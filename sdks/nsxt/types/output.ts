// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlgorithmTypeNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface ComputeManagerCredential {
    /**
     * A login credential specifying saml token
     */
    samlLogin?: outputs.ComputeManagerCredentialSamlLogin;
    /**
     * A login credential specifying session_id
     */
    sessionLogin?: outputs.ComputeManagerCredentialSessionLogin;
    /**
     * A login credential specifying a username and password
     */
    usernamePasswordLogin?: outputs.ComputeManagerCredentialUsernamePasswordLogin;
    /**
     * A verifiable asymmetric login credential
     */
    verifiableAsymmetricLogin?: outputs.ComputeManagerCredentialVerifiableAsymmetricLogin;
}

export interface ComputeManagerCredentialSamlLogin {
    /**
     * Thumbprint of the server
     */
    thumbprint: string;
    /**
     * The saml token to login to server
     */
    token: string;
}

export interface ComputeManagerCredentialSessionLogin {
    /**
     * The session_id to login to server
     */
    sessionId: string;
    /**
     * Thumbprint of the login server
     */
    thumbprint: string;
}

export interface ComputeManagerCredentialUsernamePasswordLogin {
    /**
     * The authentication password for login
     */
    password: string;
    /**
     * Thumbprint of the login server
     */
    thumbprint: string;
    /**
     * The username for login
     */
    username: string;
}

export interface ComputeManagerCredentialVerifiableAsymmetricLogin {
    /**
     * Asymmetric login credential
     */
    asymmetricCredential: string;
    /**
     * Credential key
     */
    credentialKey: string;
    /**
     * Credential verifier
     */
    credentialVerifier: string;
}

export interface ComputeManagerExtensionCertificate {
    /**
     * PEM encoded certificate data
     */
    pemEncoded: string;
    /**
     * Private key of certificate
     */
    privateKey: string;
}

export interface ComputeManagerTag {
    scope?: string;
    tag?: string;
}

export interface DhcpRelayProfileTag {
    scope?: string;
    tag?: string;
}

export interface DhcpRelayServiceTag {
    scope?: string;
    tag?: string;
}

export interface DhcpServerIpPoolDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface DhcpServerIpPoolDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface DhcpServerIpPoolIpRange {
    end: string;
    start: string;
}

export interface DhcpServerIpPoolTag {
    scope?: string;
    tag?: string;
}

export interface DhcpServerProfileTag {
    scope?: string;
    tag?: string;
}

export interface EdgeClusterMember {
    /**
     * Description of this resource
     */
    description?: string;
    /**
     * The display name of this resource. Defaults to ID if not set
     */
    displayName: string;
    /**
     * System generated index for cluster member
     */
    memberIndex: number;
    /**
     * UUID of edge transport node
     */
    transportNodeId: string;
}

export interface EdgeClusterNodeRtepIp {
    memberIndex: number;
    rtepIps: string[];
    transportNodeId: string;
}

export interface EdgeClusterTag {
    scope?: string;
    tag?: string;
}

export interface EdgeHighAvailabilityProfileTag {
    scope?: string;
    tag?: string;
}

export interface EdgeTransportNodeDeploymentConfig {
    formFactor?: string;
    /**
     * Node user settings
     */
    nodeUserSettings: outputs.EdgeTransportNodeDeploymentConfigNodeUserSettings;
    /**
     * The vSphere deployment configuration determines where to deploy the edge node
     */
    vmDeploymentConfig: outputs.EdgeTransportNodeDeploymentConfigVmDeploymentConfig;
}

export interface EdgeTransportNodeDeploymentConfigNodeUserSettings {
    /**
     * Node audit user password
     */
    auditPassword?: string;
    /**
     * CLI "audit" username
     */
    auditUsername?: string;
    /**
     * Node cli password
     */
    cliPassword: string;
    /**
     * CLI "admin" username
     */
    cliUsername?: string;
    /**
     * Node root user password
     */
    rootPassword: string;
}

export interface EdgeTransportNodeDeploymentConfigVmDeploymentConfig {
    /**
     * Compute folder identifier in the specified vcenter server
     */
    computeFolderId?: string;
    /**
     * Cluster identifier or resourcepool identifier for specified vcenter server
     */
    computeId: string;
    /**
     * List of portgroups, logical switch identifiers or segment paths for datapath connectivity
     */
    dataNetworkIds: string[];
    /**
     * Default gateway for the node
     */
    defaultGatewayAddresses: string[];
    /**
     * Host identifier in the specified vcenter server
     */
    hostId?: string;
    /**
     * Portgroup, logical switch identifier or segment path for management network connectivity
     */
    managementNetworkId: string;
    /**
     * Port subnets for management port. IPv4, IPv6 and Dual Stack Address is supported
     */
    managementPortSubnets?: outputs.EdgeTransportNodeDeploymentConfigVmDeploymentConfigManagementPortSubnet[];
    /**
     * Resource reservation settings
     */
    reservationInfo?: outputs.EdgeTransportNodeDeploymentConfigVmDeploymentConfigReservationInfo;
    /**
     * Storage/datastore identifier in the specified vcenter server
     */
    storageId: string;
    /**
     * Vsphere compute identifier for identifying the vcenter server
     */
    vcId: string;
}

export interface EdgeTransportNodeDeploymentConfigVmDeploymentConfigManagementPortSubnet {
    /**
     * IP Addresses
     */
    ipAddresses: string[];
    /**
     * Subnet Prefix Length
     */
    prefixLength: number;
}

export interface EdgeTransportNodeDeploymentConfigVmDeploymentConfigReservationInfo {
    /**
     * CPU reservation in MHz
     */
    cpuReservationInMhz?: number;
    /**
     * CPU reservation in shares
     */
    cpuReservationInShares?: string;
    /**
     * Memory reservation percentage
     */
    memoryReservationPercentage?: number;
}

export interface EdgeTransportNodeNodeSettings {
    /**
     * Advanced configuration
     */
    advancedConfigurations?: outputs.EdgeTransportNodeNodeSettingsAdvancedConfiguration[];
    /**
     * Allow root SSH logins
     */
    allowSshRootLogin?: boolean;
    /**
     * DNS servers
     */
    dnsServers?: string[];
    /**
     * Enable SSH
     */
    enableSsh?: boolean;
    /**
     * Enable Uniform Passthrough mode
     */
    enableUptMode?: boolean;
    /**
     * Host name or FQDN for edge node
     */
    hostname: string;
    /**
     * NTP servers
     */
    ntpServers?: string[];
    /**
     * Search domain names
     */
    searchDomains?: string[];
    /**
     * Syslog servers
     */
    syslogServers?: outputs.EdgeTransportNodeNodeSettingsSyslogServer[];
}

export interface EdgeTransportNodeNodeSettingsAdvancedConfiguration {
    key: string;
    value: string;
}

export interface EdgeTransportNodeNodeSettingsSyslogServer {
    /**
     * Log level to be redirected
     */
    logLevel?: string;
    /**
     * Syslog server port
     */
    port?: string;
    /**
     * Syslog protocol
     */
    protocol?: string;
    /**
     * Server IP or fqdn
     */
    server: string;
}

export interface EdgeTransportNodeRtepIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.EdgeTransportNodeRtepIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface EdgeTransportNodeRtepIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface EdgeTransportNodeStandardHostSwitch {
    /**
     * The host switch id. This ID will be used to reference a host switch
     */
    hostSwitchId: string;
    /**
     * Host switch name. This name will be used to reference a host switch
     */
    hostSwitchName: string;
    /**
     * Identifiers of host switch profiles to be associated with this host switch
     */
    hostSwitchProfiles?: string[];
    /**
     * Specification for IPs to be used with host switch virtual tunnel endpoints
     */
    ipAssignment: outputs.EdgeTransportNodeStandardHostSwitchIpAssignment;
    /**
     * Physical NICs connected to the host switch
     */
    pnics?: outputs.EdgeTransportNodeStandardHostSwitchPnic[];
    /**
     * Transport zone endpoints
     */
    transportZoneEndpoints?: outputs.EdgeTransportNodeStandardHostSwitchTransportZoneEndpoint[];
}

export interface EdgeTransportNodeStandardHostSwitchIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.EdgeTransportNodeStandardHostSwitchIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface EdgeTransportNodeStandardHostSwitchIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface EdgeTransportNodeStandardHostSwitchPnic {
    /**
     * Device name or key
     */
    deviceName: string;
    /**
     * Uplink name for this Pnic
     */
    uplinkName: string;
}

export interface EdgeTransportNodeStandardHostSwitchTransportZoneEndpoint {
    /**
     * Unique ID identifying the transport zone for this endpoint
     */
    transportZone: string;
    /**
     * Identifiers of the transport zone profiles associated with this transport zone endpoint on this transport node
     */
    transportZoneProfiles: string[];
}

export interface EdgeTransportNodeTag {
    scope?: string;
    tag?: string;
}

export interface EtherTypeNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface FailureDomainTag {
    scope?: string;
    tag?: string;
}

export interface FirewallSectionAppliedTo {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface FirewallSectionRule {
    /**
     * Action enforced on the packets which matches the firewall rule
     */
    action: string;
    /**
     * List of objects where rule will be enforced. The section level field overrides this one. Null will be treated as any
     */
    appliedTos?: outputs.FirewallSectionRuleAppliedTo[];
    /**
     * Description of this resource
     */
    description?: string;
    /**
     * List of the destinations. Null will be treated as any
     */
    destinations?: outputs.FirewallSectionRuleDestination[];
    /**
     * When this boolean flag is set to true, the rule destinations will be negated
     */
    destinationsExcluded?: boolean;
    /**
     * Rule direction in case of stateless firewall rules. This will only be considered if section level parameter is set to stateless. Default to IN_OUT if not specified
     */
    direction?: string;
    /**
     * Flag to disable rule. Disabled will only be persisted but never provisioned/realized
     */
    disabled?: boolean;
    /**
     * Defaults to ID if not set
     */
    displayName?: string;
    /**
     * ID of this resource
     */
    id: string;
    /**
     * Type of IP packet that should be matched while enforcing the rule (IPV4, IPV6, IPV4_IPV6)
     */
    ipProtocol?: string;
    /**
     * Flag to enable packet logging. Default is disabled
     */
    logged?: boolean;
    /**
     * User notes specific to the rule
     */
    notes?: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * User level field which will be printed in CLI and packet logs
     */
    ruleTag?: string;
    /**
     * List of the services. Null will be treated as any
     */
    services?: outputs.FirewallSectionRuleService[];
    /**
     * List of sources. Null will be treated as any
     */
    sources?: outputs.FirewallSectionRuleSource[];
    /**
     * When this boolean flag is set to true, the rule sources will be negated
     */
    sourcesExcluded?: boolean;
}

export interface FirewallSectionRuleAppliedTo {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface FirewallSectionRuleDestination {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface FirewallSectionRuleService {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface FirewallSectionRuleSource {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface FirewallSectionTag {
    scope?: string;
    tag?: string;
}

export interface GetPolicyContextProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyDhcpServerContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyDistributedFloodProtectionProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayDnsForwarderContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayFloodProtectionProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayInterfaceRealizationContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayLocaleServiceContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGatewayQosProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyGroupContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIntrusionServiceProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIpBlockContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIpDiscoveryProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIpPoolContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIpv6DadProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyIpv6NdraProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyMacDiscoveryProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyProjectSiteInfo {
    edgeClusterPaths?: string[];
    sitePath?: string;
}

export interface GetPolicyQosProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyRealizationInfoContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicySecurityPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicySegmentContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicySegmentRealizationContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicySegmentSecurityProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyServiceContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicySpoofguardProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyTier1GatewayContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyVmContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetPolicyVmsContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface GetUpgradePostcheckFailedGroup {
    details: string;
    failureCount: number;
    id: string;
    status: string;
}

export interface IcmpTypeNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface IgmpTypeNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface IpBlockSubnetAllocationRange {
    end: string;
    start: string;
}

export interface IpBlockSubnetTag {
    scope?: string;
    tag?: string;
}

export interface IpBlockTag {
    scope?: string;
    tag?: string;
}

export interface IpDiscoverySwitchingProfileTag {
    scope?: string;
    tag?: string;
}

export interface IpPoolSubnet {
    /**
     * A collection of IPv4 Pool Ranges
     */
    allocationRanges: string[];
    /**
     * Network address and the prefix length which will be associated with a layer-2 broadcast domain
     */
    cidr: string;
    /**
     * A collection of DNS servers for the subnet
     */
    dnsNameservers?: string[];
    /**
     * The DNS suffix for the DNS server
     */
    dnsSuffix?: string;
    /**
     * The default gateway address on a layer-3 router
     */
    gatewayIp?: string;
}

export interface IpPoolTag {
    scope?: string;
    tag?: string;
}

export interface IpProtocolNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface IpSetTag {
    scope?: string;
    tag?: string;
}

export interface L4PortSetNsServiceTag {
    scope?: string;
    tag?: string;
}

export interface LbClientSslProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbCookiePersistenceProfileInsertModeParams {
    /**
     * HTTP cookie domain
     */
    cookieDomain?: string;
    /**
     * Type of cookie expiration timing
     */
    cookieExpiryType?: string;
    /**
     * HTTP cookie path
     */
    cookiePath?: string;
    /**
     * Maximum interval (in seconds) the cookie is valid for from the last time it was seen in a request (required if cookie_expiry_type is set)
     */
    maxIdleTime: number;
    /**
     * Maximum interval (in seconds) the cookie is valid for from the first time the cookie was seen in a request (required if cookie_expiry_type is SESSION_COOKIE_TIME expiration)
     */
    maxLifeTime: number;
}

export interface LbCookiePersistenceProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbFastTcpApplicationProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbFastUdpApplicationProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpApplicationProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpForwardingRuleBodyCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    value: string;
}

export interface LbHttpForwardingRuleCookieCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpForwardingRuleHeaderCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpForwardingRuleHttpRedirectAction {
    redirectStatus: string;
    redirectUrl: string;
}

export interface LbHttpForwardingRuleHttpRejectAction {
    replyMessage: string;
    replyStatus: string;
}

export interface LbHttpForwardingRuleIpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourceAddress: string;
}

export interface LbHttpForwardingRuleMethodCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    method: string;
}

export interface LbHttpForwardingRuleSelectPoolAction {
    poolId: string;
}

export interface LbHttpForwardingRuleTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpForwardingRuleTcpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourcePort: string;
}

export interface LbHttpForwardingRuleUriCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uri: string;
}

export interface LbHttpForwardingRuleVersionCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    version: string;
}

export interface LbHttpMonitorRequestHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface LbHttpMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpRequestRewriteRuleBodyCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    value: string;
}

export interface LbHttpRequestRewriteRuleCookieCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpRequestRewriteRuleHeaderCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpRequestRewriteRuleHeaderRewriteAction {
    name: string;
    value?: string;
}

export interface LbHttpRequestRewriteRuleIpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourceAddress: string;
}

export interface LbHttpRequestRewriteRuleMethodCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    method: string;
}

export interface LbHttpRequestRewriteRuleTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpRequestRewriteRuleTcpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourcePort: string;
}

export interface LbHttpRequestRewriteRuleUriArgumentsCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uriArguments: string;
}

export interface LbHttpRequestRewriteRuleUriCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uri: string;
}

export interface LbHttpRequestRewriteRuleUriRewriteAction {
    uri: string;
    uriArguments?: string;
}

export interface LbHttpRequestRewriteRuleVersionCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    version: string;
}

export interface LbHttpResponseRewriteRuleCookieCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpResponseRewriteRuleHeaderRewriteAction {
    name: string;
    value?: string;
}

export interface LbHttpResponseRewriteRuleIpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourceAddress: string;
}

export interface LbHttpResponseRewriteRuleMethodCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    method: string;
}

export interface LbHttpResponseRewriteRuleRequestHeaderCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpResponseRewriteRuleResponseHeaderCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    name: string;
    value: string;
}

export interface LbHttpResponseRewriteRuleTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpResponseRewriteRuleTcpCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourcePort: string;
}

export interface LbHttpResponseRewriteRuleUriArgumentsCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uriArguments: string;
}

export interface LbHttpResponseRewriteRuleUriCondition {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uri: string;
}

export interface LbHttpResponseRewriteRuleVersionCondition {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    version: string;
}

export interface LbHttpVirtualServerClientSsl {
    /**
     * List of CA ids for client authentication
     */
    caIds?: string[];
    /**
     * Verification depth in the server certificate chain
     */
    certificateChainDepth?: number;
    /**
     * Whether client certificate authentication is mandatory
     */
    clientAuth?: boolean;
    /**
     * Id of client SSL profile that defines reusable properties
     */
    clientSslProfileId: string;
    /**
     * List of CRL ids for client authentication
     */
    crlIds?: string[];
    /**
     * Id of certificate that will be used if the server does not host multiple hostnames on the same IP address or if the client does not support SNI extension
     */
    defaultCertificateId: string;
    /**
     * List of certificates to serve different hostnames
     */
    sniCertificateIds?: string[];
}

export interface LbHttpVirtualServerServerSsl {
    /**
     * List of CA ids for server authentication
     */
    caIds?: string[];
    /**
     * Verification depth in the server certificate chain
     */
    certificateChainDepth?: number;
    /**
     * Id of certificate that will be used if the server does not host multiple hostnames on the same IP address or if the client does not support SNI extension
     */
    clientCertificateId?: string;
    /**
     * List of CRL ids for server authentication
     */
    crlIds?: string[];
    /**
     * Server authentication mode
     */
    serverAuth?: boolean;
    /**
     * Id of server SSL profile that defines reusable properties
     */
    serverSslProfileId: string;
}

export interface LbHttpVirtualServerTag {
    scope?: string;
    tag?: string;
}

export interface LbHttpsMonitorRequestHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface LbHttpsMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbIcmpMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbPassiveMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbPoolMember {
    /**
     * Member admin state
     */
    adminState?: string;
    /**
     * A boolean flag which reflects whether this is a backup pool member
     */
    backupMember?: boolean;
    /**
     * Pool member name
     */
    displayName: string;
    /**
     * Pool member IP address
     */
    ipAddress: string;
    /**
     * To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
     */
    maxConcurrentConnections?: number;
    /**
     * If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
     */
    port?: string;
    /**
     * Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
     */
    weight?: number;
}

export interface LbPoolMemberGroup {
    /**
     * Load balancer pool support grouping object as dynamic pool members. The IP list of the grouping object such as NSGroup would be used as pool member IP setting
     */
    groupingObject: outputs.LbPoolMemberGroupGroupingObject;
    /**
     * Ip revision filter is used to filter IPv4 or IPv6 addresses from the grouping object. If the filter is not specified, both IPv4 and IPv6 addresses would be used as server IPs
     */
    ipVersionFilter?: string;
    /**
     * Specifies whether to limit pool members. If false, dynamic pool can grow up to the load balancer max pool member capacity.
     */
    limitIpListSize?: boolean;
    /**
     * Limits the max number of pool members to the specified value if limit_ip_list_size is set to true, ignored otherwise.
     */
    maxIpListSize?: number;
    /**
     * If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
     */
    port?: number;
}

export interface LbPoolMemberGroupGroupingObject {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface LbPoolSnatTranslation {
    /**
     * Ip address or Ip range for SNAT of type SNAT_IP_POOL
     */
    ip?: string;
    /**
     * Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
     */
    type?: string;
}

export interface LbPoolTag {
    scope?: string;
    tag?: string;
}

export interface LbServerSslProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbServiceTag {
    scope?: string;
    tag?: string;
}

export interface LbSourceIpPersistenceProfileTag {
    scope?: string;
    tag?: string;
}

export interface LbTcpMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbTcpVirtualServerTag {
    scope?: string;
    tag?: string;
}

export interface LbUdpMonitorTag {
    scope?: string;
    tag?: string;
}

export interface LbUdpVirtualServerTag {
    scope?: string;
    tag?: string;
}

export interface LogicalDhcpPortTag {
    scope?: string;
    tag?: string;
}

export interface LogicalDhcpServerDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface LogicalDhcpServerDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface LogicalDhcpServerTag {
    scope?: string;
    tag?: string;
}

export interface LogicalPortSwitchingProfileId {
    /**
     * The resource type of this profile
     */
    key: string;
    /**
     * The ID of this profile
     */
    value: string;
}

export interface LogicalPortTag {
    scope?: string;
    tag?: string;
}

export interface LogicalRouterCentralizedServicePortTag {
    scope?: string;
    tag?: string;
}

export interface LogicalRouterDownlinkPortServiceBinding {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface LogicalRouterDownlinkPortTag {
    scope?: string;
    tag?: string;
}

export interface LogicalRouterLinkPortOnTier0Tag {
    scope?: string;
    tag?: string;
}

export interface LogicalRouterLinkPortOnTier1Tag {
    scope?: string;
    tag?: string;
}

export interface LogicalSwitchAddressBinding {
    /**
     * A single IP address or a subnet cidr
     */
    ipAddress?: string;
    /**
     * A single MAC address
     */
    macAddress?: string;
    /**
     * A single vlan tag value
     */
    vlan?: number;
}

export interface LogicalSwitchSwitchingProfileId {
    /**
     * The resource type of this profile
     */
    key: string;
    /**
     * The ID of this profile
     */
    value: string;
}

export interface LogicalSwitchTag {
    scope?: string;
    tag?: string;
}

export interface LogicalTier0RouterFirewallSection {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface LogicalTier0RouterTag {
    scope?: string;
    tag?: string;
}

export interface LogicalTier1RouterFirewallSection {
    /**
     * A boolean flag which will be set to false if the referenced NSX resource has been deleted
     */
    isValid: boolean;
    /**
     * Display name of the NSX resource
     */
    targetDisplayName: string;
    /**
     * Identifier of the NSX resource
     */
    targetId?: string;
    /**
     * Type of the NSX resource
     */
    targetType?: string;
}

export interface LogicalTier1RouterTag {
    scope?: string;
    tag?: string;
}

export interface MacManagementSwitchingProfileMacLearning {
    /**
     * Allowing source MAC address learning
     */
    enabled?: boolean;
    /**
     * The maximum number of MAC addresses that can be learned on this port
     */
    limit?: number;
    /**
     * The policy after MAC Limit is exceeded
     */
    limitPolicy?: string;
    /**
     * Allowing flooding for unlearned MAC for ingress traffic
     */
    unicastFloodingAllowed?: boolean;
}

export interface MacManagementSwitchingProfileTag {
    scope?: string;
    tag?: string;
}

export interface ManagerClusterApiProbing {
    /**
     * Initial delay in seconds before probing connection
     */
    delay?: number;
    /**
     * Whether API probing for NSX nodes is enabled
     */
    enabled?: boolean;
    /**
     * Connection probing interval in seconds
     */
    interval?: number;
    /**
     * Timeout for connection probing in seconds
     */
    timeout?: number;
}

export interface ManagerClusterNode {
    /**
     * FQDN for the cluster node
     */
    fqdn: string;
    /**
     * ID of the cluster node
     */
    id: string;
    /**
     * IP address of the cluster node that will join the cluster
     */
    ipAddress: string;
    /**
     * The password for login
     */
    password: string;
    /**
     * Status of the cluster node
     */
    status: string;
    /**
     * The username for login
     */
    username: string;
}

export interface NatRuleTag {
    scope?: string;
    tag?: string;
}

export interface NsGroupMember {
    /**
     * Type of the resource on which this expression is evaluated
     */
    targetType: string;
    /**
     * Value that satisfies this expression
     */
    value: string;
}

export interface NsGroupMembershipCriteria {
    scope?: string;
    scopeOp?: string;
    tag?: string;
    tagOp?: string;
    targetType: string;
}

export interface NsGroupTag {
    scope?: string;
    tag?: string;
}

export interface NsServiceGroupTag {
    scope?: string;
    tag?: string;
}

export interface PolicyBgpConfigRouteAggregation {
    /**
     * CIDR of aggregate address
     */
    prefix?: string;
    /**
     * Send only summarized route
     */
    summaryOnly?: boolean;
}

export interface PolicyBgpConfigTag {
    scope?: string;
    tag?: string;
}

export interface PolicyBgpNeighborBfdConfig {
    /**
     * Flag to enable/disable BFD configuration
     */
    enabled?: boolean;
    /**
     * Time interval between heartbeat packets in milliseconds
     */
    interval?: number;
    /**
     * Number of times heartbeat packet is missed before BFD declares the neighbor is down
     */
    multiple?: number;
}

export interface PolicyBgpNeighborRouteFiltering {
    /**
     * Address family type
     */
    addressFamily: string;
    /**
     * Flag to enable/disable address family
     */
    enabled?: boolean;
    /**
     * Prefix-list or route map path for IN direction
     */
    inRouteFilter?: string;
    /**
     * Maximum number of routes for the address family
     */
    maximumRoutes?: number;
    /**
     * Prefix-list or route map path for OUT direction
     */
    outRouteFilter?: string;
}

export interface PolicyBgpNeighborTag {
    scope?: string;
    tag?: string;
}

export interface PolicyComputeSubClusterTag {
    scope?: string;
    tag?: string;
}

export interface PolicyContextProfileAppId {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Whether the app_id value is ALG type or not
     */
    isAlgType: boolean;
    subAttribute?: outputs.PolicyContextProfileAppIdSubAttribute;
    /**
     * Values for attribute key
     */
    values: string[];
}

export interface PolicyContextProfileAppIdSubAttribute {
    /**
     * Values for sub attribute key cifs_smb_version
     */
    cifsSmbVersions?: string[];
    /**
     * Values for sub attribute key tls_cipher_suite
     */
    tlsCipherSuites?: string[];
    /**
     * Values for sub attribute key tls_version
     */
    tlsVersions?: string[];
}

export interface PolicyContextProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyContextProfileCustomAttributeContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyContextProfileCustomUrl {
    /**
     * True value for this flag will be treated as a partial match for custom url
     */
    customUrlPartialMatch?: boolean;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Values for attribute key
     */
    values: string[];
}

export interface PolicyContextProfileDomainName {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Values for attribute key
     */
    values: string[];
}

export interface PolicyContextProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyContextProfileUrlCategory {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Values for attribute key
     */
    values: string[];
}

export interface PolicyDhcpRelayContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDhcpRelayTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDhcpServerContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDhcpServerTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDhcpV4StaticBindingContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDhcpV4StaticBindingDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface PolicyDhcpV4StaticBindingDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface PolicyDhcpV4StaticBindingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDhcpV6StaticBindingContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDhcpV6StaticBindingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDistributedFloodProtectionProfileBindingContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDistributedFloodProtectionProfileBindingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDistributedFloodProtectionProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDistributedFloodProtectionProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDnsForwarderZoneContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyDnsForwarderZoneTag {
    scope?: string;
    tag?: string;
}

export interface PolicyDomainTag {
    scope?: string;
    tag?: string;
}

export interface PolicyEvpnConfigTag {
    scope?: string;
    tag?: string;
}

export interface PolicyEvpnTenantMapping {
    /**
     * Values for attribute key
     */
    vlans: string;
    /**
     * Values for attribute key
     */
    vnis: string;
}

export interface PolicyEvpnTenantTag {
    scope?: string;
    tag?: string;
}

export interface PolicyEvpnTunnelEndpointTag {
    scope?: string;
    tag?: string;
}

export interface PolicyFixedSegmentAdvancedConfig {
    /**
     * Policy path to IP address pool
     */
    addressPoolPath?: string;
    /**
     * Connectivity configuration to manually connect (ON) or disconnect (OFF)
     */
    connectivity?: string;
    /**
     * Flag to identify a hybrid logical switch
     */
    hybrid?: boolean;
    /**
     * Flag to enable local egress
     */
    localEgress?: boolean;
    /**
     * The name of the switching uplink teaming policy for the bridge endpoint
     */
    uplinkTeamingPolicy?: string;
    /**
     * This URPF mode is applied to the downlink logical router port created while attaching this segment to gateway
     */
    urpfMode?: string;
}

export interface PolicyFixedSegmentBridgeConfig {
    /**
     * profile path
     */
    profilePath: string;
    /**
     * vlan transport zone path
     */
    transportZonePath: string;
    uplinkTeamingPolicy?: string;
    /**
     * VLAN specification for bridge endpoint
     */
    vlanIds: string[];
}

export interface PolicyFixedSegmentContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyFixedSegmentL2Extension {
    /**
     * Policy paths of associated L2 VPN sessions
     */
    l2vpnPaths?: string[];
    /**
     * Tunnel ID
     */
    tunnelId?: number;
}

export interface PolicyFixedSegmentSubnet {
    /**
     * Gateway IP address in CIDR format
     */
    cidr?: string;
    /**
     * DHCP address ranges for dynamic IP allocation
     */
    dhcpRanges?: string[];
    dhcpV4Config?: outputs.PolicyFixedSegmentSubnetDhcpV4Config;
    dhcpV6Config?: outputs.PolicyFixedSegmentSubnetDhcpV6Config;
    /**
     * Network CIDR for subnet
     */
    network: string;
}

export interface PolicyFixedSegmentSubnetDhcpV4Config {
    /**
     * Generic DHCP options
     */
    dhcpGenericOptions?: outputs.PolicyFixedSegmentSubnetDhcpV4ConfigDhcpGenericOption[];
    /**
     * DHCP classless static routes
     */
    dhcpOption121s?: outputs.PolicyFixedSegmentSubnetDhcpV4ConfigDhcpOption121[];
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
}

export interface PolicyFixedSegmentSubnetDhcpV4ConfigDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface PolicyFixedSegmentSubnetDhcpV4ConfigDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface PolicyFixedSegmentSubnetDhcpV6Config {
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * Domain names
     */
    domainNames?: string[];
    /**
     * Excluded addresses to define dynamic ip allocation ranges
     */
    excludedRanges?: outputs.PolicyFixedSegmentSubnetDhcpV6ConfigExcludedRange[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * The time interval in seconds, in which the prefix is advertised as preferred
     */
    preferredTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
    /**
     * IPv6 address of SNTP servers for subnet
     */
    sntpServers?: string[];
}

export interface PolicyFixedSegmentSubnetDhcpV6ConfigExcludedRange {
    /**
     * The end IP Address for the range
     */
    end: string;
    /**
     * The start IP Address for the range
     */
    start: string;
}

export interface PolicyFixedSegmentTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayCommunityListTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayDnsForwarderContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyGatewayDnsForwarderTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayFloodProtectionProfileBindingContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyGatewayFloodProtectionProfileBindingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayFloodProtectionProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyGatewayFloodProtectionProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyGatewayPolicyRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * List of destination groups
     */
    destinationGroups?: string[];
    /**
     * Negation of destination groups
     */
    destinationsExcluded?: boolean;
    /**
     * Traffic direction
     */
    direction?: string;
    /**
     * Flag to disable the rule
     */
    disabled?: boolean;
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * IP version
     */
    ipVersion?: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * Text for additional notes on changes
     */
    notes?: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * List of profiles
     */
    profiles?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Unique positive number that is assigned by the system and is useful for debugging
     */
    ruleId: number;
    /**
     * List of policy paths where the rule is applied
     */
    scopes: string[];
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * List of services to match
     */
    services?: string[];
    /**
     * List of source groups
     */
    sourceGroups?: string[];
    /**
     * Negation of source groups
     */
    sourcesExcluded?: boolean;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyGatewayPolicyRuleTag[];
}

export interface PolicyGatewayPolicyRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayPolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayPrefixListPrefix {
    /**
     * Action for the prefix list
     */
    action?: string;
    /**
     * Prefix length greater than or equal to
     */
    ge?: number;
    /**
     * Prefix length less than or equal to
     */
    le?: number;
    /**
     * Network prefix in CIDR format. If not set it will match ANY network
     */
    network?: string;
}

export interface PolicyGatewayPrefixListTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayQosProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGatewayRedistributionConfigRule {
    /**
     * BGP destination for this rule
     */
    bgp?: boolean;
    /**
     * Rule name
     */
    name?: string;
    /**
     * OSPF destination for this rule
     */
    ospf?: boolean;
    /**
     * Route map to be associated with the redistribution rule
     */
    routeMapPath?: string;
    /**
     * List of redistribution types
     */
    types?: string[];
}

export interface PolicyGatewayRouteMapEntry {
    /**
     * Action for the route map entry
     */
    action?: string;
    /**
     * Prefix list match criteria for route map
     */
    communityListMatches?: outputs.PolicyGatewayRouteMapEntryCommunityListMatch[];
    /**
     * List of paths for prefix lists for route map
     */
    prefixListMatches?: string[];
    /**
     * Set criteria for route map entry
     */
    set?: outputs.PolicyGatewayRouteMapEntrySet;
}

export interface PolicyGatewayRouteMapEntryCommunityListMatch {
    /**
     * Community list path or a regular expression
     */
    criteria: string;
    /**
     * Match operator for community list entries
     */
    matchOperator: string;
}

export interface PolicyGatewayRouteMapEntrySet {
    /**
     * Autonomous System (AS) path prepend to influence route selection
     */
    asPathPrepend?: string;
    /**
     * Set BGP regular or large community for matching routes
     */
    community?: string;
    /**
     * Local preference indicates the degree of preference for one BGP route over other BGP routes
     */
    localPreference: number;
    /**
     * A lower Multi exit descriminator (MED) is preferred over a higher value
     */
    med: number;
    /**
     * Indicator whether to prefer global address over link-local as the next hop
     */
    preferGlobalV6NextHop?: boolean;
    /**
     * Weight is used to select a route when multiple routes are available to the same network
     */
    weight?: number;
}

export interface PolicyGatewayRouteMapTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGlobalManagerConnectionInfo {
    /**
     * Fully Qualified Domain Name of the Management Node
     */
    fqdn?: string;
    /**
     * Password
     */
    password?: string;
    /**
     * id of Site
     */
    siteUuid?: string;
    /**
     * Thumbprint of Enforcement Point
     */
    thumbprint?: string;
    /**
     * Username
     */
    username?: string;
}

export interface PolicyGlobalManagerTag {
    scope?: string;
    tag?: string;
}

export interface PolicyGroupConjunction {
    /**
     * The conjunction operator; either OR or AND
     */
    operator: string;
}

export interface PolicyGroupContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyGroupCriteria {
    /**
     * A Condition querying resources for membership in the Group
     */
    conditions?: outputs.PolicyGroupCriteriaCondition[];
    /**
     * External ID expression specifying additional members in the Group
     */
    externalIdExpressions?: outputs.PolicyGroupCriteriaExternalIdExpression[];
    /**
     * An IP Address expression specifying IP Address members in the Group
     */
    ipaddressExpression?: outputs.PolicyGroupCriteriaIpaddressExpression;
    /**
     * MAC address expression specifying MAC Address members in the Group
     */
    macaddressExpression?: outputs.PolicyGroupCriteriaMacaddressExpression;
    /**
     * A list of object paths for members in the group
     */
    pathExpression?: outputs.PolicyGroupCriteriaPathExpression;
}

export interface PolicyGroupCriteriaCondition {
    /**
     * The resource key attribute to apply the condition to.
     */
    key: string;
    /**
     * The NSX member to apply the condition to. Can be one of; IPSet, LogicalPort, LogicalSwitch, Segment, SegmentPort or VirtualMachine
     */
    memberType: string;
    /**
     * The operator to use for the condition. Can be one of; CONTAINS, ENDSWITH, EQUALS, NOTEQUALS or STARTSWITH
     */
    operator: string;
    /**
     * The value to check for in the condition
     */
    value: string;
}

export interface PolicyGroupCriteriaExternalIdExpression {
    /**
     * List of external IDs
     */
    externalIds: string[];
    /**
     * External ID member type, default to virtual machine if not specified
     */
    memberType?: string;
}

export interface PolicyGroupCriteriaIpaddressExpression {
    /**
     * List of single IP addresses, IP address ranges or Subnets. Cannot mix IPv4 and IPv6 in a single list
     */
    ipAddresses: string[];
}

export interface PolicyGroupCriteriaMacaddressExpression {
    /**
     * List of Mac Addresses
     */
    macAddresses: string[];
}

export interface PolicyGroupCriteriaPathExpression {
    /**
     * List of policy paths of direct group members
     */
    memberPaths: string[];
}

export interface PolicyGroupExtendedCriteria {
    /**
     * Identity Group expression
     */
    identityGroups?: outputs.PolicyGroupExtendedCriteriaIdentityGroup[];
}

export interface PolicyGroupExtendedCriteriaIdentityGroup {
    /**
     * LDAP distinguished name
     */
    distinguishedName?: string;
    /**
     * Identity (Directory) domain base distinguished name
     */
    domainBaseDistinguishedName?: string;
    /**
     * Identity (Directory) Group SID (security identifier)
     */
    sid?: string;
}

export interface PolicyGroupTag {
    scope?: string;
    tag?: string;
}

export interface PolicyHostTransportNodeCollectionSubClusterConfig {
    /**
     * List of overridden HostSwitch configuration
     */
    hostSwitchConfigSources: outputs.PolicyHostTransportNodeCollectionSubClusterConfigHostSwitchConfigSource[];
    /**
     * sub-cluster Id
     */
    subClusterId: string;
}

export interface PolicyHostTransportNodeCollectionSubClusterConfigHostSwitchConfigSource {
    /**
     * HostSwitch Id
     */
    hostSwitchId: string;
    /**
     * Name of the TransportNodeProfile sub configuration to be used
     */
    transportNodeProfileSubConfigName: string;
}

export interface PolicyHostTransportNodeCollectionTag {
    scope?: string;
    tag?: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitch {
    /**
     * Enhanced Networking Stack enabled HostSwitch CPU configuration
     */
    cpuConfigs?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchCpuConfig[];
    /**
     * The host switch id. This ID will be used to reference a host switch
     */
    hostSwitchId: string;
    /**
     * Operational mode of a HostSwitch
     */
    hostSwitchMode?: string;
    /**
     * Host switch name. This name will be used to reference a host switch
     */
    hostSwitchName: string;
    /**
     * Identifiers of host switch profiles to be associated with this host switch
     */
    hostSwitchProfiles?: string[];
    /**
     * Specification for IPs to be used with host switch virtual tunnel endpoints
     */
    ipAssignment: outputs.PolicyHostTransportNodeProfileStandardHostSwitchIpAssignment;
    /**
     * Migrate any pnics which are in use
     */
    isMigratePnics?: boolean;
    /**
     * Physical NICs connected to the host switch
     */
    pnics?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchPnic[];
    /**
     * Transport Node Profile sub-configuration Options
     */
    transportNodeProfileSubConfigs?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfig[];
    /**
     * Transport zone endpoints
     */
    transportZoneEndpoints?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportZoneEndpoint[];
    /**
     * Uplink/LAG of VMware vSphere Distributed Switch connected to the HostSwitch
     */
    uplinks?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchUplink[];
    /**
     * The vmknic and logical switch mappings
     */
    vmkInstallMigrations?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchVmkInstallMigration[];
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchCpuConfig {
    /**
     * Number of Logical cpu cores (Lcores) to be placed on a specified NUMA node
     */
    numLcores: number;
    /**
     * Unique index of the Non Uniform Memory Access (NUMA) node
     */
    numaNodeIndex: number;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchPnic {
    /**
     * Device name or key
     */
    deviceName: string;
    /**
     * Uplink name for this Pnic
     */
    uplinkName: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfig {
    /**
     * Subset of the host switch configuration
     */
    hostSwitchConfigOption: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOption;
    /**
     * Name of the transport node profile config option
     */
    name: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOption {
    /**
     * The host switch id. This ID will be used to reference a host switch
     */
    hostSwitchId?: string;
    /**
     * Identifiers of host switch profiles to be associated with this host switch
     */
    hostSwitchProfiles?: string[];
    /**
     * Specification for IPs to be used with host switch virtual tunnel endpoints
     */
    ipAssignment?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignment;
    /**
     * Uplink/LAG of VMware vSphere Distributed Switch connected to the HostSwitch
     */
    uplinks?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionUplink[];
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionUplink {
    /**
     * Uplink name from UplinkHostSwitch profile
     */
    uplinkName: string;
    /**
     * Link Aggregation Group (LAG) name of Virtual Distributed Switch
     */
    vdsLagName?: string;
    /**
     * Uplink name of VMware vSphere Distributed Switch (VDS)
     */
    vdsUplinkName?: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchTransportZoneEndpoint {
    /**
     * Unique ID identifying the transport zone for this endpoint
     */
    transportZone: string;
    /**
     * Identifiers of the transport zone profiles associated with this transport zone endpoint on this transport node
     */
    transportZoneProfiles: string[];
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchUplink {
    /**
     * Uplink name from UplinkHostSwitch profile
     */
    uplinkName: string;
    /**
     * Link Aggregation Group (LAG) name of Virtual Distributed Switch
     */
    vdsLagName?: string;
    /**
     * Uplink name of VMware vSphere Distributed Switch (VDS)
     */
    vdsUplinkName?: string;
}

export interface PolicyHostTransportNodeProfileStandardHostSwitchVmkInstallMigration {
    /**
     * The network id to which the ESX vmk interface will be migrated
     */
    destinationNetwork: string;
    /**
     * ESX vmk interface name
     */
    deviceName: string;
}

export interface PolicyHostTransportNodeProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyHostTransportNodeStandardHostSwitch {
    /**
     * Enhanced Networking Stack enabled HostSwitch CPU configuration
     */
    cpuConfigs?: outputs.PolicyHostTransportNodeStandardHostSwitchCpuConfig[];
    /**
     * The host switch id. This ID will be used to reference a host switch
     */
    hostSwitchId: string;
    /**
     * Operational mode of a HostSwitch
     */
    hostSwitchMode?: string;
    /**
     * Host switch name. This name will be used to reference a host switch
     */
    hostSwitchName: string;
    /**
     * Identifiers of host switch profiles to be associated with this host switch
     */
    hostSwitchProfiles?: string[];
    /**
     * Specification for IPs to be used with host switch virtual tunnel endpoints
     */
    ipAssignment: outputs.PolicyHostTransportNodeStandardHostSwitchIpAssignment;
    /**
     * Migrate any pnics which are in use
     */
    isMigratePnics?: boolean;
    /**
     * Physical NICs connected to the host switch
     */
    pnics?: outputs.PolicyHostTransportNodeStandardHostSwitchPnic[];
    /**
     * Transport Node Profile sub-configuration Options
     */
    transportNodeProfileSubConfigs?: outputs.PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfig[];
    /**
     * Transport zone endpoints
     */
    transportZoneEndpoints?: outputs.PolicyHostTransportNodeStandardHostSwitchTransportZoneEndpoint[];
    /**
     * Uplink/LAG of VMware vSphere Distributed Switch connected to the HostSwitch
     */
    uplinks?: outputs.PolicyHostTransportNodeStandardHostSwitchUplink[];
    /**
     * The vmknic and logical switch mappings
     */
    vmkInstallMigrations?: outputs.PolicyHostTransportNodeStandardHostSwitchVmkInstallMigration[];
}

export interface PolicyHostTransportNodeStandardHostSwitchCpuConfig {
    /**
     * Number of Logical cpu cores (Lcores) to be placed on a specified NUMA node
     */
    numLcores: number;
    /**
     * Unique index of the Non Uniform Memory Access (NUMA) node
     */
    numaNodeIndex: number;
}

export interface PolicyHostTransportNodeStandardHostSwitchIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.PolicyHostTransportNodeStandardHostSwitchIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchPnic {
    /**
     * Device name or key
     */
    deviceName: string;
    /**
     * Uplink name for this Pnic
     */
    uplinkName: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfig {
    /**
     * Subset of the host switch configuration
     */
    hostSwitchConfigOption: outputs.PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOption;
    /**
     * Name of the transport node profile config option
     */
    name: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOption {
    /**
     * The host switch id. This ID will be used to reference a host switch
     */
    hostSwitchId?: string;
    /**
     * Identifiers of host switch profiles to be associated with this host switch
     */
    hostSwitchProfiles?: string[];
    /**
     * Specification for IPs to be used with host switch virtual tunnel endpoints
     */
    ipAssignment?: outputs.PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignment;
    /**
     * Uplink/LAG of VMware vSphere Distributed Switch connected to the HostSwitch
     */
    uplinks?: outputs.PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionUplink[];
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignment {
    /**
     * Enables DHCP assignment
     */
    assignedByDhcp?: boolean;
    /**
     * IP assignment specification for Static IP List.
     */
    staticIp?: outputs.PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignmentStaticIp;
    /**
     * IP assignment specification for Static IP Pool
     */
    staticIpPool?: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionIpAssignmentStaticIp {
    /**
     * Gateway IP
     */
    defaultGateway: string;
    /**
     * List of IPs for transport node host switch virtual tunnel endpoints
     */
    ipAddresses: string[];
    /**
     * Subnet mask
     */
    subnetMask: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportNodeProfileSubConfigHostSwitchConfigOptionUplink {
    /**
     * Uplink name from UplinkHostSwitch profile
     */
    uplinkName: string;
    /**
     * Link Aggregation Group (LAG) name of Virtual Distributed Switch
     */
    vdsLagName?: string;
    /**
     * Uplink name of VMware vSphere Distributed Switch (VDS)
     */
    vdsUplinkName?: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchTransportZoneEndpoint {
    /**
     * Unique ID identifying the transport zone for this endpoint
     */
    transportZone: string;
    /**
     * Identifiers of the transport zone profiles associated with this transport zone endpoint on this transport node
     */
    transportZoneProfiles: string[];
}

export interface PolicyHostTransportNodeStandardHostSwitchUplink {
    /**
     * Uplink name from UplinkHostSwitch profile
     */
    uplinkName: string;
    /**
     * Link Aggregation Group (LAG) name of Virtual Distributed Switch
     */
    vdsLagName?: string;
    /**
     * Uplink name of VMware vSphere Distributed Switch (VDS)
     */
    vdsUplinkName?: string;
}

export interface PolicyHostTransportNodeStandardHostSwitchVmkInstallMigration {
    /**
     * The network id to which the ESX vmk interface will be migrated
     */
    destinationNetwork: string;
    /**
     * ESX vmk interface name
     */
    deviceName: string;
}

export interface PolicyHostTransportNodeTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIntrusionServicePolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIntrusionServicePolicyRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * List of destination groups
     */
    destinationGroups?: string[];
    /**
     * Negation of destination groups
     */
    destinationsExcluded?: boolean;
    /**
     * Traffic direction
     */
    direction?: string;
    /**
     * Flag to disable the rule
     */
    disabled?: boolean;
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * List of policy Paths for IDS Profiles
     */
    idsProfiles: string[];
    /**
     * IP version
     */
    ipVersion?: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * Text for additional notes on changes
     */
    notes?: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * List of profiles
     */
    profiles?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Unique positive number that is assigned by the system and is useful for debugging
     */
    ruleId: number;
    /**
     * List of policy paths where the rule is applied
     */
    scopes?: string[];
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * List of services to match
     */
    services?: string[];
    /**
     * List of source groups
     */
    sourceGroups?: string[];
    /**
     * Negation of source groups
     */
    sourcesExcluded?: boolean;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyIntrusionServicePolicyRuleTag[];
}

export interface PolicyIntrusionServicePolicyRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIntrusionServicePolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIntrusionServiceProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIntrusionServiceProfileCriteria {
    /**
     * List of attack target criteria
     */
    attackTargets?: string[];
    /**
     * List of attack type criteria
     */
    attackTypes?: string[];
    /**
     * Common Vulnerability Scoring System Ranges
     */
    cvsses?: string[];
    /**
     * List of products affected
     */
    productsAffecteds?: string[];
}

export interface PolicyIntrusionServiceProfileOverriddenSignature {
    /**
     * This will take precedence over IDS signature action
     */
    action?: string;
    enabled?: boolean;
    signatureId: string;
}

export interface PolicyIntrusionServiceProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpAddressAllocationContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpAddressAllocationTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpBlockContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpBlockTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpDiscoveryProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpDiscoveryProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpPoolBlockSubnetContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpPoolBlockSubnetTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpPoolContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpPoolStaticSubnetAllocationRange {
    /**
     * The end IP Address for the range
     */
    end: string;
    /**
     * The start IP Address for the range
     */
    start: string;
}

export interface PolicyIpPoolStaticSubnetContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyIpPoolStaticSubnetTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpPoolTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnDpdProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnIkeProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnLocalEndpointTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnServiceBypassRule {
    /**
     * PROTECT - Protect rules are defined per policy based IPSec VPN session. BYPASS - Bypass rules are defined per IPSec VPN service and affects all policy based IPSec VPN sessions. Bypass rules are prioritized over protect rules.
     */
    action?: string;
    /**
     * List of remote subnets
     */
    destinations?: string[];
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * List of local subnets. Specifying no value is interpreted as 0.0.0.0/0.
     */
    sources?: string[];
}

export interface PolicyIpsecVpnServiceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnSessionRule {
    /**
     * PROTECT - Protect rules are defined per policy based IPSec VPN session. BYPASS - Bypass rules are defined per IPSec VPN service and affects all policy based IPSec VPN sessions. Bypass rules are prioritized over protect rules.
     */
    action?: string;
    /**
     * List of remote subnets
     */
    destinations?: string[];
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * List of local subnets. Specifying no value is interpreted as 0.0.0.0/0.
     */
    sources?: string[];
}

export interface PolicyIpsecVpnSessionTag {
    scope?: string;
    tag?: string;
}

export interface PolicyIpsecVpnTunnelProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyL2VpnServiceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyL2VpnSessionTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbClientSslProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbHttpApplicationProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbHttpMonitorProfileRequestHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface PolicyLbHttpMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbHttpsMonitorProfileRequestHeader {
    /**
     * Header name
     */
    name: string;
    /**
     * Header value
     */
    value: string;
}

export interface PolicyLbHttpsMonitorProfileServerSsl {
    /**
     * Authentication depth is used to set the verification depth in the server certificates chain. format: int64
     */
    certificateChainDepth?: number;
    /**
     * Client certificate path
     */
    clientCertificatePath?: string;
    /**
     * Server authentication mode.
     */
    serverAuth?: string;
    /**
     * If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified.
     */
    serverAuthCaPaths?: string[];
    /**
     * A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates.
     */
    serverAuthCrlPaths?: string[];
    /**
     * SSL profile path
     */
    sslProfilePath?: string;
}

export interface PolicyLbHttpsMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbIcmpMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbPassiveMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbPoolMember {
    /**
     * Member admin state
     */
    adminState?: string;
    /**
     * A boolean flag which reflects whether this is a backup pool member
     */
    backupMember?: boolean;
    /**
     * Pool member name
     */
    displayName: string;
    /**
     * Pool member IP address
     */
    ipAddress: string;
    /**
     * To ensure members are not overloaded, connections to a member can be capped by the load balancer. When a member reaches this limit, it is skipped during server selection. If it is not specified, it means that connections are unlimited
     */
    maxConcurrentConnections?: number;
    /**
     * If port is specified, all connections will be sent to this port. Only single port is supported. If unset, the same port the client connected to will be used, it could be overrode by default_pool_member_port setting in virtual server. The port should not specified for port range case
     */
    port?: string;
    /**
     * Pool member weight is used for WEIGHTED_ROUND_ROBIN balancing algorithm. The weight value would be ignored in other algorithms
     */
    weight?: number;
}

export interface PolicyLbPoolMemberGroup {
    /**
     * Use IPv4 addresses as server IPs
     */
    allowIpv4?: boolean;
    /**
     * Use IPv6 addresses as server IPs
     */
    allowIpv6?: boolean;
    /**
     * The IP list of the Group would be used as pool member IP setting
     */
    groupPath: string;
    /**
     * Limits the max number of pool members to the specified value
     */
    maxIpListSize?: number;
    /**
     * If port is specified, all connections will be sent to this port. If unset, the same port the client connected to will be used
     */
    port?: string;
}

export interface PolicyLbPoolSnat {
    /**
     * List of IP CIDRs or IP ranges for SNAT of type SNAT_IP_POOL
     */
    ipPoolAddresses?: string[];
    /**
     * Type of SNAT performed to ensure reverse traffic from the server can be received and processed by the loadbalancer
     */
    type?: string;
}

export interface PolicyLbPoolTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbServiceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbTcpMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbUdpMonitorProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLbVirtualServerAccessListControl {
    /**
     * Action to apply to connections matching the group
     */
    action: string;
    /**
     * Flag to enable access list control
     */
    enabled?: boolean;
    /**
     * The path of grouping object which defines the IP addresses or ranges to match the client IP
     */
    groupPath: string;
}

export interface PolicyLbVirtualServerClientSsl {
    /**
     * If client auth type is REQUIRED, client certificate must be signed by one Certificate Authorities
     */
    caPaths?: string[];
    /**
     * Certificate chain depth
     */
    certificateChainDepth?: number;
    /**
     * Client authentication mode
     */
    clientAuth?: string;
    /**
     * Certificate Revocation Lists can be specified to disallow compromised certificates
     */
    crlPaths?: string[];
    /**
     * Default Certificate Path
     */
    defaultCertificatePath: string;
    /**
     * This setting allows multiple certificates, for different hostnames, to be bound to the same virtual server
     */
    sniPaths?: string[];
    /**
     * Client SSL Profile Path
     */
    sslProfilePath?: string;
}

export interface PolicyLbVirtualServerRule {
    /**
     * A list of actions to be executed at specified phase when load balancer rule matches.
     */
    actions: outputs.PolicyLbVirtualServerRuleAction[];
    /**
     * A list of match conditions used to match application traffic.
     */
    conditions?: outputs.PolicyLbVirtualServerRuleCondition[];
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * Match strategy for determining match of multiple conditions (ALL or ANY, default: ANY).
     */
    matchStrategy?: string;
    /**
     * Load balancer processing phase, one of HTTP_REQUEST_REWRITE, HTTP_FORWARDING (Default), HTTP_RESPONSE_REWRITE, HTTP_ACCESS, TRANSPORT.
     */
    phase?: string;
}

export interface PolicyLbVirtualServerRuleAction {
    /**
     * Action to drop the connection.
     */
    connectionDrops?: outputs.PolicyLbVirtualServerRuleActionConnectionDrop[];
    /**
     * Action to redirect HTTP request messages to a new URL.
     */
    httpRedirects?: outputs.PolicyLbVirtualServerRuleActionHttpRedirect[];
    /**
     * Action to reject HTTP request messages
     */
    httpRejects?: outputs.PolicyLbVirtualServerRuleActionHttpReject[];
    /**
     * Action to delete header fields of HTTP request messages at HTTP_REQUEST_REWRITE phase.
     */
    httpRequestHeaderDeletes?: outputs.PolicyLbVirtualServerRuleActionHttpRequestHeaderDelete[];
    /**
     * Action to rewrite header fields of HTTP request messages to specified new values at HTTP_REQUEST_REWRITE phase.
     */
    httpRequestHeaderRewrites?: outputs.PolicyLbVirtualServerRuleActionHttpRequestHeaderRewrite[];
    /**
     * Action to rewrite URIs in matched HTTP request messages.
     */
    httpRequestUriRewrites?: outputs.PolicyLbVirtualServerRuleActionHttpRequestUriRewrite[];
    /**
     * Action to delete header fields of HTTP response messages at HTTP_RESPONSE_REWRITE phase.
     */
    httpResponseHeaderDeletes?: outputs.PolicyLbVirtualServerRuleActionHttpResponseHeaderDelete[];
    /**
     * Action to rewrite header fields of HTTP response messages to specified new values at HTTP_RESPONSE_REWRITE phase.
     */
    httpResponseHeaderRewrites?: outputs.PolicyLbVirtualServerRuleActionHttpResponseHeaderRewrite[];
    /**
     * Action  to control access to backend server resources using JSON Web Token(JWT) authentication.
     */
    jwtAuths?: outputs.PolicyLbVirtualServerRuleActionJwtAuth[];
    /**
     * Action to select a pool for matched HTTP request messages.
     */
    selectPools?: outputs.PolicyLbVirtualServerRuleActionSelectPool[];
    /**
     * Action to select SSL mode.
     */
    sslModeSelections?: outputs.PolicyLbVirtualServerRuleActionSslModeSelection[];
    /**
     * Action to create a new variable and assign value to it.
     */
    variableAssignments?: outputs.PolicyLbVirtualServerRuleActionVariableAssignment[];
    /**
     * Action to create a new variable and assign value to it.
     */
    variablePersistenceLearns?: outputs.PolicyLbVirtualServerRuleActionVariablePersistenceLearn[];
    /**
     * Action to create a new variable and assign value to it.
     */
    variablePersistenceOns?: outputs.PolicyLbVirtualServerRuleActionVariablePersistenceOn[];
}

export interface PolicyLbVirtualServerRuleActionConnectionDrop {
    _dummy?: string;
}

export interface PolicyLbVirtualServerRuleActionHttpRedirect {
    redirectStatus: string;
    redirectUrl: string;
}

export interface PolicyLbVirtualServerRuleActionHttpReject {
    replyMessage?: string;
    replyStatus: string;
}

export interface PolicyLbVirtualServerRuleActionHttpRequestHeaderDelete {
    headerName: string;
}

export interface PolicyLbVirtualServerRuleActionHttpRequestHeaderRewrite {
    headerName: string;
    headerValue: string;
}

export interface PolicyLbVirtualServerRuleActionHttpRequestUriRewrite {
    uri: string;
    uriArguments?: string;
}

export interface PolicyLbVirtualServerRuleActionHttpResponseHeaderDelete {
    headerName: string;
}

export interface PolicyLbVirtualServerRuleActionHttpResponseHeaderRewrite {
    headerName: string;
    headerValue: string;
}

export interface PolicyLbVirtualServerRuleActionJwtAuth {
    key?: outputs.PolicyLbVirtualServerRuleActionJwtAuthKey;
    passJwtToPool?: boolean;
    realm?: string;
    /**
     * JWT tokens
     */
    tokens?: string[];
}

export interface PolicyLbVirtualServerRuleActionJwtAuthKey {
    certificatePath?: string;
    publicKeyContent?: string;
    symmetricKey?: string;
}

export interface PolicyLbVirtualServerRuleActionSelectPool {
    poolId: string;
}

export interface PolicyLbVirtualServerRuleActionSslModeSelection {
    sslMode: string;
}

export interface PolicyLbVirtualServerRuleActionVariableAssignment {
    variableName: string;
    variableValue: string;
}

export interface PolicyLbVirtualServerRuleActionVariablePersistenceLearn {
    persistenceProfilePath?: string;
    variableHashEnabled?: boolean;
    variableName: string;
}

export interface PolicyLbVirtualServerRuleActionVariablePersistenceOn {
    persistenceProfilePath?: string;
    variableHashEnabled?: boolean;
    variableName: string;
}

export interface PolicyLbVirtualServerRuleCondition {
    /**
     * Rule condition based on HTTP request body
     */
    httpRequestBodies?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestBody[];
    /**
     * Rule condition based on HTTP cookie
     */
    httpRequestCookies?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestCooky[];
    /**
     * Rule condition based on HTTP request header
     */
    httpRequestHeaders?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestHeader[];
    /**
     * Rule condition based on http request method
     */
    httpRequestMethods?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestMethod[];
    /**
     * Rule condition based on http request URI arguments (query string)
     */
    httpRequestUriArguments?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestUriArgument[];
    /**
     * Rule condition based on http request URI
     */
    httpRequestUris?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestUri[];
    /**
     * Rule condition based on http request version
     */
    httpRequestVersion?: outputs.PolicyLbVirtualServerRuleConditionHttpRequestVersion;
    /**
     * Rule condition based on HTTP response header
     */
    httpResponseHeaders?: outputs.PolicyLbVirtualServerRuleConditionHttpResponseHeader[];
    /**
     * Rule condition based on HTTP SSL handshake and connection
     */
    httpSsls?: outputs.PolicyLbVirtualServerRuleConditionHttpSsl[];
    /**
     * Rule condition based on IP settings of the message
     */
    ipHeaders?: outputs.PolicyLbVirtualServerRuleConditionIpHeader[];
    /**
     * Rule condition based on SSL SNI in client hello
     */
    sslSnis?: outputs.PolicyLbVirtualServerRuleConditionSslSni[];
    /**
     * Rule condition based on TCP settings of the message
     */
    tcpHeaders?: outputs.PolicyLbVirtualServerRuleConditionTcpHeader[];
    /**
     * Rule condition based on IP header
     */
    variables?: outputs.PolicyLbVirtualServerRuleConditionVariable[];
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestBody {
    bodyValue: string;
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestCooky {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    cookieName: string;
    cookieValue: string;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestHeader {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    headerName: string;
    headerValue: string;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestMethod {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    method: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestUri {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uri: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestUriArgument {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    uriArguments: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpRequestVersion {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    version: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpResponseHeader {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    headerName: string;
    headerValue: string;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpSsl {
    clientCertificateIssuerDns?: outputs.PolicyLbVirtualServerRuleConditionHttpSslClientCertificateIssuerDn[];
    clientCertificateSubjectDns?: outputs.PolicyLbVirtualServerRuleConditionHttpSslClientCertificateSubjectDn[];
    /**
     * Supported SSL ciphers
     */
    clientSupportedSslCiphers?: string[];
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sessionReused?: string;
    usedProtocol?: string;
    usedSslCipher?: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpSslClientCertificateIssuerDn {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    issuerDn: string;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
}

export interface PolicyLbVirtualServerRuleConditionHttpSslClientCertificateSubjectDn {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    subjectDn: string;
}

export interface PolicyLbVirtualServerRuleConditionIpHeader {
    groupPath?: string;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourceAddress?: string;
}

export interface PolicyLbVirtualServerRuleConditionSslSni {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    sni: string;
}

export interface PolicyLbVirtualServerRuleConditionTcpHeader {
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    sourcePort: string;
}

export interface PolicyLbVirtualServerRuleConditionVariable {
    /**
     * If true, case is significant in condition matching
     */
    caseSensitive?: boolean;
    /**
     * Whether to reverse match result of this condition
     */
    inverse?: boolean;
    /**
     * Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
     */
    matchType: string;
    variableName: string;
    variableValue: string;
}

export interface PolicyLbVirtualServerServerSsl {
    /**
     * If server auth type is REQUIRED, server certificate must be signed by one Certificate Authorities
     */
    caPaths?: string[];
    /**
     * Certificate chain depth
     */
    certificateChainDepth?: number;
    /**
     * Client certificat path for client authentication
     */
    clientCertificatePath?: string;
    /**
     * Certificate Revocation Lists can be specified disallow compromised certificates
     */
    crlPaths?: string[];
    /**
     * Server authentication mode
     */
    serverAuth?: string;
    /**
     * Server SSL Profile Path
     */
    sslProfilePath?: string;
}

export interface PolicyLbVirtualServerTag {
    scope?: string;
    tag?: string;
}

export interface PolicyLdapIdentitySourceLdapServer {
    /**
     * Username or DN for LDAP authentication
     */
    bindIdentity?: string;
    /**
     * TLS certificate(s) for LDAP server(s)
     */
    certificates?: string[];
    /**
     * If true, this LDAP server is enabled
     */
    enabled?: boolean;
    /**
     * The authentication password for login
     */
    password?: string;
    /**
     * The URL for the LDAP server
     */
    url: string;
    /**
     * Enable/disable StartTLS
     */
    useStarttls?: boolean;
}

export interface PolicyLdapIdentitySourceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyMacDiscoveryProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyMacDiscoveryProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyMetadataProxyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyNatRuleContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyNatRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyOspfAreaTag {
    scope?: string;
    tag?: string;
}

export interface PolicyOspfConfigSummaryAddress {
    /**
     * Used to filter the advertisement of external routes into the OSPF domain
     */
    advertise?: boolean;
    /**
     * OSPF Summary address in CIDR format
     */
    prefix?: string;
}

export interface PolicyOspfConfigTag {
    scope?: string;
    tag?: string;
}

export interface PolicyParentSecurityPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyParentSecurityPolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedGatewayPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyPredefinedGatewayPolicyDefaultRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Scope for this rule
     */
    scope: string;
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyPredefinedGatewayPolicyDefaultRuleTag[];
}

export interface PolicyPredefinedGatewayPolicyDefaultRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedGatewayPolicyRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * List of destination groups
     */
    destinationGroups?: string[];
    /**
     * Negation of destination groups
     */
    destinationsExcluded?: boolean;
    /**
     * Traffic direction
     */
    direction?: string;
    /**
     * Flag to disable the rule
     */
    disabled?: boolean;
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * IP version
     */
    ipVersion?: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * Text for additional notes on changes
     */
    notes?: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * List of profiles
     */
    profiles?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Unique positive number that is assigned by the system and is useful for debugging
     */
    ruleId: number;
    /**
     * List of policy paths where the rule is applied
     */
    scopes: string[];
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * List of services to match
     */
    services?: string[];
    /**
     * List of source groups
     */
    sourceGroups?: string[];
    /**
     * Negation of source groups
     */
    sourcesExcluded?: boolean;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyPredefinedGatewayPolicyRuleTag[];
}

export interface PolicyPredefinedGatewayPolicyRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedGatewayPolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedSecurityPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyPredefinedSecurityPolicyDefaultRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Resource context
     */
    context?: outputs.PolicyPredefinedSecurityPolicyDefaultRuleContext;
    /**
     * Description for this resource
     */
    description: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Scope for this rule
     */
    scope: string;
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyPredefinedSecurityPolicyDefaultRuleTag[];
}

export interface PolicyPredefinedSecurityPolicyDefaultRuleContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyPredefinedSecurityPolicyDefaultRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedSecurityPolicyRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * List of destination groups
     */
    destinationGroups?: string[];
    /**
     * Negation of destination groups
     */
    destinationsExcluded?: boolean;
    /**
     * Traffic direction
     */
    direction?: string;
    /**
     * Flag to disable the rule
     */
    disabled?: boolean;
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * IP version
     */
    ipVersion?: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * Text for additional notes on changes
     */
    notes?: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * List of profiles
     */
    profiles?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Unique positive number that is assigned by the system and is useful for debugging
     */
    ruleId: number;
    /**
     * List of policy paths where the rule is applied
     */
    scopes?: string[];
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * List of services to match
     */
    services?: string[];
    /**
     * List of source groups
     */
    sourceGroups?: string[];
    /**
     * Negation of source groups
     */
    sourcesExcluded?: boolean;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyPredefinedSecurityPolicyRuleTag[];
}

export interface PolicyPredefinedSecurityPolicyRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyPredefinedSecurityPolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicyProjectSiteInfo {
    edgeClusterPaths?: string[];
    sitePath: string;
}

export interface PolicyProjectTag {
    scope?: string;
    tag?: string;
}

export interface PolicyQosProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyQosProfileEgressRateShaper {
    /**
     * Average Bandwidth in mbps
     */
    averageBwMbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in mbps
     */
    peakBwMbps?: number;
}

export interface PolicyQosProfileIngressBroadcastRateShaper {
    /**
     * Average Bandwidth in kbps
     */
    averageBwKbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in kbps
     */
    peakBwKbps?: number;
}

export interface PolicyQosProfileIngressRateShaper {
    /**
     * Average Bandwidth in mbps
     */
    averageBwMbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in mbps
     */
    peakBwMbps?: number;
}

export interface PolicyQosProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicySecurityPolicyContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicySecurityPolicyRule {
    /**
     * Action
     */
    action?: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * List of destination groups
     */
    destinationGroups?: string[];
    /**
     * Negation of destination groups
     */
    destinationsExcluded?: boolean;
    /**
     * Traffic direction
     */
    direction?: string;
    /**
     * Flag to disable the rule
     */
    disabled?: boolean;
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * IP version
     */
    ipVersion?: string;
    /**
     * Additional information (string) which will be propagated to the rule syslog
     */
    logLabel?: string;
    /**
     * Flag to enable packet logging
     */
    logged?: boolean;
    /**
     * Text for additional notes on changes
     */
    notes?: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * List of profiles
     */
    profiles?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Unique positive number that is assigned by the system and is useful for debugging
     */
    ruleId: number;
    /**
     * List of policy paths where the rule is applied
     */
    scopes?: string[];
    /**
     * Sequence number of the this rule
     */
    sequenceNumber: number;
    /**
     * List of services to match
     */
    services?: string[];
    /**
     * List of source groups
     */
    sourceGroups?: string[];
    /**
     * Negation of source groups
     */
    sourcesExcluded?: boolean;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicySecurityPolicyRuleTag[];
}

export interface PolicySecurityPolicyRuleContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicySecurityPolicyRuleTag {
    scope?: string;
    tag?: string;
}

export interface PolicySecurityPolicyTag {
    scope?: string;
    tag?: string;
}

export interface PolicySegmentAdvancedConfig {
    /**
     * Policy path to IP address pool
     */
    addressPoolPath?: string;
    /**
     * Connectivity configuration to manually connect (ON) or disconnect (OFF)
     */
    connectivity?: string;
    /**
     * Flag to identify a hybrid logical switch
     */
    hybrid?: boolean;
    /**
     * Flag to enable local egress
     */
    localEgress?: boolean;
    /**
     * The name of the switching uplink teaming policy for the bridge endpoint
     */
    uplinkTeamingPolicy?: string;
    /**
     * This URPF mode is applied to the downlink logical router port created while attaching this segment to gateway
     */
    urpfMode?: string;
}

export interface PolicySegmentBridgeConfig {
    /**
     * profile path
     */
    profilePath: string;
    /**
     * vlan transport zone path
     */
    transportZonePath: string;
    uplinkTeamingPolicy?: string;
    /**
     * VLAN specification for bridge endpoint
     */
    vlanIds: string[];
}

export interface PolicySegmentContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicySegmentDiscoveryProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * Policy path of associated IP Discovery Profile
     */
    ipDiscoveryProfilePath?: string;
    /**
     * Policy path of associated Mac Discovery Profile
     */
    macDiscoveryProfilePath?: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicySegmentL2Extension {
    /**
     * Policy paths of associated L2 VPN sessions
     */
    l2vpnPaths?: string[];
    /**
     * Tunnel ID
     */
    tunnelId?: number;
}

export interface PolicySegmentQosProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * Policy path of associated QoS Profile
     */
    qosProfilePath: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicySegmentSecurityProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Policy path of associated Segment Security Profile
     */
    securityProfilePath?: string;
    /**
     * Policy path of associated Spoofguard Profile
     */
    spoofguardProfilePath?: string;
}

export interface PolicySegmentSecurityProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicySegmentSecurityProfileRateLimit {
    rxBroadcast?: number;
    rxMulticast?: number;
    txBroadcast?: number;
    txMulticast?: number;
}

export interface PolicySegmentSecurityProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicySegmentSubnet {
    /**
     * Gateway IP address in CIDR format
     */
    cidr?: string;
    /**
     * DHCP address ranges for dynamic IP allocation
     */
    dhcpRanges?: string[];
    dhcpV4Config?: outputs.PolicySegmentSubnetDhcpV4Config;
    dhcpV6Config?: outputs.PolicySegmentSubnetDhcpV6Config;
    /**
     * Network CIDR for subnet
     */
    network: string;
}

export interface PolicySegmentSubnetDhcpV4Config {
    /**
     * Generic DHCP options
     */
    dhcpGenericOptions?: outputs.PolicySegmentSubnetDhcpV4ConfigDhcpGenericOption[];
    /**
     * DHCP classless static routes
     */
    dhcpOption121s?: outputs.PolicySegmentSubnetDhcpV4ConfigDhcpOption121[];
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
}

export interface PolicySegmentSubnetDhcpV4ConfigDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface PolicySegmentSubnetDhcpV4ConfigDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface PolicySegmentSubnetDhcpV6Config {
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * Domain names
     */
    domainNames?: string[];
    /**
     * Excluded addresses to define dynamic ip allocation ranges
     */
    excludedRanges?: outputs.PolicySegmentSubnetDhcpV6ConfigExcludedRange[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * The time interval in seconds, in which the prefix is advertised as preferred
     */
    preferredTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
    /**
     * IPv6 address of SNTP servers for subnet
     */
    sntpServers?: string[];
}

export interface PolicySegmentSubnetDhcpV6ConfigExcludedRange {
    /**
     * The end IP Address for the range
     */
    end: string;
    /**
     * The start IP Address for the range
     */
    start: string;
}

export interface PolicySegmentTag {
    scope?: string;
    tag?: string;
}

export interface PolicyServiceAlgorithmEntry {
    /**
     * Algorithm
     */
    algorithm: string;
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * A single destination port
     */
    destinationPort: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * Set of source ports or ranges
     */
    sourcePorts?: string[];
}

export interface PolicyServiceContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyServiceEtherTypeEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * Type of the encapsulated protocol
     */
    etherType: number;
}

export interface PolicyServiceIcmpEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * ICMP message code
     */
    icmpCode?: string;
    /**
     * ICMP message type
     */
    icmpType?: string;
    /**
     * Version of ICMP protocol (ICMPv4/ICMPv6)
     */
    protocol: string;
}

export interface PolicyServiceIgmpEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
}

export interface PolicyServiceIpProtocolEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * IP protocol number
     */
    protocol: number;
}

export interface PolicyServiceL4PortSetEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Set of destination ports
     */
    destinationPorts?: string[];
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * L4 Protocol
     */
    protocol: string;
    /**
     * Set of source ports
     */
    sourcePorts?: string[];
}

export interface PolicyServiceNestedServiceEntry {
    /**
     * Description for this resource
     */
    description?: string;
    /**
     * Display name for this resource
     */
    displayName?: string;
    /**
     * Nested Service Path
     */
    nestedServicePath: string;
}

export interface PolicyServiceTag {
    scope?: string;
    tag?: string;
}

export interface PolicySiteSiteConnectionInfo {
    /**
     * Fully Qualified Domain Name of the Management Node
     */
    fqdn?: string;
    /**
     * Password
     */
    password?: string;
    /**
     * id of Site
     */
    siteUuid?: string;
    /**
     * Thumbprint of Enforcement Point
     */
    thumbprint?: string;
    /**
     * Username
     */
    username?: string;
}

export interface PolicySiteTag {
    scope?: string;
    tag?: string;
}

export interface PolicySpoofGuardProfileContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicySpoofGuardProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyStaticRouteBfdPeerTag {
    scope?: string;
    tag?: string;
}

export interface PolicyStaticRouteContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyStaticRouteNextHop {
    /**
     * Cost associated with next hop route
     */
    adminDistance?: number;
    /**
     * Interface path associated with current route
     */
    interface?: string;
    /**
     * Next hop gateway IP address
     */
    ipAddress?: string;
}

export interface PolicyStaticRouteTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0GatewayBgpConfig {
    /**
     * Flag to enable ECMP
     */
    ecmp?: boolean;
    /**
     * Flag to enable BGP configuration
     */
    enabled?: boolean;
    /**
     * BGP Graceful Restart Configuration Mode
     */
    gracefulRestartMode?: string;
    /**
     * BGP Stale Route Timer
     */
    gracefulRestartStaleRouteTimer?: number;
    /**
     * BGP Graceful Restart Timer
     */
    gracefulRestartTimer?: number;
    /**
     * Enable inter SR IBGP configuration
     */
    interSrIbgp: boolean;
    /**
     * BGP AS number in ASPLAIN/ASDOT Format
     */
    localAsNum: string;
    /**
     * Flag to enable BGP multipath relax option
     */
    multipathRelax: boolean;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * List of routes to be aggregated
     */
    routeAggregations?: outputs.PolicyTier0GatewayBgpConfigRouteAggregation[];
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyTier0GatewayBgpConfigTag[];
}

export interface PolicyTier0GatewayBgpConfigRouteAggregation {
    /**
     * CIDR of aggregate address
     */
    prefix?: string;
    /**
     * Send only summarized route
     */
    summaryOnly?: boolean;
}

export interface PolicyTier0GatewayBgpConfigTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0GatewayGreTunnelTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0GatewayGreTunnelTunnelAddress {
    /**
     * Policy edge node path
     */
    edgePath: string;
    /**
     * IPv4 source address
     */
    sourceAddress: string;
    /**
     * Interface Subnet object parameter
     */
    tunnelInterfaceSubnets: outputs.PolicyTier0GatewayGreTunnelTunnelAddressTunnelInterfaceSubnet[];
}

export interface PolicyTier0GatewayGreTunnelTunnelAddressTunnelInterfaceSubnet {
    /**
     * IP addresses assigned to interface
     */
    ipAddresses: string[];
    /**
     * Subnet prefix length
     */
    prefixLen: number;
}

export interface PolicyTier0GatewayGreTunnelTunnelKeepalive {
    /**
     * Dead time multiplier
     */
    deadTimeMultiplier?: number;
    /**
     * Enable tunnel keep alive acknowledge
     */
    enableKeepaliveAck?: boolean;
    /**
     * Enable/Disable tunnel keep alive
     */
    enabled?: boolean;
    /**
     * Keep alive interval
     */
    keepaliveInterval?: number;
}

export interface PolicyTier0GatewayHaVipConfigConfig {
    /**
     * Flag to enable this HA VIP config
     */
    enabled?: boolean;
    /**
     * paths to Tier0 external interfaces which are to be paired to provide redundancy
     */
    externalInterfacePaths: string[];
    /**
     * IP address subnets which will be used as floating IP addresses
     */
    vipSubnets: string[];
}

export interface PolicyTier0GatewayInterfaceOspf {
    /**
     * OSPF Area Path
     */
    areaPath: string;
    /**
     * BFD profile path to be applied to all OSPF peers in this interface
     */
    bfdProfilePath?: string;
    /**
     * Number of seconds that router must wait before it declares OSPF neighbor router as down
     */
    deadInterval?: number;
    enableBfd?: boolean;
    enabled?: boolean;
    /**
     * Interval in seconds between hello packets that OSPF sends on this interface
     */
    helloInterval?: number;
    /**
     * OSPF network type
     */
    networkType?: string;
}

export interface PolicyTier0GatewayInterfaceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0GatewayIntersiteConfig {
    /**
     * Fallback sites to be used as new primary site on current primary site failure
     */
    fallbackSitePaths?: string[];
    /**
     * Primary egress site for gateway
     */
    primarySitePath?: string;
    /**
     * IPv4 subnet for inter-site transit segment connecting service routers across sites for stretched gateway. For IPv6 link local subnet is auto configured
     */
    transitSubnet: string;
}

export interface PolicyTier0GatewayLocaleService {
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * The path of the edge cluster connected to this gateway
     */
    edgeClusterPath: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * Paths of specific edge nodes
     */
    preferredEdgePaths?: string[];
    /**
     * Route Redistribution configuration
     *
     * @deprecated Deprecated
     */
    redistributionConfig?: outputs.PolicyTier0GatewayLocaleServiceRedistributionConfig;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicyTier0GatewayLocaleServiceRedistributionConfig {
    /**
     * Flag to enable route redistribution for BGP
     */
    enabled?: boolean;
    /**
     * Flag to enable route redistribution for OSPF
     */
    ospfEnabled?: boolean;
    /**
     * List of routes to be aggregated
     */
    rules?: outputs.PolicyTier0GatewayLocaleServiceRedistributionConfigRule[];
}

export interface PolicyTier0GatewayLocaleServiceRedistributionConfigRule {
    /**
     * BGP destination for this rule
     */
    bgp?: boolean;
    /**
     * Rule name
     */
    name?: string;
    /**
     * OSPF destination for this rule
     */
    ospf?: boolean;
    /**
     * Route map to be associated with the redistribution rule
     */
    routeMapPath?: string;
    /**
     * List of redistribution types
     */
    types?: string[];
}

export interface PolicyTier0GatewayRedistributionConfig {
    /**
     * Flag to enable route redistribution for BGP
     */
    enabled?: boolean;
    /**
     * Flag to enable route redistribution for OSPF
     */
    ospfEnabled?: boolean;
    /**
     * List of routes to be aggregated
     */
    rules?: outputs.PolicyTier0GatewayRedistributionConfigRule[];
}

export interface PolicyTier0GatewayRedistributionConfigRule {
    /**
     * BGP destination for this rule
     */
    bgp?: boolean;
    /**
     * Rule name
     */
    name?: string;
    /**
     * OSPF destination for this rule
     */
    ospf?: boolean;
    /**
     * Route map to be associated with the redistribution rule
     */
    routeMapPath?: string;
    /**
     * List of redistribution types
     */
    types?: string[];
}

export interface PolicyTier0GatewayTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0GatewayVrfConfig {
    /**
     * L3 VNI associated with the VRF for overlay traffic. VNI must be unique and belong to configured VNI pool
     */
    evpnTransitVni?: number;
    /**
     * Default tier0 path
     */
    gatewayPath: string;
    /**
     * Policy path for this resource
     */
    path: string;
    routeDistinguisher?: string;
    /**
     * Route targets
     */
    routeTarget?: outputs.PolicyTier0GatewayVrfConfigRouteTarget;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyTier0GatewayVrfConfigTag[];
}

export interface PolicyTier0GatewayVrfConfigRouteTarget {
    addressFamily?: string;
    /**
     * When set to false, targets should be configured
     */
    autoMode?: boolean;
    exportTargets?: string[];
    importTargets?: string[];
}

export interface PolicyTier0GatewayVrfConfigTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier0InterVrfRoutingBgpRouteLeaking {
    /**
     * Address family type
     */
    addressFamily?: string;
    /**
     * route map path for IN direction
     */
    inFilters?: string[];
    /**
     * route map path for OUT direction
     */
    outFilters?: string[];
}

export interface PolicyTier0InterVrfRoutingStaticRouteAdvertisement {
    /**
     * Route advertisement rules
     */
    advertisementRules?: outputs.PolicyTier0InterVrfRoutingStaticRouteAdvertisementAdvertisementRule[];
    /**
     * Paths of ordered Prefix list
     */
    inFilterPrefixLists?: string[];
}

export interface PolicyTier0InterVrfRoutingStaticRouteAdvertisementAdvertisementRule {
    /**
     * Action to advertise routes
     */
    action?: string;
    /**
     * Display name for rule
     */
    name?: string;
    /**
     * Prefix operator to match subnets
     */
    prefixOperator?: string;
    /**
     * Enable different types of route advertisements
     */
    routeAdvertisementTypes?: string[];
    /**
     * Network CIDRs
     */
    subnets?: string[];
}

export interface PolicyTier0InterVrfRoutingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier1GatewayContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyTier1GatewayInterfaceContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyTier1GatewayInterfaceTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTier1GatewayIntersiteConfig {
    /**
     * Fallback sites to be used as new primary site on current primary site failure
     */
    fallbackSitePaths?: string[];
    /**
     * Primary egress site for gateway
     */
    primarySitePath?: string;
    /**
     * IPv4 subnet for inter-site transit segment connecting service routers across sites for stretched gateway. For IPv6 link local subnet is auto configured
     */
    transitSubnet: string;
}

export interface PolicyTier1GatewayLocaleService {
    /**
     * Display name for this resource
     */
    displayName: string;
    /**
     * The path of the edge cluster connected to this gateway
     */
    edgeClusterPath: string;
    /**
     * NSX ID for this resource
     */
    nsxId: string;
    /**
     * Policy path for this resource
     */
    path: string;
    /**
     * Paths of specific edge nodes
     */
    preferredEdgePaths?: string[];
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicyTier1GatewayRouteAdvertisementRule {
    /**
     * Action to advertise filtered routes to the connected Tier0 gateway
     */
    action?: string;
    /**
     * Name of this rule
     */
    name: string;
    /**
     * Prefix operator to apply on networks
     */
    prefixOperator?: string;
    /**
     * Enable different types of route advertisements
     */
    routeAdvertisementTypes?: string[];
    /**
     * List of network CIDRs to be routed
     */
    subnets: string[];
}

export interface PolicyTier1GatewayTag {
    scope?: string;
    tag?: string;
}

export interface PolicyTransportZoneTag {
    scope?: string;
    tag?: string;
}

export interface PolicyUplinkHostSwitchProfileLag {
    /**
     * unique id
     */
    id: string;
    /**
     * LACP load balance Algorithm
     */
    loadBalanceAlgorithm: string;
    /**
     * LACP group mode
     */
    mode: string;
    /**
     * Lag name
     */
    name: string;
    /**
     * Number of uplinks
     */
    numberOfUplinks: number;
    /**
     * LACP timeout type
     */
    timeoutType?: string;
    /**
     * uplink names
     */
    uplinks: outputs.PolicyUplinkHostSwitchProfileLagUplink[];
}

export interface PolicyUplinkHostSwitchProfileLagUplink {
    uplinkName: string;
    uplinkType: string;
}

export interface PolicyUplinkHostSwitchProfileNamedTeaming {
    /**
     * List of Uplinks used in active list
     */
    actives: outputs.PolicyUplinkHostSwitchProfileNamedTeamingActive[];
    /**
     * The name of the uplink teaming policy
     */
    name: string;
    /**
     * Teaming policy
     */
    policy: string;
    /**
     * List of Uplinks used in standby list
     */
    standbies?: outputs.PolicyUplinkHostSwitchProfileNamedTeamingStandby[];
}

export interface PolicyUplinkHostSwitchProfileNamedTeamingActive {
    /**
     * Name of this uplink
     */
    uplinkName: string;
    /**
     * Type of the uplink
     */
    uplinkType: string;
}

export interface PolicyUplinkHostSwitchProfileNamedTeamingStandby {
    /**
     * Name of this uplink
     */
    uplinkName: string;
    /**
     * Type of the uplink
     */
    uplinkType: string;
}

export interface PolicyUplinkHostSwitchProfileTag {
    scope?: string;
    tag?: string;
}

export interface PolicyUplinkHostSwitchProfileTeaming {
    /**
     * List of Uplinks used in active list
     */
    actives: outputs.PolicyUplinkHostSwitchProfileTeamingActive[];
    /**
     * Teaming policy
     */
    policy: string;
    /**
     * List of Uplinks used in standby list
     */
    standbies?: outputs.PolicyUplinkHostSwitchProfileTeamingStandby[];
}

export interface PolicyUplinkHostSwitchProfileTeamingActive {
    /**
     * Name of this uplink
     */
    uplinkName: string;
    /**
     * Type of the uplink
     */
    uplinkType: string;
}

export interface PolicyUplinkHostSwitchProfileTeamingStandby {
    /**
     * Name of this uplink
     */
    uplinkName: string;
    /**
     * Type of the uplink
     */
    uplinkType: string;
}

export interface PolicyUserManagementRoleBindingRolesForPath {
    /**
     * Path of the entity in parent hierarchy.
     */
    path: string;
    /**
     * Applicable roles
     */
    roles: string[];
}

export interface PolicyUserManagementRoleBindingTag {
    scope?: string;
    tag?: string;
}

export interface PolicyUserManagementRoleFeature {
    /**
     * Feature Id
     */
    feature: string;
    /**
     * Feature Description
     */
    featureDescription: string;
    /**
     * Feature Name
     */
    featureName: string;
    permission: string;
}

export interface PolicyUserManagementRoleTag {
    scope?: string;
    tag?: string;
}

export interface PolicyVlanSegmentAdvancedConfig {
    /**
     * Policy path to IP address pool
     */
    addressPoolPath?: string;
    /**
     * Connectivity configuration to manually connect (ON) or disconnect (OFF)
     */
    connectivity?: string;
    /**
     * Flag to identify a hybrid logical switch
     */
    hybrid?: boolean;
    /**
     * Flag to enable local egress
     */
    localEgress?: boolean;
    /**
     * The name of the switching uplink teaming policy for the bridge endpoint
     */
    uplinkTeamingPolicy?: string;
    /**
     * This URPF mode is applied to the downlink logical router port created while attaching this segment to gateway
     */
    urpfMode?: string;
}

export interface PolicyVlanSegmentBridgeConfig {
    /**
     * profile path
     */
    profilePath: string;
    /**
     * vlan transport zone path
     */
    transportZonePath: string;
    uplinkTeamingPolicy?: string;
    /**
     * VLAN specification for bridge endpoint
     */
    vlanIds: string[];
}

export interface PolicyVlanSegmentContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyVlanSegmentDiscoveryProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * Policy path of associated IP Discovery Profile
     */
    ipDiscoveryProfilePath?: string;
    /**
     * Policy path of associated Mac Discovery Profile
     */
    macDiscoveryProfilePath?: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicyVlanSegmentL2Extension {
    /**
     * Policy paths of associated L2 VPN sessions
     */
    l2vpnPaths?: string[];
    /**
     * Tunnel ID
     */
    tunnelId?: number;
}

export interface PolicyVlanSegmentQosProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * Policy path of associated QoS Profile
     */
    qosProfilePath: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
}

export interface PolicyVlanSegmentSecurityProfile {
    /**
     * Policy path of profile binding map
     */
    bindingMapPath: string;
    /**
     * The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
     */
    revision: number;
    /**
     * Policy path of associated Segment Security Profile
     */
    securityProfilePath?: string;
    /**
     * Policy path of associated Spoofguard Profile
     */
    spoofguardProfilePath?: string;
}

export interface PolicyVlanSegmentSubnet {
    /**
     * Gateway IP address in CIDR format
     */
    cidr?: string;
    /**
     * DHCP address ranges for dynamic IP allocation
     */
    dhcpRanges?: string[];
    dhcpV4Config?: outputs.PolicyVlanSegmentSubnetDhcpV4Config;
    dhcpV6Config?: outputs.PolicyVlanSegmentSubnetDhcpV6Config;
    /**
     * Network CIDR for subnet
     */
    network: string;
}

export interface PolicyVlanSegmentSubnetDhcpV4Config {
    /**
     * Generic DHCP options
     */
    dhcpGenericOptions?: outputs.PolicyVlanSegmentSubnetDhcpV4ConfigDhcpGenericOption[];
    /**
     * DHCP classless static routes
     */
    dhcpOption121s?: outputs.PolicyVlanSegmentSubnetDhcpV4ConfigDhcpOption121[];
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
}

export interface PolicyVlanSegmentSubnetDhcpV4ConfigDhcpGenericOption {
    /**
     * DHCP option code, [0-255]
     */
    code: number;
    /**
     * DHCP option values
     */
    values: string[];
}

export interface PolicyVlanSegmentSubnetDhcpV4ConfigDhcpOption121 {
    /**
     * Destination in cidr
     */
    network: string;
    /**
     * Next hop IP
     */
    nextHop: string;
}

export interface PolicyVlanSegmentSubnetDhcpV6Config {
    /**
     * IP addresses of DNS servers for subnet
     */
    dnsServers?: string[];
    /**
     * Domain names
     */
    domainNames?: string[];
    /**
     * Excluded addresses to define dynamic ip allocation ranges
     */
    excludedRanges?: outputs.PolicyVlanSegmentSubnetDhcpV6ConfigExcludedRange[];
    /**
     * DHCP lease time in seconds
     */
    leaseTime?: number;
    /**
     * The time interval in seconds, in which the prefix is advertised as preferred
     */
    preferredTime?: number;
    /**
     * IP address of the DHCP server in CIDR format
     */
    serverAddress?: string;
    /**
     * IPv6 address of SNTP servers for subnet
     */
    sntpServers?: string[];
}

export interface PolicyVlanSegmentSubnetDhcpV6ConfigExcludedRange {
    /**
     * The end IP Address for the range
     */
    end: string;
    /**
     * The start IP Address for the range
     */
    start: string;
}

export interface PolicyVlanSegmentTag {
    scope?: string;
    tag?: string;
}

export interface PolicyVmTagsContext {
    /**
     * Id of the project which the resource belongs to.
     */
    projectId: string;
}

export interface PolicyVmTagsPort {
    /**
     * Segment path where VM port should be tagged
     */
    segmentPath: string;
    /**
     * Set of opaque identifiers meaningful to the user
     */
    tags?: outputs.PolicyVmTagsPortTag[];
}

export interface PolicyVmTagsPortTag {
    scope?: string;
    tag?: string;
}

export interface PolicyVmTagsTag {
    scope?: string;
    tag?: string;
}

export interface PolicyVniPoolTag {
    scope?: string;
    tag?: string;
}

export interface PolicyVtepHaHostSwitchProfileTag {
    scope?: string;
    tag?: string;
}

export interface PrincipalIdentityRolesForPath {
    /**
     * Path of the entity in parent hierarchy.
     */
    path: string;
    /**
     * Applicable roles
     */
    roles: string[];
}

export interface PrincipalIdentityTag {
    scope?: string;
    tag?: string;
}

export interface QosSwitchingProfileEgressRateShaper {
    /**
     * Average Bandwidth in mbps
     */
    averageBwMbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in mbps
     */
    peakBwMbps?: number;
}

export interface QosSwitchingProfileIngressBroadcastRateShaper {
    /**
     * Average Bandwidth in kbps
     */
    averageBwKbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in kbps
     */
    peakBwKbps?: number;
}

export interface QosSwitchingProfileIngressRateShaper {
    /**
     * Average Bandwidth in mbps
     */
    averageBwMbps?: number;
    /**
     * Burst size in bytes
     */
    burstSize?: number;
    /**
     * Whether this rate shaper is enabled
     */
    enabled?: boolean;
    /**
     * Peak Bandwidth in mbps
     */
    peakBwMbps?: number;
}

export interface QosSwitchingProfileTag {
    scope?: string;
    tag?: string;
}

export interface SpoofguardSwitchingProfileTag {
    scope?: string;
    tag?: string;
}

export interface StaticRouteNextHop {
    /**
     * Administrative Distance for the next hop IP
     */
    administrativeDistance?: number;
    /**
     * Status of bfd for this next hop where bfdEnabled = true indicate bfd is enabled for this next hop and bfdEnabled = false indicate bfd peer is disabled or not configured for this next hop.
     */
    bfdEnabled: boolean;
    /**
     * Action to be taken on matching packets for NULL routes
     */
    blackholeAction: string;
    /**
     * Next Hop IP
     */
    ipAddress?: string;
    /**
     * Logical router port id
     */
    logicalRouterPortId?: string;
}

export interface StaticRouteTag {
    scope?: string;
    tag?: string;
}

export interface SwitchSecuritySwitchingProfileRateLimits {
    /**
     * Whether rate limiting is enabled
     */
    enabled?: boolean;
    /**
     * Incoming broadcast traffic limit in packets per second
     */
    rxBroadcast?: number;
    /**
     * Incoming multicast traffic limit in packets per second
     */
    rxMulticast?: number;
    /**
     * Outgoing broadcast traffic limit in packets per second
     */
    txBroadcast?: number;
    /**
     * Outgoing multicast traffic limit in packets per second
     */
    txMulticast?: number;
}

export interface SwitchSecuritySwitchingProfileTag {
    scope?: string;
    tag?: string;
}

export interface UpgradePrecheckAcknowledgePrecheckWarning {
    id: string;
    isAcknowledged: boolean;
    message: string;
}

export interface UpgradePrepareFailedPrecheck {
    acked: boolean;
    id: string;
    message: string;
    needsAck: boolean;
    needsResolve: boolean;
    resolutionStatus: string;
    type: string;
}

export interface UpgradeRunEdgeGroup {
    /**
     * Flag to indicate whether upgrade of this group is enabled or not
     */
    enabled?: boolean;
    /**
     * ID of upgrade unit group
     */
    id: string;
    /**
     * Upgrade method to specify whether the upgrade is to be performed in parallel or serially
     */
    parallel?: boolean;
    /**
     * Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
     */
    pauseAfterEachUpgradeUnit?: boolean;
}

export interface UpgradeRunEdgeUpgradeSetting {
    /**
     * Whether run upgrade parallel
     */
    parallel?: boolean;
    /**
     * Whether run post upgrade check
     */
    postUpgradeCheck?: boolean;
}

export interface UpgradeRunHostGroup {
    /**
     * Flag to indicate whether upgrade of this group is enabled or not
     */
    enabled?: boolean;
    /**
     * ID of upgrade unit group
     */
    id: string;
    /**
     * Maintenance mode config evacuate powered off vms
     */
    maintenanceModeConfigEvacuatePoweredOffVms?: boolean;
    /**
     * Maintenance mode config vsan mode
     */
    maintenanceModeConfigVsanMode?: string;
    /**
     * Upgrade method to specify whether the upgrade is to be performed in parallel or serially
     */
    parallel?: boolean;
    /**
     * Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
     */
    pauseAfterEachUpgradeUnit?: boolean;
    /**
     * Rebootless upgrade
     */
    rebootlessUpgrade?: boolean;
    /**
     * Upgrade mode
     */
    upgradeMode?: string;
}

export interface UpgradeRunHostUpgradeSetting {
    /**
     * Whether run upgrade parallel
     */
    parallel?: boolean;
    /**
     * Whether run post upgrade check
     */
    postUpgradeCheck?: boolean;
    /**
     * Whether stop the upgrade when an error occur
     */
    stopOnError?: boolean;
}

export interface UpgradeRunState {
    details: string;
    groupStates: outputs.UpgradeRunStateGroupState[];
    status: string;
    targetVersion: string;
    type: string;
}

export interface UpgradeRunStateGroupState {
    groupId: string;
    groupName: string;
    status: string;
}

export interface UpgradeRunUpgradeGroupPlan {
    /**
     * Flag to indicate whether upgrade of this group is enabled or not
     */
    enabled: boolean;
    extendedConfig: {[key: string]: string};
    /**
     * ID of upgrade unit group
     */
    id: string;
    /**
     * Upgrade method to specify whether the upgrade is to be performed in parallel or serially
     */
    parallel: boolean;
    /**
     * Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
     */
    pauseAfterEachUpgradeUnit: boolean;
    /**
     * Component type
     */
    type: string;
}

export interface VlanLogicalSwitchAddressBinding {
    /**
     * A single IP address or a subnet cidr
     */
    ipAddress?: string;
    /**
     * A single MAC address
     */
    macAddress?: string;
    /**
     * A single vlan tag value
     */
    vlan?: number;
}

export interface VlanLogicalSwitchSwitchingProfileId {
    /**
     * The resource type of this profile
     */
    key: string;
    /**
     * The ID of this profile
     */
    value: string;
}

export interface VlanLogicalSwitchTag {
    scope?: string;
    tag?: string;
}

export interface VmTagsLogicalPortTag {
    scope?: string;
    tag?: string;
}

export interface VmTagsTag {
    scope?: string;
    tag?: string;
}

