// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CaasClusterBlueprintWorkerNode {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface CaasClusterDefaultMachineSet {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface CaasClusterDefaultMachineSetsDetail {
    computeType: string;
    machineProvider: string;
    machineRoles: string[];
    machines: outputs.CaasClusterDefaultMachineSetsDetailMachine[];
    maxSize: number;
    minSize: number;
    name: string;
    networks: string[];
    proxy: string;
    size: string;
    sizeDetails: outputs.CaasClusterDefaultMachineSetsDetailSizeDetail[];
    storageType: string;
}

export interface CaasClusterDefaultMachineSetsDetailMachine {
    createdDate: string;
    health: string;
    hostname: string;
    id: string;
    lastUpdateDate: string;
    name: string;
    state: string;
}

export interface CaasClusterDefaultMachineSetsDetailSizeDetail {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface CaasClusterMachineSet {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface CaasClusterMachineSetsDetail {
    computeType: string;
    machineProvider: string;
    machineRoles: string[];
    machines: outputs.CaasClusterMachineSetsDetailMachine[];
    maxSize: number;
    minSize: number;
    name: string;
    networks: string[];
    proxy: string;
    size: string;
    sizeDetails: outputs.CaasClusterMachineSetsDetailSizeDetail[];
    storageType: string;
}

export interface CaasClusterMachineSetsDetailMachine {
    createdDate: string;
    health: string;
    hostname: string;
    id: string;
    lastUpdateDate: string;
    name: string;
    state: string;
}

export interface CaasClusterMachineSetsDetailSizeDetail {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface CaasClusterServiceEndpoint {
    endpoint: string;
    name: string;
    namespace: string;
    type: string;
}

export interface CaasClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CaasClusterWorkerNode {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface CaasMachineBlueprintSizeDetail {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface GetCaasClusterBlueprintMachineSet {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface GetCaasClusterMachineSet {
    machineBlueprintId: string;
    maxSize: number;
    minSize: number;
    name: string;
}

export interface GetCaasClusterMachineSetsDetail {
    computeType: string;
    machineProvider: string;
    machineRoles: string[];
    machines: outputs.GetCaasClusterMachineSetsDetailMachine[];
    maxSize: number;
    minSize: number;
    name: string;
    networks: string[];
    proxy: string;
    size: string;
    sizeDetails: outputs.GetCaasClusterMachineSetsDetailSizeDetail[];
    storageType: string;
}

export interface GetCaasClusterMachineSetsDetailMachine {
    createdDate: string;
    health: string;
    hostname: string;
    id: string;
    lastUpdateDate: string;
    name: string;
    state: string;
}

export interface GetCaasClusterMachineSetsDetailSizeDetail {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface GetCaasClusterProviderAvailableCapacity {
    clusters: number;
    cpu: number;
    nodes: number;
}

export interface GetCaasClusterProviderLicenseInfo {
    label: string;
    status: string;
    summary: string;
}

export interface GetCaasClusterProviderMinMasterSize {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface GetCaasClusterProviderMinWorkerSize {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface GetCaasClusterProviderStorageClass {
    accessProtocol: string;
    costPerGb: string;
    dedupe: string;
    description: string;
    encryption: string;
    glStorageType: string;
    iops: string;
    name: string;
}

export interface GetCaasClusterServiceEndpoint {
    endpoint: string;
    name: string;
    namespace: string;
    type: string;
}

export interface GetCaasMachineBlueprintSizeDetail {
    cpu: number;
    ephemeralDisk: number;
    memory: number;
    name: string;
    persistentDisk: number;
    rootDisk: number;
}

export interface GetMetalAvailableImagesFilter {
    name: string;
    values: string[];
}

export interface GetMetalAvailableImagesImage {
    category: string;
    flavor: string;
    id: string;
    version: string;
}

export interface GetMetalAvailableResourcesFilter {
    name: string;
    values: string[];
}

export interface GetMetalAvailableResourcesImage {
    category: string;
    flavor: string;
    id: string;
    version: string;
}

export interface GetMetalAvailableResourcesLocation {
    country: string;
    dataCenter: string;
    id: string;
    location: string;
    region: string;
}

export interface GetMetalAvailableResourcesMachineSize {
    description: string;
    id: string;
    location: string;
    locationId: string;
    name: string;
    quantity: number;
}

export interface GetMetalAvailableResourcesNetwork {
    description: string;
    hostUse: string;
    id: string;
    ipPoolId: string;
    ipPools: outputs.GetMetalAvailableResourcesNetworkIpPool[];
    location: string;
    locationId: string;
    name: string;
    purpose: string;
    vlan: number;
    vni: number;
}

export interface GetMetalAvailableResourcesNetworkIpPool {
    baseIp: string;
    defaultRoute: string;
    description: string;
    dns: string[];
    ipVer: string;
    name: string;
    netmask: string;
    noProxy: string;
    ntps: string[];
    proxy: string;
    sources: outputs.GetMetalAvailableResourcesNetworkIpPoolSource[];
}

export interface GetMetalAvailableResourcesNetworkIpPoolSource {
    baseIp: string;
    count: number;
}

export interface GetMetalAvailableResourcesSshKey {
    id: string;
    name: string;
}

export interface GetMetalAvailableResourcesStoragePool {
    capacity: number;
    id: string;
    location: string;
    locationId: string;
    name: string;
}

export interface GetMetalAvailableResourcesVolume {
    description: string;
    flavor: string;
    flavorId: string;
    id: string;
    labels: {[key: string]: string};
    location: string;
    locationId: string;
    name: string;
    shareable: boolean;
    size: number;
    state: string;
    status: string;
    storagePool: string;
    storagePoolId: string;
    volumeCollection: string;
    volumeCollectionId: string;
    wwn: string;
}

export interface GetMetalAvailableResourcesVolumeCollection {
    description: string;
    id: string;
    location: string;
    locationId: string;
    name: string;
    storagePoolIds: string[];
}

export interface GetMetalAvailableResourcesVolumeFlavor {
    description: string;
    id: string;
    name: string;
}

export interface GetVmaasRouterInterface {
    cidr: string;
    id: number;
    sourceAddresses: string;
}

export interface MetalHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MetalHostVolumeInfo {
    /**
     * iSCSI Discovery IP.
     */
    discoveryIp: string;
    /**
     * The ID the volume attached.
     */
    id: string;
    /**
     * A friendly name of the volume attached.
     */
    name: string;
    /**
     * iSCSI Target IQN.
     */
    targetIqn: string;
}

export interface MetalNetworkIpPool {
    /**
     * Base IP of the pool.
     */
    baseIp: string;
    /**
     * Default route of the IP pool.
     */
    defaultRoute?: string;
    /**
     * A description of the IP pool.
     */
    description?: string;
    /**
     * DNS servers to be specified in each allocation from the pool
     */
    dns?: string[];
    /**
     * IP version of the pool (IPv4 or IPv6).
     */
    ipVer: string;
    /**
     * A friendly name of the IP pool.
     */
    name: string;
    /**
     * Netmask of the IP pool.
     */
    netmask: string;
    /**
     * IPs or CIDRs for which proxy requests are not made.
     */
    noProxy?: string;
    /**
     * NTP servers of the IP pool
     */
    ntps?: string[];
    /**
     * Web-proxy for external internet access should this pool actually be behind a firewall.
     */
    proxy?: string;
    /**
     * IP ranges that are to be included in the pool within the base IP and netmask
     */
    sources?: outputs.MetalNetworkIpPoolSource[];
}

export interface MetalNetworkIpPoolSource {
    /**
     * Base IP for the source.
     */
    baseIp: string;
    /**
     * Number of IPs to include starting from the base.
     */
    count: number;
}

export interface MetalProjectLimits {
    /**
     * Maximum number of host allowed in the team.
     */
    hosts?: number;
    /**
     * Map of instance type ID to maximum number of hosts that can be created with that instance type
     */
    instanceTypes?: {[key: string]: number};
    /**
     * Maximum number of private networks allowed in the team.
     */
    privateNetworks?: number;
    /**
     * Total allowable volume capacity (GiB) allowed in the team.
     */
    volumeCapacity?: number;
    /**
     * Maximum number of volumes allowed in the team.
     */
    volumes?: number;
}

export interface MetalProjectProfile {
    /**
     * The company address with the team.
     */
    address?: string;
    /**
     * The company associated with the team.
     */
    company?: string;
    /**
     * Email address.
     */
    email: string;
    /**
     * Email address has been validated.
     */
    emailVerified: boolean;
    /**
     * Phine number.
     */
    phoneNumber?: string;
    /**
     * Phine number has been validated.
     */
    phoneNumberVerified: boolean;
    /**
     * A friendly description of the team.
     */
    projectDescription?: string;
    /**
     * A friendly name of the team.
     */
    projectName: string;
}

export interface VmaasDhcpServerConfig {
    /**
     * Provider ID of the Edge Cluster. Use hpegl.getVmaasEdgeCluster datasource to obtain the provider_id here.
     */
    edgeCluster?: string;
}

export interface VmaasInstanceCloneConfig {
    /**
     * Asset tag
     */
    assetTag?: string;
    /**
     * Create user
     */
    createUser?: boolean;
    /**
     * Folder in which all VMs to be spawned, use hpegl_vmaas_cloud_folder.code datasource
     */
    folderCode?: string;
    /**
     * If true agent will not be installed on the instance.
     */
    noAgent?: boolean;
    /**
     * Unique ID to identify a resource pool.
     */
    resourcePoolId?: number;
    /**
     * Unique ID for the template
     */
    templateId?: number;
}

export interface VmaasInstanceCloneContainer {
    containerTypes: outputs.VmaasInstanceCloneContainerContainerType[];
    externalFqdn: string;
    hostname: string;
    id: number;
    ip: string;
    maxCores: number;
    maxMemory: number;
    maxStorage: number;
    name: string;
    servers: outputs.VmaasInstanceCloneContainerServer[];
}

export interface VmaasInstanceCloneContainerContainerType {
    name: string;
}

export interface VmaasInstanceCloneContainerServer {
    computeServerTypes: outputs.VmaasInstanceCloneContainerServerComputeServerType[];
    dateCreated: string;
    id: number;
    lastUpdated: string;
    owners: outputs.VmaasInstanceCloneContainerServerOwner[];
    platform: string;
    platformVersion: string;
    serverOs: outputs.VmaasInstanceCloneContainerServerServerO[];
    sshHost: string;
    sshPort: number;
    visibility: string;
}

export interface VmaasInstanceCloneContainerServerComputeServerType {
    externalDelete: boolean;
    managed: boolean;
    name: string;
}

export interface VmaasInstanceCloneContainerServerOwner {
    username: string;
}

export interface VmaasInstanceCloneContainerServerServerO {
    name: string;
}

export interface VmaasInstanceCloneHistory {
    accountId: number;
    createdBies: outputs.VmaasInstanceCloneHistoryCreatedBy[];
    dateCreated: string;
    displayName: string;
    duration: number;
    endDate: string;
    id: number;
    instanceId: number;
    lastUpdated: string;
    percent: number;
    processTypes: outputs.VmaasInstanceCloneHistoryProcessType[];
    reason: string;
    startDate: string;
    status: string;
    statusEta: number;
    uniqueId: string;
    updatedBies: outputs.VmaasInstanceCloneHistoryUpdatedBy[];
}

export interface VmaasInstanceCloneHistoryCreatedBy {
    displayName: string;
    username: string;
}

export interface VmaasInstanceCloneHistoryProcessType {
    code: string;
    name: string;
}

export interface VmaasInstanceCloneHistoryUpdatedBy {
    displayName: string;
    username: string;
}

export interface VmaasInstanceCloneNetwork {
    /**
     * Unique ID to identify a network ID.
     */
    id: number;
    /**
     * Unique ID to identify a network interface type.
     */
    interfaceId?: number;
    /**
     * Unique ID to identify a network internal ID.
     */
    internalId: number;
    /**
     * Flag that identifies if a given network is primary. Primary network cannot be deleted.
     */
    isPrimary: boolean;
    /**
     * name of the interface
     */
    name: string;
}

export interface VmaasInstanceCloneSnapshot {
    /**
     * Description of the snapshot
     */
    description?: string;
    /**
     * ID of the snapshot.
     */
    id: number;
    /**
     * Flag which will be set to be true if the snapshot with the name
     * 							exists.
     */
    isSnapshotExists: boolean;
    /**
     * Name of the snapshot.
     */
    name: string;
}

export interface VmaasInstanceCloneVolume {
    /**
     * Datastore ID can be obtained from hpegl.getVmaasDatastore
     * 							data source. Use the value 'auto' so that the datastore is automatically selected.
     */
    datastoreId: string;
    /**
     * ID for the volume
     */
    id: number;
    /**
     * Unique name for the volume.
     */
    name: string;
    /**
     * true if volume is root
     */
    root: boolean;
    /**
     * Size of the volume in GB.
     */
    size: number;
}

export interface VmaasInstanceConfig {
    /**
     * Asset tag
     */
    assetTag?: string;
    /**
     * Create user
     */
    createUser?: boolean;
    /**
     * Folder in which all VMs to be spawned, use hpegl_vmaas_cloud_folder.code datasource
     */
    folderCode: string;
    /**
     * If true agent will not be installed on the instance.
     */
    noAgent?: boolean;
    /**
     * Unique ID to identify a resource pool.
     */
    resourcePoolId: number;
    /**
     * Unique ID for the template
     */
    templateId?: number;
}

export interface VmaasInstanceContainer {
    containerTypes: outputs.VmaasInstanceContainerContainerType[];
    externalFqdn: string;
    hostname: string;
    id: number;
    ip: string;
    maxCores: number;
    maxMemory: number;
    maxStorage: number;
    name: string;
    servers: outputs.VmaasInstanceContainerServer[];
}

export interface VmaasInstanceContainerContainerType {
    name: string;
}

export interface VmaasInstanceContainerServer {
    computeServerTypes: outputs.VmaasInstanceContainerServerComputeServerType[];
    dateCreated: string;
    id: number;
    lastUpdated: string;
    owners: outputs.VmaasInstanceContainerServerOwner[];
    platform: string;
    platformVersion: string;
    serverOs: outputs.VmaasInstanceContainerServerServerO[];
    sshHost: string;
    sshPort: number;
    visibility: string;
}

export interface VmaasInstanceContainerServerComputeServerType {
    externalDelete: boolean;
    managed: boolean;
    name: string;
}

export interface VmaasInstanceContainerServerOwner {
    username: string;
}

export interface VmaasInstanceContainerServerServerO {
    name: string;
}

export interface VmaasInstanceHistory {
    accountId: number;
    createdBies: outputs.VmaasInstanceHistoryCreatedBy[];
    dateCreated: string;
    displayName: string;
    duration: number;
    endDate: string;
    id: number;
    instanceId: number;
    lastUpdated: string;
    percent: number;
    processTypes: outputs.VmaasInstanceHistoryProcessType[];
    reason: string;
    startDate: string;
    status: string;
    statusEta: number;
    uniqueId: string;
    updatedBies: outputs.VmaasInstanceHistoryUpdatedBy[];
}

export interface VmaasInstanceHistoryCreatedBy {
    displayName: string;
    username: string;
}

export interface VmaasInstanceHistoryProcessType {
    code: string;
    name: string;
}

export interface VmaasInstanceHistoryUpdatedBy {
    displayName: string;
    username: string;
}

export interface VmaasInstanceNetwork {
    /**
     * Unique ID to identify a network ID.
     */
    id: number;
    /**
     * Unique ID to identify a network interface type.
     */
    interfaceId?: number;
    /**
     * Unique ID to identify a network internal ID.
     */
    internalId: number;
    /**
     * Flag that identifies if a given network is primary. Primary network cannot be deleted.
     */
    isPrimary: boolean;
    /**
     * name of the interface
     */
    name: string;
}

export interface VmaasInstancePort {
    /**
     * Load balancing configuration for ports.
     * 					 Supported values are "No LB", "HTTP", "HTTPS", "TCP"
     */
    lb: string;
    /**
     * Name of the port
     */
    name: string;
    /**
     * Port value in string
     */
    port: string;
}

export interface VmaasInstanceSnapshot {
    /**
     * Description of the snapshot
     */
    description?: string;
    /**
     * ID of the snapshot.
     */
    id: number;
    /**
     * Flag which will be set to be true if the snapshot with the name
     * 							exists.
     */
    isSnapshotExists: boolean;
    /**
     * Name of the snapshot.
     */
    name: string;
}

export interface VmaasInstanceVolume {
    /**
     * Datastore ID can be obtained from hpegl.getVmaasDatastore
     * 							data source. Use the value 'auto' so that the datastore is automatically selected.
     */
    datastoreId: string;
    /**
     * ID for the volume
     */
    id: number;
    /**
     * Unique name for the volume.
     */
    name: string;
    /**
     * true if volume is root
     */
    root: boolean;
    /**
     * Size of the volume in GB.
     */
    size: number;
}

export interface VmaasLoadBalancerConfig {
    /**
     * If `true` then admin State rule will be active/enabled.
     */
    adminState?: boolean;
    /**
     * In Filter. Supported Values are "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL", "ALERT", "EMERGENCY"
     */
    logLevel?: string;
    /**
     * In Filter. Supported Values are "SMALL", "MEDIUM", "LARGE"
     */
    size?: string;
    /**
     * Provider ID of the Tier1 Gateway. Use hpegl.VmaasRouter datasource to obtain the provider_id here.
     */
    tier1Gateways: string;
}

export interface VmaasLoadBalancerGroupAccess {
    /**
     * Pass `true` to allow access to all groups.
     */
    all?: boolean;
    /**
     * List of sites/groups
     */
    sites?: outputs.VmaasLoadBalancerGroupAccessSite[];
}

export interface VmaasLoadBalancerGroupAccessSite {
    /**
     * Group Default Selection
     */
    default?: boolean;
    /**
     * ID of the site/group
     */
    id?: number;
}

export interface VmaasLoadBalancerMonitorHttpMonitor {
    /**
     * Number of consecutive checks that must fail before marking it down.
     */
    fallCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    interval?: number;
    /**
     * Set the value of the monitoring port.
     */
    monitorPort?: number;
    /**
     * Enter the request body. Valid for the POST and PUT methods
     */
    requestBody?: string;
    /**
     * Select the method to detect the server status
     */
    requestMethod?: string;
    /**
     * Enter the request URI for the method
     */
    requestUrl?: string;
    /**
     * HTTP request version. Valid values are HTTP_VERSION_1_0 and HTTP_VERSION_1_1
     */
    requestVersion?: string;
    /**
     * If the HTTP response body string and the HTTP health check response body match,then the server is considered as healthy
     */
    responseData?: string;
    /**
     * Enter the string that the monitor expects to match in the status line of HTTP response body.The response code is a comma-separated list
     */
    responseStatusCodes?: string;
    /**
     * Number of consecutive checks that must pass before marking it up
     */
    riseCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerMonitorHttpsMonitor {
    /**
     * Number of consecutive checks that must fail before marking it down.
     */
    fallCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    interval?: number;
    /**
     * Set the value of the monitoring port
     */
    monitorPort?: number;
    /**
     * Enter the request body. Valid for the POST and PUT methods
     */
    requestBody?: string;
    /**
     * Select the method to detect the server status
     */
    requestMethod?: string;
    /**
     * Enter the request URI for the method
     */
    requestUrl?: string;
    /**
     * HTTP request version. Valid values are HTTP_VERSION_1_0 and HTTP_VERSION_1_1
     */
    requestVersion?: string;
    /**
     * If the HTTP response body string and the HTTP health check response body match,then the server is considered as healthy
     */
    responseData?: string;
    /**
     * Enter the string that the monitor expects to match in the status line of HTTP response body.The response code is a comma-separated list
     */
    responseStatusCodes?: string;
    /**
     * Number of consecutive checks that must pass before marking it up
     */
    riseCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerMonitorIcmpMonitor {
    /**
     * Maximum size of the ICMP data packet
     */
    dataLength?: number;
    /**
     * Number of consecutive checks that must fail before marking it down
     */
    fallCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    interval?: number;
    /**
     * Set the value of the monitoring port.
     */
    monitorPort?: number;
    /**
     * Number of consecutive checks that must pass before marking it up
     */
    riseCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerMonitorPassiveMonitor {
    /**
     * Set a value when the consecutive failures reach this value,the server is considered temporarily unavailable
     */
    maxFail?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerMonitorTcpMonitor {
    /**
     * Number of consecutive checks that must fail before marking it down.
     */
    fallCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    interval?: number;
    /**
     * Set the value of the monitoring port.
     */
    monitorPort?: number;
    /**
     * Enter the request body. Valid for the POST and PUT methods
     */
    requestBody?: string;
    /**
     * If the HTTP response body string and the HTTP health check response body matchthen the server is considered as healthy
     */
    responseData?: string;
    /**
     * Number of consecutive checks that must pass before marking it up
     */
    riseCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerMonitorUdpMonitor {
    /**
     * Number of consecutive checks that must fail before marking it down.
     */
    fallCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    interval?: number;
    /**
     * Set the value of the monitoring port.
     */
    monitorPort?: number;
    /**
     * Enter the request body. Valid for the POST and PUT methods
     */
    requestBody?: string;
    /**
     * If the HTTP response body string and the HTTP health check response body match,then the server is considered as healthy
     */
    responseData?: string;
    /**
     * Number of consecutive checks that must pass before marking it up
     */
    riseCount?: number;
    /**
     * Set the number of times the server is tested before it is considered as DOWN
     */
    timeout?: number;
}

export interface VmaasLoadBalancerPoolConfig {
    /**
     * Active Monitor ID, Get the `id` from hpegl.VmaasLoadBalancerMonitor datasource to obtain the active monitor ID
     */
    activeMonitorPaths?: number;
    /**
     * member group
     */
    memberGroups?: outputs.VmaasLoadBalancerPoolConfigMemberGroup[];
    /**
     * Passive Monitor ID, Get the `id` from hpegl.VmaasLoadBalancerMonitor datasource to obtain the passive monitor ID
     */
    passiveMonitorPath?: number;
    /**
     * Address of the snat_ip for Network loadbalancer pool
     */
    snatIpAddress?: string;
    /**
     * Network Loadbalancer Supported values are `LBSnatAutoMap`,`LBSnatDisabled`, `LBSnatIpPool`
     */
    snatTranslationType?: string;
    /**
     * With TCP multiplexing, user can use the same TCP connectionbetween a load balancer and the server forsending multiple client requests from different client TCP connections.
     */
    tcpMultiplexing?: boolean;
    /**
     * The maximum number of TCP connections per poolthat are idly kept alive for sending future client requests
     */
    tcpMultiplexingNumber?: number;
}

export interface VmaasLoadBalancerPoolConfigMemberGroup {
    /**
     * Pool Member Groups path, get the `externalId` from hpegl_vmaas_lb_pool_member_groupdatasource to obtain the path
     */
    group?: string;
    /**
     * Ip version filter is used to filter `IPv4` addresses from the grouping object
     */
    ipRevisionFilter?: string;
    /**
     * It Should only be specified if `limit_ip_list_size` is set to true.Limits the max number of pool members to the specified value
     */
    maxIpListSize?: number;
    /**
     * This is member port, The traffic which enter into VIP will get transferto member groups based on the port specified.Depends on the application running on the member VM
     */
    port?: number;
}

export interface VmaasLoadBalancerPoolTag {
    /**
     * scope for Network Load balancer Pool
     */
    scope?: string;
    /**
     * tag for Network Load balancer Pool
     */
    tag?: string;
}

export interface VmaasLoadBalancerProfileClientProfile {
    /**
     * During SSL handshake as part of the SSL client sends an ordered listof ciphers that it can support (or prefers) and typically server selects the first one from the topof that list it can also support.For Perfect Forward Secrecy(PFS), server could override the client's preference
     */
    preferServerCipher?: boolean;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
    /**
     * To allow the SSL client and server to reuse previously negotiated security parameters avoidingthe expensive public key operation during an SSL handshake
     */
    sessionCache?: boolean;
    /**
     * Enter the cache timeout in seconds to specify how long the SSL sessionparameters must be kept and can be reused
     */
    sessionCacheEntryTimeout?: number;
    /**
     * Provide the  Supported values for ssl_suite
     */
    sslSuite: string;
}

export interface VmaasLoadBalancerProfileConfig {
    /**
     * tags Configuration
     */
    tags?: outputs.VmaasLoadBalancerProfileConfigTag[];
}

export interface VmaasLoadBalancerProfileConfigTag {
    /**
     * scope for Network Load balancer Profile
     */
    scope?: string;
    /**
     * tag for Network Load balancer Profile
     */
    tag?: string;
}

export interface VmaasLoadBalancerProfileCookieProfile {
    /**
     * Enter the domain name. HTTP cookie domain can be configured only in the `INSERT` mode
     */
    cookieDomain?: string;
    /**
     * Cookie fallback enabled means,so that the client request is rejectedif cookie points to a server that is in a DISABLED or is in a DOWN state
     */
    cookieFallback?: boolean;
    /**
     * When garbling is disabled, the cookie server IP addressand port information is in a plain text
     */
    cookieGarbling?: boolean;
    /**
     * The cookie persistence mode
     */
    cookieMode: string;
    /**
     * cookie_name for Network Load balancer Profile
     */
    cookieName: string;
    /**
     * Enter the cookie URL path. HTTP cookie path can be set only in the `INSERT` mode
     */
    cookiePath?: string;
    /**
     * Provide the  Supported values for cookie_type
     */
    cookieType: string;
    /**
     * Enter the time in seconds that the cookie type can be idle before a cookie expires
     */
    maxIdleTime?: number;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
    /**
     * Toggle the button to share the persistence so thatall virtual servers this profile is associated with can share the persistence table
     */
    sharePersistence?: boolean;
}

export interface VmaasLoadBalancerProfileGenericProfile {
    /**
     * Toggle the button to synchronize persistence entries to the HA peer.When HA persistence mirroring is enabled,the client IP persistence remains in the case of load balancer failover.
     */
    haPersistenceMirroring?: boolean;
    /**
     * Persistence expiration time in seconds,counted from the time all the connections are completed
     */
    persistenceEntryTimeout?: number;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
    /**
     * Toggle the button to share the persistence sothat all virtual servers this profile is associated with can share the persistence table
     */
    sharePersistence?: boolean;
}

export interface VmaasLoadBalancerProfileHttpProfile {
    /**
     * Timeout in seconds to specify how long an HTTP application can remain idle
     */
    httpIdleTimeout?: number;
    /**
     * Toggle the button for the load balancer to turn off TCP multiplexing and enable HTTP keep-alive.
     */
    ntlmAuthentication?: boolean;
    /**
     * If a website is temporarily down or has moved, incoming requestsfor that virtual server can be temporarily redirected to a URL specified here.
     */
    redirection: string;
    /**
     * Enter value for the maximum size of the buffer used to store the HTTP request body
     */
    requestBodySize?: string;
    /**
     * Specify the maximum buffer size in bytes used to store HTTP request headers
     */
    requestHeaderSize?: number;
    /**
     * Specify the maximum buffer size in bytes used to store HTTP response headers.
     */
    responseHeaderSize?: number;
    /**
     * Number of seconds waiting for the server response before the connection is closed.
     */
    responseTimeout?: number;
    /**
     * Provide the Supported values for serviceTypes
     */
    serviceType: string;
    /**
     * When this value is set, the x_forwarded_for header in the incoming request will be inserted or replaced.
     */
    xForwardedFor: string;
}

export interface VmaasLoadBalancerProfileServerProfile {
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
    /**
     * To allow the SSL client and server to reuse previously negotiated security parameters avoidingthe expensive public key operation during an SSL handshake
     */
    sessionCache: boolean;
    /**
     * Provide the  Supported values for ssl_suite
     */
    sslSuite: string;
}

export interface VmaasLoadBalancerProfileSourceipProfile {
    /**
     * Toggle the button to synchronize persistence entries to the HA peer.When HA persistence mirroring is enabled,the client IP persistence remains in the case of load balancer failover
     */
    haPersistenceMirroring?: boolean;
    /**
     * Persistence expiration time in seconds, counted from the time all the connections are completed
     */
    persistenceEntryTimeout?: number;
    /**
     * When this option is enabled, the oldest entry isdeleted to accept the newest entry in the persistence table
     */
    purgeEntriesWhenFull?: boolean;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
    /**
     * Toggle the button to share the persistence so that all virtual serversthis profile is associated with can share the persistence table
     */
    sharePersistence?: boolean;
}

export interface VmaasLoadBalancerProfileTcpProfile {
    /**
     * Timeout in seconds to specify how long a closed TCP connection
     */
    connectionCloseTimeout?: number;
    /**
     * Timeout in seconds to specify how long an idle TCP connection in ESTABLISHED
     */
    fastTcpIdleTimeout?: number;
    /**
     * Toggle the button to make all the flows to the associated virtual server mirrored to the HA standby node
     */
    haFlowMirroring?: boolean;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
}

export interface VmaasLoadBalancerProfileUdpProfile {
    /**
     * Timeout in seconds to specify how long an idle UDP connection in ESTABLISHED
     */
    fastUdpIdleTimeout?: number;
    /**
     * Toggle the button to make all the flows to the associated virtual server mirrored to the HA standby node
     */
    haFlowMirroring?: boolean;
    /**
     * Provide the  Supported values for serviceType
     */
    serviceType: string;
}

export interface VmaasLoadBalancerVirtualServerCookiePersistenceProfile {
    /**
     * COOKIE persistence_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the COOKIE persistence_profile Id
     */
    persistenceProfile: number;
}

export interface VmaasLoadBalancerVirtualServerHttpApplicationProfile {
    /**
     * HTTP application_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the HTTP application_profile Id
     */
    applicationProfile: number;
}

export interface VmaasLoadBalancerVirtualServerSourceipPersistenceProfile {
    /**
     * SOURCEIP persistence_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the SOURCEIP persistence_profile Id
     */
    persistenceProfile: number;
}

export interface VmaasLoadBalancerVirtualServerSslClientConfig {
    /**
     * ssl_client_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the ssl_client_profile Id
     */
    sslClientProfile: number;
}

export interface VmaasLoadBalancerVirtualServerSslServerConfig {
    /**
     * ssl_server_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the ssl_server_profile Id
     */
    sslServerProfile: number;
}

export interface VmaasLoadBalancerVirtualServerTcpApplicationProfile {
    /**
     * TCP application_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the TCP application_profile Id
     */
    applicationProfile: number;
}

export interface VmaasLoadBalancerVirtualServerUdpApplicationProfile {
    /**
     * UDP application_profile Id, Get the `id` from hpegl.VmaasLoadBalancerProfile datasource to obtain the UDP application_profile Id
     */
    applicationProfile: number;
}

export interface VmaasNetworkDhcpNetwork {
    /**
     * DHCP Server default lease time
     */
    dhcpLeaseTime: string;
    /**
     * DHCP server IP Address range
     */
    dhcpRange: string;
    /**
     * DHCP server ID. Use hpegl.VmaasDhcpServer Data source's `provider_id` here.
     */
    dhcpServer: string;
    /**
     * DHCP Server address and its CIDR. This address must not overlap theip-ranges of the subnet, or the gateway address of the subnet,or the DHCP static-binding addresses of this segment
     */
    dhcpServerAddress?: string;
    /**
     * DHCP Server type. Supported Values is "dhcpLocal"
     */
    dhcpType: string;
}

export interface VmaasNetworkResourcePermissions {
    /**
     * Pass `true` to allow access to all groups.
     */
    all?: boolean;
    /**
     * List of sites/groups
     */
    sites?: outputs.VmaasNetworkResourcePermissionsSite[];
}

export interface VmaasNetworkResourcePermissionsSite {
    /**
     * Group Default Selection
     */
    default?: boolean;
    /**
     * ID of the site/group
     */
    id: number;
}

export interface VmaasNetworkStaticNetwork {
    /**
     * Pool ID can be obtained with hpegl.getVmaasNetworkPool data source.
     */
    poolId?: number;
}

export interface VmaasRouterBgpNeighborConfig {
    /**
     * Source Addresses. This can be retrieved using Network Router Data Source
     */
    sourceAddresses: string[];
}

export interface VmaasRouterInterface {
    cidr: string;
    id: number;
    sourceAddresses: string;
}

export interface VmaasRouterNatRuleConfig {
    /**
     * NAT Rule Type. Supported values are `DNAT` and `SNAT`
     */
    action: string;
    /**
     * Firewall Type. Supported values are : MATCH_EXTERNAL_ADDRESS,
     * 							MATCH_INTERNAL_ADDRESS, BYPASS
     */
    firewall?: string;
    /**
     * Enable/Disable Logging
     */
    logging?: boolean;
    /**
     * Type of the service
     */
    service?: string;
}

export interface VmaasRouterTier0Config {
    bgp: outputs.VmaasRouterTier0ConfigBgp;
    /**
     * Edge Cluster. Use EdgeCluster's provided_id here using EdgeCluster Data Source.
     */
    edgeCluster?: string;
    /**
     * Failover. Available values are 'PREEMPTIVE' or 'NON_PREEMPTIVE'
     */
    failOver?: string;
    /**
     * HA Mode. Available values are 'ACTIVE_ACTIVE' or 'ACTIVE_STANDBY'
     */
    haMode: string;
    routeRedistributionTier0?: outputs.VmaasRouterTier0ConfigRouteRedistributionTier0;
    routeRedistributionTier1?: outputs.VmaasRouterTier0ConfigRouteRedistributionTier1;
}

export interface VmaasRouterTier0ConfigBgp {
    /**
     * ECMP
     */
    ecmp?: boolean;
    enableBgp?: boolean;
    /**
     * Inter SR iBGP
     */
    interSrIbgp?: boolean;
    /**
     * Local AS Number
     */
    localAsNum: number;
    /**
     * Multipath Relax
     */
    multipathRelax?: boolean;
    /**
     * Graceful Restart
     */
    restartMode: string;
    /**
     * Graceful Restart Timer
     */
    restartTime: number;
    /**
     * Graceful Restart Stale Timer
     */
    staleRouteTime: number;
}

export interface VmaasRouterTier0ConfigRouteRedistributionTier0 {
    /**
     * DNS Forwarder IP
     */
    tier0DnsForwarderIp?: boolean;
    /**
     * External Interface Subnet
     */
    tier0ExternalInterface?: boolean;
    /**
     * IP Sec Local IP
     */
    tier0IpsecLocalIp?: boolean;
    /**
     * Loopback Interface Subnet
     */
    tier0LoopbackInterface?: boolean;
    /**
     * NAT IP
     */
    tier0Nat?: boolean;
    /**
     * Connected Segment
     */
    tier0Segment?: boolean;
    /**
     * Service Interface Subnet
     */
    tier0ServiceInterface?: boolean;
    /**
     * Static Routes
     */
    tier0Static?: boolean;
}

export interface VmaasRouterTier0ConfigRouteRedistributionTier1 {
    /**
     * DNS Forwarder IP
     */
    tier1DnsForwarderIp?: boolean;
    /**
     * IPSec Local Endpoint
     */
    tier1IpsecLocalEndpoint?: boolean;
    /**
     * LB SNAT IP
     */
    tier1LbSnat?: boolean;
    /**
     * LB VIP
     */
    tier1LbVip?: boolean;
    /**
     * NAT IP
     */
    tier1Nat?: boolean;
    /**
     * Connected Segment
     */
    tier1Segment?: boolean;
    /**
     * Service Interface Subnet
     */
    tier1ServiceInterface?: boolean;
    /**
     * Static Routes
     */
    tier1Static?: boolean;
}

export interface VmaasRouterTier1Config {
    /**
     * Edge Cluster. Use EdgeCluster's provided_id here using EdgeCluster Data Source.
     */
    edgeCluster?: string;
    /**
     * Failover. Available values are 'PREEMPTIVE' or 'NON_PREEMPTIVE'
     */
    failOver?: string;
    routeAdvertisement?: outputs.VmaasRouterTier1ConfigRouteAdvertisement;
    /**
     * Provider ID of the Tier0 Gateway. Use Tier0 Router's  .provider_id  here.
     */
    tier0Gateway?: string;
}

export interface VmaasRouterTier1ConfigRouteAdvertisement {
    /**
     * Connected Routes
     */
    tier1Connected?: boolean;
    /**
     * DNS Forwarder IP Routes
     */
    tier1DnsForwarderIp?: boolean;
    /**
     * IPSec Local Endpoint
     */
    tier1IpsecLocalEndpoint?: boolean;
    /**
     * LB SNAT IP Routes
     */
    tier1LbSnat?: boolean;
    /**
     * LB VIP Routes
     */
    tier1LbVip?: boolean;
    /**
     * NAT IPs
     */
    tier1Nat?: boolean;
    /**
     * Static Routes
     */
    tier1StaticRoutes?: boolean;
}

export namespace config {
    export interface Caas {
        /**
         * The URL to use for the CaaS API, can also be set with the HPEGL_CAAS_API_URL env var
         */
        apiUrl?: string;
    }

    export interface Metal {
        /**
         * Field indicating whether the token is GreenLake (GLCS or GLP) IAM issued token or Metal Service issued one,
         * 				can also be set with the HPEGL_METAL_GL_TOKEN env-var
         */
        glToken?: boolean;
        /**
         * Field indicating the GLP role to be used, can also be set with the HPEGL_METAL_GLP_ROLE env-var
         */
        glpRole?: string;
        /**
         * Field indicating the GLP workspace to be used, can also be set with the HPEGL_METAL_GLP_WORKSPACE env-var
         */
        glpWorkspace?: string;
        /**
         * The Metal project-id to use, can also be set with the HPEGL_METAL_PROJECT_ID env-var
         */
        projectId?: string;
        /**
         * The Metal portal rest-url to use, can also be set with the HPEGL_METAL_REST_URL env-var
         */
        restUrl?: string;
        /**
         * The space-name to use with Metal, only required for project creation operations,
         * 				can also be set with the HPEGL_METAL_SPACE_NAME env-var
         */
        spaceName?: string;
    }

    export interface Vmaas {
        /**
         * The URL to use for the VMaaS API, can also be set with the HPEGL_VMAAS_API_URL env var
         */
        apiUrl?: string;
        /**
         * Location of GL VMaaS Service, can also be set with the HPEGL_VMAAS_LOCATION env var.
         */
        location?: string;
        /**
         * It can also be set with the HPEGL_VMAAS_SPACE_NAME env var. When `HPEGL_IAM_VERSION` is `glcs` it refers to IAM Space name of the GL VMaaS Service i.e., Default. When `HPEGL_IAM_VERSION` is `glp` it refers to GLP Workspace ID.
         */
        spaceName?: string;
    }

}
