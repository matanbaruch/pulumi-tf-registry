// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DeviceApAeroscout {
    /**
     * whether to enable aeroscout config
     */
    enabled: boolean;
    /**
     * required if enabled, aeroscout server host
     */
    host?: string;
    /**
     * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
     */
    locateConnected: boolean;
}

export interface DeviceApBleConfig {
    /**
     * whether Mist beacons is enabled
     */
    beaconEnabled: boolean;
    /**
     * required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
     */
    beaconRate: number;
    /**
     * enum: `custom`, `default`
     */
    beaconRateMode: string;
    /**
     * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
     */
    beamDisableds?: number[];
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send custom packet
     */
    customBlePacketEnabled: boolean;
    /**
     * The custom frame to be sent out in this beacon. The frame must be a hexstring
     */
    customBlePacketFrame: string;
    /**
     * Frequency (msec) of data emitted by custom ble beacon
     */
    customBlePacketFreqMsec: number;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUidAdvPower: number;
    eddystoneUidBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
     */
    eddystoneUidEnabled: boolean;
    /**
     * Frequency (msec) of data emmit by Eddystone-UID beacon
     */
    eddystoneUidFreqMsec: number;
    /**
     * Eddystone-UID instance for the device
     */
    eddystoneUidInstance: string;
    /**
     * Eddystone-UID namespace
     */
    eddystoneUidNamespace: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUrlAdvPower: number;
    eddystoneUrlBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
     */
    eddystoneUrlEnabled: boolean;
    /**
     * Frequency (msec) of data emit by Eddystone-UID beacon
     */
    eddystoneUrlFreqMsec: number;
    /**
     * URL pointed by Eddystone-URL beacon
     */
    eddystoneUrlUrl: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    ibeaconAdvPower: number;
    ibeaconBeams: string;
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
     */
    ibeaconEnabled: boolean;
    /**
     * Frequency (msec) of data emmit for iBeacon
     */
    ibeaconFreqMsec: number;
    /**
     * Major number for iBeacon
     */
    ibeaconMajor: number;
    /**
     * Minor number for iBeacon
     */
    ibeaconMinor: number;
    /**
     * optional, if not specified, the same UUID as the beacon will be used
     */
    ibeaconUuid: string;
    /**
     * required if `power_mode`==`custom`
     */
    power: number;
    /**
     * enum: `custom`, `default`
     */
    powerMode: string;
}

export interface DeviceApCentrak {
    enabled: boolean;
}

export interface DeviceApClientBridge {
    auth?: outputs.DeviceApClientBridgeAuth;
    /**
     * when acted as client bridge:
     *   * only 5G radio can be used
     *   * will not serve as AP on any radios
     */
    enabled: boolean;
    ssid?: string;
}

export interface DeviceApClientBridgeAuth {
    psk?: string;
    /**
     * wpa2-AES/CCMPp is assumed when `type`==`psk`. enum: `open`, `psk`
     */
    type: string;
}

export interface DeviceApEslConfig {
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    cacert?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    channel?: number;
    /**
     * usb_config is ignored if esl_config enabled
     */
    enabled: boolean;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    host?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    port?: number;
    /**
     * note: ble_config will be ingored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
     */
    type?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    verifyCert?: boolean;
    /**
     * Only if `type`==`solum` or `type`==`hanshow`
     */
    vlanId: number;
}

export interface DeviceApIpConfig {
    /**
     * if `type`==`static`
     */
    dns: string[];
    /**
     * required if `type`==`static`
     */
    dnsSuffixes: string[];
    /**
     * required if `type`==`static`
     */
    gateway?: string;
    gateway6?: string;
    /**
     * required if `type`==`static`
     */
    ip?: string;
    ip6?: string;
    mtu?: number;
    /**
     * required if `type`==`static`
     */
    netmask?: string;
    netmask6?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * enum: `autoconf`, `dhcp`, `disabled`, `static`
     */
    type6: string;
    /**
     * management vlan id, default is 1 (untagged)
     */
    vlanId: number;
}

export interface DeviceApLed {
    brightness: number;
    enabled: boolean;
}

export interface DeviceApMesh {
    /**
     * whether mesh is enabled on this AP
     */
    enabled: boolean;
    /**
     * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
     */
    group?: number;
    /**
     * enum: `base`, `remote`
     */
    role?: string;
}

export interface DeviceApPwrConfig {
    /**
     * additional power to request during negotiating with PSE over PoE, in mW
     */
    base: number;
    /**
     * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
     */
    preferUsbOverWifi: boolean;
}

export interface DeviceApRadioConfig {
    allowRrmDisable: boolean;
    /**
     * antenna gain for 2.4G - for models with external antenna only
     */
    antGain24?: number;
    /**
     * antenna gain for 5G - for models with external antenna only
     */
    antGain5?: number;
    /**
     * antenna gain for 6G - for models with external antenna only
     */
    antGain6?: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * Radio Band AP settings
     */
    band24?: outputs.DeviceApRadioConfigBand24;
    /**
     * enum: `24`, `5`, `6`, `auto`
     */
    band24Usage?: string;
    /**
     * Radio Band AP settings
     */
    band5?: outputs.DeviceApRadioConfigBand5;
    /**
     * Radio Band AP settings
     */
    band5On24Radio?: outputs.DeviceApRadioConfigBand5On24Radio;
    /**
     * Radio Band AP settings
     */
    band6?: outputs.DeviceApRadioConfigBand6;
    /**
     * to make an outdoor operate indoor.
     * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
     */
    indoorUse: boolean;
    /**
     * whether scanning radio is enabled
     */
    scanningEnabled?: boolean;
}

export interface DeviceApRadioConfigBand24 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 2.4GHz band. enum: `20`, `40`
     */
    bandwidth: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface DeviceApRadioConfigBand5 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface DeviceApRadioConfigBand5On24Radio {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface DeviceApRadioConfigBand6 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
     */
    bandwidth: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
    /**
     * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
     */
    standardPower: boolean;
}

export interface DeviceApUplinkPortConfig {
    /**
     * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
     */
    dot1x: boolean;
    /**
     * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
     */
    keepWlansUpIfDown: boolean;
}

export interface DeviceApUsbConfig {
    /**
     * only if `type`==`imagotag`
     */
    cacert?: string;
    /**
     * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
     */
    channel?: number;
    /**
     * whether to enable any usb config
     */
    enabled?: boolean;
    /**
     * only if `type`==`imagotag`
     */
    host?: string;
    /**
     * only if `type`==`imagotag`
     */
    port: number;
    /**
     * usb config type. enum: `hanshow`, `imagotag`, `solum`
     */
    type?: string;
    /**
     * only if `type`==`imagotag`, whether to turn on SSL verification
     */
    verifyCert?: boolean;
    /**
     * only if `type`==`solum` or `type`==`hanshow`
     */
    vlanId: number;
}

export interface DeviceGatewayBgpConfig {
    authKey?: string;
    /**
     * when bfd_multiplier is configured alone. Default:
     *   * 1000 if `type`==`external`
     *   * 350 `type`==`internal`
     */
    bfdMinimumInterval: number;
    /**
     * when bfd_minimum_interval_is_configured alone
     */
    bfdMultiplier: number;
    communities?: outputs.DeviceGatewayBgpConfigCommunity[];
    /**
     * BFD provides faster path failure detection and is enabled by default
     */
    disableBfd: boolean;
    export?: string;
    /**
     * default export policies if no per-neighbor policies defined
     */
    exportPolicy?: string;
    /**
     * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
     * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
     */
    extendedV4Nexthop?: boolean;
    /**
     * `0` means disable
     */
    gracefulRestartTime: number;
    holdTime: number;
    import?: string;
    /**
     * default import policies if no per-neighbor policies defined
     */
    importPolicy?: string;
    localAs?: number;
    neighborAs?: number;
    /**
     * if per-neighbor as is desired. Property key is the neighbor address
     */
    neighbors?: {[key: string]: outputs.DeviceGatewayBgpConfigNeighbors};
    /**
     * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
     */
    networks: string[];
    /**
     * by default, we'll re-advertise all learned BGP routers toward overlay
     */
    noReadvertiseToOverlay: boolean;
    /**
     * enum: `external`, `internal`
     */
    type?: string;
    /**
     * network name. enum: `lan`, `vpn`, `wan`
     */
    via: string;
    vpnName?: string;
    /**
     * if `via`==`wan`
     */
    wanName?: string;
}

export interface DeviceGatewayBgpConfigCommunity {
    id?: string;
    localPreference?: number;
    vpnName?: string;
}

export interface DeviceGatewayBgpConfigNeighbors {
    /**
     * If true, the BGP session to this neighbor will be administratively disabled/shutdown
     */
    disabled: boolean;
    exportPolicy?: string;
    holdTime: number;
    importPolicy?: string;
    /**
     * assuming BGP neighbor is directly connected
     */
    multihopTtl?: number;
    neighborAs?: number;
}

export interface DeviceGatewayClusterNode {
    /**
     * Gateway MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
     */
    mac: string;
}

export interface DeviceGatewayDhcpdConfig {
    config?: {[key: string]: outputs.DeviceGatewayDhcpdConfigConfig};
    /**
     * if set to `true`, enable the DHCP server
     */
    enabled: boolean;
}

export interface DeviceGatewayDhcpdConfigConfig {
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsServers?: string[];
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsSuffixes: string[];
    /**
     * Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
     */
    fixedBindings?: {[key: string]: outputs.DeviceGatewayDhcpdConfigConfigFixedBindings};
    /**
     * if `type`==`local` - optional, `ip` will be used if not provided
     */
    gateway?: string;
    /**
     * if `type`==`local`
     */
    ipEnd?: string;
    /**
     * if `type6`==`local`
     */
    ipEnd6?: string;
    /**
     * if `type`==`local`
     */
    ipStart?: string;
    /**
     * if `type6`==`local`
     */
    ipStart6?: string;
    /**
     * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
     */
    leaseTime: number;
    /**
     * Property key is the DHCP option number
     */
    options?: {[key: string]: outputs.DeviceGatewayDhcpdConfigConfigOptions};
    /**
     * `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
     * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
     */
    serverIdOverride: boolean;
    /**
     * if `type`==`relay`
     */
    servers: string[];
    /**
     * if `type6`==`relay`
     */
    servers6s: string[];
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type: string;
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type6: string;
    /**
     * Property key is <enterprise number>:<sub option code>, with
     *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
     *   * sub option code: 1-255, sub-option code'
     */
    vendorEncapulated?: {[key: string]: outputs.DeviceGatewayDhcpdConfigConfigVendorEncapulated};
}

export interface DeviceGatewayDhcpdConfigConfigFixedBindings {
    ip: string;
    name?: string;
}

export interface DeviceGatewayDhcpdConfigConfigOptions {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface DeviceGatewayDhcpdConfigConfigVendorEncapulated {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface DeviceGatewayExtraRoutes {
    via: string;
}

export interface DeviceGatewayExtraRoutes6 {
    via: string;
}

export interface DeviceGatewayIdpProfiles {
    /**
     * enum: `critical`, `standard`, `strict`
     */
    baseProfile?: string;
    createdTime?: number;
    id?: string;
    modifiedTime?: number;
    name?: string;
    orgId?: string;
    overwrites?: outputs.DeviceGatewayIdpProfilesOverwrite[];
}

export interface DeviceGatewayIdpProfilesOverwrite {
    /**
     * enum:
     *   * alert (default)
     *   * drop: siliently dropping packets
     *   * close: notify client/server to close connection
     */
    action: string;
    matching?: outputs.DeviceGatewayIdpProfilesOverwriteMatching;
    name?: string;
}

export interface DeviceGatewayIdpProfilesOverwriteMatching {
    attackNames?: string[];
    dstSubnets?: string[];
    severities?: string[];
}

export interface DeviceGatewayIpConfigs {
    ip: string;
    netmask: string;
    /**
     * optional list of secondary IPs in CIDR format
     */
    secondaryIps: string[];
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
}

export interface DeviceGatewayNetwork {
    createdTime?: number;
    /**
     * whether to disallow Mist Devices in the network
     */
    disallowMistServices: boolean;
    gateway?: string;
    gateway6?: string;
    id?: string;
    internalAccess?: outputs.DeviceGatewayNetworkInternalAccess;
    /**
     * whether this network has direct internet access
     */
    internetAccess?: outputs.DeviceGatewayNetworkInternetAccess;
    /**
     * whether to allow clients in the network to talk to each other
     */
    isolation?: boolean;
    modifiedTime?: number;
    name: string;
    orgId?: string;
    /**
     * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
     */
    routedForNetworks?: string[];
    subnet: string;
    subnet6?: string;
    tenants?: {[key: string]: outputs.DeviceGatewayNetworkTenants};
    vlanId?: string;
    /**
     * Property key is the VPN name. Whether this network can be accessed from vpn
     */
    vpnAccess?: {[key: string]: outputs.DeviceGatewayNetworkVpnAccess};
}

export interface DeviceGatewayNetworkInternalAccess {
    enabled?: boolean;
}

export interface DeviceGatewayNetworkInternetAccess {
    createSimpleServicePolicy: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat?: {[key: string]: outputs.DeviceGatewayNetworkInternetAccessDestinationNat};
    enabled?: boolean;
    /**
     * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
     */
    restricted: boolean;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat?: {[key: string]: outputs.DeviceGatewayNetworkInternetAccessStaticNat};
}

export interface DeviceGatewayNetworkInternetAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface DeviceGatewayNetworkInternetAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface DeviceGatewayNetworkTenants {
    addresses?: string[];
}

export interface DeviceGatewayNetworkVpnAccess {
    /**
     * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
     */
    advertisedSubnet?: string;
    /**
     * whether to allow ping from vpn into this routed network
     */
    allowPing?: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat: {[key: string]: outputs.DeviceGatewayNetworkVpnAccessDestinationNat};
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
     */
    natPool?: string;
    /**
     * toward LAN-side BGP peers
     */
    noReadvertiseToLanBgp: boolean;
    /**
     * toward LAN-side OSPF peers
     */
    noReadvertiseToLanOspf: boolean;
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    noReadvertiseToOverlay?: boolean;
    /**
     * by default, the routes are only readvertised toward the same vrf on spoke
     * to allow it to be leaked to other vrfs
     */
    otherVrfs: string[];
    /**
     * whether this network is routable
     */
    routed?: boolean;
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
     */
    sourceNat: outputs.DeviceGatewayNetworkVpnAccessSourceNat;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat: {[key: string]: outputs.DeviceGatewayNetworkVpnAccessStaticNat};
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    summarizedSubnet?: string;
    /**
     * toward LAN-side BGP peers
     */
    summarizedSubnetToLanBgp?: string;
    /**
     * toward LAN-side OSPF peers
     */
    summarizedSubnetToLanOspf?: string;
}

export interface DeviceGatewayNetworkVpnAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface DeviceGatewayNetworkVpnAccessSourceNat {
    externalIp?: string;
}

export interface DeviceGatewayNetworkVpnAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface DeviceGatewayOobIpConfig {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    /**
     * if `type`==`static`
     */
    ip?: string;
    /**
     * if `type`==`static`
     */
    netmask?: string;
    /**
     * for HA Cluster, node1 can have different IP Config
     */
    node1?: outputs.DeviceGatewayOobIpConfigNode1;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface DeviceGatewayOobIpConfigNode1 {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface DeviceGatewayPathPreferences {
    paths?: outputs.DeviceGatewayPathPreferencesPath[];
    /**
     * enum: `ecmp`, `ordered`, `weighted`
     */
    strategy: string;
}

export interface DeviceGatewayPathPreferencesPath {
    cost?: number;
    /**
     * For SSR Only. `true`, if this specific path is undesired
     */
    disabled?: boolean;
    /**
     * only if `type`==`local`, if a different gateway is desired
     */
    gatewayIp?: string;
    /**
     * only if `type`==`vpn`, if this vpn path can be used for internet
     */
    internetAccess?: boolean;
    /**
     * required when 
     *   * `type`==`vpn`: the name of the VPN Path to use 
     *   * `type`==`wan`: the name of the WAN interface to use'
     */
    name?: string;
    /**
     * required when `type`==`local`
     */
    networks: string[];
    /**
     * if `type`==`local`, if destination IP is to be replaced
     */
    targetIps: string[];
    /**
     * enum: `local`, `tunnel`, `vpn`, `wan`
     */
    type?: string;
    /**
     * required when`type`==`tunnel`
     */
    wanName?: string;
}

export interface DeviceGatewayPortConfig {
    description?: string;
    disableAutoneg: boolean;
    /**
     * port admin up (true) / down (false)
     */
    disabled: boolean;
    /**
     * if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
     */
    dslType: string;
    /**
     * if `wan_type`==`dsl`
     * 16 bit int
     */
    dslVci: number;
    /**
     * if `wan_type`==`dsl`
     * 8 bit int
     */
    dslVpi: number;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Junos IP Config
     */
    ipConfig?: outputs.DeviceGatewayPortConfigIpConfig;
    /**
     * if `wan_type`==`lte`
     */
    lteApn?: string;
    /**
     * if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
     */
    lteAuth: string;
    lteBackup?: boolean;
    /**
     * if `wan_type`==`lte`
     */
    ltePassword?: string;
    /**
     * if `wan_type`==`lte`
     */
    lteUsername?: string;
    mtu?: number;
    /**
     * name that we'll use to derive config
     */
    name?: string;
    /**
     * if `usage`==`lan`
     */
    networks: string[];
    /**
     * for Q-in-Q
     */
    outerVlanId?: number;
    poeDisabled: boolean;
    /**
     * if `usage`==`lan`
     */
    portNetwork?: string;
    /**
     * whether to preserve dscp when sending traffic over VPN (SSR-only)
     */
    preserveDscp: boolean;
    /**
     * if HA mode
     */
    redundant?: boolean;
    /**
     * if HA mode
     */
    rethIdx?: number;
    /**
     * if HA mode
     */
    rethNode?: string;
    /**
     * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
     */
    rethNodes: string[];
    speed: string;
    /**
     * when SSR is running as VM, this is required on certain hosting platforms
     */
    ssrNoVirtualMac: boolean;
    /**
     * for SSR only
     */
    svrPortRange: string;
    trafficShaping?: outputs.DeviceGatewayPortConfigTrafficShaping;
    /**
     * port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
     */
    usage: string;
    /**
     * if WAN interface is on a VLAN
     */
    vlanId?: number;
    vpnPaths?: {[key: string]: outputs.DeviceGatewayPortConfigVpnPaths};
    /**
     * when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
     */
    wanArpPolicer: string;
    /**
     * optional, if spoke should reach this port by a different IP
     */
    wanExtIp?: string;
    /**
     * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
     */
    wanSourceNat?: outputs.DeviceGatewayPortConfigWanSourceNat;
    /**
     * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
     */
    wanType: string;
}

export interface DeviceGatewayPortConfigIpConfig {
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dns?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dnsSuffixes?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * optional, the network to be used for mgmt
     */
    network?: string;
    /**
     * if `type`==`pppoe`
     */
    poserPassword?: string;
    /**
     * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
     */
    pppoeAuth: string;
    /**
     * if `type`==`pppoe`
     */
    pppoeUsername?: string;
    /**
     * enum: `dhcp`, `pppoe`, `static`
     */
    type: string;
}

export interface DeviceGatewayPortConfigTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface DeviceGatewayPortConfigVpnPaths {
    /**
     * enum: `broadband`, `lte`
     */
    bfdProfile: string;
    /**
     * whether to use tunnel mode. SSR only
     */
    bfdUseTunnelMode: boolean;
    /**
     * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
     */
    preference?: number;
    /**
     * enum: `hub`, `spoke`
     */
    role: string;
    trafficShaping?: outputs.DeviceGatewayPortConfigVpnPathsTrafficShaping;
}

export interface DeviceGatewayPortConfigVpnPathsTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface DeviceGatewayPortConfigWanSourceNat {
    /**
     * or to disable the source-nat
     */
    disabled: boolean;
    /**
     * if alternative nat_pool is desired
     */
    natPool?: string;
}

export interface DeviceGatewayPortMirroring {
    portMirror?: outputs.DeviceGatewayPortMirroringPortMirror;
}

export interface DeviceGatewayPortMirroringPortMirror {
    familyType?: string;
    ingressPortIds?: string[];
    outputPortId?: string;
    rate?: number;
    runLength?: number;
}

export interface DeviceGatewayRoutingPolicies {
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    terms?: outputs.DeviceGatewayRoutingPoliciesTerm[];
}

export interface DeviceGatewayRoutingPoliciesTerm {
    /**
     * when used as import policy
     */
    action?: outputs.DeviceGatewayRoutingPoliciesTermAction;
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    matching?: outputs.DeviceGatewayRoutingPoliciesTermMatching;
}

export interface DeviceGatewayRoutingPoliciesTermAction {
    accept?: boolean;
    addCommunities?: string[];
    /**
     * for SSR, hub decides how VRF routes are leaked on spoke
     */
    addTargetVrfs?: string[];
    /**
     * when used as export policy, optional
     */
    communities?: string[];
    /**
     * when used as export policy, optional. To exclude certain AS
     */
    excludeAsPaths?: string[];
    excludeCommunities?: string[];
    /**
     * when used as export policy, optional
     */
    exportCommunitites?: string[];
    /**
     * optional, for an import policy, local_preference can be changed
     */
    localPreference?: string;
    /**
     * when used as export policy, optional. By default, the local AS will be prepended, to change it
     */
    prependAsPaths?: string[];
}

export interface DeviceGatewayRoutingPoliciesTermMatching {
    /**
     * takes regular expression
     */
    asPaths?: string[];
    communities?: string[];
    networks?: string[];
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    prefixes?: string[];
    /**
     * `direct`, `bgp`, `osp`, ...
     */
    protocols?: string[];
    routeExists?: outputs.DeviceGatewayRoutingPoliciesTermMatchingRouteExists;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     */
    vpnNeighborMacs?: string[];
    vpnPathSla?: outputs.DeviceGatewayRoutingPoliciesTermMatchingVpnPathSla;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     * ordered-
     */
    vpnPaths?: string[];
}

export interface DeviceGatewayRoutingPoliciesTermMatchingRouteExists {
    route?: string;
    /**
     * name of the vrf instance
     * it can also be the name of the VPN or wan if they
     */
    vrfName: string;
}

export interface DeviceGatewayRoutingPoliciesTermMatchingVpnPathSla {
    maxJitter?: number;
    maxLatency?: number;
    maxLoss?: number;
}

export interface DeviceGatewayServicePolicy {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    /**
     * For SRX Only
     */
    appqoe?: outputs.DeviceGatewayServicePolicyAppqoe;
    ewfs?: outputs.DeviceGatewayServicePolicyEwf[];
    idp?: outputs.DeviceGatewayServicePolicyIdp;
    /**
     * access within the same VRF
     */
    localRouting: boolean;
    name?: string;
    /**
     * by default, we derive all paths available and use them
     * optionally, you can customize by using `path_preference`
     */
    pathPreference?: string;
    /**
     * used to link servicepolicy defined at org level and overwrite some attributes
     */
    servicepolicyId?: string;
    services: string[];
    tenants: string[];
}

export interface DeviceGatewayServicePolicyAppqoe {
    enabled: boolean;
}

export interface DeviceGatewayServicePolicyEwf {
    alertOnly?: boolean;
    blockMessage?: string;
    enabled: boolean;
    /**
     * enum: `critical`, `standard`, `strict`
     */
    profile: string;
}

export interface DeviceGatewayServicePolicyIdp {
    alertOnly?: boolean;
    enabled: boolean;
    /**
     * org_level IDP Profile can be used, this takes precedence over `profile`
     */
    idpprofileId?: string;
    /**
     * `strict` (default) / `standard` / or keys from from idp_profiles
     */
    profile: string;
}

export interface DeviceGatewayTunnelConfigs {
    autoProvision?: outputs.DeviceGatewayTunnelConfigsAutoProvision;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    ikeLifetime?: number;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
     */
    ikeMode: string;
    /**
     * if `provider`== `custom-ipsec`
     */
    ikeProposals?: outputs.DeviceGatewayTunnelConfigsIkeProposal[];
    /**
     * if `provider`== `custom-ipsec`
     */
    ipsecLifetime?: number;
    /**
     * Only if  `provider`== `custom-ipsec`
     */
    ipsecProposals?: outputs.DeviceGatewayTunnelConfigsIpsecProposal[];
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    localId?: string;
    /**
     * enum: `active-active`, `active-standby`
     */
    mode: string;
    primary?: outputs.DeviceGatewayTunnelConfigsPrimary;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    probe?: outputs.DeviceGatewayTunnelConfigsProbe;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
     */
    protocol?: string;
    /**
     * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
     */
    provider?: string;
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    psk?: string;
    secondary?: outputs.DeviceGatewayTunnelConfigsSecondary;
    /**
     * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
     */
    version: string;
}

export interface DeviceGatewayTunnelConfigsAutoProvision {
    enable?: boolean;
    latlng?: outputs.DeviceGatewayTunnelConfigsAutoProvisionLatlng;
    primary?: outputs.DeviceGatewayTunnelConfigsAutoProvisionPrimary;
    /**
     * enum: `APAC`, `Americas`, `EMEA`, `auto`
     */
    region: string;
    secondary?: outputs.DeviceGatewayTunnelConfigsAutoProvisionSecondary;
}

export interface DeviceGatewayTunnelConfigsAutoProvisionLatlng {
    lat: number;
    lng: number;
}

export interface DeviceGatewayTunnelConfigsAutoProvisionPrimary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface DeviceGatewayTunnelConfigsAutoProvisionSecondary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface DeviceGatewayTunnelConfigsIkeProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface DeviceGatewayTunnelConfigsIpsecProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * Only if `provider`== `custom-ipsec`. enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface DeviceGatewayTunnelConfigsPrimary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface DeviceGatewayTunnelConfigsProbe {
    /**
     * how often to trigger the probe
     */
    interval?: number;
    /**
     * number of consecutive misses before declaring the tunnel down
     */
    threshold?: number;
    /**
     * time within which to complete the connectivity check
     */
    timeout?: number;
    /**
     * enum: `http`, `icmp`
     */
    type: string;
}

export interface DeviceGatewayTunnelConfigsSecondary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface DeviceGatewayTunnelProviderOptions {
    /**
     * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
     */
    jse?: outputs.DeviceGatewayTunnelProviderOptionsJse;
    /**
     * for zscaler-ipsec and zscaler-gre
     */
    zscaler?: outputs.DeviceGatewayTunnelProviderOptionsZscaler;
}

export interface DeviceGatewayTunnelProviderOptionsJse {
    name?: string;
    numUsers?: number;
}

export interface DeviceGatewayTunnelProviderOptionsZscaler {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    name?: string;
    /**
     * if `use_xff`==`true`
     */
    subLocations?: outputs.DeviceGatewayTunnelProviderOptionsZscalerSubLocation[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
    /**
     * location uses proxy chaining to forward traffic
     */
    useXff?: boolean;
}

export interface DeviceGatewayTunnelProviderOptionsZscalerSubLocation {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup?: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    subnets?: string[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
}

export interface DeviceGatewayVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface DeviceGatewayVrfInstances {
    networks?: string[];
}

export interface DeviceSwitchAclPolicy {
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    actions?: outputs.DeviceSwitchAclPolicyAction[];
    name?: string;
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    srcTags?: string[];
}

export interface DeviceSwitchAclPolicyAction {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    dstTag?: string;
}

export interface DeviceSwitchAclTags {
    /**
     * required if
     * - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
     * - `type`==`static_gbp` (applying gbp tag against matching conditions)
     */
    gbpTag?: number;
    /**
     * required if 
     * - `type`==`mac`
     * - `type`==`static_gbp` if from matching mac
     */
    macs?: string[];
    /**
     * if:
     *   * `type`==`mac` (optional. default is `any`)
     *   * `type`==`subnet` (optional. default is `any`)
     *   * `type`==`network`
     *   * `type`==`resource` (optional. default is `any`)
     *   * `type`==`static_gbp` if from matching network (vlan)'
     */
    network?: string;
    /**
     * required if:
     *   * `type`==`radius_group`
     *   * `type`==`static_gbp`
     * if from matching radius_group
     */
    radiusGroup?: string;
    /**
     * if `type`==`resource`
     * empty means unrestricted, i.e. any
     */
    specs?: outputs.DeviceSwitchAclTagsSpec[];
    /**
     * if 
     * - `type`==`subnet` 
     * - `type`==`resource` (optional. default is `any`)
     * - `type`==`static_gbp` if from matching subnet
     */
    subnets?: string[];
    /**
     * enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
     */
    type: string;
}

export interface DeviceSwitchAclTagsSpec {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
     */
    protocol: string;
}

export interface DeviceSwitchDhcpSnooping {
    allNetworks?: boolean;
    /**
     * Enable for dynamic ARP inspection check
     */
    enableArpSpoofCheck?: boolean;
    /**
     * Enable for check for forging source IP address
     */
    enableIpSourceGuard?: boolean;
    enabled?: boolean;
    /**
     * if `all_networks`==`false`, list of network with DHCP snooping enabled
     */
    networks?: string[];
}

export interface DeviceSwitchDhcpdConfig {
    config?: {[key: string]: outputs.DeviceSwitchDhcpdConfigConfig};
    /**
     * if set to `true`, enable the DHCP server
     */
    enabled: boolean;
}

export interface DeviceSwitchDhcpdConfigConfig {
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsServers?: string[];
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsSuffixes?: string[];
    /**
     * Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
     */
    fixedBindings?: {[key: string]: outputs.DeviceSwitchDhcpdConfigConfigFixedBindings};
    /**
     * if `type`==`local` - optional, `ip` will be used if not provided
     */
    gateway?: string;
    /**
     * if `type`==`local`
     */
    ipEnd?: string;
    /**
     * if `type6`==`local`
     */
    ipEnd6?: string;
    /**
     * if `type`==`local`
     */
    ipStart?: string;
    /**
     * if `type6`==`local`
     */
    ipStart6?: string;
    /**
     * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
     */
    leaseTime: number;
    /**
     * Property key is the DHCP option number
     */
    options?: {[key: string]: outputs.DeviceSwitchDhcpdConfigConfigOptions};
    /**
     * `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
     * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
     */
    serverIdOverride: boolean;
    /**
     * if `type`==`relay`
     */
    servers?: string[];
    /**
     * if `type6`==`relay`
     */
    servers6s?: string[];
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type: string;
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type6: string;
    /**
     * Property key is <enterprise number>:<sub option code>, with
     *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
     *   * sub option code: 1-255, sub-option code'
     */
    vendorEncapulated?: {[key: string]: outputs.DeviceSwitchDhcpdConfigConfigVendorEncapulated};
}

export interface DeviceSwitchDhcpdConfigConfigFixedBindings {
    ip: string;
    name?: string;
}

export interface DeviceSwitchDhcpdConfigConfigOptions {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface DeviceSwitchDhcpdConfigConfigVendorEncapulated {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface DeviceSwitchEvpnConfig {
    enabled?: boolean;
    /**
     * enum: `access`, `core`, `distribution`
     */
    role?: string;
}

export interface DeviceSwitchExtraRoutes {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.DeviceSwitchExtraRoutesNextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface DeviceSwitchExtraRoutes6 {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.DeviceSwitchExtraRoutes6NextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface DeviceSwitchExtraRoutes6NextQualified {
    metric?: number;
    preference?: number;
}

export interface DeviceSwitchExtraRoutesNextQualified {
    metric?: number;
    preference?: number;
}

export interface DeviceSwitchIpConfig {
    dns: string[];
    dnsSuffixes: string[];
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * the network where this mgmt IP reside, this will be used as default network for outbound-ssh, dns, ntp, dns, tacplus, radius, syslog, snmp
     */
    network?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
}

export interface DeviceSwitchMistNac {
    enabled?: boolean;
    network?: string;
}

export interface DeviceSwitchNetworks {
    /**
     * whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
     * NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
     */
    isolation: boolean;
    isolationVlanId?: string;
    /**
     * optional for pure switching, required when L3 / routing features are used
     */
    subnet?: string;
    vlanId: string;
}

export interface DeviceSwitchOobIpConfig {
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * optional, the network to be used for mgmt
     */
    network?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * f supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
     */
    useMgmtVrfForHostOut: boolean;
}

export interface DeviceSwitchOspfConfig {
    /**
     * OSPF areas to run on this device and the corresponding per-area-specific configs. Property key is the area
     */
    areas?: {[key: string]: outputs.DeviceSwitchOspfConfigAreas};
    /**
     * whether to rung OSPF on this device
     */
    enabled?: boolean;
    /**
     * Bandwidth for calculating metric defaults (9600..4000000000000)
     */
    referenceBandwidth: string;
}

export interface DeviceSwitchOspfConfigAreas {
    /**
     * for a stub/nssa area, where to avoid forwarding type-3 LSA to this area
     */
    noSummary?: boolean;
}

export interface DeviceSwitchOtherIpConfigs {
    /**
     * for EVPN, if anycast is desired
     */
    evpnAnycast: boolean;
    /**
     * required if `type`==`static`
     */
    ip?: string;
    /**
     * required if `type6`==`static`
     */
    ip6?: string;
    /**
     * optional, `subnet` from `network` definition will be used if defined
     */
    netmask?: string;
    /**
     * optional, `subnet` from `network` definition will be used if defined
     */
    netmask6?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * enum: `autoconf`, `dhcp`, `disabled`, `static`
     */
    type6: string;
}

export interface DeviceSwitchPortConfig {
    /**
     * To disable LACP support for the AE interface
     */
    aeDisableLacp?: boolean;
    /**
     * Users could force to use the designated AE name
     */
    aeIdx?: number;
    /**
     * to use fast timeout
     */
    aeLacpSlow: boolean;
    aggregated: boolean;
    /**
     * if want to generate port up/down alarm
     */
    critical?: boolean;
    description?: string;
    /**
     * if `speed` and `duplex` are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Enable dynamic usage for this port. Set to `dynamic` to enable.
     */
    dynamicUsage?: string;
    esilag?: boolean;
    /**
     * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
     */
    mtu: number;
    /**
     * prevent helpdesk to override the port config
     */
    noLocalOverwrite?: boolean;
    poeDisabled: boolean;
    /**
     * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
     */
    speed: string;
    /**
     * port usage name. 
     *
     * If EVPN is used, use `evpn_uplink`or `evpn_downlink`
     */
    usage: string;
}

export interface DeviceSwitchPortMirroring {
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputNetworksIngresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsEgresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsIngresses: string[];
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputNetwork?: string;
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputPortId?: string;
}

export interface DeviceSwitchPortUsages {
    /**
     * Only if `mode`==`trunk` whether to trunk all network/vlans
     */
    allNetworks: boolean;
    /**
     * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
     *
     * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
     */
    allowDhcpd?: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    allowMultipleSupplicants: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDown: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDownForUnkonwnClient: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    description?: string;
    /**
     * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * Only if `mode`!=`dynamic` whether the port is disabled
     */
    disabled: boolean;
    /**
     * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     */
    dynamicVlanNetworks: string[];
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
     */
    enableMacAuth: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    enableQos: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     */
    guestNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
     * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     */
    interSwitchLink: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
     */
    macAuthOnly?: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     */
    macAuthProtocol: string;
    /**
     * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     */
    macLimit: number;
    /**
     * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     */
    mode?: string;
    /**
     * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     */
    mtu?: number;
    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     */
    networks: string[];
    /**
     * Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     */
    persistMac: boolean;
    /**
     * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
     */
    poeDisabled: boolean;
    /**
     * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
     */
    portAuth?: string;
    /**
     * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
     */
    portNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
     */
    reauthInterval: number;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
     */
    rejectedNetwork?: string;
    /**
     * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
     */
    resetDefaultWhen: string;
    /**
     * Only if `mode`==`dynamic`
     */
    rules?: outputs.DeviceSwitchPortUsagesRule[];
    /**
     * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
     */
    speed?: string;
    /**
     * Switch storm control
     * Only if `mode`!=`dynamic`
     */
    stormControl?: outputs.DeviceSwitchPortUsagesStormControl;
    /**
     * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
     */
    stpEdge: boolean;
    /**
     * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     */
    voipNetwork?: string;
}

export interface DeviceSwitchPortUsagesRule {
    equals?: string;
    /**
     * use `equals_any` to match any item in a list
     */
    equalsAnies?: string[];
    /**
     * "[0:3]":"abcdef" > "abc"
     * "split(.)[1]": "a.b.c" > "b"
     * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
     */
    expression?: string;
    /**
     * enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
     */
    src: string;
    /**
     * `port_usage` name
     */
    usage?: string;
}

export interface DeviceSwitchPortUsagesStormControl {
    /**
     * whether to disable storm control on broadcast traffic
     */
    noBroadcast: boolean;
    /**
     * whether to disable storm control on multicast traffic
     */
    noMulticast: boolean;
    /**
     * whether to disable storm control on registered multicast traffic
     */
    noRegisteredMulticast: boolean;
    /**
     * whether to disable storm control on unknown unicast traffic
     */
    noUnknownUnicast: boolean;
    /**
     * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
     */
    percentage: number;
}

export interface DeviceSwitchRadiusConfig {
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    acctInterimInterval: number;
    acctServers?: outputs.DeviceSwitchRadiusConfigAcctServer[];
    authServers?: outputs.DeviceSwitchRadiusConfigAuthServer[];
    /**
     * radius auth session retries
     */
    authServersRetries: number;
    /**
     * radius auth session timeout
     */
    authServersTimeout: number;
    coaEnabled: boolean;
    coaPort: number;
    /**
     * use `network`or `source_ip`
     * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
     */
    network?: string;
    /**
     * use `network`or `source_ip`
     */
    sourceIp?: string;
}

export interface DeviceSwitchRadiusConfigAcctServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Acct port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface DeviceSwitchRadiusConfigAuthServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Auth port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface DeviceSwitchRemoteSyslog {
    archive?: outputs.DeviceSwitchRemoteSyslogArchive;
    console?: outputs.DeviceSwitchRemoteSyslogConsole;
    enabled: boolean;
    files?: outputs.DeviceSwitchRemoteSyslogFile[];
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    network?: string;
    sendToAllServers: boolean;
    servers?: outputs.DeviceSwitchRemoteSyslogServer[];
    /**
     * enum: `millisecond`, `year`, `year millisecond`
     */
    timeFormat?: string;
    users?: outputs.DeviceSwitchRemoteSyslogUser[];
}

export interface DeviceSwitchRemoteSyslogArchive {
    files?: number;
    size?: string;
}

export interface DeviceSwitchRemoteSyslogConsole {
    contents?: outputs.DeviceSwitchRemoteSyslogConsoleContent[];
}

export interface DeviceSwitchRemoteSyslogConsoleContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface DeviceSwitchRemoteSyslogFile {
    archive?: outputs.DeviceSwitchRemoteSyslogFileArchive;
    contents?: outputs.DeviceSwitchRemoteSyslogFileContent[];
    explicitPriority?: boolean;
    file?: string;
    match?: string;
    structuredData?: boolean;
}

export interface DeviceSwitchRemoteSyslogFileArchive {
    files?: number;
    size?: string;
}

export interface DeviceSwitchRemoteSyslogFileContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface DeviceSwitchRemoteSyslogServer {
    contents?: outputs.DeviceSwitchRemoteSyslogServerContent[];
    explicitPriority?: boolean;
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    host?: string;
    match?: string;
    port: number;
    /**
     * enum: `tcp`, `udp`
     */
    protocol: string;
    routingInstance?: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    sourceAddress?: string;
    structuredData?: boolean;
    tag?: string;
}

export interface DeviceSwitchRemoteSyslogServerContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface DeviceSwitchRemoteSyslogUser {
    contents?: outputs.DeviceSwitchRemoteSyslogUserContent[];
    match?: string;
    user?: string;
}

export interface DeviceSwitchRemoteSyslogUserContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface DeviceSwitchSnmpConfig {
    clientLists?: outputs.DeviceSwitchSnmpConfigClientList[];
    contact?: string;
    description?: string;
    enabled: boolean;
    /**
     * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
     */
    engineId?: string;
    location?: string;
    name?: string;
    network: string;
    trapGroups?: outputs.DeviceSwitchSnmpConfigTrapGroup[];
    v2cConfigs?: outputs.DeviceSwitchSnmpConfigV2cConfig[];
    v3Config?: outputs.DeviceSwitchSnmpConfigV3Config;
    views?: outputs.DeviceSwitchSnmpConfigView[];
}

export interface DeviceSwitchSnmpConfigClientList {
    clientListName?: string;
    clients?: string[];
}

export interface DeviceSwitchSnmpConfigTrapGroup {
    categories?: string[];
    /**
     * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
     */
    groupName?: string;
    targets?: string[];
    /**
     * enum: `all`, `v1`, `v2`
     */
    version: string;
}

export interface DeviceSwitchSnmpConfigV2cConfig {
    authorization?: string;
    /**
     * client_list_name here should refer to client_list above
     */
    clientListName?: string;
    communityName?: string;
    /**
     * view name here should be defined in views above
     */
    view?: string;
}

export interface DeviceSwitchSnmpConfigV3Config {
    notifies?: outputs.DeviceSwitchSnmpConfigV3ConfigNotify[];
    notifyFilters?: outputs.DeviceSwitchSnmpConfigV3ConfigNotifyFilter[];
    targetAddresses?: outputs.DeviceSwitchSnmpConfigV3ConfigTargetAddress[];
    targetParameters?: outputs.DeviceSwitchSnmpConfigV3ConfigTargetParameter[];
    usm?: outputs.DeviceSwitchSnmpConfigV3ConfigUsm;
    vacm?: outputs.DeviceSwitchSnmpConfigV3ConfigVacm;
}

export interface DeviceSwitchSnmpConfigV3ConfigNotify {
    name?: string;
    tag?: string;
    /**
     * enum: `inform`, `trap`
     */
    type?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigNotifyFilter {
    contents?: outputs.DeviceSwitchSnmpConfigV3ConfigNotifyFilterContent[];
    profileName?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigNotifyFilterContent {
    include?: boolean;
    oid?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigTargetAddress {
    address?: string;
    addressMask?: string;
    port: number;
    /**
     * <refer to notify tag, can be multiple with blank
     */
    tagList?: string;
    targetAddressName?: string;
    /**
     * refer to notify target parameters name
     */
    targetParameters?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigTargetParameter {
    /**
     * enum: `v1`, `v2c`, `v3`
     */
    messageProcessingModel?: string;
    name?: string;
    /**
     * refer to profile-name in notify_filter
     */
    notifyFilter?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * refer to security_name in usm
     */
    securityName?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigUsm {
    /**
     * enum: `local_engine`, `remote_engine`
     */
    engineType?: string;
    /**
     * required only if `engine_type`==`remote_engine`
     */
    engineid?: string;
    users?: outputs.DeviceSwitchSnmpConfigV3ConfigUsmUser[];
}

export interface DeviceSwitchSnmpConfigV3ConfigUsmUser {
    /**
     * Not required if `authentication_type`==`authentication_none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters.
     */
    authenticationPassword?: string;
    /**
     * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
     */
    authenticationType?: string;
    /**
     * Not required if `encryption_type`==`privacy-none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters
     */
    encryptionPassword?: string;
    /**
     * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
     */
    encryptionType?: string;
    name?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigVacm {
    accesses?: outputs.DeviceSwitchSnmpConfigV3ConfigVacmAccess[];
    securityToGroup?: outputs.DeviceSwitchSnmpConfigV3ConfigVacmSecurityToGroup;
}

export interface DeviceSwitchSnmpConfigV3ConfigVacmAccess {
    groupName?: string;
    prefixLists?: outputs.DeviceSwitchSnmpConfigV3ConfigVacmAccessPrefixList[];
}

export interface DeviceSwitchSnmpConfigV3ConfigVacmAccessPrefixList {
    /**
     * only required if `type`==`context_prefix`
     */
    contextPrefix?: string;
    /**
     * refer to view name
     */
    notifyView?: string;
    /**
     * refer to view name
     */
    readView?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `any`, `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * enum: `context_prefix`, `default_context_prefix`
     */
    type?: string;
    /**
     * refer to view name
     */
    writeView?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigVacmSecurityToGroup {
    contents?: outputs.DeviceSwitchSnmpConfigV3ConfigVacmSecurityToGroupContent[];
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
}

export interface DeviceSwitchSnmpConfigV3ConfigVacmSecurityToGroupContent {
    /**
     * refer to group_name under access
     */
    group?: string;
    securityName?: string;
}

export interface DeviceSwitchSnmpConfigView {
    /**
     * if the root oid configured is included
     */
    include?: boolean;
    oid?: string;
    viewName?: string;
}

export interface DeviceSwitchStpConfig {
    /**
     * enum: `rstp`, `vstp`
     */
    type: string;
}

export interface DeviceSwitchSwitchMgmt {
    configRevert: number;
    /**
     * restrict inbound-traffic to host
     * when enabled, all traffic that is not essential to our operation will be dropped 
     * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
     */
    protectRe?: outputs.DeviceSwitchSwitchMgmtProtectRe;
    rootPassword?: string;
    tacacs?: outputs.DeviceSwitchSwitchMgmtTacacs;
}

export interface DeviceSwitchSwitchMgmtProtectRe {
    /**
     * optionally, services we'll allow
     */
    allowedServices: string[];
    customs?: outputs.DeviceSwitchSwitchMgmtProtectReCustom[];
    /**
     * when enabled, all traffic that is not essential to our operation will be dropped
     * e.g. ntp / dns / traffic to mist will be allowed by default
     *      if dhcpd is enabled, we'll make sure it works
     */
    enabled: boolean;
    /**
     * host/subnets we'll allow traffic to/from
     */
    trustedHosts: string[];
}

export interface DeviceSwitchSwitchMgmtProtectReCustom {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * enum: `any`, `icmp`, `tcp`, `udp`
     */
    protocol: string;
    subnets?: string[];
}

export interface DeviceSwitchSwitchMgmtTacacs {
    acctServers?: outputs.DeviceSwitchSwitchMgmtTacacsAcctServer[];
    /**
     * enum: `admin`, `helpdesk`, `none`, `read`
     */
    defaultRole: string;
    enabled?: boolean;
    /**
     * which network the TACACS server resides
     */
    network?: string;
    tacplusServers?: outputs.DeviceSwitchSwitchMgmtTacacsTacplusServer[];
}

export interface DeviceSwitchSwitchMgmtTacacsAcctServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface DeviceSwitchSwitchMgmtTacacsTacplusServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface DeviceSwitchVirtualChassis {
    /**
     * list of Virtual Chassis members
     */
    members?: outputs.DeviceSwitchVirtualChassisMember[];
    /**
     * to configure whether the VC is preprovisioned or nonprovisioned
     */
    preprovisioned: boolean;
}

export interface DeviceSwitchVirtualChassisMember {
    /**
     * fpc0, same as the mac of device_id
     */
    mac?: string;
    memberId?: number;
    /**
     * Both vc_role master and backup will be matched to routing-engine role in Junos preprovisioned VC config. enum: `backup`, `linecard`, `master`
     */
    vcRole?: string;
}

export interface DeviceSwitchVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface DeviceSwitchVrfInstances {
    networks?: string[];
    /**
     * Property key is the destination CIDR (e.g. "10.0.0.0/8")
     */
    vrfExtraRoutes?: {[key: string]: outputs.DeviceSwitchVrfInstancesVrfExtraRoutes};
}

export interface DeviceSwitchVrfInstancesVrfExtraRoutes {
    /**
     * Next-hop address
     */
    via: string;
}

export interface DeviceSwitchVrrpConfig {
    enabled?: boolean;
    /**
     * Property key is the VRRP name
     */
    groups?: {[key: string]: outputs.DeviceSwitchVrrpConfigGroups};
}

export interface DeviceSwitchVrrpConfigGroups {
    priority?: number;
}

export interface GetConstAppCategoriesConstAppCategory {
    /**
     * Description of the app category
     */
    display: string;
    filters: outputs.GetConstAppCategoriesConstAppCategoryFilters;
    /**
     * List of other App Categories contained by this one
     */
    includes: string[];
    /**
     * Key name of the app category
     */
    key: string;
}

export interface GetConstAppCategoriesConstAppCategoryFilters {
    srxes: string[];
    ssrs: string[];
}

export interface GetConstAppSubCategoriesConstAppSubCategory {
    /**
     * Description of the app subcategory
     */
    display: string;
    /**
     * Key name of the app subcategory
     */
    key: string;
    /**
     * Type of traffic (QoS) of the app subcategory
     */
    trafficType: string;
}

export interface GetConstApplicationsConstApplication {
    appId: boolean;
    appImageUrl: string;
    appProbe: boolean;
    category: string;
    group: string;
    key: string;
    name: string;
    signatureBased: boolean;
    ssrAppId: boolean;
}

export interface GetConstCountriesConstCountry {
    /**
     * country code, in two-character
     */
    alpha2: string;
    certified: boolean;
    name: string;
    /**
     * country code, ISO 3166-1 numeric
     */
    numeric: number;
}

export interface GetConstTrafficTypesConstTrafficType {
    display: string;
    dscp: number;
    failoverPolicy: string;
    maxJitter: number;
    maxLatency: number;
    maxLoss: number;
    name: string;
    trafficClass: string;
}

export interface GetDeviceApStatsDeviceApStat {
    autoPlacement: outputs.GetDeviceApStatsDeviceApStatAutoPlacement;
    autoUpgradeStat: outputs.GetDeviceApStatsDeviceApStatAutoUpgradeStat;
    bleStat: outputs.GetDeviceApStatsDeviceApStatBleStat;
    certExpiry: number;
    configReverted: boolean;
    cpuSystem: number;
    cpuUtil: number;
    createdTime: number;
    deviceprofileId: string;
    /**
     * device environment, including CPU temperature, Ambient temperature, Humidity, Attitude, Pressure, Accelerometers, Magnetometers and vCore Voltage
     */
    envStat: outputs.GetDeviceApStatsDeviceApStatEnvStat;
    eslStat: outputs.GetDeviceApStatsDeviceApStatEslStat;
    extIp: string;
    fwupdate: outputs.GetDeviceApStatsDeviceApStatFwupdate;
    hwRev: string;
    id: string;
    inactiveWiredVlans: number[];
    iotStat: {[key: string]: outputs.GetDeviceApStatsDeviceApStatIotStat};
    ip: string;
    /**
     * IP AP settings
     */
    ipConfig: outputs.GetDeviceApStatsDeviceApStatIpConfig;
    ipStat: outputs.GetDeviceApStatsDeviceApStatIpStat;
    /**
     * l2tp tunnel status (key is the wxtunnel_id)
     */
    l2tpStat: {[key: string]: outputs.GetDeviceApStatsDeviceApStatL2tpStat};
    /**
     * last seen timestamp
     */
    lastSeen: number;
    /**
     * last trouble code of switch
     */
    lastTrouble: outputs.GetDeviceApStatsDeviceApStatLastTrouble;
    /**
     * LED AP settings
     */
    led: outputs.GetDeviceApStatsDeviceApStatLed;
    /**
     * LLDP Stat (neighbor information, power negotiations)
     */
    lldpStat: outputs.GetDeviceApStatsDeviceApStatLldpStat;
    locating: boolean;
    /**
     * whether this AP is considered locked (placement / orientation has been vetted)
     */
    locked: boolean;
    /**
     * device mac
     */
    mac: string;
    mapId: string;
    memUsedKb: number;
    /**
     * Property key is the mesh downlink id (e.g `00000000-0000-0000-1000-5c5b35000010`)
     */
    meshDownlinks: {[key: string]: outputs.GetDeviceApStatsDeviceApStatMeshDownlinks};
    meshUplink: outputs.GetDeviceApStatsDeviceApStatMeshUplink;
    /**
     * device model
     */
    model: string;
    modifiedTime: number;
    mount: string;
    name: string;
    notes: string;
    /**
     * how many wireless clients are currently connected
     */
    numClients: number;
    orgId: string;
    /**
     * Property key is the port name (e.g. `eth0`)
     */
    portStat: {[key: string]: outputs.GetDeviceApStatsDeviceApStatPortStat};
    /**
     * in mW, surplus if positive or deficit if negative
     */
    powerBudget: number;
    /**
     * whether insufficient power
     */
    powerConstrained: boolean;
    /**
     * constrained mode
     */
    powerOpmode: string;
    /**
     * DC Input / PoE 802.3at / PoE 802.3af / LLDP / ? (unknown)
     */
    powerSrc: string;
    radioStat: outputs.GetDeviceApStatsDeviceApStatRadioStat;
    rxBps: number;
    rxBytes: number;
    rxPkts: number;
    /**
     * serial
     */
    serial: string;
    siteId: string;
    status: string;
    switchRedundancy: outputs.GetDeviceApStatsDeviceApStatSwitchRedundancy;
    txBps: number;
    txBytes: number;
    txPkts: number;
    /**
     * how long, in seconds, has the device been up (or rebooted)
     */
    uptime: number;
    usbStat: outputs.GetDeviceApStatsDeviceApStatUsbStat;
    version: string;
    x: number;
    y: number;
}

export interface GetDeviceApStatsDeviceApStatAutoPlacement {
    /**
     * Additional information about auto placements AP data
     */
    info: outputs.GetDeviceApStatsDeviceApStatAutoPlacementInfo;
    /**
     * Flag to represent if AP is recommended as an anchor by auto placement service
     */
    recommendedAnchor: boolean;
    /**
     * Basic Placement Status
     */
    status: string;
    /**
     * Additional info about placement status
     */
    statusDetail: string;
    /**
     * Flag to represent if auto_placement values are currently utilized
     */
    useAutoPlacement: boolean;
    /**
     * X Autoplaced Position in pixels
     */
    x: number;
    /**
     * X Autoplaced Position in meters
     */
    xM: number;
    /**
     * Y Autoplaced Position in pixels
     */
    y: number;
    /**
     * X Autoplaced Position in meters
     */
    yM: number;
}

export interface GetDeviceApStatsDeviceApStatAutoPlacementInfo {
    /**
     * All APs sharing a given cluster number can be placed relative to each other
     */
    clusterNumber: number;
    /**
     * The orientation of an AP
     */
    orientationStats: number;
    /**
     * Coordinates representing a circle where the AP is most likely exists in the event of an inaccurate placement result
     */
    probabilitySurface: outputs.GetDeviceApStatsDeviceApStatAutoPlacementInfoProbabilitySurface;
}

export interface GetDeviceApStatsDeviceApStatAutoPlacementInfoProbabilitySurface {
    /**
     * The radius representing placement uncertainty, measured in pixels
     */
    radius: number;
    /**
     * The radius representing placement uncertainty, measured in meters
     */
    radiusM: number;
    /**
     * Y-coordinate of the potential placement’s center, measured in pixels
     */
    x: number;
}

export interface GetDeviceApStatsDeviceApStatAutoUpgradeStat {
    lastcheck: number;
}

export interface GetDeviceApStatsDeviceApStatBleStat {
    beaconEnabled: boolean;
    beaconRate: number;
    eddystoneUidEnabled: boolean;
    eddystoneUidFreqMsec: number;
    eddystoneUidInstance: string;
    eddystoneUidNamespace: string;
    eddystoneUrlEnabled: boolean;
    /**
     * Frequency (msec) of data emmit by Eddystone-UID beacon
     */
    eddystoneUrlFreqMsec: number;
    eddystoneUrlUrl: string;
    ibeaconEnabled: boolean;
    ibeaconFreqMsec: number;
    ibeaconMajor: number;
    ibeaconMinor: number;
    ibeaconUuid: string;
    major: number;
    minors: number[];
    power: number;
    rxBytes: number;
    rxPkts: number;
    txBytes: number;
    txPkts: number;
    /**
     * resets due to tx hung
     */
    txResets: number;
    uuid: string;
}

export interface GetDeviceApStatsDeviceApStatEnvStat {
    accelX: number;
    accelY: number;
    accelZ: number;
    ambientTemp: number;
    attitude: number;
    cpuTemp: number;
    humidity: number;
    magneX: number;
    magneY: number;
    magneZ: number;
    pressure: number;
    vcoreVoltage: number;
}

export interface GetDeviceApStatsDeviceApStatEslStat {
    channel: number;
    connected: boolean;
    type: string;
    up: boolean;
}

export interface GetDeviceApStatsDeviceApStatFwupdate {
    progress: number;
    status: string;
    statusId: number;
    timestamp: number;
    willRetry: boolean;
}

export interface GetDeviceApStatsDeviceApStatIotStat {
    value: number;
}

export interface GetDeviceApStatsDeviceApStatIpConfig {
    /**
     * if `type`==`static`
     */
    dns: string[];
    /**
     * required if `type`==`static`
     */
    dnsSuffixes: string[];
    /**
     * required if `type`==`static`
     */
    gateway: string;
    gateway6: string;
    /**
     * required if `type`==`static`
     */
    ip: string;
    ip6: string;
    mtu: number;
    /**
     * required if `type`==`static`
     */
    netmask: string;
    netmask6: string;
    type: string;
    type6: string;
    /**
     * management vlan id, default is 1 (untagged)
     */
    vlanId: number;
}

export interface GetDeviceApStatsDeviceApStatIpStat {
    dhcpServer: string;
    dns: string[];
    dnsSuffixes: string[];
    gateway: string;
    gateway6: string;
    ip: string;
    ip6: string;
    ips: {[key: string]: string};
    netmask: string;
    netmask6: string;
}

export interface GetDeviceApStatsDeviceApStatL2tpStat {
    /**
     * list of sessions
     */
    sessions: outputs.GetDeviceApStatsDeviceApStatL2tpStatSession[];
    state: string;
    /**
     * uptime
     */
    uptime: number;
    /**
     * WxlanTunnel ID
     */
    wxtunnelId: string;
}

export interface GetDeviceApStatsDeviceApStatL2tpStatSession {
    /**
     * remote sessions id (dynamically unless Tunnel is said to be static)
     */
    localSid: number;
    /**
     * WxlanTunnel Remote ID (user-configured)
     */
    remoteId: string;
    /**
     * remote sessions id (dynamically unless Tunnel is said to be static)
     */
    remoteSid: number;
    state: string;
}

export interface GetDeviceApStatsDeviceApStatLastTrouble {
    /**
     * Code definitions list at /api/v1/consts/ap_led_status
     */
    code: string;
    timestamp: number;
}

export interface GetDeviceApStatsDeviceApStatLed {
    brightness: number;
    enabled: boolean;
}

export interface GetDeviceApStatsDeviceApStatLldpStat {
    chassisId: string;
    /**
     * whether it support LLDP-MED
     */
    lldpMedSupported: boolean;
    /**
     * switch’s management address (if advertised), can be IPv4, IPv6, or MAC
     */
    mgmtAddr: string;
    mgmtAddrs: string[];
    /**
     * ge-0/0/4
     */
    portDesc: string;
    portId: string;
    /**
     * in mW, provided/allocated by PSE
     */
    powerAllocated: number;
    /**
     * in mW, total power needed by PD
     */
    powerDraw: number;
    /**
     * number of negotiations, if it keeps increasing, we don’t have a stable power
     */
    powerRequestCount: number;
    /**
     * in mW, the current power requested by PD
     */
    powerRequested: number;
    /**
     * description provided by switch
     */
    systemDesc: string;
    /**
     * name of the switch
     */
    systemName: string;
}

export interface GetDeviceApStatsDeviceApStatMeshDownlinks {
    band: string;
    channel: number;
    idleTime: number;
    lastSeen: number;
    proto: string;
    rssi: number;
    rxBps: number;
    rxBytes: number;
    rxPackets: number;
    rxRate: number;
    rxRetries: number;
    siteId: string;
    snr: number;
    txBps: number;
    txBytes: number;
    txPackets: number;
    txRate: number;
    txRetries: number;
}

export interface GetDeviceApStatsDeviceApStatMeshUplink {
    band: string;
    channel: number;
    idleTime: number;
    lastSeen: number;
    proto: string;
    rssi: number;
    rxBps: number;
    rxBytes: number;
    rxPackets: number;
    rxRate: number;
    rxRetries: number;
    siteId: string;
    snr: number;
    txBps: number;
    txBytes: number;
    txPackets: number;
    txRate: number;
    txRetries: number;
    uplinkApId: string;
}

export interface GetDeviceApStatsDeviceApStatPortStat {
    fullDuplex: boolean;
    rxBytes: number;
    rxErrors: number;
    rxPkts: number;
    speed: number;
    txBytes: number;
    txPkts: number;
    up: boolean;
}

export interface GetDeviceApStatsDeviceApStatRadioStat {
    /**
     * radio stat
     */
    band24: outputs.GetDeviceApStatsDeviceApStatRadioStatBand24;
    /**
     * radio stat
     */
    band5: outputs.GetDeviceApStatsDeviceApStatRadioStatBand5;
    /**
     * radio stat
     */
    band6: outputs.GetDeviceApStatsDeviceApStatRadioStatBand6;
}

export interface GetDeviceApStatsDeviceApStatRadioStatBand24 {
    /**
     * channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6
     */
    bandwidth: number;
    /**
     * current channel the radio is running on
     */
    channel: number;
    /**
     * Use dynamic chaining for downlink
     */
    dynamicChainingEnalbed: boolean;
    /**
     * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
     */
    mac: string;
    noiseFloor: number;
    numClients: number;
    /**
     * transmit power (in dBm)
     */
    power: number;
    rxBytes: number;
    rxPkts: number;
    txBytes: number;
    txPkts: number;
    usage: string;
    /**
     * all utilization in percentage
     */
    utilAll: number;
    /**
     * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
     */
    utilNonWifi: number;
    /**
     * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
     */
    utilRxInBss: number;
    /**
     * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
     */
    utilRxOtherBss: number;
    /**
     * transmission utilization in percentage
     */
    utilTx: number;
    /**
     * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
     */
    utilUndecodableWifi: number;
    /**
     * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
     */
    utilUnknownWifi: number;
}

export interface GetDeviceApStatsDeviceApStatRadioStatBand5 {
    /**
     * channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6
     */
    bandwidth: number;
    /**
     * current channel the radio is running on
     */
    channel: number;
    /**
     * Use dynamic chaining for downlink
     */
    dynamicChainingEnalbed: boolean;
    /**
     * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
     */
    mac: string;
    noiseFloor: number;
    numClients: number;
    /**
     * transmit power (in dBm)
     */
    power: number;
    rxBytes: number;
    rxPkts: number;
    txBytes: number;
    txPkts: number;
    usage: string;
    /**
     * all utilization in percentage
     */
    utilAll: number;
    /**
     * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
     */
    utilNonWifi: number;
    /**
     * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
     */
    utilRxInBss: number;
    /**
     * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
     */
    utilRxOtherBss: number;
    /**
     * transmission utilization in percentage
     */
    utilTx: number;
    /**
     * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
     */
    utilUndecodableWifi: number;
    /**
     * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
     */
    utilUnknownWifi: number;
}

export interface GetDeviceApStatsDeviceApStatRadioStatBand6 {
    /**
     * channel width for the band * `80` is only applicable for band_5 and band_6 * `160` is only for band_6
     */
    bandwidth: number;
    /**
     * current channel the radio is running on
     */
    channel: number;
    /**
     * Use dynamic chaining for downlink
     */
    dynamicChainingEnalbed: boolean;
    /**
     * radio (base) mac, it can have 16 bssids (e.g. 5c5b350001a0-5c5b350001af)
     */
    mac: string;
    noiseFloor: number;
    numClients: number;
    /**
     * transmit power (in dBm)
     */
    power: number;
    rxBytes: number;
    rxPkts: number;
    txBytes: number;
    txPkts: number;
    usage: string;
    /**
     * all utilization in percentage
     */
    utilAll: number;
    /**
     * reception of “No Packets” utilization in percentage, received frames with invalid PLCPs and CRS glitches as noise
     */
    utilNonWifi: number;
    /**
     * reception of “In BSS” utilization in percentage, only frames that are received from AP/STAs within the BSS
     */
    utilRxInBss: number;
    /**
     * reception of “Other BSS” utilization in percentage, all frames received from AP/STAs that are outside the BSS
     */
    utilRxOtherBss: number;
    /**
     * transmission utilization in percentage
     */
    utilTx: number;
    /**
     * reception of “UnDecodable Wifi“ utilization in percentage, only Preamble, PLCP header is decoded, Rest is undecodable in this radio
     */
    utilUndecodableWifi: number;
    /**
     * reception of “No Category” utilization in percentage, all 802.11 frames that are corrupted at the receiver
     */
    utilUnknownWifi: number;
}

export interface GetDeviceApStatsDeviceApStatSwitchRedundancy {
    numRedundantAps: number;
}

export interface GetDeviceApStatsDeviceApStatUsbStat {
    channel: number;
    connected: boolean;
    lastActivity: number;
    type: string;
    up: boolean;
}

export interface GetDeviceGatewayStatsDeviceGatewayStat {
    apRedundancy: outputs.GetDeviceGatewayStatsDeviceGatewayStatApRedundancy;
    arpTableStats: outputs.GetDeviceGatewayStatsDeviceGatewayStatArpTableStats;
    certExpiry: number;
    clusterConfig: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterConfig;
    clusterStat: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterStat;
    conductorName: string;
    configStatus: string;
    cpu2Stat: outputs.GetDeviceGatewayStatsDeviceGatewayStatCpu2Stat;
    cpuStat: outputs.GetDeviceGatewayStatsDeviceGatewayStatCpuStat;
    createdTime: number;
    deviceprofileId: string;
    /**
     * Property key is the network name
     */
    dhcpd2Stat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatDhcpd2Stat};
    /**
     * Property key is the network name
     */
    dhcpdStat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatDhcpdStat};
    /**
     * IP address
     */
    extIp: string;
    fwupdate: outputs.GetDeviceGatewayStatsDeviceGatewayStatFwupdate;
    hasPcap: boolean;
    /**
     * hostname reported by the device
     */
    hostname: string;
    /**
     * serial
     */
    id: string;
    /**
     * Property key is the interface name
     */
    if2Stat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatIf2Stat};
    /**
     * Property key is the interface name
     */
    ifStat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatIfStat};
    /**
     * IP address
     */
    ip: string;
    ip2Stat: outputs.GetDeviceGatewayStatsDeviceGatewayStatIp2Stat;
    ipStat: outputs.GetDeviceGatewayStatsDeviceGatewayStatIpStat;
    isHa: boolean;
    /**
     * last seen timestamp
     */
    lastSeen: number;
    /**
     * device mac
     */
    mac: string;
    /**
     * serial
     */
    mapId: string;
    /**
     * memory usage stat (for virtual chassis, memory usage of master RE)
     */
    memory2Stat: outputs.GetDeviceGatewayStatsDeviceGatewayStatMemory2Stat;
    /**
     * memory usage stat (for virtual chassis, memory usage of master RE)
     */
    memoryStat: outputs.GetDeviceGatewayStatsDeviceGatewayStatMemoryStat;
    /**
     * device model
     */
    model: string;
    modifiedTime: number;
    module2Stats: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2Stat[];
    moduleStats: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStat[];
    /**
     * device name if configured
     */
    name: string;
    nodeName: string;
    /**
     * serial
     */
    orgId: string;
    routeSummaryStats: outputs.GetDeviceGatewayStatsDeviceGatewayStatRouteSummaryStats;
    /**
     * device name if configured
     */
    routerName: string;
    /**
     * serial
     */
    serial: string;
    service2Stat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatService2Stat};
    serviceStat: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatServiceStat};
    serviceStatus: outputs.GetDeviceGatewayStatsDeviceGatewayStatServiceStatus;
    /**
     * serial
     */
    siteId: string;
    spu2Stats: outputs.GetDeviceGatewayStatsDeviceGatewayStatSpu2Stat[];
    spuStats: outputs.GetDeviceGatewayStatsDeviceGatewayStatSpuStat[];
    status: string;
    uptime: number;
    version: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatApRedundancy {
    /**
     * Property key is the node id
     */
    modules: {[key: string]: outputs.GetDeviceGatewayStatsDeviceGatewayStatApRedundancyModules};
    numAps: number;
    numApsWithSwitchRedundancy: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatApRedundancyModules {
    numAps: number;
    numApsWithSwitchRedundancy: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatArpTableStats {
    arpTableCount: number;
    maxEntriesSupported: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterConfig {
    configuration: string;
    controlLinkInfo: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfo;
    ethernetConnections: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterConfigEthernetConnection[];
    fabricLinkInfo: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfo;
    lastStatusChangeReason: string;
    operational: string;
    primaryNodeHealth: string;
    redundancyGroupInformations: outputs.GetDeviceGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformation[];
    secondaryNodeHealth: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterConfigControlLinkInfo {
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterConfigEthernetConnection {
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterConfigFabricLinkInfo {
    dataPlaneNotifiedStatus: string;
    interfaces: string[];
    internalStatus: string;
    state: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterConfigRedundancyGroupInformation {
    id: number;
    monitoringFailure: string;
    threshold: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatClusterStat {
    state: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatCpu2Stat {
    /**
     * Percentage of CPU time that is idle
     */
    idle: number;
    /**
     * Percentage of CPU time being used by interrupts
     */
    interrupt: number;
    /**
     * Load averages for the last 1, 5, and 15 minutes
     */
    loadAvgs: number[];
    /**
     * Percentage of CPU time being used by system processes
     */
    system: number;
    /**
     * Percentage of CPU time being used by user processe
     */
    user: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatCpuStat {
    /**
     * Percentage of CPU time that is idle
     */
    idle: number;
    /**
     * Percentage of CPU time being used by interrupts
     */
    interrupt: number;
    /**
     * Load averages for the last 1, 5, and 15 minutes
     */
    loadAvgs: number[];
    /**
     * Percentage of CPU time being used by system processes
     */
    system: number;
    /**
     * Percentage of CPU time being used by user processe
     */
    user: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatDhcpd2Stat {
    numIps: number;
    numLeased: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatDhcpdStat {
    numIps: number;
    numLeased: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatFwupdate {
    progress: number;
    status: string;
    statusId: number;
    timestamp: number;
    willRetry: boolean;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIf2Stat {
    addressMode: string;
    ips: string[];
    natAddresses: string[];
    networkName: string;
    portId: string;
    portUsage: string;
    redundancyState: string;
    rxBytes: number;
    rxPkts: number;
    servpInfo: outputs.GetDeviceGatewayStatsDeviceGatewayStatIf2StatServpInfo;
    txBytes: number;
    txPkts: number;
    up: boolean;
    vlan: number;
    wanName: string;
    wanType: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIf2StatServpInfo {
    asn: string;
    city: string;
    countryCode: string;
    latitude: number;
    longitude: number;
    org: string;
    regionCode: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIfStat {
    addressMode: string;
    ips: string[];
    natAddresses: string[];
    networkName: string;
    portId: string;
    portUsage: string;
    redundancyState: string;
    rxBytes: number;
    rxPkts: number;
    servpInfo: outputs.GetDeviceGatewayStatsDeviceGatewayStatIfStatServpInfo;
    txBytes: number;
    txPkts: number;
    up: boolean;
    vlan: number;
    wanName: string;
    wanType: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIfStatServpInfo {
    asn: string;
    city: string;
    countryCode: string;
    latitude: number;
    longitude: number;
    org: string;
    regionCode: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIp2Stat {
    dhcpServer: string;
    dns: string[];
    dnsSuffixes: string[];
    gateway: string;
    gateway6: string;
    ip: string;
    ip6: string;
    ips: {[key: string]: string};
    netmask: string;
    netmask6: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatIpStat {
    dhcpServer: string;
    dns: string[];
    dnsSuffixes: string[];
    gateway: string;
    gateway6: string;
    ip: string;
    ip6: string;
    ips: {[key: string]: string};
    netmask: string;
    netmask6: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatMemory2Stat {
    usage: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatMemoryStat {
    usage: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2Stat {
    backupVersion: string;
    biosVersion: string;
    cpldVersion: string;
    /**
     * used to report all error states the device node is running into.
     * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
     */
    errors: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatError[];
    fans: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatFan[];
    fpgaVersion: string;
    lastSeen: number;
    model: string;
    opticsCpldVersion: string;
    pendingVersion: string;
    pics: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatPic[];
    poe: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatPoe;
    poeVersion: string;
    powerCpldVersion: string;
    psuses: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatPsus[];
    reFpgaVersion: string;
    recoveryVersion: string;
    serial: string;
    status: string;
    temperatures: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatTemperature[];
    tmcFpgaVersion: string;
    ubootVersion: string;
    uptime: number;
    vcLinks: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatVcLink[];
    vcMode: string;
    /**
     * master / backup / linecard
     */
    vcRole: string;
    vcState: string;
    version: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatError {
    feature: string;
    minimumVersion: string;
    reason: string;
    since: number;
    type: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatFan {
    airflow: string;
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatPic {
    index: number;
    modelNumber: string;
    portGroups: outputs.GetDeviceGatewayStatsDeviceGatewayStatModule2StatPicPortGroup[];
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatPicPortGroup {
    count: number;
    type: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatPoe {
    maxPower: number;
    powerDraw: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatPsus {
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatTemperature {
    celsius: number;
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModule2StatVcLink {
    neighborModuleIdx: number;
    neighborPortId: string;
    portId: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStat {
    backupVersion: string;
    biosVersion: string;
    cpldVersion: string;
    /**
     * used to report all error states the device node is running into.
     * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
     */
    errors: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatError[];
    fans: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatFan[];
    fpgaVersion: string;
    lastSeen: number;
    model: string;
    opticsCpldVersion: string;
    pendingVersion: string;
    pics: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatPic[];
    poe: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatPoe;
    poeVersion: string;
    powerCpldVersion: string;
    psuses: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatPsus[];
    reFpgaVersion: string;
    recoveryVersion: string;
    serial: string;
    status: string;
    temperatures: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatTemperature[];
    tmcFpgaVersion: string;
    ubootVersion: string;
    uptime: number;
    vcLinks: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatVcLink[];
    vcMode: string;
    /**
     * master / backup / linecard
     */
    vcRole: string;
    vcState: string;
    version: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatError {
    feature: string;
    minimumVersion: string;
    reason: string;
    since: number;
    type: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatFan {
    airflow: string;
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatPic {
    index: number;
    modelNumber: string;
    portGroups: outputs.GetDeviceGatewayStatsDeviceGatewayStatModuleStatPicPortGroup[];
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatPicPortGroup {
    count: number;
    type: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatPoe {
    maxPower: number;
    powerDraw: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatPsus {
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatTemperature {
    celsius: number;
    name: string;
    status: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatModuleStatVcLink {
    neighborModuleIdx: number;
    neighborPortId: string;
    portId: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatRouteSummaryStats {
    fibRoutes: number;
    maxUnicastRoutesSupported: number;
    ribRoutes: number;
    totalRoutes: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatService2Stat {
    ashVersion: string;
    ciaVersion: string;
    emberVersion: string;
    ipsecClientVersion: string;
    mistAgentVersion: string;
    packageVersion: string;
    testingToolsVersion: string;
    wheeljackVersion: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatServiceStat {
    ashVersion: string;
    ciaVersion: string;
    emberVersion: string;
    ipsecClientVersion: string;
    mistAgentVersion: string;
    packageVersion: string;
    testingToolsVersion: string;
    wheeljackVersion: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatServiceStatus {
    appidInstallResult: string;
    appidInstallTimestamp: string;
    appidStatus: string;
    appidVersion: number;
    ewfStatus: string;
    idpInstallResult: string;
    idpInstallTimestamp: string;
    idpPolicy: string;
    idpStatus: string;
    idpUpdateTimestamp: string;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatSpu2Stat {
    spuCpu: number;
    spuCurrentSession: number;
    spuMaxSession: number;
    spuMemory: number;
    spuPendingSession: number;
    spuValidSession: number;
}

export interface GetDeviceGatewayStatsDeviceGatewayStatSpuStat {
    spuCpu: number;
    spuCurrentSession: number;
    spuMaxSession: number;
    spuMemory: number;
    spuPendingSession: number;
    spuValidSession: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStat {
    apRedundancy: outputs.GetDeviceSwitchStatsDeviceSwitchStatApRedundancy;
    arpTableStats: outputs.GetDeviceSwitchStatsDeviceSwitchStatArpTableStats;
    certExpiry: number;
    clients: outputs.GetDeviceSwitchStatsDeviceSwitchStatClient[];
    clientsStats: outputs.GetDeviceSwitchStatsDeviceSwitchStatClientsStats;
    configStatus: string;
    cpuStat: outputs.GetDeviceSwitchStatsDeviceSwitchStatCpuStat;
    createdTime: number;
    deviceprofileId: string;
    /**
     * Property key is the network name
     */
    dhcpdStat: {[key: string]: outputs.GetDeviceSwitchStatsDeviceSwitchStatDhcpdStat};
    evpntopoId: string;
    fwVersionsOutofsync: boolean;
    fwupdate: outputs.GetDeviceSwitchStatsDeviceSwitchStatFwupdate;
    /**
     * whether the switch supports packet capture
     */
    hasPcap: boolean;
    /**
     * hostname reported by the device
     */
    hostname: string;
    /**
     * device hardware revision number
     */
    hwRev: string;
    id: string;
    /**
     * Property key is the interface name
     */
    ifStat: {[key: string]: outputs.GetDeviceSwitchStatsDeviceSwitchStatIfStat};
    ip: string;
    ipStat: outputs.GetDeviceSwitchStatsDeviceSwitchStatIpStat;
    lastSeen: number;
    /**
     * last trouble code of switch
     */
    lastTrouble: outputs.GetDeviceSwitchStatsDeviceSwitchStatLastTrouble;
    mac: string;
    macTableStats: outputs.GetDeviceSwitchStatsDeviceSwitchStatMacTableStats;
    mapId: string;
    /**
     * memory usage stat (for virtual chassis, memory usage of master RE)
     */
    memoryStat: outputs.GetDeviceSwitchStatsDeviceSwitchStatMemoryStat;
    model: string;
    modifiedTime: number;
    moduleStats: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStat[];
    /**
     * device name if configured
     */
    name: string;
    orgId: string;
    routeSummaryStats: outputs.GetDeviceSwitchStatsDeviceSwitchStatRouteSummaryStats;
    serial: string;
    serviceStat: {[key: string]: outputs.GetDeviceSwitchStatsDeviceSwitchStatServiceStat};
    siteId: string;
    status: string;
    uptime: number;
    vcMac: string;
    vcSetupInfo: outputs.GetDeviceSwitchStatsDeviceSwitchStatVcSetupInfo;
    version: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatApRedundancy {
    /**
     * for a VC / stacked switches.
     */
    modules: {[key: string]: outputs.GetDeviceSwitchStatsDeviceSwitchStatApRedundancyModules};
    numAps: number;
    numApsWithSwitchRedundancy: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatApRedundancyModules {
    numAps: number;
    numApsWithSwitchRedundancy: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatArpTableStats {
    arpTableCount: number;
    maxEntriesSupported: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatClient {
    deviceMac: string;
    hostname: string;
    mac: string;
    portId: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatClientsStats {
    total: outputs.GetDeviceSwitchStatsDeviceSwitchStatClientsStatsTotal;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatClientsStatsTotal {
    numAps: number[];
    numWiredClients: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatCpuStat {
    /**
     * Percentage of CPU time that is idle
     */
    idle: number;
    /**
     * Percentage of CPU time being used by interrupts
     */
    interrupt: number;
    /**
     * Load averages for the last 1, 5, and 15 minutes
     */
    loadAvgs: number[];
    /**
     * Percentage of CPU time being used by system processes
     */
    system: number;
    /**
     * Percentage of CPU time being used by user processe
     */
    user: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatDhcpdStat {
    numIps: number;
    numLeased: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatFwupdate {
    progress: number;
    status: string;
    statusId: number;
    timestamp: number;
    willRetry: boolean;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatIfStat {
    addressMode: string;
    ips: string[];
    natAddresses: string[];
    networkName: string;
    portId: string;
    portUsage: string;
    redundancyState: string;
    rxBytes: number;
    rxPkts: number;
    servpInfo: outputs.GetDeviceSwitchStatsDeviceSwitchStatIfStatServpInfo;
    txBytes: number;
    txPkts: number;
    up: boolean;
    vlan: number;
    wanName: string;
    wanType: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatIfStatServpInfo {
    asn: string;
    city: string;
    countryCode: string;
    latitude: number;
    longitude: number;
    org: string;
    regionCode: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatIpStat {
    dhcpServer: string;
    dns: string[];
    dnsSuffixes: string[];
    gateway: string;
    gateway6: string;
    ip: string;
    ip6: string;
    ips: {[key: string]: string};
    netmask: string;
    netmask6: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatLastTrouble {
    /**
     * Code definitions list at /api/v1/consts/ap_led_status
     */
    code: string;
    timestamp: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatMacTableStats {
    macTableCount: number;
    maxMacEntriesSupported: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatMemoryStat {
    usage: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStat {
    backupVersion: string;
    biosVersion: string;
    cpldVersion: string;
    /**
     * used to report all error states the device node is running into.
     * An error should always have `type` and `since` fields, and could have some other fields specific to that type.
     */
    errors: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatError[];
    fans: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatFan[];
    fpcIdx: number;
    fpgaVersion: string;
    lastSeen: number;
    model: string;
    opticsCpldVersion: string;
    pendingVersion: string;
    pics: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatPic[];
    poe: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatPoe;
    poeVersion: string;
    powerCpldVersion: string;
    psuses: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatPsus[];
    reFpgaVersion: string;
    recoveryVersion: string;
    serial: string;
    status: string;
    temperatures: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatTemperature[];
    tmcFpgaVersion: string;
    ubootVersion: string;
    uptime: number;
    vcLinks: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatVcLink[];
    vcMode: string;
    /**
     * master / backup / linecard
     */
    vcRole: string;
    vcState: string;
    version: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatError {
    feature: string;
    minimumVersion: string;
    reason: string;
    since: number;
    type: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatFan {
    airflow: string;
    name: string;
    status: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatPic {
    index: number;
    modelNumber: string;
    portGroups: outputs.GetDeviceSwitchStatsDeviceSwitchStatModuleStatPicPortGroup[];
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatPicPortGroup {
    count: number;
    type: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatPoe {
    maxPower: number;
    powerDraw: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatPsus {
    name: string;
    status: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatTemperature {
    celsius: number;
    name: string;
    status: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatModuleStatVcLink {
    neighborModuleIdx: number;
    neighborPortId: string;
    portId: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatRouteSummaryStats {
    fibRoutes: number;
    maxUnicastRoutesSupported: number;
    ribRoutes: number;
    totalRoutes: number;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatServiceStat {
    ashVersion: string;
    ciaVersion: string;
    emberVersion: string;
    ipsecClientVersion: string;
    mistAgentVersion: string;
    packageVersion: string;
    testingToolsVersion: string;
    wheeljackVersion: string;
}

export interface GetDeviceSwitchStatsDeviceSwitchStatVcSetupInfo {
    configType: string;
    errMissingDevIdFpc: boolean;
}

export interface GetOrgDeviceprofilesApDeviceprofile {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
    type: string;
}

export interface GetOrgDeviceprofilesGatewayDeviceprofile {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
    type: string;
}

export interface GetOrgGatewaytemplatesOrgGatewaytemplate {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgIdpprofilesOrgIdpprofile {
    /**
     * enum: `critical`, `standard`, `strict`
     */
    baseProfile: string;
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
    overwrites: outputs.GetOrgIdpprofilesOrgIdpprofileOverwrite[];
}

export interface GetOrgIdpprofilesOrgIdpprofileOverwrite {
    /**
     * enum:
     *   * alert (default)
     *   * drop: siliently dropping packets
     *   * close: notify client/server to close connection
     */
    action: string;
    matching: outputs.GetOrgIdpprofilesOrgIdpprofileOverwriteMatching;
    name: string;
}

export interface GetOrgIdpprofilesOrgIdpprofileOverwriteMatching {
    attackNames: string[];
    dstSubnets: string[];
    severities: string[];
}

export interface GetOrgInventoryOrgInventory {
    /**
     * only if `type`==`switch` or `type`==`gateway`
     * whether the switch/gateway is adopted
     */
    adopted: boolean;
    /**
     * device claim code
     */
    claimCode: string;
    /**
     * whether the device is connected
     */
    connected: boolean;
    /**
     * inventory created time, in epoch
     */
    createdTime: number;
    /**
     * deviceprofile id if assigned, null if not assigned
     */
    deviceprofileId: string;
    /**
     * hostname reported by the device
     */
    hostname: string;
    /**
     * device hardware revision number
     */
    hwRev: string;
    /**
     * device id
     */
    id: string;
    jsi: boolean;
    /**
     * device MAC address
     */
    mac: string;
    /**
     * device model
     */
    model: string;
    /**
     * inventory last modified time, in epoch
     */
    modifiedTime: number;
    /**
     * device name if configured
     */
    name: string;
    orgId: string;
    /**
     * device serial
     */
    serial: string;
    siteId: string;
    /**
     * device stock keeping unit
     */
    sku: string;
    /**
     * only if `type`==`switch`, MAC Address of the Virtual Chassis
     */
    vcMac: string;
}

export interface GetOrgNacrulesOrgNacrule {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgNactagsOrgNactag {
    /**
     * can be set to true to allow the override by usermac result
     */
    allowUsermacOverride: boolean;
    createdTime: number;
    /**
     * if `type`==`egress_vlan_names`, list of egress vlans to return
     */
    egressVlanNames: string[];
    /**
     * if `type`==`gbp_tag`
     */
    gbpTag: number;
    id: string;
    /**
     * if `type`==`match`. enum: `cert_cn`, `cert_issuer`, `cert_san`, `cert_serial`, `cert_sub`, `client_mac`, `idp_role`, `mdm_status`, `radius_group`, `realm`, `ssid`, `user_name`, `usermac_label`
     */
    match: string;
    /**
     * This field is applicable only when `type`==`match`
     *   * `false`: means it is sufficient to match any of the values (i.e., match-any behavior)
     *   * `true`: means all values should be matched (i.e., match-all behavior)
     *
     *
     * Currently it makes sense to set this field to `true` only if the `match`==`idp_role` or `match`==`usermac_label`'
     */
    matchAll: boolean;
    modifiedTime: number;
    name: string;
    orgId: string;
    /**
     * if `type`==`radius_attrs`, user can specify a list of one or more standard attributes in the field "radius_attrs". 
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radius_attrs in the result of a given rule.
     */
    radiusAttrs: string[];
    /**
     * if `type`==`radius_group`
     */
    radiusGroup: string;
    /**
     * if `type`==`radius_vendor_attrs`, user can specify a list of one or more vendor-specific attributes in the field "radius_vendor_attrs". 
     * It is the responsibility of the user to provide a syntactically correct string, otherwise it may not work as expected.
     * Note that it is allowed to have more than one radius_vendor_attrs in the result of a given rule.
     */
    radiusVendorAttrs: string[];
    /**
     * if `type`==`session_timeout, in seconds
     */
    sessionTimeout: number;
    /**
     * enum: `egress_vlan_names`, `gbp_tag`, `match`, `radius_attrs`, `radius_group`, `radius_vendor_attrs`, `session_timeout`, `username_attr`, `vlan`
     */
    type: string;
    usernameAttr: string;
    /**
     * if `type`==`match`
     */
    values: string[];
    /**
     * if `type`==`vlan`
     */
    vlan: string;
}

export interface GetOrgNetworksOrgNetwork {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgNetworktemplatesOrgNetworktemplate {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgPsksOrgPsk {
    /**
     * sso id for psk created from psk portal
     */
    adminSsoId: string;
    createdTime: number;
    /**
     * email to send psk expiring notifications to
     */
    email: string;
    /**
     * Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
     */
    expireTime: number;
    /**
     * Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
     */
    expiryNotificationTime: number;
    id: string;
    /**
     * if `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
     */
    mac: string;
    /**
     * if `usage`==`macs`, this list contains N number of client mac addresses or mac patterns(11:22:*) or both. This list is capped at 5000
     */
    macs: string[];
    /**
     * For Org PSK Only. Max concurrent users for this PSK key. Default is 0 (unlimited)
     */
    maxUsage: number;
    modifiedTime: number;
    name: string;
    note: string;
    /**
     * If set to true, reminder notification will be sent when psk is about to expire
     */
    notifyExpiry: boolean;
    /**
     * If set to true, notification will be sent when psk is created or edited
     */
    notifyOnCreateOrEdit: boolean;
    /**
     * previous passphrase of the PSK if it has been rotated
     */
    oldPassphrase: string;
    orgId: string;
    /**
     * passphrase of the PSK (8-63 character or 64 in hex)
     */
    passphrase: string;
    role: string;
    /**
     * SSID this PSK should be applicable to
     */
    ssid: string;
    /**
     * enum: `macs`, `multi`, `single`
     */
    usage: string;
    vlanId: string;
}

export interface GetOrgRftemplatesOrgRftemplate {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgServicepoliciesOrgServicepolicy {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    /**
     * For SRX Only
     */
    appqoe: outputs.GetOrgServicepoliciesOrgServicepolicyAppqoe;
    createdTime: number;
    ewfs: outputs.GetOrgServicepoliciesOrgServicepolicyEwf[];
    id: string;
    idp: outputs.GetOrgServicepoliciesOrgServicepolicyIdp;
    /**
     * access within the same VRF
     */
    localRouting: boolean;
    modifiedTime: number;
    name: string;
    orgId: string;
    /**
     * by default, we derive all paths available and use them
     * optionally, you can customize by using `path_preference`
     */
    pathPreference: string;
    services: string[];
    tenants: string[];
}

export interface GetOrgServicepoliciesOrgServicepolicyAppqoe {
    enabled: boolean;
}

export interface GetOrgServicepoliciesOrgServicepolicyEwf {
    alertOnly: boolean;
    blockMessage: string;
    enabled: boolean;
    /**
     * enum: `critical`, `standard`, `strict`
     */
    profile: string;
}

export interface GetOrgServicepoliciesOrgServicepolicyIdp {
    alertOnly: boolean;
    enabled: boolean;
    /**
     * org_level IDP Profile can be used, this takes precedence over `profile`
     */
    idpprofileId: string;
    /**
     * `strict` (default) / `standard` / or keys from from idp_profiles
     */
    profile: string;
}

export interface GetOrgServicesOrgService {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgSitegroupsOrgSitegroup {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
    siteIds: string[];
}

export interface GetOrgVpnsOrgVpn {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
    paths: {[key: string]: outputs.GetOrgVpnsOrgVpnPaths};
}

export interface GetOrgVpnsOrgVpnPaths {
    /**
     * enum: `broadband`, `lte`
     */
    bfdProfile: string;
    /**
     * if different from the wan port
     */
    ip: string;
    pod: number;
}

export interface GetOrgWebhooksOrgWebhook {
    createdTime: number;
    /**
     * whether webhook is enabled
     */
    enabled: boolean;
    /**
     * if `type`=`http-post`, additional custom HTTP headers to add
     * the headers name and value must be string, total bytes of headers name and value must be less than 1000
     */
    headers: {[key: string]: string};
    id: string;
    modifiedTime: number;
    /**
     * name of the webhook
     */
    name: string;
    /**
     * required when `oauth2_grant_type`==`client_credentials`
     */
    oauth2ClientId: string;
    /**
     * required when `oauth2_grant_type`==`client_credentials`
     */
    oauth2ClientSecret: string;
    /**
     * required when `type`==`oauth2`. enum: `client_credentials`, `password`
     */
    oauth2GrantType: string;
    /**
     * required when `oauth2_grant_type`==`password`
     */
    oauth2Password: string;
    /**
     * required when `type`==`oauth2`, if provided, will be used in the token request
     */
    oauth2Scopes: string[];
    /**
     * required when `type`==`oauth2`
     */
    oauth2TokenUrl: string;
    /**
     * required when `oauth2_grant_type`==`password`
     */
    oauth2Username: string;
    orgId: string;
    /**
     * only if `type`=`http-post` 
     *
     * when `secret` is provided, two  HTTP headers will be added: 
     *   * X-Mist-Signature-v2: HMAC_SHA256(secret, body)
     *   * X-Mist-Signature: HMAC_SHA1(secret, body)
     */
    secret: string;
    siteId: string;
    /**
     * required if `type`=`splunk`
     * If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.'
     */
    splunkToken: string;
    /**
     * N.B. For org webhooks, only device_events/alarms/audits/client-join/client-sessions/nac-sessions/nac_events topics are supported.
     */
    topics: string[];
    /**
     * enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
     */
    type: string;
    url: string;
    /**
     * when url uses HTTPS, whether to verify the certificate
     */
    verifyCert: boolean;
}

export interface GetOrgWlantemplatesOrgWlantemplate {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetOrgWxtagsOrgWxtag {
    createdTime: number;
    id: string;
    modifiedTime: number;
    name: string;
    orgId: string;
}

export interface GetSitePsksSitePsk {
    /**
     * sso id for psk created from psk portal
     */
    adminSsoId: string;
    createdTime: number;
    /**
     * email to send psk expiring notifications to
     */
    email: string;
    /**
     * Expire time for this PSK key (epoch time in seconds). Default `null` (as no expiration)
     */
    expireTime: number;
    /**
     * Number of days before psk is expired. Used as to when to start sending reminder notification when the psk is about to expire
     */
    expiryNotificationTime: number;
    id: string;
    /**
     * if `usage`==`single`, the mac that this PSK ties to, empty if `auto-binding`
     */
    mac: string;
    modifiedTime: number;
    name: string;
    note: string;
    /**
     * If set to true, reminder notification will be sent when psk is about to expire
     */
    notifyExpiry: boolean;
    /**
     * If set to true, notification will be sent when psk is created or edited
     */
    notifyOnCreateOrEdit: boolean;
    /**
     * previous passphrase of the PSK if it has been rotated
     */
    oldPassphrase: string;
    orgId: string;
    /**
     * passphrase of the PSK (8-63 character or 64 in hex)
     */
    passphrase: string;
    role: string;
    siteId: string;
    /**
     * SSID this PSK should be applicable to
     */
    ssid: string;
    /**
     * enum: `macs`, `multi`, `single`
     */
    usage: string;
    vlanId: string;
}

export interface GetSiteWebhooksSiteWebhook {
    createdTime: number;
    /**
     * whether webhook is enabled
     */
    enabled: boolean;
    /**
     * if `type`=`http-post`, additional custom HTTP headers to add
     * the headers name and value must be string, total bytes of headers name and value must be less than 1000
     */
    headers: {[key: string]: string};
    id: string;
    modifiedTime: number;
    /**
     * name of the webhook
     */
    name: string;
    /**
     * required when `oauth2_grant_type`==`client_credentials`
     */
    oauth2ClientId: string;
    /**
     * required when `oauth2_grant_type`==`client_credentials`
     */
    oauth2ClientSecret: string;
    /**
     * required when `type`==`oauth2`. enum: `client_credentials`, `password`
     */
    oauth2GrantType: string;
    /**
     * required when `oauth2_grant_type`==`password`
     */
    oauth2Password: string;
    /**
     * required when `type`==`oauth2`, if provided, will be used in the token request
     */
    oauth2Scopes: string[];
    /**
     * required when `type`==`oauth2`
     */
    oauth2TokenUrl: string;
    /**
     * required when `oauth2_grant_type`==`password`
     */
    oauth2Username: string;
    orgId: string;
    /**
     * only if `type`=`http-post` 
     *
     * when `secret` is provided, two  HTTP headers will be added: 
     *   * X-Mist-Signature-v2: HMAC_SHA256(secret, body)
     *   * X-Mist-Signature: HMAC_SHA1(secret, body)
     */
    secret: string;
    siteId: string;
    /**
     * required if `type`=`splunk`
     * If splunk_token is not defined for a type Splunk webhook, it will not send, regardless if the webhook receiver is configured to accept it.'
     */
    splunkToken: string;
    /**
     * N.B. For org webhooks, only device_events/alarms/audits/client-join/client-sessions/nac-sessions/nac_events topics are supported.
     */
    topics: string[];
    /**
     * enum: `aws-sns`, `google-pubsub`, `http-post`, `oauth2`, `splunk`
     */
    type: string;
    url: string;
    /**
     * when url uses HTTPS, whether to verify the certificate
     */
    verifyCert: boolean;
}

export interface GetSitesSite {
    /**
     * full address of the site
     */
    address: string;
    /**
     * Alarm Template ID, this takes precedence over the Org-level alarmtemplate_id
     */
    alarmtemplateId: string;
    /**
     * AP Template ID, used by APs
     */
    aptemplateId: string;
    /**
     * country code for the site (for AP config generation), in two-character
     */
    countryCode: string;
    createdTime: number;
    /**
     * Gateway Template ID, used by gateways
     */
    gatewaytemplateId: string;
    id: string;
    latlng: outputs.GetSitesSiteLatlng;
    modifiedTime: number;
    name: string;
    /**
     * Network Template ID, this takes precedence over Site Settings
     */
    networktemplateId: string;
    /**
     * optional, any notes about the site
     */
    notes: string;
    orgId: string;
    /**
     * RF Template ID, this takes precedence over Site Settings
     */
    rftemplateId: string;
    /**
     * SecPolicy ID
     */
    secpolicyId: string;
    /**
     * sitegroups this site belongs to
     */
    sitegroupIds: string[];
    /**
     * Site Template ID
     */
    sitetemplateId: string;
    /**
     * Timezone the site is at
     */
    timezone: string;
}

export interface GetSitesSiteLatlng {
    lat: number;
    lng: number;
}

export interface OrgDeviceprofileApAeroscout {
    /**
     * whether to enable aeroscout config
     */
    enabled: boolean;
    /**
     * required if enabled, aeroscout server host
     */
    host?: string;
    /**
     * whether to enable the feature to allow wireless clients data received and sent to AES server for location calculation
     */
    locateConnected: boolean;
}

export interface OrgDeviceprofileApBleConfig {
    /**
     * whether Mist beacons is enabled
     */
    beaconEnabled: boolean;
    /**
     * required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
     */
    beaconRate: number;
    /**
     * enum: `custom`, `default`
     */
    beaconRateMode: string;
    /**
     * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
     */
    beamDisableds?: number[];
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send custom packet
     */
    customBlePacketEnabled: boolean;
    /**
     * The custom frame to be sent out in this beacon. The frame must be a hexstring
     */
    customBlePacketFrame: string;
    /**
     * Frequency (msec) of data emitted by custom ble beacon
     */
    customBlePacketFreqMsec: number;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUidAdvPower: number;
    eddystoneUidBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
     */
    eddystoneUidEnabled: boolean;
    /**
     * Frequency (msec) of data emmit by Eddystone-UID beacon
     */
    eddystoneUidFreqMsec: number;
    /**
     * Eddystone-UID instance for the device
     */
    eddystoneUidInstance: string;
    /**
     * Eddystone-UID namespace
     */
    eddystoneUidNamespace: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUrlAdvPower: number;
    eddystoneUrlBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
     */
    eddystoneUrlEnabled: boolean;
    /**
     * Frequency (msec) of data emit by Eddystone-UID beacon
     */
    eddystoneUrlFreqMsec: number;
    /**
     * URL pointed by Eddystone-URL beacon
     */
    eddystoneUrlUrl: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    ibeaconAdvPower: number;
    ibeaconBeams: string;
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
     */
    ibeaconEnabled: boolean;
    /**
     * Frequency (msec) of data emmit for iBeacon
     */
    ibeaconFreqMsec: number;
    /**
     * Major number for iBeacon
     */
    ibeaconMajor: number;
    /**
     * Minor number for iBeacon
     */
    ibeaconMinor: number;
    /**
     * optional, if not specified, the same UUID as the beacon will be used
     */
    ibeaconUuid: string;
    /**
     * required if `power_mode`==`custom`
     */
    power: number;
    /**
     * enum: `custom`, `default`
     */
    powerMode: string;
}

export interface OrgDeviceprofileApEslConfig {
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    cacert?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    channel?: number;
    /**
     * usb_config is ignored if esl_config enabled
     */
    enabled: boolean;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    host?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    port?: number;
    /**
     * note: ble_config will be ingored if esl_config is enabled and with native mode. enum: `hanshow`, `imagotag`, `native`, `solum`
     */
    type?: string;
    /**
     * Only if `type`==`imagotag` or `type`==`native`
     */
    verifyCert?: boolean;
    /**
     * Only if `type`==`solum` or `type`==`hanshow`
     */
    vlanId: number;
}

export interface OrgDeviceprofileApIpConfig {
    /**
     * if `type`==`static`
     */
    dns: string[];
    /**
     * required if `type`==`static`
     */
    dnsSuffixes: string[];
    /**
     * required if `type`==`static`
     */
    gateway?: string;
    gateway6?: string;
    /**
     * required if `type`==`static`
     */
    ip?: string;
    ip6?: string;
    mtu?: number;
    /**
     * required if `type`==`static`
     */
    netmask?: string;
    netmask6?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * enum: `autoconf`, `dhcp`, `disabled`, `static`
     */
    type6: string;
    /**
     * management vlan id, default is 1 (untagged)
     */
    vlanId: number;
}

export interface OrgDeviceprofileApLed {
    brightness: number;
    enabled: boolean;
}

export interface OrgDeviceprofileApMesh {
    /**
     * whether mesh is enabled on this AP
     */
    enabled: boolean;
    /**
     * mesh group, base AP(s) will only allow remote AP(s) in the same mesh group to join, 1-9, optional
     */
    group?: number;
    /**
     * enum: `base`, `remote`
     */
    role?: string;
}

export interface OrgDeviceprofileApPwrConfig {
    /**
     * additional power to request during negotiating with PSE over PoE, in mW
     */
    base: number;
    /**
     * whether to enable power out to peripheral, meanwhile will reduce power to wifi (only for AP45 at power mode)
     */
    preferUsbOverWifi: boolean;
}

export interface OrgDeviceprofileApRadioConfig {
    allowRrmDisable: boolean;
    /**
     * antenna gain for 2.4G - for models with external antenna only
     */
    antGain24?: number;
    /**
     * antenna gain for 5G - for models with external antenna only
     */
    antGain5?: number;
    /**
     * antenna gain for 6G - for models with external antenna only
     */
    antGain6?: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * Radio Band AP settings
     */
    band24?: outputs.OrgDeviceprofileApRadioConfigBand24;
    /**
     * enum: `24`, `5`, `6`, `auto`
     */
    band24Usage?: string;
    /**
     * Radio Band AP settings
     */
    band5?: outputs.OrgDeviceprofileApRadioConfigBand5;
    /**
     * Radio Band AP settings
     */
    band5On24Radio?: outputs.OrgDeviceprofileApRadioConfigBand5On24Radio;
    /**
     * Radio Band AP settings
     */
    band6?: outputs.OrgDeviceprofileApRadioConfigBand6;
    /**
     * to make an outdoor operate indoor.
     * for an outdoor-ap, some channels are disallowed by default, this allows the user to use it as an indoor-ap
     */
    indoorUse: boolean;
    /**
     * whether scanning radio is enabled
     */
    scanningEnabled?: boolean;
}

export interface OrgDeviceprofileApRadioConfigBand24 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 2.4GHz band. enum: `20`, `40`
     */
    bandwidth: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgDeviceprofileApRadioConfigBand5 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgDeviceprofileApRadioConfigBand5On24Radio {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgDeviceprofileApRadioConfigBand6 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
     */
    bandwidth: number;
    /**
     * For Device. (primary) channel for the band, 0 means using the Site Setting
     */
    channel: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
    /**
     * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
     */
    standardPower: boolean;
}

export interface OrgDeviceprofileApUplinkPortConfig {
    /**
     * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
     */
    dot1x: boolean;
    /**
     * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
     */
    keepWlansUpIfDown: boolean;
}

export interface OrgDeviceprofileApUsbConfig {
    /**
     * only if `type`==`imagotag`
     */
    cacert?: string;
    /**
     * only if `type`==`imagotag`, channel selection, not needed by default, required for manual channel override only
     */
    channel?: number;
    /**
     * whether to enable any usb config
     */
    enabled?: boolean;
    /**
     * only if `type`==`imagotag`
     */
    host?: string;
    /**
     * only if `type`==`imagotag`
     */
    port: number;
    /**
     * usb config type. enum: `hanshow`, `imagotag`, `solum`
     */
    type?: string;
    /**
     * only if `type`==`imagotag`, whether to turn on SSL verification
     */
    verifyCert?: boolean;
    /**
     * only if `type`==`solum` or `type`==`hanshow`
     */
    vlanId: number;
}

export interface OrgDeviceprofileGatewayBgpConfig {
    authKey?: string;
    /**
     * when bfd_multiplier is configured alone. Default:
     *   * 1000 if `type`==`external`
     *   * 350 `type`==`internal`
     */
    bfdMinimumInterval: number;
    /**
     * when bfd_minimum_interval_is_configured alone
     */
    bfdMultiplier: number;
    communities?: outputs.OrgDeviceprofileGatewayBgpConfigCommunity[];
    /**
     * BFD provides faster path failure detection and is enabled by default
     */
    disableBfd: boolean;
    export?: string;
    /**
     * default export policies if no per-neighbor policies defined
     */
    exportPolicy?: string;
    /**
     * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
     * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
     */
    extendedV4Nexthop?: boolean;
    /**
     * `0` means disable
     */
    gracefulRestartTime: number;
    holdTime: number;
    import?: string;
    /**
     * default import policies if no per-neighbor policies defined
     */
    importPolicy?: string;
    localAs?: number;
    neighborAs?: number;
    /**
     * if per-neighbor as is desired. Property key is the neighbor address
     */
    neighbors?: {[key: string]: outputs.OrgDeviceprofileGatewayBgpConfigNeighbors};
    /**
     * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
     */
    networks: string[];
    /**
     * by default, we'll re-advertise all learned BGP routers toward overlay
     */
    noReadvertiseToOverlay: boolean;
    /**
     * enum: `external`, `internal`
     */
    type?: string;
    /**
     * network name. enum: `lan`, `vpn`, `wan`
     */
    via: string;
    vpnName?: string;
    /**
     * if `via`==`wan`
     */
    wanName?: string;
}

export interface OrgDeviceprofileGatewayBgpConfigCommunity {
    id?: string;
    localPreference?: number;
    vpnName?: string;
}

export interface OrgDeviceprofileGatewayBgpConfigNeighbors {
    /**
     * If true, the BGP session to this neighbor will be administratively disabled/shutdown
     */
    disabled: boolean;
    exportPolicy?: string;
    holdTime: number;
    importPolicy?: string;
    /**
     * assuming BGP neighbor is directly connected
     */
    multihopTtl?: number;
    neighborAs?: number;
}

export interface OrgDeviceprofileGatewayDhcpdConfig {
    config?: {[key: string]: outputs.OrgDeviceprofileGatewayDhcpdConfigConfig};
    /**
     * if set to `true`, enable the DHCP server
     */
    enabled: boolean;
}

export interface OrgDeviceprofileGatewayDhcpdConfigConfig {
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsServers?: string[];
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsSuffixes: string[];
    /**
     * Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
     */
    fixedBindings?: {[key: string]: outputs.OrgDeviceprofileGatewayDhcpdConfigConfigFixedBindings};
    /**
     * if `type`==`local` - optional, `ip` will be used if not provided
     */
    gateway?: string;
    /**
     * if `type`==`local`
     */
    ipEnd?: string;
    /**
     * if `type6`==`local`
     */
    ipEnd6?: string;
    /**
     * if `type`==`local`
     */
    ipStart?: string;
    /**
     * if `type6`==`local`
     */
    ipStart6?: string;
    /**
     * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
     */
    leaseTime: number;
    /**
     * Property key is the DHCP option number
     */
    options?: {[key: string]: outputs.OrgDeviceprofileGatewayDhcpdConfigConfigOptions};
    /**
     * `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
     * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
     */
    serverIdOverride: boolean;
    /**
     * if `type`==`relay`
     */
    servers: string[];
    /**
     * if `type6`==`relay`
     */
    servers6s: string[];
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type: string;
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type6: string;
    /**
     * Property key is <enterprise number>:<sub option code>, with
     *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
     *   * sub option code: 1-255, sub-option code'
     */
    vendorEncapulated?: {[key: string]: outputs.OrgDeviceprofileGatewayDhcpdConfigConfigVendorEncapulated};
}

export interface OrgDeviceprofileGatewayDhcpdConfigConfigFixedBindings {
    ip: string;
    name?: string;
}

export interface OrgDeviceprofileGatewayDhcpdConfigConfigOptions {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface OrgDeviceprofileGatewayDhcpdConfigConfigVendorEncapulated {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface OrgDeviceprofileGatewayExtraRoutes {
    via: string;
}

export interface OrgDeviceprofileGatewayExtraRoutes6 {
    via: string;
}

export interface OrgDeviceprofileGatewayIdpProfiles {
    /**
     * enum: `critical`, `standard`, `strict`
     */
    baseProfile?: string;
    name?: string;
    orgId?: string;
    overwrites?: outputs.OrgDeviceprofileGatewayIdpProfilesOverwrite[];
}

export interface OrgDeviceprofileGatewayIdpProfilesOverwrite {
    /**
     * enum:
     *   * alert (default)
     *   * drop: siliently dropping packets
     *   * close: notify client/server to close connection
     */
    action: string;
    matching?: outputs.OrgDeviceprofileGatewayIdpProfilesOverwriteMatching;
    name?: string;
}

export interface OrgDeviceprofileGatewayIdpProfilesOverwriteMatching {
    attackNames?: string[];
    dstSubnets?: string[];
    severities?: string[];
}

export interface OrgDeviceprofileGatewayIpConfigs {
    ip: string;
    netmask: string;
    /**
     * optional list of secondary IPs in CIDR format
     */
    secondaryIps: string[];
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
}

export interface OrgDeviceprofileGatewayNetwork {
    /**
     * whether to disallow Mist Devices in the network
     */
    disallowMistServices: boolean;
    gateway?: string;
    gateway6?: string;
    internalAccess?: outputs.OrgDeviceprofileGatewayNetworkInternalAccess;
    /**
     * whether this network has direct internet access
     */
    internetAccess?: outputs.OrgDeviceprofileGatewayNetworkInternetAccess;
    /**
     * whether to allow clients in the network to talk to each other
     */
    isolation?: boolean;
    name: string;
    /**
     * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
     */
    routedForNetworks?: string[];
    subnet: string;
    subnet6?: string;
    tenants?: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkTenants};
    vlanId?: string;
    /**
     * Property key is the VPN name. Whether this network can be accessed from vpn
     */
    vpnAccess?: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkVpnAccess};
}

export interface OrgDeviceprofileGatewayNetworkInternalAccess {
    enabled?: boolean;
}

export interface OrgDeviceprofileGatewayNetworkInternetAccess {
    createSimpleServicePolicy: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat?: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkInternetAccessDestinationNat};
    enabled?: boolean;
    /**
     * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
     */
    restricted: boolean;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat?: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkInternetAccessStaticNat};
}

export interface OrgDeviceprofileGatewayNetworkInternetAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgDeviceprofileGatewayNetworkInternetAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgDeviceprofileGatewayNetworkTenants {
    addresses?: string[];
}

export interface OrgDeviceprofileGatewayNetworkVpnAccess {
    /**
     * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
     */
    advertisedSubnet?: string;
    /**
     * whether to allow ping from vpn into this routed network
     */
    allowPing?: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkVpnAccessDestinationNat};
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
     */
    natPool?: string;
    /**
     * toward LAN-side BGP peers
     */
    noReadvertiseToLanBgp: boolean;
    /**
     * toward LAN-side OSPF peers
     */
    noReadvertiseToLanOspf: boolean;
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    noReadvertiseToOverlay?: boolean;
    /**
     * by default, the routes are only readvertised toward the same vrf on spoke
     * to allow it to be leaked to other vrfs
     */
    otherVrfs: string[];
    /**
     * whether this network is routable
     */
    routed?: boolean;
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
     */
    sourceNat: outputs.OrgDeviceprofileGatewayNetworkVpnAccessSourceNat;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat: {[key: string]: outputs.OrgDeviceprofileGatewayNetworkVpnAccessStaticNat};
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    summarizedSubnet?: string;
    /**
     * toward LAN-side BGP peers
     */
    summarizedSubnetToLanBgp?: string;
    /**
     * toward LAN-side OSPF peers
     */
    summarizedSubnetToLanOspf?: string;
}

export interface OrgDeviceprofileGatewayNetworkVpnAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgDeviceprofileGatewayNetworkVpnAccessSourceNat {
    externalIp?: string;
}

export interface OrgDeviceprofileGatewayNetworkVpnAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgDeviceprofileGatewayOobIpConfig {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    /**
     * if `type`==`static`
     */
    ip?: string;
    /**
     * if `type`==`static`
     */
    netmask?: string;
    /**
     * for HA Cluster, node1 can have different IP Config
     */
    node1?: outputs.OrgDeviceprofileGatewayOobIpConfigNode1;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface OrgDeviceprofileGatewayOobIpConfigNode1 {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface OrgDeviceprofileGatewayPathPreferences {
    paths?: outputs.OrgDeviceprofileGatewayPathPreferencesPath[];
    /**
     * enum: `ecmp`, `ordered`, `weighted`
     */
    strategy: string;
}

export interface OrgDeviceprofileGatewayPathPreferencesPath {
    cost?: number;
    /**
     * For SSR Only. `true`, if this specific path is undesired
     */
    disabled?: boolean;
    /**
     * only if `type`==`local`, if a different gateway is desired
     */
    gatewayIp?: string;
    /**
     * only if `type`==`vpn`, if this vpn path can be used for internet
     */
    internetAccess?: boolean;
    /**
     * required when 
     *   * `type`==`vpn`: the name of the VPN Path to use 
     *   * `type`==`wan`: the name of the WAN interface to use'
     */
    name?: string;
    /**
     * required when `type`==`local`
     */
    networks: string[];
    /**
     * if `type`==`local`, if destination IP is to be replaced
     */
    targetIps: string[];
    /**
     * enum: `local`, `tunnel`, `vpn`, `wan`
     */
    type?: string;
    /**
     * required when`type`==`tunnel`
     */
    wanName?: string;
}

export interface OrgDeviceprofileGatewayPortConfig {
    description?: string;
    disableAutoneg: boolean;
    /**
     * port admin up (true) / down (false)
     */
    disabled: boolean;
    /**
     * if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
     */
    dslType: string;
    /**
     * if `wan_type`==`dsl`
     * 16 bit int
     */
    dslVci: number;
    /**
     * if `wan_type`==`dsl`
     * 8 bit int
     */
    dslVpi: number;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Junos IP Config
     */
    ipConfig?: outputs.OrgDeviceprofileGatewayPortConfigIpConfig;
    /**
     * if `wan_type`==`lte`
     */
    lteApn?: string;
    /**
     * if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
     */
    lteAuth: string;
    lteBackup?: boolean;
    /**
     * if `wan_type`==`lte`
     */
    ltePassword?: string;
    /**
     * if `wan_type`==`lte`
     */
    lteUsername?: string;
    mtu?: number;
    /**
     * name that we'll use to derive config
     */
    name?: string;
    /**
     * if `usage`==`lan`
     */
    networks: string[];
    /**
     * for Q-in-Q
     */
    outerVlanId?: number;
    poeDisabled: boolean;
    /**
     * if `usage`==`lan`
     */
    portNetwork?: string;
    /**
     * whether to preserve dscp when sending traffic over VPN (SSR-only)
     */
    preserveDscp: boolean;
    /**
     * if HA mode
     */
    redundant?: boolean;
    /**
     * if HA mode
     */
    rethIdx?: number;
    /**
     * if HA mode
     */
    rethNode?: string;
    /**
     * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
     */
    rethNodes: string[];
    speed: string;
    /**
     * when SSR is running as VM, this is required on certain hosting platforms
     */
    ssrNoVirtualMac: boolean;
    /**
     * for SSR only
     */
    svrPortRange: string;
    trafficShaping?: outputs.OrgDeviceprofileGatewayPortConfigTrafficShaping;
    /**
     * port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
     */
    usage: string;
    /**
     * if WAN interface is on a VLAN
     */
    vlanId?: number;
    vpnPaths?: {[key: string]: outputs.OrgDeviceprofileGatewayPortConfigVpnPaths};
    /**
     * when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
     */
    wanArpPolicer: string;
    /**
     * optional, if spoke should reach this port by a different IP
     */
    wanExtIp?: string;
    /**
     * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
     */
    wanSourceNat?: outputs.OrgDeviceprofileGatewayPortConfigWanSourceNat;
    /**
     * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
     */
    wanType: string;
}

export interface OrgDeviceprofileGatewayPortConfigIpConfig {
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dns?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dnsSuffixes?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * optional, the network to be used for mgmt
     */
    network?: string;
    /**
     * if `type`==`pppoe`
     */
    poserPassword?: string;
    /**
     * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
     */
    pppoeAuth: string;
    /**
     * if `type`==`pppoe`
     */
    pppoeUsername?: string;
    /**
     * enum: `dhcp`, `pppoe`, `static`
     */
    type: string;
}

export interface OrgDeviceprofileGatewayPortConfigTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface OrgDeviceprofileGatewayPortConfigVpnPaths {
    /**
     * enum: `broadband`, `lte`
     */
    bfdProfile: string;
    /**
     * whether to use tunnel mode. SSR only
     */
    bfdUseTunnelMode: boolean;
    /**
     * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
     */
    preference?: number;
    /**
     * enum: `hub`, `spoke`
     */
    role: string;
    trafficShaping?: outputs.OrgDeviceprofileGatewayPortConfigVpnPathsTrafficShaping;
}

export interface OrgDeviceprofileGatewayPortConfigVpnPathsTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface OrgDeviceprofileGatewayPortConfigWanSourceNat {
    /**
     * or to disable the source-nat
     */
    disabled: boolean;
    /**
     * if alternative nat_pool is desired
     */
    natPool?: string;
}

export interface OrgDeviceprofileGatewayRoutingPolicies {
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    terms?: outputs.OrgDeviceprofileGatewayRoutingPoliciesTerm[];
}

export interface OrgDeviceprofileGatewayRoutingPoliciesTerm {
    /**
     * when used as import policy
     */
    action?: outputs.OrgDeviceprofileGatewayRoutingPoliciesTermAction;
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    matching?: outputs.OrgDeviceprofileGatewayRoutingPoliciesTermMatching;
}

export interface OrgDeviceprofileGatewayRoutingPoliciesTermAction {
    accept?: boolean;
    addCommunities?: string[];
    /**
     * for SSR, hub decides how VRF routes are leaked on spoke
     */
    addTargetVrfs?: string[];
    /**
     * when used as export policy, optional
     */
    communities?: string[];
    /**
     * when used as export policy, optional. To exclude certain AS
     */
    excludeAsPaths?: string[];
    excludeCommunities?: string[];
    /**
     * when used as export policy, optional
     */
    exportCommunitites?: string[];
    /**
     * optional, for an import policy, local_preference can be changed
     */
    localPreference?: string;
    /**
     * when used as export policy, optional. By default, the local AS will be prepended, to change it
     */
    prependAsPaths?: string[];
}

export interface OrgDeviceprofileGatewayRoutingPoliciesTermMatching {
    /**
     * takes regular expression
     */
    asPaths?: string[];
    communities?: string[];
    networks?: string[];
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    prefixes?: string[];
    /**
     * `direct`, `bgp`, `osp`, ...
     */
    protocols?: string[];
    routeExists?: outputs.OrgDeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     */
    vpnNeighborMacs?: string[];
    vpnPathSla?: outputs.OrgDeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     * ordered-
     */
    vpnPaths?: string[];
}

export interface OrgDeviceprofileGatewayRoutingPoliciesTermMatchingRouteExists {
    route?: string;
    /**
     * name of the vrf instance
     * it can also be the name of the VPN or wan if they
     */
    vrfName: string;
}

export interface OrgDeviceprofileGatewayRoutingPoliciesTermMatchingVpnPathSla {
    maxJitter?: number;
    maxLatency?: number;
    maxLoss?: number;
}

export interface OrgDeviceprofileGatewayServicePolicy {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    /**
     * For SRX Only
     */
    appqoe?: outputs.OrgDeviceprofileGatewayServicePolicyAppqoe;
    ewfs?: outputs.OrgDeviceprofileGatewayServicePolicyEwf[];
    idp?: outputs.OrgDeviceprofileGatewayServicePolicyIdp;
    /**
     * access within the same VRF
     */
    localRouting: boolean;
    name?: string;
    /**
     * by default, we derive all paths available and use them
     * optionally, you can customize by using `path_preference`
     */
    pathPreference?: string;
    /**
     * used to link servicepolicy defined at org level and overwrite some attributes
     */
    servicepolicyId?: string;
    services: string[];
    tenants: string[];
}

export interface OrgDeviceprofileGatewayServicePolicyAppqoe {
    enabled: boolean;
}

export interface OrgDeviceprofileGatewayServicePolicyEwf {
    alertOnly?: boolean;
    blockMessage?: string;
    enabled: boolean;
    /**
     * enum: `critical`, `standard`, `strict`
     */
    profile: string;
}

export interface OrgDeviceprofileGatewayServicePolicyIdp {
    alertOnly?: boolean;
    enabled: boolean;
    /**
     * org_level IDP Profile can be used, this takes precedence over `profile`
     */
    idpprofileId?: string;
    /**
     * `strict` (default) / `standard` / or keys from from idp_profiles
     */
    profile: string;
}

export interface OrgDeviceprofileGatewayTunnelConfigs {
    autoProvision?: outputs.OrgDeviceprofileGatewayTunnelConfigsAutoProvision;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    ikeLifetime?: number;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
     */
    ikeMode: string;
    /**
     * if `provider`== `custom-ipsec`
     */
    ikeProposals?: outputs.OrgDeviceprofileGatewayTunnelConfigsIkeProposal[];
    /**
     * if `provider`== `custom-ipsec`
     */
    ipsecLifetime?: number;
    /**
     * Only if  `provider`== `custom-ipsec`
     */
    ipsecProposals?: outputs.OrgDeviceprofileGatewayTunnelConfigsIpsecProposal[];
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    localId?: string;
    /**
     * enum: `active-active`, `active-standby`
     */
    mode: string;
    primary?: outputs.OrgDeviceprofileGatewayTunnelConfigsPrimary;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    probe?: outputs.OrgDeviceprofileGatewayTunnelConfigsProbe;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
     */
    protocol?: string;
    /**
     * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
     */
    provider?: string;
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    psk?: string;
    secondary?: outputs.OrgDeviceprofileGatewayTunnelConfigsSecondary;
    /**
     * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
     */
    version: string;
}

export interface OrgDeviceprofileGatewayTunnelConfigsAutoProvision {
    enable?: boolean;
    latlng?: outputs.OrgDeviceprofileGatewayTunnelConfigsAutoProvisionLatlng;
    primary?: outputs.OrgDeviceprofileGatewayTunnelConfigsAutoProvisionPrimary;
    /**
     * enum: `APAC`, `Americas`, `EMEA`, `auto`
     */
    region: string;
    secondary?: outputs.OrgDeviceprofileGatewayTunnelConfigsAutoProvisionSecondary;
}

export interface OrgDeviceprofileGatewayTunnelConfigsAutoProvisionLatlng {
    lat: number;
    lng: number;
}

export interface OrgDeviceprofileGatewayTunnelConfigsAutoProvisionPrimary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface OrgDeviceprofileGatewayTunnelConfigsAutoProvisionSecondary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface OrgDeviceprofileGatewayTunnelConfigsIkeProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface OrgDeviceprofileGatewayTunnelConfigsIpsecProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * Only if `provider`== `custom-ipsec`. enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface OrgDeviceprofileGatewayTunnelConfigsPrimary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface OrgDeviceprofileGatewayTunnelConfigsProbe {
    /**
     * how often to trigger the probe
     */
    interval?: number;
    /**
     * number of consecutive misses before declaring the tunnel down
     */
    threshold?: number;
    /**
     * time within which to complete the connectivity check
     */
    timeout?: number;
    /**
     * enum: `http`, `icmp`
     */
    type: string;
}

export interface OrgDeviceprofileGatewayTunnelConfigsSecondary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface OrgDeviceprofileGatewayTunnelProviderOptions {
    /**
     * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
     */
    jse?: outputs.OrgDeviceprofileGatewayTunnelProviderOptionsJse;
    /**
     * for zscaler-ipsec and zscaler-gre
     */
    zscaler?: outputs.OrgDeviceprofileGatewayTunnelProviderOptionsZscaler;
}

export interface OrgDeviceprofileGatewayTunnelProviderOptionsJse {
    name?: string;
    numUsers?: number;
}

export interface OrgDeviceprofileGatewayTunnelProviderOptionsZscaler {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    name?: string;
    /**
     * if `use_xff`==`true`
     */
    subLocations?: outputs.OrgDeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
    /**
     * location uses proxy chaining to forward traffic
     */
    useXff?: boolean;
}

export interface OrgDeviceprofileGatewayTunnelProviderOptionsZscalerSubLocation {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup?: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    subnets?: string[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
}

export interface OrgDeviceprofileGatewayVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface OrgDeviceprofileGatewayVrfInstances {
    networks?: string[];
}

export interface OrgGatewaytemplateBgpConfig {
    authKey?: string;
    /**
     * when bfd_multiplier is configured alone. Default:
     *   * 1000 if `type`==`external`
     *   * 350 `type`==`internal`
     */
    bfdMinimumInterval: number;
    /**
     * when bfd_minimum_interval_is_configured alone
     */
    bfdMultiplier: number;
    communities?: outputs.OrgGatewaytemplateBgpConfigCommunity[];
    /**
     * BFD provides faster path failure detection and is enabled by default
     */
    disableBfd: boolean;
    export?: string;
    /**
     * default export policies if no per-neighbor policies defined
     */
    exportPolicy?: string;
    /**
     * by default, either inet/net6 unicast depending on neighbor IP family (v4 or v6)
     * for v6 neighbors, to exchange v4 nexthop, which allows dual-stack support, enable this
     */
    extendedV4Nexthop?: boolean;
    /**
     * `0` means disable
     */
    gracefulRestartTime: number;
    holdTime: number;
    import?: string;
    /**
     * default import policies if no per-neighbor policies defined
     */
    importPolicy?: string;
    localAs?: number;
    neighborAs?: number;
    /**
     * if per-neighbor as is desired. Property key is the neighbor address
     */
    neighbors?: {[key: string]: outputs.OrgGatewaytemplateBgpConfigNeighbors};
    /**
     * if `type`!=`external`or `via`==`wan`networks where we expect BGP neighbor to connect to/from
     */
    networks: string[];
    /**
     * by default, we'll re-advertise all learned BGP routers toward overlay
     */
    noReadvertiseToOverlay: boolean;
    /**
     * enum: `external`, `internal`
     */
    type?: string;
    /**
     * network name. enum: `lan`, `vpn`, `wan`
     */
    via: string;
    vpnName?: string;
    /**
     * if `via`==`wan`
     */
    wanName?: string;
}

export interface OrgGatewaytemplateBgpConfigCommunity {
    id?: string;
    localPreference?: number;
    vpnName?: string;
}

export interface OrgGatewaytemplateBgpConfigNeighbors {
    /**
     * If true, the BGP session to this neighbor will be administratively disabled/shutdown
     */
    disabled: boolean;
    exportPolicy?: string;
    holdTime: number;
    importPolicy?: string;
    /**
     * assuming BGP neighbor is directly connected
     */
    multihopTtl?: number;
    neighborAs?: number;
}

export interface OrgGatewaytemplateDhcpdConfig {
    config?: {[key: string]: outputs.OrgGatewaytemplateDhcpdConfigConfig};
    /**
     * if set to `true`, enable the DHCP server
     */
    enabled: boolean;
}

export interface OrgGatewaytemplateDhcpdConfigConfig {
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsServers?: string[];
    /**
     * if `type`==`local` - optional, if not defined, system one will be used
     */
    dnsSuffixes: string[];
    /**
     * Property key is the MAC Address. Format is `[0-9a-f]{12}` (e.g "5684dae9ac8b")
     */
    fixedBindings?: {[key: string]: outputs.OrgGatewaytemplateDhcpdConfigConfigFixedBindings};
    /**
     * if `type`==`local` - optional, `ip` will be used if not provided
     */
    gateway?: string;
    /**
     * if `type`==`local`
     */
    ipEnd?: string;
    /**
     * if `type6`==`local`
     */
    ipEnd6?: string;
    /**
     * if `type`==`local`
     */
    ipStart?: string;
    /**
     * if `type6`==`local`
     */
    ipStart6?: string;
    /**
     * in seconds, lease time has to be between 3600 [1hr] - 604800 [1 week], default is 86400 [1 day]
     */
    leaseTime: number;
    /**
     * Property key is the DHCP option number
     */
    options?: {[key: string]: outputs.OrgGatewaytemplateDhcpdConfigConfigOptions};
    /**
     * `server_id_override`==`true` means the device, when acts as DHCP relay and forwards DHCP responses from DHCP server to clients, 
     * should overwrite the Sever Identifier option (i.e. DHCP option 54) in DHCP responses with its own IP address.
     */
    serverIdOverride: boolean;
    /**
     * if `type`==`relay`
     */
    servers: string[];
    /**
     * if `type6`==`relay`
     */
    servers6s: string[];
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type: string;
    /**
     * enum: `local` (DHCP Server), `none`, `relay` (DHCP Relay)
     */
    type6: string;
    /**
     * Property key is <enterprise number>:<sub option code>, with
     *   * enterprise number: 1-65535 (https://www.iana.org/assignments/enterprise-numbers/enterprise-numbers)
     *   * sub option code: 1-255, sub-option code'
     */
    vendorEncapulated?: {[key: string]: outputs.OrgGatewaytemplateDhcpdConfigConfigVendorEncapulated};
}

export interface OrgGatewaytemplateDhcpdConfigConfigFixedBindings {
    ip: string;
    name?: string;
}

export interface OrgGatewaytemplateDhcpdConfigConfigOptions {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface OrgGatewaytemplateDhcpdConfigConfigVendorEncapulated {
    /**
     * enum: `boolean`, `hex`, `int16`, `int32`, `ip`, `string`, `uint16`, `uint32`
     */
    type?: string;
    value?: string;
}

export interface OrgGatewaytemplateExtraRoutes {
    via: string;
}

export interface OrgGatewaytemplateExtraRoutes6 {
    via: string;
}

export interface OrgGatewaytemplateIdpProfiles {
    /**
     * enum: `critical`, `standard`, `strict`
     */
    baseProfile?: string;
    name?: string;
    orgId?: string;
    overwrites?: outputs.OrgGatewaytemplateIdpProfilesOverwrite[];
}

export interface OrgGatewaytemplateIdpProfilesOverwrite {
    /**
     * enum:
     *   * alert (default)
     *   * drop: siliently dropping packets
     *   * close: notify client/server to close connection
     */
    action: string;
    matching?: outputs.OrgGatewaytemplateIdpProfilesOverwriteMatching;
    name?: string;
}

export interface OrgGatewaytemplateIdpProfilesOverwriteMatching {
    attackNames?: string[];
    dstSubnets?: string[];
    severities?: string[];
}

export interface OrgGatewaytemplateIpConfigs {
    ip: string;
    netmask: string;
    /**
     * optional list of secondary IPs in CIDR format
     */
    secondaryIps: string[];
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
}

export interface OrgGatewaytemplateNetwork {
    /**
     * whether to disallow Mist Devices in the network
     */
    disallowMistServices: boolean;
    gateway?: string;
    gateway6?: string;
    internalAccess?: outputs.OrgGatewaytemplateNetworkInternalAccess;
    /**
     * whether this network has direct internet access
     */
    internetAccess?: outputs.OrgGatewaytemplateNetworkInternetAccess;
    /**
     * whether to allow clients in the network to talk to each other
     */
    isolation?: boolean;
    name: string;
    /**
     * for a Network (usually LAN), it can be routable to other networks (e.g. OSPF)
     */
    routedForNetworks?: string[];
    subnet: string;
    subnet6?: string;
    tenants?: {[key: string]: outputs.OrgGatewaytemplateNetworkTenants};
    vlanId?: string;
    /**
     * Property key is the VPN name. Whether this network can be accessed from vpn
     */
    vpnAccess?: {[key: string]: outputs.OrgGatewaytemplateNetworkVpnAccess};
}

export interface OrgGatewaytemplateNetworkInternalAccess {
    enabled?: boolean;
}

export interface OrgGatewaytemplateNetworkInternetAccess {
    createSimpleServicePolicy: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat?: {[key: string]: outputs.OrgGatewaytemplateNetworkInternetAccessDestinationNat};
    enabled?: boolean;
    /**
     * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
     */
    restricted: boolean;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat?: {[key: string]: outputs.OrgGatewaytemplateNetworkInternetAccessStaticNat};
}

export interface OrgGatewaytemplateNetworkInternetAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgGatewaytemplateNetworkInternetAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgGatewaytemplateNetworkTenants {
    addresses?: string[];
}

export interface OrgGatewaytemplateNetworkVpnAccess {
    /**
     * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
     */
    advertisedSubnet?: string;
    /**
     * whether to allow ping from vpn into this routed network
     */
    allowPing?: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat: {[key: string]: outputs.OrgGatewaytemplateNetworkVpnAccessDestinationNat};
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
     */
    natPool?: string;
    /**
     * toward LAN-side BGP peers
     */
    noReadvertiseToLanBgp: boolean;
    /**
     * toward LAN-side OSPF peers
     */
    noReadvertiseToLanOspf: boolean;
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    noReadvertiseToOverlay?: boolean;
    /**
     * by default, the routes are only readvertised toward the same vrf on spoke
     * to allow it to be leaked to other vrfs
     */
    otherVrfs: string[];
    /**
     * whether this network is routable
     */
    routed?: boolean;
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
     */
    sourceNat: outputs.OrgGatewaytemplateNetworkVpnAccessSourceNat;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat: {[key: string]: outputs.OrgGatewaytemplateNetworkVpnAccessStaticNat};
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    summarizedSubnet?: string;
    /**
     * toward LAN-side BGP peers
     */
    summarizedSubnetToLanBgp?: string;
    /**
     * toward LAN-side OSPF peers
     */
    summarizedSubnetToLanOspf?: string;
}

export interface OrgGatewaytemplateNetworkVpnAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgGatewaytemplateNetworkVpnAccessSourceNat {
    externalIp?: string;
}

export interface OrgGatewaytemplateNetworkVpnAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgGatewaytemplateOobIpConfig {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    /**
     * if `type`==`static`
     */
    ip?: string;
    /**
     * if `type`==`static`
     */
    netmask?: string;
    /**
     * for HA Cluster, node1 can have different IP Config
     */
    node1?: outputs.OrgGatewaytemplateOobIpConfigNode1;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired,
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface OrgGatewaytemplateOobIpConfigNode1 {
    /**
     * if `type`==`static`
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * enum: `dhcp`, `static`
     */
    type: string;
    /**
     * if supported on the platform. If enabled, DNS will be using this routing-instance, too
     */
    useMgmtVrf: boolean;
    /**
     * whether to use `mgmt_junos` for host-out traffic (NTP/TACPLUS/RADIUS/SYSLOG/SNMP), if alternative source network/ip is desired
     */
    useMgmtVrfForHostOut: boolean;
    vlanId?: string;
}

export interface OrgGatewaytemplatePathPreferences {
    paths?: outputs.OrgGatewaytemplatePathPreferencesPath[];
    /**
     * enum: `ecmp`, `ordered`, `weighted`
     */
    strategy: string;
}

export interface OrgGatewaytemplatePathPreferencesPath {
    cost?: number;
    /**
     * For SSR Only. `true`, if this specific path is undesired
     */
    disabled?: boolean;
    /**
     * only if `type`==`local`, if a different gateway is desired
     */
    gatewayIp?: string;
    /**
     * only if `type`==`vpn`, if this vpn path can be used for internet
     */
    internetAccess?: boolean;
    /**
     * required when 
     *   * `type`==`vpn`: the name of the VPN Path to use 
     *   * `type`==`wan`: the name of the WAN interface to use'
     */
    name?: string;
    /**
     * required when `type`==`local`
     */
    networks: string[];
    /**
     * if `type`==`local`, if destination IP is to be replaced
     */
    targetIps: string[];
    /**
     * enum: `local`, `tunnel`, `vpn`, `wan`
     */
    type?: string;
    /**
     * required when`type`==`tunnel`
     */
    wanName?: string;
}

export interface OrgGatewaytemplatePortConfig {
    description?: string;
    disableAutoneg: boolean;
    /**
     * port admin up (true) / down (false)
     */
    disabled: boolean;
    /**
     * if `wan_type`==`dsl`. enum: `adsl`, `vdsl`
     */
    dslType: string;
    /**
     * if `wan_type`==`dsl`
     * 16 bit int
     */
    dslVci: number;
    /**
     * if `wan_type`==`dsl`
     * 8 bit int
     */
    dslVpi: number;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Junos IP Config
     */
    ipConfig?: outputs.OrgGatewaytemplatePortConfigIpConfig;
    /**
     * if `wan_type`==`lte`
     */
    lteApn?: string;
    /**
     * if `wan_type`==`lte`. enum: `chap`, `none`, `pap`
     */
    lteAuth: string;
    lteBackup?: boolean;
    /**
     * if `wan_type`==`lte`
     */
    ltePassword?: string;
    /**
     * if `wan_type`==`lte`
     */
    lteUsername?: string;
    mtu?: number;
    /**
     * name that we'll use to derive config
     */
    name?: string;
    /**
     * if `usage`==`lan`
     */
    networks: string[];
    /**
     * for Q-in-Q
     */
    outerVlanId?: number;
    poeDisabled: boolean;
    /**
     * if `usage`==`lan`
     */
    portNetwork?: string;
    /**
     * whether to preserve dscp when sending traffic over VPN (SSR-only)
     */
    preserveDscp: boolean;
    /**
     * if HA mode
     */
    redundant?: boolean;
    /**
     * if HA mode
     */
    rethIdx?: number;
    /**
     * if HA mode
     */
    rethNode?: string;
    /**
     * SSR only - supporting vlan-based redundancy (matching the size of `networks`)
     */
    rethNodes: string[];
    speed: string;
    /**
     * when SSR is running as VM, this is required on certain hosting platforms
     */
    ssrNoVirtualMac: boolean;
    /**
     * for SSR only
     */
    svrPortRange: string;
    trafficShaping?: outputs.OrgGatewaytemplatePortConfigTrafficShaping;
    /**
     * port usage name. enum: `ha_control`, `ha_data`, `lan`, `wan`
     */
    usage: string;
    /**
     * if WAN interface is on a VLAN
     */
    vlanId?: number;
    vpnPaths?: {[key: string]: outputs.OrgGatewaytemplatePortConfigVpnPaths};
    /**
     * when `wan_type`==`broadband`. enum: `default`, `max`, `recommended`
     */
    wanArpPolicer: string;
    /**
     * optional, if spoke should reach this port by a different IP
     */
    wanExtIp?: string;
    /**
     * optional, by default, source-NAT is performed on all WAN Ports using the interface-ip
     */
    wanSourceNat?: outputs.OrgGatewaytemplatePortConfigWanSourceNat;
    /**
     * if `usage`==`wan`. enum: `broadband`, `dsl`, `lte`
     */
    wanType: string;
}

export interface OrgGatewaytemplatePortConfigIpConfig {
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dns?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    dnsSuffixes?: string[];
    /**
     * except for out-of_band interface (vme/em0/fxp0)
     */
    gateway?: string;
    ip?: string;
    /**
     * used only if `subnet` is not specified in `networks`
     */
    netmask?: string;
    /**
     * optional, the network to be used for mgmt
     */
    network?: string;
    /**
     * if `type`==`pppoe`
     */
    poserPassword?: string;
    /**
     * if `type`==`pppoe`. enum: `chap`, `none`, `pap`
     */
    pppoeAuth: string;
    /**
     * if `type`==`pppoe`
     */
    pppoeUsername?: string;
    /**
     * enum: `dhcp`, `pppoe`, `static`
     */
    type: string;
}

export interface OrgGatewaytemplatePortConfigTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface OrgGatewaytemplatePortConfigVpnPaths {
    /**
     * enum: `broadband`, `lte`
     */
    bfdProfile: string;
    /**
     * whether to use tunnel mode. SSR only
     */
    bfdUseTunnelMode: boolean;
    /**
     * for a given VPN, when `path_selection.strategy`==`simple`, the preference for a path (lower is preferred)
     */
    preference?: number;
    /**
     * enum: `hub`, `spoke`
     */
    role: string;
    trafficShaping?: outputs.OrgGatewaytemplatePortConfigVpnPathsTrafficShaping;
}

export interface OrgGatewaytemplatePortConfigVpnPathsTrafficShaping {
    /**
     * percentages for differet class of traffic: high / medium / low / best-effort
     * sum must be equal to 100
     */
    classPercentages?: number[];
    enabled: boolean;
}

export interface OrgGatewaytemplatePortConfigWanSourceNat {
    /**
     * or to disable the source-nat
     */
    disabled: boolean;
    /**
     * if alternative nat_pool is desired
     */
    natPool?: string;
}

export interface OrgGatewaytemplateRoutingPolicies {
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    terms?: outputs.OrgGatewaytemplateRoutingPoliciesTerm[];
}

export interface OrgGatewaytemplateRoutingPoliciesTerm {
    /**
     * when used as import policy
     */
    action?: outputs.OrgGatewaytemplateRoutingPoliciesTermAction;
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    matching?: outputs.OrgGatewaytemplateRoutingPoliciesTermMatching;
}

export interface OrgGatewaytemplateRoutingPoliciesTermAction {
    accept?: boolean;
    addCommunities?: string[];
    /**
     * for SSR, hub decides how VRF routes are leaked on spoke
     */
    addTargetVrfs?: string[];
    /**
     * when used as export policy, optional
     */
    communities?: string[];
    /**
     * when used as export policy, optional. To exclude certain AS
     */
    excludeAsPaths?: string[];
    excludeCommunities?: string[];
    /**
     * when used as export policy, optional
     */
    exportCommunitites?: string[];
    /**
     * optional, for an import policy, local_preference can be changed
     */
    localPreference?: string;
    /**
     * when used as export policy, optional. By default, the local AS will be prepended, to change it
     */
    prependAsPaths?: string[];
}

export interface OrgGatewaytemplateRoutingPoliciesTermMatching {
    /**
     * takes regular expression
     */
    asPaths?: string[];
    communities?: string[];
    networks?: string[];
    /**
     * zero or more criteria/filter can be specified to match the term, all criteria have to be met
     */
    prefixes?: string[];
    /**
     * `direct`, `bgp`, `osp`, ...
     */
    protocols?: string[];
    routeExists?: outputs.OrgGatewaytemplateRoutingPoliciesTermMatchingRouteExists;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     */
    vpnNeighborMacs?: string[];
    vpnPathSla?: outputs.OrgGatewaytemplateRoutingPoliciesTermMatchingVpnPathSla;
    /**
     * overlay-facing criteria (used for bgp_config where via=vpn)
     * ordered-
     */
    vpnPaths?: string[];
}

export interface OrgGatewaytemplateRoutingPoliciesTermMatchingRouteExists {
    route?: string;
    /**
     * name of the vrf instance
     * it can also be the name of the VPN or wan if they
     */
    vrfName: string;
}

export interface OrgGatewaytemplateRoutingPoliciesTermMatchingVpnPathSla {
    maxJitter?: number;
    maxLatency?: number;
    maxLoss?: number;
}

export interface OrgGatewaytemplateServicePolicy {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    /**
     * For SRX Only
     */
    appqoe?: outputs.OrgGatewaytemplateServicePolicyAppqoe;
    ewfs?: outputs.OrgGatewaytemplateServicePolicyEwf[];
    idp?: outputs.OrgGatewaytemplateServicePolicyIdp;
    /**
     * access within the same VRF
     */
    localRouting: boolean;
    name?: string;
    /**
     * by default, we derive all paths available and use them
     * optionally, you can customize by using `path_preference`
     */
    pathPreference?: string;
    /**
     * used to link servicepolicy defined at org level and overwrite some attributes
     */
    servicepolicyId?: string;
    services: string[];
    tenants: string[];
}

export interface OrgGatewaytemplateServicePolicyAppqoe {
    enabled: boolean;
}

export interface OrgGatewaytemplateServicePolicyEwf {
    alertOnly?: boolean;
    blockMessage?: string;
    enabled: boolean;
    /**
     * enum: `critical`, `standard`, `strict`
     */
    profile: string;
}

export interface OrgGatewaytemplateServicePolicyIdp {
    alertOnly?: boolean;
    enabled: boolean;
    /**
     * org_level IDP Profile can be used, this takes precedence over `profile`
     */
    idpprofileId?: string;
    /**
     * `strict` (default) / `standard` / or keys from from idp_profiles
     */
    profile: string;
}

export interface OrgGatewaytemplateTunnelConfigs {
    autoProvision?: outputs.OrgGatewaytemplateTunnelConfigsAutoProvision;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    ikeLifetime?: number;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `aggressive`, `main`
     */
    ikeMode: string;
    /**
     * if `provider`== `custom-ipsec`
     */
    ikeProposals?: outputs.OrgGatewaytemplateTunnelConfigsIkeProposal[];
    /**
     * if `provider`== `custom-ipsec`
     */
    ipsecLifetime?: number;
    /**
     * Only if  `provider`== `custom-ipsec`
     */
    ipsecProposals?: outputs.OrgGatewaytemplateTunnelConfigsIpsecProposal[];
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    localId?: string;
    /**
     * enum: `active-active`, `active-standby`
     */
    mode: string;
    primary?: outputs.OrgGatewaytemplateTunnelConfigsPrimary;
    /**
     * Only if `provider`== `custom-ipsec`
     */
    probe?: outputs.OrgGatewaytemplateTunnelConfigsProbe;
    /**
     * Only if `provider`== `custom-ipsec`. enum: `gre`, `ipsec`
     */
    protocol?: string;
    /**
     * enum: `custom-ipsec`, `customer-gre`, `jse-ipsec`, `zscaler-gre`, `zscaler-ipsec`
     */
    provider?: string;
    /**
     * Only if:
     *   * `provider`== `zscaler-ipsec`
     *   * `provider`==`jse-ipsec`
     *   * `provider`== `custom-ipsec`
     */
    psk?: string;
    secondary?: outputs.OrgGatewaytemplateTunnelConfigsSecondary;
    /**
     * Only if `provider`== `custom-gre` or `provider`== `custom-ipsec`. enum: `1`, `2`
     */
    version: string;
}

export interface OrgGatewaytemplateTunnelConfigsAutoProvision {
    enable?: boolean;
    latlng?: outputs.OrgGatewaytemplateTunnelConfigsAutoProvisionLatlng;
    primary?: outputs.OrgGatewaytemplateTunnelConfigsAutoProvisionPrimary;
    /**
     * enum: `APAC`, `Americas`, `EMEA`, `auto`
     */
    region: string;
    secondary?: outputs.OrgGatewaytemplateTunnelConfigsAutoProvisionSecondary;
}

export interface OrgGatewaytemplateTunnelConfigsAutoProvisionLatlng {
    lat: number;
    lng: number;
}

export interface OrgGatewaytemplateTunnelConfigsAutoProvisionPrimary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface OrgGatewaytemplateTunnelConfigsAutoProvisionSecondary {
    numHosts?: string;
    /**
     * optional, only needed if `vars_only`==`false`
     */
    wanNames?: string[];
}

export interface OrgGatewaytemplateTunnelConfigsIkeProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface OrgGatewaytemplateTunnelConfigsIpsecProposal {
    /**
     * enum: `md5`, `sha1`, `sha2`
     */
    authAlgo?: string;
    /**
     * Only if `provider`== `custom-ipsec`. enum:
     *   * 1
     *   * 2 (1024-bit)
     *   * 5
     *   * 14 (default, 2048-bit)
     *   * 15 (3072-bit)
     *   * 16 (4096-bit)
     *   * 19 (256-bit ECP)
     *   * 20 (384-bit ECP)
     *   * 21 (521-bit ECP)
     *   * 24 (2048-bit ECP)
     */
    dhGroup: string;
    /**
     * enum: `3des`, `aes128`, `aes256`, `aes_gcm128`, `aes_gcm256`
     */
    encAlgo: string;
}

export interface OrgGatewaytemplateTunnelConfigsPrimary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface OrgGatewaytemplateTunnelConfigsProbe {
    /**
     * how often to trigger the probe
     */
    interval?: number;
    /**
     * number of consecutive misses before declaring the tunnel down
     */
    threshold?: number;
    /**
     * time within which to complete the connectivity check
     */
    timeout?: number;
    /**
     * enum: `http`, `icmp`
     */
    type: string;
}

export interface OrgGatewaytemplateTunnelConfigsSecondary {
    hosts?: string[];
    /**
     * Only if:
     *   * `provider`== `zscaler-gre`
     *   * `provider`== `custom-gre`
     */
    internalIps?: string[];
    probeIps?: string[];
    /**
     * Only if `provider`== `custom-ipsec`
     */
    remoteIds?: string[];
    wanNames?: string[];
}

export interface OrgGatewaytemplateTunnelProviderOptions {
    /**
     * for jse-ipsec, this allow provisioning of adequate resource on JSE. Make sure adequate licenses are added
     */
    jse?: outputs.OrgGatewaytemplateTunnelProviderOptionsJse;
    /**
     * for zscaler-ipsec and zscaler-gre
     */
    zscaler?: outputs.OrgGatewaytemplateTunnelProviderOptionsZscaler;
}

export interface OrgGatewaytemplateTunnelProviderOptionsJse {
    name?: string;
    numUsers?: number;
}

export interface OrgGatewaytemplateTunnelProviderOptionsZscaler {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    name?: string;
    /**
     * if `use_xff`==`true`
     */
    subLocations?: outputs.OrgGatewaytemplateTunnelProviderOptionsZscalerSubLocation[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
    /**
     * location uses proxy chaining to forward traffic
     */
    useXff?: boolean;
}

export interface OrgGatewaytemplateTunnelProviderOptionsZscalerSubLocation {
    aupAcceptanceRequired: boolean;
    /**
     * days before AUP is requested again
     */
    aupExpire: number;
    /**
     * proxy HTTPs traffic, requiring Zscaler cert to be installed in browser
     */
    aupSslProxy: boolean;
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    downloadMbps?: number;
    /**
     * if `use_xff`==`true`, display Acceptable Use Policy (AUP)
     */
    enableAup?: boolean;
    /**
     * when `enforce_authentication`==`false`, display caution notification for non-authenticated users
     */
    enableCaution: boolean;
    enforceAuthentication: boolean;
    subnets?: string[];
    /**
     * the download bandwidth cap of the link, in Mbps
     */
    uploadMbps?: number;
}

export interface OrgGatewaytemplateVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface OrgGatewaytemplateVrfInstances {
    networks?: string[];
}

export interface OrgIdpprofileOverwrite {
    /**
     * enum:
     *   * alert (default)
     *   * drop: siliently dropping packets
     *   * close: notify client/server to close connection
     */
    action: string;
    matching?: outputs.OrgIdpprofileOverwriteMatching;
    name: string;
}

export interface OrgIdpprofileOverwriteMatching {
    attackNames?: string[];
    dstSubnets?: string[];
    severities?: string[];
}

export interface OrgInventoryDevice {
    /**
     * Device Claim Code. Required for claimed devices. Removing an adopted device from the list will release it
     */
    claimCode: string;
    /**
     * Device Hostname
     */
    hostname: string;
    /**
     * Mist Device ID
     */
    id: string;
    /**
     * Device MAC address. Required to assign adopted devices to site. Removing an adopted device from the list will not release it, but will unassign it from the site. Cannot be specified when `claim_code` is used
     */
    mac: string;
    /**
     * Device model
     */
    model: string;
    orgId: string;
    /**
     * Device serial
     */
    serial: string;
    /**
     * Site ID. Used to assign device to a Site
     */
    siteId?: string;
    type: string;
    /**
     * Virtual Chassis MAC Address
     */
    vcMac: string;
}

export interface OrgNacruleMatching {
    /**
     * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
     */
    authType?: string;
    nactags: string[];
    portTypes: string[];
    /**
     * list of site ids to match
     */
    siteIds: string[];
    /**
     * list of sitegroup ids to match
     */
    sitegroupIds: string[];
    /**
     * list of vendors to match
     */
    vendors: string[];
}

export interface OrgNacruleNotMatching {
    /**
     * enum: `cert`, `device-auth`, `eap-teap`, `eap-tls`, `eap-ttls`, `idp`, `mab`, `psk`
     */
    authType?: string;
    nactags: string[];
    portTypes: string[];
    /**
     * list of site ids to match
     */
    siteIds: string[];
    /**
     * list of sitegroup ids to match
     */
    sitegroupIds: string[];
    /**
     * list of vendors to match
     */
    vendors: string[];
}

export interface OrgNetworkInternalAccess {
    enabled?: boolean;
}

export interface OrgNetworkInternetAccess {
    createSimpleServicePolicy: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat?: {[key: string]: outputs.OrgNetworkInternetAccessDestinationNat};
    enabled?: boolean;
    /**
     * by default, all access is allowed, to only allow certain traffic, make `restricted`=`true` and define service_policies
     */
    restricted: boolean;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat?: {[key: string]: outputs.OrgNetworkInternetAccessStaticNat};
}

export interface OrgNetworkInternetAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgNetworkInternetAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgNetworkTenants {
    addresses?: string[];
}

export interface OrgNetworkVpnAccess {
    /**
     * if `routed`==`true`, whether to advertise an aggregated subnet toward HUB this is useful when there are multiple networks on SPOKE's side
     */
    advertisedSubnet?: string;
    /**
     * whether to allow ping from vpn into this routed network
     */
    allowPing?: boolean;
    /**
     * Property key may be an IP/Port (i.e. "63.16.0.3:443"), or a port (i.e. ":2222")
     */
    destinationNat: {[key: string]: outputs.OrgNetworkVpnAccessDestinationNat};
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub, a subnet is required to create and advertise the route to Hub
     */
    natPool?: string;
    /**
     * toward LAN-side BGP peers
     */
    noReadvertiseToLanBgp: boolean;
    /**
     * toward LAN-side OSPF peers
     */
    noReadvertiseToLanOspf: boolean;
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    noReadvertiseToOverlay?: boolean;
    /**
     * by default, the routes are only readvertised toward the same vrf on spoke
     * to allow it to be leaked to other vrfs
     */
    otherVrfs: string[];
    /**
     * whether this network is routable
     */
    routed?: boolean;
    /**
     * if `routed`==`false` (usually at Spoke), but some hosts needs to be reachable from Hub
     */
    sourceNat: outputs.OrgNetworkVpnAccessSourceNat;
    /**
     * Property key may be an IP Address (i.e. "172.16.0.1"), and IP Address and Port (i.e. "172.16.0.1:8443") or a CIDR (i.e. "172.16.0.12/20")
     */
    staticNat: {[key: string]: outputs.OrgNetworkVpnAccessStaticNat};
    /**
     * toward overlay
     * how HUB should deal with routes it received from Spokes
     */
    summarizedSubnet?: string;
    /**
     * toward LAN-side BGP peers
     */
    summarizedSubnetToLanBgp?: string;
    /**
     * toward LAN-side OSPF peers
     */
    summarizedSubnetToLanOspf?: string;
}

export interface OrgNetworkVpnAccessDestinationNat {
    internalIp?: string;
    name?: string;
    port?: number;
}

export interface OrgNetworkVpnAccessSourceNat {
    externalIp?: string;
}

export interface OrgNetworkVpnAccessStaticNat {
    internalIp?: string;
    name?: string;
    /**
     * If not set, we configure the nat policies against all WAN ports for simplicity
     */
    wanName?: string;
}

export interface OrgNetworktemplateAclPolicy {
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    actions?: outputs.OrgNetworktemplateAclPolicyAction[];
    name?: string;
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    srcTags?: string[];
}

export interface OrgNetworktemplateAclPolicyAction {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    dstTag?: string;
}

export interface OrgNetworktemplateAclTags {
    /**
     * required if
     * - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
     * - `type`==`static_gbp` (applying gbp tag against matching conditions)
     */
    gbpTag?: number;
    /**
     * required if 
     * - `type`==`mac`
     * - `type`==`static_gbp` if from matching mac
     */
    macs?: string[];
    /**
     * if:
     *   * `type`==`mac` (optional. default is `any`)
     *   * `type`==`subnet` (optional. default is `any`)
     *   * `type`==`network`
     *   * `type`==`resource` (optional. default is `any`)
     *   * `type`==`static_gbp` if from matching network (vlan)'
     */
    network?: string;
    /**
     * required if:
     *   * `type`==`radius_group`
     *   * `type`==`static_gbp`
     * if from matching radius_group
     */
    radiusGroup?: string;
    /**
     * if `type`==`resource`
     * empty means unrestricted, i.e. any
     */
    specs?: outputs.OrgNetworktemplateAclTagsSpec[];
    /**
     * if 
     * - `type`==`subnet` 
     * - `type`==`resource` (optional. default is `any`)
     * - `type`==`static_gbp` if from matching subnet
     */
    subnets?: string[];
    /**
     * enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
     */
    type: string;
}

export interface OrgNetworktemplateAclTagsSpec {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
     */
    protocol: string;
}

export interface OrgNetworktemplateDhcpSnooping {
    allNetworks?: boolean;
    /**
     * Enable for dynamic ARP inspection check
     */
    enableArpSpoofCheck?: boolean;
    /**
     * Enable for check for forging source IP address
     */
    enableIpSourceGuard?: boolean;
    enabled?: boolean;
    /**
     * if `all_networks`==`false`, list of network with DHCP snooping enabled
     */
    networks?: string[];
}

export interface OrgNetworktemplateExtraRoutes {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.OrgNetworktemplateExtraRoutesNextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface OrgNetworktemplateExtraRoutes6 {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.OrgNetworktemplateExtraRoutes6NextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface OrgNetworktemplateExtraRoutes6NextQualified {
    metric?: number;
    preference?: number;
}

export interface OrgNetworktemplateExtraRoutesNextQualified {
    metric?: number;
    preference?: number;
}

export interface OrgNetworktemplateMistNac {
    enabled?: boolean;
    network?: string;
}

export interface OrgNetworktemplateNetworks {
    /**
     * whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
     * NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
     */
    isolation: boolean;
    isolationVlanId?: string;
    /**
     * optional for pure switching, required when L3 / routing features are used
     */
    subnet?: string;
    vlanId: string;
}

export interface OrgNetworktemplatePortMirroring {
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputNetworksIngresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsEgresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsIngresses: string[];
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputNetwork?: string;
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputPortId?: string;
}

export interface OrgNetworktemplatePortUsages {
    /**
     * Only if `mode`==`trunk` whether to trunk all network/vlans
     */
    allNetworks: boolean;
    /**
     * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
     *
     * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
     */
    allowDhcpd?: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    allowMultipleSupplicants: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDown: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDownForUnkonwnClient: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    description?: string;
    /**
     * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * Only if `mode`!=`dynamic` whether the port is disabled
     */
    disabled: boolean;
    /**
     * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     */
    dynamicVlanNetworks: string[];
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
     */
    enableMacAuth: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    enableQos: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     */
    guestNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
     * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     */
    interSwitchLink: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
     */
    macAuthOnly?: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     */
    macAuthProtocol: string;
    /**
     * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     */
    macLimit: number;
    /**
     * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     */
    mode?: string;
    /**
     * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     */
    mtu?: number;
    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     */
    networks: string[];
    /**
     * Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     */
    persistMac: boolean;
    /**
     * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
     */
    poeDisabled: boolean;
    /**
     * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
     */
    portAuth?: string;
    /**
     * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
     */
    portNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
     */
    reauthInterval: number;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
     */
    rejectedNetwork?: string;
    /**
     * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
     */
    resetDefaultWhen: string;
    /**
     * Only if `mode`==`dynamic`
     */
    rules?: outputs.OrgNetworktemplatePortUsagesRule[];
    /**
     * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
     */
    speed?: string;
    /**
     * Switch storm control
     * Only if `mode`!=`dynamic`
     */
    stormControl?: outputs.OrgNetworktemplatePortUsagesStormControl;
    /**
     * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
     */
    stpEdge: boolean;
    stpNoRootPort: boolean;
    stpP2p: boolean;
    /**
     * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     */
    voipNetwork?: string;
}

export interface OrgNetworktemplatePortUsagesRule {
    equals?: string;
    /**
     * use `equals_any` to match any item in a list
     */
    equalsAnies?: string[];
    /**
     * "[0:3]":"abcdef" > "abc"
     * "split(.)[1]": "a.b.c" > "b"
     * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
     */
    expression?: string;
    /**
     * enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
     */
    src: string;
    /**
     * `port_usage` name
     */
    usage?: string;
}

export interface OrgNetworktemplatePortUsagesStormControl {
    /**
     * whether to disable storm control on broadcast traffic
     */
    noBroadcast: boolean;
    /**
     * whether to disable storm control on multicast traffic
     */
    noMulticast: boolean;
    /**
     * whether to disable storm control on registered multicast traffic
     */
    noRegisteredMulticast: boolean;
    /**
     * whether to disable storm control on unknown unicast traffic
     */
    noUnknownUnicast: boolean;
    /**
     * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
     */
    percentage: number;
}

export interface OrgNetworktemplateRadiusConfig {
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    acctInterimInterval: number;
    acctServers?: outputs.OrgNetworktemplateRadiusConfigAcctServer[];
    authServers?: outputs.OrgNetworktemplateRadiusConfigAuthServer[];
    /**
     * radius auth session retries
     */
    authServersRetries: number;
    /**
     * radius auth session timeout
     */
    authServersTimeout: number;
    coaEnabled: boolean;
    coaPort: number;
    /**
     * use `network`or `source_ip`
     * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
     */
    network?: string;
    /**
     * use `network`or `source_ip`
     */
    sourceIp?: string;
}

export interface OrgNetworktemplateRadiusConfigAcctServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Acct port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface OrgNetworktemplateRadiusConfigAuthServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Auth port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface OrgNetworktemplateRemoteSyslog {
    archive?: outputs.OrgNetworktemplateRemoteSyslogArchive;
    console?: outputs.OrgNetworktemplateRemoteSyslogConsole;
    enabled: boolean;
    files?: outputs.OrgNetworktemplateRemoteSyslogFile[];
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    network?: string;
    sendToAllServers: boolean;
    servers?: outputs.OrgNetworktemplateRemoteSyslogServer[];
    /**
     * enum: `millisecond`, `year`, `year millisecond`
     */
    timeFormat?: string;
    users?: outputs.OrgNetworktemplateRemoteSyslogUser[];
}

export interface OrgNetworktemplateRemoteSyslogArchive {
    files?: number;
    size?: string;
}

export interface OrgNetworktemplateRemoteSyslogConsole {
    contents?: outputs.OrgNetworktemplateRemoteSyslogConsoleContent[];
}

export interface OrgNetworktemplateRemoteSyslogConsoleContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface OrgNetworktemplateRemoteSyslogFile {
    archive?: outputs.OrgNetworktemplateRemoteSyslogFileArchive;
    contents?: outputs.OrgNetworktemplateRemoteSyslogFileContent[];
    explicitPriority?: boolean;
    file?: string;
    match?: string;
    structuredData?: boolean;
}

export interface OrgNetworktemplateRemoteSyslogFileArchive {
    files?: number;
    size?: string;
}

export interface OrgNetworktemplateRemoteSyslogFileContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface OrgNetworktemplateRemoteSyslogServer {
    contents?: outputs.OrgNetworktemplateRemoteSyslogServerContent[];
    explicitPriority?: boolean;
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    host?: string;
    match?: string;
    port: number;
    /**
     * enum: `tcp`, `udp`
     */
    protocol: string;
    routingInstance?: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    sourceAddress?: string;
    structuredData?: boolean;
    tag?: string;
}

export interface OrgNetworktemplateRemoteSyslogServerContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface OrgNetworktemplateRemoteSyslogUser {
    contents?: outputs.OrgNetworktemplateRemoteSyslogUserContent[];
    match?: string;
    user?: string;
}

export interface OrgNetworktemplateRemoteSyslogUserContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface OrgNetworktemplateSnmpConfig {
    clientLists?: outputs.OrgNetworktemplateSnmpConfigClientList[];
    contact?: string;
    description?: string;
    enabled: boolean;
    /**
     * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
     */
    engineId?: string;
    location?: string;
    name?: string;
    network: string;
    trapGroups?: outputs.OrgNetworktemplateSnmpConfigTrapGroup[];
    v2cConfigs?: outputs.OrgNetworktemplateSnmpConfigV2cConfig[];
    v3Config?: outputs.OrgNetworktemplateSnmpConfigV3Config;
    views?: outputs.OrgNetworktemplateSnmpConfigView[];
}

export interface OrgNetworktemplateSnmpConfigClientList {
    clientListName?: string;
    clients?: string[];
}

export interface OrgNetworktemplateSnmpConfigTrapGroup {
    categories?: string[];
    /**
     * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
     */
    groupName?: string;
    targets?: string[];
    /**
     * enum: `all`, `v1`, `v2`
     */
    version: string;
}

export interface OrgNetworktemplateSnmpConfigV2cConfig {
    authorization?: string;
    /**
     * client_list_name here should refer to client_list above
     */
    clientListName?: string;
    communityName?: string;
    /**
     * view name here should be defined in views above
     */
    view?: string;
}

export interface OrgNetworktemplateSnmpConfigV3Config {
    notifies?: outputs.OrgNetworktemplateSnmpConfigV3ConfigNotify[];
    notifyFilters?: outputs.OrgNetworktemplateSnmpConfigV3ConfigNotifyFilter[];
    targetAddresses?: outputs.OrgNetworktemplateSnmpConfigV3ConfigTargetAddress[];
    targetParameters?: outputs.OrgNetworktemplateSnmpConfigV3ConfigTargetParameter[];
    usm?: outputs.OrgNetworktemplateSnmpConfigV3ConfigUsm;
    vacm?: outputs.OrgNetworktemplateSnmpConfigV3ConfigVacm;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigNotify {
    name?: string;
    tag?: string;
    /**
     * enum: `inform`, `trap`
     */
    type?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigNotifyFilter {
    contents?: outputs.OrgNetworktemplateSnmpConfigV3ConfigNotifyFilterContent[];
    profileName?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
    include?: boolean;
    oid?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigTargetAddress {
    address?: string;
    addressMask?: string;
    port: number;
    /**
     * <refer to notify tag, can be multiple with blank
     */
    tagList?: string;
    targetAddressName?: string;
    /**
     * refer to notify target parameters name
     */
    targetParameters?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigTargetParameter {
    /**
     * enum: `v1`, `v2c`, `v3`
     */
    messageProcessingModel?: string;
    name?: string;
    /**
     * refer to profile-name in notify_filter
     */
    notifyFilter?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * refer to security_name in usm
     */
    securityName?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigUsm {
    /**
     * enum: `local_engine`, `remote_engine`
     */
    engineType?: string;
    /**
     * required only if `engine_type`==`remote_engine`
     */
    engineid?: string;
    users?: outputs.OrgNetworktemplateSnmpConfigV3ConfigUsmUser[];
}

export interface OrgNetworktemplateSnmpConfigV3ConfigUsmUser {
    /**
     * Not required if `authentication_type`==`authentication_none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters.
     */
    authenticationPassword?: string;
    /**
     * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
     */
    authenticationType?: string;
    /**
     * Not required if `encryption_type`==`privacy-none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters
     */
    encryptionPassword?: string;
    /**
     * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
     */
    encryptionType?: string;
    name?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigVacm {
    accesses?: outputs.OrgNetworktemplateSnmpConfigV3ConfigVacmAccess[];
    securityToGroup?: outputs.OrgNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigVacmAccess {
    groupName?: string;
    prefixLists?: outputs.OrgNetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList[];
}

export interface OrgNetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
    /**
     * only required if `type`==`context_prefix`
     */
    contextPrefix?: string;
    /**
     * refer to view name
     */
    notifyView?: string;
    /**
     * refer to view name
     */
    readView?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `any`, `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * enum: `context_prefix`, `default_context_prefix`
     */
    type?: string;
    /**
     * refer to view name
     */
    writeView?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
    contents?: outputs.OrgNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent[];
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
}

export interface OrgNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
    /**
     * refer to group_name under access
     */
    group?: string;
    securityName?: string;
}

export interface OrgNetworktemplateSnmpConfigView {
    /**
     * if the root oid configured is included
     */
    include?: boolean;
    oid?: string;
    viewName?: string;
}

export interface OrgNetworktemplateSwitchMatching {
    enable?: boolean;
    rules?: outputs.OrgNetworktemplateSwitchMatchingRule[];
}

export interface OrgNetworktemplateSwitchMatchingRule {
    /**
     * additional CLI commands to append to the generated Junos config
     *
     * **Note**: no check is done
     */
    additionalConfigCmds?: string[];
    /**
     * role to match
     */
    matchRole?: string;
    /**
     * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
     */
    matchType?: string;
    matchValue?: string;
    name?: string;
    /**
     * Propery key is the interface name or interface range
     */
    portConfig?: {[key: string]: outputs.OrgNetworktemplateSwitchMatchingRulePortConfig};
    /**
     * Property key is the port mirroring instance name
     * port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
     */
    portMirroring?: {[key: string]: outputs.OrgNetworktemplateSwitchMatchingRulePortMirroring};
}

export interface OrgNetworktemplateSwitchMatchingRulePortConfig {
    /**
     * To disable LACP support for the AE interface
     */
    aeDisableLacp?: boolean;
    /**
     * Users could force to use the designated AE name
     */
    aeIdx?: number;
    /**
     * to use fast timeout
     */
    aeLacpSlow: boolean;
    aggregated: boolean;
    /**
     * if want to generate port up/down alarm
     */
    critical?: boolean;
    description?: string;
    /**
     * if `speed` and `duplex` are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Enable dynamic usage for this port. Set to `dynamic` to enable.
     */
    dynamicUsage?: string;
    esilag?: boolean;
    /**
     * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
     */
    mtu: number;
    /**
     * prevent helpdesk to override the port config
     */
    noLocalOverwrite?: boolean;
    poeDisabled: boolean;
    /**
     * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
     */
    speed: string;
    /**
     * port usage name. 
     *
     * If EVPN is used, use `evpn_uplink`or `evpn_downlink`
     */
    usage: string;
}

export interface OrgNetworktemplateSwitchMatchingRulePortMirroring {
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputNetworksIngresses?: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsEgresses?: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsIngresses?: string[];
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputNetwork?: string;
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputPortId?: string;
}

export interface OrgNetworktemplateSwitchMgmt {
    /**
     * ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
     */
    apAffinityThreshold: number;
    /**
     * Set Banners for switches. Allows markup formatting
     */
    cliBanner?: string;
    /**
     * Sets timeout for switches
     */
    cliIdleTimeout?: number;
    /**
     * the rollback timer for commit confirmed
     */
    configRevertTimer: number;
    /**
     * Enable to provide the FQDN with DHCP option 81
     */
    dhcpOptionFqdn: boolean;
    /**
     * Property key is the user name. For Local user authentication
     */
    localAccounts?: {[key: string]: outputs.OrgNetworktemplateSwitchMgmtLocalAccounts};
    mxedgeProxyHost?: string;
    mxedgeProxyPort: number;
    /**
     * restrict inbound-traffic to host
     * when enabled, all traffic that is not essential to our operation will be dropped 
     * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
     */
    protectRe?: outputs.OrgNetworktemplateSwitchMgmtProtectRe;
    rootPassword?: string;
    tacacs?: outputs.OrgNetworktemplateSwitchMgmtTacacs;
    /**
     * to use mxedge as proxy
     */
    useMxedgeProxy?: boolean;
}

export interface OrgNetworktemplateSwitchMgmtLocalAccounts {
    password?: string;
    /**
     * enum: `admin`, `helpdesk`, `none`, `read`
     */
    role: string;
}

export interface OrgNetworktemplateSwitchMgmtProtectRe {
    /**
     * optionally, services we'll allow
     */
    allowedServices: string[];
    customs?: outputs.OrgNetworktemplateSwitchMgmtProtectReCustom[];
    /**
     * when enabled, all traffic that is not essential to our operation will be dropped
     * e.g. ntp / dns / traffic to mist will be allowed by default
     *      if dhcpd is enabled, we'll make sure it works
     */
    enabled: boolean;
    /**
     * host/subnets we'll allow traffic to/from
     */
    trustedHosts: string[];
}

export interface OrgNetworktemplateSwitchMgmtProtectReCustom {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * enum: `any`, `icmp`, `tcp`, `udp`
     */
    protocol: string;
    subnets?: string[];
}

export interface OrgNetworktemplateSwitchMgmtTacacs {
    acctServers?: outputs.OrgNetworktemplateSwitchMgmtTacacsAcctServer[];
    /**
     * enum: `admin`, `helpdesk`, `none`, `read`
     */
    defaultRole: string;
    enabled?: boolean;
    /**
     * which network the TACACS server resides
     */
    network?: string;
    tacplusServers?: outputs.OrgNetworktemplateSwitchMgmtTacacsTacplusServer[];
}

export interface OrgNetworktemplateSwitchMgmtTacacsAcctServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface OrgNetworktemplateSwitchMgmtTacacsTacplusServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface OrgNetworktemplateVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface OrgNetworktemplateVrfInstances {
    /**
     * Property key is the destination CIDR (e.g. "10.0.0.0/8")
     */
    extraRoutes?: {[key: string]: outputs.OrgNetworktemplateVrfInstancesExtraRoutes};
    networks?: string[];
}

export interface OrgNetworktemplateVrfInstancesExtraRoutes {
    /**
     * Next-hop address
     */
    via: string;
}

export interface OrgRftemplateBand24 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 2.4GHz band. enum: `20`, `40`
     */
    bandwidth: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateBand5 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateBand5On24Radio {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateBand6 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
     */
    bandwidth: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
    /**
     * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
     */
    standardPower: boolean;
}

export interface OrgRftemplateModelSpecific {
    antGain24?: number;
    antGain5?: number;
    antGain6?: number;
    /**
     * Radio Band AP settings
     */
    band24?: outputs.OrgRftemplateModelSpecificBand24;
    /**
     * enum: `24`, `5`, `6`, `auto`
     */
    band24Usage?: string;
    /**
     * Radio Band AP settings
     */
    band5?: outputs.OrgRftemplateModelSpecificBand5;
    /**
     * Radio Band AP settings
     */
    band5On24Radio?: outputs.OrgRftemplateModelSpecificBand5On24Radio;
    /**
     * Radio Band AP settings
     */
    band6?: outputs.OrgRftemplateModelSpecificBand6;
}

export interface OrgRftemplateModelSpecificBand24 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 2.4GHz band. enum: `20`, `40`
     */
    bandwidth: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateModelSpecificBand5 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateModelSpecificBand5On24Radio {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 5GHz band. enum: `20`, `40`, `80`
     */
    bandwidth?: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
}

export interface OrgRftemplateModelSpecificBand6 {
    allowRrmDisable: boolean;
    antGain: number;
    /**
     * enum: `1x1`, `2x2`, `3x3`, `4x4`, `default`
     */
    antennaMode: string;
    /**
     * channel width for the 6GHz band. enum: `20`, `40`, `80`, `160`
     */
    bandwidth: number;
    /**
     * For RFTemplates. List of channels, null or empty array means auto
     */
    channels?: number[];
    /**
     * whether to disable the radio
     */
    disabled: boolean;
    /**
     * TX power of the radio. For Devices, 0 means auto. -1 / -2 / -3 / …: treated as 0 / -1 / -2 / …
     */
    power: number;
    /**
     * when power=0, max tx power to use, HW-specific values will be used if not set
     */
    powerMax: number;
    /**
     * when power=0, min tx power to use, HW-specific values will be used if not set
     */
    powerMin: number;
    /**
     * enum: `auto`, `long`, `short`
     */
    preamble: string;
    /**
     * for 6GHz Only, standard-power operation, AFC (Automatic Frequency Coordination) will be performed and we'll fallback to Low Power Indoor if AFC failed
     */
    standardPower: boolean;
}

export interface OrgServiceSpec {
    /**
     * port number, port range, or variable
     */
    portRange?: string;
    /**
     * `https`/ `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`.
     * `protocol_number` is between 1-254
     */
    protocol: string;
}

export interface OrgServicepolicyAppqoe {
    enabled: boolean;
}

export interface OrgServicepolicyEwf {
    alertOnly?: boolean;
    blockMessage?: string;
    enabled: boolean;
    /**
     * enum: `critical`, `standard`, `strict`
     */
    profile: string;
}

export interface OrgServicepolicyIdp {
    alertOnly?: boolean;
    enabled: boolean;
    /**
     * org_level IDP Profile can be used, this takes precedence over `profile`
     */
    idpprofileId?: string;
    /**
     * `strict` (default) / `standard` / or keys from from idp_profiles
     */
    profile: string;
}

export interface OrgSettingApiPolicy {
    /**
     * by default, API hides password/secrets when the user doesn't have write access
     *   * `true`: API will hide passwords/secrets for all users
     *   * `false`: API will hide passwords/secrets for read-only users
     */
    noReveal: boolean;
}

export interface OrgSettingCelona {
    apiKey: string;
    apiPrefix: string;
}

export interface OrgSettingCloudshark {
    apitoken: string;
    /**
     * if using CS Enteprise
     */
    url?: string;
}

export interface OrgSettingCradlepoint {
    cpApiId: string;
    cpApiKey: string;
    ecmApiId: string;
    ecmApiKey: string;
}

export interface OrgSettingDeviceCert {
    cert: string;
    key: string;
}

export interface OrgSettingInstaller {
    allowAllDevices?: boolean;
    allowAllSites?: boolean;
    extraSiteIds: string[];
    gracePeriod?: number;
}

export interface OrgSettingJcloud {
    /**
     * JCloud Org Token
     */
    orgApitoken: string;
    /**
     * JCloud Org Token Name
     */
    orgApitokenName: string;
    /**
     * JCloud Org ID
     */
    orgId: string;
}

export interface OrgSettingJuniper {
    accounts: outputs.OrgSettingJuniperAccount[];
}

export interface OrgSettingJuniperAccount {
    linkedBy: string;
    name: string;
}

export interface OrgSettingMgmt {
    /**
     * list of Mist Tunnels
     */
    mxtunnelIds: string[];
    /**
     * whether to use Mist Tunnel for mgmt connectivity, this takes precedence over use_wxtunnel
     */
    useMxtunnel: boolean;
    /**
     * whether to use wxtunnel for mgmt connectivity
     */
    useWxtunnel: boolean;
}

export interface OrgSettingMistNac {
    /**
     * list of PEM-encoded ca certs
     */
    cacerts: string[];
    /**
     * use this IDP when no explicit realm present in the incoming username/CN OR when no IDP is explicitly mapped to the incoming realm.
     */
    defaultIdpId?: string;
    /**
     * eap ssl security level
     * see https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR
     */
    eapSslSecurityLevel: number;
    /**
     * By default NAC POD failover considers all NAC pods available around the globe, i.e. EU, US, or APAC based, failover happens based on geo IP of the originating site.
     * For strict GDPR compliancy NAC POD failover would only happen between the PODs located within the EU environment, and no authentication would take place outside of EU. This is an org setting that is applicable to WLANs, switch templates, mxedge clusters that have mist_nac enabled
     */
    euOnly: boolean;
    idps: outputs.OrgSettingMistNacIdp[];
    /**
     * radius server cert to be presented in EAP TLS
     */
    serverCert?: outputs.OrgSettingMistNacServerCert;
    /**
     * by default NAS devices(switches/aps) and proxies(mxedge) are configured to reach mist-nac via IPv4. enum: `v4`, `v6`
     */
    useIpVersion: string;
    /**
     * By default NAS devices (switches/aps) and proxies(mxedge) are configured to use port TCP2083(radsec) to reach mist-nac. 
     * Set `use_ssl_port`==`true` to override that port with TCP43 (ssl), 
     * This is a org level setting that is applicable to wlans, switch_templates, and mxedge_clusters that have mist-nac enabled
     */
    useSslPort: boolean;
}

export interface OrgSettingMistNacIdp {
    /**
     * when the IDP of mxedge_proxy type, exclude the following realms from proxying in addition to other valid home realms in this org
     */
    excludeRealms: string[];
    id?: string;
    /**
     * which realm should trigger this IDP. User Realm is extracted from:
     *   * Username-AVP (`mist.com` from john@mist.com)
     *   * Cert CN
     */
    userRealms: string[];
}

export interface OrgSettingMistNacServerCert {
    cert?: string;
    key?: string;
    /**
     * private key password (optional)
     */
    password?: string;
}

export interface OrgSettingMxedgeMgmt {
    fipsEnabled: boolean;
    mistPassword?: string;
    /**
     * enum: `dhcp`, `disabled`, `static`
     */
    oobIpType: string;
    /**
     * enum: `autoconf`, `dhcp`, `disabled`, `static`
     */
    oobIpType6: string;
    rootPassword?: string;
}

export interface OrgSettingPasswordPolicy {
    /**
     * whether the policy is enabled
     */
    enabled: boolean;
    /**
     * days, required if password policy is enabled
     */
    freshness?: number;
    /**
     * required password length
     */
    minLength: number;
    /**
     * whether to require special character
     */
    requiresSpecialChar: boolean;
    /**
     * whether to require two-factor auth
     */
    requiresTwoFactorAuth: boolean;
}

export interface OrgSettingPcap {
    bucket?: string;
    /**
     * max_len of non-management packets to capture
     */
    maxPktLen: number;
}

export interface OrgSettingSecurity {
    /**
     * whether to disable local SSH (by default, local SSH is enabled with allow_mist in Org is enabled
     */
    disableLocalSsh?: boolean;
    /**
     * password required to zeroize devices (FIPS) on site level
     */
    fipsZeroizePassword?: string;
    /**
     * whether to allow certain SSH keys to SSH into the AP (see Site:Setting)
     */
    limitSshAccess: boolean;
}

export interface OrgSettingSwitchMgmt {
    /**
     * If the field is set in both site/setting and org/setting, the value from site/setting will be used.
     */
    apAffinityThreshold: number;
}

export interface OrgSettingSyntheticTest {
    disabled: boolean;
    vlans?: outputs.OrgSettingSyntheticTestVlan[];
    wanSpeedtest?: outputs.OrgSettingSyntheticTestWanSpeedtest;
}

export interface OrgSettingSyntheticTestVlan {
    customTestUrls: string[];
    /**
     * for some vlans where we don't want this to run
     */
    disabled: boolean;
    vlanIds: string[];
}

export interface OrgSettingSyntheticTestWanSpeedtest {
    enabled?: boolean;
    /**
     * any / HH:MM (24-hour format)
     */
    timeOdFay: string;
}

export interface OrgSettingVpnOptions {
    asBase?: number;
    /**
     * equiring /12 or bigger to support 16 private IPs for 65535 gateways
     */
    stSubnet: string;
}

export interface OrgVpnPaths {
    /**
     * enum: `broadband`, `lte`
     */
    bfdProfile: string;
    /**
     * if different from the wan port
     */
    ip?: string;
    pod: number;
}

export interface OrgWlanAcctServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Acct port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface OrgWlanAirwatch {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * console URL
     */
    consoleUrl: string;
    enabled: boolean;
    /**
     * password
     */
    password: string;
    /**
     * username
     */
    username: string;
}

export interface OrgWlanAppLimit {
    /**
     * Map from app key to bandwidth in kbps. 
     * Property key is the app key, defined in Get Application List
     */
    apps?: {[key: string]: number};
    enabled: boolean;
    /**
     * Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
     * Property key is the wxtag id
     */
    wxtagIds: {[key: string]: number};
}

export interface OrgWlanAppQos {
    apps?: {[key: string]: outputs.OrgWlanAppQosApps};
    enabled: boolean;
    others?: outputs.OrgWlanAppQosOther[];
}

export interface OrgWlanAppQosApps {
    dscp?: number;
    /**
     * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
     */
    dstSubnet?: string;
    /**
     * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
     */
    srcSubnet?: string;
}

export interface OrgWlanAppQosOther {
    dscp?: number;
    dstSubnet?: string;
    portRanges?: string;
    protocol?: string;
    srcSubnet?: string;
}

export interface OrgWlanAuth {
    /**
     * SAE anti-clogging token threshold
     */
    anticlogThreshold: number;
    /**
     * whether to trigger EAP reauth when the session ends
     */
    eapReauth: boolean;
    /**
     * whether to enable MAC Auth, uses the same auth_servers
     */
    enableMacAuth: boolean;
    /**
     * when `type`==`wep`
     */
    keyIdx: number;
    /**
     * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
     */
    keys: string[];
    /**
     * when `type`==`psk`, whether to only use multi_psk
     */
    multiPskOnly: boolean;
    /**
     * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
     */
    owe: string;
    /**
     * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
     */
    pairwises: string[];
    /**
     * when `multi_psk_only`==`true`, whether private wlan is enabled
     */
    privateWlan: boolean;
    /**
     * when `type`==`psk`, 8-64 characters, or 64 hex characters
     */
    psk: string;
    /**
     * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
     */
    type: string;
    /**
     * enable WEP as secondary auth
     */
    wepAsSecondaryAuth: boolean;
}

export interface OrgWlanAuthServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Auth port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface OrgWlanBonjour {
    /**
     * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
     */
    additionalVlanIds: string[];
    /**
     * whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
     */
    enabled: boolean;
    /**
     * what services are allowed. 
     * Property key is the service name
     */
    services: {[key: string]: outputs.OrgWlanBonjourServices};
}

export interface OrgWlanBonjourServices {
    /**
     * whether to prevent wireless clients to discover bonjour devices on the same WLAN
     */
    disableLocal: boolean;
    /**
     * optional, if the service is further restricted for certain RADIUS groups
     */
    radiusGroups?: string[];
    /**
     * how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
     */
    scope: string;
}

export interface OrgWlanCiscoCwa {
    /**
     * list of hostnames without http(s):// (matched by substring)
     */
    allowedHostnames?: string[];
    /**
     * list of CIDRs
     */
    allowedSubnets?: string[];
    /**
     * list of blocked CIDRs
     */
    blockedSubnets?: string[];
    enabled: boolean;
}

export interface OrgWlanCoaServer {
    /**
     * whether to disable Event-Timestamp Check
     */
    disableEventTimestampCheck: boolean;
    enabled: boolean;
    ip: string;
    port: number;
    secret: string;
}

export interface OrgWlanDnsServerRewrite {
    enabled: boolean;
    /**
     * map between radius_group and the desired DNS server (IPv4 only)
     * Property key is the RADIUS group, property value is the desired DNS Server
     */
    radiusGroups?: {[key: string]: string};
}

export interface OrgWlanDynamicPsk {
    /**
     * default PSK to use if cloud WLC is not available, 8-63 characters
     */
    defaultPsk?: string;
    defaultVlanId?: string;
    enabled: boolean;
    /**
     * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
     * `false` means auto
     */
    forceLookup: boolean;
    /**
     * enum: `cloud_psks`, `radius`
     */
    source: string;
    vlanIds?: string[];
}

export interface OrgWlanDynamicVlan {
    /**
     * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
     */
    defaultVlanIds: string[];
    /**
     * whether to enable dynamic vlan
     */
    enabled: boolean;
    /**
     * vlan_ids to be locally bridged
     */
    localVlanIds: string[];
    /**
     * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
     */
    type: string;
    /**
     * map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
     *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
     *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
     */
    vlans?: {[key: string]: string};
}

export interface OrgWlanHotspot20 {
    domainNames?: string[];
    /**
     * whether to enable hotspot 2.0 config
     */
    enabled?: boolean;
    naiRealms?: string[];
    /**
     * list of operators to support
     */
    operators?: string[];
    rcois?: string[];
    /**
     * venue name, default is site name
     */
    venueName?: string;
}

export interface OrgWlanInjectDhcpOption82 {
    circuitId?: string;
    /**
     * whether to inject option 82 when forwarding DHCP packets
     */
    enabled: boolean;
}

export interface OrgWlanMistNac {
    /**
     * when enabled:
     *   * `auth_servers` is ignored
     *   * `acct_servers` is ignored
     *   * `auth_servers_*` are ignored
     *   * `coa_servers` is ignored
     *   * `radsec` is ignored
     *   * `coa_enabled` is assumed'
     */
    enabled: boolean;
}

export interface OrgWlanPortal {
    /**
     * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
     */
    amazonClientId: string;
    /**
     * amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    amazonClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    amazonEmailDomains: string[];
    /**
     * whether amazon is enabled as a login method
     */
    amazonEnabled: boolean;
    /**
     * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
     */
    amazonExpire: number;
    /**
     * authentication scheme. enum: `external`, `none`, `sso`
     */
    auth: string;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory app client id
     */
    azureClientId: string;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory app client secret
     */
    azureClientSecret: string;
    /**
     * whether Azure Active Directory is enabled as a login method
     */
    azureEnabled: boolean;
    /**
     * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
     */
    azureExpire: number;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory tenant id.
     */
    azureTenantId: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetPassword: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetSid: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetUserId: string;
    /**
     * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
     */
    bypassWhenCloudDown: boolean;
    /**
     * when `sms_provider`==`clickatell`
     */
    clickatellApiKey: string;
    /**
     * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
     */
    crossSite: boolean;
    /**
     * whether email (access code verification) is enabled as a login method
     */
    emailEnabled: boolean;
    /**
     * whether guest portal is enabled
     */
    enabled: boolean;
    /**
     * how long to remain authorized, in minutes
     */
    expire: number;
    /**
     * external portal URL (e.g. https://host/url) where we can append our query parameters to
     */
    externalPortalUrl: string;
    /**
     * Required if `facebook_enabled`==`true`.
     * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
     */
    facebookClientId: string;
    /**
     * Required if `facebook_enabled`==`true`.
     * Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    facebookClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    facebookEmailDomains: string[];
    /**
     * whether facebook is enabled as a login method
     */
    facebookEnabled: boolean;
    /**
     * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
     */
    facebookExpire: number;
    /**
     * whether to forward the user to another URL after authorized
     */
    forward: boolean;
    /**
     * the URL to forward the user to
     */
    forwardUrl: string;
    /**
     * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
     */
    googleClientId: string;
    /**
     * Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    googleClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    googleEmailDomains: string[];
    /**
     * whether google is enabled as login method
     */
    googleEnabled: boolean;
    /**
     * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
     */
    googleExpire: number;
    /**
     * when `sms_provider`==`gupshup`
     */
    gupshupPassword: string;
    /**
     * when `sms_provider`==`gupshup`
     */
    gupshupUserid: string;
    /**
     * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
     */
    microsoftClientId: string;
    /**
     * microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    microsoftClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    microsoftEmailDomains: string[];
    /**
     * whether microsoft 365 is enabled as a login method
     */
    microsoftEnabled: boolean;
    /**
     * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
     */
    microsoftExpire: number;
    /**
     * whether password is enabled
     */
    passphraseEnabled: boolean;
    /**
     * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
     */
    passphraseExpire: number;
    /**
     * passphrase
     */
    password: string;
    /**
     * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
     */
    predefinedSponsorsEnabled: boolean;
    /**
     * whether to hide sponsor’s email from list of sponsors
     */
    predefinedSponsorsHideEmail: boolean;
    privacy: boolean;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelPassword: string;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelServiceId: string;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelUsername: string;
    /**
     * whether sms is enabled as a login method
     */
    smsEnabled: boolean;
    /**
     * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
     */
    smsExpire: number;
    smsMessageFormat: string;
    /**
     * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
     */
    smsProvider: string;
    /**
     * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
     */
    sponsorAutoApprove: boolean;
    /**
     * list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
     */
    sponsorEmailDomains: string[];
    /**
     * whether sponsor is enabled
     */
    sponsorEnabled: boolean;
    /**
     * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
     */
    sponsorExpire: number;
    /**
     * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
     */
    sponsorLinkValidityDuration: string;
    /**
     * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
     */
    sponsorNotifyAll: boolean;
    /**
     * if enabled, guest will get email about sponsor's action (approve/deny)
     */
    sponsorStatusNotify: boolean;
    /**
     * object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.
     * Property key is the sponsor email, Property value is the sponsor name
     */
    sponsors: {[key: string]: string};
    /**
     * default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
     */
    ssoDefaultRole: string;
    ssoForcedRole: string;
    /**
     * IDP Cert (used to verify the signed response)
     */
    ssoIdpCert: string;
    /**
     * signing algorithm for SAML Assertion
     */
    ssoIdpSignAlgo: string;
    /**
     * IDP Single-Sign-On URL
     */
    ssoIdpSsoUrl: string;
    /**
     * IDP issuer URL
     */
    ssoIssuer: string;
    /**
     * enum: `email`, `unspecified`
     */
    ssoNameidFormat: string;
    /**
     * when `sms_provider`==`telstra`, Client ID provided by Telstra
     */
    telstraClientId: string;
    /**
     * when `sms_provider`==`telstra`, Client secret provided by Telstra
     */
    telstraClientSecret: string;
    /**
     * when `sms_provider`==`twilio`, Auth token account with twilio account
     */
    twilioAuthToken: string;
    /**
     * when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
     */
    twilioPhoneNumber: string;
    /**
     * when `sms_provider`==`twilio`, Account SID provided by Twilio
     */
    twilioSid: string;
}

export interface OrgWlanQos {
    /**
     * enum: `background`, `best_effort`, `video`, `voice`
     */
    class: string;
    /**
     * whether to overwrite QoS
     */
    overwrite: boolean;
}

export interface OrgWlanRadsec {
    coaEnabled: boolean;
    enabled?: boolean;
    idleTimeout?: number;
    /**
     * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
     * Org mxedge(s) identified by mxcluster_ids
     */
    mxclusterIds: string[];
    /**
     * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
     * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
     */
    proxyHosts: string[];
    /**
     * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
     */
    serverName?: string;
    /**
     * List of Radsec Servers. Only if not Mist Edge.
     */
    servers?: outputs.OrgWlanRadsecServer[];
    /**
     * use mxedge(s) as radsecproxy
     */
    useMxedge?: boolean;
    /**
     * To use Site mxedges when this WLAN does not use mxtunnel
     */
    useSiteMxedge: boolean;
}

export interface OrgWlanRadsecServer {
    host?: string;
    port?: number;
}

export interface OrgWlanSchedule {
    enabled: boolean;
    /**
     * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
     *
     * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
     */
    hours?: outputs.OrgWlanScheduleHours;
}

export interface OrgWlanScheduleHours {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    tue: string;
    wed: string;
}

export interface OrgWlantemplateApplies {
    orgId?: string;
    /**
     * list of site ids
     */
    siteIds: string[];
    /**
     * list of sitegroup ids
     */
    sitegroupIds: string[];
}

export interface OrgWlantemplateExceptions {
    /**
     * list of site ids
     */
    siteIds: string[];
    /**
     * list of sitegroup ids
     */
    sitegroupIds: string[];
}

export interface OrgWxtagSpec {
    /**
     * matched destination port, "0" means any
     */
    portRange: string;
    /**
     * tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
     */
    protocol: string;
    /**
     * matched destination subnets and/or IP Addresses
     */
    subnets: string[];
}

export interface SiteLatlng {
    lat: number;
    lng: number;
}

export interface SiteNetworktemplateAclPolicy {
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    actions?: outputs.SiteNetworktemplateAclPolicyAction[];
    name?: string;
    /**
     * - for GBP-based policy, all src_tags and dst_tags have to be gbp-based
     * - for ACL-based policy, `network` is required in either the source or destination so that we know where to attach the policy to
     */
    srcTags?: string[];
}

export interface SiteNetworktemplateAclPolicyAction {
    /**
     * enum: `allow`, `deny`
     */
    action: string;
    dstTag?: string;
}

export interface SiteNetworktemplateAclTags {
    /**
     * required if
     * - `type`==`dynamic_gbp` (gbp_tag received from RADIUS)
     * - `type`==`static_gbp` (applying gbp tag against matching conditions)
     */
    gbpTag?: number;
    /**
     * required if 
     * - `type`==`mac`
     * - `type`==`static_gbp` if from matching mac
     */
    macs?: string[];
    /**
     * if:
     *   * `type`==`mac` (optional. default is `any`)
     *   * `type`==`subnet` (optional. default is `any`)
     *   * `type`==`network`
     *   * `type`==`resource` (optional. default is `any`)
     *   * `type`==`static_gbp` if from matching network (vlan)'
     */
    network?: string;
    /**
     * required if:
     *   * `type`==`radius_group`
     *   * `type`==`static_gbp`
     * if from matching radius_group
     */
    radiusGroup?: string;
    /**
     * if `type`==`resource`
     * empty means unrestricted, i.e. any
     */
    specs?: outputs.SiteNetworktemplateAclTagsSpec[];
    /**
     * if 
     * - `type`==`subnet` 
     * - `type`==`resource` (optional. default is `any`)
     * - `type`==`static_gbp` if from matching subnet
     */
    subnets?: string[];
    /**
     * enum: `any`, `dynamic_gbp`, `mac`, `network`, `radius_group`, `resource`, `static_gbp`, `subnet`
     */
    type: string;
}

export interface SiteNetworktemplateAclTagsSpec {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * `tcp` / `udp` / `icmp` / `gre` / `any` / `:protocol_number`. `protocol_number` is between 1-254
     */
    protocol: string;
}

export interface SiteNetworktemplateDhcpSnooping {
    allNetworks?: boolean;
    /**
     * Enable for dynamic ARP inspection check
     */
    enableArpSpoofCheck?: boolean;
    /**
     * Enable for check for forging source IP address
     */
    enableIpSourceGuard?: boolean;
    enabled?: boolean;
    /**
     * if `all_networks`==`false`, list of network with DHCP snooping enabled
     */
    networks?: string[];
}

export interface SiteNetworktemplateExtraRoutes {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.SiteNetworktemplateExtraRoutesNextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface SiteNetworktemplateExtraRoutes6 {
    /**
     * this takes precedence
     */
    discard: boolean;
    metric?: number;
    nextQualified?: {[key: string]: outputs.SiteNetworktemplateExtraRoutes6NextQualified};
    noResolve: boolean;
    preference?: number;
    /**
     * next-hop IP Address
     */
    via: string;
}

export interface SiteNetworktemplateExtraRoutes6NextQualified {
    metric?: number;
    preference?: number;
}

export interface SiteNetworktemplateExtraRoutesNextQualified {
    metric?: number;
    preference?: number;
}

export interface SiteNetworktemplateMistNac {
    enabled?: boolean;
    network?: string;
}

export interface SiteNetworktemplateNetworks {
    /**
     * whether to stop clients to talk to each other, default is false (when enabled, a unique isolation_vlan_id is required)
     * NOTE: this features requires uplink device to also a be Juniper device and `inter_switch_link` to be set
     */
    isolation: boolean;
    isolationVlanId?: string;
    /**
     * optional for pure switching, required when L3 / routing features are used
     */
    subnet?: string;
    vlanId: string;
}

export interface SiteNetworktemplatePortMirroring {
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputNetworksIngresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsEgresses: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsIngresses: string[];
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputNetwork?: string;
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputPortId?: string;
}

export interface SiteNetworktemplatePortUsages {
    /**
     * Only if `mode`==`trunk` whether to trunk all network/vlans
     */
    allNetworks: boolean;
    /**
     * Only if `mode`!=`dynamic` if DHCP snooping is enabled, whether DHCP server is allowed on the interfaces with. All the interfaces from port configs using this port usage are effected. Please notice that allow_dhcpd is a tri_state.
     *
     * When it is not defined, it means using the system’s default setting which depends on whether the port is a access or trunk port.
     */
    allowDhcpd?: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    allowMultipleSupplicants: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` bypass auth for known clients if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDown: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` bypass auth for all (including unknown clients) if set to true when RADIUS server is down
     */
    bypassAuthWhenServerDownForUnkonwnClient: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    description?: string;
    /**
     * Only if `mode`!=`dynamic` if speed and duplex are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * Only if `mode`!=`dynamic` whether the port is disabled
     */
    disabled: boolean;
    /**
     * Only if `mode`!=`dynamic` link connection mode. enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x`, if dynamic vlan is used, specify the possible networks/vlans RADIUS can return
     */
    dynamicVlanNetworks: string[];
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` whether to enable MAC Auth
     */
    enableMacAuth: boolean;
    /**
     * Only if `mode`!=`dynamic`
     */
    enableQos: boolean;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` which network to put the device into if the device cannot do dot1x. default is null (i.e. not allowed)
     */
    guestNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` inter_switch_link is used together with "isolation" under networks
     * NOTE: inter_switch_link works only between Juniper device. This has to be applied to both ports connected together
     */
    interSwitchLink: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth`==`true`
     */
    macAuthOnly?: boolean;
    /**
     * Only if `mode`!=`dynamic` and `enable_mac_auth` ==`true`. This type is ignored if mist_nac is enabled. enum: `eap-md5`, `eap-peap`, `pap`
     */
    macAuthProtocol: string;
    /**
     * Only if `mode`!=`dynamic` max number of mac addresses, default is 0 for unlimited, otherwise range is 1 or higher, with upper bound constrained by platform
     */
    macLimit: number;
    /**
     * `mode`==`dynamic` must only be used with the port usage with the name `dynamic`. enum: `access`, `dynamic`, `inet`, `trunk`
     */
    mode?: string;
    /**
     * Only if `mode`!=`dynamic` media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation. The default value is 1514.
     */
    mtu?: number;
    /**
     * Only if `mode`==`trunk`, the list of network/vlans
     */
    networks: string[];
    /**
     * Only if `mode`==`access` and `port_auth`!=`dot1x` whether the port should retain dynamically learned MAC addresses
     */
    persistMac: boolean;
    /**
     * Only if `mode`!=`dynamic` whether PoE capabilities are disabled for a port
     */
    poeDisabled: boolean;
    /**
     * Only if `mode`!=`dynamic` if dot1x is desired, set to dot1x. enum: `dot1x`
     */
    portAuth?: string;
    /**
     * Only if `mode`!=`dynamic` native network/vlan for untagged traffic
     */
    portNetwork?: string;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`=`dot1x` reauthentication interval range
     */
    reauthInterval: number;
    /**
     * Only if `mode`!=`dynamic` and `port_auth`==`dot1x` when radius server reject / fails
     */
    rejectedNetwork?: string;
    /**
     * Only if `mode`==`dynamic` Control when the DPC port should be changed to the default port usage. enum: `link_down`, `none` (let the DPC port keep at the current port usage)
     */
    resetDefaultWhen: string;
    /**
     * Only if `mode`==`dynamic`
     */
    rules?: outputs.SiteNetworktemplatePortUsagesRule[];
    /**
     * Only if `mode`!=`dynamic` speed, default is auto to automatically negotiate speed
     */
    speed?: string;
    /**
     * Switch storm control
     * Only if `mode`!=`dynamic`
     */
    stormControl?: outputs.SiteNetworktemplatePortUsagesStormControl;
    /**
     * Only if `mode`!=`dynamic` when enabled, the port is not expected to receive BPDU frames
     */
    stpEdge: boolean;
    stpNoRootPort: boolean;
    stpP2p: boolean;
    /**
     * Only if `mode`!=`dynamic` network/vlan for voip traffic, must also set port_network. to authenticate device, set port_auth
     */
    voipNetwork?: string;
}

export interface SiteNetworktemplatePortUsagesRule {
    equals?: string;
    /**
     * use `equals_any` to match any item in a list
     */
    equalsAnies?: string[];
    /**
     * "[0:3]":"abcdef" > "abc"
     * "split(.)[1]": "a.b.c" > "b"
     * "split(-)[1][0:3]: "a1234-b5678-c90" > "b56"
     */
    expression?: string;
    /**
     * enum: `link_peermac`, `lldp_chassis_id`, `lldp_hardware_revision`, `lldp_manufacturer_name`, `lldp_oui`, `lldp_serial_number`, `lldp_system_name`, `radius_dynamicfilter`, `radius_usermac`, `radius_username`
     */
    src: string;
    /**
     * `port_usage` name
     */
    usage?: string;
}

export interface SiteNetworktemplatePortUsagesStormControl {
    /**
     * whether to disable storm control on broadcast traffic
     */
    noBroadcast: boolean;
    /**
     * whether to disable storm control on multicast traffic
     */
    noMulticast: boolean;
    /**
     * whether to disable storm control on registered multicast traffic
     */
    noRegisteredMulticast: boolean;
    /**
     * whether to disable storm control on unknown unicast traffic
     */
    noUnknownUnicast: boolean;
    /**
     * bandwidth-percentage, configures the storm control level as a percentage of the available bandwidth
     */
    percentage: number;
}

export interface SiteNetworktemplateRadiusConfig {
    /**
     * how frequently should interim accounting be reported, 60-65535. default is 0 (use one specified in Access-Accept request from RADIUS Server). Very frequent messages can affect the performance of the radius server, 600 and up is recommended when enabled
     */
    acctInterimInterval: number;
    acctServers?: outputs.SiteNetworktemplateRadiusConfigAcctServer[];
    authServers?: outputs.SiteNetworktemplateRadiusConfigAuthServer[];
    /**
     * radius auth session retries
     */
    authServersRetries: number;
    /**
     * radius auth session timeout
     */
    authServersTimeout: number;
    coaEnabled: boolean;
    coaPort: number;
    /**
     * use `network`or `source_ip`
     * which network the RADIUS server resides, if there's static IP for this network, we'd use it as source-ip
     */
    network?: string;
    /**
     * use `network`or `source_ip`
     */
    sourceIp?: string;
}

export interface SiteNetworktemplateRadiusConfigAcctServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Acct port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface SiteNetworktemplateRadiusConfigAuthServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Auth port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface SiteNetworktemplateRemoteSyslog {
    archive?: outputs.SiteNetworktemplateRemoteSyslogArchive;
    console?: outputs.SiteNetworktemplateRemoteSyslogConsole;
    enabled: boolean;
    files?: outputs.SiteNetworktemplateRemoteSyslogFile[];
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    network?: string;
    sendToAllServers: boolean;
    servers?: outputs.SiteNetworktemplateRemoteSyslogServer[];
    /**
     * enum: `millisecond`, `year`, `year millisecond`
     */
    timeFormat?: string;
    users?: outputs.SiteNetworktemplateRemoteSyslogUser[];
}

export interface SiteNetworktemplateRemoteSyslogArchive {
    files?: number;
    size?: string;
}

export interface SiteNetworktemplateRemoteSyslogConsole {
    contents?: outputs.SiteNetworktemplateRemoteSyslogConsoleContent[];
}

export interface SiteNetworktemplateRemoteSyslogConsoleContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface SiteNetworktemplateRemoteSyslogFile {
    archive?: outputs.SiteNetworktemplateRemoteSyslogFileArchive;
    contents?: outputs.SiteNetworktemplateRemoteSyslogFileContent[];
    explicitPriority?: boolean;
    file?: string;
    match?: string;
    structuredData?: boolean;
}

export interface SiteNetworktemplateRemoteSyslogFileArchive {
    files?: number;
    size?: string;
}

export interface SiteNetworktemplateRemoteSyslogFileContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface SiteNetworktemplateRemoteSyslogServer {
    contents?: outputs.SiteNetworktemplateRemoteSyslogServerContent[];
    explicitPriority?: boolean;
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    host?: string;
    match?: string;
    port: number;
    /**
     * enum: `tcp`, `udp`
     */
    protocol: string;
    routingInstance?: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
    /**
     * if source_address is configured, will use the vlan firstly otherwise use source_ip
     */
    sourceAddress?: string;
    structuredData?: boolean;
    tag?: string;
}

export interface SiteNetworktemplateRemoteSyslogServerContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface SiteNetworktemplateRemoteSyslogUser {
    contents?: outputs.SiteNetworktemplateRemoteSyslogUserContent[];
    match?: string;
    user?: string;
}

export interface SiteNetworktemplateRemoteSyslogUserContent {
    /**
     * enum: `any`, `authorization`, `change-log`, `config`, `conflict-log`, `daemon`, `dfc`, `external`, `firewall`, `ftp`, `interactive-commands`, `kernel`, `ntp`, `pfe`, `security`, `user`
     */
    facility: string;
    /**
     * enum: `alert`, `any`, `critical`, `emergency`, `error`, `info`, `notice`, `warning`
     */
    severity: string;
}

export interface SiteNetworktemplateSnmpConfig {
    clientLists?: outputs.SiteNetworktemplateSnmpConfigClientList[];
    contact?: string;
    description?: string;
    enabled: boolean;
    /**
     * enum: `engine-id-suffix`, `local`, `use-default-ip-address`, `use_mac-address`
     */
    engineId?: string;
    location?: string;
    name?: string;
    network: string;
    trapGroups?: outputs.SiteNetworktemplateSnmpConfigTrapGroup[];
    v2cConfigs?: outputs.SiteNetworktemplateSnmpConfigV2cConfig[];
    v3Config?: outputs.SiteNetworktemplateSnmpConfigV3Config;
    views?: outputs.SiteNetworktemplateSnmpConfigView[];
}

export interface SiteNetworktemplateSnmpConfigClientList {
    clientListName?: string;
    clients?: string[];
}

export interface SiteNetworktemplateSnmpConfigTrapGroup {
    categories?: string[];
    /**
     * Categories list can refer to https://www.juniper.net/documentation/software/topics/task/configuration/snmp_trap-groups-configuring-junos-nm.html
     */
    groupName?: string;
    targets?: string[];
    /**
     * enum: `all`, `v1`, `v2`
     */
    version: string;
}

export interface SiteNetworktemplateSnmpConfigV2cConfig {
    authorization?: string;
    /**
     * client_list_name here should refer to client_list above
     */
    clientListName?: string;
    communityName?: string;
    /**
     * view name here should be defined in views above
     */
    view?: string;
}

export interface SiteNetworktemplateSnmpConfigV3Config {
    notifies?: outputs.SiteNetworktemplateSnmpConfigV3ConfigNotify[];
    notifyFilters?: outputs.SiteNetworktemplateSnmpConfigV3ConfigNotifyFilter[];
    targetAddresses?: outputs.SiteNetworktemplateSnmpConfigV3ConfigTargetAddress[];
    targetParameters?: outputs.SiteNetworktemplateSnmpConfigV3ConfigTargetParameter[];
    usm?: outputs.SiteNetworktemplateSnmpConfigV3ConfigUsm;
    vacm?: outputs.SiteNetworktemplateSnmpConfigV3ConfigVacm;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigNotify {
    name?: string;
    tag?: string;
    /**
     * enum: `inform`, `trap`
     */
    type?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigNotifyFilter {
    contents?: outputs.SiteNetworktemplateSnmpConfigV3ConfigNotifyFilterContent[];
    profileName?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigNotifyFilterContent {
    include?: boolean;
    oid?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigTargetAddress {
    address?: string;
    addressMask?: string;
    port: number;
    /**
     * <refer to notify tag, can be multiple with blank
     */
    tagList?: string;
    targetAddressName?: string;
    /**
     * refer to notify target parameters name
     */
    targetParameters?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigTargetParameter {
    /**
     * enum: `v1`, `v2c`, `v3`
     */
    messageProcessingModel?: string;
    name?: string;
    /**
     * refer to profile-name in notify_filter
     */
    notifyFilter?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * refer to security_name in usm
     */
    securityName?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigUsm {
    /**
     * enum: `local_engine`, `remote_engine`
     */
    engineType?: string;
    /**
     * required only if `engine_type`==`remote_engine`
     */
    engineid?: string;
    users?: outputs.SiteNetworktemplateSnmpConfigV3ConfigUsmUser[];
}

export interface SiteNetworktemplateSnmpConfigV3ConfigUsmUser {
    /**
     * Not required if `authentication_type`==`authentication_none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters.
     */
    authenticationPassword?: string;
    /**
     * sha224, sha256, sha384, sha512 are supported in 21.1 and newer release. enum: `authentication_md5`, `authentication_none`, `authentication_sha`, `authentication_sha224`, `authentication_sha256`, `authentication_sha384`, `authentication_sha512`
     */
    authenticationType?: string;
    /**
     * Not required if `encryption_type`==`privacy-none`
     * include alphabetic, numeric, and special characters, but it cannot include control characters
     */
    encryptionPassword?: string;
    /**
     * enum: `privacy-3des`, `privacy-aes128`, `privacy-des`, `privacy-none`
     */
    encryptionType?: string;
    name?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigVacm {
    accesses?: outputs.SiteNetworktemplateSnmpConfigV3ConfigVacmAccess[];
    securityToGroup?: outputs.SiteNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigVacmAccess {
    groupName?: string;
    prefixLists?: outputs.SiteNetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList[];
}

export interface SiteNetworktemplateSnmpConfigV3ConfigVacmAccessPrefixList {
    /**
     * only required if `type`==`context_prefix`
     */
    contextPrefix?: string;
    /**
     * refer to view name
     */
    notifyView?: string;
    /**
     * refer to view name
     */
    readView?: string;
    /**
     * enum: `authentication`, `none`, `privacy`
     */
    securityLevel?: string;
    /**
     * enum: `any`, `usm`, `v1`, `v2c`
     */
    securityModel?: string;
    /**
     * enum: `context_prefix`, `default_context_prefix`
     */
    type?: string;
    /**
     * refer to view name
     */
    writeView?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroup {
    contents?: outputs.SiteNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent[];
    /**
     * enum: `usm`, `v1`, `v2c`
     */
    securityModel?: string;
}

export interface SiteNetworktemplateSnmpConfigV3ConfigVacmSecurityToGroupContent {
    /**
     * refer to group_name under access
     */
    group?: string;
    securityName?: string;
}

export interface SiteNetworktemplateSnmpConfigView {
    /**
     * if the root oid configured is included
     */
    include?: boolean;
    oid?: string;
    viewName?: string;
}

export interface SiteNetworktemplateSwitchMatching {
    enable?: boolean;
    rules?: outputs.SiteNetworktemplateSwitchMatchingRule[];
}

export interface SiteNetworktemplateSwitchMatchingRule {
    /**
     * additional CLI commands to append to the generated Junos config
     *
     * **Note**: no check is done
     */
    additionalConfigCmds?: string[];
    /**
     * role to match
     */
    matchRole?: string;
    /**
     * 'property key define the type of matching, value is the string to match. e.g: `match_name[0:3]`, `match_name[2:6]`, `match_model`,  `match_model[0-6]`
     */
    matchType?: string;
    matchValue?: string;
    name?: string;
    /**
     * Propery key is the interface name or interface range
     */
    portConfig?: {[key: string]: outputs.SiteNetworktemplateSwitchMatchingRulePortConfig};
    /**
     * Property key is the port mirroring instance name
     * port_mirroring can be added under device/site settings. It takes interface and ports as input for ingress, interface as input for egress and can take interface and port as output.
     */
    portMirroring?: {[key: string]: outputs.SiteNetworktemplateSwitchMatchingRulePortMirroring};
}

export interface SiteNetworktemplateSwitchMatchingRulePortConfig {
    /**
     * To disable LACP support for the AE interface
     */
    aeDisableLacp?: boolean;
    /**
     * Users could force to use the designated AE name
     */
    aeIdx?: number;
    /**
     * to use fast timeout
     */
    aeLacpSlow: boolean;
    aggregated: boolean;
    /**
     * if want to generate port up/down alarm
     */
    critical?: boolean;
    description?: string;
    /**
     * if `speed` and `duplex` are specified, whether to disable autonegotiation
     */
    disableAutoneg: boolean;
    /**
     * enum: `auto`, `full`, `half`
     */
    duplex: string;
    /**
     * Enable dynamic usage for this port. Set to `dynamic` to enable.
     */
    dynamicUsage?: string;
    esilag?: boolean;
    /**
     * media maximum transmission unit (MTU) is the largest data unit that can be forwarded without fragmentation
     */
    mtu: number;
    /**
     * prevent helpdesk to override the port config
     */
    noLocalOverwrite?: boolean;
    poeDisabled: boolean;
    /**
     * enum: `100m`, `10m`, `1g`, `2.5g`, `5g`, `auto`
     */
    speed: string;
    /**
     * port usage name. 
     *
     * If EVPN is used, use `evpn_uplink`or `evpn_downlink`
     */
    usage: string;
}

export interface SiteNetworktemplateSwitchMatchingRulePortMirroring {
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputNetworksIngresses?: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsEgresses?: string[];
    /**
     * at least one of the `input_port_ids_ingress`, `input_port_ids_egress` or `input_networks_ingress ` should be specified
     */
    inputPortIdsIngresses?: string[];
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputNetwork?: string;
    /**
     * exaclty one of the `output_port_id` or `output_network` should be provided
     */
    outputPortId?: string;
}

export interface SiteNetworktemplateSwitchMgmt {
    /**
     * ap_affinity_threshold ap_affinity_threshold can be added as a field under site/setting. By default this value is set to 12. If the field is set in both site/setting and org/setting, the value from site/setting will be used.
     */
    apAffinityThreshold: number;
    /**
     * Set Banners for switches. Allows markup formatting
     */
    cliBanner?: string;
    /**
     * Sets timeout for switches
     */
    cliIdleTimeout?: number;
    /**
     * the rollback timer for commit confirmed
     */
    configRevertTimer: number;
    /**
     * Enable to provide the FQDN with DHCP option 81
     */
    dhcpOptionFqdn: boolean;
    /**
     * Property key is the user name. For Local user authentication
     */
    localAccounts?: {[key: string]: outputs.SiteNetworktemplateSwitchMgmtLocalAccounts};
    mxedgeProxyHost?: string;
    mxedgeProxyPort: number;
    /**
     * restrict inbound-traffic to host
     * when enabled, all traffic that is not essential to our operation will be dropped 
     * e.g. ntp / dns / traffic to mist will be allowed by default, if dhcpd is enabled, we'll make sure it works
     */
    protectRe?: outputs.SiteNetworktemplateSwitchMgmtProtectRe;
    rootPassword?: string;
    tacacs?: outputs.SiteNetworktemplateSwitchMgmtTacacs;
    /**
     * to use mxedge as proxy
     */
    useMxedgeProxy?: boolean;
}

export interface SiteNetworktemplateSwitchMgmtLocalAccounts {
    password?: string;
    /**
     * enum: `admin`, `helpdesk`, `none`, `read`
     */
    role: string;
}

export interface SiteNetworktemplateSwitchMgmtProtectRe {
    /**
     * optionally, services we'll allow
     */
    allowedServices: string[];
    customs?: outputs.SiteNetworktemplateSwitchMgmtProtectReCustom[];
    /**
     * when enabled, all traffic that is not essential to our operation will be dropped
     * e.g. ntp / dns / traffic to mist will be allowed by default
     *      if dhcpd is enabled, we'll make sure it works
     */
    enabled: boolean;
    /**
     * host/subnets we'll allow traffic to/from
     */
    trustedHosts: string[];
}

export interface SiteNetworktemplateSwitchMgmtProtectReCustom {
    /**
     * matched dst port, "0" means any
     */
    portRange: string;
    /**
     * enum: `any`, `icmp`, `tcp`, `udp`
     */
    protocol: string;
    subnets?: string[];
}

export interface SiteNetworktemplateSwitchMgmtTacacs {
    acctServers?: outputs.SiteNetworktemplateSwitchMgmtTacacsAcctServer[];
    /**
     * enum: `admin`, `helpdesk`, `none`, `read`
     */
    defaultRole: string;
    enabled?: boolean;
    /**
     * which network the TACACS server resides
     */
    network?: string;
    tacplusServers?: outputs.SiteNetworktemplateSwitchMgmtTacacsTacplusServer[];
}

export interface SiteNetworktemplateSwitchMgmtTacacsAcctServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface SiteNetworktemplateSwitchMgmtTacacsTacplusServer {
    host?: string;
    port?: string;
    secret?: string;
    timeout: number;
}

export interface SiteNetworktemplateUplinkPortConfig {
    /**
     * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
     */
    dot1x: boolean;
    /**
     * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
     */
    keepWlansUpIfDown: boolean;
}

export interface SiteNetworktemplateVrfConfig {
    /**
     * whether to enable VRF (when supported on the device)
     */
    enabled?: boolean;
}

export interface SiteNetworktemplateVrfInstances {
    /**
     * Property key is the destination CIDR (e.g. "10.0.0.0/8")
     */
    extraRoutes?: {[key: string]: outputs.SiteNetworktemplateVrfInstancesExtraRoutes};
    networks?: string[];
}

export interface SiteNetworktemplateVrfInstancesExtraRoutes {
    /**
     * Next-hop address
     */
    via: string;
}

export interface SiteSettingAnalytic {
    /**
     * enable Advanced Analytic feature (using SUB-ANA license)
     */
    enabled: boolean;
}

export interface SiteSettingAutoUpgrade {
    /**
     * custom versions for different models. Property key is the model name (e.g. "AP41")
     */
    customVersions: {[key: string]: string};
    /**
     * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
     */
    dayOfWeek?: string;
    /**
     * whether auto upgrade should happen (Note that Mist may auto-upgrade if the version is not supported)
     */
    enabled: boolean;
    /**
     * any / HH:MM (24-hour format), upgrade will happen within up to 1-hour from this time
     */
    timeOfDay?: string;
    /**
     * desired version. enum: `beta`, `custom`, `stable`
     */
    version: string;
}

export interface SiteSettingBleConfig {
    /**
     * whether Mist beacons is enabled
     */
    beaconEnabled: boolean;
    /**
     * required if `beacon_rate_mode`==`custom`, 1-10, in number-beacons-per-second
     */
    beaconRate: number;
    /**
     * enum: `custom`, `default`
     */
    beaconRateMode: string;
    /**
     * list of AP BLE location beam numbers (1-8) which should be disabled at the AP and not transmit location information (where beam 1 is oriented at the top the AP, growing counter-clock-wise, with 9 being the omni BLE beam)
     */
    beamDisableds?: number[];
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send custom packet
     */
    customBlePacketEnabled: boolean;
    /**
     * The custom frame to be sent out in this beacon. The frame must be a hexstring
     */
    customBlePacketFrame: string;
    /**
     * Frequency (msec) of data emitted by custom ble beacon
     */
    customBlePacketFreqMsec: number;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUidAdvPower: number;
    eddystoneUidBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-UID beacon is enabled
     */
    eddystoneUidEnabled: boolean;
    /**
     * Frequency (msec) of data emmit by Eddystone-UID beacon
     */
    eddystoneUidFreqMsec: number;
    /**
     * Eddystone-UID instance for the device
     */
    eddystoneUidInstance: string;
    /**
     * Eddystone-UID namespace
     */
    eddystoneUidNamespace: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    eddystoneUrlAdvPower: number;
    eddystoneUrlBeams: string;
    /**
     * only if `beacon_enabled`==`false`, Whether Eddystone-URL beacon is enabled
     */
    eddystoneUrlEnabled: boolean;
    /**
     * Frequency (msec) of data emit by Eddystone-UID beacon
     */
    eddystoneUrlFreqMsec: number;
    /**
     * URL pointed by Eddystone-URL beacon
     */
    eddystoneUrlUrl: string;
    /**
     * advertised TX Power, -100 to 20 (dBm), omit this attribute to use default
     */
    ibeaconAdvPower: number;
    ibeaconBeams: string;
    /**
     * can be enabled if `beacon_enabled`==`true`, whether to send iBeacon
     */
    ibeaconEnabled: boolean;
    /**
     * Frequency (msec) of data emmit for iBeacon
     */
    ibeaconFreqMsec: number;
    /**
     * Major number for iBeacon
     */
    ibeaconMajor: number;
    /**
     * Minor number for iBeacon
     */
    ibeaconMinor: number;
    /**
     * optional, if not specified, the same UUID as the beacon will be used
     */
    ibeaconUuid: string;
    /**
     * required if `power_mode`==`custom`
     */
    power: number;
    /**
     * enum: `custom`, `default`
     */
    powerMode: string;
}

export interface SiteSettingConfigPushPolicy {
    /**
     * stop any new config from being pushed to the device
     */
    noPush: boolean;
    /**
     * if enabled, new config will only be pushed to device within the specified time window
     */
    pushWindow?: outputs.SiteSettingConfigPushPolicyPushWindow;
}

export interface SiteSettingConfigPushPolicyPushWindow {
    enabled: boolean;
    /**
     * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
     *
     * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
     */
    hours?: outputs.SiteSettingConfigPushPolicyPushWindowHours;
}

export interface SiteSettingConfigPushPolicyPushWindowHours {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    tue: string;
    wed: string;
}

export interface SiteSettingCriticalUrlMonitoring {
    enabled: boolean;
    monitors: outputs.SiteSettingCriticalUrlMonitoringMonitor[];
}

export interface SiteSettingCriticalUrlMonitoringMonitor {
    url?: string;
    vlanId?: string;
}

export interface SiteSettingEngagement {
    dwellTagNames?: outputs.SiteSettingEngagementDwellTagNames;
    /**
     * add tags to visits within the duration (in seconds), available tags (passerby, bounce, engaged, stationed)
     */
    dwellTags?: outputs.SiteSettingEngagementDwellTags;
    /**
     * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
     *
     * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
     */
    hours?: outputs.SiteSettingEngagementHours;
    /**
     * max time, default is 43200(12h), max is 68400 (18h)
     */
    maxDwell: number;
    /**
     * min time
     */
    minDwell?: number;
}

export interface SiteSettingEngagementDwellTagNames {
    bounce?: string;
    engaged?: string;
    passerby?: string;
    stationed?: string;
}

export interface SiteSettingEngagementDwellTags {
    bounce?: string;
    engaged?: string;
    passerby?: string;
    stationed?: string;
}

export interface SiteSettingEngagementHours {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    tue: string;
    wed: string;
}

export interface SiteSettingGatewayMgmt {
    /**
     * for SSR only, as direct root access is not allowed
     */
    adminSshkeys: string[];
    appProbing?: outputs.SiteSettingGatewayMgmtAppProbing;
    /**
     * consumes uplink bandwidth, requires WA license
     */
    appUsage?: boolean;
    autoSignatureUpdate?: outputs.SiteSettingGatewayMgmtAutoSignatureUpdate;
    /**
     * he rollback timer for commit confirmed
     */
    configRevertTimer: number;
    probeHosts: string[];
    /**
     * for SRX only
     */
    rootPassword?: string;
    securityLogSourceAddress?: string;
    securityLogSourceInterface?: string;
}

export interface SiteSettingGatewayMgmtAppProbing {
    /**
     * app-keys from /api/v1/const/applications
     */
    apps?: string[];
    customApps?: outputs.SiteSettingGatewayMgmtAppProbingCustomApp[];
    enabled?: boolean;
}

export interface SiteSettingGatewayMgmtAppProbingCustomApp {
    /**
     * if `protocol`==`icmp`
     */
    address: string;
    appType?: string;
    /**
     * if `protocol`==`http`
     */
    hostnames?: string[];
    name?: string;
    network?: string;
    /**
     * enum: `http`, `udp`
     */
    protocol: string;
    /**
     * if `protocol`==`http`
     */
    url?: string;
    vrf?: string;
}

export interface SiteSettingGatewayMgmtAutoSignatureUpdate {
    /**
     * enum: `any`, `fri`, `mon`, `sat`, `sun`, `thu`, `tue`, `wed`
     */
    dayOfWeek?: string;
    enable: boolean;
    /**
     * optional, Mist will decide the timing
     */
    timeOfDay?: string;
}

export interface SiteSettingLed {
    brightness: number;
    enabled: boolean;
}

export interface SiteSettingOccupancy {
    /**
     * indicate whether named BLE assets should be included in the zone occupancy calculation
     */
    assetsEnabled: boolean;
    /**
     * indicate whether connected WiFi clients should be included in the zone occupancy calculation
     */
    clientsEnabled: boolean;
    /**
     * minimum duration
     */
    minDuration: number;
    /**
     * indicate whether SDK clients should be included in the zone occupancy calculation
     */
    sdkclientsEnabled: boolean;
    /**
     * indicate whether unconnected WiFi clients should be included in the zone occupancy calculation
     */
    unconnectedClientsEnabled: boolean;
}

export interface SiteSettingProxy {
    url?: string;
}

export interface SiteSettingRogue {
    /**
     * whether or not rogue detection is enabled
     */
    enabled: boolean;
    /**
     * whether or not honeypot detection is enabled
     */
    honeypotEnabled: boolean;
    /**
     * minimum duration for a bssid to be considered rogue
     */
    minDuration: number;
    /**
     * minimum RSSI for an AP to be considered rogue (ignoring APs that’s far away)
     */
    minRssi: number;
    /**
     * list of BSSIDs to whitelist. Ex: "cc-:8e-:6f-:d4-:bf-:16", "cc-8e-6f-d4-bf-16", "cc-73-*", "cc:82:*"
     */
    whitelistedBssids: string[];
    /**
     * list of SSIDs to whitelist
     */
    whitelistedSsids: string[];
}

export interface SiteSettingRtsa {
    appWaking: boolean;
    disableDeadReckoning?: boolean;
    disablePressureSensor: boolean;
    enabled?: boolean;
    /**
     * asset tracking related
     */
    trackAsset: boolean;
}

export interface SiteSettingSimpleAlert {
    arpFailure?: outputs.SiteSettingSimpleAlertArpFailure;
    dhcpFailure?: outputs.SiteSettingSimpleAlertDhcpFailure;
    dnsFailure?: outputs.SiteSettingSimpleAlertDnsFailure;
}

export interface SiteSettingSimpleAlertArpFailure {
    clientCount: number;
    /**
     * failing within minutes
     */
    duration: number;
    incidentCount: number;
}

export interface SiteSettingSimpleAlertDhcpFailure {
    clientCount: number;
    /**
     * failing within minutes
     */
    duration: number;
    incidentCount: number;
}

export interface SiteSettingSimpleAlertDnsFailure {
    clientCount: number;
    /**
     * failing within minutes
     */
    duration: number;
    incidentCount: number;
}

export interface SiteSettingSkyatp {
    enabled?: boolean;
    /**
     * whether to send IP-MAC mapping to SkyATP
     */
    sendIpMacMapping: boolean;
}

export interface SiteSettingSrxApp {
    enabled: boolean;
}

export interface SiteSettingSsr {
    conductorHosts?: string[];
    disableStats?: boolean;
}

export interface SiteSettingSyntheticTest {
    disabled: boolean;
    vlans?: outputs.SiteSettingSyntheticTestVlan[];
    wanSpeedtest?: outputs.SiteSettingSyntheticTestWanSpeedtest;
}

export interface SiteSettingSyntheticTestVlan {
    customTestUrls: string[];
    /**
     * for some vlans where we don't want this to run
     */
    disabled: boolean;
    vlanIds: string[];
}

export interface SiteSettingSyntheticTestWanSpeedtest {
    enabled?: boolean;
    /**
     * any / HH:MM (24-hour format)
     */
    timeOdFay: string;
}

export interface SiteSettingUplinkPortConfig {
    /**
     * Whether to do 802.1x against uplink switch. When enaled, AP cert will be used to do EAP-TLS and the Org's CA Cert has to be provisioned at the switch
     */
    dot1x: boolean;
    /**
     * by default, WLANs are disabled when uplink is down. In some scenario, like SiteSurvey, one would want the AP to keep sending beacons.
     */
    keepWlansUpIfDown: boolean;
}

export interface SiteSettingVna {
    /**
     * enable Virtual Network Assistant (using SUB-VNA license). This applied to AP / Switch / Gateway
     */
    enabled: boolean;
}

export interface SiteSettingVsInstance {
    networks: string[];
}

export interface SiteSettingWanVna {
    enabled: boolean;
}

export interface SiteSettingWids {
    repeatedAuthFailures?: outputs.SiteSettingWidsRepeatedAuthFailures;
}

export interface SiteSettingWidsRepeatedAuthFailures {
    /**
     * window where a trigger will be detected and action to be taken (in seconds)
     */
    duration?: number;
    /**
     * count of events to trigger
     */
    threshold?: number;
}

export interface SiteSettingWifi {
    ciscoEnabled: boolean;
    /**
     * whether to disable 11k
     */
    disable11k: boolean;
    disableRadiosWhenPowerConstrained: boolean;
    /**
     * when proxy_arp is enabled, check for arp spoofing.
     */
    enableArpSpoofCheck: boolean;
    enableSharedRadioScanning: boolean;
    /**
     * enable WIFI feature (using SUB-MAN license)
     */
    enabled: boolean;
    /**
     * whether to locate connected clients
     */
    locateConnected: boolean;
    /**
     * whether to locate unconnected clients
     */
    locateUnconnected: boolean;
    /**
     * whether to allow Mesh to use DFS channels. For DFS channels, Remote Mesh AP would have to do CAC when scanning for new Base AP, which is slow and will distrupt the connection. If roaming is desired, keep it disabled.
     */
    meshAllowDfs: boolean;
    /**
     * used to enable/disable CRM
     */
    meshEnableCrm: boolean;
    /**
     * whether to enable Mesh feature for the site
     */
    meshEnabled: boolean;
    /**
     * optional passphrase of mesh networking, default is generated randomly
     */
    meshPsk?: string;
    /**
     * optional ssid of mesh networking, default is based on site_id
     */
    meshSsid?: string;
    /**
     * enum: `default`, `disabled`, `enabled`
     */
    proxyArp?: string;
}

export interface SiteSettingWiredVna {
    enabled: boolean;
}

export interface SiteSettingZoneOccupancyAlert {
    /**
     * list of email addresses to send email notifications when the alert threshold is reached
     */
    emailNotifiers?: string[];
    /**
     * indicate whether zone occupancy alert is enabled for the site
     */
    enabled: boolean;
    /**
     * sending zone-occupancy-alert webhook message only if a zone stays non-compliant (i.e. actual occupancy > occupancy_limit) for a minimum duration specified in the threshold, in minutes
     */
    threshold: number;
}

export interface SiteWlanAcctServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Acct port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface SiteWlanAirwatch {
    /**
     * API Key
     */
    apiKey: string;
    /**
     * console URL
     */
    consoleUrl: string;
    enabled: boolean;
    /**
     * password
     */
    password: string;
    /**
     * username
     */
    username: string;
}

export interface SiteWlanAppLimit {
    /**
     * Map from app key to bandwidth in kbps. 
     * Property key is the app key, defined in Get Application List
     */
    apps?: {[key: string]: number};
    enabled: boolean;
    /**
     * Map from wxtag_id of Hostname Wxlan Tags to bandwidth in kbps
     * Property key is the wxtag id
     */
    wxtagIds: {[key: string]: number};
}

export interface SiteWlanAppQos {
    apps?: {[key: string]: outputs.SiteWlanAppQosApps};
    enabled: boolean;
    others?: outputs.SiteWlanAppQosOther[];
}

export interface SiteWlanAppQosApps {
    dscp?: number;
    /**
     * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
     */
    dstSubnet?: string;
    /**
     * subnet filter is not required but helps AP to only inspect certain traffic (thus reducing AP load)
     */
    srcSubnet?: string;
}

export interface SiteWlanAppQosOther {
    dscp?: number;
    dstSubnet?: string;
    portRanges?: string;
    protocol?: string;
    srcSubnet?: string;
}

export interface SiteWlanAuth {
    /**
     * SAE anti-clogging token threshold
     */
    anticlogThreshold: number;
    /**
     * whether to trigger EAP reauth when the session ends
     */
    eapReauth: boolean;
    /**
     * whether to enable MAC Auth, uses the same auth_servers
     */
    enableMacAuth: boolean;
    /**
     * when `type`==`wep`
     */
    keyIdx: number;
    /**
     * when type=wep, four 10-character or 26-character hex string, null can be used. All keys, if provided, have to be in the same length
     */
    keys: string[];
    /**
     * when `type`==`psk`, whether to only use multi_psk
     */
    multiPskOnly: boolean;
    /**
     * if `type`==`open`. enum: `disabled`, `enabled` (means transition mode), `required`
     */
    owe: string;
    /**
     * when `type`=`psk` or `type`=`eap`, one or more of `wpa1-ccmp`, `wpa1-tkip`, `wpa2-ccmp`, `wpa2-tkip`, `wpa3`
     */
    pairwises: string[];
    /**
     * when `multi_psk_only`==`true`, whether private wlan is enabled
     */
    privateWlan: boolean;
    /**
     * when `type`==`psk`, 8-64 characters, or 64 hex characters
     */
    psk: string;
    /**
     * enum: `eap`, `eap192`, `open`, `psk`, `psk-tkip`, `psk-wpa2-tkip`, `wep`
     */
    type: string;
    /**
     * enable WEP as secondary auth
     */
    wepAsSecondaryAuth: boolean;
}

export interface SiteWlanAuthServer {
    /**
     * ip / hostname of RADIUS server
     */
    host: string;
    keywrapEnabled?: boolean;
    /**
     * enum: `ascii`, `hex`
     */
    keywrapFormat?: string;
    keywrapKek?: string;
    keywrapMack?: string;
    /**
     * Auth port of RADIUS server
     */
    port: number;
    /**
     * secret of RADIUS server
     */
    secret: string;
}

export interface SiteWlanBonjour {
    /**
     * additional VLAN IDs (on the LAN side or from other WLANs) should we be forwarding bonjour queries/responses
     */
    additionalVlanIds: string[];
    /**
     * whether to enable bonjour for this WLAN. Once enabled, limit_bcast is assumed true, allow_mdns is assumed false
     */
    enabled: boolean;
    /**
     * what services are allowed. 
     * Property key is the service name
     */
    services: {[key: string]: outputs.SiteWlanBonjourServices};
}

export interface SiteWlanBonjourServices {
    /**
     * whether to prevent wireless clients to discover bonjour devices on the same WLAN
     */
    disableLocal: boolean;
    /**
     * optional, if the service is further restricted for certain RADIUS groups
     */
    radiusGroups?: string[];
    /**
     * how bonjour services should be discovered for the same WLAN. enum: `same_ap`, `same_map`, `same_site`
     */
    scope: string;
}

export interface SiteWlanCiscoCwa {
    /**
     * list of hostnames without http(s):// (matched by substring)
     */
    allowedHostnames?: string[];
    /**
     * list of CIDRs
     */
    allowedSubnets?: string[];
    /**
     * list of blocked CIDRs
     */
    blockedSubnets?: string[];
    enabled: boolean;
}

export interface SiteWlanCoaServer {
    /**
     * whether to disable Event-Timestamp Check
     */
    disableEventTimestampCheck: boolean;
    enabled: boolean;
    ip: string;
    port: number;
    secret: string;
}

export interface SiteWlanDnsServerRewrite {
    enabled: boolean;
    /**
     * map between radius_group and the desired DNS server (IPv4 only)
     * Property key is the RADIUS group, property value is the desired DNS Server
     */
    radiusGroups?: {[key: string]: string};
}

export interface SiteWlanDynamicPsk {
    /**
     * default PSK to use if cloud WLC is not available, 8-63 characters
     */
    defaultPsk?: string;
    defaultVlanId?: string;
    enabled: boolean;
    /**
     * when 11r is enabled, we'll try to use the cached PMK, this can be disabled
     * `false` means auto
     */
    forceLookup: boolean;
    /**
     * enum: `cloud_psks`, `radius`
     */
    source: string;
    vlanIds?: string[];
}

export interface SiteWlanDynamicVlan {
    /**
     * Default VLAN ID(s) can be a number, a range of VLAN IDs, a variable or multiple numbers, ranges or variables as a VLAN pool. Default VLAN as a pool of VLANS requires 0.14.x or newer firmware
     */
    defaultVlanIds: string[];
    /**
     * whether to enable dynamic vlan
     */
    enabled: boolean;
    /**
     * vlan_ids to be locally bridged
     */
    localVlanIds: string[];
    /**
     * standard (using Tunnel-Private-Group-ID, widely supported), airespace-interface-name (Airespace/Cisco). enum: `airespace-interface-name`, `standard`
     */
    type: string;
    /**
     * map between vlan_id (as string) to airespace interface names (comma-separated) or null for stndard mapping
     *   * if `dynamic_vlan.type`==`standard`, property key is the Vlan ID and property value is \"\"
     *   * if `dynamic_vlan.type`==`airespace-interface-name`, property key is the Vlan ID and property value is the Airespace Interface Name
     */
    vlans?: {[key: string]: string};
}

export interface SiteWlanHotspot20 {
    domainNames?: string[];
    /**
     * whether to enable hotspot 2.0 config
     */
    enabled?: boolean;
    naiRealms?: string[];
    /**
     * list of operators to support
     */
    operators?: string[];
    rcois?: string[];
    /**
     * venue name, default is site name
     */
    venueName?: string;
}

export interface SiteWlanInjectDhcpOption82 {
    circuitId?: string;
    /**
     * whether to inject option 82 when forwarding DHCP packets
     */
    enabled: boolean;
}

export interface SiteWlanMistNac {
    /**
     * when enabled:
     *   * `auth_servers` is ignored
     *   * `acct_servers` is ignored
     *   * `auth_servers_*` are ignored
     *   * `coa_servers` is ignored
     *   * `radsec` is ignored
     *   * `coa_enabled` is assumed'
     */
    enabled: boolean;
}

export interface SiteWlanPortal {
    /**
     * amazon OAuth2 client id. This is optional. If not provided, it will use a default one.
     */
    amazonClientId: string;
    /**
     * amazon OAuth2 client secret. If amazon_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    amazonClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    amazonEmailDomains: string[];
    /**
     * whether amazon is enabled as a login method
     */
    amazonEnabled: boolean;
    /**
     * interval for which guest remains authorized using amazon auth (in minutes), if not provided, uses expire`
     */
    amazonExpire: number;
    /**
     * authentication scheme. enum: `external`, `none`, `sso`
     */
    auth: string;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory app client id
     */
    azureClientId: string;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory app client secret
     */
    azureClientSecret: string;
    /**
     * whether Azure Active Directory is enabled as a login method
     */
    azureEnabled: boolean;
    /**
     * interval for which guest remains authorized using azure auth (in minutes), if not provided, uses expire`
     */
    azureExpire: number;
    /**
     * Required if `azure_enabled`==`true`.
     * Azure active directory tenant id.
     */
    azureTenantId: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetPassword: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetSid: string;
    /**
     * when `sms_provider`==`broadnet`
     */
    broadnetUserId: string;
    /**
     * whether to bypass the guest portal when cloud not reachable (and apply the default policies)
     */
    bypassWhenCloudDown: boolean;
    /**
     * when `sms_provider`==`clickatell`
     */
    clickatellApiKey: string;
    /**
     * whether to allow guest to roam between WLANs (with same `WLAN.ssid`, regardless of variables) of different sites of same org without reauthentication (disable random_mac for seamless roaming)
     */
    crossSite: boolean;
    /**
     * whether email (access code verification) is enabled as a login method
     */
    emailEnabled: boolean;
    /**
     * whether guest portal is enabled
     */
    enabled: boolean;
    /**
     * how long to remain authorized, in minutes
     */
    expire: number;
    /**
     * external portal URL (e.g. https://host/url) where we can append our query parameters to
     */
    externalPortalUrl: string;
    /**
     * Required if `facebook_enabled`==`true`.
     * Facebook OAuth2 app id. This is optional. If not provided, it will use a default one.
     */
    facebookClientId: string;
    /**
     * Required if `facebook_enabled`==`true`.
     * Facebook OAuth2 app secret. If facebook_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    facebookClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    facebookEmailDomains: string[];
    /**
     * whether facebook is enabled as a login method
     */
    facebookEnabled: boolean;
    /**
     * interval for which guest remains authorized using facebook auth (in minutes), if not provided, uses expire`
     */
    facebookExpire: number;
    /**
     * whether to forward the user to another URL after authorized
     */
    forward: boolean;
    /**
     * the URL to forward the user to
     */
    forwardUrl: string;
    /**
     * Google OAuth2 app id. This is optional. If not provided, it will use a default one.
     */
    googleClientId: string;
    /**
     * Google OAuth2 app secret. If google_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    googleClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    googleEmailDomains: string[];
    /**
     * whether google is enabled as login method
     */
    googleEnabled: boolean;
    /**
     * interval for which guest remains authorized using google auth (in minutes), if not provided, uses expire`
     */
    googleExpire: number;
    /**
     * when `sms_provider`==`gupshup`
     */
    gupshupPassword: string;
    /**
     * when `sms_provider`==`gupshup`
     */
    gupshupUserid: string;
    /**
     * microsoft 365 OAuth2 client id. This is optional. If not provided, it will use a default one.
     */
    microsoftClientId: string;
    /**
     * microsoft 365 OAuth2 client secret. If microsoft_client_id was provided, provide a correspoinding value. Else leave blank.
     */
    microsoftClientSecret: string;
    /**
     * Matches authenticated user email against provided domains. If null or [], all authenticated emails will be allowed.
     */
    microsoftEmailDomains: string[];
    /**
     * whether microsoft 365 is enabled as a login method
     */
    microsoftEnabled: boolean;
    /**
     * interval for which guest remains authorized using microsoft auth (in minutes), if not provided, uses expire`
     */
    microsoftExpire: number;
    /**
     * whether password is enabled
     */
    passphraseEnabled: boolean;
    /**
     * interval for which guest remains authorized using passphrase auth (in minutes), if not provided, uses `expire`
     */
    passphraseExpire: number;
    /**
     * passphrase
     */
    password: string;
    /**
     * whether to show list of sponsor emails mentioned in `sponsors` object as a dropdown. If both `sponsor_notify_all` and `predefined_sponsors_enabled` are false, behaviour is acc to `sponsor_email_domains`
     */
    predefinedSponsorsEnabled: boolean;
    /**
     * whether to hide sponsor’s email from list of sponsors
     */
    predefinedSponsorsHideEmail: boolean;
    privacy: boolean;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelPassword: string;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelServiceId: string;
    /**
     * when `sms_provider`==`puzzel`
     */
    puzzelUsername: string;
    /**
     * whether sms is enabled as a login method
     */
    smsEnabled: boolean;
    /**
     * interval for which guest remains authorized using sms auth (in minutes), if not provided, uses expire`
     */
    smsExpire: number;
    smsMessageFormat: string;
    /**
     * enum: `broadnet`, `clickatell`, `gupshup`, `manual`, `puzzel`, `telstra`, `twilio`
     */
    smsProvider: string;
    /**
     * whether to automatically approve guest and allow sponsor to revoke guest access, needs predefined_sponsors_enabled enabled and sponsor_notify_all disabled
     */
    sponsorAutoApprove: boolean;
    /**
     * list of domain allowed for sponsor email. Required if `sponsor_enabled` is `true` and `sponsors` is empty.
     */
    sponsorEmailDomains: string[];
    /**
     * whether sponsor is enabled
     */
    sponsorEnabled: boolean;
    /**
     * interval for which guest remains authorized using sponsor auth (in minutes), if not provided, uses expire`
     */
    sponsorExpire: number;
    /**
     * how long to remain valid sponsored guest request approve/deny link received in email, in minutes.
     */
    sponsorLinkValidityDuration: string;
    /**
     * whether to notify all sponsors that are mentioned in `sponsors` object. Both `sponsor_notify_all` and `predefined_sponsors_enabled` should be true in order to notify sponsors. If true, email sent to 10 sponsors in no particular order.
     */
    sponsorNotifyAll: boolean;
    /**
     * if enabled, guest will get email about sponsor's action (approve/deny)
     */
    sponsorStatusNotify: boolean;
    /**
     * object of allowed sponsors email with name. Required if `sponsor_enabled` is `true` and `sponsor_email_domains` is empty.
     * Property key is the sponsor email, Property value is the sponsor name
     */
    sponsors: {[key: string]: string};
    /**
     * default role to assign if there’s no match. By default, an assertion is treated as invalid when there’s no role matched
     */
    ssoDefaultRole: string;
    ssoForcedRole: string;
    /**
     * IDP Cert (used to verify the signed response)
     */
    ssoIdpCert: string;
    /**
     * signing algorithm for SAML Assertion
     */
    ssoIdpSignAlgo: string;
    /**
     * IDP Single-Sign-On URL
     */
    ssoIdpSsoUrl: string;
    /**
     * IDP issuer URL
     */
    ssoIssuer: string;
    /**
     * enum: `email`, `unspecified`
     */
    ssoNameidFormat: string;
    /**
     * when `sms_provider`==`telstra`, Client ID provided by Telstra
     */
    telstraClientId: string;
    /**
     * when `sms_provider`==`telstra`, Client secret provided by Telstra
     */
    telstraClientSecret: string;
    /**
     * when `sms_provider`==`twilio`, Auth token account with twilio account
     */
    twilioAuthToken: string;
    /**
     * when `sms_provider`==`twilio`, Twilio phone number associated with the account. See example for accepted format.
     */
    twilioPhoneNumber: string;
    /**
     * when `sms_provider`==`twilio`, Account SID provided by Twilio
     */
    twilioSid: string;
}

export interface SiteWlanQos {
    /**
     * enum: `background`, `best_effort`, `video`, `voice`
     */
    class: string;
    /**
     * whether to overwrite QoS
     */
    overwrite: boolean;
}

export interface SiteWlanRadsec {
    coaEnabled: boolean;
    enabled?: boolean;
    idleTimeout?: number;
    /**
     * To use Org mxedges when this WLAN does not use mxtunnel, specify their mxcluster_ids.
     * Org mxedge(s) identified by mxcluster_ids
     */
    mxclusterIds: string[];
    /**
     * default is site.mxedge.radsec.proxy_hosts which must be a superset of all wlans[*].radsec.proxy_hosts
     * when radsec.proxy_hosts are not used, tunnel peers (org or site mxedges) are used irrespective of use_site_mxedge
     */
    proxyHosts: string[];
    /**
     * name of the server to verify (against the cacerts in Org Setting). Only if not Mist Edge.
     */
    serverName?: string;
    /**
     * List of Radsec Servers. Only if not Mist Edge.
     */
    servers?: outputs.SiteWlanRadsecServer[];
    /**
     * use mxedge(s) as radsecproxy
     */
    useMxedge?: boolean;
    /**
     * To use Site mxedges when this WLAN does not use mxtunnel
     */
    useSiteMxedge: boolean;
}

export interface SiteWlanRadsecServer {
    host?: string;
    port?: number;
}

export interface SiteWlanSchedule {
    enabled: boolean;
    /**
     * hours of operation filter, the available days (mon, tue, wed, thu, fri, sat, sun). 
     *
     * **Note**: If the dow is not defined then it\u2019\ s treated as 00:00-23:59.
     */
    hours?: outputs.SiteWlanScheduleHours;
}

export interface SiteWlanScheduleHours {
    fri: string;
    mon: string;
    sat: string;
    sun: string;
    thu: string;
    tue: string;
    wed: string;
}

export interface SiteWxtagSpec {
    /**
     * matched destination port, "0" means any
     */
    portRange: string;
    /**
     * tcp / udp / icmp / gre / any / ":protocol_number", `protocol_number` is between 1-254
     */
    protocol: string;
    /**
     * matched destination subnets and/or IP Addresses
     */
    subnets: string[];
}

