// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DataIntegrationS3 {
    bucketName: string;
    subdir?: string;
}

export interface ElastigroupAwsBeanstalkDeploymentPreferences {
    automaticRoll?: boolean;
    batchSizePercentage?: number;
    gracePeriod?: number;
    strategies?: outputs.ElastigroupAwsBeanstalkDeploymentPreferencesStrategy[];
}

export interface ElastigroupAwsBeanstalkDeploymentPreferencesStrategy {
    action?: string;
    shouldDrainInstances?: boolean;
}

export interface ElastigroupAwsBeanstalkManagedActions {
    platformUpdate?: outputs.ElastigroupAwsBeanstalkManagedActionsPlatformUpdate;
}

export interface ElastigroupAwsBeanstalkManagedActionsPlatformUpdate {
    performAt?: string;
    timeWindow?: string;
    updateLevel?: string;
}

export interface ElastigroupAwsBeanstalkScheduledTask {
    adjustment?: string;
    adjustmentPercentage?: string;
    batchSizePercentage?: string;
    cronExpression?: string;
    frequency?: string;
    gracePeriod?: string;
    isEnabled?: boolean;
    maxCapacity?: string;
    minCapacity?: string;
    scaleMaxCapacity?: string;
    scaleMinCapacity?: string;
    scaleTargetCapacity?: string;
    startTime?: string;
    targetCapacity?: string;
    taskType: string;
}

export interface ElastigroupAwsCpuOptions {
    threadsPerCore: number;
}

export interface ElastigroupAwsEbsBlockDevice {
    deleteOnTermination: boolean;
    deviceName: string;
    dynamicIops?: outputs.ElastigroupAwsEbsBlockDeviceDynamicIops;
    dynamicVolumeSize?: outputs.ElastigroupAwsEbsBlockDeviceDynamicVolumeSize;
    encrypted: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface ElastigroupAwsEbsBlockDeviceDynamicIops {
    baseSize?: number;
    resource?: string;
    sizePerResourceUnit?: number;
}

export interface ElastigroupAwsEbsBlockDeviceDynamicVolumeSize {
    baseSize?: number;
    resource?: string;
    sizePerResourceUnit?: number;
}

export interface ElastigroupAwsEphemeralBlockDevice {
    deviceName: string;
    virtualName: string;
}

export interface ElastigroupAwsImage {
    images: outputs.ElastigroupAwsImageImage[];
}

export interface ElastigroupAwsImageImage {
    id: string;
}

export interface ElastigroupAwsInstanceTypesWeight {
    instanceType: string;
    weight: number;
}

export interface ElastigroupAwsIntegrationBeanstalk {
    deploymentPreferences?: outputs.ElastigroupAwsIntegrationBeanstalkDeploymentPreferences;
    environmentId?: string;
    managedActions?: outputs.ElastigroupAwsIntegrationBeanstalkManagedActions;
}

export interface ElastigroupAwsIntegrationBeanstalkDeploymentPreferences {
    automaticRoll?: boolean;
    batchSizePercentage?: number;
    gracePeriod?: number;
    strategy?: outputs.ElastigroupAwsIntegrationBeanstalkDeploymentPreferencesStrategy;
}

export interface ElastigroupAwsIntegrationBeanstalkDeploymentPreferencesStrategy {
    action?: string;
    shouldDrainInstances?: boolean;
}

export interface ElastigroupAwsIntegrationBeanstalkManagedActions {
    platformUpdate?: outputs.ElastigroupAwsIntegrationBeanstalkManagedActionsPlatformUpdate;
}

export interface ElastigroupAwsIntegrationBeanstalkManagedActionsPlatformUpdate {
    performAt?: string;
    timeWindow?: string;
    updateLevel?: string;
}

export interface ElastigroupAwsIntegrationCodedeploy {
    cleanupOnFailure: boolean;
    deploymentGroups: outputs.ElastigroupAwsIntegrationCodedeployDeploymentGroup[];
    terminateInstanceOnFailure: boolean;
}

export interface ElastigroupAwsIntegrationCodedeployDeploymentGroup {
    applicationName: string;
    deploymentGroupName: string;
}

export interface ElastigroupAwsIntegrationDockerSwarm {
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupAwsIntegrationDockerSwarmAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupAwsIntegrationDockerSwarmAutoscaleHeadroom;
    autoscaleIsEnabled?: boolean;
    masterHost: string;
    masterPort: number;
}

export interface ElastigroupAwsIntegrationDockerSwarmAutoscaleDown {
    evaluationPeriods?: number;
    maxScaleDownPercentage?: number;
}

export interface ElastigroupAwsIntegrationDockerSwarmAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupAwsIntegrationEcs {
    autoscaleAttributes?: outputs.ElastigroupAwsIntegrationEcsAutoscaleAttribute[];
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupAwsIntegrationEcsAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupAwsIntegrationEcsAutoscaleHeadroom;
    autoscaleIsAutoConfig?: boolean;
    autoscaleIsEnabled?: boolean;
    autoscaleScaleDownNonServiceTasks?: boolean;
    batch?: outputs.ElastigroupAwsIntegrationEcsBatch;
    clusterName: string;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleAttribute {
    key: string;
    value: string;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleDown {
    evaluationPeriods?: number;
    maxScaleDownPercentage?: number;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupAwsIntegrationEcsBatch {
    jobQueueNames: string[];
}

export interface ElastigroupAwsIntegrationGitlab {
    runner?: outputs.ElastigroupAwsIntegrationGitlabRunner;
}

export interface ElastigroupAwsIntegrationGitlabRunner {
    isEnabled?: boolean;
}

export interface ElastigroupAwsIntegrationKubernetes {
    apiServer?: string;
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupAwsIntegrationKubernetesAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupAwsIntegrationKubernetesAutoscaleHeadroom;
    autoscaleIsAutoConfig?: boolean;
    autoscaleIsEnabled?: boolean;
    autoscaleLabels?: outputs.ElastigroupAwsIntegrationKubernetesAutoscaleLabel[];
    clusterIdentifier?: string;
    integrationMode?: string;
    token?: string;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleDown {
    evaluationPeriods?: number;
    maxScaleDownPercentage?: number;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleLabel {
    key: string;
    value: string;
}

export interface ElastigroupAwsIntegrationMesosphere {
    apiServer: string;
}

export interface ElastigroupAwsIntegrationNomad {
    aclToken?: string;
    autoscaleConstraints?: outputs.ElastigroupAwsIntegrationNomadAutoscaleConstraint[];
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupAwsIntegrationNomadAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupAwsIntegrationNomadAutoscaleHeadroom;
    autoscaleIsEnabled?: boolean;
    masterHost: string;
    masterPort: number;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleConstraint {
    key: string;
    value: string;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleDown {
    evaluationPeriods?: number;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupAwsIntegrationRancher {
    accessKey: string;
    masterHost: string;
    secretKey: string;
    version?: string;
}

export interface ElastigroupAwsIntegrationRoute53 {
    domains: outputs.ElastigroupAwsIntegrationRoute53Domain[];
}

export interface ElastigroupAwsIntegrationRoute53Domain {
    hostedZoneId: string;
    recordSetType?: string;
    recordSets: outputs.ElastigroupAwsIntegrationRoute53DomainRecordSet[];
    spotinstAcctId?: string;
}

export interface ElastigroupAwsIntegrationRoute53DomainRecordSet {
    name: string;
    usePublicDns?: boolean;
    usePublicIp?: boolean;
}

export interface ElastigroupAwsItf {
    defaultStaticTargetGroup?: outputs.ElastigroupAwsItfDefaultStaticTargetGroup;
    fixedTargetGroups: boolean;
    loadBalancers: outputs.ElastigroupAwsItfLoadBalancer[];
    migrationHealthinessThreshold?: number;
    targetGroupConfigs: outputs.ElastigroupAwsItfTargetGroupConfig[];
    weightStrategy: string;
}

export interface ElastigroupAwsItfDefaultStaticTargetGroup {
    arn: string;
    percentage: number;
}

export interface ElastigroupAwsItfLoadBalancer {
    listenerRules: outputs.ElastigroupAwsItfLoadBalancerListenerRule[];
    loadBalancerArn: string;
}

export interface ElastigroupAwsItfLoadBalancerListenerRule {
    ruleArn: string;
    staticTargetGroup?: outputs.ElastigroupAwsItfLoadBalancerListenerRuleStaticTargetGroup;
}

export interface ElastigroupAwsItfLoadBalancerListenerRuleStaticTargetGroup {
    arn: string;
    percentage: number;
}

export interface ElastigroupAwsItfTargetGroupConfig {
    healthCheckIntervalSeconds?: number;
    healthCheckPath: string;
    healthCheckPort?: string;
    healthCheckProtocol?: string;
    healthCheckTimeoutSeconds?: number;
    healthyThresholdCount?: number;
    matchers?: outputs.ElastigroupAwsItfTargetGroupConfigMatcher[];
    port: number;
    protocol: string;
    protocolVersion?: string;
    tags?: outputs.ElastigroupAwsItfTargetGroupConfigTag[];
    unhealthyThresholdCount?: number;
    vpcId: string;
}

export interface ElastigroupAwsItfTargetGroupConfigMatcher {
    grpcCode?: string;
    httpCode?: string;
}

export interface ElastigroupAwsItfTargetGroupConfigTag {
    tagKey: string;
    tagValue?: string;
}

export interface ElastigroupAwsLogging {
    export?: outputs.ElastigroupAwsLoggingExport;
}

export interface ElastigroupAwsLoggingExport {
    s3s?: outputs.ElastigroupAwsLoggingExportS3[];
}

export interface ElastigroupAwsLoggingExportS3 {
    id: string;
}

export interface ElastigroupAwsMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
    instanceMetadataTags?: string;
}

export interface ElastigroupAwsMultipleMetrics {
    expressions?: outputs.ElastigroupAwsMultipleMetricsExpression[];
    metrics?: outputs.ElastigroupAwsMultipleMetricsMetric[];
}

export interface ElastigroupAwsMultipleMetricsExpression {
    expression: string;
    name: string;
}

export interface ElastigroupAwsMultipleMetricsMetric {
    dimensions?: outputs.ElastigroupAwsMultipleMetricsMetricDimension[];
    extendedStatistic?: string;
    metricName: string;
    name: string;
    namespace: string;
    statistic?: string;
    unit?: string;
}

export interface ElastigroupAwsMultipleMetricsMetricDimension {
    name: string;
    value?: string;
}

export interface ElastigroupAwsNetworkInterface {
    associateIpv6Address?: boolean;
    associatePublicIpAddress?: boolean;
    deleteOnTermination: boolean;
    description?: string;
    deviceIndex: string;
    networkInterfaceId?: string;
    privateIpAddress?: string;
    secondaryPrivateIpAddressCount?: string;
}

export interface ElastigroupAwsResourceRequirement {
    excludedInstanceFamilies?: string[];
    excludedInstanceGenerations?: string[];
    excludedInstanceTypes?: string[];
    requiredGpuMaximum?: number;
    requiredGpuMinimum?: number;
    requiredMemoryMaximum: number;
    requiredMemoryMinimum: number;
    requiredVcpuMaximum: number;
    requiredVcpuMinimum: number;
}

export interface ElastigroupAwsResourceTagSpecification {
    shouldTagAmis?: boolean;
    shouldTagEnis?: boolean;
    shouldTagSnapshots?: boolean;
    shouldTagVolumes?: boolean;
}

export interface ElastigroupAwsRevertToSpot {
    performAt: string;
    timeWindows?: string[];
}

export interface ElastigroupAwsScalingDownPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown?: number;
    dimensions?: outputs.ElastigroupAwsScalingDownPolicyDimension[];
    evaluationPeriods: number;
    isEnabled?: boolean;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic?: string;
    stepAdjustments?: outputs.ElastigroupAwsScalingDownPolicyStepAdjustment[];
    target?: string;
    threshold?: number;
    unit?: string;
}

export interface ElastigroupAwsScalingDownPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupAwsScalingDownPolicyStepAdjustment {
    action: outputs.ElastigroupAwsScalingDownPolicyStepAdjustmentAction;
    threshold: number;
}

export interface ElastigroupAwsScalingDownPolicyStepAdjustmentAction {
    adjustment?: string;
    maxTargetCapacity?: string;
    maximum?: string;
    minTargetCapacity?: string;
    minimum?: string;
    target?: string;
    type: string;
}

export interface ElastigroupAwsScalingStrategy {
    terminateAtEndOfBillingHour?: boolean;
    terminationPolicy?: string;
}

export interface ElastigroupAwsScalingTargetPolicy {
    cooldown?: number;
    dimensions?: outputs.ElastigroupAwsScalingTargetPolicyDimension[];
    evaluationPeriods?: number;
    maxCapacityPerScale?: string;
    metricName: string;
    namespace: string;
    period?: number;
    policyName: string;
    predictiveMode?: string;
    source: string;
    statistic?: string;
    target: number;
    unit?: string;
}

export interface ElastigroupAwsScalingTargetPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupAwsScalingUpPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown?: number;
    dimensions?: outputs.ElastigroupAwsScalingUpPolicyDimension[];
    evaluationPeriods: number;
    isEnabled?: boolean;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic?: string;
    stepAdjustments?: outputs.ElastigroupAwsScalingUpPolicyStepAdjustment[];
    target?: string;
    threshold?: number;
    unit?: string;
}

export interface ElastigroupAwsScalingUpPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupAwsScalingUpPolicyStepAdjustment {
    action: outputs.ElastigroupAwsScalingUpPolicyStepAdjustmentAction;
    threshold: number;
}

export interface ElastigroupAwsScalingUpPolicyStepAdjustmentAction {
    adjustment?: string;
    maxTargetCapacity?: string;
    maximum?: string;
    minTargetCapacity?: string;
    minimum?: string;
    target?: string;
    type: string;
}

export interface ElastigroupAwsScheduledTask {
    adjustment?: string;
    adjustmentPercentage?: string;
    batchSizePercentage?: string;
    cronExpression?: string;
    frequency?: string;
    gracePeriod?: string;
    isEnabled?: boolean;
    maxCapacity?: string;
    minCapacity?: string;
    scaleMaxCapacity?: string;
    scaleMinCapacity?: string;
    scaleTargetCapacity?: string;
    startTime?: string;
    targetCapacity?: string;
    taskType: string;
}

export interface ElastigroupAwsSignal {
    name: string;
    timeout?: number;
}

export interface ElastigroupAwsStatefulDeallocation {
    shouldDeleteImages?: boolean;
    shouldDeleteNetworkInterfaces?: boolean;
    shouldDeleteSnapshots?: boolean;
    shouldDeleteVolumes?: boolean;
}

export interface ElastigroupAwsStatefulInstanceAction {
    statefulInstanceId: string;
    type: string;
}

export interface ElastigroupAwsSuspensionSuspension {
    name: string;
}

export interface ElastigroupAwsTag {
    key?: string;
    value?: string;
}

export interface ElastigroupAwsUpdatePolicy {
    autoApplyTags?: boolean;
    rollConfig?: outputs.ElastigroupAwsUpdatePolicyRollConfig;
    shouldResumeStateful: boolean;
    shouldRoll: boolean;
}

export interface ElastigroupAwsUpdatePolicyRollConfig {
    batchSizePercentage: number;
    gracePeriod?: number;
    healthCheckType?: string;
    strategy?: outputs.ElastigroupAwsUpdatePolicyRollConfigStrategy;
    waitForRollPercentage?: number;
    waitForRollTimeout?: number;
}

export interface ElastigroupAwsUpdatePolicyRollConfigStrategy {
    action: string;
    batchMinHealthyPercentage?: number;
    onFailure?: outputs.ElastigroupAwsUpdatePolicyRollConfigStrategyOnFailure;
    shouldDrainInstances?: boolean;
}

export interface ElastigroupAwsUpdatePolicyRollConfigStrategyOnFailure {
    actionType: string;
    batchNum?: number;
    drainingTimeout?: number;
    shouldDecrementTargetCapacity?: boolean;
    shouldHandleAllBatches?: boolean;
}

export interface ElastigroupAzureV3Image {
    customs?: outputs.ElastigroupAzureV3ImageCustom[];
    galleryImages?: outputs.ElastigroupAzureV3ImageGalleryImage[];
    marketplaces?: outputs.ElastigroupAzureV3ImageMarketplace[];
}

export interface ElastigroupAzureV3ImageCustom {
    imageName: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3ImageGalleryImage {
    galleryName: string;
    imageName: string;
    resourceGroupName: string;
    spotAccountId?: string;
    version: string;
}

export interface ElastigroupAzureV3ImageMarketplace {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface ElastigroupAzureV3Login {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface ElastigroupAzureV3ManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Network {
    networkInterfaces: outputs.ElastigroupAzureV3NetworkNetworkInterface[];
    resourceGroupName: string;
    virtualNetworkName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterface {
    additionalIpConfigs?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig[];
    applicationSecurityGroups?: outputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp: boolean;
    isPrimary: boolean;
    subnetName: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig {
    name: string;
    privateIpVersion?: string;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    resourceGroupName: string;
}

export interface ElastigroupAzureV3Tag {
    key: string;
    value: string;
}

export interface ElastigroupAzureV3VmSizes {
    odSizes: string[];
    spotSizes: string[];
}

export interface ElastigroupGcpBackendService {
    locationType?: string;
    namedPorts?: outputs.ElastigroupGcpBackendServiceNamedPort[];
    scheme?: string;
    serviceName: string;
}

export interface ElastigroupGcpBackendServiceNamedPort {
    name: string;
    ports: string[];
}

export interface ElastigroupGcpDisk {
    autoDelete?: boolean;
    boot?: boolean;
    deviceName?: string;
    initializeParams?: outputs.ElastigroupGcpDiskInitializeParam[];
    interface?: string;
    mode?: string;
    source?: string;
    type?: string;
}

export interface ElastigroupGcpDiskInitializeParam {
    diskSizeGb?: string;
    diskType?: string;
    sourceImage: string;
}

export interface ElastigroupGcpGpus {
    count: number;
    type: string;
}

export interface ElastigroupGcpInstanceTypesCustom {
    memoryGib: number;
    vcpu: number;
}

export interface ElastigroupGcpIntegrationDockerSwarm {
    masterHost: string;
    masterPort: number;
}

export interface ElastigroupGcpIntegrationGke {
    autoUpdate?: boolean;
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupGcpIntegrationGkeAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupGcpIntegrationGkeAutoscaleHeadroom;
    autoscaleIsAutoConfig?: boolean;
    autoscaleIsEnabled?: boolean;
    autoscaleLabels?: outputs.ElastigroupGcpIntegrationGkeAutoscaleLabel[];
    clusterId?: string;
    location?: string;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleDown {
    evaluationPeriods?: number;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleLabel {
    key: string;
    value: string;
}

export interface ElastigroupGcpLabel {
    key: string;
    value: string;
}

export interface ElastigroupGcpMetadata {
    key: string;
    value: string;
}

export interface ElastigroupGcpNetworkInterface {
    accessConfigs?: outputs.ElastigroupGcpNetworkInterfaceAccessConfig[];
    aliasIpRanges?: outputs.ElastigroupGcpNetworkInterfaceAliasIpRange[];
    network: string;
}

export interface ElastigroupGcpNetworkInterfaceAccessConfig {
    name?: string;
    type?: string;
}

export interface ElastigroupGcpNetworkInterfaceAliasIpRange {
    ipCidrRange: string;
    subnetworkRangeName: string;
}

export interface ElastigroupGcpRevertToPreemptible {
    performAt: string;
}

export interface ElastigroupGcpScalingDownPolicy {
    actionType?: string;
    adjustment?: number;
    cooldown: number;
    dimensions?: outputs.ElastigroupGcpScalingDownPolicyDimension[];
    evaluationPeriods: number;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit: string;
}

export interface ElastigroupGcpScalingDownPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupGcpScalingUpPolicy {
    actionType?: string;
    adjustment?: number;
    cooldown: number;
    dimensions?: outputs.ElastigroupGcpScalingUpPolicyDimension[];
    evaluationPeriods: number;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit: string;
}

export interface ElastigroupGcpScalingUpPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupGcpScheduledTask {
    cronExpression?: string;
    isEnabled?: boolean;
    maxCapacity?: string;
    minCapacity?: string;
    targetCapacity?: string;
    taskType: string;
}

export interface ElastigroupGcpSubnet {
    region: string;
    subnetNames: string[];
}

export interface ElastigroupGkeBackendService {
    locationType?: string;
    namedPorts?: outputs.ElastigroupGkeBackendServiceNamedPort[];
    scheme?: string;
    serviceName: string;
}

export interface ElastigroupGkeBackendServiceNamedPort {
    name: string;
    ports: string[];
}

export interface ElastigroupGkeDisk {
    autoDelete?: boolean;
    boot?: boolean;
    deviceName?: string;
    initializeParams?: outputs.ElastigroupGkeDiskInitializeParam[];
    interface?: string;
    mode?: string;
    source?: string;
    type?: string;
}

export interface ElastigroupGkeDiskInitializeParam {
    diskSizeGb?: string;
    diskType?: string;
    sourceImage: string;
}

export interface ElastigroupGkeGpus {
    count: number;
    type: string;
}

export interface ElastigroupGkeInstanceTypesCustom {
    memoryGib: number;
    vcpu: number;
}

export interface ElastigroupGkeIntegrationDockerSwarm {
    masterHost: string;
    masterPort: number;
}

export interface ElastigroupGkeIntegrationGke {
    autoUpdate?: boolean;
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.ElastigroupGkeIntegrationGkeAutoscaleDown;
    autoscaleHeadroom?: outputs.ElastigroupGkeIntegrationGkeAutoscaleHeadroom;
    autoscaleIsAutoConfig?: boolean;
    autoscaleIsEnabled?: boolean;
    autoscaleLabels?: outputs.ElastigroupGkeIntegrationGkeAutoscaleLabel[];
    clusterId?: string;
    location?: string;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleDown {
    evaluationPeriods?: number;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleLabel {
    key: string;
    value: string;
}

export interface ElastigroupGkeLabel {
    key: string;
    value: string;
}

export interface ElastigroupGkeMetadata {
    key: string;
    value: string;
}

export interface ElastigroupGkeNetworkInterface {
    accessConfigs?: outputs.ElastigroupGkeNetworkInterfaceAccessConfig[];
    aliasIpRanges?: outputs.ElastigroupGkeNetworkInterfaceAliasIpRange[];
    network: string;
}

export interface ElastigroupGkeNetworkInterfaceAccessConfig {
    name?: string;
    type?: string;
}

export interface ElastigroupGkeNetworkInterfaceAliasIpRange {
    ipCidrRange: string;
    subnetworkRangeName: string;
}

export interface ElastigroupGkeRevertToPreemptible {
    performAt: string;
}

export interface ElastigroupGkeScalingDownPolicy {
    actionType?: string;
    adjustment?: number;
    cooldown: number;
    dimensions?: outputs.ElastigroupGkeScalingDownPolicyDimension[];
    evaluationPeriods: number;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit: string;
}

export interface ElastigroupGkeScalingDownPolicyDimension {
    name: string;
    value?: string;
}

export interface ElastigroupGkeScalingUpPolicy {
    actionType?: string;
    adjustment?: number;
    cooldown: number;
    dimensions?: outputs.ElastigroupGkeScalingUpPolicyDimension[];
    evaluationPeriods: number;
    metricName: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    source: string;
    statistic: string;
    threshold: number;
    unit: string;
}

export interface ElastigroupGkeScalingUpPolicyDimension {
    name: string;
    value?: string;
}

export interface HealthCheckCheck {
    endPoint?: string;
    endpoint?: string;
    healthy: number;
    interval: number;
    port: number;
    protocol: string;
    timeOut?: number;
    timeout?: number;
    unhealthy: number;
}

export interface ManagedInstanceAwsBlockDeviceMapping {
    deviceName: string;
    ebs?: outputs.ManagedInstanceAwsBlockDeviceMappingEbs;
}

export interface ManagedInstanceAwsBlockDeviceMappingEbs {
    deleteOnTermination: boolean;
    encrypted?: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface ManagedInstanceAwsDelete {
    amiBackupShouldDeleteImages?: boolean;
    deallocationConfigShouldDeleteImages?: boolean;
    shouldDeleteNetworkInterfaces?: boolean;
    shouldDeleteSnapshots?: boolean;
    shouldDeleteVolumes?: boolean;
    shouldTerminateInstance?: boolean;
}

export interface ManagedInstanceAwsIntegrationRoute53 {
    domains: outputs.ManagedInstanceAwsIntegrationRoute53Domain[];
}

export interface ManagedInstanceAwsIntegrationRoute53Domain {
    hostedZoneId: string;
    recordSetType?: string;
    recordSets: outputs.ManagedInstanceAwsIntegrationRoute53DomainRecordSet[];
    spotinstAcctId?: string;
}

export interface ManagedInstanceAwsIntegrationRoute53DomainRecordSet {
    name: string;
    usePublicDns?: boolean;
    usePublicIp?: boolean;
}

export interface ManagedInstanceAwsLoadBalancer {
    arn?: string;
    name?: string;
    type: string;
}

export interface ManagedInstanceAwsManagedInstanceAction {
    type: string;
}

export interface ManagedInstanceAwsMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
    instanceMetadataTags?: string;
}

export interface ManagedInstanceAwsNetworkInterface {
    associateIpv6Address?: boolean;
    associatePublicIpAddress?: boolean;
    deviceIndex: string;
}

export interface ManagedInstanceAwsResourceTagSpecification {
    shouldTagAmis?: boolean;
    shouldTagEnis?: boolean;
    shouldTagSnapshots?: boolean;
    shouldTagVolumes?: boolean;
}

export interface ManagedInstanceAwsRevertToSpot {
    performAt: string;
}

export interface ManagedInstanceAwsScheduledTask {
    cronExpression?: string;
    frequency?: string;
    isEnabled?: boolean;
    startTime?: string;
    taskType: string;
}

export interface ManagedInstanceAwsTag {
    key?: string;
    value?: string;
}

export interface MrscalerAwsApplication {
    args?: string[];
    name: string;
    version?: string;
}

export interface MrscalerAwsBootstrapActionsFile {
    bucket: string;
    key: string;
}

export interface MrscalerAwsConfigurationsFile {
    bucket: string;
    key: string;
}

export interface MrscalerAwsCoreEbsBlockDevice {
    iops?: number;
    sizeInGb: number;
    volumeType: string;
    volumesPerInstance?: number;
}

export interface MrscalerAwsCoreScalingDownPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown: number;
    dimensions?: {[key: string]: string};
    evaluationPeriods: number;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    statistic: string;
    target?: string;
    threshold: number;
    unit: string;
}

export interface MrscalerAwsCoreScalingUpPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown: number;
    dimensions?: {[key: string]: string};
    evaluationPeriods: number;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    statistic: string;
    target?: string;
    threshold: number;
    unit: string;
}

export interface MrscalerAwsInstanceWeight {
    instanceType: string;
    weightedCapacity: number;
}

export interface MrscalerAwsMasterEbsBlockDevice {
    iops?: number;
    sizeInGb: number;
    volumeType: string;
    volumesPerInstance?: number;
}

export interface MrscalerAwsProvisioningTimeout {
    timeout: number;
    timeoutAction: string;
}

export interface MrscalerAwsScheduledTask {
    cron: string;
    desiredCapacity?: string;
    instanceGroupType: string;
    isEnabled?: boolean;
    maxCapacity?: string;
    minCapacity?: string;
    taskType: string;
}

export interface MrscalerAwsStepsFile {
    bucket: string;
    key: string;
}

export interface MrscalerAwsTag {
    key: string;
    value: string;
}

export interface MrscalerAwsTaskEbsBlockDevice {
    iops?: number;
    sizeInGb: number;
    volumeType: string;
    volumesPerInstance?: number;
}

export interface MrscalerAwsTaskScalingDownPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown: number;
    dimensions?: {[key: string]: string};
    evaluationPeriods: number;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    statistic: string;
    target?: string;
    threshold: number;
    unit: string;
}

export interface MrscalerAwsTaskScalingUpPolicy {
    actionType?: string;
    adjustment?: string;
    cooldown: number;
    dimensions?: {[key: string]: string};
    evaluationPeriods: number;
    maxTargetCapacity?: string;
    maximum?: string;
    metricName: string;
    minTargetCapacity?: string;
    minimum?: string;
    namespace: string;
    operator: string;
    period: number;
    policyName: string;
    statistic: string;
    target?: string;
    threshold: number;
    unit: string;
}

export interface MrscalerAwsTerminationPolicy {
    statements: outputs.MrscalerAwsTerminationPolicyStatement[];
}

export interface MrscalerAwsTerminationPolicyStatement {
    evaluationPeriods?: number;
    metricName: string;
    namespace: string;
    operator?: string;
    period?: number;
    statistic?: string;
    threshold: number;
    unit?: string;
}

export interface OceanAksNpAutoscaler {
    autoscaleDown?: outputs.OceanAksNpAutoscalerAutoscaleDown;
    autoscaleHeadroom?: outputs.OceanAksNpAutoscalerAutoscaleHeadroom;
    autoscaleIsEnabled?: boolean;
    resourceLimits?: outputs.OceanAksNpAutoscalerResourceLimits;
}

export interface OceanAksNpAutoscalerAutoscaleDown {
    maxScaleDownPercentage?: number;
}

export interface OceanAksNpAutoscalerAutoscaleHeadroom {
    automatic?: outputs.OceanAksNpAutoscalerAutoscaleHeadroomAutomatic;
}

export interface OceanAksNpAutoscalerAutoscaleHeadroomAutomatic {
    isEnabled?: boolean;
    percentage?: number;
}

export interface OceanAksNpAutoscalerResourceLimits {
    maxMemoryGib?: number;
    maxVcpu?: number;
}

export interface OceanAksNpFilters {
    acceleratedNetworking?: string;
    architectures?: string[];
    diskPerformance?: string;
    excludeSeries?: string[];
    gpuTypes?: string[];
    maxGpu?: number;
    maxMemoryGib?: number;
    maxVcpu?: number;
    minDisk?: number;
    minGpu?: number;
    minMemoryGib?: number;
    minNics?: number;
    minVcpu?: number;
    series?: string[];
    vmTypes?: string[];
}

export interface OceanAksNpHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface OceanAksNpHealth {
    gracePeriod?: number;
}

export interface OceanAksNpLinuxOsConfig {
    sysctls?: outputs.OceanAksNpLinuxOsConfigSysctl[];
}

export interface OceanAksNpLinuxOsConfigSysctl {
    vmMaxMapCount?: number;
}

export interface OceanAksNpScheduling {
    shutdownHours?: outputs.OceanAksNpSchedulingShutdownHours;
    tasks?: outputs.OceanAksNpSchedulingTask[];
}

export interface OceanAksNpSchedulingShutdownHours {
    isEnabled?: boolean;
    timeWindows?: string[];
}

export interface OceanAksNpSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    parameters?: outputs.OceanAksNpSchedulingTaskParameters;
    taskType: string;
}

export interface OceanAksNpSchedulingTaskParameters {
    parametersClusterRoll?: outputs.OceanAksNpSchedulingTaskParametersParametersClusterRoll;
}

export interface OceanAksNpSchedulingTaskParametersParametersClusterRoll {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    respectPdb?: boolean;
    respectRestrictScaleDown?: boolean;
    vngIds?: string[];
}

export interface OceanAksNpTaint {
    effect: string;
    key: string;
    value: string;
}

export interface OceanAksNpUpdatePolicy {
    conditionedRoll?: boolean;
    rollConfig?: outputs.OceanAksNpUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanAksNpUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    nodeNames?: string[];
    nodePoolNames?: string[];
    respectPdb?: boolean;
    respectRestrictScaleDown?: boolean;
    vngIds?: string[];
}

export interface OceanAksNpVirtualNodeGroupFilters {
    acceleratedNetworking?: string;
    architectures?: string[];
    diskPerformance?: string;
    excludeSeries?: string[];
    gpuTypes?: string[];
    maxGpu?: number;
    maxMemoryGib?: number;
    maxVcpu?: number;
    minDisk?: number;
    minGpu?: number;
    minMemoryGib?: number;
    minNics?: number;
    minVcpu?: number;
    series?: string[];
    vmTypes?: string[];
}

export interface OceanAksNpVirtualNodeGroupHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface OceanAksNpVirtualNodeGroupLinuxOsConfig {
    sysctls?: outputs.OceanAksNpVirtualNodeGroupLinuxOsConfigSysctl[];
}

export interface OceanAksNpVirtualNodeGroupLinuxOsConfigSysctl {
    vmMaxMapCount?: number;
}

export interface OceanAksNpVirtualNodeGroupTaint {
    effect: string;
    key: string;
    value: string;
}

export interface OceanAksNpVirtualNodeGroupUpdatePolicy {
    conditionedRoll?: boolean;
    rollConfig?: outputs.OceanAksNpVirtualNodeGroupUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanAksNpVirtualNodeGroupUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    nodeNames?: string[];
    nodePoolNames?: string[];
    respectPdb?: boolean;
    respectRestrictScaleDown?: boolean;
    vngIds?: string[];
}

export interface OceanAwsAttachLoadBalancer {
    arn?: string;
    name?: string;
    type: string;
}

export interface OceanAwsAutoscaler {
    autoHeadroomPercentage?: number;
    autoscaleCooldown?: number;
    autoscaleDown?: outputs.OceanAwsAutoscalerAutoscaleDown;
    autoscaleHeadroom?: outputs.OceanAwsAutoscalerAutoscaleHeadroom;
    autoscaleIsAutoConfig?: boolean;
    autoscaleIsEnabled?: boolean;
    enableAutomaticAndManualHeadroom?: boolean;
    extendedResourceDefinitions?: string[];
    resourceLimits?: outputs.OceanAwsAutoscalerResourceLimits;
}

export interface OceanAwsAutoscalerAutoscaleDown {
    evaluationPeriods?: number;
    isAggressiveScaleDownEnabled?: boolean;
    maxScaleDownPercentage?: number;
}

export interface OceanAwsAutoscalerAutoscaleHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface OceanAwsAutoscalerResourceLimits {
    maxMemoryGib?: number;
    maxVcpu?: number;
}

export interface OceanAwsBlockDeviceMapping {
    deviceName?: string;
    ebs?: outputs.OceanAwsBlockDeviceMappingEbs;
}

export interface OceanAwsBlockDeviceMappingEbs {
    deleteOnTermination: boolean;
    dynamicIops?: outputs.OceanAwsBlockDeviceMappingEbsDynamicIops;
    dynamicVolumeSize?: outputs.OceanAwsBlockDeviceMappingEbsDynamicVolumeSize;
    encrypted: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface OceanAwsBlockDeviceMappingEbsDynamicIops {
    baseSize: number;
    resource: string;
    sizePerResourceUnit: number;
}

export interface OceanAwsBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: number;
    resource: string;
    sizePerResourceUnit: number;
}

export interface OceanAwsClusterOrientation {
    availabilityVsCost?: string;
}

export interface OceanAwsDetachLoadBalancer {
    arn?: string;
    name?: string;
    type: string;
}

export interface OceanAwsFilters {
    architectures?: string[];
    categories?: string[];
    diskTypes?: string[];
    excludeFamilies?: string[];
    excludeMetal?: boolean;
    hypervisors?: string[];
    includeFamilies?: string[];
    isEnaSupported?: string;
    maxGpu?: number;
    maxMemoryGib?: number;
    maxNetworkPerformance?: number;
    maxVcpu?: number;
    minEnis?: number;
    minGpu?: number;
    minMemoryGib?: number;
    minNetworkPerformance?: number;
    minVcpu?: number;
    rootDeviceTypes?: string[];
    virtualizationTypes?: string[];
}

export interface OceanAwsInstanceMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
}

export interface OceanAwsLaunchSpecAutoscaleDown {
    maxScaleDownPercentage?: number;
}

export interface OceanAwsLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanAwsLaunchSpecAutoscaleHeadroomsAutomatic {
    autoHeadroomPercentage?: number;
}

export interface OceanAwsLaunchSpecBlockDeviceMapping {
    deviceName?: string;
    ebs?: outputs.OceanAwsLaunchSpecBlockDeviceMappingEbs;
    noDevice?: string;
    virtualName?: string;
}

export interface OceanAwsLaunchSpecBlockDeviceMappingEbs {
    deleteOnTermination: boolean;
    dynamicVolumeSize?: outputs.OceanAwsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
    encrypted: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface OceanAwsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: number;
    resource: string;
    sizePerResourceUnit: number;
}

export interface OceanAwsLaunchSpecCreateOptions {
    initialNodes?: number;
}

export interface OceanAwsLaunchSpecDeleteOptions {
    deleteNodes?: boolean;
    forceDelete: boolean;
}

export interface OceanAwsLaunchSpecElasticIpPool {
    tagSelector?: outputs.OceanAwsLaunchSpecElasticIpPoolTagSelector;
}

export interface OceanAwsLaunchSpecElasticIpPoolTagSelector {
    tagKey: string;
    tagValue?: string;
}

export interface OceanAwsLaunchSpecEphemeralStorage {
    ephemeralStorageDeviceName?: string;
}

export interface OceanAwsLaunchSpecImage {
    imageId?: string;
}

export interface OceanAwsLaunchSpecInstanceMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
}

export interface OceanAwsLaunchSpecInstanceTypesFilters {
    categories?: string[];
    diskTypes?: string[];
    excludeFamilies?: string[];
    excludeMetal?: boolean;
    hypervisors?: string[];
    includeFamilies?: string[];
    isEnaSupported?: string;
    maxGpu?: number;
    maxMemoryGib?: number;
    maxNetworkPerformance?: number;
    maxVcpu?: number;
    minEnis?: number;
    minGpu?: number;
    minMemoryGib?: number;
    minNetworkPerformance?: number;
    minVcpu?: number;
    rootDeviceTypes?: string[];
    virtualizationTypes?: string[];
}

export interface OceanAwsLaunchSpecLabel {
    key: string;
    value: string;
}

export interface OceanAwsLaunchSpecResourceLimit {
    maxInstanceCount?: number;
    minInstanceCount?: number;
}

export interface OceanAwsLaunchSpecSchedulingShutdownHours {
    isEnabled?: boolean;
    timeWindows: string[];
}

export interface OceanAwsLaunchSpecSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    taskHeadrooms?: outputs.OceanAwsLaunchSpecSchedulingTaskTaskHeadroom[];
    taskType: string;
}

export interface OceanAwsLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanAwsLaunchSpecStrategy {
    drainingTimeout?: number;
    spotPercentage?: number;
}

export interface OceanAwsLaunchSpecTag {
    key: string;
    value: string;
}

export interface OceanAwsLaunchSpecTaint {
    effect: string;
    key: string;
    value: string;
}

export interface OceanAwsLaunchSpecUpdatePolicy {
    rollConfig?: outputs.OceanAwsLaunchSpecUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanAwsLaunchSpecUpdatePolicyRollConfig {
    batchSizePercentage: number;
}

export interface OceanAwsLoadBalancer {
    arn?: string;
    name?: string;
    type?: string;
}

export interface OceanAwsLogging {
    export?: outputs.OceanAwsLoggingExport;
}

export interface OceanAwsLoggingExport {
    s3s?: outputs.OceanAwsLoggingExportS3[];
}

export interface OceanAwsLoggingExportS3 {
    id: string;
}

export interface OceanAwsResourceTagSpecification {
    shouldTagVolumes?: boolean;
}

export interface OceanAwsScheduledTask {
    shutdownHours?: outputs.OceanAwsScheduledTaskShutdownHours;
    tasks?: outputs.OceanAwsScheduledTaskTask[];
}

export interface OceanAwsScheduledTaskShutdownHours {
    isEnabled?: boolean;
    timeWindows: string[];
}

export interface OceanAwsScheduledTaskTask {
    cronExpression: string;
    isEnabled: boolean;
    parameters?: outputs.OceanAwsScheduledTaskTaskParameters;
    taskType: string;
}

export interface OceanAwsScheduledTaskTaskParameters {
    amiAutoUpdate?: outputs.OceanAwsScheduledTaskTaskParametersAmiAutoUpdate;
    parametersClusterRoll?: outputs.OceanAwsScheduledTaskTaskParametersParametersClusterRoll;
}

export interface OceanAwsScheduledTaskTaskParametersAmiAutoUpdate {
    amiAutoUpdateClusterRoll?: outputs.OceanAwsScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll;
    applyRoll?: boolean;
    minorVersion?: boolean;
    patch?: boolean;
}

export interface OceanAwsScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    respectPdb?: boolean;
}

export interface OceanAwsScheduledTaskTaskParametersParametersClusterRoll {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    respectPdb?: boolean;
}

export interface OceanAwsTag {
    key: string;
    value: string;
}

export interface OceanAwsUpdatePolicy {
    autoApplyTags?: boolean;
    conditionedRoll?: boolean;
    conditionedRollParams?: string[];
    rollConfig?: outputs.OceanAwsUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanAwsUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: number;
    batchSizePercentage: number;
    launchSpecIds?: string[];
    respectPdb?: boolean;
}

export interface OceanEcsAutoscaler {
    autoHeadroomPercentage?: number;
    cooldown?: number;
    down?: outputs.OceanEcsAutoscalerDown;
    enableAutomaticAndManualHeadroom?: boolean;
    headroom?: outputs.OceanEcsAutoscalerHeadroom;
    isAutoConfig?: boolean;
    isEnabled?: boolean;
    resourceLimits?: outputs.OceanEcsAutoscalerResourceLimits;
    shouldScaleDownNonServiceTasks?: boolean;
}

export interface OceanEcsAutoscalerDown {
    maxScaleDownPercentage?: number;
}

export interface OceanEcsAutoscalerHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface OceanEcsAutoscalerResourceLimits {
    maxMemoryGib?: number;
    maxVcpu?: number;
}

export interface OceanEcsBlockDeviceMapping {
    deviceName: string;
    ebs?: outputs.OceanEcsBlockDeviceMappingEbs;
    noDevice?: string;
    virtualName?: string;
}

export interface OceanEcsBlockDeviceMappingEbs {
    deleteOnTermination: boolean;
    dynamicVolumeSize?: outputs.OceanEcsBlockDeviceMappingEbsDynamicVolumeSize;
    encrypted: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface OceanEcsBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: number;
    resource: string;
    sizePerResourceUnit: number;
}

export interface OceanEcsClusterOrientation {
    availabilityVsCost?: string;
}

export interface OceanEcsFilters {
    architectures?: string[];
    categories?: string[];
    diskTypes?: string[];
    excludeFamilies?: string[];
    excludeMetal?: boolean;
    hypervisors?: string[];
    includeFamilies?: string[];
    isEnaSupported?: string;
    maxGpu?: number;
    maxMemoryGib?: number;
    maxNetworkPerformance?: number;
    maxVcpu?: number;
    minEnis?: number;
    minGpu?: number;
    minMemoryGib?: number;
    minNetworkPerformance?: number;
    minVcpu?: number;
    rootDeviceTypes?: string[];
    virtualizationTypes?: string[];
}

export interface OceanEcsInstanceMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
}

export interface OceanEcsLaunchSpecAttribute {
    key: string;
    value: string;
}

export interface OceanEcsLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanEcsLaunchSpecBlockDeviceMapping {
    deviceName: string;
    ebs?: outputs.OceanEcsLaunchSpecBlockDeviceMappingEbs;
    noDevice?: string;
    virtualName?: string;
}

export interface OceanEcsLaunchSpecBlockDeviceMappingEbs {
    deleteOnTermination: boolean;
    dynamicVolumeSize?: outputs.OceanEcsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize;
    encrypted: boolean;
    iops?: number;
    kmsKeyId?: string;
    snapshotId?: string;
    throughput?: number;
    volumeSize?: number;
    volumeType: string;
}

export interface OceanEcsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: number;
    resource: string;
    sizePerResourceUnit: number;
}

export interface OceanEcsLaunchSpecImage {
    imageId?: string;
}

export interface OceanEcsLaunchSpecInstanceMetadataOptions {
    httpPutResponseHopLimit?: number;
    httpTokens: string;
}

export interface OceanEcsLaunchSpecSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    taskHeadrooms?: outputs.OceanEcsLaunchSpecSchedulingTaskTaskHeadroom[];
    taskType: string;
}

export interface OceanEcsLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanEcsLaunchSpecStrategy {
    spotPercentage?: number;
}

export interface OceanEcsLaunchSpecTag {
    key: string;
    value: string;
}

export interface OceanEcsLogging {
    export?: outputs.OceanEcsLoggingExport;
}

export interface OceanEcsLoggingExport {
    s3s?: outputs.OceanEcsLoggingExportS3[];
}

export interface OceanEcsLoggingExportS3 {
    id: string;
}

export interface OceanEcsOptimizeImages {
    performAt: string;
    shouldOptimizeEcsAmi: boolean;
    timeWindows?: string[];
}

export interface OceanEcsScheduledTask {
    shutdownHours?: outputs.OceanEcsScheduledTaskShutdownHours;
    tasks?: outputs.OceanEcsScheduledTaskTask[];
}

export interface OceanEcsScheduledTaskShutdownHours {
    isEnabled?: boolean;
    timeWindows: string[];
}

export interface OceanEcsScheduledTaskTask {
    cronExpression: string;
    isEnabled: boolean;
    taskType: string;
}

export interface OceanEcsTag {
    key: string;
    value: string;
}

export interface OceanEcsUpdatePolicy {
    autoApplyTags?: boolean;
    conditionedRoll?: boolean;
    rollConfig?: outputs.OceanEcsUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanEcsUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: number;
    batchSizePercentage: number;
}

export interface OceanGkeImportAutoscaler {
    autoHeadroomPercentage?: number;
    cooldown?: number;
    down?: outputs.OceanGkeImportAutoscalerDown;
    enableAutomaticAndManualHeadroom?: boolean;
    headroom?: outputs.OceanGkeImportAutoscalerHeadroom;
    isAutoConfig?: boolean;
    isEnabled?: boolean;
    resourceLimits?: outputs.OceanGkeImportAutoscalerResourceLimits;
}

export interface OceanGkeImportAutoscalerDown {
    evaluationPeriods?: number;
    maxScaleDownPercentage?: number;
}

export interface OceanGkeImportAutoscalerHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits?: number;
}

export interface OceanGkeImportAutoscalerResourceLimits {
    maxMemoryGib?: number;
    maxVcpu?: number;
}

export interface OceanGkeImportBackendService {
    locationType?: string;
    namedPorts?: outputs.OceanGkeImportBackendServiceNamedPort[];
    scheme?: string;
    serviceName: string;
}

export interface OceanGkeImportBackendServiceNamedPort {
    name: string;
    ports: string[];
}

export interface OceanGkeImportScheduledTask {
    shutdownHours?: outputs.OceanGkeImportScheduledTaskShutdownHours;
    tasks?: outputs.OceanGkeImportScheduledTaskTask[];
}

export interface OceanGkeImportScheduledTaskShutdownHours {
    isEnabled?: boolean;
    timeWindows: string[];
}

export interface OceanGkeImportScheduledTaskTask {
    cronExpression: string;
    isEnabled: boolean;
    taskParameters?: outputs.OceanGkeImportScheduledTaskTaskTaskParameters;
    taskType: string;
}

export interface OceanGkeImportScheduledTaskTaskTaskParameters {
    clusterRoll?: outputs.OceanGkeImportScheduledTaskTaskTaskParametersClusterRoll;
}

export interface OceanGkeImportScheduledTaskTaskTaskParametersClusterRoll {
    batchMinHealthyPercentage?: number;
    batchSizePercentage?: number;
    comment?: string;
    respectPdb?: boolean;
}

export interface OceanGkeImportShieldedInstanceConfig {
    enableIntegrityMonitoring: boolean;
    enableSecureBoot: boolean;
}

export interface OceanGkeImportStrategy {
    drainingTimeout?: number;
    preemptiblePercentage?: number;
    provisioningModel?: string;
}

export interface OceanGkeImportUpdatePolicy {
    conditionedRoll?: boolean;
    rollConfig?: outputs.OceanGkeImportUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanGkeImportUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: number;
    batchSizePercentage: number;
    launchSpecIds?: string[];
    respectPdb?: boolean;
}

export interface OceanGkeLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanGkeLaunchSpecAutoscaleHeadroomsAutomatic {
    autoHeadroomPercentage?: number;
}

export interface OceanGkeLaunchSpecCreateOptions {
    initialNodes?: number;
}

export interface OceanGkeLaunchSpecLabel {
    key: string;
    value: string;
}

export interface OceanGkeLaunchSpecMetadata {
    key: string;
    value: string;
}

export interface OceanGkeLaunchSpecNetworkInterface {
    accessConfigs?: outputs.OceanGkeLaunchSpecNetworkInterfaceAccessConfig[];
    aliasIpRanges?: outputs.OceanGkeLaunchSpecNetworkInterfaceAliasIpRange[];
    network: string;
    projectId?: string;
}

export interface OceanGkeLaunchSpecNetworkInterfaceAccessConfig {
    name?: string;
    type?: string;
}

export interface OceanGkeLaunchSpecNetworkInterfaceAliasIpRange {
    ipCidrRange: string;
    subnetworkRangeName: string;
}

export interface OceanGkeLaunchSpecResourceLimits {
    maxInstanceCount?: number;
    minInstanceCount?: number;
}

export interface OceanGkeLaunchSpecSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    taskHeadrooms?: outputs.OceanGkeLaunchSpecSchedulingTaskTaskHeadroom[];
    taskType: string;
}

export interface OceanGkeLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: number;
    gpuPerUnit?: number;
    memoryPerUnit?: number;
    numOfUnits: number;
}

export interface OceanGkeLaunchSpecShieldedInstanceConfig {
    enableIntegrityMonitoring: boolean;
    enableSecureBoot: boolean;
}

export interface OceanGkeLaunchSpecStorage {
    localSsdCount: number;
}

export interface OceanGkeLaunchSpecStrategy {
    preemptiblePercentage?: number;
}

export interface OceanGkeLaunchSpecTaint {
    effect: string;
    key: string;
    value: string;
}

export interface OceanGkeLaunchSpecUpdatePolicy {
    rollConfig?: outputs.OceanGkeLaunchSpecUpdatePolicyRollConfig;
    shouldRoll: boolean;
}

export interface OceanGkeLaunchSpecUpdatePolicyRollConfig {
    batchSizePercentage: number;
}

export interface OceanRightSizingRuleAttachWorkload {
    namespaces: outputs.OceanRightSizingRuleAttachWorkloadNamespace[];
}

export interface OceanRightSizingRuleAttachWorkloadNamespace {
    labels?: outputs.OceanRightSizingRuleAttachWorkloadNamespaceLabel[];
    namespaceName: string;
    workloads?: outputs.OceanRightSizingRuleAttachWorkloadNamespaceWorkload[];
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceLabel {
    key: string;
    value: string;
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceWorkload {
    regexName?: string;
    workloadName?: string;
    workloadType: string;
}

export interface OceanRightSizingRuleDetachWorkload {
    namespaces: outputs.OceanRightSizingRuleDetachWorkloadNamespace[];
}

export interface OceanRightSizingRuleDetachWorkloadNamespace {
    labels?: outputs.OceanRightSizingRuleDetachWorkloadNamespaceLabel[];
    namespaceName: string;
    workloads?: outputs.OceanRightSizingRuleDetachWorkloadNamespaceWorkload[];
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceLabel {
    key: string;
    value: string;
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceWorkload {
    regexName?: string;
    workloadName?: string;
    workloadType: string;
}

export interface OceanRightSizingRuleRecommendationApplicationBoundary {
    cpuMax?: number;
    cpuMin?: number;
    memoryMax?: number;
    memoryMin?: number;
}

export interface OceanRightSizingRuleRecommendationApplicationInterval {
    monthlyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase[];
    repetitionBasis: string;
    weeklyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase[];
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase {
    intervalMonths: number[];
    weekOfTheMonths: string[];
    weeklyRepetitionBases?: outputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase[];
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase {
    intervalDays: string[];
    intervalHoursEndTime: string;
    intervalHoursStartTime: string;
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase {
    intervalDays: string[];
    intervalHoursEndTime: string;
    intervalHoursStartTime: string;
}

export interface OceanRightSizingRuleRecommendationApplicationMinThreshold {
    cpuPercentage?: number;
    memoryPercentage?: number;
}

export interface OceanRightSizingRuleRecommendationApplicationOverheadValue {
    cpuPercentage?: number;
    memoryPercentage?: number;
}

export interface OceanSparkCompute {
    createVngs: boolean;
    useTaints: boolean;
}

export interface OceanSparkIngress {
    controller?: outputs.OceanSparkIngressController;
    customEndpoint?: outputs.OceanSparkIngressCustomEndpoint;
    loadBalancer?: outputs.OceanSparkIngressLoadBalancer;
    privateLink?: outputs.OceanSparkIngressPrivateLink;
    serviceAnnotations: {[key: string]: string};
}

export interface OceanSparkIngressController {
    managed?: boolean;
}

export interface OceanSparkIngressCustomEndpoint {
    address?: string;
    enabled?: boolean;
}

export interface OceanSparkIngressLoadBalancer {
    managed?: boolean;
    serviceAnnotations?: {[key: string]: string};
    targetGroupArn?: string;
}

export interface OceanSparkIngressPrivateLink {
    enabled?: boolean;
    vpcEndpointService?: string;
}

export interface OceanSparkLogCollection {
    collectAppLogs: boolean;
}

export interface OceanSparkSpark {
    additionalAppNamespaces: string[];
}

export interface OceanSparkWebhook {
    hostNetworkPorts: number[];
    useHostNetwork: boolean;
}

export interface OceancdRolloutSpecFailurePolicy {
    action: string;
}

export interface OceancdRolloutSpecSpotDeployment {
    spotDeploymentsClusterId?: string;
    spotDeploymentsName?: string;
    spotDeploymentsNamespace?: string;
}

export interface OceancdRolloutSpecStrategy {
    args?: outputs.OceancdRolloutSpecStrategyArg[];
    strategyName: string;
}

export interface OceancdRolloutSpecStrategyArg {
    argName: string;
    argValue?: string;
    valueFrom?: outputs.OceancdRolloutSpecStrategyArgValueFrom;
}

export interface OceancdRolloutSpecStrategyArgValueFrom {
    fieldRef: outputs.OceancdRolloutSpecStrategyArgValueFromFieldRef;
}

export interface OceancdRolloutSpecStrategyArgValueFromFieldRef {
    fieldPath: string;
}

export interface OceancdRolloutSpecTraffic {
    alb?: outputs.OceancdRolloutSpecTrafficAlb;
    ambassador?: outputs.OceancdRolloutSpecTrafficAmbassador;
    canaryService?: string;
    istio?: outputs.OceancdRolloutSpecTrafficIstio;
    nginx?: outputs.OceancdRolloutSpecTrafficNginx;
    pingPong?: outputs.OceancdRolloutSpecTrafficPingPong;
    smi?: outputs.OceancdRolloutSpecTrafficSmi;
    stableService?: string;
}

export interface OceancdRolloutSpecTrafficAlb {
    albAnnotationPrefix?: string;
    albIngress: string;
    albRootService: string;
    servicePort: number;
    stickinessConfig?: outputs.OceancdRolloutSpecTrafficAlbStickinessConfig;
}

export interface OceancdRolloutSpecTrafficAlbStickinessConfig {
    durationSeconds?: number;
    enabled?: boolean;
}

export interface OceancdRolloutSpecTrafficAmbassador {
    mappings: string[];
}

export interface OceancdRolloutSpecTrafficIstio {
    destinationRule?: outputs.OceancdRolloutSpecTrafficIstioDestinationRule;
    virtualServices: outputs.OceancdRolloutSpecTrafficIstioVirtualService[];
}

export interface OceancdRolloutSpecTrafficIstioDestinationRule {
    canarySubsetName: string;
    destinationRuleName: string;
    stableSubsetName: string;
}

export interface OceancdRolloutSpecTrafficIstioVirtualService {
    tlsRoutes?: outputs.OceancdRolloutSpecTrafficIstioVirtualServiceTlsRoute[];
    virtualServiceName: string;
    virtualServiceRoutes?: string[];
}

export interface OceancdRolloutSpecTrafficIstioVirtualServiceTlsRoute {
    port?: number;
    sniHosts?: string[];
}

export interface OceancdRolloutSpecTrafficNginx {
    additionalIngressAnnotation?: outputs.OceancdRolloutSpecTrafficNginxAdditionalIngressAnnotation;
    nginxAnnotationPrefix?: string;
    stableIngress: string;
}

export interface OceancdRolloutSpecTrafficNginxAdditionalIngressAnnotation {
    canaryByHeader?: string;
    key1?: string;
}

export interface OceancdRolloutSpecTrafficPingPong {
    pingService: string;
    pongService: string;
}

export interface OceancdRolloutSpecTrafficSmi {
    smiRootService?: string;
    trafficSplitName?: string;
}

export interface OceancdStrategyCanary {
    backgroundVerification?: outputs.OceancdStrategyCanaryBackgroundVerification;
    steps: outputs.OceancdStrategyCanaryStep[];
}

export interface OceancdStrategyCanaryBackgroundVerification {
    templateNames: string[];
}

export interface OceancdStrategyCanaryStep {
    pause?: outputs.OceancdStrategyCanaryStepPause;
    setCanaryScale?: outputs.OceancdStrategyCanaryStepSetCanaryScale;
    setHeaderRoute?: outputs.OceancdStrategyCanaryStepSetHeaderRoute;
    setWeight?: number;
    stepName?: string;
    verification?: outputs.OceancdStrategyCanaryStepVerification;
}

export interface OceancdStrategyCanaryStepPause {
    duration?: string;
}

export interface OceancdStrategyCanaryStepSetCanaryScale {
    matchTrafficWeight?: boolean;
    replicas?: number;
    weight?: number;
}

export interface OceancdStrategyCanaryStepSetHeaderRoute {
    headerRouteName: string;
    matches: outputs.OceancdStrategyCanaryStepSetHeaderRouteMatch[];
}

export interface OceancdStrategyCanaryStepSetHeaderRouteMatch {
    headerName: string;
    headerValue: outputs.OceancdStrategyCanaryStepSetHeaderRouteMatchHeaderValue;
}

export interface OceancdStrategyCanaryStepSetHeaderRouteMatchHeaderValue {
    exact?: string;
    prefix?: string;
    regex?: string;
}

export interface OceancdStrategyCanaryStepVerification {
    templateNames: string[];
}

export interface OceancdStrategyRolling {
    steps: outputs.OceancdStrategyRollingStep[];
}

export interface OceancdStrategyRollingStep {
    pause?: outputs.OceancdStrategyRollingStepPause;
    stepsName?: string;
    verification?: outputs.OceancdStrategyRollingStepVerification;
}

export interface OceancdStrategyRollingStepPause {
    duration?: string;
}

export interface OceancdStrategyRollingStepVerification {
    templateNames: string[];
}

export interface OceancdVerificationProviderCloudWatch {
    iamArn: string;
}

export interface OceancdVerificationProviderDatadog {
    address: string;
    apiKey: string;
    appKey: string;
}

export interface OceancdVerificationProviderJenkins {
    apiToken: string;
    baseUrl: string;
    username: string;
}

export interface OceancdVerificationProviderNewRelic {
    accountId: string;
    baseUrlNerdGraph?: string;
    baseUrlRest?: string;
    personalApiKey: string;
    region?: string;
}

export interface OceancdVerificationProviderPrometheus {
    address: string;
}

export interface OceancdVerificationTemplateArg {
    argName: string;
    value?: string;
    valueFrom?: outputs.OceancdVerificationTemplateArgValueFrom;
}

export interface OceancdVerificationTemplateArgValueFrom {
    secretKeyRef?: outputs.OceancdVerificationTemplateArgValueFromSecretKeyRef;
}

export interface OceancdVerificationTemplateArgValueFromSecretKeyRef {
    key: string;
    name: string;
}

export interface OceancdVerificationTemplateMetric {
    baseline?: outputs.OceancdVerificationTemplateMetricBaseline;
    consecutiveErrorLimit?: number;
    count?: number;
    dryRun?: boolean;
    failureCondition?: string;
    failureLimit?: number;
    initialDelay?: string;
    interval?: string;
    metricsName: string;
    providers: outputs.OceancdVerificationTemplateMetricProvider[];
    successCondition?: string;
}

export interface OceancdVerificationTemplateMetricBaseline {
    baselineProviders: outputs.OceancdVerificationTemplateMetricBaselineBaselineProvider[];
    maxRange?: number;
    minRange?: number;
    threshold: string;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProvider {
    datadog?: outputs.OceancdVerificationTemplateMetricBaselineBaselineProviderDatadog;
    newRelic?: outputs.OceancdVerificationTemplateMetricBaselineBaselineProviderNewRelic;
    prometheus?: outputs.OceancdVerificationTemplateMetricBaselineBaselineProviderPrometheus;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderDatadog {
    datadogQuery: string;
    duration?: string;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderNewRelic {
    newRelicQuery: string;
    profile?: string;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderPrometheus {
    prometheusQuery: string;
}

export interface OceancdVerificationTemplateMetricProvider {
    cloudWatch?: outputs.OceancdVerificationTemplateMetricProviderCloudWatch;
    datadog?: outputs.OceancdVerificationTemplateMetricProviderDatadog;
    jenkins?: outputs.OceancdVerificationTemplateMetricProviderJenkins;
    job?: outputs.OceancdVerificationTemplateMetricProviderJob;
    newRelic?: outputs.OceancdVerificationTemplateMetricProviderNewRelic;
    prometheus?: outputs.OceancdVerificationTemplateMetricProviderPrometheus;
    web?: outputs.OceancdVerificationTemplateMetricProviderWeb;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatch {
    duration?: string;
    metricDataQueries: outputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQuery[];
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQuery {
    expression?: string;
    id: string;
    label?: string;
    metricStat?: outputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat;
    period?: number;
    returnData?: boolean;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat {
    metric?: outputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric;
    metricPeriod?: number;
    stat?: string;
    unit?: string;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric {
    dimensions?: outputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension[];
    metricName: string;
    namespace?: string;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension {
    dimensionName: string;
    dimensionValue: string;
}

export interface OceancdVerificationTemplateMetricProviderDatadog {
    datadogQuery?: string;
    duration?: string;
}

export interface OceancdVerificationTemplateMetricProviderJenkins {
    jenkinsInterval: string;
    jenkinsParameters?: outputs.OceancdVerificationTemplateMetricProviderJenkinsJenkinsParameters;
    pipelineName: string;
    timeout: string;
    tlsVerification?: boolean;
}

export interface OceancdVerificationTemplateMetricProviderJenkinsJenkinsParameters {
    parameterKey: string;
    parameterValue: string;
}

export interface OceancdVerificationTemplateMetricProviderJob {
    specs: outputs.OceancdVerificationTemplateMetricProviderJobSpec[];
}

export interface OceancdVerificationTemplateMetricProviderJobSpec {
    backoffLimit?: number;
    jobTemplates: outputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplate[];
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplate {
    templateSpecs: outputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec[];
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec {
    containers: outputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer[];
    restartPolicy: string;
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer {
    commands: string[];
    containerName: string;
    image: string;
}

export interface OceancdVerificationTemplateMetricProviderNewRelic {
    newRelicQuery: string;
    profile?: string;
}

export interface OceancdVerificationTemplateMetricProviderPrometheus {
    prometheusQuery: string;
}

export interface OceancdVerificationTemplateMetricProviderWeb {
    body?: string;
    insecure?: boolean;
    jsonPath?: string;
    method?: string;
    timeoutSeconds?: number;
    url: string;
    webHeaders?: outputs.OceancdVerificationTemplateMetricProviderWebWebHeader[];
}

export interface OceancdVerificationTemplateMetricProviderWebWebHeader {
    webHeaderKey: string;
    webHeaderValue: string;
}

export interface OrganizationPolicyPolicyContent {
    statements: outputs.OrganizationPolicyPolicyContentStatement[];
}

export interface OrganizationPolicyPolicyContentStatement {
    actions: string[];
    effect: string;
    resources: string[];
}

export interface OrganizationProgrammaticUserAccount {
    accountId: string;
    accountRole: string;
}

export interface OrganizationProgrammaticUserPolicy {
    policyAccountIds?: string[];
    policyId: string;
}

export interface OrganizationUserGroupPolicy {
    accountIds: string[];
    policyId: string;
}

export interface OrganizationUserPolicy {
    policyAccountIds: string[];
    policyId: string;
}

export interface StatefulNodeAzureAttachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    lun?: number;
    sizeGb: number;
    storageAccountType: string;
    zone?: string;
}

export interface StatefulNodeAzureBootDiagnostic {
    isEnabled: boolean;
    storageUrl: string;
    type: string;
}

export interface StatefulNodeAzureDataDisk {
    lun: number;
    sizeGb: number;
    type: string;
}

export interface StatefulNodeAzureDelete {
    diskShouldDeallocate: boolean;
    diskTtlInHours?: number;
    networkShouldDeallocate: boolean;
    networkTtlInHours?: number;
    publicIpShouldDeallocate: boolean;
    publicIpTtlInHours?: number;
    shouldDeregisterFromLb?: boolean;
    shouldTerminateVm: boolean;
    snapshotShouldDeallocate: boolean;
    snapshotTtlInHours?: number;
}

export interface StatefulNodeAzureDetachDataDisk {
    dataDiskName: string;
    dataDiskResourceGroupName: string;
    shouldDeallocate: boolean;
    ttlInHours?: number;
}

export interface StatefulNodeAzureExtension {
    apiVersion: string;
    minorVersionAutoUpgrade: boolean;
    name: string;
    protectedSettings: {[key: string]: string};
    publicSettings: {[key: string]: string};
    publisher: string;
    type: string;
}

export interface StatefulNodeAzureHealth {
    autoHealing: boolean;
    gracePeriod: number;
    healthCheckTypes: string[];
    unhealthyDuration: number;
}

export interface StatefulNodeAzureImage {
    customImages?: outputs.StatefulNodeAzureImageCustomImage[];
    galleries?: outputs.StatefulNodeAzureImageGallery[];
    marketplaceImages?: outputs.StatefulNodeAzureImageMarketplaceImage[];
}

export interface StatefulNodeAzureImageCustomImage {
    customImageResourceGroupName: string;
    name: string;
}

export interface StatefulNodeAzureImageGallery {
    galleryName: string;
    galleryResourceGroupName: string;
    imageName: string;
    spotAccountId?: string;
    versionName: string;
}

export interface StatefulNodeAzureImageMarketplaceImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface StatefulNodeAzureImportVm {
    drainingTimeout?: number;
    originalVmName: string;
    resourceGroupName: string;
    resourcesRetentionTime?: number;
}

export interface StatefulNodeAzureLoadBalancer {
    backendPoolNames: string[];
    name: string;
    resourceGroupName: string;
    sku: string;
    type: string;
}

export interface StatefulNodeAzureLogin {
    password?: string;
    sshPublicKey?: string;
    userName: string;
}

export interface StatefulNodeAzureManagedServiceIdentity {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureNetwork {
    networkInterfaces: outputs.StatefulNodeAzureNetworkNetworkInterface[];
    networkResourceGroupName: string;
    virtualNetworkName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterface {
    additionalIpConfigurations?: outputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration[];
    applicationSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup[];
    assignPublicIp?: boolean;
    enableIpForwarding?: boolean;
    isPrimary: boolean;
    networkSecurityGroups?: outputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup[];
    privateIpAddresses?: string[];
    publicIpSku?: string;
    publicIps?: outputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp[];
    subnetName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration {
    name: string;
    privateIpAddressVersion: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup {
    name?: string;
    networkResourceGroupName?: string;
}

export interface StatefulNodeAzureNetworkNetworkInterfacePublicIp {
    name: string;
    networkResourceGroupName: string;
}

export interface StatefulNodeAzureOsDisk {
    caching?: string;
    sizeGb?: number;
    type: string;
}

export interface StatefulNodeAzureProximityPlacementGroup {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSchedulingTask {
    cronExpression: string;
    isEnabled: boolean;
    type: string;
}

export interface StatefulNodeAzureSecret {
    sourceVaults: outputs.StatefulNodeAzureSecretSourceVault[];
    vaultCertificates: outputs.StatefulNodeAzureSecretVaultCertificate[];
}

export interface StatefulNodeAzureSecretSourceVault {
    name: string;
    resourceGroupName: string;
}

export interface StatefulNodeAzureSecretVaultCertificate {
    certificateStore?: string;
    certificateUrl?: string;
}

export interface StatefulNodeAzureSecurity {
    confidentialOsDiskEncryption?: boolean;
    encryptionAtHost?: boolean;
    secureBootEnabled?: boolean;
    securityType?: string;
    vtpmEnabled?: boolean;
}

export interface StatefulNodeAzureSignal {
    timeout: number;
    type: string;
}

export interface StatefulNodeAzureStrategy {
    availabilityVsCost?: number;
    capacityReservations?: outputs.StatefulNodeAzureStrategyCapacityReservation[];
    drainingTimeout: number;
    fallbackToOnDemand: boolean;
    odWindows?: string[];
    optimizationWindows?: string[];
    preferredLifeCycle: string;
    revertToSpot?: outputs.StatefulNodeAzureStrategyRevertToSpot;
    vmAdmins?: string[];
}

export interface StatefulNodeAzureStrategyCapacityReservation {
    capacityReservationGroups?: outputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup[];
    shouldUtilize: boolean;
    utilizationStrategy: string;
}

export interface StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup {
    crgName: string;
    crgResourceGroupName: string;
    crgShouldPrioritize?: boolean;
}

export interface StatefulNodeAzureStrategyRevertToSpot {
    performAt: string;
}

export interface StatefulNodeAzureTag {
    tagKey: string;
    tagValue?: string;
}

export interface StatefulNodeAzureUpdateState {
    state: string;
}

export interface StatefulNodeAzureVmSizes {
    odSizes: string[];
    preferredSpotSizes?: string[];
    spotSizes: string[];
}

