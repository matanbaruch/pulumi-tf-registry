// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DataIntegrationS3 {
    bucketName: pulumi.Input<string>;
    subdir?: pulumi.Input<string>;
}

export interface ElastigroupAwsBeanstalkDeploymentPreferences {
    automaticRoll?: pulumi.Input<boolean>;
    batchSizePercentage?: pulumi.Input<number>;
    gracePeriod?: pulumi.Input<number>;
    strategies?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsBeanstalkDeploymentPreferencesStrategy>[]>;
}

export interface ElastigroupAwsBeanstalkDeploymentPreferencesStrategy {
    action?: pulumi.Input<string>;
    shouldDrainInstances?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsBeanstalkManagedActions {
    platformUpdate?: pulumi.Input<inputs.ElastigroupAwsBeanstalkManagedActionsPlatformUpdate>;
}

export interface ElastigroupAwsBeanstalkManagedActionsPlatformUpdate {
    performAt?: pulumi.Input<string>;
    timeWindow?: pulumi.Input<string>;
    updateLevel?: pulumi.Input<string>;
}

export interface ElastigroupAwsBeanstalkScheduledTask {
    adjustment?: pulumi.Input<string>;
    adjustmentPercentage?: pulumi.Input<string>;
    batchSizePercentage?: pulumi.Input<string>;
    cronExpression?: pulumi.Input<string>;
    frequency?: pulumi.Input<string>;
    gracePeriod?: pulumi.Input<string>;
    isEnabled?: pulumi.Input<boolean>;
    maxCapacity?: pulumi.Input<string>;
    minCapacity?: pulumi.Input<string>;
    scaleMaxCapacity?: pulumi.Input<string>;
    scaleMinCapacity?: pulumi.Input<string>;
    scaleTargetCapacity?: pulumi.Input<string>;
    startTime?: pulumi.Input<string>;
    targetCapacity?: pulumi.Input<string>;
    taskType: pulumi.Input<string>;
}

export interface ElastigroupAwsCpuOptions {
    threadsPerCore: pulumi.Input<number>;
}

export interface ElastigroupAwsEbsBlockDevice {
    deleteOnTermination?: pulumi.Input<boolean>;
    deviceName: pulumi.Input<string>;
    dynamicIops?: pulumi.Input<inputs.ElastigroupAwsEbsBlockDeviceDynamicIops>;
    dynamicVolumeSize?: pulumi.Input<inputs.ElastigroupAwsEbsBlockDeviceDynamicVolumeSize>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface ElastigroupAwsEbsBlockDeviceDynamicIops {
    baseSize?: pulumi.Input<number>;
    resource?: pulumi.Input<string>;
    sizePerResourceUnit?: pulumi.Input<number>;
}

export interface ElastigroupAwsEbsBlockDeviceDynamicVolumeSize {
    baseSize?: pulumi.Input<number>;
    resource?: pulumi.Input<string>;
    sizePerResourceUnit?: pulumi.Input<number>;
}

export interface ElastigroupAwsEphemeralBlockDevice {
    deviceName: pulumi.Input<string>;
    virtualName: pulumi.Input<string>;
}

export interface ElastigroupAwsImage {
    images: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsImageImage>[]>;
}

export interface ElastigroupAwsImageImage {
    id: pulumi.Input<string>;
}

export interface ElastigroupAwsInstanceTypesWeight {
    instanceType: pulumi.Input<string>;
    weight: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationBeanstalk {
    deploymentPreferences?: pulumi.Input<inputs.ElastigroupAwsIntegrationBeanstalkDeploymentPreferences>;
    environmentId?: pulumi.Input<string>;
    managedActions?: pulumi.Input<inputs.ElastigroupAwsIntegrationBeanstalkManagedActions>;
}

export interface ElastigroupAwsIntegrationBeanstalkDeploymentPreferences {
    automaticRoll?: pulumi.Input<boolean>;
    batchSizePercentage?: pulumi.Input<number>;
    gracePeriod?: pulumi.Input<number>;
    strategy?: pulumi.Input<inputs.ElastigroupAwsIntegrationBeanstalkDeploymentPreferencesStrategy>;
}

export interface ElastigroupAwsIntegrationBeanstalkDeploymentPreferencesStrategy {
    action?: pulumi.Input<string>;
    shouldDrainInstances?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsIntegrationBeanstalkManagedActions {
    platformUpdate?: pulumi.Input<inputs.ElastigroupAwsIntegrationBeanstalkManagedActionsPlatformUpdate>;
}

export interface ElastigroupAwsIntegrationBeanstalkManagedActionsPlatformUpdate {
    performAt?: pulumi.Input<string>;
    timeWindow?: pulumi.Input<string>;
    updateLevel?: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationCodedeploy {
    cleanupOnFailure: pulumi.Input<boolean>;
    deploymentGroups: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationCodedeployDeploymentGroup>[]>;
    terminateInstanceOnFailure: pulumi.Input<boolean>;
}

export interface ElastigroupAwsIntegrationCodedeployDeploymentGroup {
    applicationName: pulumi.Input<string>;
    deploymentGroupName: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationDockerSwarm {
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupAwsIntegrationDockerSwarmAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupAwsIntegrationDockerSwarmAutoscaleHeadroom>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    masterHost: pulumi.Input<string>;
    masterPort: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationDockerSwarmAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationDockerSwarmAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationEcs {
    autoscaleAttributes?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationEcsAutoscaleAttribute>[]>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupAwsIntegrationEcsAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupAwsIntegrationEcsAutoscaleHeadroom>;
    autoscaleIsAutoConfig?: pulumi.Input<boolean>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    autoscaleScaleDownNonServiceTasks?: pulumi.Input<boolean>;
    batch?: pulumi.Input<inputs.ElastigroupAwsIntegrationEcsBatch>;
    clusterName: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleAttribute {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationEcsAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationEcsBatch {
    jobQueueNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupAwsIntegrationGitlab {
    runner?: pulumi.Input<inputs.ElastigroupAwsIntegrationGitlabRunner>;
}

export interface ElastigroupAwsIntegrationGitlabRunner {
    isEnabled?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsIntegrationKubernetes {
    apiServer?: pulumi.Input<string>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupAwsIntegrationKubernetesAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupAwsIntegrationKubernetesAutoscaleHeadroom>;
    autoscaleIsAutoConfig?: pulumi.Input<boolean>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    autoscaleLabels?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationKubernetesAutoscaleLabel>[]>;
    clusterIdentifier?: pulumi.Input<string>;
    integrationMode?: pulumi.Input<string>;
    token?: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationKubernetesAutoscaleLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationMesosphere {
    apiServer: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationNomad {
    aclToken?: pulumi.Input<string>;
    autoscaleConstraints?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationNomadAutoscaleConstraint>[]>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupAwsIntegrationNomadAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupAwsIntegrationNomadAutoscaleHeadroom>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    masterHost: pulumi.Input<string>;
    masterPort: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleConstraint {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationNomadAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupAwsIntegrationRancher {
    accessKey: pulumi.Input<string>;
    masterHost: pulumi.Input<string>;
    secretKey: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationRoute53 {
    domains: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationRoute53Domain>[]>;
}

export interface ElastigroupAwsIntegrationRoute53Domain {
    hostedZoneId: pulumi.Input<string>;
    recordSetType?: pulumi.Input<string>;
    recordSets: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsIntegrationRoute53DomainRecordSet>[]>;
    spotinstAcctId?: pulumi.Input<string>;
}

export interface ElastigroupAwsIntegrationRoute53DomainRecordSet {
    name: pulumi.Input<string>;
    usePublicDns?: pulumi.Input<boolean>;
    usePublicIp?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsItf {
    defaultStaticTargetGroup?: pulumi.Input<inputs.ElastigroupAwsItfDefaultStaticTargetGroup>;
    fixedTargetGroups: pulumi.Input<boolean>;
    loadBalancers: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsItfLoadBalancer>[]>;
    migrationHealthinessThreshold?: pulumi.Input<number>;
    targetGroupConfigs: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsItfTargetGroupConfig>[]>;
    weightStrategy: pulumi.Input<string>;
}

export interface ElastigroupAwsItfDefaultStaticTargetGroup {
    arn: pulumi.Input<string>;
    percentage: pulumi.Input<number>;
}

export interface ElastigroupAwsItfLoadBalancer {
    listenerRules: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsItfLoadBalancerListenerRule>[]>;
    loadBalancerArn: pulumi.Input<string>;
}

export interface ElastigroupAwsItfLoadBalancerListenerRule {
    ruleArn: pulumi.Input<string>;
    staticTargetGroup?: pulumi.Input<inputs.ElastigroupAwsItfLoadBalancerListenerRuleStaticTargetGroup>;
}

export interface ElastigroupAwsItfLoadBalancerListenerRuleStaticTargetGroup {
    arn: pulumi.Input<string>;
    percentage: pulumi.Input<number>;
}

export interface ElastigroupAwsItfTargetGroupConfig {
    healthCheckIntervalSeconds?: pulumi.Input<number>;
    healthCheckPath: pulumi.Input<string>;
    healthCheckPort?: pulumi.Input<string>;
    healthCheckProtocol?: pulumi.Input<string>;
    healthCheckTimeoutSeconds?: pulumi.Input<number>;
    healthyThresholdCount?: pulumi.Input<number>;
    matchers?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsItfTargetGroupConfigMatcher>[]>;
    port: pulumi.Input<number>;
    protocol: pulumi.Input<string>;
    protocolVersion?: pulumi.Input<string>;
    tags?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsItfTargetGroupConfigTag>[]>;
    unhealthyThresholdCount?: pulumi.Input<number>;
    vpcId: pulumi.Input<string>;
}

export interface ElastigroupAwsItfTargetGroupConfigMatcher {
    grpcCode?: pulumi.Input<string>;
    httpCode?: pulumi.Input<string>;
}

export interface ElastigroupAwsItfTargetGroupConfigTag {
    tagKey: pulumi.Input<string>;
    tagValue?: pulumi.Input<string>;
}

export interface ElastigroupAwsLogging {
    export?: pulumi.Input<inputs.ElastigroupAwsLoggingExport>;
}

export interface ElastigroupAwsLoggingExport {
    s3s?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsLoggingExportS3>[]>;
}

export interface ElastigroupAwsLoggingExportS3 {
    id: pulumi.Input<string>;
}

export interface ElastigroupAwsMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
    instanceMetadataTags?: pulumi.Input<string>;
}

export interface ElastigroupAwsMultipleMetrics {
    expressions?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsMultipleMetricsExpression>[]>;
    metrics?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsMultipleMetricsMetric>[]>;
}

export interface ElastigroupAwsMultipleMetricsExpression {
    expression: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface ElastigroupAwsMultipleMetricsMetric {
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsMultipleMetricsMetricDimension>[]>;
    extendedStatistic?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    name: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    unit?: pulumi.Input<string>;
}

export interface ElastigroupAwsMultipleMetricsMetricDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupAwsNetworkInterface {
    associateIpv6Address?: pulumi.Input<boolean>;
    associatePublicIpAddress?: pulumi.Input<boolean>;
    deleteOnTermination?: pulumi.Input<boolean>;
    description?: pulumi.Input<string>;
    deviceIndex: pulumi.Input<string>;
    networkInterfaceId?: pulumi.Input<string>;
    privateIpAddress?: pulumi.Input<string>;
    secondaryPrivateIpAddressCount?: pulumi.Input<string>;
}

export interface ElastigroupAwsResourceRequirement {
    excludedInstanceFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    excludedInstanceGenerations?: pulumi.Input<pulumi.Input<string>[]>;
    excludedInstanceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    requiredGpuMaximum?: pulumi.Input<number>;
    requiredGpuMinimum?: pulumi.Input<number>;
    requiredMemoryMaximum: pulumi.Input<number>;
    requiredMemoryMinimum: pulumi.Input<number>;
    requiredVcpuMaximum: pulumi.Input<number>;
    requiredVcpuMinimum: pulumi.Input<number>;
}

export interface ElastigroupAwsResourceTagSpecification {
    shouldTagAmis?: pulumi.Input<boolean>;
    shouldTagEnis?: pulumi.Input<boolean>;
    shouldTagSnapshots?: pulumi.Input<boolean>;
    shouldTagVolumes?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsRevertToSpot {
    performAt: pulumi.Input<string>;
    timeWindows?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupAwsScalingDownPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsScalingDownPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    isEnabled?: pulumi.Input<boolean>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    stepAdjustments?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsScalingDownPolicyStepAdjustment>[]>;
    target?: pulumi.Input<string>;
    threshold?: pulumi.Input<number>;
    unit?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingDownPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingDownPolicyStepAdjustment {
    action: pulumi.Input<inputs.ElastigroupAwsScalingDownPolicyStepAdjustmentAction>;
    threshold: pulumi.Input<number>;
}

export interface ElastigroupAwsScalingDownPolicyStepAdjustmentAction {
    adjustment?: pulumi.Input<string>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingStrategy {
    terminateAtEndOfBillingHour?: pulumi.Input<boolean>;
    terminationPolicy?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingTargetPolicy {
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsScalingTargetPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    maxCapacityPerScale?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    predictiveMode?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    target: pulumi.Input<number>;
    unit?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingTargetPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingUpPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsScalingUpPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    isEnabled?: pulumi.Input<boolean>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    stepAdjustments?: pulumi.Input<pulumi.Input<inputs.ElastigroupAwsScalingUpPolicyStepAdjustment>[]>;
    target?: pulumi.Input<string>;
    threshold?: pulumi.Input<number>;
    unit?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingUpPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupAwsScalingUpPolicyStepAdjustment {
    action: pulumi.Input<inputs.ElastigroupAwsScalingUpPolicyStepAdjustmentAction>;
    threshold: pulumi.Input<number>;
}

export interface ElastigroupAwsScalingUpPolicyStepAdjustmentAction {
    adjustment?: pulumi.Input<string>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ElastigroupAwsScheduledTask {
    adjustment?: pulumi.Input<string>;
    adjustmentPercentage?: pulumi.Input<string>;
    batchSizePercentage?: pulumi.Input<string>;
    cronExpression?: pulumi.Input<string>;
    frequency?: pulumi.Input<string>;
    gracePeriod?: pulumi.Input<string>;
    isEnabled?: pulumi.Input<boolean>;
    maxCapacity?: pulumi.Input<string>;
    minCapacity?: pulumi.Input<string>;
    scaleMaxCapacity?: pulumi.Input<string>;
    scaleMinCapacity?: pulumi.Input<string>;
    scaleTargetCapacity?: pulumi.Input<string>;
    startTime?: pulumi.Input<string>;
    targetCapacity?: pulumi.Input<string>;
    taskType: pulumi.Input<string>;
}

export interface ElastigroupAwsSignal {
    name: pulumi.Input<string>;
    timeout?: pulumi.Input<number>;
}

export interface ElastigroupAwsStatefulDeallocation {
    shouldDeleteImages?: pulumi.Input<boolean>;
    shouldDeleteNetworkInterfaces?: pulumi.Input<boolean>;
    shouldDeleteSnapshots?: pulumi.Input<boolean>;
    shouldDeleteVolumes?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsStatefulInstanceAction {
    statefulInstanceId: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ElastigroupAwsSuspensionSuspension {
    name: pulumi.Input<string>;
}

export interface ElastigroupAwsTag {
    key?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupAwsUpdatePolicy {
    autoApplyTags?: pulumi.Input<boolean>;
    rollConfig?: pulumi.Input<inputs.ElastigroupAwsUpdatePolicyRollConfig>;
    shouldResumeStateful: pulumi.Input<boolean>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface ElastigroupAwsUpdatePolicyRollConfig {
    batchSizePercentage: pulumi.Input<number>;
    gracePeriod?: pulumi.Input<number>;
    healthCheckType?: pulumi.Input<string>;
    strategy?: pulumi.Input<inputs.ElastigroupAwsUpdatePolicyRollConfigStrategy>;
    waitForRollPercentage?: pulumi.Input<number>;
    waitForRollTimeout?: pulumi.Input<number>;
}

export interface ElastigroupAwsUpdatePolicyRollConfigStrategy {
    action: pulumi.Input<string>;
    batchMinHealthyPercentage?: pulumi.Input<number>;
    onFailure?: pulumi.Input<inputs.ElastigroupAwsUpdatePolicyRollConfigStrategyOnFailure>;
    shouldDrainInstances?: pulumi.Input<boolean>;
}

export interface ElastigroupAwsUpdatePolicyRollConfigStrategyOnFailure {
    actionType: pulumi.Input<string>;
    batchNum?: pulumi.Input<number>;
    drainingTimeout?: pulumi.Input<number>;
    shouldDecrementTargetCapacity?: pulumi.Input<boolean>;
    shouldHandleAllBatches?: pulumi.Input<boolean>;
}

export interface ElastigroupAzureV3Image {
    customs?: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3ImageCustom>[]>;
    galleryImages?: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3ImageGalleryImage>[]>;
    marketplaces?: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3ImageMarketplace>[]>;
}

export interface ElastigroupAzureV3ImageCustom {
    imageName: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3ImageGalleryImage {
    galleryName: pulumi.Input<string>;
    imageName: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
    spotAccountId?: pulumi.Input<string>;
    version: pulumi.Input<string>;
}

export interface ElastigroupAzureV3ImageMarketplace {
    offer: pulumi.Input<string>;
    publisher: pulumi.Input<string>;
    sku: pulumi.Input<string>;
    version: pulumi.Input<string>;
}

export interface ElastigroupAzureV3Login {
    password?: pulumi.Input<string>;
    sshPublicKey?: pulumi.Input<string>;
    userName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3ManagedServiceIdentity {
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3Network {
    networkInterfaces: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3NetworkNetworkInterface>[]>;
    resourceGroupName: pulumi.Input<string>;
    virtualNetworkName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3NetworkNetworkInterface {
    additionalIpConfigs?: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig>[]>;
    applicationSecurityGroups?: pulumi.Input<pulumi.Input<inputs.ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup>[]>;
    assignPublicIp: pulumi.Input<boolean>;
    isPrimary: pulumi.Input<boolean>;
    subnetName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceAdditionalIpConfig {
    name: pulumi.Input<string>;
    privateIpVersion?: pulumi.Input<string>;
}

export interface ElastigroupAzureV3NetworkNetworkInterfaceApplicationSecurityGroup {
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface ElastigroupAzureV3Tag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupAzureV3VmSizes {
    odSizes: pulumi.Input<pulumi.Input<string>[]>;
    spotSizes: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupGcpBackendService {
    locationType?: pulumi.Input<string>;
    namedPorts?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpBackendServiceNamedPort>[]>;
    scheme?: pulumi.Input<string>;
    serviceName: pulumi.Input<string>;
}

export interface ElastigroupGcpBackendServiceNamedPort {
    name: pulumi.Input<string>;
    ports: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupGcpDisk {
    autoDelete?: pulumi.Input<boolean>;
    boot?: pulumi.Input<boolean>;
    deviceName?: pulumi.Input<string>;
    initializeParams?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpDiskInitializeParam>[]>;
    interface?: pulumi.Input<string>;
    mode?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ElastigroupGcpDiskInitializeParam {
    diskSizeGb?: pulumi.Input<string>;
    diskType?: pulumi.Input<string>;
    sourceImage: pulumi.Input<string>;
}

export interface ElastigroupGcpGpus {
    count: pulumi.Input<number>;
    type: pulumi.Input<string>;
}

export interface ElastigroupGcpInstanceTypesCustom {
    memoryGib: pulumi.Input<number>;
    vcpu: pulumi.Input<number>;
}

export interface ElastigroupGcpIntegrationDockerSwarm {
    masterHost: pulumi.Input<string>;
    masterPort: pulumi.Input<number>;
}

export interface ElastigroupGcpIntegrationGke {
    autoUpdate?: pulumi.Input<boolean>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupGcpIntegrationGkeAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupGcpIntegrationGkeAutoscaleHeadroom>;
    autoscaleIsAutoConfig?: pulumi.Input<boolean>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    autoscaleLabels?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpIntegrationGkeAutoscaleLabel>[]>;
    clusterId?: pulumi.Input<string>;
    location?: pulumi.Input<string>;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupGcpIntegrationGkeAutoscaleLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGcpLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGcpMetadata {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGcpNetworkInterface {
    accessConfigs?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpNetworkInterfaceAccessConfig>[]>;
    aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpNetworkInterfaceAliasIpRange>[]>;
    network: pulumi.Input<string>;
}

export interface ElastigroupGcpNetworkInterfaceAccessConfig {
    name?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ElastigroupGcpNetworkInterfaceAliasIpRange {
    ipCidrRange: pulumi.Input<string>;
    subnetworkRangeName: pulumi.Input<string>;
}

export interface ElastigroupGcpRevertToPreemptible {
    performAt: pulumi.Input<string>;
}

export interface ElastigroupGcpScalingDownPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpScalingDownPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface ElastigroupGcpScalingDownPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupGcpScalingUpPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupGcpScalingUpPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface ElastigroupGcpScalingUpPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupGcpScheduledTask {
    cronExpression?: pulumi.Input<string>;
    isEnabled?: pulumi.Input<boolean>;
    maxCapacity?: pulumi.Input<string>;
    minCapacity?: pulumi.Input<string>;
    targetCapacity?: pulumi.Input<string>;
    taskType: pulumi.Input<string>;
}

export interface ElastigroupGcpSubnet {
    region: pulumi.Input<string>;
    subnetNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupGkeBackendService {
    locationType?: pulumi.Input<string>;
    namedPorts?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeBackendServiceNamedPort>[]>;
    scheme?: pulumi.Input<string>;
    serviceName: pulumi.Input<string>;
}

export interface ElastigroupGkeBackendServiceNamedPort {
    name: pulumi.Input<string>;
    ports: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ElastigroupGkeDisk {
    autoDelete?: pulumi.Input<boolean>;
    boot?: pulumi.Input<boolean>;
    deviceName?: pulumi.Input<string>;
    initializeParams?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeDiskInitializeParam>[]>;
    interface?: pulumi.Input<string>;
    mode?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ElastigroupGkeDiskInitializeParam {
    diskSizeGb?: pulumi.Input<string>;
    diskType?: pulumi.Input<string>;
    sourceImage: pulumi.Input<string>;
}

export interface ElastigroupGkeGpus {
    count: pulumi.Input<number>;
    type: pulumi.Input<string>;
}

export interface ElastigroupGkeInstanceTypesCustom {
    memoryGib: pulumi.Input<number>;
    vcpu: pulumi.Input<number>;
}

export interface ElastigroupGkeIntegrationDockerSwarm {
    masterHost: pulumi.Input<string>;
    masterPort: pulumi.Input<number>;
}

export interface ElastigroupGkeIntegrationGke {
    autoUpdate?: pulumi.Input<boolean>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.ElastigroupGkeIntegrationGkeAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.ElastigroupGkeIntegrationGkeAutoscaleHeadroom>;
    autoscaleIsAutoConfig?: pulumi.Input<boolean>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    autoscaleLabels?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeIntegrationGkeAutoscaleLabel>[]>;
    clusterId?: pulumi.Input<string>;
    location?: pulumi.Input<string>;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface ElastigroupGkeIntegrationGkeAutoscaleLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGkeLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGkeMetadata {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface ElastigroupGkeNetworkInterface {
    accessConfigs?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeNetworkInterfaceAccessConfig>[]>;
    aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeNetworkInterfaceAliasIpRange>[]>;
    network: pulumi.Input<string>;
}

export interface ElastigroupGkeNetworkInterfaceAccessConfig {
    name?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ElastigroupGkeNetworkInterfaceAliasIpRange {
    ipCidrRange: pulumi.Input<string>;
    subnetworkRangeName: pulumi.Input<string>;
}

export interface ElastigroupGkeRevertToPreemptible {
    performAt: pulumi.Input<string>;
}

export interface ElastigroupGkeScalingDownPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeScalingDownPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface ElastigroupGkeScalingDownPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ElastigroupGkeScalingUpPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<pulumi.Input<inputs.ElastigroupGkeScalingUpPolicyDimension>[]>;
    evaluationPeriods?: pulumi.Input<number>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface ElastigroupGkeScalingUpPolicyDimension {
    name: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface HealthCheckCheck {
    endPoint?: pulumi.Input<string>;
    endpoint?: pulumi.Input<string>;
    healthy: pulumi.Input<number>;
    interval: pulumi.Input<number>;
    port: pulumi.Input<number>;
    protocol: pulumi.Input<string>;
    timeOut?: pulumi.Input<number>;
    timeout?: pulumi.Input<number>;
    unhealthy: pulumi.Input<number>;
}

export interface ManagedInstanceAwsBlockDeviceMapping {
    deviceName: pulumi.Input<string>;
    ebs?: pulumi.Input<inputs.ManagedInstanceAwsBlockDeviceMappingEbs>;
}

export interface ManagedInstanceAwsBlockDeviceMappingEbs {
    deleteOnTermination?: pulumi.Input<boolean>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface ManagedInstanceAwsDelete {
    amiBackupShouldDeleteImages?: pulumi.Input<boolean>;
    deallocationConfigShouldDeleteImages?: pulumi.Input<boolean>;
    shouldDeleteNetworkInterfaces?: pulumi.Input<boolean>;
    shouldDeleteSnapshots?: pulumi.Input<boolean>;
    shouldDeleteVolumes?: pulumi.Input<boolean>;
    shouldTerminateInstance?: pulumi.Input<boolean>;
}

export interface ManagedInstanceAwsIntegrationRoute53 {
    domains: pulumi.Input<pulumi.Input<inputs.ManagedInstanceAwsIntegrationRoute53Domain>[]>;
}

export interface ManagedInstanceAwsIntegrationRoute53Domain {
    hostedZoneId: pulumi.Input<string>;
    recordSetType?: pulumi.Input<string>;
    recordSets: pulumi.Input<pulumi.Input<inputs.ManagedInstanceAwsIntegrationRoute53DomainRecordSet>[]>;
    spotinstAcctId?: pulumi.Input<string>;
}

export interface ManagedInstanceAwsIntegrationRoute53DomainRecordSet {
    name: pulumi.Input<string>;
    usePublicDns?: pulumi.Input<boolean>;
    usePublicIp?: pulumi.Input<boolean>;
}

export interface ManagedInstanceAwsLoadBalancer {
    arn?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ManagedInstanceAwsManagedInstanceAction {
    type: pulumi.Input<string>;
}

export interface ManagedInstanceAwsMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
    instanceMetadataTags?: pulumi.Input<string>;
}

export interface ManagedInstanceAwsNetworkInterface {
    associateIpv6Address?: pulumi.Input<boolean>;
    associatePublicIpAddress?: pulumi.Input<boolean>;
    deviceIndex: pulumi.Input<string>;
}

export interface ManagedInstanceAwsResourceTagSpecification {
    shouldTagAmis?: pulumi.Input<boolean>;
    shouldTagEnis?: pulumi.Input<boolean>;
    shouldTagSnapshots?: pulumi.Input<boolean>;
    shouldTagVolumes?: pulumi.Input<boolean>;
}

export interface ManagedInstanceAwsRevertToSpot {
    performAt: pulumi.Input<string>;
}

export interface ManagedInstanceAwsScheduledTask {
    cronExpression?: pulumi.Input<string>;
    frequency?: pulumi.Input<string>;
    isEnabled?: pulumi.Input<boolean>;
    startTime?: pulumi.Input<string>;
    taskType: pulumi.Input<string>;
}

export interface ManagedInstanceAwsTag {
    key?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface MrscalerAwsApplication {
    args?: pulumi.Input<pulumi.Input<string>[]>;
    name: pulumi.Input<string>;
    version?: pulumi.Input<string>;
}

export interface MrscalerAwsBootstrapActionsFile {
    bucket: pulumi.Input<string>;
    key: pulumi.Input<string>;
}

export interface MrscalerAwsConfigurationsFile {
    bucket: pulumi.Input<string>;
    key: pulumi.Input<string>;
}

export interface MrscalerAwsCoreEbsBlockDevice {
    iops?: pulumi.Input<number>;
    sizeInGb: pulumi.Input<number>;
    volumeType: pulumi.Input<string>;
    volumesPerInstance?: pulumi.Input<number>;
}

export interface MrscalerAwsCoreScalingDownPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    evaluationPeriods?: pulumi.Input<number>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface MrscalerAwsCoreScalingUpPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    evaluationPeriods?: pulumi.Input<number>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface MrscalerAwsInstanceWeight {
    instanceType: pulumi.Input<string>;
    weightedCapacity: pulumi.Input<number>;
}

export interface MrscalerAwsMasterEbsBlockDevice {
    iops?: pulumi.Input<number>;
    sizeInGb: pulumi.Input<number>;
    volumeType: pulumi.Input<string>;
    volumesPerInstance?: pulumi.Input<number>;
}

export interface MrscalerAwsProvisioningTimeout {
    timeout: pulumi.Input<number>;
    timeoutAction: pulumi.Input<string>;
}

export interface MrscalerAwsScheduledTask {
    cron: pulumi.Input<string>;
    desiredCapacity?: pulumi.Input<string>;
    instanceGroupType: pulumi.Input<string>;
    isEnabled?: pulumi.Input<boolean>;
    maxCapacity?: pulumi.Input<string>;
    minCapacity?: pulumi.Input<string>;
    taskType: pulumi.Input<string>;
}

export interface MrscalerAwsStepsFile {
    bucket: pulumi.Input<string>;
    key: pulumi.Input<string>;
}

export interface MrscalerAwsTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface MrscalerAwsTaskEbsBlockDevice {
    iops?: pulumi.Input<number>;
    sizeInGb: pulumi.Input<number>;
    volumeType: pulumi.Input<string>;
    volumesPerInstance?: pulumi.Input<number>;
}

export interface MrscalerAwsTaskScalingDownPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    evaluationPeriods?: pulumi.Input<number>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface MrscalerAwsTaskScalingUpPolicy {
    actionType?: pulumi.Input<string>;
    adjustment?: pulumi.Input<string>;
    cooldown?: pulumi.Input<number>;
    dimensions?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    evaluationPeriods?: pulumi.Input<number>;
    maxTargetCapacity?: pulumi.Input<string>;
    maximum?: pulumi.Input<string>;
    metricName: pulumi.Input<string>;
    minTargetCapacity?: pulumi.Input<string>;
    minimum?: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    policyName: pulumi.Input<string>;
    statistic?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit: pulumi.Input<string>;
}

export interface MrscalerAwsTerminationPolicy {
    statements: pulumi.Input<pulumi.Input<inputs.MrscalerAwsTerminationPolicyStatement>[]>;
}

export interface MrscalerAwsTerminationPolicyStatement {
    evaluationPeriods?: pulumi.Input<number>;
    metricName: pulumi.Input<string>;
    namespace: pulumi.Input<string>;
    operator?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    statistic?: pulumi.Input<string>;
    threshold: pulumi.Input<number>;
    unit?: pulumi.Input<string>;
}

export interface OceanAksNpAutoscaler {
    autoscaleDown?: pulumi.Input<inputs.OceanAksNpAutoscalerAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.OceanAksNpAutoscalerAutoscaleHeadroom>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    resourceLimits?: pulumi.Input<inputs.OceanAksNpAutoscalerResourceLimits>;
}

export interface OceanAksNpAutoscalerAutoscaleDown {
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface OceanAksNpAutoscalerAutoscaleHeadroom {
    automatic?: pulumi.Input<inputs.OceanAksNpAutoscalerAutoscaleHeadroomAutomatic>;
}

export interface OceanAksNpAutoscalerAutoscaleHeadroomAutomatic {
    isEnabled?: pulumi.Input<boolean>;
    percentage?: pulumi.Input<number>;
}

export interface OceanAksNpAutoscalerResourceLimits {
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
}

export interface OceanAksNpFilters {
    acceleratedNetworking?: pulumi.Input<string>;
    architectures?: pulumi.Input<pulumi.Input<string>[]>;
    diskPerformance?: pulumi.Input<string>;
    excludeSeries?: pulumi.Input<pulumi.Input<string>[]>;
    gpuTypes?: pulumi.Input<pulumi.Input<string>[]>;
    maxGpu?: pulumi.Input<number>;
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
    minDisk?: pulumi.Input<number>;
    minGpu?: pulumi.Input<number>;
    minMemoryGib?: pulumi.Input<number>;
    minNics?: pulumi.Input<number>;
    minVcpu?: pulumi.Input<number>;
    series?: pulumi.Input<pulumi.Input<string>[]>;
    vmTypes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAksNpHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface OceanAksNpHealth {
    gracePeriod?: pulumi.Input<number>;
}

export interface OceanAksNpLinuxOsConfig {
    sysctls?: pulumi.Input<pulumi.Input<inputs.OceanAksNpLinuxOsConfigSysctl>[]>;
}

export interface OceanAksNpLinuxOsConfigSysctl {
    vmMaxMapCount?: pulumi.Input<number>;
}

export interface OceanAksNpScheduling {
    shutdownHours?: pulumi.Input<inputs.OceanAksNpSchedulingShutdownHours>;
    tasks?: pulumi.Input<pulumi.Input<inputs.OceanAksNpSchedulingTask>[]>;
}

export interface OceanAksNpSchedulingShutdownHours {
    isEnabled?: pulumi.Input<boolean>;
    timeWindows?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAksNpSchedulingTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    parameters?: pulumi.Input<inputs.OceanAksNpSchedulingTaskParameters>;
    taskType: pulumi.Input<string>;
}

export interface OceanAksNpSchedulingTaskParameters {
    parametersClusterRoll?: pulumi.Input<inputs.OceanAksNpSchedulingTaskParametersParametersClusterRoll>;
}

export interface OceanAksNpSchedulingTaskParametersParametersClusterRoll {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    respectPdb?: pulumi.Input<boolean>;
    respectRestrictScaleDown?: pulumi.Input<boolean>;
    vngIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAksNpTaint {
    effect: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAksNpUpdatePolicy {
    conditionedRoll?: pulumi.Input<boolean>;
    rollConfig?: pulumi.Input<inputs.OceanAksNpUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanAksNpUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    nodeNames?: pulumi.Input<pulumi.Input<string>[]>;
    nodePoolNames?: pulumi.Input<pulumi.Input<string>[]>;
    respectPdb?: pulumi.Input<boolean>;
    respectRestrictScaleDown?: pulumi.Input<boolean>;
    vngIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAksNpVirtualNodeGroupFilters {
    acceleratedNetworking?: pulumi.Input<string>;
    architectures?: pulumi.Input<pulumi.Input<string>[]>;
    diskPerformance?: pulumi.Input<string>;
    excludeSeries?: pulumi.Input<pulumi.Input<string>[]>;
    gpuTypes?: pulumi.Input<pulumi.Input<string>[]>;
    maxGpu?: pulumi.Input<number>;
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
    minDisk?: pulumi.Input<number>;
    minGpu?: pulumi.Input<number>;
    minMemoryGib?: pulumi.Input<number>;
    minNics?: pulumi.Input<number>;
    minVcpu?: pulumi.Input<number>;
    series?: pulumi.Input<pulumi.Input<string>[]>;
    vmTypes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAksNpVirtualNodeGroupHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface OceanAksNpVirtualNodeGroupLinuxOsConfig {
    sysctls?: pulumi.Input<pulumi.Input<inputs.OceanAksNpVirtualNodeGroupLinuxOsConfigSysctl>[]>;
}

export interface OceanAksNpVirtualNodeGroupLinuxOsConfigSysctl {
    vmMaxMapCount?: pulumi.Input<number>;
}

export interface OceanAksNpVirtualNodeGroupTaint {
    effect: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAksNpVirtualNodeGroupUpdatePolicy {
    conditionedRoll?: pulumi.Input<boolean>;
    rollConfig?: pulumi.Input<inputs.OceanAksNpVirtualNodeGroupUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanAksNpVirtualNodeGroupUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    nodeNames?: pulumi.Input<pulumi.Input<string>[]>;
    nodePoolNames?: pulumi.Input<pulumi.Input<string>[]>;
    respectPdb?: pulumi.Input<boolean>;
    respectRestrictScaleDown?: pulumi.Input<boolean>;
    vngIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAwsAttachLoadBalancer {
    arn?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface OceanAwsAutoscaler {
    autoHeadroomPercentage?: pulumi.Input<number>;
    autoscaleCooldown?: pulumi.Input<number>;
    autoscaleDown?: pulumi.Input<inputs.OceanAwsAutoscalerAutoscaleDown>;
    autoscaleHeadroom?: pulumi.Input<inputs.OceanAwsAutoscalerAutoscaleHeadroom>;
    autoscaleIsAutoConfig?: pulumi.Input<boolean>;
    autoscaleIsEnabled?: pulumi.Input<boolean>;
    enableAutomaticAndManualHeadroom?: pulumi.Input<boolean>;
    extendedResourceDefinitions?: pulumi.Input<pulumi.Input<string>[]>;
    resourceLimits?: pulumi.Input<inputs.OceanAwsAutoscalerResourceLimits>;
}

export interface OceanAwsAutoscalerAutoscaleDown {
    evaluationPeriods?: pulumi.Input<number>;
    isAggressiveScaleDownEnabled?: pulumi.Input<boolean>;
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface OceanAwsAutoscalerAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface OceanAwsAutoscalerResourceLimits {
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
}

export interface OceanAwsBlockDeviceMapping {
    deviceName?: pulumi.Input<string>;
    ebs?: pulumi.Input<inputs.OceanAwsBlockDeviceMappingEbs>;
}

export interface OceanAwsBlockDeviceMappingEbs {
    deleteOnTermination?: pulumi.Input<boolean>;
    dynamicIops?: pulumi.Input<inputs.OceanAwsBlockDeviceMappingEbsDynamicIops>;
    dynamicVolumeSize?: pulumi.Input<inputs.OceanAwsBlockDeviceMappingEbsDynamicVolumeSize>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface OceanAwsBlockDeviceMappingEbsDynamicIops {
    baseSize: pulumi.Input<number>;
    resource: pulumi.Input<string>;
    sizePerResourceUnit: pulumi.Input<number>;
}

export interface OceanAwsBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: pulumi.Input<number>;
    resource: pulumi.Input<string>;
    sizePerResourceUnit: pulumi.Input<number>;
}

export interface OceanAwsClusterOrientation {
    availabilityVsCost?: pulumi.Input<string>;
}

export interface OceanAwsDetachLoadBalancer {
    arn?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface OceanAwsFilters {
    architectures?: pulumi.Input<pulumi.Input<string>[]>;
    categories?: pulumi.Input<pulumi.Input<string>[]>;
    diskTypes?: pulumi.Input<pulumi.Input<string>[]>;
    excludeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    excludeMetal?: pulumi.Input<boolean>;
    hypervisors?: pulumi.Input<pulumi.Input<string>[]>;
    includeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    isEnaSupported?: pulumi.Input<string>;
    maxGpu?: pulumi.Input<number>;
    maxMemoryGib?: pulumi.Input<number>;
    maxNetworkPerformance?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
    minEnis?: pulumi.Input<number>;
    minGpu?: pulumi.Input<number>;
    minMemoryGib?: pulumi.Input<number>;
    minNetworkPerformance?: pulumi.Input<number>;
    minVcpu?: pulumi.Input<number>;
    rootDeviceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    virtualizationTypes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAwsInstanceMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecAutoscaleDown {
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecAutoscaleHeadroomsAutomatic {
    autoHeadroomPercentage?: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecBlockDeviceMapping {
    deviceName?: pulumi.Input<string>;
    ebs?: pulumi.Input<inputs.OceanAwsLaunchSpecBlockDeviceMappingEbs>;
    noDevice?: pulumi.Input<string>;
    virtualName?: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecBlockDeviceMappingEbs {
    deleteOnTermination?: pulumi.Input<boolean>;
    dynamicVolumeSize?: pulumi.Input<inputs.OceanAwsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: pulumi.Input<number>;
    resource: pulumi.Input<string>;
    sizePerResourceUnit: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecCreateOptions {
    initialNodes?: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecDeleteOptions {
    deleteNodes?: pulumi.Input<boolean>;
    forceDelete: pulumi.Input<boolean>;
}

export interface OceanAwsLaunchSpecElasticIpPool {
    tagSelector?: pulumi.Input<inputs.OceanAwsLaunchSpecElasticIpPoolTagSelector>;
}

export interface OceanAwsLaunchSpecElasticIpPoolTagSelector {
    tagKey: pulumi.Input<string>;
    tagValue?: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecEphemeralStorage {
    ephemeralStorageDeviceName?: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecImage {
    imageId?: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecInstanceMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecInstanceTypesFilters {
    categories?: pulumi.Input<pulumi.Input<string>[]>;
    diskTypes?: pulumi.Input<pulumi.Input<string>[]>;
    excludeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    excludeMetal?: pulumi.Input<boolean>;
    hypervisors?: pulumi.Input<pulumi.Input<string>[]>;
    includeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    isEnaSupported?: pulumi.Input<string>;
    maxGpu?: pulumi.Input<number>;
    maxMemoryGib?: pulumi.Input<number>;
    maxNetworkPerformance?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
    minEnis?: pulumi.Input<number>;
    minGpu?: pulumi.Input<number>;
    minMemoryGib?: pulumi.Input<number>;
    minNetworkPerformance?: pulumi.Input<number>;
    minVcpu?: pulumi.Input<number>;
    rootDeviceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    virtualizationTypes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAwsLaunchSpecLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecResourceLimit {
    maxInstanceCount?: pulumi.Input<number>;
    minInstanceCount?: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecSchedulingShutdownHours {
    isEnabled?: pulumi.Input<boolean>;
    timeWindows: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAwsLaunchSpecSchedulingTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    taskHeadrooms?: pulumi.Input<pulumi.Input<inputs.OceanAwsLaunchSpecSchedulingTaskTaskHeadroom>[]>;
    taskType: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecStrategy {
    drainingTimeout?: pulumi.Input<number>;
    spotPercentage?: pulumi.Input<number>;
}

export interface OceanAwsLaunchSpecTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecTaint {
    effect: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAwsLaunchSpecUpdatePolicy {
    rollConfig?: pulumi.Input<inputs.OceanAwsLaunchSpecUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanAwsLaunchSpecUpdatePolicyRollConfig {
    batchSizePercentage: pulumi.Input<number>;
}

export interface OceanAwsLoadBalancer {
    arn?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface OceanAwsLogging {
    export?: pulumi.Input<inputs.OceanAwsLoggingExport>;
}

export interface OceanAwsLoggingExport {
    s3s?: pulumi.Input<pulumi.Input<inputs.OceanAwsLoggingExportS3>[]>;
}

export interface OceanAwsLoggingExportS3 {
    id: pulumi.Input<string>;
}

export interface OceanAwsResourceTagSpecification {
    shouldTagVolumes?: pulumi.Input<boolean>;
}

export interface OceanAwsScheduledTask {
    shutdownHours?: pulumi.Input<inputs.OceanAwsScheduledTaskShutdownHours>;
    tasks?: pulumi.Input<pulumi.Input<inputs.OceanAwsScheduledTaskTask>[]>;
}

export interface OceanAwsScheduledTaskShutdownHours {
    isEnabled?: pulumi.Input<boolean>;
    timeWindows: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanAwsScheduledTaskTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    parameters?: pulumi.Input<inputs.OceanAwsScheduledTaskTaskParameters>;
    taskType: pulumi.Input<string>;
}

export interface OceanAwsScheduledTaskTaskParameters {
    amiAutoUpdate?: pulumi.Input<inputs.OceanAwsScheduledTaskTaskParametersAmiAutoUpdate>;
    parametersClusterRoll?: pulumi.Input<inputs.OceanAwsScheduledTaskTaskParametersParametersClusterRoll>;
}

export interface OceanAwsScheduledTaskTaskParametersAmiAutoUpdate {
    amiAutoUpdateClusterRoll?: pulumi.Input<inputs.OceanAwsScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll>;
    applyRoll?: pulumi.Input<boolean>;
    minorVersion?: pulumi.Input<boolean>;
    patch?: pulumi.Input<boolean>;
}

export interface OceanAwsScheduledTaskTaskParametersAmiAutoUpdateAmiAutoUpdateClusterRoll {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    respectPdb?: pulumi.Input<boolean>;
}

export interface OceanAwsScheduledTaskTaskParametersParametersClusterRoll {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    respectPdb?: pulumi.Input<boolean>;
}

export interface OceanAwsTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanAwsUpdatePolicy {
    autoApplyTags?: pulumi.Input<boolean>;
    conditionedRoll?: pulumi.Input<boolean>;
    conditionedRollParams?: pulumi.Input<pulumi.Input<string>[]>;
    rollConfig?: pulumi.Input<inputs.OceanAwsUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanAwsUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage: pulumi.Input<number>;
    launchSpecIds?: pulumi.Input<pulumi.Input<string>[]>;
    respectPdb?: pulumi.Input<boolean>;
}

export interface OceanEcsAutoscaler {
    autoHeadroomPercentage?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    down?: pulumi.Input<inputs.OceanEcsAutoscalerDown>;
    enableAutomaticAndManualHeadroom?: pulumi.Input<boolean>;
    headroom?: pulumi.Input<inputs.OceanEcsAutoscalerHeadroom>;
    isAutoConfig?: pulumi.Input<boolean>;
    isEnabled?: pulumi.Input<boolean>;
    resourceLimits?: pulumi.Input<inputs.OceanEcsAutoscalerResourceLimits>;
    shouldScaleDownNonServiceTasks?: pulumi.Input<boolean>;
}

export interface OceanEcsAutoscalerDown {
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface OceanEcsAutoscalerHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface OceanEcsAutoscalerResourceLimits {
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
}

export interface OceanEcsBlockDeviceMapping {
    deviceName: pulumi.Input<string>;
    ebs?: pulumi.Input<inputs.OceanEcsBlockDeviceMappingEbs>;
    noDevice?: pulumi.Input<string>;
    virtualName?: pulumi.Input<string>;
}

export interface OceanEcsBlockDeviceMappingEbs {
    deleteOnTermination?: pulumi.Input<boolean>;
    dynamicVolumeSize?: pulumi.Input<inputs.OceanEcsBlockDeviceMappingEbsDynamicVolumeSize>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface OceanEcsBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: pulumi.Input<number>;
    resource: pulumi.Input<string>;
    sizePerResourceUnit: pulumi.Input<number>;
}

export interface OceanEcsClusterOrientation {
    availabilityVsCost?: pulumi.Input<string>;
}

export interface OceanEcsFilters {
    architectures?: pulumi.Input<pulumi.Input<string>[]>;
    categories?: pulumi.Input<pulumi.Input<string>[]>;
    diskTypes?: pulumi.Input<pulumi.Input<string>[]>;
    excludeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    excludeMetal?: pulumi.Input<boolean>;
    hypervisors?: pulumi.Input<pulumi.Input<string>[]>;
    includeFamilies?: pulumi.Input<pulumi.Input<string>[]>;
    isEnaSupported?: pulumi.Input<string>;
    maxGpu?: pulumi.Input<number>;
    maxMemoryGib?: pulumi.Input<number>;
    maxNetworkPerformance?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
    minEnis?: pulumi.Input<number>;
    minGpu?: pulumi.Input<number>;
    minMemoryGib?: pulumi.Input<number>;
    minNetworkPerformance?: pulumi.Input<number>;
    minVcpu?: pulumi.Input<number>;
    rootDeviceTypes?: pulumi.Input<pulumi.Input<string>[]>;
    virtualizationTypes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanEcsInstanceMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecAttribute {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanEcsLaunchSpecBlockDeviceMapping {
    deviceName: pulumi.Input<string>;
    ebs?: pulumi.Input<inputs.OceanEcsLaunchSpecBlockDeviceMappingEbs>;
    noDevice?: pulumi.Input<string>;
    virtualName?: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecBlockDeviceMappingEbs {
    deleteOnTermination?: pulumi.Input<boolean>;
    dynamicVolumeSize?: pulumi.Input<inputs.OceanEcsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize>;
    encrypted?: pulumi.Input<boolean>;
    iops?: pulumi.Input<number>;
    kmsKeyId?: pulumi.Input<string>;
    snapshotId?: pulumi.Input<string>;
    throughput?: pulumi.Input<number>;
    volumeSize?: pulumi.Input<number>;
    volumeType?: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecBlockDeviceMappingEbsDynamicVolumeSize {
    baseSize: pulumi.Input<number>;
    resource: pulumi.Input<string>;
    sizePerResourceUnit: pulumi.Input<number>;
}

export interface OceanEcsLaunchSpecImage {
    imageId?: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecInstanceMetadataOptions {
    httpPutResponseHopLimit?: pulumi.Input<number>;
    httpTokens: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecSchedulingTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    taskHeadrooms?: pulumi.Input<pulumi.Input<inputs.OceanEcsLaunchSpecSchedulingTaskTaskHeadroom>[]>;
    taskType: pulumi.Input<string>;
}

export interface OceanEcsLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanEcsLaunchSpecStrategy {
    spotPercentage?: pulumi.Input<number>;
}

export interface OceanEcsLaunchSpecTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanEcsLogging {
    export?: pulumi.Input<inputs.OceanEcsLoggingExport>;
}

export interface OceanEcsLoggingExport {
    s3s?: pulumi.Input<pulumi.Input<inputs.OceanEcsLoggingExportS3>[]>;
}

export interface OceanEcsLoggingExportS3 {
    id: pulumi.Input<string>;
}

export interface OceanEcsOptimizeImages {
    performAt: pulumi.Input<string>;
    shouldOptimizeEcsAmi: pulumi.Input<boolean>;
    timeWindows?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanEcsScheduledTask {
    shutdownHours?: pulumi.Input<inputs.OceanEcsScheduledTaskShutdownHours>;
    tasks?: pulumi.Input<pulumi.Input<inputs.OceanEcsScheduledTaskTask>[]>;
}

export interface OceanEcsScheduledTaskShutdownHours {
    isEnabled?: pulumi.Input<boolean>;
    timeWindows: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanEcsScheduledTaskTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    taskType: pulumi.Input<string>;
}

export interface OceanEcsTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanEcsUpdatePolicy {
    autoApplyTags?: pulumi.Input<boolean>;
    conditionedRoll?: pulumi.Input<boolean>;
    rollConfig?: pulumi.Input<inputs.OceanEcsUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanEcsUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage: pulumi.Input<number>;
}

export interface OceanGkeImportAutoscaler {
    autoHeadroomPercentage?: pulumi.Input<number>;
    cooldown?: pulumi.Input<number>;
    down?: pulumi.Input<inputs.OceanGkeImportAutoscalerDown>;
    enableAutomaticAndManualHeadroom?: pulumi.Input<boolean>;
    headroom?: pulumi.Input<inputs.OceanGkeImportAutoscalerHeadroom>;
    isAutoConfig?: pulumi.Input<boolean>;
    isEnabled?: pulumi.Input<boolean>;
    resourceLimits?: pulumi.Input<inputs.OceanGkeImportAutoscalerResourceLimits>;
}

export interface OceanGkeImportAutoscalerDown {
    evaluationPeriods?: pulumi.Input<number>;
    maxScaleDownPercentage?: pulumi.Input<number>;
}

export interface OceanGkeImportAutoscalerHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits?: pulumi.Input<number>;
}

export interface OceanGkeImportAutoscalerResourceLimits {
    maxMemoryGib?: pulumi.Input<number>;
    maxVcpu?: pulumi.Input<number>;
}

export interface OceanGkeImportBackendService {
    locationType?: pulumi.Input<string>;
    namedPorts?: pulumi.Input<pulumi.Input<inputs.OceanGkeImportBackendServiceNamedPort>[]>;
    scheme?: pulumi.Input<string>;
    serviceName: pulumi.Input<string>;
}

export interface OceanGkeImportBackendServiceNamedPort {
    name: pulumi.Input<string>;
    ports: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanGkeImportScheduledTask {
    shutdownHours?: pulumi.Input<inputs.OceanGkeImportScheduledTaskShutdownHours>;
    tasks?: pulumi.Input<pulumi.Input<inputs.OceanGkeImportScheduledTaskTask>[]>;
}

export interface OceanGkeImportScheduledTaskShutdownHours {
    isEnabled?: pulumi.Input<boolean>;
    timeWindows: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanGkeImportScheduledTaskTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    taskParameters?: pulumi.Input<inputs.OceanGkeImportScheduledTaskTaskTaskParameters>;
    taskType: pulumi.Input<string>;
}

export interface OceanGkeImportScheduledTaskTaskTaskParameters {
    clusterRoll?: pulumi.Input<inputs.OceanGkeImportScheduledTaskTaskTaskParametersClusterRoll>;
}

export interface OceanGkeImportScheduledTaskTaskTaskParametersClusterRoll {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    respectPdb?: pulumi.Input<boolean>;
}

export interface OceanGkeImportShieldedInstanceConfig {
    enableIntegrityMonitoring?: pulumi.Input<boolean>;
    enableSecureBoot?: pulumi.Input<boolean>;
}

export interface OceanGkeImportStrategy {
    drainingTimeout?: pulumi.Input<number>;
    preemptiblePercentage?: pulumi.Input<number>;
    provisioningModel?: pulumi.Input<string>;
}

export interface OceanGkeImportUpdatePolicy {
    conditionedRoll?: pulumi.Input<boolean>;
    rollConfig?: pulumi.Input<inputs.OceanGkeImportUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanGkeImportUpdatePolicyRollConfig {
    batchMinHealthyPercentage?: pulumi.Input<number>;
    batchSizePercentage: pulumi.Input<number>;
    launchSpecIds?: pulumi.Input<pulumi.Input<string>[]>;
    respectPdb?: pulumi.Input<boolean>;
}

export interface OceanGkeLaunchSpecAutoscaleHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecAutoscaleHeadroomsAutomatic {
    autoHeadroomPercentage?: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecCreateOptions {
    initialNodes?: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecLabel {
    key?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecMetadata {
    key?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecNetworkInterface {
    accessConfigs?: pulumi.Input<pulumi.Input<inputs.OceanGkeLaunchSpecNetworkInterfaceAccessConfig>[]>;
    aliasIpRanges?: pulumi.Input<pulumi.Input<inputs.OceanGkeLaunchSpecNetworkInterfaceAliasIpRange>[]>;
    network: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecNetworkInterfaceAccessConfig {
    name?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecNetworkInterfaceAliasIpRange {
    ipCidrRange: pulumi.Input<string>;
    subnetworkRangeName: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecResourceLimits {
    maxInstanceCount?: pulumi.Input<number>;
    minInstanceCount?: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecSchedulingTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    taskHeadrooms?: pulumi.Input<pulumi.Input<inputs.OceanGkeLaunchSpecSchedulingTaskTaskHeadroom>[]>;
    taskType: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecSchedulingTaskTaskHeadroom {
    cpuPerUnit?: pulumi.Input<number>;
    gpuPerUnit?: pulumi.Input<number>;
    memoryPerUnit?: pulumi.Input<number>;
    numOfUnits: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecShieldedInstanceConfig {
    enableIntegrityMonitoring?: pulumi.Input<boolean>;
    enableSecureBoot?: pulumi.Input<boolean>;
}

export interface OceanGkeLaunchSpecStorage {
    localSsdCount?: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecStrategy {
    preemptiblePercentage?: pulumi.Input<number>;
}

export interface OceanGkeLaunchSpecTaint {
    effect?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface OceanGkeLaunchSpecUpdatePolicy {
    rollConfig?: pulumi.Input<inputs.OceanGkeLaunchSpecUpdatePolicyRollConfig>;
    shouldRoll: pulumi.Input<boolean>;
}

export interface OceanGkeLaunchSpecUpdatePolicyRollConfig {
    batchSizePercentage: pulumi.Input<number>;
}

export interface OceanRightSizingRuleAttachWorkload {
    namespaces: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleAttachWorkloadNamespace>[]>;
}

export interface OceanRightSizingRuleAttachWorkloadNamespace {
    labels?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleAttachWorkloadNamespaceLabel>[]>;
    namespaceName: pulumi.Input<string>;
    workloads?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleAttachWorkloadNamespaceWorkload>[]>;
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanRightSizingRuleAttachWorkloadNamespaceWorkload {
    regexName?: pulumi.Input<string>;
    workloadName?: pulumi.Input<string>;
    workloadType: pulumi.Input<string>;
}

export interface OceanRightSizingRuleDetachWorkload {
    namespaces: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleDetachWorkloadNamespace>[]>;
}

export interface OceanRightSizingRuleDetachWorkloadNamespace {
    labels?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleDetachWorkloadNamespaceLabel>[]>;
    namespaceName: pulumi.Input<string>;
    workloads?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleDetachWorkloadNamespaceWorkload>[]>;
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceLabel {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface OceanRightSizingRuleDetachWorkloadNamespaceWorkload {
    regexName?: pulumi.Input<string>;
    workloadName?: pulumi.Input<string>;
    workloadType: pulumi.Input<string>;
}

export interface OceanRightSizingRuleRecommendationApplicationBoundary {
    cpuMax?: pulumi.Input<number>;
    cpuMin?: pulumi.Input<number>;
    memoryMax?: pulumi.Input<number>;
    memoryMin?: pulumi.Input<number>;
}

export interface OceanRightSizingRuleRecommendationApplicationInterval {
    monthlyRepetitionBases?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase>[]>;
    repetitionBasis: pulumi.Input<string>;
    weeklyRepetitionBases?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase>[]>;
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBase {
    intervalMonths: pulumi.Input<pulumi.Input<number>[]>;
    weekOfTheMonths: pulumi.Input<pulumi.Input<string>[]>;
    weeklyRepetitionBases?: pulumi.Input<pulumi.Input<inputs.OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase>[]>;
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalMonthlyRepetitionBaseWeeklyRepetitionBase {
    intervalDays: pulumi.Input<pulumi.Input<string>[]>;
    intervalHoursEndTime: pulumi.Input<string>;
    intervalHoursStartTime: pulumi.Input<string>;
}

export interface OceanRightSizingRuleRecommendationApplicationIntervalWeeklyRepetitionBase {
    intervalDays: pulumi.Input<pulumi.Input<string>[]>;
    intervalHoursEndTime: pulumi.Input<string>;
    intervalHoursStartTime: pulumi.Input<string>;
}

export interface OceanRightSizingRuleRecommendationApplicationMinThreshold {
    cpuPercentage?: pulumi.Input<number>;
    memoryPercentage?: pulumi.Input<number>;
}

export interface OceanRightSizingRuleRecommendationApplicationOverheadValue {
    cpuPercentage?: pulumi.Input<number>;
    memoryPercentage?: pulumi.Input<number>;
}

export interface OceanSparkCompute {
    createVngs?: pulumi.Input<boolean>;
    useTaints?: pulumi.Input<boolean>;
}

export interface OceanSparkIngress {
    controller?: pulumi.Input<inputs.OceanSparkIngressController>;
    customEndpoint?: pulumi.Input<inputs.OceanSparkIngressCustomEndpoint>;
    loadBalancer?: pulumi.Input<inputs.OceanSparkIngressLoadBalancer>;
    privateLink?: pulumi.Input<inputs.OceanSparkIngressPrivateLink>;
    serviceAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface OceanSparkIngressController {
    managed?: pulumi.Input<boolean>;
}

export interface OceanSparkIngressCustomEndpoint {
    address?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface OceanSparkIngressLoadBalancer {
    managed?: pulumi.Input<boolean>;
    serviceAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    targetGroupArn?: pulumi.Input<string>;
}

export interface OceanSparkIngressPrivateLink {
    enabled?: pulumi.Input<boolean>;
    vpcEndpointService?: pulumi.Input<string>;
}

export interface OceanSparkLogCollection {
    collectAppLogs?: pulumi.Input<boolean>;
}

export interface OceanSparkSpark {
    additionalAppNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceanSparkWebhook {
    hostNetworkPorts?: pulumi.Input<pulumi.Input<number>[]>;
    useHostNetwork?: pulumi.Input<boolean>;
}

export interface OceancdRolloutSpecFailurePolicy {
    action: pulumi.Input<string>;
}

export interface OceancdRolloutSpecSpotDeployment {
    spotDeploymentsClusterId?: pulumi.Input<string>;
    spotDeploymentsName?: pulumi.Input<string>;
    spotDeploymentsNamespace?: pulumi.Input<string>;
}

export interface OceancdRolloutSpecStrategy {
    args?: pulumi.Input<pulumi.Input<inputs.OceancdRolloutSpecStrategyArg>[]>;
    strategyName: pulumi.Input<string>;
}

export interface OceancdRolloutSpecStrategyArg {
    argName: pulumi.Input<string>;
    argValue?: pulumi.Input<string>;
    valueFrom?: pulumi.Input<inputs.OceancdRolloutSpecStrategyArgValueFrom>;
}

export interface OceancdRolloutSpecStrategyArgValueFrom {
    fieldRef: pulumi.Input<inputs.OceancdRolloutSpecStrategyArgValueFromFieldRef>;
}

export interface OceancdRolloutSpecStrategyArgValueFromFieldRef {
    fieldPath: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTraffic {
    alb?: pulumi.Input<inputs.OceancdRolloutSpecTrafficAlb>;
    ambassador?: pulumi.Input<inputs.OceancdRolloutSpecTrafficAmbassador>;
    canaryService?: pulumi.Input<string>;
    istio?: pulumi.Input<inputs.OceancdRolloutSpecTrafficIstio>;
    nginx?: pulumi.Input<inputs.OceancdRolloutSpecTrafficNginx>;
    pingPong?: pulumi.Input<inputs.OceancdRolloutSpecTrafficPingPong>;
    smi?: pulumi.Input<inputs.OceancdRolloutSpecTrafficSmi>;
    stableService?: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTrafficAlb {
    albAnnotationPrefix?: pulumi.Input<string>;
    albIngress: pulumi.Input<string>;
    albRootService: pulumi.Input<string>;
    servicePort: pulumi.Input<number>;
    stickinessConfig?: pulumi.Input<inputs.OceancdRolloutSpecTrafficAlbStickinessConfig>;
}

export interface OceancdRolloutSpecTrafficAlbStickinessConfig {
    durationSeconds?: pulumi.Input<number>;
    enabled?: pulumi.Input<boolean>;
}

export interface OceancdRolloutSpecTrafficAmbassador {
    mappings: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdRolloutSpecTrafficIstio {
    destinationRule?: pulumi.Input<inputs.OceancdRolloutSpecTrafficIstioDestinationRule>;
    virtualServices: pulumi.Input<pulumi.Input<inputs.OceancdRolloutSpecTrafficIstioVirtualService>[]>;
}

export interface OceancdRolloutSpecTrafficIstioDestinationRule {
    canarySubsetName: pulumi.Input<string>;
    destinationRuleName: pulumi.Input<string>;
    stableSubsetName: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTrafficIstioVirtualService {
    tlsRoutes?: pulumi.Input<pulumi.Input<inputs.OceancdRolloutSpecTrafficIstioVirtualServiceTlsRoute>[]>;
    virtualServiceName: pulumi.Input<string>;
    virtualServiceRoutes?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdRolloutSpecTrafficIstioVirtualServiceTlsRoute {
    port?: pulumi.Input<number>;
    sniHosts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdRolloutSpecTrafficNginx {
    additionalIngressAnnotation?: pulumi.Input<inputs.OceancdRolloutSpecTrafficNginxAdditionalIngressAnnotation>;
    nginxAnnotationPrefix?: pulumi.Input<string>;
    stableIngress: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTrafficNginxAdditionalIngressAnnotation {
    canaryByHeader?: pulumi.Input<string>;
    key1?: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTrafficPingPong {
    pingService: pulumi.Input<string>;
    pongService: pulumi.Input<string>;
}

export interface OceancdRolloutSpecTrafficSmi {
    smiRootService?: pulumi.Input<string>;
    trafficSplitName?: pulumi.Input<string>;
}

export interface OceancdStrategyCanary {
    backgroundVerification?: pulumi.Input<inputs.OceancdStrategyCanaryBackgroundVerification>;
    steps: pulumi.Input<pulumi.Input<inputs.OceancdStrategyCanaryStep>[]>;
}

export interface OceancdStrategyCanaryBackgroundVerification {
    templateNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdStrategyCanaryStep {
    pause?: pulumi.Input<inputs.OceancdStrategyCanaryStepPause>;
    setCanaryScale?: pulumi.Input<inputs.OceancdStrategyCanaryStepSetCanaryScale>;
    setHeaderRoute?: pulumi.Input<inputs.OceancdStrategyCanaryStepSetHeaderRoute>;
    setWeight?: pulumi.Input<number>;
    stepName?: pulumi.Input<string>;
    verification?: pulumi.Input<inputs.OceancdStrategyCanaryStepVerification>;
}

export interface OceancdStrategyCanaryStepPause {
    duration?: pulumi.Input<string>;
}

export interface OceancdStrategyCanaryStepSetCanaryScale {
    matchTrafficWeight?: pulumi.Input<boolean>;
    replicas?: pulumi.Input<number>;
    weight?: pulumi.Input<number>;
}

export interface OceancdStrategyCanaryStepSetHeaderRoute {
    headerRouteName: pulumi.Input<string>;
    matches: pulumi.Input<pulumi.Input<inputs.OceancdStrategyCanaryStepSetHeaderRouteMatch>[]>;
}

export interface OceancdStrategyCanaryStepSetHeaderRouteMatch {
    headerName: pulumi.Input<string>;
    headerValue: pulumi.Input<inputs.OceancdStrategyCanaryStepSetHeaderRouteMatchHeaderValue>;
}

export interface OceancdStrategyCanaryStepSetHeaderRouteMatchHeaderValue {
    exact?: pulumi.Input<string>;
    prefix?: pulumi.Input<string>;
    regex?: pulumi.Input<string>;
}

export interface OceancdStrategyCanaryStepVerification {
    templateNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdStrategyRolling {
    steps: pulumi.Input<pulumi.Input<inputs.OceancdStrategyRollingStep>[]>;
}

export interface OceancdStrategyRollingStep {
    pause?: pulumi.Input<inputs.OceancdStrategyRollingStepPause>;
    stepsName?: pulumi.Input<string>;
    verification?: pulumi.Input<inputs.OceancdStrategyRollingStepVerification>;
}

export interface OceancdStrategyRollingStepPause {
    duration?: pulumi.Input<string>;
}

export interface OceancdStrategyRollingStepVerification {
    templateNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OceancdVerificationProviderCloudWatch {
    iamArn: pulumi.Input<string>;
}

export interface OceancdVerificationProviderDatadog {
    address: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
    appKey: pulumi.Input<string>;
}

export interface OceancdVerificationProviderJenkins {
    apiToken: pulumi.Input<string>;
    baseUrl: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface OceancdVerificationProviderNewRelic {
    accountId: pulumi.Input<string>;
    baseUrlNerdGraph?: pulumi.Input<string>;
    baseUrlRest?: pulumi.Input<string>;
    personalApiKey: pulumi.Input<string>;
    region?: pulumi.Input<string>;
}

export interface OceancdVerificationProviderPrometheus {
    address: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateArg {
    argName: pulumi.Input<string>;
    value?: pulumi.Input<string>;
    valueFrom?: pulumi.Input<inputs.OceancdVerificationTemplateArgValueFrom>;
}

export interface OceancdVerificationTemplateArgValueFrom {
    secretKeyRef?: pulumi.Input<inputs.OceancdVerificationTemplateArgValueFromSecretKeyRef>;
}

export interface OceancdVerificationTemplateArgValueFromSecretKeyRef {
    key: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetric {
    baseline?: pulumi.Input<inputs.OceancdVerificationTemplateMetricBaseline>;
    consecutiveErrorLimit?: pulumi.Input<number>;
    count?: pulumi.Input<number>;
    dryRun?: pulumi.Input<boolean>;
    failureCondition?: pulumi.Input<string>;
    failureLimit?: pulumi.Input<number>;
    initialDelay?: pulumi.Input<string>;
    interval?: pulumi.Input<string>;
    metricsName: pulumi.Input<string>;
    providers: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProvider>[]>;
    successCondition?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricBaseline {
    baselineProviders: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricBaselineBaselineProvider>[]>;
    maxRange?: pulumi.Input<number>;
    minRange?: pulumi.Input<number>;
    threshold: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProvider {
    datadog?: pulumi.Input<inputs.OceancdVerificationTemplateMetricBaselineBaselineProviderDatadog>;
    newRelic?: pulumi.Input<inputs.OceancdVerificationTemplateMetricBaselineBaselineProviderNewRelic>;
    prometheus?: pulumi.Input<inputs.OceancdVerificationTemplateMetricBaselineBaselineProviderPrometheus>;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderDatadog {
    datadogQuery: pulumi.Input<string>;
    duration?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderNewRelic {
    newRelicQuery: pulumi.Input<string>;
    profile?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricBaselineBaselineProviderPrometheus {
    prometheusQuery: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProvider {
    cloudWatch?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderCloudWatch>;
    datadog?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderDatadog>;
    jenkins?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJenkins>;
    job?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJob>;
    newRelic?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderNewRelic>;
    prometheus?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderPrometheus>;
    web?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderWeb>;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatch {
    duration?: pulumi.Input<string>;
    metricDataQueries: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQuery>[]>;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQuery {
    expression?: pulumi.Input<string>;
    id: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    metricStat?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat>;
    period?: pulumi.Input<number>;
    returnData?: pulumi.Input<boolean>;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStat {
    metric?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric>;
    metricPeriod?: pulumi.Input<number>;
    stat?: pulumi.Input<string>;
    unit?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetric {
    dimensions?: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension>[]>;
    metricName: pulumi.Input<string>;
    namespace?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderCloudWatchMetricDataQueryMetricStatMetricDimension {
    dimensionName: pulumi.Input<string>;
    dimensionValue: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderDatadog {
    datadogQuery?: pulumi.Input<string>;
    duration?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderJenkins {
    jenkinsInterval: pulumi.Input<string>;
    jenkinsParameters?: pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJenkinsJenkinsParameters>;
    pipelineName: pulumi.Input<string>;
    timeout: pulumi.Input<string>;
    tlsVerification?: pulumi.Input<boolean>;
}

export interface OceancdVerificationTemplateMetricProviderJenkinsJenkinsParameters {
    parameterKey: pulumi.Input<string>;
    parameterValue: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderJob {
    specs: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJobSpec>[]>;
}

export interface OceancdVerificationTemplateMetricProviderJobSpec {
    backoffLimit?: pulumi.Input<number>;
    jobTemplates: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplate>[]>;
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplate {
    templateSpecs: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec>[]>;
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpec {
    containers: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer>[]>;
    restartPolicy: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderJobSpecJobTemplateTemplateSpecContainer {
    commands: pulumi.Input<pulumi.Input<string>[]>;
    containerName: pulumi.Input<string>;
    image: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderNewRelic {
    newRelicQuery: pulumi.Input<string>;
    profile?: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderPrometheus {
    prometheusQuery: pulumi.Input<string>;
}

export interface OceancdVerificationTemplateMetricProviderWeb {
    body?: pulumi.Input<string>;
    insecure?: pulumi.Input<boolean>;
    jsonPath?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    timeoutSeconds?: pulumi.Input<number>;
    url: pulumi.Input<string>;
    webHeaders?: pulumi.Input<pulumi.Input<inputs.OceancdVerificationTemplateMetricProviderWebWebHeader>[]>;
}

export interface OceancdVerificationTemplateMetricProviderWebWebHeader {
    webHeaderKey: pulumi.Input<string>;
    webHeaderValue: pulumi.Input<string>;
}

export interface OrganizationPolicyPolicyContent {
    statements: pulumi.Input<pulumi.Input<inputs.OrganizationPolicyPolicyContentStatement>[]>;
}

export interface OrganizationPolicyPolicyContentStatement {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    effect: pulumi.Input<string>;
    resources: pulumi.Input<pulumi.Input<string>[]>;
}

export interface OrganizationProgrammaticUserAccount {
    accountId: pulumi.Input<string>;
    accountRole: pulumi.Input<string>;
}

export interface OrganizationProgrammaticUserPolicy {
    policyAccountIds?: pulumi.Input<pulumi.Input<string>[]>;
    policyId: pulumi.Input<string>;
}

export interface OrganizationUserGroupPolicy {
    accountIds: pulumi.Input<pulumi.Input<string>[]>;
    policyId: pulumi.Input<string>;
}

export interface OrganizationUserPolicy {
    policyAccountIds: pulumi.Input<pulumi.Input<string>[]>;
    policyId: pulumi.Input<string>;
}

export interface StatefulNodeAzureAttachDataDisk {
    dataDiskName: pulumi.Input<string>;
    dataDiskResourceGroupName: pulumi.Input<string>;
    lun?: pulumi.Input<number>;
    sizeGb: pulumi.Input<number>;
    storageAccountType: pulumi.Input<string>;
    zone?: pulumi.Input<string>;
}

export interface StatefulNodeAzureBootDiagnostic {
    isEnabled?: pulumi.Input<boolean>;
    storageUrl?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface StatefulNodeAzureDataDisk {
    lun: pulumi.Input<number>;
    sizeGb: pulumi.Input<number>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureDelete {
    diskShouldDeallocate: pulumi.Input<boolean>;
    diskTtlInHours?: pulumi.Input<number>;
    networkShouldDeallocate: pulumi.Input<boolean>;
    networkTtlInHours?: pulumi.Input<number>;
    publicIpShouldDeallocate: pulumi.Input<boolean>;
    publicIpTtlInHours?: pulumi.Input<number>;
    shouldDeregisterFromLb?: pulumi.Input<boolean>;
    shouldTerminateVm: pulumi.Input<boolean>;
    snapshotShouldDeallocate: pulumi.Input<boolean>;
    snapshotTtlInHours?: pulumi.Input<number>;
}

export interface StatefulNodeAzureDetachDataDisk {
    dataDiskName: pulumi.Input<string>;
    dataDiskResourceGroupName: pulumi.Input<string>;
    shouldDeallocate: pulumi.Input<boolean>;
    ttlInHours?: pulumi.Input<number>;
}

export interface StatefulNodeAzureExtension {
    apiVersion: pulumi.Input<string>;
    minorVersionAutoUpgrade: pulumi.Input<boolean>;
    name: pulumi.Input<string>;
    protectedSettings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    publicSettings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    publisher: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureHealth {
    autoHealing: pulumi.Input<boolean>;
    gracePeriod?: pulumi.Input<number>;
    healthCheckTypes: pulumi.Input<pulumi.Input<string>[]>;
    unhealthyDuration?: pulumi.Input<number>;
}

export interface StatefulNodeAzureImage {
    customImages?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureImageCustomImage>[]>;
    galleries?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureImageGallery>[]>;
    marketplaceImages?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureImageMarketplaceImage>[]>;
}

export interface StatefulNodeAzureImageCustomImage {
    customImageResourceGroupName: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface StatefulNodeAzureImageGallery {
    galleryName: pulumi.Input<string>;
    galleryResourceGroupName: pulumi.Input<string>;
    imageName: pulumi.Input<string>;
    spotAccountId?: pulumi.Input<string>;
    versionName: pulumi.Input<string>;
}

export interface StatefulNodeAzureImageMarketplaceImage {
    offer: pulumi.Input<string>;
    publisher: pulumi.Input<string>;
    sku: pulumi.Input<string>;
    version: pulumi.Input<string>;
}

export interface StatefulNodeAzureImportVm {
    drainingTimeout?: pulumi.Input<number>;
    originalVmName: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
    resourcesRetentionTime?: pulumi.Input<number>;
}

export interface StatefulNodeAzureLoadBalancer {
    backendPoolNames: pulumi.Input<pulumi.Input<string>[]>;
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
    sku?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureLogin {
    password?: pulumi.Input<string>;
    sshPublicKey?: pulumi.Input<string>;
    userName: pulumi.Input<string>;
}

export interface StatefulNodeAzureManagedServiceIdentity {
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetwork {
    networkInterfaces: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureNetworkNetworkInterface>[]>;
    networkResourceGroupName: pulumi.Input<string>;
    virtualNetworkName: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetworkNetworkInterface {
    additionalIpConfigurations?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration>[]>;
    applicationSecurityGroups?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup>[]>;
    assignPublicIp?: pulumi.Input<boolean>;
    enableIpForwarding?: pulumi.Input<boolean>;
    isPrimary: pulumi.Input<boolean>;
    networkSecurityGroups?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup>[]>;
    privateIpAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    publicIpSku?: pulumi.Input<string>;
    publicIps?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureNetworkNetworkInterfacePublicIp>[]>;
    subnetName: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceAdditionalIpConfiguration {
    name: pulumi.Input<string>;
    privateIpAddressVersion: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceApplicationSecurityGroup {
    name: pulumi.Input<string>;
    networkResourceGroupName: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetworkNetworkInterfaceNetworkSecurityGroup {
    name?: pulumi.Input<string>;
    networkResourceGroupName?: pulumi.Input<string>;
}

export interface StatefulNodeAzureNetworkNetworkInterfacePublicIp {
    name: pulumi.Input<string>;
    networkResourceGroupName: pulumi.Input<string>;
}

export interface StatefulNodeAzureOsDisk {
    caching?: pulumi.Input<string>;
    sizeGb?: pulumi.Input<number>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureProximityPlacementGroup {
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface StatefulNodeAzureSchedulingTask {
    cronExpression: pulumi.Input<string>;
    isEnabled: pulumi.Input<boolean>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureSecret {
    sourceVaults: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSecretSourceVault>[]>;
    vaultCertificates: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureSecretVaultCertificate>[]>;
}

export interface StatefulNodeAzureSecretSourceVault {
    name: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
}

export interface StatefulNodeAzureSecretVaultCertificate {
    certificateStore?: pulumi.Input<string>;
    certificateUrl?: pulumi.Input<string>;
}

export interface StatefulNodeAzureSecurity {
    confidentialOsDiskEncryption?: pulumi.Input<boolean>;
    encryptionAtHost?: pulumi.Input<boolean>;
    secureBootEnabled?: pulumi.Input<boolean>;
    securityType?: pulumi.Input<string>;
    vtpmEnabled?: pulumi.Input<boolean>;
}

export interface StatefulNodeAzureSignal {
    timeout: pulumi.Input<number>;
    type: pulumi.Input<string>;
}

export interface StatefulNodeAzureStrategy {
    availabilityVsCost?: pulumi.Input<number>;
    capacityReservations?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureStrategyCapacityReservation>[]>;
    drainingTimeout?: pulumi.Input<number>;
    fallbackToOnDemand: pulumi.Input<boolean>;
    odWindows?: pulumi.Input<pulumi.Input<string>[]>;
    optimizationWindows?: pulumi.Input<pulumi.Input<string>[]>;
    preferredLifeCycle?: pulumi.Input<string>;
    revertToSpot?: pulumi.Input<inputs.StatefulNodeAzureStrategyRevertToSpot>;
    vmAdmins?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface StatefulNodeAzureStrategyCapacityReservation {
    capacityReservationGroups?: pulumi.Input<pulumi.Input<inputs.StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup>[]>;
    shouldUtilize: pulumi.Input<boolean>;
    utilizationStrategy: pulumi.Input<string>;
}

export interface StatefulNodeAzureStrategyCapacityReservationCapacityReservationGroup {
    crgName: pulumi.Input<string>;
    crgResourceGroupName: pulumi.Input<string>;
    crgShouldPrioritize?: pulumi.Input<boolean>;
}

export interface StatefulNodeAzureStrategyRevertToSpot {
    performAt: pulumi.Input<string>;
}

export interface StatefulNodeAzureTag {
    tagKey: pulumi.Input<string>;
    tagValue?: pulumi.Input<string>;
}

export interface StatefulNodeAzureUpdateState {
    state: pulumi.Input<string>;
}

export interface StatefulNodeAzureVmSizes {
    odSizes: pulumi.Input<pulumi.Input<string>[]>;
    preferredSpotSizes?: pulumi.Input<pulumi.Input<string>[]>;
    spotSizes: pulumi.Input<pulumi.Input<string>[]>;
}
