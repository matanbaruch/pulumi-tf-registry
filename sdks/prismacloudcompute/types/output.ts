// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AdmissionPolicyRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect to be used. Can be set to 'allow', 'block' or 'alert'.
     */
    effect?: string;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Policy script in Rego syntax.
     */
    script?: string;
}

export interface AlertprofilePolicy {
    /**
     * Admission audits
     */
    admission?: outputs.AlertprofilePolicyAdmission;
    /**
     * WAAS Firewall (Agentless)
     */
    agentlessAppFirewall?: outputs.AlertprofilePolicyAgentlessAppFirewall;
    /**
     * WAAS Firewall (App-Embedded Defender)
     */
    appEmbeddedAppFirewall?: outputs.AlertprofilePolicyAppEmbeddedAppFirewall;
    /**
     * App-Embedded Defender runtime
     */
    appEmbeddedRuntime?: outputs.AlertprofilePolicyAppEmbeddedRuntime;
    /**
     * Cloud discovery
     */
    cloudDiscovery?: outputs.AlertprofilePolicyCloudDiscovery;
    /**
     * Code repository vulnerabilities
     */
    codeRepoVulnerability?: outputs.AlertprofilePolicyCodeRepoVulnerability;
    /**
     * WAAS Firewall (container)
     */
    containerAppFirewall?: outputs.AlertprofilePolicyContainerAppFirewall;
    containerCompliance?: outputs.AlertprofilePolicyContainerCompliance;
    /**
     * Container and image compliance
     */
    containerComplianceScan?: outputs.AlertprofilePolicyContainerComplianceScan;
    /**
     * Container runtime
     */
    containerRuntime?: outputs.AlertprofilePolicyContainerRuntime;
    /**
     * Deployed image vulnerabilities
     */
    containerVulnerability?: outputs.AlertprofilePolicyContainerVulnerability;
    /**
     * Defender health
     */
    defender?: outputs.AlertprofilePolicyDefender;
    /**
     * Access
     */
    docker?: outputs.AlertprofilePolicyDocker;
    /**
     * WAAS Firewall (host)
     */
    hostAppFirewall?: outputs.AlertprofilePolicyHostAppFirewall;
    hostCompliance?: outputs.AlertprofilePolicyHostCompliance;
    /**
     * Host compliance
     */
    hostComplianceScan?: outputs.AlertprofilePolicyHostComplianceScan;
    /**
     * Host runtime
     */
    hostRuntime?: outputs.AlertprofilePolicyHostRuntime;
    /**
     * Host vulnerabilities
     */
    hostVulnerability?: outputs.AlertprofilePolicyHostVulnerability;
    /**
     * Incidents
     */
    incident?: outputs.AlertprofilePolicyIncident;
    /**
     * Kubernetes audits
     */
    kubernetesAudit?: outputs.AlertprofilePolicyKubernetesAudit;
    /**
     * Cloud Native Network Segmentation (CNNS)
     */
    networkFirewall?: outputs.AlertprofilePolicyNetworkFirewall;
    /**
     * Registry image vulnerabilities
     */
    registryVulnerability?: outputs.AlertprofilePolicyRegistryVulnerability;
    /**
     * WAAS Firewall (serverless)
     */
    serverlessAppFirewall?: outputs.AlertprofilePolicyServerlessAppFirewall;
    /**
     * Serverless runtime
     */
    serverlessRuntime?: outputs.AlertprofilePolicyServerlessRuntime;
    /**
     * VM images compliance
     */
    vmCompliance?: outputs.AlertprofilePolicyVmCompliance;
    /**
     * VM images vulnerabilities
     */
    vmVulnerability?: outputs.AlertprofilePolicyVmVulnerability;
    /**
     * WAAS health
     */
    waasHealth?: outputs.AlertprofilePolicyWaasHealth;
}

export interface AlertprofilePolicyAdmission {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyAgentlessAppFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyAppEmbeddedAppFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyAppEmbeddedRuntime {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyCloudDiscovery {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyCodeRepoVulnerability {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyContainerAppFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyContainerCompliance {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyContainerComplianceScan {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyContainerRuntime {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyContainerVulnerability {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyDefender {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyDocker {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyHostAppFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyHostCompliance {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyHostComplianceScan {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyHostRuntime {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyHostVulnerability {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyIncident {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyKubernetesAudit {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyNetworkFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyRegistryVulnerability {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyServerlessAppFirewall {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyServerlessRuntime {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyVmCompliance {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyVmVulnerability {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofilePolicyWaasHealth {
    allRules: boolean;
    enabled: boolean;
    rules: string[];
}

export interface AlertprofileWebhook {
    /**
     * Credential ID
     */
    credentialId?: string;
    /**
     * Custom CA Cert
     */
    customCa?: string;
    /**
     * Custom JSON payload
     */
    customJson?: string;
    /**
     * Webhook URL
     */
    url?: string;
}

export interface CiCoderepoCompliancePolicyRule {
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore' or 'alert'.
     */
    effect?: string;
    /**
     * License compliance section.
     */
    license?: outputs.CiCoderepoCompliancePolicyRuleLicense;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
}

export interface CiCoderepoCompliancePolicyRuleLicense {
    /**
     * Threshold for generating license alerts.
     */
    alertThreshold?: outputs.CiCoderepoCompliancePolicyRuleLicenseAlertThreshold;
    /**
     * Threshold for generating license alerts.
     */
    blockThreshold?: outputs.CiCoderepoCompliancePolicyRuleLicenseBlockThreshold;
    /**
     * List of licenses with critical level of violation.
     */
    criticals?: string[];
    /**
     * List of licenses with high level of violation.
     */
    highs?: string[];
    /**
     * List of licenses with low level of violation.
     */
    lows?: string[];
    /**
     * List of licenses with medium level of violation.
     */
    media?: string[];
}

export interface CiCoderepoCompliancePolicyRuleLicenseAlertThreshold {
    /**
     * Whether or not to disable compliance alerts.
     */
    enabled?: boolean;
    /**
     * Minimum compliance severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiCoderepoCompliancePolicyRuleLicenseBlockThreshold {
    /**
     * Whether or not to disable compliance alerts.
     */
    enabled?: boolean;
    /**
     * Minimum compliance severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiCoderepoVulnerabilityPolicyRule {
    /**
     * Threshold for generating alerts.
     */
    alertThreshold?: outputs.CiCoderepoVulnerabilityPolicyRuleAlertThreshold;
    /**
     * Message to display when an coderepo is blocked.
     */
    blockMessage?: string;
    /**
     * Threshold for blocking.
     */
    blockThreshold?: outputs.CiCoderepoVulnerabilityPolicyRuleBlockThreshold;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of rules for handling specific CVEs.
     */
    cveRules?: outputs.CiCoderepoVulnerabilityPolicyRuleCveRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Number of days to suppress the rule's block effect. Measured from date the vulnerability was fixed. If there's no fix, measured from the date the vulnerability was published.
     */
    graceDays?: number;
    /**
     * Composite alternative to grace_days. Allows to set the effect for different severity level.
     */
    graceDaysPolicy?: outputs.CiCoderepoVulnerabilityPolicyRuleGraceDaysPolicy;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to apply the rule only when vendor fixes are available.
     */
    onlyFixed?: boolean;
    /**
     * List of rules for handling specific tags.
     */
    tagRules?: outputs.CiCoderepoVulnerabilityPolicyRuleTagRule[];
    /**
     * Whether or not to display a detailed message when blocked.
     */
    verbose?: boolean;
}

export interface CiCoderepoVulnerabilityPolicyRuleAlertThreshold {
    /**
     * Whether or not to disable vulnerability alerts.
     */
    disabled?: boolean;
    /**
     * Minimum vulnerability severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiCoderepoVulnerabilityPolicyRuleBlockThreshold {
    /**
     * Whether or not to block when vulnerabilities are found.
     */
    enabled?: boolean;
    /**
     * Minimum vulnerability severity to block. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiCoderepoVulnerabilityPolicyRuleCveRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if the CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * CVE rule expiration.
     */
    expiration?: outputs.CiCoderepoVulnerabilityPolicyRuleCveRuleExpiration;
    /**
     * CVE ID.
     */
    id?: string;
}

export interface CiCoderepoVulnerabilityPolicyRuleCveRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the CVE rule expiration.
     */
    enabled?: boolean;
}

export interface CiCoderepoVulnerabilityPolicyRuleGraceDaysPolicy {
    critical?: number;
    high?: number;
    low?: number;
    medium?: number;
}

export interface CiCoderepoVulnerabilityPolicyRuleTagRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if a tagged CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * Tag rule expiration.
     */
    expiration?: outputs.CiCoderepoVulnerabilityPolicyRuleTagRuleExpiration;
    /**
     * Tag name.
     */
    name?: string;
}

export interface CiCoderepoVulnerabilityPolicyRuleTagRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the tag rule expiration.
     */
    enabled?: boolean;
}

export interface CiImageCompliancePolicyRule {
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Compliance checks. Omitted checks are ignored.
     */
    complianceChecks?: outputs.CiImageCompliancePolicyRuleComplianceCheck[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to provide verbose output for blocked requests.
     */
    verbose?: boolean;
}

export interface CiImageCompliancePolicyRuleComplianceCheck {
    /**
     * Whether or not to block if this check is failed. Setting to 'false' will only alert if the check is failed.
     */
    block?: boolean;
    /**
     * Compliance check number.
     */
    id?: number;
}

export interface CiImageVulnerabilityPolicyRule {
    /**
     * Threshold for generating alerts.
     */
    alertThreshold?: outputs.CiImageVulnerabilityPolicyRuleAlertThreshold;
    /**
     * Message to display when an image is blocked.
     */
    blockMessage?: string;
    /**
     * Threshold for blocking.
     */
    blockThreshold?: outputs.CiImageVulnerabilityPolicyRuleBlockThreshold;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of rules for handling specific CVEs.
     */
    cveRules?: outputs.CiImageVulnerabilityPolicyRuleCveRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Number of days to suppress the rule's block effect. Measured from date the vulnerability was fixed. If there's no fix, measured from the date the vulnerability was published.
     */
    graceDays?: number;
    /**
     * Composite alternative to grace_days. Allows to set the effect for different severity level.
     */
    graceDaysPolicy?: outputs.CiImageVulnerabilityPolicyRuleGraceDaysPolicy;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to apply the rule only when vendor fixes are available.
     */
    onlyFixed?: boolean;
    /**
     * List of rules for handling specific tags.
     */
    tagRules?: outputs.CiImageVulnerabilityPolicyRuleTagRule[];
    /**
     * Whether or not to display a detailed message when blocked.
     */
    verbose?: boolean;
}

export interface CiImageVulnerabilityPolicyRuleAlertThreshold {
    /**
     * Whether or not to disable vulnerability alerts.
     */
    disabled?: boolean;
    /**
     * Minimum vulnerability severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiImageVulnerabilityPolicyRuleBlockThreshold {
    /**
     * Whether or not to block when vulnerabilities are found.
     */
    enabled?: boolean;
    /**
     * Minimum vulnerability severity to block. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CiImageVulnerabilityPolicyRuleCveRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if the CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * CVE rule expiration.
     */
    expiration?: outputs.CiImageVulnerabilityPolicyRuleCveRuleExpiration;
    /**
     * CVE ID.
     */
    id?: string;
}

export interface CiImageVulnerabilityPolicyRuleCveRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the CVE rule expiration.
     */
    enabled?: boolean;
}

export interface CiImageVulnerabilityPolicyRuleGraceDaysPolicy {
    critical?: number;
    high?: number;
    low?: number;
    medium?: number;
}

export interface CiImageVulnerabilityPolicyRuleTagRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if a tagged CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * Tag rule expiration.
     */
    expiration?: outputs.CiImageVulnerabilityPolicyRuleTagRuleExpiration;
    /**
     * Tag name.
     */
    name?: string;
}

export interface CiImageVulnerabilityPolicyRuleTagRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the tag rule expiration.
     */
    enabled?: boolean;
}

export interface CloudAccountAgentlessScanSpec {
    /**
     * When enabled, Prisma Cloud automatically spins up multiple scanners in the environment to parallel scan for faster results.
     */
    autoScale?: boolean;
    /**
     * Console URL.
     */
    consoleAddr?: string;
    /**
     * These tags will be applied to resources created by Prisma Cloud in the Agentless scan process.
     */
    customTags?: outputs.CloudAccountAgentlessScanSpecCustomTag[];
    enabled?: boolean;
    /**
     * Indicates whether the Prisma Cloud scanner will be centralized in the hub account and scan the target accounts from there (enabled) or the actual scanning will occur within each account that is being scanned (false).
     */
    hubAccount?: boolean;
    includedTags?: outputs.CloudAccountAgentlessScanSpecIncludedTag[];
    /**
     * Example: http://proxyserver.company.com:8081
     */
    proxyAddress?: string;
    /**
     * Proxy CA certificate. Required when using TLS intercept proxies.
     */
    proxyCa?: string;
    regions?: string[];
    /**
     * Scan non running hosts.
     */
    scanNonRunning?: boolean;
    /**
     * Limit on the number of scanners that Prisma Cloud can spin up at any given time.
     */
    scanners?: number;
    /**
     * Security group name. Should be identical and unique across all regions.
     */
    securityGroup?: string;
    /**
     * When enabled, Prisma Cloud will scan this account even if there are missing permissions.
     */
    skipPermissionsCheck?: boolean;
    /**
     * Subnet name. Should be identical and unique across all regions. Note: if the subnet allows auto-assignment of public IPs, a public IP will be attached to the scanner instance.
     */
    subnet?: string;
}

export interface CloudAccountAgentlessScanSpecCustomTag {
    key?: string;
    value?: string;
}

export interface CloudAccountAgentlessScanSpecIncludedTag {
    key?: string;
    value?: string;
}

export interface CloudAccountCredential {
    accountGuid?: string;
    /**
     * Account identifier (username, access key, etc.).
     */
    accountId?: string;
    /**
     * The plain and encrypted version of the API token (the plain version is never stored in the database)
     */
    apiToken?: outputs.CloudAccountCredentialApiToken;
    /**
     * CA certificate for certificate-based authentication.
     */
    caCert?: string;
    /**
     * Description of the credential.
     */
    description?: string;
    /**
     * Indicates if the credential is external (true) or not (false).
     */
    external?: boolean;
    /**
     * IBM Cloud account GUID.
     */
    ibmAccountGuid?: string;
    /**
     * The ID of the credential.
     */
    id: string;
    /**
     * Unique name for the credential.
     */
    name: string;
    /**
     * Amazon Resource Name (ARN) of the role to assume.
     */
    roleArn?: string;
    /**
     * Plain and encrypted version of the credential (the plain version is never stored in the database)
     */
    secret?: outputs.CloudAccountCredentialSecret;
    /**
     * SkipVerify if should skip certificate verification in tls communication.
     */
    skipCertVerification?: boolean;
    /**
     * Credential type.
     */
    type?: string;
    /**
     * URL is the server base url.
     */
    url?: string;
    /**
     * Indicates if authentication should be done with the instance's attached credentials (EC2 IAM Role).
     */
    useAwsRole?: boolean;
    /**
     * Indicates whether to use the regional STS endpoint for an STS session.
     */
    useStsRegionalEndpoint?: boolean;
}

export interface CloudAccountCredentialApiToken {
    /**
     * Encrypted value for the secret
     */
    encrypted: string;
    /**
     * Plain text value for the secret. Note: marshalling to JSON will convert to an encrypted value
     */
    plain?: string;
}

export interface CloudAccountCredentialSecret {
    /**
     * Encrypted value for the secret
     */
    encrypted: string;
    /**
     * Plain text value for the secret. Note: marshalling to JSON will convert to an encrypted value
     */
    plain?: string;
}

export interface CloudAccountServerlessScanSpec {
    /**
     * The number of most recently modified functions to scan, on a per-scope basis. For example, if there are 100 functions in scope, and you set this value to 50, Prisma Cloud will only scan the fifty most recently modified functions. To scan all functions in scope, set this to 0.
     */
    cap?: number;
    enabled?: boolean;
    /**
     * Indicates whether Prisma Cloud will scan all versions (enabled) or only the latest versions (false) of serverless functions.
     */
    scanAllVersions?: boolean;
    /**
     * Indicates whether or not Prisma Cloud will scan Lambda layers.
     */
    scanLayers?: boolean;
}

export interface CoderepoCompliancePolicyRule {
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore' or 'alert'.
     */
    effect?: string;
    /**
     * License compliance section.
     */
    license?: outputs.CoderepoCompliancePolicyRuleLicense;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
}

export interface CoderepoCompliancePolicyRuleLicense {
    /**
     * Threshold for generating license alerts.
     */
    alertThreshold?: outputs.CoderepoCompliancePolicyRuleLicenseAlertThreshold;
    /**
     * List of licenses with critical level of violation.
     */
    criticals?: string[];
    /**
     * List of licenses with high level of violation.
     */
    highs?: string[];
    /**
     * List of licenses with low level of violation.
     */
    lows?: string[];
    /**
     * List of licenses with medium level of violation.
     */
    media?: string[];
}

export interface CoderepoCompliancePolicyRuleLicenseAlertThreshold {
    /**
     * Whether or not to disable compliance alerts.
     */
    enabled?: boolean;
    /**
     * Minimum compliance severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CoderepoVulnerabilityPolicyRule {
    /**
     * Threshold for generating alerts.
     */
    alertThreshold?: outputs.CoderepoVulnerabilityPolicyRuleAlertThreshold;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Whether or not to create PRs when fixes are available.
     */
    createPr?: boolean;
    /**
     * List of rules for handling specific CVEs.
     */
    cveRules?: outputs.CoderepoVulnerabilityPolicyRuleCveRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore' or 'alert'.
     */
    effect?: string;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to apply the rule only when vendor fixes are available.
     */
    onlyFixed?: boolean;
    /**
     * List of rules for handling specific tags.
     */
    tagRules?: outputs.CoderepoVulnerabilityPolicyRuleTagRule[];
    /**
     * Whether or not to display a detailed message when blocked.
     */
    verbose?: boolean;
}

export interface CoderepoVulnerabilityPolicyRuleAlertThreshold {
    /**
     * Whether or not to disable vulnerability alerts.
     */
    disabled?: boolean;
    /**
     * Minimum vulnerability severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface CoderepoVulnerabilityPolicyRuleCveRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if the CVE is found. Can be set to 'ignore' or 'alert'.
     */
    effect?: string;
    /**
     * CVE rule expiration.
     */
    expiration?: outputs.CoderepoVulnerabilityPolicyRuleCveRuleExpiration;
    /**
     * CVE ID.
     */
    id?: string;
}

export interface CoderepoVulnerabilityPolicyRuleCveRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the CVE rule expiration.
     */
    enabled?: boolean;
}

export interface CoderepoVulnerabilityPolicyRuleTagRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if a tagged CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * Tag rule expiration.
     */
    expiration?: outputs.CoderepoVulnerabilityPolicyRuleTagRuleExpiration;
    /**
     * Tag name.
     */
    name?: string;
}

export interface CoderepoVulnerabilityPolicyRuleTagRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the tag rule expiration.
     */
    enabled?: boolean;
}

export interface ContainerCompliancePolicyRule {
    /**
     * Message to display for blocked requests.
     */
    blockMessage?: string;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Compliance checks. Omitted checks are ignored.
     */
    complianceChecks?: outputs.ContainerCompliancePolicyRuleComplianceCheck[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to report both failed and passed compliance checks.
     */
    showPassedChecks?: boolean;
    /**
     * Whether or not to provide verbose output for blocked requests.
     */
    verbose?: boolean;
}

export interface ContainerCompliancePolicyRuleComplianceCheck {
    /**
     * Whether or not to block if this check is failed. Setting to 'false' will only alert if the check is failed.
     */
    block?: boolean;
    /**
     * Compliance check number.
     */
    id?: number;
}

export interface ContainerRuntimePolicyRule {
    /**
     * Whether or not to enable advanced protection.
     */
    advancedProtectionEffect?: string;
    /**
     * Whether or not to enable cloud metadata access monitoring.
     */
    cloudMetadataEnforcementEffect?: string;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of custom rules.
     */
    customRules?: outputs.ContainerRuntimePolicyRuleCustomRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * DNS configuration.
     */
    dns?: outputs.ContainerRuntimePolicyRuleDns;
    /**
     * File system configuration.
     */
    filesystem?: outputs.ContainerRuntimePolicyRuleFilesystem;
    /**
     * Whether or not to detect attacks against the cluster.
     */
    kubernetesEnforcementEffect?: string;
    /**
     * Unique name of the rule.
     */
    name: string;
    /**
     * Network configuration.
     */
    network?: outputs.ContainerRuntimePolicyRuleNetwork;
    /**
     * Free-form text field.
     */
    notes?: string;
    previousName?: string;
    /**
     * Processes configuration.
     */
    processes?: outputs.ContainerRuntimePolicyRuleProcesses;
    skipExecSessions?: boolean;
    /**
     * The effect to be used when WildFire analysis is enabled. Can be set to 'block', 'alert', or 'disable'.
     */
    wildfireAnalysis?: string;
}

export interface ContainerRuntimePolicyRuleCustomRule {
    /**
     * The action to perform if the custom rule applies. Can be set to 'audit' or 'incident'.
     */
    action?: string;
    /**
     * The effect to be used. Can be set to 'block', 'prevent', 'alert', or 'allow'.
     */
    effect?: string;
    /**
     * Custom rule number.
     */
    id?: number;
}

export interface ContainerRuntimePolicyRuleDns {
    defaultEffect?: string;
    disabled?: boolean;
    domainLists?: outputs.ContainerRuntimePolicyRuleDnsDomainList[];
}

export interface ContainerRuntimePolicyRuleDnsDomainList {
    /**
     * Allowed domains. Wildcard prefixes are supported.
     */
    alloweds?: string[];
    /**
     * Denied domains. Wildcard prefixes are supported.
     */
    denieds?: string[];
    effect?: string;
}

export interface ContainerRuntimePolicyRuleFilesystem {
    allowedLists?: string[];
    backdoorFilesEffect?: string;
    defaultEffect?: string;
    deniedLists?: outputs.ContainerRuntimePolicyRuleFilesystemDeniedList[];
    disabled?: boolean;
    encryptedBinariesEffect?: string;
    newFilesEffect?: string;
    suspiciousElfHeadersEffect?: string;
}

export interface ContainerRuntimePolicyRuleFilesystemDeniedList {
    effect?: string;
    paths?: string[];
}

export interface ContainerRuntimePolicyRuleNetwork {
    allowedIps?: string[];
    defaultEffect?: string;
    deniedIps?: string[];
    deniedIpsEffect?: string;
    disabled?: boolean;
    listeningPorts?: outputs.ContainerRuntimePolicyRuleNetworkListeningPort[];
    modifiedProcEffect?: string;
    outboundPorts?: outputs.ContainerRuntimePolicyRuleNetworkOutboundPort[];
    portScanEffect?: string;
    rawSocketsEffect?: string;
}

export interface ContainerRuntimePolicyRuleNetworkListeningPort {
    /**
     * List of denied outbound ports.
     */
    alloweds?: outputs.ContainerRuntimePolicyRuleNetworkListeningPortAllowed[];
    /**
     * List of denied outbound ports.
     */
    denieds?: outputs.ContainerRuntimePolicyRuleNetworkListeningPortDenied[];
    effect?: string;
}

export interface ContainerRuntimePolicyRuleNetworkListeningPortAllowed {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface ContainerRuntimePolicyRuleNetworkListeningPortDenied {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface ContainerRuntimePolicyRuleNetworkOutboundPort {
    /**
     * List of allowed outbound ports.
     */
    alloweds?: outputs.ContainerRuntimePolicyRuleNetworkOutboundPortAllowed[];
    /**
     * List of denied outbound ports.
     */
    denieds?: outputs.ContainerRuntimePolicyRuleNetworkOutboundPortDenied[];
    effect?: string;
}

export interface ContainerRuntimePolicyRuleNetworkOutboundPortAllowed {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface ContainerRuntimePolicyRuleNetworkOutboundPortDenied {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface ContainerRuntimePolicyRuleProcesses {
    /**
     * List of allowed processes.
     */
    allowedLists?: string[];
    /**
     * Whether or not to check for parent-child relationship when comparing spawned processes in the model.
     */
    checkParentChild?: boolean;
    cryptoMinersEffect?: string;
    defaultEffect?: string;
    deniedLists?: outputs.ContainerRuntimePolicyRuleProcessesDeniedList[];
    /**
     * Whether or not skip detection of reverse shells.
     */
    disabled?: boolean;
    lateralMovementEffect?: string;
    modifiedProcessEffect?: string;
    reverseShellEffect?: string;
    suidBinariesEffect?: string;
}

export interface ContainerRuntimePolicyRuleProcessesDeniedList {
    effect?: string;
    paths?: string[];
}

export interface CredentialApiToken {
    /**
     * Encrypted value for the secret
     */
    encrypted: string;
    /**
     * Plain text value for the secret. Note: marshalling to JSON will convert to an encrypted value
     */
    plain?: string;
}

export interface CredentialSecret {
    /**
     * Encrypted value for the secret
     */
    encrypted: string;
    /**
     * Plain text value for the secret. Note: marshalling to JSON will convert to an encrypted value
     */
    plain?: string;
}

export interface GroupPermission {
    /**
     * Specifies the set of Defenders in-scope for working on a scan job.
     */
    collections?: string[];
    /**
     * Names of projects which the user can access.
     */
    project?: string;
}

export interface HostCompliancePolicyRule {
    /**
     * Message to display for blocked requests.
     */
    blockMessage?: string;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * Compliance checks. Omitted checks are ignored.
     */
    complianceChecks?: outputs.HostCompliancePolicyRuleComplianceCheck[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to report both failed and passed compliance checks.
     */
    showPassedChecks?: boolean;
    /**
     * Whether or not to provide verbose output for blocked requests.
     */
    verbose?: boolean;
}

export interface HostCompliancePolicyRuleComplianceCheck {
    /**
     * Whether or not to block if this check is failed. Setting to 'false' will only alert if the check is failed.
     */
    block?: boolean;
    /**
     * Compliance check number.
     */
    id?: number;
}

export interface HostRuntimePolicyRule {
    /**
     * Activities configuration.
     */
    activities?: outputs.HostRuntimePolicyRuleActivities;
    /**
     * Anti-malware configuration.
     */
    antimalware?: outputs.HostRuntimePolicyRuleAntimalware;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of custom rules.
     */
    customRules?: outputs.HostRuntimePolicyRuleCustomRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * DNS configuration.
     */
    dns?: outputs.HostRuntimePolicyRuleDns;
    /**
     * List of file integrity rules.
     */
    fileIntegrityRules?: outputs.HostRuntimePolicyRuleFileIntegrityRule[];
    /**
     * List of log inspection rules.
     */
    logInspectionRules?: outputs.HostRuntimePolicyRuleLogInspectionRule[];
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Network configuration.
     */
    network?: outputs.HostRuntimePolicyRuleNetwork;
    /**
     * Free-form text field.
     */
    notes?: string;
}

export interface HostRuntimePolicyRuleActivities {
    /**
     * Whether or not to disable host activity collection.
     */
    disabled?: boolean;
    /**
     * Whether or not to collect docker commands.
     */
    dockerEnabled?: boolean;
    /**
     * Whether or not to collect read-only docker commands.
     */
    readonlyDockerEnabled?: boolean;
    /**
     * Whether or not to collect activity from services.
     */
    serviceActivitiesEnabled?: boolean;
    /**
     * Whether or not to collect new SSH sessions.
     */
    sshdEnabled?: boolean;
    /**
     * Whether or not to collect commands ran with sudo or su.
     */
    sudoEnabled?: boolean;
}

export interface HostRuntimePolicyRuleAntimalware {
    /**
     * List of processes and files to allow during anti-malware checks.
     */
    allowedProcesses?: string[];
    /**
     * The effect to be used when crypto miners are detected. Can be set to 'prevent', 'alert', or 'disable'.
     */
    cryptoMiners?: string;
    /**
     * The effect to be used when malware from custom feeds is detected. Can be set to 'alert' or 'disable'.
     */
    customFeed?: string;
    /**
     * Denied processes configuration.
     */
    deniedProcesses?: outputs.HostRuntimePolicyRuleAntimalwareDeniedProcesses;
    /**
     * Whether or not to detect compiler-generated binaries.
     */
    detectCompilerGeneratedBinary?: boolean;
    /**
     * The effect to be used when encrypted or packed binaries are detected. Can be set to 'alert' or 'disable'.
     */
    encryptedBinaries?: string;
    /**
     * The effect to be used when execution flow hijacking is detected. Can be set to 'alert' or 'disable'.
     */
    executionFlowHijack?: string;
    /**
     * The effect to be used when malware according to Prisma Cloud Compute is detected. Can be set to 'alert' or 'disable'.
     */
    intelligenceFeed?: string;
    /**
     * The effect to be used when reverse shell attacks are detected. Can be set to 'alert' or 'disable'.
     */
    reverseShell?: string;
    /**
     * The effect to be used when non-packaged binaries are created or ran by a service. Can be set to 'prevent', 'alert', or 'disable'.
     */
    serviceUnknownOriginBinary?: string;
    /**
     * Whether or not to skip tracking of SSH events.
     */
    skipSshTracking?: boolean;
    /**
     * The effect to be used when binaries with suspicious ELF headers are detected. Can be set to 'alert' or 'disable'.
     */
    suspiciousElfHeaders?: string;
    /**
     * The effect to be used when processes are ran from a temporary file system. Can be set to 'prevent', 'alert', or 'disable'.
     */
    tempFilesystemProcesses?: string;
    /**
     * The effect to be used when non-packaged binaries are created or ran by a user. Can be set to 'prevent', 'alert', or 'disable'.
     */
    userUnknownOriginBinary?: string;
    /**
     * The effect to be used when webshell attacks are detected. Can be set to 'prevent', 'alert', or 'disable'.
     */
    webshell?: string;
    /**
     * The effect to be used when WildFire analysis is enabled. Can be set to 'alert' or 'disable'.
     */
    wildfireAnalysis?: string;
}

export interface HostRuntimePolicyRuleAntimalwareDeniedProcesses {
    /**
     * The effect to be used. Can be set to 'prevent' or 'alert'.
     */
    effect?: string;
    /**
     * List of processes and files to deny during anti-malware checks.
     */
    paths?: string[];
}

export interface HostRuntimePolicyRuleCustomRule {
    /**
     * The action to perform if the custom rule applies. Can be set to 'audit' or 'incident'.
     */
    action?: string;
    /**
     * The effect to be used. Can be set to 'prevent', 'alert', or 'allow'.
     */
    effect?: string;
    /**
     * Custom rule number.
     */
    id?: number;
}

export interface HostRuntimePolicyRuleDns {
    /**
     * Allowed domains. Wildcard prefixes are supported.
     */
    alloweds?: string[];
    /**
     * Denied domains. Wildcard prefixes are supported.
     */
    denieds?: string[];
    /**
     * The effect to be used. Can be set to 'prevent', 'alert', or 'disable'.
     */
    denyEffect?: string;
    /**
     * The effect to be used when resolving suspicious domains according to Prisma Cloud Compute. Can be set to 'prevent', 'alert', or 'disable'.
     */
    intelligenceFeed?: string;
}

export interface HostRuntimePolicyRuleFileIntegrityRule {
    /**
     * List of processes allowed to generate file system events on monitored files.
     */
    allowedProcesses?: string[];
    /**
     * List of file names to ignore. Pattern matching is supported.
     */
    excludedFiles?: string[];
    /**
     * Whether or not to monitor file metadata changes.
     */
    metadata?: boolean;
    /**
     * Path to monitor.
     */
    path?: string;
    /**
     * Whether or not to monitor file reads.
     */
    read?: boolean;
    /**
     * Whether or not to recursively monitor files starting at `path`.
     */
    recursive?: boolean;
    /**
     * Whether or not to monitor file writes.
     */
    write?: boolean;
}

export interface HostRuntimePolicyRuleLogInspectionRule {
    /**
     * Path to the log file.
     */
    path?: string;
    /**
     * List of regular expressions to use when inspecting the log file.
     */
    regexes?: string[];
}

export interface HostRuntimePolicyRuleNetwork {
    /**
     * List of allowed outbound IP addresses.
     */
    allowedOutboundIps?: string[];
    /**
     * The effect to be used when connecting to suspicious IPs according to custom feeds. Can be set to 'alert' or 'disable'.
     */
    customFeed?: string;
    /**
     * List of denied listening ports.
     */
    deniedListeningPorts?: outputs.HostRuntimePolicyRuleNetworkDeniedListeningPort[];
    /**
     * List of denied outbound IP addresses.
     */
    deniedOutboundIps?: string[];
    /**
     * List of denied outbound ports.
     */
    deniedOutboundPorts?: outputs.HostRuntimePolicyRuleNetworkDeniedOutboundPort[];
    /**
     * The effect to be used. Can be set to 'alert' or 'disable'.
     */
    denyEffect?: string;
    /**
     * The effect to be used when connecting to suspicious IPs according to Prisma Cloud Compute. Can be set to 'alert' or 'disable'.
     */
    intelligenceFeed?: string;
}

export interface HostRuntimePolicyRuleNetworkDeniedListeningPort {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface HostRuntimePolicyRuleNetworkDeniedOutboundPort {
    /**
     * Whether or not to deny the connection.
     */
    deny?: boolean;
    /**
     * End of the port range.
     */
    end?: number;
    /**
     * Start of the port range.
     */
    start?: number;
}

export interface HostVulnerabilityPolicyRule {
    /**
     * Threshold for generating alerts.
     */
    alertThreshold?: outputs.HostVulnerabilityPolicyRuleAlertThreshold;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of rules for handling specific CVEs.
     */
    cveRules?: outputs.HostVulnerabilityPolicyRuleCveRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Number of days to suppress the rule's block effect. Measured from date the vulnerability was fixed. If there's no fix, measured from the date the vulnerability was published.
     */
    graceDays?: number;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to apply the rule only when vendor fixes are available.
     */
    onlyFixed?: boolean;
    /**
     * List of rules for handling specific tags.
     */
    tagRules?: outputs.HostVulnerabilityPolicyRuleTagRule[];
    /**
     * Whether or not to display a detailed message when blocked.
     */
    verbose?: boolean;
}

export interface HostVulnerabilityPolicyRuleAlertThreshold {
    /**
     * Whether or not to disable vulnerability alerts.
     */
    disabled?: boolean;
    /**
     * Minimum vulnerability severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface HostVulnerabilityPolicyRuleCveRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if the CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * CVE rule expiration.
     */
    expiration?: outputs.HostVulnerabilityPolicyRuleCveRuleExpiration;
    /**
     * CVE ID.
     */
    id?: string;
}

export interface HostVulnerabilityPolicyRuleCveRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the CVE rule expiration.
     */
    enabled?: boolean;
}

export interface HostVulnerabilityPolicyRuleTagRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if a tagged CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * Tag rule expiration.
     */
    expiration?: outputs.HostVulnerabilityPolicyRuleTagRuleExpiration;
    /**
     * Tag name.
     */
    name?: string;
}

export interface HostVulnerabilityPolicyRuleTagRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the tag rule expiration.
     */
    enabled?: boolean;
}

export interface ImageVulnerabilityPolicyRule {
    /**
     * Threshold for generating alerts.
     */
    alertThreshold?: outputs.ImageVulnerabilityPolicyRuleAlertThreshold;
    /**
     * Message to display when an image is blocked.
     */
    blockMessage?: string;
    /**
     * Threshold for blocking.
     */
    blockThreshold?: outputs.ImageVulnerabilityPolicyRuleBlockThreshold;
    /**
     * Collections used to scope the rule.
     */
    collections?: string[];
    /**
     * List of rules for handling specific CVEs.
     */
    cveRules?: outputs.ImageVulnerabilityPolicyRuleCveRule[];
    /**
     * Whether or not to disable the rule.
     */
    disabled?: boolean;
    /**
     * The effect of the rule. Can be set to 'ignore', 'alert', 'block', or 'alert, block'.
     */
    effect?: string;
    /**
     * Number of days to suppress the rule's block effect. Measured from date the vulnerability was fixed. If there's no fix, measured from the date the vulnerability was published.
     */
    graceDays?: number;
    /**
     * Composite alternative to grace_days. Allows to set the effect for different severity level.
     */
    graceDaysPolicy?: outputs.ImageVulnerabilityPolicyRuleGraceDaysPolicy;
    /**
     * Unique name of the rule.
     */
    name?: string;
    /**
     * Free-form text field.
     */
    notes?: string;
    /**
     * Whether or not to apply the rule only when vendor fixes are available.
     */
    onlyFixed?: boolean;
    /**
     * List of rules for handling specific tags.
     */
    tagRules?: outputs.ImageVulnerabilityPolicyRuleTagRule[];
    /**
     * Whether or not to display a detailed message when blocked.
     */
    verbose?: boolean;
}

export interface ImageVulnerabilityPolicyRuleAlertThreshold {
    /**
     * Whether or not to disable vulnerability alerts.
     */
    disabled?: boolean;
    /**
     * Minimum vulnerability severity to generate an alert. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface ImageVulnerabilityPolicyRuleBlockThreshold {
    /**
     * Whether or not to block when vulnerabilities are found.
     */
    enabled?: boolean;
    /**
     * Minimum vulnerability severity to block. Can be set to 0=off, 1=low, 4=medium, 7=high, and 9=critical.
     */
    value?: number;
}

export interface ImageVulnerabilityPolicyRuleCveRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if the CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * CVE rule expiration.
     */
    expiration?: outputs.ImageVulnerabilityPolicyRuleCveRuleExpiration;
    /**
     * CVE ID.
     */
    id?: string;
}

export interface ImageVulnerabilityPolicyRuleCveRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the CVE rule expiration.
     */
    enabled?: boolean;
}

export interface ImageVulnerabilityPolicyRuleGraceDaysPolicy {
    critical?: number;
    high?: number;
    low?: number;
    medium?: number;
}

export interface ImageVulnerabilityPolicyRuleTagRule {
    /**
     * Free-form text field.
     */
    description?: string;
    /**
     * Action to take if a tagged CVE is found. Can be set to 'ignore', 'alert', or 'block'.
     */
    effect?: string;
    /**
     * Tag rule expiration.
     */
    expiration?: outputs.ImageVulnerabilityPolicyRuleTagRuleExpiration;
    /**
     * Tag name.
     */
    name?: string;
}

export interface ImageVulnerabilityPolicyRuleTagRuleExpiration {
    /**
     * Expiration date.
     */
    date?: string;
    /**
     * Whether or not to enable the tag rule expiration.
     */
    enabled?: boolean;
}

export interface RegistrySettingsSpecification {
    /**
     * The maximum number of images to scan from each repository, sorted by most recently modified.
     */
    cap?: number;
    /**
     * The set of Defenders available for scanning.
     */
    collections?: string[];
    /**
     * The name of the credential from the credentials store to use for authenticating with the registry.
     */
    credential?: string;
    /**
     * Repositories to exclude from scanning.
     */
    excludedRepositories?: string[];
    /**
     * Tags to exclude from scanning.
     */
    excludedTags?: string[];
    /**
     * Use temporary tokens provided by Harbor to scan images in projects with the deployment security setting enabled.
     */
    harborDeploymentSecurity?: boolean;
    /**
     * JFrog Artifactory repository types to scan.
     */
    jfrogRepoTypes?: string[];
    /**
     * IBM Cloud namespace.
     */
    namespace?: string;
    /**
     * The base OS of the registry images.
     */
    os?: string;
    /**
     * Registry address.
     */
    registry?: string;
    /**
     * Repositories to scan. Pattern matching is supported.
     */
    repository?: string;
    /**
     * Number of Defenders that can be utilized for each scan job.
     */
    scanners?: number;
    /**
     * Tags to scan. Pattern matching is supported.
     */
    tag?: string;
    /**
     * Registry type. Can be set to 'aws', 'azure', 'gcp', 'ibmCloud', 'oci', 'apiToken', 'githubToken', 'githubEnterpriseToken', 'basic', 'dtr', 'kubeconfig' or 'certificate'.
     */
    type?: string;
    /**
     * Pattern used by the scanner to identify the latest tags without querying the registry for additional metadata. If a pattern specifies both date and version, date takes precedence over version.
     */
    versionPattern?: string;
}

export interface RolePermission {
    /**
     * Names roles for the user.
     */
    name?: string;
    /**
     * Indicates the type of permission.
     */
    readWrite?: boolean;
}

export interface UserPermissions {
    /**
     * Specifies the set of Defenders in-scope for working on a scan job.
     */
    collections?: string[];
    /**
     * Names of projects which the user can access.
     */
    project?: string;
}

