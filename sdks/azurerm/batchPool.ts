// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class BatchPool extends pulumi.CustomResource {
    /**
     * Get an existing BatchPool resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: BatchPoolState, opts?: pulumi.CustomResourceOptions): BatchPool {
        return new BatchPool(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'azurerm:index/batchPool:BatchPool';

    /**
     * Returns true if the given object is an instance of BatchPool.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is BatchPool {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === BatchPool.__pulumiType;
    }

    public readonly accountName!: pulumi.Output<string>;
    public readonly autoScale!: pulumi.Output<outputs.BatchPoolAutoScale | undefined>;
    public readonly certificates!: pulumi.Output<outputs.BatchPoolCertificate[] | undefined>;
    public readonly containerConfiguration!: pulumi.Output<outputs.BatchPoolContainerConfiguration | undefined>;
    public readonly dataDisks!: pulumi.Output<outputs.BatchPoolDataDisk[] | undefined>;
    public readonly diskEncryptions!: pulumi.Output<outputs.BatchPoolDiskEncryption[] | undefined>;
    public readonly displayName!: pulumi.Output<string | undefined>;
    public readonly extensions!: pulumi.Output<outputs.BatchPoolExtension[] | undefined>;
    public readonly fixedScale!: pulumi.Output<outputs.BatchPoolFixedScale | undefined>;
    public readonly identity!: pulumi.Output<outputs.BatchPoolIdentity | undefined>;
    public readonly interNodeCommunication!: pulumi.Output<string | undefined>;
    public readonly licenseType!: pulumi.Output<string | undefined>;
    public readonly maxTasksPerNode!: pulumi.Output<number | undefined>;
    public readonly metadata!: pulumi.Output<{[key: string]: string} | undefined>;
    public readonly mounts!: pulumi.Output<outputs.BatchPoolMount[] | undefined>;
    public readonly name!: pulumi.Output<string>;
    public readonly networkConfiguration!: pulumi.Output<outputs.BatchPoolNetworkConfiguration | undefined>;
    public readonly nodeAgentSkuId!: pulumi.Output<string>;
    public readonly nodePlacements!: pulumi.Output<outputs.BatchPoolNodePlacement[] | undefined>;
    public readonly osDiskPlacement!: pulumi.Output<string | undefined>;
    public readonly resourceGroupName!: pulumi.Output<string>;
    public readonly startTask!: pulumi.Output<outputs.BatchPoolStartTask | undefined>;
    public readonly stopPendingResizeOperation!: pulumi.Output<boolean | undefined>;
    public readonly storageImageReference!: pulumi.Output<outputs.BatchPoolStorageImageReference>;
    public readonly targetNodeCommunicationMode!: pulumi.Output<string | undefined>;
    public readonly taskSchedulingPolicies!: pulumi.Output<outputs.BatchPoolTaskSchedulingPolicy[] | undefined>;
    public readonly timeouts!: pulumi.Output<outputs.BatchPoolTimeouts | undefined>;
    public readonly userAccounts!: pulumi.Output<outputs.BatchPoolUserAccount[] | undefined>;
    public readonly vmSize!: pulumi.Output<string>;
    public readonly windows!: pulumi.Output<outputs.BatchPoolWindow[] | undefined>;

    /**
     * Create a BatchPool resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: BatchPoolArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: BatchPoolArgs | BatchPoolState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as BatchPoolState | undefined;
            resourceInputs["accountName"] = state ? state.accountName : undefined;
            resourceInputs["autoScale"] = state ? state.autoScale : undefined;
            resourceInputs["certificates"] = state ? state.certificates : undefined;
            resourceInputs["containerConfiguration"] = state ? state.containerConfiguration : undefined;
            resourceInputs["dataDisks"] = state ? state.dataDisks : undefined;
            resourceInputs["diskEncryptions"] = state ? state.diskEncryptions : undefined;
            resourceInputs["displayName"] = state ? state.displayName : undefined;
            resourceInputs["extensions"] = state ? state.extensions : undefined;
            resourceInputs["fixedScale"] = state ? state.fixedScale : undefined;
            resourceInputs["identity"] = state ? state.identity : undefined;
            resourceInputs["interNodeCommunication"] = state ? state.interNodeCommunication : undefined;
            resourceInputs["licenseType"] = state ? state.licenseType : undefined;
            resourceInputs["maxTasksPerNode"] = state ? state.maxTasksPerNode : undefined;
            resourceInputs["metadata"] = state ? state.metadata : undefined;
            resourceInputs["mounts"] = state ? state.mounts : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["networkConfiguration"] = state ? state.networkConfiguration : undefined;
            resourceInputs["nodeAgentSkuId"] = state ? state.nodeAgentSkuId : undefined;
            resourceInputs["nodePlacements"] = state ? state.nodePlacements : undefined;
            resourceInputs["osDiskPlacement"] = state ? state.osDiskPlacement : undefined;
            resourceInputs["resourceGroupName"] = state ? state.resourceGroupName : undefined;
            resourceInputs["startTask"] = state ? state.startTask : undefined;
            resourceInputs["stopPendingResizeOperation"] = state ? state.stopPendingResizeOperation : undefined;
            resourceInputs["storageImageReference"] = state ? state.storageImageReference : undefined;
            resourceInputs["targetNodeCommunicationMode"] = state ? state.targetNodeCommunicationMode : undefined;
            resourceInputs["taskSchedulingPolicies"] = state ? state.taskSchedulingPolicies : undefined;
            resourceInputs["timeouts"] = state ? state.timeouts : undefined;
            resourceInputs["userAccounts"] = state ? state.userAccounts : undefined;
            resourceInputs["vmSize"] = state ? state.vmSize : undefined;
            resourceInputs["windows"] = state ? state.windows : undefined;
        } else {
            const args = argsOrState as BatchPoolArgs | undefined;
            if ((!args || args.accountName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'accountName'");
            }
            if ((!args || args.nodeAgentSkuId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'nodeAgentSkuId'");
            }
            if ((!args || args.resourceGroupName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'resourceGroupName'");
            }
            if ((!args || args.storageImageReference === undefined) && !opts.urn) {
                throw new Error("Missing required property 'storageImageReference'");
            }
            if ((!args || args.vmSize === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vmSize'");
            }
            resourceInputs["accountName"] = args ? args.accountName : undefined;
            resourceInputs["autoScale"] = args ? args.autoScale : undefined;
            resourceInputs["certificates"] = args ? args.certificates : undefined;
            resourceInputs["containerConfiguration"] = args ? args.containerConfiguration : undefined;
            resourceInputs["dataDisks"] = args ? args.dataDisks : undefined;
            resourceInputs["diskEncryptions"] = args ? args.diskEncryptions : undefined;
            resourceInputs["displayName"] = args ? args.displayName : undefined;
            resourceInputs["extensions"] = args ? args.extensions : undefined;
            resourceInputs["fixedScale"] = args ? args.fixedScale : undefined;
            resourceInputs["identity"] = args ? args.identity : undefined;
            resourceInputs["interNodeCommunication"] = args ? args.interNodeCommunication : undefined;
            resourceInputs["licenseType"] = args ? args.licenseType : undefined;
            resourceInputs["maxTasksPerNode"] = args ? args.maxTasksPerNode : undefined;
            resourceInputs["metadata"] = args ? args.metadata : undefined;
            resourceInputs["mounts"] = args ? args.mounts : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["networkConfiguration"] = args ? args.networkConfiguration : undefined;
            resourceInputs["nodeAgentSkuId"] = args ? args.nodeAgentSkuId : undefined;
            resourceInputs["nodePlacements"] = args ? args.nodePlacements : undefined;
            resourceInputs["osDiskPlacement"] = args ? args.osDiskPlacement : undefined;
            resourceInputs["resourceGroupName"] = args ? args.resourceGroupName : undefined;
            resourceInputs["startTask"] = args ? args.startTask : undefined;
            resourceInputs["stopPendingResizeOperation"] = args ? args.stopPendingResizeOperation : undefined;
            resourceInputs["storageImageReference"] = args ? args.storageImageReference : undefined;
            resourceInputs["targetNodeCommunicationMode"] = args ? args.targetNodeCommunicationMode : undefined;
            resourceInputs["taskSchedulingPolicies"] = args ? args.taskSchedulingPolicies : undefined;
            resourceInputs["timeouts"] = args ? args.timeouts : undefined;
            resourceInputs["userAccounts"] = args ? args.userAccounts : undefined;
            resourceInputs["vmSize"] = args ? args.vmSize : undefined;
            resourceInputs["windows"] = args ? args.windows : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(BatchPool.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering BatchPool resources.
 */
export interface BatchPoolState {
    accountName?: pulumi.Input<string>;
    autoScale?: pulumi.Input<inputs.BatchPoolAutoScale>;
    certificates?: pulumi.Input<pulumi.Input<inputs.BatchPoolCertificate>[]>;
    containerConfiguration?: pulumi.Input<inputs.BatchPoolContainerConfiguration>;
    dataDisks?: pulumi.Input<pulumi.Input<inputs.BatchPoolDataDisk>[]>;
    diskEncryptions?: pulumi.Input<pulumi.Input<inputs.BatchPoolDiskEncryption>[]>;
    displayName?: pulumi.Input<string>;
    extensions?: pulumi.Input<pulumi.Input<inputs.BatchPoolExtension>[]>;
    fixedScale?: pulumi.Input<inputs.BatchPoolFixedScale>;
    identity?: pulumi.Input<inputs.BatchPoolIdentity>;
    interNodeCommunication?: pulumi.Input<string>;
    licenseType?: pulumi.Input<string>;
    maxTasksPerNode?: pulumi.Input<number>;
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    mounts?: pulumi.Input<pulumi.Input<inputs.BatchPoolMount>[]>;
    name?: pulumi.Input<string>;
    networkConfiguration?: pulumi.Input<inputs.BatchPoolNetworkConfiguration>;
    nodeAgentSkuId?: pulumi.Input<string>;
    nodePlacements?: pulumi.Input<pulumi.Input<inputs.BatchPoolNodePlacement>[]>;
    osDiskPlacement?: pulumi.Input<string>;
    resourceGroupName?: pulumi.Input<string>;
    startTask?: pulumi.Input<inputs.BatchPoolStartTask>;
    stopPendingResizeOperation?: pulumi.Input<boolean>;
    storageImageReference?: pulumi.Input<inputs.BatchPoolStorageImageReference>;
    targetNodeCommunicationMode?: pulumi.Input<string>;
    taskSchedulingPolicies?: pulumi.Input<pulumi.Input<inputs.BatchPoolTaskSchedulingPolicy>[]>;
    timeouts?: pulumi.Input<inputs.BatchPoolTimeouts>;
    userAccounts?: pulumi.Input<pulumi.Input<inputs.BatchPoolUserAccount>[]>;
    vmSize?: pulumi.Input<string>;
    windows?: pulumi.Input<pulumi.Input<inputs.BatchPoolWindow>[]>;
}

/**
 * The set of arguments for constructing a BatchPool resource.
 */
export interface BatchPoolArgs {
    accountName: pulumi.Input<string>;
    autoScale?: pulumi.Input<inputs.BatchPoolAutoScale>;
    certificates?: pulumi.Input<pulumi.Input<inputs.BatchPoolCertificate>[]>;
    containerConfiguration?: pulumi.Input<inputs.BatchPoolContainerConfiguration>;
    dataDisks?: pulumi.Input<pulumi.Input<inputs.BatchPoolDataDisk>[]>;
    diskEncryptions?: pulumi.Input<pulumi.Input<inputs.BatchPoolDiskEncryption>[]>;
    displayName?: pulumi.Input<string>;
    extensions?: pulumi.Input<pulumi.Input<inputs.BatchPoolExtension>[]>;
    fixedScale?: pulumi.Input<inputs.BatchPoolFixedScale>;
    identity?: pulumi.Input<inputs.BatchPoolIdentity>;
    interNodeCommunication?: pulumi.Input<string>;
    licenseType?: pulumi.Input<string>;
    maxTasksPerNode?: pulumi.Input<number>;
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    mounts?: pulumi.Input<pulumi.Input<inputs.BatchPoolMount>[]>;
    name?: pulumi.Input<string>;
    networkConfiguration?: pulumi.Input<inputs.BatchPoolNetworkConfiguration>;
    nodeAgentSkuId: pulumi.Input<string>;
    nodePlacements?: pulumi.Input<pulumi.Input<inputs.BatchPoolNodePlacement>[]>;
    osDiskPlacement?: pulumi.Input<string>;
    resourceGroupName: pulumi.Input<string>;
    startTask?: pulumi.Input<inputs.BatchPoolStartTask>;
    stopPendingResizeOperation?: pulumi.Input<boolean>;
    storageImageReference: pulumi.Input<inputs.BatchPoolStorageImageReference>;
    targetNodeCommunicationMode?: pulumi.Input<string>;
    taskSchedulingPolicies?: pulumi.Input<pulumi.Input<inputs.BatchPoolTaskSchedulingPolicy>[]>;
    timeouts?: pulumi.Input<inputs.BatchPoolTimeouts>;
    userAccounts?: pulumi.Input<pulumi.Input<inputs.BatchPoolUserAccount>[]>;
    vmSize: pulumi.Input<string>;
    windows?: pulumi.Input<pulumi.Input<inputs.BatchPoolWindow>[]>;
}
