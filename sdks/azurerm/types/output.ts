// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface Aadb2cDirectoryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveDirectoryDomainServiceInitialReplicaSet {
    domainControllerIpAddresses: string[];
    externalAccessIpAddress: string;
    id: string;
    location: string;
    serviceStatus: string;
    subnetId: string;
}

export interface ActiveDirectoryDomainServiceNotifications {
    additionalRecipients?: string[];
    notifyDcAdmins?: boolean;
    notifyGlobalAdmins?: boolean;
}

export interface ActiveDirectoryDomainServiceReplicaSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ActiveDirectoryDomainServiceSecureLdap {
    certificateExpiry: string;
    certificateThumbprint: string;
    enabled: boolean;
    externalAccessEnabled?: boolean;
    pfxCertificate: string;
    pfxCertificatePassword: string;
    publicCertificate: string;
}

export interface ActiveDirectoryDomainServiceSecurity {
    kerberosArmoringEnabled?: boolean;
    kerberosRc4EncryptionEnabled?: boolean;
    ntlmV1Enabled?: boolean;
    syncKerberosPasswords?: boolean;
    syncNtlmPasswords?: boolean;
    syncOnPremPasswords?: boolean;
    tlsV1Enabled?: boolean;
}

export interface ActiveDirectoryDomainServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveDirectoryDomainServiceTrustTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AdvancedThreatProtectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AiServicesCustomerManagedKey {
    identityClientId?: string;
    keyVaultKeyId?: string;
    managedHsmKeyId?: string;
}

export interface AiServicesIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface AiServicesNetworkAcls {
    defaultAction: string;
    ipRules?: string[];
    virtualNetworkRules?: outputs.AiServicesNetworkAclsVirtualNetworkRule[];
}

export interface AiServicesNetworkAclsVirtualNetworkRule {
    ignoreMissingVnetServiceEndpoint?: boolean;
    subnetId: string;
}

export interface AiServicesStorage {
    identityClientId?: string;
    storageAccountId: string;
}

export interface AiServicesTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AnalysisServicesServerIpv4FirewallRule {
    name: string;
    rangeEnd: string;
    rangeStart: string;
}

export interface AnalysisServicesServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementAdditionalLocation {
    capacity: number;
    gatewayDisabled?: boolean;
    gatewayRegionalUrl: string;
    location: string;
    privateIpAddresses: string[];
    publicIpAddressId?: string;
    publicIpAddresses: string[];
    virtualNetworkConfiguration?: outputs.ApiManagementAdditionalLocationVirtualNetworkConfiguration;
    zones?: string[];
}

export interface ApiManagementAdditionalLocationVirtualNetworkConfiguration {
    subnetId: string;
}

export interface ApiManagementApiContact {
    email?: string;
    name?: string;
    url?: string;
}

export interface ApiManagementApiDiagnosticBackendRequest {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementApiDiagnosticBackendRequestDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementApiDiagnosticBackendRequestDataMasking {
    headers?: outputs.ApiManagementApiDiagnosticBackendRequestDataMaskingHeader[];
    queryParams?: outputs.ApiManagementApiDiagnosticBackendRequestDataMaskingQueryParam[];
}

export interface ApiManagementApiDiagnosticBackendRequestDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticBackendRequestDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticBackendResponse {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementApiDiagnosticBackendResponseDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementApiDiagnosticBackendResponseDataMasking {
    headers?: outputs.ApiManagementApiDiagnosticBackendResponseDataMaskingHeader[];
    queryParams?: outputs.ApiManagementApiDiagnosticBackendResponseDataMaskingQueryParam[];
}

export interface ApiManagementApiDiagnosticBackendResponseDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticBackendResponseDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticFrontendRequest {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementApiDiagnosticFrontendRequestDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementApiDiagnosticFrontendRequestDataMasking {
    headers?: outputs.ApiManagementApiDiagnosticFrontendRequestDataMaskingHeader[];
    queryParams?: outputs.ApiManagementApiDiagnosticFrontendRequestDataMaskingQueryParam[];
}

export interface ApiManagementApiDiagnosticFrontendRequestDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticFrontendRequestDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticFrontendResponse {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementApiDiagnosticFrontendResponseDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementApiDiagnosticFrontendResponseDataMasking {
    headers?: outputs.ApiManagementApiDiagnosticFrontendResponseDataMaskingHeader[];
    queryParams?: outputs.ApiManagementApiDiagnosticFrontendResponseDataMaskingQueryParam[];
}

export interface ApiManagementApiDiagnosticFrontendResponseDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticFrontendResponseDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementApiDiagnosticTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiImport {
    contentFormat: string;
    contentValue: string;
    wsdlSelector?: outputs.ApiManagementApiImportWsdlSelector;
}

export interface ApiManagementApiImportWsdlSelector {
    endpointName: string;
    serviceName: string;
}

export interface ApiManagementApiLicense {
    name?: string;
    url?: string;
}

export interface ApiManagementApiOauth2Authorization {
    authorizationServerName: string;
    scope?: string;
}

export interface ApiManagementApiOpenidAuthentication {
    bearerTokenSendingMethods?: string[];
    openidProviderName: string;
}

export interface ApiManagementApiOperationPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiOperationRequest {
    description?: string;
    headers?: outputs.ApiManagementApiOperationRequestHeader[];
    queryParameters?: outputs.ApiManagementApiOperationRequestQueryParameter[];
    representations?: outputs.ApiManagementApiOperationRequestRepresentation[];
}

export interface ApiManagementApiOperationRequestHeader {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationRequestHeaderExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationRequestHeaderExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationRequestQueryParameter {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationRequestQueryParameterExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationRequestQueryParameterExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationRequestRepresentation {
    contentType: string;
    examples?: outputs.ApiManagementApiOperationRequestRepresentationExample[];
    formParameters?: outputs.ApiManagementApiOperationRequestRepresentationFormParameter[];
    schemaId?: string;
    typeName?: string;
}

export interface ApiManagementApiOperationRequestRepresentationExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationRequestRepresentationFormParameter {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationRequestRepresentationFormParameterExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationRequestRepresentationFormParameterExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationResponse {
    description?: string;
    headers?: outputs.ApiManagementApiOperationResponseHeader[];
    representations?: outputs.ApiManagementApiOperationResponseRepresentation[];
    statusCode: number;
}

export interface ApiManagementApiOperationResponseHeader {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationResponseHeaderExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationResponseHeaderExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationResponseRepresentation {
    contentType: string;
    examples?: outputs.ApiManagementApiOperationResponseRepresentationExample[];
    formParameters?: outputs.ApiManagementApiOperationResponseRepresentationFormParameter[];
    schemaId?: string;
    typeName?: string;
}

export interface ApiManagementApiOperationResponseRepresentationExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationResponseRepresentationFormParameter {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationResponseRepresentationFormParameterExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationResponseRepresentationFormParameterExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationTagTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiOperationTemplateParameter {
    defaultValue?: string;
    description?: string;
    examples?: outputs.ApiManagementApiOperationTemplateParameterExample[];
    name: string;
    required: boolean;
    schemaId?: string;
    type: string;
    typeName?: string;
    values?: string[];
}

export interface ApiManagementApiOperationTemplateParameterExample {
    description?: string;
    externalValue?: string;
    name: string;
    summary?: string;
    value?: string;
}

export interface ApiManagementApiOperationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiReleaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiSchemaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiSubscriptionKeyParameterNames {
    header: string;
    query: string;
}

export interface ApiManagementApiTagDescriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiTagTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementApiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementApiVersionSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementAuthorizationServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementAuthorizationServerTokenBodyParameter {
    name: string;
    value: string;
}

export interface ApiManagementBackendCredentials {
    authorization?: outputs.ApiManagementBackendCredentialsAuthorization;
    certificates?: string[];
    header?: {[key: string]: string};
    query?: {[key: string]: string};
}

export interface ApiManagementBackendCredentialsAuthorization {
    parameter?: string;
    scheme?: string;
}

export interface ApiManagementBackendProxy {
    password?: string;
    url: string;
    username: string;
}

export interface ApiManagementBackendServiceFabricCluster {
    clientCertificateId: string;
    clientCertificateThumbprint: string;
    managementEndpoints: string[];
    maxPartitionResolutionRetries: number;
    serverCertificateThumbprints?: string[];
    serverX509Names?: outputs.ApiManagementBackendServiceFabricClusterServerX509Name[];
}

export interface ApiManagementBackendServiceFabricClusterServerX509Name {
    issuerCertificateThumbprint: string;
    name: string;
}

export interface ApiManagementBackendTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementBackendTls {
    validateCertificateChain?: boolean;
    validateCertificateName?: boolean;
}

export interface ApiManagementCertificate {
    certificatePassword?: string;
    encodedCertificate: string;
    expiry: string;
    storeName: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementCustomDomainDeveloperPortal {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCustomDomainGateway {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    defaultSslBinding: boolean;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCustomDomainManagement {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCustomDomainPortal {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCustomDomainScm {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementDelegation {
    subscriptionsEnabled?: boolean;
    url?: string;
    userRegistrationEnabled?: boolean;
    validationKey?: string;
}

export interface ApiManagementDiagnosticBackendRequest {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementDiagnosticBackendRequestDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementDiagnosticBackendRequestDataMasking {
    headers?: outputs.ApiManagementDiagnosticBackendRequestDataMaskingHeader[];
    queryParams?: outputs.ApiManagementDiagnosticBackendRequestDataMaskingQueryParam[];
}

export interface ApiManagementDiagnosticBackendRequestDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticBackendRequestDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticBackendResponse {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementDiagnosticBackendResponseDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementDiagnosticBackendResponseDataMasking {
    headers?: outputs.ApiManagementDiagnosticBackendResponseDataMaskingHeader[];
    queryParams?: outputs.ApiManagementDiagnosticBackendResponseDataMaskingQueryParam[];
}

export interface ApiManagementDiagnosticBackendResponseDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticBackendResponseDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticFrontendRequest {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementDiagnosticFrontendRequestDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementDiagnosticFrontendRequestDataMasking {
    headers?: outputs.ApiManagementDiagnosticFrontendRequestDataMaskingHeader[];
    queryParams?: outputs.ApiManagementDiagnosticFrontendRequestDataMaskingQueryParam[];
}

export interface ApiManagementDiagnosticFrontendRequestDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticFrontendRequestDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticFrontendResponse {
    bodyBytes?: number;
    dataMasking?: outputs.ApiManagementDiagnosticFrontendResponseDataMasking;
    headersToLogs?: string[];
}

export interface ApiManagementDiagnosticFrontendResponseDataMasking {
    headers?: outputs.ApiManagementDiagnosticFrontendResponseDataMaskingHeader[];
    queryParams?: outputs.ApiManagementDiagnosticFrontendResponseDataMaskingQueryParam[];
}

export interface ApiManagementDiagnosticFrontendResponseDataMaskingHeader {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticFrontendResponseDataMaskingQueryParam {
    mode: string;
    value: string;
}

export interface ApiManagementDiagnosticTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementEmailTemplateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGatewayApiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementGatewayCertificateAuthorityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGatewayHostNameConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGatewayLocationData {
    city?: string;
    district?: string;
    name: string;
    region?: string;
}

export interface ApiManagementGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGlobalSchemaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementGroupUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementHostnameConfiguration {
    developerPortals?: outputs.ApiManagementHostnameConfigurationDeveloperPortal[];
    managements?: outputs.ApiManagementHostnameConfigurationManagement[];
    portals?: outputs.ApiManagementHostnameConfigurationPortal[];
    proxies?: outputs.ApiManagementHostnameConfigurationProxy[];
    scms?: outputs.ApiManagementHostnameConfigurationScm[];
}

export interface ApiManagementHostnameConfigurationDeveloperPortal {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementHostnameConfigurationManagement {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementHostnameConfigurationPortal {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementHostnameConfigurationProxy {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    defaultSslBinding: boolean;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementHostnameConfigurationScm {
    certificate?: string;
    certificatePassword?: string;
    certificateSource: string;
    certificateStatus: string;
    expiry: string;
    hostName: string;
    keyVaultId?: string;
    negotiateClientCertificate?: boolean;
    sslKeyvaultIdentityClientId?: string;
    subject: string;
    thumbprint: string;
}

export interface ApiManagementIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ApiManagementIdentityProviderAadTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementIdentityProviderAadb2cTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementIdentityProviderFacebookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementIdentityProviderGoogleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementIdentityProviderMicrosoftTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementIdentityProviderTwitterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementLoggerApplicationInsights {
    instrumentationKey: string;
}

export interface ApiManagementLoggerEventhub {
    connectionString?: string;
    endpointUri?: string;
    name: string;
    userAssignedIdentityClientId?: string;
}

export interface ApiManagementLoggerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementNamedValueTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementNamedValueValueFromKeyVault {
    identityClientId?: string;
    secretId: string;
}

export interface ApiManagementNotificationRecipientEmailTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementNotificationRecipientUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementOpenidConnectProviderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementPolicyFragmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementProductApiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementProductGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementProductPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementProductTagTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApiManagementProductTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementProtocols {
    enableHttp2?: boolean;
}

export interface ApiManagementRedisCacheTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementSecurity {
    enableBackendSsl30?: boolean;
    enableBackendTls10?: boolean;
    enableBackendTls11?: boolean;
    enableFrontendSsl30?: boolean;
    enableFrontendTls10?: boolean;
    enableFrontendTls11?: boolean;
    tlsEcdheEcdsaWithAes128CbcShaCiphersEnabled?: boolean;
    tlsEcdheEcdsaWithAes256CbcShaCiphersEnabled?: boolean;
    tlsEcdheRsaWithAes128CbcShaCiphersEnabled?: boolean;
    tlsEcdheRsaWithAes256CbcShaCiphersEnabled?: boolean;
    tlsRsaWithAes128CbcSha256CiphersEnabled?: boolean;
    tlsRsaWithAes128CbcShaCiphersEnabled?: boolean;
    tlsRsaWithAes128GcmSha256CiphersEnabled?: boolean;
    tlsRsaWithAes256CbcSha256CiphersEnabled?: boolean;
    tlsRsaWithAes256CbcShaCiphersEnabled?: boolean;
    tlsRsaWithAes256GcmSha384CiphersEnabled?: boolean;
    tripleDesCiphersEnabled?: boolean;
}

export interface ApiManagementSignIn {
    enabled: boolean;
}

export interface ApiManagementSignUp {
    enabled: boolean;
    termsOfService: outputs.ApiManagementSignUpTermsOfService;
}

export interface ApiManagementSignUpTermsOfService {
    consentRequired: boolean;
    enabled: boolean;
    text?: string;
}

export interface ApiManagementSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementTagTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementTenantAccess {
    enabled: boolean;
    primaryKey: string;
    secondaryKey: string;
    tenantId: string;
}

export interface ApiManagementTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApiManagementVirtualNetworkConfiguration {
    subnetId: string;
}

export interface AppConfigurationEncryption {
    identityClientId?: string;
    keyVaultKeyIdentifier?: string;
}

export interface AppConfigurationFeatureTargetingFilter {
    defaultRolloutPercentage: number;
    groups?: outputs.AppConfigurationFeatureTargetingFilterGroup[];
    users?: string[];
}

export interface AppConfigurationFeatureTargetingFilterGroup {
    name: string;
    rolloutPercentage: number;
}

export interface AppConfigurationFeatureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppConfigurationFeatureTimewindowFilter {
    end?: string;
    start?: string;
}

export interface AppConfigurationIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface AppConfigurationKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppConfigurationPrimaryReadKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface AppConfigurationPrimaryWriteKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface AppConfigurationReplica {
    endpoint: string;
    id: string;
    location: string;
    name: string;
}

export interface AppConfigurationSecondaryReadKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface AppConfigurationSecondaryWriteKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface AppConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceActiveSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceAuthSettings {
    activeDirectory?: outputs.AppServiceAuthSettingsActiveDirectory;
    additionalLoginParams?: {[key: string]: string};
    allowedExternalRedirectUrls?: string[];
    defaultProvider?: string;
    enabled: boolean;
    facebook?: outputs.AppServiceAuthSettingsFacebook;
    google?: outputs.AppServiceAuthSettingsGoogle;
    issuer?: string;
    microsoft?: outputs.AppServiceAuthSettingsMicrosoft;
    runtimeVersion?: string;
    tokenRefreshExtensionHours?: number;
    tokenStoreEnabled?: boolean;
    twitter?: outputs.AppServiceAuthSettingsTwitter;
    unauthenticatedClientAction?: string;
}

export interface AppServiceAuthSettingsActiveDirectory {
    allowedAudiences?: string[];
    clientId: string;
    clientSecret?: string;
}

export interface AppServiceAuthSettingsFacebook {
    appId: string;
    appSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceAuthSettingsGoogle {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceAuthSettingsMicrosoft {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceAuthSettingsTwitter {
    consumerKey: string;
    consumerSecret: string;
}

export interface AppServiceBackup {
    enabled?: boolean;
    name: string;
    schedule: outputs.AppServiceBackupSchedule;
    storageAccountUrl: string;
}

export interface AppServiceBackupSchedule {
    frequencyInterval: number;
    frequencyUnit: string;
    keepAtLeastOneBackup?: boolean;
    retentionPeriodInDays?: number;
    startTime?: string;
}

export interface AppServiceCertificateBindingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceCertificateOrderCertificate {
    certificateName: string;
    keyVaultId: string;
    keyVaultSecretName: string;
    provisioningState: string;
}

export interface AppServiceCertificateOrderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceConnectionAuthentication {
    certificate?: string;
    clientId?: string;
    name?: string;
    principalId?: string;
    secret?: string;
    subscriptionId?: string;
    type: string;
}

export interface AppServiceConnectionSecretStore {
    keyVaultId: string;
}

export interface AppServiceConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface AppServiceConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceCustomHostnameBindingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceEnvironmentV3ClusterSetting {
    name: string;
    value: string;
}

export interface AppServiceEnvironmentV3InboundNetworkDependency {
    description: string;
    ipAddresses: string[];
    ports: string[];
}

export interface AppServiceEnvironmentV3Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceHybridConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface AppServiceLogs {
    applicationLogs?: outputs.AppServiceLogsApplicationLogs;
    detailedErrorMessagesEnabled?: boolean;
    failedRequestTracingEnabled?: boolean;
    httpLogs?: outputs.AppServiceLogsHttpLogs;
}

export interface AppServiceLogsApplicationLogs {
    azureBlobStorage?: outputs.AppServiceLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel?: string;
}

export interface AppServiceLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface AppServiceLogsHttpLogs {
    azureBlobStorage?: outputs.AppServiceLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.AppServiceLogsHttpLogsFileSystem;
}

export interface AppServiceLogsHttpLogsAzureBlobStorage {
    retentionInDays: number;
    sasUrl: string;
}

export interface AppServiceLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface AppServiceManagedCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServicePlanSku {
    capacity: number;
    size: string;
    tier: string;
}

export interface AppServicePlanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServicePublicCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceSiteConfig {
    acrUseManagedIdentityCredentials?: boolean;
    acrUserManagedIdentityClientId?: string;
    alwaysOn?: boolean;
    appCommandLine?: string;
    autoSwapSlotName?: string;
    cors?: outputs.AppServiceSiteConfigCors;
    defaultDocuments?: string[];
    dotnetFrameworkVersion?: string;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.AppServiceSiteConfigIpRestriction[];
    javaContainer?: string;
    javaContainerVersion?: string;
    javaVersion?: string;
    linuxFxVersion: string;
    localMysqlEnabled: boolean;
    managedPipelineMode: string;
    minTlsVersion: string;
    numberOfWorkers: number;
    phpVersion?: string;
    pythonVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictions: outputs.AppServiceSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    windowsFxVersion: string;
}

export interface AppServiceSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface AppServiceSiteConfigIpRestriction {
    action: string;
    headers: outputs.AppServiceSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface AppServiceSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface AppServiceSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.AppServiceSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface AppServiceSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface AppServiceSiteCredential {
    password: string;
    username: string;
}

export interface AppServiceSlotAuthSettings {
    activeDirectory?: outputs.AppServiceSlotAuthSettingsActiveDirectory;
    additionalLoginParams?: {[key: string]: string};
    allowedExternalRedirectUrls?: string[];
    defaultProvider?: string;
    enabled: boolean;
    facebook?: outputs.AppServiceSlotAuthSettingsFacebook;
    google?: outputs.AppServiceSlotAuthSettingsGoogle;
    issuer?: string;
    microsoft?: outputs.AppServiceSlotAuthSettingsMicrosoft;
    runtimeVersion?: string;
    tokenRefreshExtensionHours?: number;
    tokenStoreEnabled?: boolean;
    twitter?: outputs.AppServiceSlotAuthSettingsTwitter;
    unauthenticatedClientAction?: string;
}

export interface AppServiceSlotAuthSettingsActiveDirectory {
    allowedAudiences?: string[];
    clientId: string;
    clientSecret?: string;
}

export interface AppServiceSlotAuthSettingsFacebook {
    appId: string;
    appSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceSlotAuthSettingsGoogle {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceSlotAuthSettingsMicrosoft {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface AppServiceSlotAuthSettingsTwitter {
    consumerKey: string;
    consumerSecret: string;
}

export interface AppServiceSlotConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface AppServiceSlotCustomHostnameBindingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface AppServiceSlotLogs {
    applicationLogs?: outputs.AppServiceSlotLogsApplicationLogs;
    detailedErrorMessagesEnabled?: boolean;
    failedRequestTracingEnabled?: boolean;
    httpLogs?: outputs.AppServiceSlotLogsHttpLogs;
}

export interface AppServiceSlotLogsApplicationLogs {
    azureBlobStorage?: outputs.AppServiceSlotLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel?: string;
}

export interface AppServiceSlotLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface AppServiceSlotLogsHttpLogs {
    azureBlobStorage?: outputs.AppServiceSlotLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.AppServiceSlotLogsHttpLogsFileSystem;
}

export interface AppServiceSlotLogsHttpLogsAzureBlobStorage {
    retentionInDays: number;
    sasUrl: string;
}

export interface AppServiceSlotLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface AppServiceSlotSiteConfig {
    acrUseManagedIdentityCredentials?: boolean;
    acrUserManagedIdentityClientId?: string;
    alwaysOn?: boolean;
    appCommandLine?: string;
    autoSwapSlotName?: string;
    cors?: outputs.AppServiceSlotSiteConfigCors;
    defaultDocuments?: string[];
    dotnetFrameworkVersion?: string;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.AppServiceSlotSiteConfigIpRestriction[];
    javaContainer?: string;
    javaContainerVersion?: string;
    javaVersion?: string;
    linuxFxVersion: string;
    localMysqlEnabled: boolean;
    managedPipelineMode: string;
    minTlsVersion: string;
    numberOfWorkers: number;
    phpVersion?: string;
    pythonVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictions: outputs.AppServiceSlotSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    windowsFxVersion: string;
}

export interface AppServiceSlotSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface AppServiceSlotSiteConfigIpRestriction {
    action: string;
    headers: outputs.AppServiceSlotSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface AppServiceSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface AppServiceSlotSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.AppServiceSlotSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface AppServiceSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface AppServiceSlotSiteCredential {
    password: string;
    username: string;
}

export interface AppServiceSlotStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface AppServiceSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceSlotVirtualNetworkSwiftConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceSourceControl {
    branch: string;
    manualIntegration: boolean;
    repoUrl: string;
    rollbackEnabled: boolean;
    useMercurial: boolean;
}

export interface AppServiceSourceControlGithubActionConfiguration {
    codeConfiguration?: outputs.AppServiceSourceControlGithubActionConfigurationCodeConfiguration;
    containerConfiguration?: outputs.AppServiceSourceControlGithubActionConfigurationContainerConfiguration;
    /**
     * Should the service generate the GitHub Action Workflow file. Defaults to `true`
     */
    generateWorkflowFile?: boolean;
    /**
     * Denotes this action uses a Linux base image.
     */
    linuxAction: boolean;
}

export interface AppServiceSourceControlGithubActionConfigurationCodeConfiguration {
    /**
     * The value to use for the Runtime Stack in the workflow file content for code base apps.
     */
    runtimeStack: string;
    /**
     * The value to use for the Runtime Version in the workflow file content for code base apps.
     */
    runtimeVersion: string;
}

export interface AppServiceSourceControlGithubActionConfigurationContainerConfiguration {
    /**
     * The image name for the build.
     */
    imageName: string;
    /**
     * The password used to upload the image to the container registry.
     */
    registryPassword?: string;
    /**
     * The server URL for the container registry where the build will be hosted.
     */
    registryUrl: string;
    /**
     * The username used to upload the image to the container registry.
     */
    registryUsername?: string;
}

export interface AppServiceSourceControlSlotGithubActionConfiguration {
    codeConfiguration?: outputs.AppServiceSourceControlSlotGithubActionConfigurationCodeConfiguration;
    containerConfiguration?: outputs.AppServiceSourceControlSlotGithubActionConfigurationContainerConfiguration;
    /**
     * Should the service generate the GitHub Action Workflow file. Defaults to `true`
     */
    generateWorkflowFile?: boolean;
    /**
     * Denotes this action uses a Linux base image.
     */
    linuxAction: boolean;
}

export interface AppServiceSourceControlSlotGithubActionConfigurationCodeConfiguration {
    /**
     * The value to use for the Runtime Stack in the workflow file content for code base apps.
     */
    runtimeStack: string;
    /**
     * The value to use for the Runtime Version in the workflow file content for code base apps.
     */
    runtimeVersion: string;
}

export interface AppServiceSourceControlSlotGithubActionConfigurationContainerConfiguration {
    /**
     * The image name for the build.
     */
    imageName: string;
    /**
     * The password used to upload the image to the container registry.
     */
    registryPassword?: string;
    /**
     * The server URL for the container registry where the build will be hosted.
     */
    registryUrl: string;
    /**
     * The username used to upload the image to the container registry.
     */
    registryUsername?: string;
}

export interface AppServiceSourceControlSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceSourceControlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AppServiceSourceControlTokenTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface AppServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppServiceVirtualNetworkSwiftConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationGatewayAuthenticationCertificate {
    data: string;
    id: string;
    name: string;
}

export interface ApplicationGatewayAutoscaleConfiguration {
    maxCapacity?: number;
    minCapacity: number;
}

export interface ApplicationGatewayBackendAddressPool {
    fqdns?: string[];
    id: string;
    ipAddresses?: string[];
    name: string;
}

export interface ApplicationGatewayBackendHttpSetting {
    affinityCookieName?: string;
    authenticationCertificates?: outputs.ApplicationGatewayBackendHttpSettingAuthenticationCertificate[];
    connectionDraining?: outputs.ApplicationGatewayBackendHttpSettingConnectionDraining;
    cookieBasedAffinity: string;
    hostName?: string;
    id: string;
    name: string;
    path?: string;
    pickHostNameFromBackendAddress?: boolean;
    port: number;
    probeId: string;
    probeName?: string;
    protocol: string;
    requestTimeout?: number;
    trustedRootCertificateNames?: string[];
}

export interface ApplicationGatewayBackendHttpSettingAuthenticationCertificate {
    id: string;
    name: string;
}

export interface ApplicationGatewayBackendHttpSettingConnectionDraining {
    drainTimeoutSec: number;
    enabled: boolean;
}

export interface ApplicationGatewayCustomErrorConfiguration {
    customErrorPageUrl: string;
    id: string;
    statusCode: string;
}

export interface ApplicationGatewayFrontendIpConfiguration {
    id: string;
    name: string;
    privateIpAddress: string;
    privateIpAddressAllocation?: string;
    privateLinkConfigurationId: string;
    privateLinkConfigurationName?: string;
    publicIpAddressId?: string;
    subnetId?: string;
}

export interface ApplicationGatewayFrontendPort {
    id: string;
    name: string;
    port: number;
}

export interface ApplicationGatewayGatewayIpConfiguration {
    id: string;
    name: string;
    subnetId: string;
}

export interface ApplicationGatewayGlobal {
    requestBufferingEnabled: boolean;
    responseBufferingEnabled: boolean;
}

export interface ApplicationGatewayHttpListener {
    customErrorConfigurations?: outputs.ApplicationGatewayHttpListenerCustomErrorConfiguration[];
    firewallPolicyId?: string;
    frontendIpConfigurationId: string;
    frontendIpConfigurationName: string;
    frontendPortId: string;
    frontendPortName: string;
    hostName?: string;
    hostNames?: string[];
    id: string;
    name: string;
    protocol: string;
    requireSni?: boolean;
    sslCertificateId: string;
    sslCertificateName?: string;
    sslProfileId: string;
    sslProfileName?: string;
}

export interface ApplicationGatewayHttpListenerCustomErrorConfiguration {
    customErrorPageUrl: string;
    id: string;
    statusCode: string;
}

export interface ApplicationGatewayIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ApplicationGatewayPrivateEndpointConnection {
    id: string;
    name: string;
}

export interface ApplicationGatewayPrivateLinkConfiguration {
    id: string;
    ipConfigurations: outputs.ApplicationGatewayPrivateLinkConfigurationIpConfiguration[];
    name: string;
}

export interface ApplicationGatewayPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary: boolean;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    subnetId: string;
}

export interface ApplicationGatewayProbe {
    host?: string;
    id: string;
    interval: number;
    match?: outputs.ApplicationGatewayProbeMatch;
    minimumServers?: number;
    name: string;
    path: string;
    pickHostNameFromBackendHttpSettings?: boolean;
    port?: number;
    protocol: string;
    timeout: number;
    unhealthyThreshold: number;
}

export interface ApplicationGatewayProbeMatch {
    body?: string;
    statusCodes: string[];
}

export interface ApplicationGatewayRedirectConfiguration {
    id: string;
    includePath?: boolean;
    includeQueryString?: boolean;
    name: string;
    redirectType: string;
    targetListenerId: string;
    targetListenerName?: string;
    targetUrl?: string;
}

export interface ApplicationGatewayRequestRoutingRule {
    backendAddressPoolId: string;
    backendAddressPoolName?: string;
    backendHttpSettingsId: string;
    backendHttpSettingsName?: string;
    httpListenerId: string;
    httpListenerName: string;
    id: string;
    name: string;
    priority?: number;
    redirectConfigurationId: string;
    redirectConfigurationName?: string;
    rewriteRuleSetId: string;
    rewriteRuleSetName?: string;
    ruleType: string;
    urlPathMapId: string;
    urlPathMapName?: string;
}

export interface ApplicationGatewayRewriteRuleSet {
    id: string;
    name: string;
    rewriteRules?: outputs.ApplicationGatewayRewriteRuleSetRewriteRule[];
}

export interface ApplicationGatewayRewriteRuleSetRewriteRule {
    conditions?: outputs.ApplicationGatewayRewriteRuleSetRewriteRuleCondition[];
    name: string;
    requestHeaderConfigurations?: outputs.ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration[];
    responseHeaderConfigurations?: outputs.ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration[];
    ruleSequence: number;
    url?: outputs.ApplicationGatewayRewriteRuleSetRewriteRuleUrl;
}

export interface ApplicationGatewayRewriteRuleSetRewriteRuleCondition {
    ignoreCase?: boolean;
    negate?: boolean;
    pattern: string;
    variable: string;
}

export interface ApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration {
    headerName: string;
    headerValue: string;
}

export interface ApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration {
    headerName: string;
    headerValue: string;
}

export interface ApplicationGatewayRewriteRuleSetRewriteRuleUrl {
    components?: string;
    path?: string;
    queryString?: string;
    reroute?: boolean;
}

export interface ApplicationGatewaySku {
    capacity?: number;
    name: string;
    tier: string;
}

export interface ApplicationGatewaySslCertificate {
    data?: string;
    id: string;
    keyVaultSecretId?: string;
    name: string;
    password?: string;
    publicCertData: string;
}

export interface ApplicationGatewaySslPolicy {
    cipherSuites?: string[];
    disabledProtocols?: string[];
    minProtocolVersion?: string;
    policyName?: string;
    policyType?: string;
}

export interface ApplicationGatewaySslProfile {
    id: string;
    name: string;
    sslPolicy?: outputs.ApplicationGatewaySslProfileSslPolicy;
    trustedClientCertificateNames?: string[];
    verifyClientCertIssuerDn?: boolean;
    verifyClientCertificateRevocation?: string;
}

export interface ApplicationGatewaySslProfileSslPolicy {
    cipherSuites?: string[];
    disabledProtocols?: string[];
    minProtocolVersion?: string;
    policyName?: string;
    policyType?: string;
}

export interface ApplicationGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationGatewayTrustedClientCertificate {
    data: string;
    id: string;
    name: string;
}

export interface ApplicationGatewayTrustedRootCertificate {
    data?: string;
    id: string;
    keyVaultSecretId?: string;
    name: string;
}

export interface ApplicationGatewayUrlPathMap {
    defaultBackendAddressPoolId: string;
    defaultBackendAddressPoolName?: string;
    defaultBackendHttpSettingsId: string;
    defaultBackendHttpSettingsName?: string;
    defaultRedirectConfigurationId: string;
    defaultRedirectConfigurationName?: string;
    defaultRewriteRuleSetId: string;
    defaultRewriteRuleSetName?: string;
    id: string;
    name: string;
    pathRules: outputs.ApplicationGatewayUrlPathMapPathRule[];
}

export interface ApplicationGatewayUrlPathMapPathRule {
    backendAddressPoolId: string;
    backendAddressPoolName?: string;
    backendHttpSettingsId: string;
    backendHttpSettingsName?: string;
    firewallPolicyId?: string;
    id: string;
    name: string;
    paths: string[];
    redirectConfigurationId: string;
    redirectConfigurationName?: string;
    rewriteRuleSetId: string;
    rewriteRuleSetName?: string;
}

export interface ApplicationGatewayWafConfiguration {
    disabledRuleGroups?: outputs.ApplicationGatewayWafConfigurationDisabledRuleGroup[];
    enabled: boolean;
    exclusions?: outputs.ApplicationGatewayWafConfigurationExclusion[];
    fileUploadLimitMb?: number;
    firewallMode: string;
    maxRequestBodySizeKb?: number;
    requestBodyCheck?: boolean;
    ruleSetType?: string;
    ruleSetVersion: string;
}

export interface ApplicationGatewayWafConfigurationDisabledRuleGroup {
    ruleGroupName: string;
    rules?: number[];
}

export interface ApplicationGatewayWafConfigurationExclusion {
    matchVariable: string;
    selector?: string;
    selectorMatchOperator?: string;
}

export interface ApplicationInsightsAnalyticsItemTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsApiKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApplicationInsightsSmartDetectionRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsStandardWebTestRequest {
    body?: string;
    followRedirectsEnabled?: boolean;
    headers?: outputs.ApplicationInsightsStandardWebTestRequestHeader[];
    httpVerb?: string;
    parseDependentRequestsEnabled?: boolean;
    url: string;
}

export interface ApplicationInsightsStandardWebTestRequestHeader {
    name: string;
    value: string;
}

export interface ApplicationInsightsStandardWebTestTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsStandardWebTestValidationRules {
    content?: outputs.ApplicationInsightsStandardWebTestValidationRulesContent;
    expectedStatusCode?: number;
    sslCertRemainingLifetime?: number;
    sslCheckEnabled?: boolean;
}

export interface ApplicationInsightsStandardWebTestValidationRulesContent {
    contentMatch: string;
    ignoreCase?: boolean;
    passIfTextFound?: boolean;
}

export interface ApplicationInsightsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsWebTestTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsWorkbookIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ApplicationInsightsWorkbookTemplateGallery {
    category: string;
    name: string;
    order?: number;
    resourceType?: string;
    type?: string;
}

export interface ApplicationInsightsWorkbookTemplateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationInsightsWorkbookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationLoadBalancerFrontendTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationLoadBalancerSubnetAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationSecurityGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcKubernetesClusterExtensionIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ArcKubernetesClusterExtensionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcKubernetesClusterIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ArcKubernetesClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcKubernetesFluxConfigurationBlobStorage {
    accountKey?: string;
    containerId: string;
    localAuthReference?: string;
    sasToken?: string;
    servicePrincipal?: outputs.ArcKubernetesFluxConfigurationBlobStorageServicePrincipal;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
}

export interface ArcKubernetesFluxConfigurationBlobStorageServicePrincipal {
    clientCertificateBase64?: string;
    clientCertificatePassword?: string;
    clientCertificateSendChain?: boolean;
    clientId: string;
    clientSecret?: string;
    tenantId: string;
}

export interface ArcKubernetesFluxConfigurationBucket {
    accessKey?: string;
    bucketName: string;
    localAuthReference?: string;
    secretKeyBase64?: string;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
    tlsEnabled?: boolean;
    url: string;
}

export interface ArcKubernetesFluxConfigurationGitRepository {
    httpsCaCertBase64?: string;
    httpsKeyBase64?: string;
    httpsUser?: string;
    localAuthReference?: string;
    referenceType: string;
    referenceValue: string;
    sshKnownHostsBase64?: string;
    sshPrivateKeyBase64?: string;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
    url: string;
}

export interface ArcKubernetesFluxConfigurationKustomization {
    dependsOns?: string[];
    garbageCollectionEnabled?: boolean;
    name: string;
    path?: string;
    recreatingEnabled?: boolean;
    retryIntervalInSeconds?: number;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
}

export interface ArcKubernetesFluxConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcMachineExtensionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcPrivateLinkScopeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ArcResourceBridgeApplianceIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ArcResourceBridgeApplianceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AttestationProviderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomanageConfigurationAntimalware {
    exclusions?: outputs.AutomanageConfigurationAntimalwareExclusions;
    realTimeProtectionEnabled?: boolean;
    scheduledScanDay?: number;
    scheduledScanEnabled?: boolean;
    scheduledScanTimeInMinutes?: number;
    scheduledScanType?: string;
}

export interface AutomanageConfigurationAntimalwareExclusions {
    extensions?: string;
    paths?: string;
    processes?: string;
}

export interface AutomanageConfigurationAzureSecurityBaseline {
    assignmentType?: string;
}

export interface AutomanageConfigurationBackup {
    instantRpRetentionRangeInDays?: number;
    policyName?: string;
    retentionPolicy?: outputs.AutomanageConfigurationBackupRetentionPolicy;
    schedulePolicy?: outputs.AutomanageConfigurationBackupSchedulePolicy;
    timeZone?: string;
}

export interface AutomanageConfigurationBackupRetentionPolicy {
    dailySchedule?: outputs.AutomanageConfigurationBackupRetentionPolicyDailySchedule;
    retentionPolicyType?: string;
    weeklySchedule?: outputs.AutomanageConfigurationBackupRetentionPolicyWeeklySchedule;
}

export interface AutomanageConfigurationBackupRetentionPolicyDailySchedule {
    retentionDuration?: outputs.AutomanageConfigurationBackupRetentionPolicyDailyScheduleRetentionDuration;
    retentionTimes?: string[];
}

export interface AutomanageConfigurationBackupRetentionPolicyDailyScheduleRetentionDuration {
    count?: number;
    durationType?: string;
}

export interface AutomanageConfigurationBackupRetentionPolicyWeeklySchedule {
    retentionDuration?: outputs.AutomanageConfigurationBackupRetentionPolicyWeeklyScheduleRetentionDuration;
    retentionTimes?: string[];
}

export interface AutomanageConfigurationBackupRetentionPolicyWeeklyScheduleRetentionDuration {
    count?: number;
    durationType?: string;
}

export interface AutomanageConfigurationBackupSchedulePolicy {
    schedulePolicyType?: string;
    scheduleRunDays?: string[];
    scheduleRunFrequency?: string;
    scheduleRunTimes?: string[];
}

export interface AutomanageConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationAccountEncryption {
    /**
     * @deprecated Deprecated
     */
    keySource?: string;
    keyVaultKeyId: string;
    userAssignedIdentityId?: string;
}

export interface AutomationAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface AutomationAccountPrivateEndpointConnection {
    id: string;
    name: string;
}

export interface AutomationAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationConnectionCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationConnectionClassicCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationConnectionServicePrincipalTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationConnectionTypeField {
    isEncrypted?: boolean;
    isOptional?: boolean;
    name: string;
    type: string;
}

export interface AutomationConnectionTypeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AutomationCredentialTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationDscConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationDscNodeconfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationHybridRunbookWorkerGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationHybridRunbookWorkerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AutomationJobScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AutomationModuleModuleLink {
    hash?: outputs.AutomationModuleModuleLinkHash;
    uri: string;
}

export interface AutomationModuleModuleLinkHash {
    algorithm: string;
    value: string;
}

export interface AutomationModuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationPowershell72ModuleModuleLink {
    hash?: outputs.AutomationPowershell72ModuleModuleLinkHash;
    uri: string;
}

export interface AutomationPowershell72ModuleModuleLinkHash {
    algorithm: string;
    value: string;
}

export interface AutomationPowershell72ModuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationPython3PackageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationRunbookDraft {
    contentLink?: outputs.AutomationRunbookDraftContentLink;
    creationTime: string;
    editModeEnabled?: boolean;
    lastModifiedTime: string;
    outputTypes?: string[];
    parameters?: outputs.AutomationRunbookDraftParameter[];
}

export interface AutomationRunbookDraftContentLink {
    hash?: outputs.AutomationRunbookDraftContentLinkHash;
    uri: string;
    version?: string;
}

export interface AutomationRunbookDraftContentLinkHash {
    algorithm: string;
    value: string;
}

export interface AutomationRunbookDraftParameter {
    defaultValue?: string;
    key: string;
    mandatory?: boolean;
    position?: number;
    type: string;
}

export interface AutomationRunbookJobSchedule {
    jobScheduleId: string;
    parameters: {[key: string]: string};
    runOn: string;
    scheduleName: string;
}

export interface AutomationRunbookPublishContentLink {
    hash?: outputs.AutomationRunbookPublishContentLinkHash;
    uri: string;
    version?: string;
}

export interface AutomationRunbookPublishContentLinkHash {
    algorithm: string;
    value: string;
}

export interface AutomationRunbookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationScheduleMonthlyOccurrence {
    day: string;
    occurrence: number;
}

export interface AutomationScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationSoftwareUpdateConfigurationLinux {
    classificationsIncludeds: string[];
    excludedPackages?: string[];
    includedPackages?: string[];
    reboot?: string;
}

export interface AutomationSoftwareUpdateConfigurationPostTask {
    parameters?: {[key: string]: string};
    source?: string;
}

export interface AutomationSoftwareUpdateConfigurationPreTask {
    parameters?: {[key: string]: string};
    source?: string;
}

export interface AutomationSoftwareUpdateConfigurationSchedule {
    advancedMonthDays?: number[];
    advancedWeekDays?: string[];
    creationTime: string;
    description?: string;
    expiryTime: string;
    expiryTimeOffsetMinutes?: number;
    frequency: string;
    interval?: number;
    isEnabled?: boolean;
    lastModifiedTime: string;
    monthlyOccurrence?: outputs.AutomationSoftwareUpdateConfigurationScheduleMonthlyOccurrence;
    nextRun: string;
    nextRunOffsetMinutes?: number;
    startTime: string;
    startTimeOffsetMinutes?: number;
    timeZone?: string;
}

export interface AutomationSoftwareUpdateConfigurationScheduleMonthlyOccurrence {
    day: string;
    occurrence: number;
}

export interface AutomationSoftwareUpdateConfigurationTarget {
    azureQueries?: outputs.AutomationSoftwareUpdateConfigurationTargetAzureQuery[];
    nonAzureQueries?: outputs.AutomationSoftwareUpdateConfigurationTargetNonAzureQuery[];
}

export interface AutomationSoftwareUpdateConfigurationTargetAzureQuery {
    locations?: string[];
    scopes?: string[];
    tagFilter?: string;
    tags?: outputs.AutomationSoftwareUpdateConfigurationTargetAzureQueryTag[];
}

export interface AutomationSoftwareUpdateConfigurationTargetAzureQueryTag {
    tag: string;
    values: string[];
}

export interface AutomationSoftwareUpdateConfigurationTargetNonAzureQuery {
    functionAlias?: string;
    workspaceId?: string;
}

export interface AutomationSoftwareUpdateConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationSoftwareUpdateConfigurationWindows {
    classificationsIncludeds: string[];
    excludedKnowledgeBaseNumbers?: string[];
    includedKnowledgeBaseNumbers?: string[];
    reboot?: string;
}

export interface AutomationSourceControlSecurity {
    refreshToken?: string;
    token: string;
    tokenType: string;
}

export interface AutomationSourceControlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationVariableBoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationVariableDatetimeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationVariableIntTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationVariableObjectTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationVariableStringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationWatcherTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AutomationWebhookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AvailabilitySetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupContainerStorageAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface BackupPolicyFileShareBackup {
    frequency: string;
    hourly?: outputs.BackupPolicyFileShareBackupHourly;
    time?: string;
}

export interface BackupPolicyFileShareBackupHourly {
    interval: number;
    startTime: string;
    windowDuration: number;
}

export interface BackupPolicyFileShareRetentionDaily {
    count: number;
}

export interface BackupPolicyFileShareRetentionMonthly {
    count: number;
    days?: number[];
    includeLastDays?: boolean;
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyFileShareRetentionWeekly {
    count: number;
    weekdays: string[];
}

export interface BackupPolicyFileShareRetentionYearly {
    count: number;
    days?: number[];
    includeLastDays?: boolean;
    months: string[];
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyFileShareTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupPolicyVmBackup {
    frequency: string;
    hourDuration?: number;
    hourInterval?: number;
    time: string;
    weekdays?: string[];
}

export interface BackupPolicyVmInstantRestoreResourceGroup {
    prefix: string;
    suffix?: string;
}

export interface BackupPolicyVmRetentionDaily {
    count: number;
}

export interface BackupPolicyVmRetentionMonthly {
    count: number;
    days?: number[];
    includeLastDays?: boolean;
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyVmRetentionWeekly {
    count: number;
    weekdays: string[];
}

export interface BackupPolicyVmRetentionYearly {
    count: number;
    days?: number[];
    includeLastDays?: boolean;
    months: string[];
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyVmTieringPolicy {
    archivedRestorePoint: outputs.BackupPolicyVmTieringPolicyArchivedRestorePoint;
}

export interface BackupPolicyVmTieringPolicyArchivedRestorePoint {
    duration?: number;
    durationType?: string;
    mode: string;
}

export interface BackupPolicyVmTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupPolicyVmWorkloadProtectionPolicy {
    backup: outputs.BackupPolicyVmWorkloadProtectionPolicyBackup;
    policyType: string;
    retentionDaily?: outputs.BackupPolicyVmWorkloadProtectionPolicyRetentionDaily;
    retentionMonthly?: outputs.BackupPolicyVmWorkloadProtectionPolicyRetentionMonthly;
    retentionWeekly?: outputs.BackupPolicyVmWorkloadProtectionPolicyRetentionWeekly;
    retentionYearly?: outputs.BackupPolicyVmWorkloadProtectionPolicyRetentionYearly;
    simpleRetention?: outputs.BackupPolicyVmWorkloadProtectionPolicySimpleRetention;
}

export interface BackupPolicyVmWorkloadProtectionPolicyBackup {
    frequency?: string;
    frequencyInMinutes?: number;
    time?: string;
    weekdays?: string[];
}

export interface BackupPolicyVmWorkloadProtectionPolicyRetentionDaily {
    count: number;
}

export interface BackupPolicyVmWorkloadProtectionPolicyRetentionMonthly {
    count: number;
    formatType: string;
    monthdays?: number[];
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyVmWorkloadProtectionPolicyRetentionWeekly {
    count: number;
    weekdays: string[];
}

export interface BackupPolicyVmWorkloadProtectionPolicyRetentionYearly {
    count: number;
    formatType: string;
    monthdays?: number[];
    months: string[];
    weekdays?: string[];
    weeks?: string[];
}

export interface BackupPolicyVmWorkloadProtectionPolicySimpleRetention {
    count: number;
}

export interface BackupPolicyVmWorkloadSettings {
    compressionEnabled?: boolean;
    timeZone: string;
}

export interface BackupPolicyVmWorkloadTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupProtectedFileShareTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BackupProtectedVmTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BastionHostIpConfiguration {
    name: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface BastionHostTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchAccountEncryption {
    keyVaultKeyId: string;
}

export interface BatchAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface BatchAccountKeyVaultReference {
    id: string;
    url: string;
}

export interface BatchAccountNetworkProfile {
    accountAccess?: outputs.BatchAccountNetworkProfileAccountAccess;
    nodeManagementAccess?: outputs.BatchAccountNetworkProfileNodeManagementAccess;
}

export interface BatchAccountNetworkProfileAccountAccess {
    defaultAction?: string;
    ipRules?: outputs.BatchAccountNetworkProfileAccountAccessIpRule[];
}

export interface BatchAccountNetworkProfileAccountAccessIpRule {
    action?: string;
    ipRange: string;
}

export interface BatchAccountNetworkProfileNodeManagementAccess {
    defaultAction?: string;
    ipRules?: outputs.BatchAccountNetworkProfileNodeManagementAccessIpRule[];
}

export interface BatchAccountNetworkProfileNodeManagementAccessIpRule {
    action?: string;
    ipRange: string;
}

export interface BatchAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchJobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchPoolAutoScale {
    evaluationInterval?: string;
    formula: string;
}

export interface BatchPoolCertificate {
    id: string;
    storeLocation: string;
    storeName?: string;
    visibilities?: string[];
}

export interface BatchPoolContainerConfiguration {
    containerImageNames?: string[];
    containerRegistries?: outputs.BatchPoolContainerConfigurationContainerRegistry[];
    type?: string;
}

export interface BatchPoolContainerConfigurationContainerRegistry {
    password: string;
    registryServer: string;
    userAssignedIdentityId: string;
    userName: string;
}

export interface BatchPoolDataDisk {
    caching?: string;
    diskSizeGb: number;
    lun: number;
    storageAccountType?: string;
}

export interface BatchPoolDiskEncryption {
    diskEncryptionTarget: string;
}

export interface BatchPoolExtension {
    autoUpgradeMinorVersion?: boolean;
    automaticUpgradeEnabled?: boolean;
    name: string;
    protectedSettings?: string;
    provisionAfterExtensions?: string[];
    publisher: string;
    settingsJson?: string;
    type: string;
    typeHandlerVersion?: string;
}

export interface BatchPoolFixedScale {
    nodeDeallocationMethod?: string;
    resizeTimeout?: string;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
}

export interface BatchPoolIdentity {
    identityIds: string[];
    type: string;
}

export interface BatchPoolMount {
    azureBlobFileSystem?: outputs.BatchPoolMountAzureBlobFileSystem;
    azureFileShares?: outputs.BatchPoolMountAzureFileShare[];
    cifsMounts?: outputs.BatchPoolMountCifsMount[];
    nfsMounts?: outputs.BatchPoolMountNfsMount[];
}

export interface BatchPoolMountAzureBlobFileSystem {
    accountKey?: string;
    accountName: string;
    blobfuseOptions?: string;
    containerName: string;
    identityId?: string;
    relativeMountPath: string;
    sasKey?: string;
}

export interface BatchPoolMountAzureFileShare {
    accountKey: string;
    accountName: string;
    azureFileUrl: string;
    mountOptions?: string;
    relativeMountPath: string;
}

export interface BatchPoolMountCifsMount {
    mountOptions?: string;
    password: string;
    relativeMountPath: string;
    source: string;
    userName: string;
}

export interface BatchPoolMountNfsMount {
    mountOptions?: string;
    relativeMountPath: string;
    source: string;
}

export interface BatchPoolNetworkConfiguration {
    acceleratedNetworkingEnabled?: boolean;
    dynamicVnetAssignmentScope?: string;
    endpointConfigurations?: outputs.BatchPoolNetworkConfigurationEndpointConfiguration[];
    publicAddressProvisioningType?: string;
    publicIps?: string[];
    subnetId?: string;
}

export interface BatchPoolNetworkConfigurationEndpointConfiguration {
    backendPort: number;
    frontendPortRange: string;
    name: string;
    networkSecurityGroupRules?: outputs.BatchPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
    protocol: string;
}

export interface BatchPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
    access: string;
    priority: number;
    sourceAddressPrefix: string;
    sourcePortRanges: string[];
}

export interface BatchPoolNodePlacement {
    policy?: string;
}

export interface BatchPoolStartTask {
    commandLine: string;
    commonEnvironmentProperties?: {[key: string]: string};
    containers?: outputs.BatchPoolStartTaskContainer[];
    resourceFiles?: outputs.BatchPoolStartTaskResourceFile[];
    taskRetryMaximum?: number;
    userIdentity: outputs.BatchPoolStartTaskUserIdentity;
    waitForSuccess?: boolean;
}

export interface BatchPoolStartTaskContainer {
    imageName: string;
    registries?: outputs.BatchPoolStartTaskContainerRegistry[];
    runOptions?: string;
    workingDirectory?: string;
}

export interface BatchPoolStartTaskContainerRegistry {
    password?: string;
    registryServer: string;
    /**
     * The User Assigned Identity to use for Container Registry access.
     */
    userAssignedIdentityId?: string;
    userName?: string;
}

export interface BatchPoolStartTaskResourceFile {
    autoStorageContainerName?: string;
    blobPrefix?: string;
    fileMode?: string;
    filePath?: string;
    httpUrl?: string;
    storageContainerUrl?: string;
    userAssignedIdentityId?: string;
}

export interface BatchPoolStartTaskUserIdentity {
    autoUser?: outputs.BatchPoolStartTaskUserIdentityAutoUser;
    userName?: string;
}

export interface BatchPoolStartTaskUserIdentityAutoUser {
    elevationLevel?: string;
    scope?: string;
}

export interface BatchPoolStorageImageReference {
    id?: string;
    offer?: string;
    publisher?: string;
    sku?: string;
    version?: string;
}

export interface BatchPoolTaskSchedulingPolicy {
    nodeFillType: string;
}

export interface BatchPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BatchPoolUserAccount {
    elevationLevel: string;
    linuxUserConfigurations?: outputs.BatchPoolUserAccountLinuxUserConfiguration[];
    name: string;
    password: string;
    windowsUserConfigurations?: outputs.BatchPoolUserAccountWindowsUserConfiguration[];
}

export interface BatchPoolUserAccountLinuxUserConfiguration {
    gid?: number;
    sshPrivateKey?: string;
    uid?: number;
}

export interface BatchPoolUserAccountWindowsUserConfiguration {
    loginMode: string;
}

export interface BatchPoolWindow {
    enableAutomaticUpdates?: boolean;
}

export interface BillingAccountCostManagementExportExportDataOptions {
    timeFrame: string;
    type: string;
}

export interface BillingAccountCostManagementExportExportDataStorageLocation {
    containerId: string;
    rootFolderPath: string;
}

export interface BillingAccountCostManagementExportTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BlueprintAssignmentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface BlueprintAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelAlexaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelDirectLineSpeechTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelDirectlineSite {
    enabled?: boolean;
    endpointParametersEnabled?: boolean;
    enhancedAuthenticationEnabled?: boolean;
    id: string;
    key: string;
    key2: string;
    name: string;
    storageEnabled?: boolean;
    trustedOrigins?: string[];
    userUploadEnabled?: boolean;
    v1Allowed?: boolean;
    v3Allowed?: boolean;
}

export interface BotChannelDirectlineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelEmailTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelFacebookPage {
    accessToken: string;
    id: string;
}

export interface BotChannelFacebookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelLineLineChannel {
    accessToken: string;
    secret: string;
}

export interface BotChannelLineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelMsTeamsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelSlackTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelSmsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelWebChatSite {
    endpointParametersEnabled?: boolean;
    name: string;
    storageEnabled?: boolean;
    userUploadEnabled?: boolean;
}

export interface BotChannelWebChatTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotChannelsRegistrationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotServiceAzureBotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface BotWebAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CapacityReservationGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CapacityReservationSku {
    capacity: number;
    name: string;
}

export interface CapacityReservationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnEndpointCustomDomainCdnManagedHttps {
    certificateType: string;
    protocolType: string;
    tlsVersion?: string;
}

export interface CdnEndpointCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnEndpointCustomDomainUserManagedHttps {
    keyVaultSecretId: string;
    tlsVersion?: string;
}

export interface CdnEndpointDeliveryRule {
    cacheExpirationAction?: outputs.CdnEndpointDeliveryRuleCacheExpirationAction;
    cacheKeyQueryStringAction?: outputs.CdnEndpointDeliveryRuleCacheKeyQueryStringAction;
    cookiesConditions?: outputs.CdnEndpointDeliveryRuleCookiesCondition[];
    deviceCondition?: outputs.CdnEndpointDeliveryRuleDeviceCondition;
    httpVersionConditions?: outputs.CdnEndpointDeliveryRuleHttpVersionCondition[];
    modifyRequestHeaderActions?: outputs.CdnEndpointDeliveryRuleModifyRequestHeaderAction[];
    modifyResponseHeaderActions?: outputs.CdnEndpointDeliveryRuleModifyResponseHeaderAction[];
    name: string;
    order: number;
    postArgConditions?: outputs.CdnEndpointDeliveryRulePostArgCondition[];
    queryStringConditions?: outputs.CdnEndpointDeliveryRuleQueryStringCondition[];
    remoteAddressConditions?: outputs.CdnEndpointDeliveryRuleRemoteAddressCondition[];
    requestBodyConditions?: outputs.CdnEndpointDeliveryRuleRequestBodyCondition[];
    requestHeaderConditions?: outputs.CdnEndpointDeliveryRuleRequestHeaderCondition[];
    requestMethodCondition?: outputs.CdnEndpointDeliveryRuleRequestMethodCondition;
    requestSchemeCondition?: outputs.CdnEndpointDeliveryRuleRequestSchemeCondition;
    requestUriConditions?: outputs.CdnEndpointDeliveryRuleRequestUriCondition[];
    urlFileExtensionConditions?: outputs.CdnEndpointDeliveryRuleUrlFileExtensionCondition[];
    urlFileNameConditions?: outputs.CdnEndpointDeliveryRuleUrlFileNameCondition[];
    urlPathConditions?: outputs.CdnEndpointDeliveryRuleUrlPathCondition[];
    urlRedirectAction?: outputs.CdnEndpointDeliveryRuleUrlRedirectAction;
    urlRewriteAction?: outputs.CdnEndpointDeliveryRuleUrlRewriteAction;
}

export interface CdnEndpointDeliveryRuleCacheExpirationAction {
    behavior: string;
    duration?: string;
}

export interface CdnEndpointDeliveryRuleCacheKeyQueryStringAction {
    behavior: string;
    parameters?: string;
}

export interface CdnEndpointDeliveryRuleCookiesCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    selector: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleDeviceCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnEndpointDeliveryRuleHttpVersionCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnEndpointDeliveryRuleModifyRequestHeaderAction {
    action: string;
    name: string;
    value?: string;
}

export interface CdnEndpointDeliveryRuleModifyResponseHeaderAction {
    action: string;
    name: string;
    value?: string;
}

export interface CdnEndpointDeliveryRulePostArgCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    selector: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleQueryStringCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleRemoteAddressCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
}

export interface CdnEndpointDeliveryRuleRequestBodyCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleRequestHeaderCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    selector: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleRequestMethodCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnEndpointDeliveryRuleRequestSchemeCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnEndpointDeliveryRuleRequestUriCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleUrlFileExtensionCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleUrlFileNameCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleUrlPathCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnEndpointDeliveryRuleUrlRedirectAction {
    fragment?: string;
    hostname?: string;
    path?: string;
    protocol?: string;
    queryString?: string;
    redirectType: string;
}

export interface CdnEndpointDeliveryRuleUrlRewriteAction {
    destination: string;
    preserveUnmatchedPath?: boolean;
    sourcePattern: string;
}

export interface CdnEndpointGeoFilter {
    action: string;
    countryCodes: string[];
    relativePath: string;
}

export interface CdnEndpointGlobalDeliveryRule {
    cacheExpirationAction?: outputs.CdnEndpointGlobalDeliveryRuleCacheExpirationAction;
    cacheKeyQueryStringAction?: outputs.CdnEndpointGlobalDeliveryRuleCacheKeyQueryStringAction;
    modifyRequestHeaderActions?: outputs.CdnEndpointGlobalDeliveryRuleModifyRequestHeaderAction[];
    modifyResponseHeaderActions?: outputs.CdnEndpointGlobalDeliveryRuleModifyResponseHeaderAction[];
    urlRedirectAction?: outputs.CdnEndpointGlobalDeliveryRuleUrlRedirectAction;
    urlRewriteAction?: outputs.CdnEndpointGlobalDeliveryRuleUrlRewriteAction;
}

export interface CdnEndpointGlobalDeliveryRuleCacheExpirationAction {
    behavior: string;
    duration?: string;
}

export interface CdnEndpointGlobalDeliveryRuleCacheKeyQueryStringAction {
    behavior: string;
    parameters?: string;
}

export interface CdnEndpointGlobalDeliveryRuleModifyRequestHeaderAction {
    action: string;
    name: string;
    value?: string;
}

export interface CdnEndpointGlobalDeliveryRuleModifyResponseHeaderAction {
    action: string;
    name: string;
    value?: string;
}

export interface CdnEndpointGlobalDeliveryRuleUrlRedirectAction {
    fragment?: string;
    hostname?: string;
    path?: string;
    protocol?: string;
    queryString?: string;
    redirectType: string;
}

export interface CdnEndpointGlobalDeliveryRuleUrlRewriteAction {
    destination: string;
    preserveUnmatchedPath?: boolean;
    sourcePattern: string;
}

export interface CdnEndpointOrigin {
    hostName: string;
    httpPort?: number;
    httpsPort?: number;
    name: string;
}

export interface CdnEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorCustomDomainAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorCustomDomainTls {
    cdnFrontdoorSecretId: string;
    certificateType?: string;
    minimumTlsVersion?: string;
}

export interface CdnFrontdoorEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorFirewallPolicyCustomRule {
    action: string;
    enabled?: boolean;
    matchConditions?: outputs.CdnFrontdoorFirewallPolicyCustomRuleMatchCondition[];
    name: string;
    priority?: number;
    rateLimitDurationInMinutes?: number;
    rateLimitThreshold?: number;
    type: string;
}

export interface CdnFrontdoorFirewallPolicyCustomRuleMatchCondition {
    matchValues: string[];
    matchVariable: string;
    negationCondition?: boolean;
    operator: string;
    selector?: string;
    transforms?: string[];
}

export interface CdnFrontdoorFirewallPolicyManagedRule {
    action: string;
    exclusions?: outputs.CdnFrontdoorFirewallPolicyManagedRuleExclusion[];
    overrides?: outputs.CdnFrontdoorFirewallPolicyManagedRuleOverride[];
    type: string;
    version: string;
}

export interface CdnFrontdoorFirewallPolicyManagedRuleExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface CdnFrontdoorFirewallPolicyManagedRuleOverride {
    exclusions?: outputs.CdnFrontdoorFirewallPolicyManagedRuleOverrideExclusion[];
    ruleGroupName: string;
    rules?: outputs.CdnFrontdoorFirewallPolicyManagedRuleOverrideRule[];
}

export interface CdnFrontdoorFirewallPolicyManagedRuleOverrideExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface CdnFrontdoorFirewallPolicyManagedRuleOverrideRule {
    action: string;
    enabled?: boolean;
    exclusions?: outputs.CdnFrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion[];
    ruleId: string;
}

export interface CdnFrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface CdnFrontdoorFirewallPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorOriginGroupHealthProbe {
    intervalInSeconds: number;
    path?: string;
    protocol: string;
    requestType?: string;
}

export interface CdnFrontdoorOriginGroupLoadBalancing {
    additionalLatencyInMilliseconds?: number;
    sampleSize?: number;
    successfulSamplesRequired?: number;
}

export interface CdnFrontdoorOriginGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorOriginPrivateLink {
    location: string;
    privateLinkTargetId: string;
    requestMessage?: string;
    targetType?: string;
}

export interface CdnFrontdoorOriginTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorRouteCache {
    compressionEnabled?: boolean;
    contentTypesToCompresses?: string[];
    queryStringCachingBehavior?: string;
    queryStrings?: string[];
}

export interface CdnFrontdoorRouteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorRuleActions {
    requestHeaderActions?: outputs.CdnFrontdoorRuleActionsRequestHeaderAction[];
    responseHeaderActions?: outputs.CdnFrontdoorRuleActionsResponseHeaderAction[];
    routeConfigurationOverrideAction?: outputs.CdnFrontdoorRuleActionsRouteConfigurationOverrideAction;
    urlRedirectAction?: outputs.CdnFrontdoorRuleActionsUrlRedirectAction;
    urlRewriteAction?: outputs.CdnFrontdoorRuleActionsUrlRewriteAction;
}

export interface CdnFrontdoorRuleActionsRequestHeaderAction {
    headerAction: string;
    headerName: string;
    value?: string;
}

export interface CdnFrontdoorRuleActionsResponseHeaderAction {
    headerAction: string;
    headerName: string;
    value?: string;
}

export interface CdnFrontdoorRuleActionsRouteConfigurationOverrideAction {
    cacheBehavior?: string;
    cacheDuration?: string;
    cdnFrontdoorOriginGroupId?: string;
    compressionEnabled?: boolean;
    forwardingProtocol?: string;
    queryStringCachingBehavior?: string;
    queryStringParameters?: string[];
}

export interface CdnFrontdoorRuleActionsUrlRedirectAction {
    destinationFragment?: string;
    destinationHostname: string;
    destinationPath?: string;
    queryString?: string;
    redirectProtocol?: string;
    redirectType: string;
}

export interface CdnFrontdoorRuleActionsUrlRewriteAction {
    destination: string;
    preserveUnmatchedPath?: boolean;
    sourcePattern: string;
}

export interface CdnFrontdoorRuleConditions {
    clientPortConditions?: outputs.CdnFrontdoorRuleConditionsClientPortCondition[];
    cookiesConditions?: outputs.CdnFrontdoorRuleConditionsCookiesCondition[];
    hostNameConditions?: outputs.CdnFrontdoorRuleConditionsHostNameCondition[];
    httpVersionConditions?: outputs.CdnFrontdoorRuleConditionsHttpVersionCondition[];
    isDeviceConditions?: outputs.CdnFrontdoorRuleConditionsIsDeviceCondition[];
    postArgsConditions?: outputs.CdnFrontdoorRuleConditionsPostArgsCondition[];
    queryStringConditions?: outputs.CdnFrontdoorRuleConditionsQueryStringCondition[];
    remoteAddressConditions?: outputs.CdnFrontdoorRuleConditionsRemoteAddressCondition[];
    requestBodyConditions?: outputs.CdnFrontdoorRuleConditionsRequestBodyCondition[];
    requestHeaderConditions?: outputs.CdnFrontdoorRuleConditionsRequestHeaderCondition[];
    requestMethodConditions?: outputs.CdnFrontdoorRuleConditionsRequestMethodCondition[];
    requestSchemeConditions?: outputs.CdnFrontdoorRuleConditionsRequestSchemeCondition[];
    requestUriConditions?: outputs.CdnFrontdoorRuleConditionsRequestUriCondition[];
    serverPortConditions?: outputs.CdnFrontdoorRuleConditionsServerPortCondition[];
    socketAddressConditions?: outputs.CdnFrontdoorRuleConditionsSocketAddressCondition[];
    sslProtocolConditions?: outputs.CdnFrontdoorRuleConditionsSslProtocolCondition[];
    urlFileExtensionConditions?: outputs.CdnFrontdoorRuleConditionsUrlFileExtensionCondition[];
    urlFilenameConditions?: outputs.CdnFrontdoorRuleConditionsUrlFilenameCondition[];
    urlPathConditions?: outputs.CdnFrontdoorRuleConditionsUrlPathCondition[];
}

export interface CdnFrontdoorRuleConditionsClientPortCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
}

export interface CdnFrontdoorRuleConditionsCookiesCondition {
    cookieName: string;
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsHostNameCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsHttpVersionCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsIsDeviceCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsPostArgsCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    postArgsName: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsQueryStringCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsRemoteAddressCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsRequestBodyCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsRequestHeaderCondition {
    headerName: string;
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsRequestMethodCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsRequestSchemeCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsRequestUriCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsServerPortCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator: string;
}

export interface CdnFrontdoorRuleConditionsSocketAddressCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsSslProtocolCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator?: string;
}

export interface CdnFrontdoorRuleConditionsUrlFileExtensionCondition {
    matchValues: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsUrlFilenameCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleConditionsUrlPathCondition {
    matchValues?: string[];
    negateCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface CdnFrontdoorRuleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CdnFrontdoorRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CdnFrontdoorSecretSecret {
    customerCertificates: outputs.CdnFrontdoorSecretSecretCustomerCertificate[];
}

export interface CdnFrontdoorSecretSecretCustomerCertificate {
    keyVaultCertificateId: string;
    subjectAlternativeNames: string[];
}

export interface CdnFrontdoorSecretTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CdnFrontdoorSecurityPolicySecurityPolicies {
    firewall: outputs.CdnFrontdoorSecurityPolicySecurityPoliciesFirewall;
}

export interface CdnFrontdoorSecurityPolicySecurityPoliciesFirewall {
    association: outputs.CdnFrontdoorSecurityPolicySecurityPoliciesFirewallAssociation;
    cdnFrontdoorFirewallPolicyId: string;
}

export interface CdnFrontdoorSecurityPolicySecurityPoliciesFirewallAssociation {
    domains: outputs.CdnFrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain[];
    patternsToMatches: string[];
}

export interface CdnFrontdoorSecurityPolicySecurityPoliciesFirewallAssociationDomain {
    active: boolean;
    cdnFrontdoorDomainId: string;
}

export interface CdnFrontdoorSecurityPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CdnProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ChaosStudioCapabilityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ChaosStudioExperimentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ChaosStudioExperimentSelector {
    chaosStudioTargetIds: string[];
    name: string;
}

export interface ChaosStudioExperimentStep {
    branches: outputs.ChaosStudioExperimentStepBranch[];
    name: string;
}

export interface ChaosStudioExperimentStepBranch {
    actions: outputs.ChaosStudioExperimentStepBranchAction[];
    name: string;
}

export interface ChaosStudioExperimentStepBranchAction {
    actionType: string;
    duration?: string;
    parameters?: {[key: string]: string};
    selectorName?: string;
    urn?: string;
}

export interface ChaosStudioExperimentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ChaosStudioTargetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CognitiveAccountCustomerManagedKey {
    identityClientId?: string;
    keyVaultKeyId: string;
}

export interface CognitiveAccountCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CognitiveAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface CognitiveAccountNetworkAcls {
    defaultAction: string;
    ipRules?: string[];
    virtualNetworkRules?: outputs.CognitiveAccountNetworkAclsVirtualNetworkRule[];
}

export interface CognitiveAccountNetworkAclsVirtualNetworkRule {
    ignoreMissingVnetServiceEndpoint?: boolean;
    subnetId: string;
}

export interface CognitiveAccountStorage {
    identityClientId?: string;
    storageAccountId: string;
}

export interface CognitiveAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CognitiveDeploymentModel {
    format: string;
    name: string;
    version?: string;
}

export interface CognitiveDeploymentSku {
    capacity?: number;
    family?: string;
    name: string;
    size?: string;
    tier?: string;
}

export interface CognitiveDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CommunicationServiceEmailDomainAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CommunicationServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ConfidentialLedgerAzureadBasedServicePrincipal {
    ledgerRoleName: string;
    principalId: string;
    tenantId: string;
}

export interface ConfidentialLedgerCertificateBasedSecurityPrincipal {
    ledgerRoleName: string;
    pemPublicKey: string;
}

export interface ConfidentialLedgerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ConsumptionBudgetManagementGroupFilter {
    dimensions?: outputs.ConsumptionBudgetManagementGroupFilterDimension[];
    tags?: outputs.ConsumptionBudgetManagementGroupFilterTag[];
}

export interface ConsumptionBudgetManagementGroupFilterDimension {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetManagementGroupFilterTag {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetManagementGroupNotification {
    contactEmails: string[];
    enabled?: boolean;
    operator: string;
    threshold: number;
    thresholdType?: string;
}

export interface ConsumptionBudgetManagementGroupTimePeriod {
    endDate: string;
    startDate: string;
}

export interface ConsumptionBudgetManagementGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ConsumptionBudgetResourceGroupFilter {
    dimensions?: outputs.ConsumptionBudgetResourceGroupFilterDimension[];
    tags?: outputs.ConsumptionBudgetResourceGroupFilterTag[];
}

export interface ConsumptionBudgetResourceGroupFilterDimension {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetResourceGroupFilterTag {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetResourceGroupNotification {
    contactEmails?: string[];
    contactGroups?: string[];
    contactRoles?: string[];
    enabled?: boolean;
    operator: string;
    threshold: number;
    thresholdType?: string;
}

export interface ConsumptionBudgetResourceGroupTimePeriod {
    endDate: string;
    startDate: string;
}

export interface ConsumptionBudgetResourceGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ConsumptionBudgetSubscriptionFilter {
    dimensions?: outputs.ConsumptionBudgetSubscriptionFilterDimension[];
    tags?: outputs.ConsumptionBudgetSubscriptionFilterTag[];
}

export interface ConsumptionBudgetSubscriptionFilterDimension {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetSubscriptionFilterTag {
    name: string;
    operator?: string;
    values: string[];
}

export interface ConsumptionBudgetSubscriptionNotification {
    contactEmails?: string[];
    contactGroups?: string[];
    contactRoles?: string[];
    enabled?: boolean;
    operator: string;
    threshold: number;
    thresholdType?: string;
}

export interface ConsumptionBudgetSubscriptionTimePeriod {
    endDate: string;
    startDate: string;
}

export interface ConsumptionBudgetSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ContainerAppDapr {
    /**
     * The Dapr Application Identifier.
     */
    appId: string;
    /**
     * The port which the application is listening on. This is the same as the `ingress` port.
     */
    appPort?: number;
    /**
     * The protocol for the app. Possible values include `http` and `grpc`. Defaults to `http`.
     */
    appProtocol?: string;
}

export interface ContainerAppEnvironmentCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppEnvironmentCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppEnvironmentDaprComponentMetadata {
    /**
     * The name of the Metadata configuration item.
     */
    name: string;
    /**
     * The name of a secret specified in the `secrets` block that contains the value for this metadata configuration item.
     */
    secretName?: string;
    /**
     * The value for this metadata configuration item.
     */
    value?: string;
}

export interface ContainerAppEnvironmentDaprComponentSecret {
    /**
     * The identity to use for accessing key vault reference.
     */
    identity?: string;
    /**
     * The Key Vault Secret ID. Could be either one of `id` or `versionless_id`.
     */
    keyVaultSecretId?: string;
    /**
     * The secret name.
     */
    name: string;
    /**
     * The value for this secret.
     */
    value?: string;
}

export interface ContainerAppEnvironmentDaprComponentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppEnvironmentStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppEnvironmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppEnvironmentWorkloadProfile {
    maximumCount?: number;
    minimumCount?: number;
    name: string;
    workloadProfileType: string;
}

export interface ContainerAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ContainerAppIngress {
    /**
     * Should this ingress allow insecure connections?
     */
    allowInsecureConnections?: boolean;
    customDomains: outputs.ContainerAppIngressCustomDomain[];
    /**
     * The exposed port on the container for the Ingress traffic.
     */
    exposedPort?: number;
    /**
     * Is this an external Ingress.
     */
    externalEnabled?: boolean;
    /**
     * The FQDN of the ingress.
     */
    fqdn: string;
    ipSecurityRestrictions?: outputs.ContainerAppIngressIpSecurityRestriction[];
    /**
     * The target port on the container for the Ingress traffic.
     */
    targetPort: number;
    trafficWeights: outputs.ContainerAppIngressTrafficWeight[];
    /**
     * The transport method for the Ingress. Possible values include `auto`, `http`, and `http2`, `tcp`. Defaults to `auto`
     */
    transport?: string;
}

export interface ContainerAppIngressCustomDomain {
    certificateBindingType: string;
    certificateId: string;
    name: string;
}

export interface ContainerAppIngressIpSecurityRestriction {
    /**
     * The action. Allow or Deny.
     */
    action: string;
    /**
     * Describe the IP restriction rule that is being sent to the container-app.
     */
    description?: string;
    /**
     * The incoming IP address or range of IP addresses (in CIDR notation).
     */
    ipAddressRange: string;
    /**
     * Name for the IP restriction rule.
     */
    name: string;
}

export interface ContainerAppIngressTrafficWeight {
    /**
     * The label to apply to the revision as a name prefix for routing traffic.
     */
    label?: string;
    /**
     * This traffic Weight relates to the latest stable Container Revision.
     */
    latestRevision?: boolean;
    /**
     * The percentage of traffic to send to this revision.
     */
    percentage: number;
    /**
     * The suffix string to append to the revision. This must be unique for the Container App's lifetime. A default hash created by the service will be used if this value is omitted.
     */
    revisionSuffix?: string;
}

export interface ContainerAppJobEventTriggerConfig {
    parallelism?: number;
    replicaCompletionCount?: number;
    scales?: outputs.ContainerAppJobEventTriggerConfigScale[];
}

export interface ContainerAppJobEventTriggerConfigScale {
    maxExecutions?: number;
    minExecutions?: number;
    pollingIntervalInSeconds?: number;
    rules?: outputs.ContainerAppJobEventTriggerConfigScaleRule[];
}

export interface ContainerAppJobEventTriggerConfigScaleRule {
    authentications?: outputs.ContainerAppJobEventTriggerConfigScaleRuleAuthentication[];
    customRuleType: string;
    metadata: {[key: string]: string};
    name: string;
}

export interface ContainerAppJobEventTriggerConfigScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface ContainerAppJobIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ContainerAppJobManualTriggerConfig {
    parallelism?: number;
    replicaCompletionCount?: number;
}

export interface ContainerAppJobRegistry {
    /**
     * ID of the System or User Managed Identity used to pull images from the Container Registry
     */
    identity?: string;
    /**
     * The name of the Secret Reference containing the password value for this user on the Container Registry.
     */
    passwordSecretName?: string;
    /**
     * The hostname for the Container Registry.
     */
    server: string;
    /**
     * The username to use for this Container Registry.
     */
    username?: string;
}

export interface ContainerAppJobScheduleTriggerConfig {
    cronExpression: string;
    parallelism?: number;
    replicaCompletionCount?: number;
}

export interface ContainerAppJobSecret {
    /**
     * The identity to use for accessing key vault reference.
     */
    identity?: string;
    /**
     * The Key Vault Secret ID. Could be either one of `id` or `versionless_id`.
     */
    keyVaultSecretId?: string;
    /**
     * The secret name.
     */
    name: string;
    /**
     * The value for this secret.
     */
    value?: string;
}

export interface ContainerAppJobTemplate {
    containers: outputs.ContainerAppJobTemplateContainer[];
    initContainers?: outputs.ContainerAppJobTemplateInitContainer[];
    volumes?: outputs.ContainerAppJobTemplateVolume[];
}

export interface ContainerAppJobTemplateContainer {
    /**
     * A list of args to pass to the container.
     */
    args?: string[];
    /**
     * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
     */
    commands?: string[];
    /**
     * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.0` / `2.0` or `0.5` / `1.0`. When there's a workload profile specified, there's no such constraint.
     */
    cpu: number;
    envs?: outputs.ContainerAppJobTemplateContainerEnv[];
    /**
     * The amount of ephemeral storage available to the Container App.
     */
    ephemeralStorage: string;
    /**
     * The image to use to create the container.
     */
    image: string;
    livenessProbes?: outputs.ContainerAppJobTemplateContainerLivenessProbe[];
    /**
     * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1.0Gi`, `1.5Gi`, `2.0Gi`, `2.5Gi`, `3.0Gi`, `3.5Gi`, and `4.0Gi`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.25` / `2.5Gi` or `0.75` / `1.5Gi`. When there's a workload profile specified, there's no such constraint.
     */
    memory: string;
    /**
     * The name of the container.
     */
    name: string;
    readinessProbes?: outputs.ContainerAppJobTemplateContainerReadinessProbe[];
    startupProbes?: outputs.ContainerAppJobTemplateContainerStartupProbe[];
    volumeMounts?: outputs.ContainerAppJobTemplateContainerVolumeMount[];
}

export interface ContainerAppJobTemplateContainerEnv {
    /**
     * The name of the environment variable for the container.
     */
    name: string;
    /**
     * The name of the secret that contains the value for this environment variable.
     */
    secretName?: string;
    /**
     * The value for this environment variable. **NOTE:** This value is ignored if `secret_name` is used
     */
    value?: string;
}

export interface ContainerAppJobTemplateContainerLivenessProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppJobTemplateContainerLivenessProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * The time in seconds to wait after the container has started before the probe is started.
     */
    initialDelay?: number;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
     */
    terminationGracePeriodSeconds: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppJobTemplateContainerLivenessProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppJobTemplateContainerReadinessProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppJobTemplateContainerReadinessProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The number of consecutive successful responses required to consider this probe as successful. Possible values are between `1` and `10`. Defaults to `3`.
     */
    successCountThreshold?: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppJobTemplateContainerReadinessProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppJobTemplateContainerStartupProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppJobTemplateContainerStartupProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
     */
    terminationGracePeriodSeconds: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppJobTemplateContainerStartupProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppJobTemplateContainerVolumeMount {
    /**
     * The name of the Volume to be mounted in the container.
     */
    name: string;
    /**
     * The path in the container at which to mount this volume.
     */
    path: string;
}

export interface ContainerAppJobTemplateInitContainer {
    /**
     * A list of args to pass to the container.
     */
    args?: string[];
    /**
     * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
     */
    commands?: string[];
    /**
     * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.0` / `2.0` or `0.5` / `1.0`. When there's a workload profile specified, there's no such constraint.
     */
    cpu?: number;
    envs?: outputs.ContainerAppJobTemplateInitContainerEnv[];
    /**
     * The amount of ephemeral storage available to the Container App.
     */
    ephemeralStorage: string;
    /**
     * The image to use to create the container.
     */
    image: string;
    /**
     * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1.0Gi`, `1.5Gi`, `2.0Gi`, `2.5Gi`, `3.0Gi`, `3.5Gi`, and `4.0Gi`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.25` / `2.5Gi` or `0.75` / `1.5Gi`. When there's a workload profile specified, there's no such constraint.
     */
    memory?: string;
    /**
     * The name of the container.
     */
    name: string;
    volumeMounts?: outputs.ContainerAppJobTemplateInitContainerVolumeMount[];
}

export interface ContainerAppJobTemplateInitContainerEnv {
    /**
     * The name of the environment variable for the container.
     */
    name: string;
    /**
     * The name of the secret that contains the value for this environment variable.
     */
    secretName?: string;
    /**
     * The value for this environment variable. **NOTE:** This value is ignored if `secret_name` is used
     */
    value?: string;
}

export interface ContainerAppJobTemplateInitContainerVolumeMount {
    /**
     * The name of the Volume to be mounted in the container.
     */
    name: string;
    /**
     * The path in the container at which to mount this volume.
     */
    path: string;
}

export interface ContainerAppJobTemplateVolume {
    /**
     * The name of the volume.
     */
    name: string;
    /**
     * The name of the `AzureFile` storage. Required when `storage_type` is `AzureFile`
     */
    storageName?: string;
    /**
     * The type of storage volume. Possible values include `AzureFile` and `EmptyDir`. Defaults to `EmptyDir`.
     */
    storageType?: string;
}

export interface ContainerAppJobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerAppRegistry {
    /**
     * ID of the System or User Managed Identity used to pull images from the Container Registry
     */
    identity?: string;
    /**
     * The name of the Secret Reference containing the password value for this user on the Container Registry.
     */
    passwordSecretName?: string;
    /**
     * The hostname for the Container Registry.
     */
    server: string;
    /**
     * The username to use for this Container Registry.
     */
    username?: string;
}

export interface ContainerAppSecret {
    /**
     * The identity to use for accessing key vault reference.
     */
    identity?: string;
    /**
     * The Key Vault Secret ID. Could be either one of `id` or `versionless_id`.
     */
    keyVaultSecretId?: string;
    /**
     * The secret name.
     */
    name: string;
    /**
     * The value for this secret.
     */
    value?: string;
}

export interface ContainerAppTemplate {
    azureQueueScaleRules?: outputs.ContainerAppTemplateAzureQueueScaleRule[];
    containers: outputs.ContainerAppTemplateContainer[];
    customScaleRules?: outputs.ContainerAppTemplateCustomScaleRule[];
    httpScaleRules?: outputs.ContainerAppTemplateHttpScaleRule[];
    initContainers?: outputs.ContainerAppTemplateInitContainer[];
    /**
     * The maximum number of replicas for this container.
     */
    maxReplicas?: number;
    /**
     * The minimum number of replicas for this container.
     */
    minReplicas?: number;
    /**
     * The suffix for the revision. This value must be unique for the lifetime of the Resource. If omitted the service will use a hash function to create one.
     */
    revisionSuffix: string;
    tcpScaleRules?: outputs.ContainerAppTemplateTcpScaleRule[];
    volumes?: outputs.ContainerAppTemplateVolume[];
}

export interface ContainerAppTemplateAzureQueueScaleRule {
    authentications: outputs.ContainerAppTemplateAzureQueueScaleRuleAuthentication[];
    name: string;
    queueLength: number;
    queueName: string;
}

export interface ContainerAppTemplateAzureQueueScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface ContainerAppTemplateContainer {
    /**
     * A list of args to pass to the container.
     */
    args?: string[];
    /**
     * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
     */
    commands?: string[];
    /**
     * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.0` / `2.0` or `0.5` / `1.0`. When there's a workload profile specified, there's no such constraint.
     */
    cpu: number;
    envs?: outputs.ContainerAppTemplateContainerEnv[];
    /**
     * The amount of ephemeral storage available to the Container App.
     */
    ephemeralStorage: string;
    /**
     * The image to use to create the container.
     */
    image: string;
    livenessProbes?: outputs.ContainerAppTemplateContainerLivenessProbe[];
    /**
     * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1.0Gi`, `1.5Gi`, `2.0Gi`, `2.5Gi`, `3.0Gi`, `3.5Gi`, and `4.0Gi`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.25` / `2.5Gi` or `0.75` / `1.5Gi`. When there's a workload profile specified, there's no such constraint.
     */
    memory: string;
    /**
     * The name of the container.
     */
    name: string;
    readinessProbes?: outputs.ContainerAppTemplateContainerReadinessProbe[];
    startupProbes?: outputs.ContainerAppTemplateContainerStartupProbe[];
    volumeMounts?: outputs.ContainerAppTemplateContainerVolumeMount[];
}

export interface ContainerAppTemplateContainerEnv {
    /**
     * The name of the environment variable for the container.
     */
    name: string;
    /**
     * The name of the secret that contains the value for this environment variable.
     */
    secretName?: string;
    /**
     * The value for this environment variable. **NOTE:** This value is ignored if `secret_name` is used
     */
    value?: string;
}

export interface ContainerAppTemplateContainerLivenessProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppTemplateContainerLivenessProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * The time in seconds to wait after the container has started before the probe is started.
     */
    initialDelay?: number;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
     */
    terminationGracePeriodSeconds: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppTemplateContainerLivenessProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppTemplateContainerReadinessProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppTemplateContainerReadinessProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The number of consecutive successful responses required to consider this probe as successful. Possible values are between `1` and `10`. Defaults to `3`.
     */
    successCountThreshold?: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppTemplateContainerReadinessProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppTemplateContainerStartupProbe {
    /**
     * The number of consecutive failures required to consider this probe as failed. Possible values are between `1` and `10`. Defaults to `3`.
     */
    failureCountThreshold?: number;
    headers?: outputs.ContainerAppTemplateContainerStartupProbeHeader[];
    /**
     * The probe hostname. Defaults to the pod IP address. Setting a value for `Host` in `headers` can be used to override this for `http` and `https` type probes.
     */
    host?: string;
    /**
     * How often, in seconds, the probe should run. Possible values are between `1` and `240`. Defaults to `10`
     */
    intervalSeconds?: number;
    /**
     * The URI to use with the `host` for http type probes. Not valid for `TCP` type probes. Defaults to `/`.
     */
    path: string;
    /**
     * The port number on which to connect. Possible values are between `1` and `65535`.
     */
    port: number;
    /**
     * The time in seconds after the container is sent the termination signal before the process if forcibly killed.
     */
    terminationGracePeriodSeconds: number;
    /**
     * Time in seconds after which the probe times out. Possible values are between `1` an `240`. Defaults to `1`.
     */
    timeout?: number;
    /**
     * Type of probe. Possible values are `TCP`, `HTTP`, and `HTTPS`.
     */
    transport: string;
}

export interface ContainerAppTemplateContainerStartupProbeHeader {
    /**
     * The HTTP Header Name.
     */
    name: string;
    /**
     * The HTTP Header value.
     */
    value: string;
}

export interface ContainerAppTemplateContainerVolumeMount {
    /**
     * The name of the Volume to be mounted in the container.
     */
    name: string;
    /**
     * The path in the container at which to mount this volume.
     */
    path: string;
}

export interface ContainerAppTemplateCustomScaleRule {
    authentications?: outputs.ContainerAppTemplateCustomScaleRuleAuthentication[];
    customRuleType: string;
    metadata: {[key: string]: string};
    name: string;
}

export interface ContainerAppTemplateCustomScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface ContainerAppTemplateHttpScaleRule {
    authentications?: outputs.ContainerAppTemplateHttpScaleRuleAuthentication[];
    concurrentRequests: string;
    name: string;
}

export interface ContainerAppTemplateHttpScaleRuleAuthentication {
    secretName: string;
    triggerParameter?: string;
}

export interface ContainerAppTemplateInitContainer {
    /**
     * A list of args to pass to the container.
     */
    args?: string[];
    /**
     * A command to pass to the container to override the default. This is provided as a list of command line elements without spaces.
     */
    commands?: string[];
    /**
     * The amount of vCPU to allocate to the container. Possible values include `0.25`, `0.5`, `0.75`, `1.0`, `1.25`, `1.5`, `1.75`, and `2.0`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.0` / `2.0` or `0.5` / `1.0`. When there's a workload profile specified, there's no such constraint.
     */
    cpu?: number;
    envs?: outputs.ContainerAppTemplateInitContainerEnv[];
    /**
     * The amount of ephemeral storage available to the Container App.
     */
    ephemeralStorage: string;
    /**
     * The image to use to create the container.
     */
    image: string;
    /**
     * The amount of memory to allocate to the container. Possible values include `0.5Gi`, `1.0Gi`, `1.5Gi`, `2.0Gi`, `2.5Gi`, `3.0Gi`, `3.5Gi`, and `4.0Gi`. **NOTE:** `cpu` and `memory` must be specified in `0.25'/'0.5Gi` combination increments. e.g. `1.25` / `2.5Gi` or `0.75` / `1.5Gi`. When there's a workload profile specified, there's no such constraint.
     */
    memory?: string;
    /**
     * The name of the container.
     */
    name: string;
    volumeMounts?: outputs.ContainerAppTemplateInitContainerVolumeMount[];
}

export interface ContainerAppTemplateInitContainerEnv {
    /**
     * The name of the environment variable for the container.
     */
    name: string;
    /**
     * The name of the secret that contains the value for this environment variable.
     */
    secretName?: string;
    /**
     * The value for this environment variable. **NOTE:** This value is ignored if `secret_name` is used
     */
    value?: string;
}

export interface ContainerAppTemplateInitContainerVolumeMount {
    /**
     * The name of the Volume to be mounted in the container.
     */
    name: string;
    /**
     * The path in the container at which to mount this volume.
     */
    path: string;
}

export interface ContainerAppTemplateTcpScaleRule {
    authentications?: outputs.ContainerAppTemplateTcpScaleRuleAuthentication[];
    concurrentRequests: string;
    name: string;
}

export interface ContainerAppTemplateTcpScaleRuleAuthentication {
    secretName: string;
    triggerParameter?: string;
}

export interface ContainerAppTemplateVolume {
    /**
     * The name of the volume.
     */
    name: string;
    /**
     * The name of the `AzureFile` storage. Required when `storage_type` is `AzureFile`
     */
    storageName?: string;
    /**
     * The type of storage volume. Possible values include `AzureFile` and `EmptyDir`. Defaults to `EmptyDir`.
     */
    storageType?: string;
}

export interface ContainerAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerConnectedRegistryNotification {
    action: string;
    digest?: string;
    name: string;
    tag?: string;
}

export interface ContainerConnectedRegistryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerGroupContainer {
    commands: string[];
    cpu: number;
    cpuLimit?: number;
    environmentVariables?: {[key: string]: string};
    image: string;
    livenessProbe?: outputs.ContainerGroupContainerLivenessProbe;
    memory: number;
    memoryLimit?: number;
    name: string;
    ports?: outputs.ContainerGroupContainerPort[];
    readinessProbe?: outputs.ContainerGroupContainerReadinessProbe;
    secureEnvironmentVariables?: {[key: string]: string};
    securities?: outputs.ContainerGroupContainerSecurity[];
    volumes?: outputs.ContainerGroupContainerVolume[];
}

export interface ContainerGroupContainerLivenessProbe {
    execs?: string[];
    failureThreshold?: number;
    httpGets?: outputs.ContainerGroupContainerLivenessProbeHttpGet[];
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
}

export interface ContainerGroupContainerLivenessProbeHttpGet {
    httpHeaders?: {[key: string]: string};
    path?: string;
    port?: number;
    scheme?: string;
}

export interface ContainerGroupContainerPort {
    port?: number;
    protocol?: string;
}

export interface ContainerGroupContainerReadinessProbe {
    execs?: string[];
    failureThreshold?: number;
    httpGets?: outputs.ContainerGroupContainerReadinessProbeHttpGet[];
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
}

export interface ContainerGroupContainerReadinessProbeHttpGet {
    httpHeaders?: {[key: string]: string};
    path?: string;
    port?: number;
    scheme?: string;
}

export interface ContainerGroupContainerSecurity {
    privilegeEnabled: boolean;
}

export interface ContainerGroupContainerVolume {
    emptyDir?: boolean;
    gitRepo?: outputs.ContainerGroupContainerVolumeGitRepo;
    mountPath: string;
    name: string;
    readOnly?: boolean;
    secret?: {[key: string]: string};
    shareName?: string;
    storageAccountKey?: string;
    storageAccountName?: string;
}

export interface ContainerGroupContainerVolumeGitRepo {
    directory?: string;
    revision?: string;
    url: string;
}

export interface ContainerGroupDiagnostics {
    logAnalytics: outputs.ContainerGroupDiagnosticsLogAnalytics;
}

export interface ContainerGroupDiagnosticsLogAnalytics {
    logType?: string;
    metadata?: {[key: string]: string};
    workspaceId: string;
    workspaceKey: string;
}

export interface ContainerGroupDnsConfig {
    nameservers: string[];
    options?: string[];
    searchDomains?: string[];
}

export interface ContainerGroupExposedPort {
    port: number;
    protocol: string;
}

export interface ContainerGroupIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ContainerGroupImageRegistryCredential {
    password?: string;
    server: string;
    /**
     * The User Assigned Identity to use for Container Registry access.
     */
    userAssignedIdentityId?: string;
    username?: string;
}

export interface ContainerGroupInitContainer {
    commands: string[];
    environmentVariables?: {[key: string]: string};
    image: string;
    name: string;
    secureEnvironmentVariables?: {[key: string]: string};
    securities?: outputs.ContainerGroupInitContainerSecurity[];
    volumes?: outputs.ContainerGroupInitContainerVolume[];
}

export interface ContainerGroupInitContainerSecurity {
    privilegeEnabled: boolean;
}

export interface ContainerGroupInitContainerVolume {
    emptyDir?: boolean;
    gitRepo?: outputs.ContainerGroupInitContainerVolumeGitRepo;
    mountPath: string;
    name: string;
    readOnly?: boolean;
    secret?: {[key: string]: string};
    shareName?: string;
    storageAccountKey?: string;
    storageAccountName?: string;
}

export interface ContainerGroupInitContainerVolumeGitRepo {
    directory?: string;
    revision?: string;
    url: string;
}

export interface ContainerGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryAgentPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryCacheRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryEncryption {
    identityClientId: string;
    keyVaultKeyId: string;
}

export interface ContainerRegistryGeoreplication {
    location: string;
    regionalEndpointEnabled?: boolean;
    tags?: {[key: string]: string};
    zoneRedundancyEnabled?: boolean;
}

export interface ContainerRegistryIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ContainerRegistryNetworkRuleSet {
    defaultAction: string;
    ipRules: outputs.ContainerRegistryNetworkRuleSetIpRule[];
}

export interface ContainerRegistryNetworkRuleSetIpRule {
    action: string;
    ipRange: string;
}

export interface ContainerRegistryScopeMapTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryTaskAgentSetting {
    cpu: number;
}

export interface ContainerRegistryTaskBaseImageTrigger {
    enabled?: boolean;
    name: string;
    type: string;
    updateTriggerEndpoint?: string;
    updateTriggerPayloadType?: string;
}

export interface ContainerRegistryTaskDockerStep {
    arguments?: {[key: string]: string};
    cacheEnabled?: boolean;
    contextAccessToken: string;
    contextPath: string;
    dockerfilePath: string;
    imageNames?: string[];
    pushEnabled?: boolean;
    secretArguments?: {[key: string]: string};
    target?: string;
}

export interface ContainerRegistryTaskEncodedStep {
    contextAccessToken?: string;
    contextPath?: string;
    secretValues?: {[key: string]: string};
    taskContent: string;
    valueContent?: string;
    values?: {[key: string]: string};
}

export interface ContainerRegistryTaskFileStep {
    contextAccessToken?: string;
    contextPath?: string;
    secretValues?: {[key: string]: string};
    taskFilePath: string;
    valueFilePath?: string;
    values?: {[key: string]: string};
}

export interface ContainerRegistryTaskIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ContainerRegistryTaskPlatform {
    architecture?: string;
    os: string;
    variant?: string;
}

export interface ContainerRegistryTaskRegistryCredential {
    customs?: outputs.ContainerRegistryTaskRegistryCredentialCustom[];
    source?: outputs.ContainerRegistryTaskRegistryCredentialSource;
}

export interface ContainerRegistryTaskRegistryCredentialCustom {
    identity?: string;
    loginServer: string;
    password?: string;
    username?: string;
}

export interface ContainerRegistryTaskRegistryCredentialSource {
    loginMode: string;
}

export interface ContainerRegistryTaskScheduleRunNowTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ContainerRegistryTaskSourceTrigger {
    authentication?: outputs.ContainerRegistryTaskSourceTriggerAuthentication;
    branch?: string;
    enabled?: boolean;
    events: string[];
    name: string;
    repositoryUrl: string;
    sourceType: string;
}

export interface ContainerRegistryTaskSourceTriggerAuthentication {
    expireInSeconds?: number;
    refreshToken?: string;
    scope?: string;
    token: string;
    tokenType: string;
}

export interface ContainerRegistryTaskTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryTaskTimerTrigger {
    enabled?: boolean;
    name: string;
    schedule: string;
}

export interface ContainerRegistryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryTokenPasswordPassword1 {
    expiry?: string;
    value: string;
}

export interface ContainerRegistryTokenPasswordPassword2 {
    expiry?: string;
    value: string;
}

export interface ContainerRegistryTokenPasswordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryTokenTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerRegistryWebhookTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbAccountAnalyticalStorage {
    schemaType: string;
}

export interface CosmosdbAccountBackup {
    intervalInMinutes: number;
    retentionInHours: number;
    storageRedundancy: string;
    tier: string;
    type: string;
}

export interface CosmosdbAccountCapability {
    name: string;
}

export interface CosmosdbAccountCapacity {
    totalThroughputLimit: number;
}

export interface CosmosdbAccountConsistencyPolicy {
    consistencyLevel: string;
    maxIntervalInSeconds?: number;
    maxStalenessPrefix?: number;
}

export interface CosmosdbAccountCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds?: number;
}

export interface CosmosdbAccountGeoLocation {
    failoverPriority: number;
    id: string;
    location: string;
    zoneRedundant?: boolean;
}

export interface CosmosdbAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface CosmosdbAccountRestore {
    databases?: outputs.CosmosdbAccountRestoreDatabase[];
    gremlinDatabases?: outputs.CosmosdbAccountRestoreGremlinDatabase[];
    restoreTimestampInUtc: string;
    sourceCosmosdbAccountId: string;
    tablesToRestores?: string[];
}

export interface CosmosdbAccountRestoreDatabase {
    collectionNames?: string[];
    name: string;
}

export interface CosmosdbAccountRestoreGremlinDatabase {
    graphNames?: string[];
    name: string;
}

export interface CosmosdbAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbAccountVirtualNetworkRule {
    id: string;
    ignoreMissingVnetServiceEndpoint?: boolean;
}

export interface CosmosdbCassandraClusterIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface CosmosdbCassandraClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbCassandraDatacenterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbCassandraKeyspaceAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbCassandraKeyspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbCassandraTableAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbCassandraTableSchema {
    clusterKeys?: outputs.CosmosdbCassandraTableSchemaClusterKey[];
    columns: outputs.CosmosdbCassandraTableSchemaColumn[];
    partitionKeys: outputs.CosmosdbCassandraTableSchemaPartitionKey[];
}

export interface CosmosdbCassandraTableSchemaClusterKey {
    name: string;
    orderBy: string;
}

export interface CosmosdbCassandraTableSchemaColumn {
    name: string;
    type: string;
}

export interface CosmosdbCassandraTableSchemaPartitionKey {
    name: string;
}

export interface CosmosdbCassandraTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbGremlinDatabaseAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbGremlinDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbGremlinGraphAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbGremlinGraphConflictResolutionPolicy {
    conflictResolutionPath?: string;
    conflictResolutionProcedure?: string;
    mode: string;
}

export interface CosmosdbGremlinGraphIndexPolicy {
    automatic?: boolean;
    compositeIndices?: outputs.CosmosdbGremlinGraphIndexPolicyCompositeIndex[];
    excludedPaths: string[];
    includedPaths: string[];
    indexingMode: string;
    spatialIndices?: outputs.CosmosdbGremlinGraphIndexPolicySpatialIndex[];
}

export interface CosmosdbGremlinGraphIndexPolicyCompositeIndex {
    indices: outputs.CosmosdbGremlinGraphIndexPolicyCompositeIndexIndex[];
}

export interface CosmosdbGremlinGraphIndexPolicyCompositeIndexIndex {
    order: string;
    path: string;
}

export interface CosmosdbGremlinGraphIndexPolicySpatialIndex {
    path: string;
    types: string[];
}

export interface CosmosdbGremlinGraphTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbGremlinGraphUniqueKey {
    paths: string[];
}

export interface CosmosdbMongoCollectionAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbMongoCollectionIndex {
    keys: string[];
    unique?: boolean;
}

export interface CosmosdbMongoCollectionSystemIndex {
    keys: string[];
    unique: boolean;
}

export interface CosmosdbMongoCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbMongoDatabaseAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbMongoDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbMongoRoleDefinitionPrivilege {
    actions: string[];
    resource: outputs.CosmosdbMongoRoleDefinitionPrivilegeResource;
}

export interface CosmosdbMongoRoleDefinitionPrivilegeResource {
    collectionName?: string;
    dbName?: string;
}

export interface CosmosdbMongoRoleDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbMongoUserDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbPostgresqlClusterMaintenanceWindow {
    dayOfWeek?: number;
    startHour?: number;
    startMinute?: number;
}

export interface CosmosdbPostgresqlClusterServer {
    fqdn: string;
    name: string;
}

export interface CosmosdbPostgresqlClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbPostgresqlCoordinatorConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbPostgresqlFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbPostgresqlNodeConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbPostgresqlRoleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface CosmosdbSqlContainerAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbSqlContainerConflictResolutionPolicy {
    conflictResolutionPath?: string;
    conflictResolutionProcedure?: string;
    mode: string;
}

export interface CosmosdbSqlContainerIndexingPolicy {
    compositeIndices?: outputs.CosmosdbSqlContainerIndexingPolicyCompositeIndex[];
    excludedPaths?: outputs.CosmosdbSqlContainerIndexingPolicyExcludedPath[];
    includedPaths?: outputs.CosmosdbSqlContainerIndexingPolicyIncludedPath[];
    indexingMode?: string;
    spatialIndices?: outputs.CosmosdbSqlContainerIndexingPolicySpatialIndex[];
}

export interface CosmosdbSqlContainerIndexingPolicyCompositeIndex {
    indices: outputs.CosmosdbSqlContainerIndexingPolicyCompositeIndexIndex[];
}

export interface CosmosdbSqlContainerIndexingPolicyCompositeIndexIndex {
    order: string;
    path: string;
}

export interface CosmosdbSqlContainerIndexingPolicyExcludedPath {
    path: string;
}

export interface CosmosdbSqlContainerIndexingPolicyIncludedPath {
    path: string;
}

export interface CosmosdbSqlContainerIndexingPolicySpatialIndex {
    path: string;
    types: string[];
}

export interface CosmosdbSqlContainerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlContainerUniqueKey {
    paths: string[];
}

export interface CosmosdbSqlDatabaseAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbSqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlDedicatedGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlFunctionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlRoleDefinitionPermission {
    dataActions: string[];
}

export interface CosmosdbSqlRoleDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlStoredProcedureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbSqlTriggerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CosmosdbTableAutoscaleSettings {
    maxThroughput: number;
}

export interface CosmosdbTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CostAnomalyAlertTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CostManagementScheduledActionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CustomIpPrefixTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CustomProviderAction {
    endpoint: string;
    name: string;
}

export interface CustomProviderResourceType {
    endpoint: string;
    name: string;
    routingType?: string;
}

export interface CustomProviderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CustomProviderValidation {
    specification: string;
}

export interface DashboardGrafanaAzureMonitorWorkspaceIntegration {
    resourceId: string;
}

export interface DashboardGrafanaIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DashboardGrafanaSmtp {
    enabled?: boolean;
    fromAddress: string;
    fromName?: string;
    host: string;
    password: string;
    startTlsPolicy: string;
    user: string;
    verificationSkipEnabled?: boolean;
}

export interface DashboardGrafanaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryCredentialServicePrincipalServicePrincipalKey {
    linkedServiceName: string;
    secretName: string;
    secretVersion?: string;
}

export interface DataFactoryCredentialServicePrincipalTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryCredentialUserManagedIdentityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryCustomDatasetLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryCustomDatasetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDataFlowSink {
    dataset?: outputs.DataFactoryDataFlowSinkDataset;
    description?: string;
    flowlet?: outputs.DataFactoryDataFlowSinkFlowlet;
    linkedService?: outputs.DataFactoryDataFlowSinkLinkedService;
    name: string;
    rejectedLinkedService?: outputs.DataFactoryDataFlowSinkRejectedLinkedService;
    schemaLinkedService?: outputs.DataFactoryDataFlowSinkSchemaLinkedService;
}

export interface DataFactoryDataFlowSinkDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSinkFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSinkLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSinkRejectedLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSinkSchemaLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSource {
    dataset?: outputs.DataFactoryDataFlowSourceDataset;
    description?: string;
    flowlet?: outputs.DataFactoryDataFlowSourceFlowlet;
    linkedService?: outputs.DataFactoryDataFlowSourceLinkedService;
    name: string;
    rejectedLinkedService?: outputs.DataFactoryDataFlowSourceRejectedLinkedService;
    schemaLinkedService?: outputs.DataFactoryDataFlowSourceSchemaLinkedService;
}

export interface DataFactoryDataFlowSourceDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSourceFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSourceLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSourceRejectedLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowSourceSchemaLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDataFlowTransformation {
    dataset?: outputs.DataFactoryDataFlowTransformationDataset;
    description?: string;
    flowlet?: outputs.DataFactoryDataFlowTransformationFlowlet;
    linkedService?: outputs.DataFactoryDataFlowTransformationLinkedService;
    name: string;
}

export interface DataFactoryDataFlowTransformationDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowTransformationFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDataFlowTransformationLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryDatasetAzureBlobSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetAzureBlobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetAzureSqlTableSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetAzureSqlTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetBinaryAzureBlobStorageLocation {
    container: string;
    dynamicContainerEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename?: string;
    path?: string;
}

export interface DataFactoryDatasetBinaryCompression {
    level?: string;
    type: string;
}

export interface DataFactoryDatasetBinaryHttpServerLocation {
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path: string;
    relativeUrl: string;
}

export interface DataFactoryDatasetBinarySftpServerLocation {
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path: string;
}

export interface DataFactoryDatasetBinaryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetCosmosdbSqlapiSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetCosmosdbSqlapiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetDelimitedTextAzureBlobFsLocation {
    dynamicFileSystemEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    fileSystem?: string;
    filename?: string;
    path?: string;
}

export interface DataFactoryDatasetDelimitedTextAzureBlobStorageLocation {
    container: string;
    dynamicContainerEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename?: string;
    path?: string;
}

export interface DataFactoryDatasetDelimitedTextHttpServerLocation {
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path: string;
    relativeUrl: string;
}

export interface DataFactoryDatasetDelimitedTextSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetDelimitedTextTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetHttpSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetHttpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetJsonAzureBlobStorageLocation {
    container: string;
    dynamicContainerEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path: string;
}

export interface DataFactoryDatasetJsonHttpServerLocation {
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path: string;
    relativeUrl: string;
}

export interface DataFactoryDatasetJsonSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetJsonTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetMysqlSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetMysqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetParquetAzureBlobFsLocation {
    dynamicFileSystemEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    fileSystem?: string;
    filename?: string;
    path?: string;
}

export interface DataFactoryDatasetParquetAzureBlobStorageLocation {
    container: string;
    dynamicContainerEnabled?: boolean;
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename?: string;
    path?: string;
}

export interface DataFactoryDatasetParquetHttpServerLocation {
    dynamicFilenameEnabled?: boolean;
    dynamicPathEnabled?: boolean;
    filename: string;
    path?: string;
    relativeUrl: string;
}

export interface DataFactoryDatasetParquetSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetParquetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetPostgresqlSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetPostgresqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetSnowflakeSchemaColumn {
    name: string;
    precision?: number;
    scale?: number;
    type?: string;
}

export interface DataFactoryDatasetSnowflakeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryDatasetSqlServerTableSchemaColumn {
    description?: string;
    name: string;
    type?: string;
}

export interface DataFactoryDatasetSqlServerTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryFlowletDataFlowSink {
    dataset?: outputs.DataFactoryFlowletDataFlowSinkDataset;
    description?: string;
    flowlet?: outputs.DataFactoryFlowletDataFlowSinkFlowlet;
    linkedService?: outputs.DataFactoryFlowletDataFlowSinkLinkedService;
    name: string;
    rejectedLinkedService?: outputs.DataFactoryFlowletDataFlowSinkRejectedLinkedService;
    schemaLinkedService?: outputs.DataFactoryFlowletDataFlowSinkSchemaLinkedService;
}

export interface DataFactoryFlowletDataFlowSinkDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSinkFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSinkLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSinkRejectedLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSinkSchemaLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSource {
    dataset?: outputs.DataFactoryFlowletDataFlowSourceDataset;
    description?: string;
    flowlet?: outputs.DataFactoryFlowletDataFlowSourceFlowlet;
    linkedService?: outputs.DataFactoryFlowletDataFlowSourceLinkedService;
    name: string;
    rejectedLinkedService?: outputs.DataFactoryFlowletDataFlowSourceRejectedLinkedService;
    schemaLinkedService?: outputs.DataFactoryFlowletDataFlowSourceSchemaLinkedService;
}

export interface DataFactoryFlowletDataFlowSourceDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSourceFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSourceLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSourceRejectedLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowSourceSchemaLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryFlowletDataFlowTransformation {
    dataset?: outputs.DataFactoryFlowletDataFlowTransformationDataset;
    description?: string;
    flowlet?: outputs.DataFactoryFlowletDataFlowTransformationFlowlet;
    linkedService?: outputs.DataFactoryFlowletDataFlowTransformationLinkedService;
    name: string;
}

export interface DataFactoryFlowletDataFlowTransformationDataset {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowTransformationFlowlet {
    datasetParameters?: string;
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryFlowletDataFlowTransformationLinkedService {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryGithubConfiguration {
    accountName: string;
    branchName: string;
    gitUrl?: string;
    publishingEnabled?: boolean;
    repositoryName: string;
    rootFolder: string;
}

export interface DataFactoryGlobalParameter {
    name: string;
    type: string;
    value: string;
}

export interface DataFactoryIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisCatalogInfo {
    administratorLogin?: string;
    administratorPassword?: string;
    dualStandbyPairName?: string;
    elasticPoolName?: string;
    pricingTier?: string;
    serverEndpoint: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisCopyComputeScale {
    dataIntegrationUnit?: number;
    timeToLive?: number;
}

export interface DataFactoryIntegrationRuntimeAzureSsisCustomSetupScript {
    blobContainerUri: string;
    sasToken: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetup {
    commandKeys?: outputs.DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupCommandKey[];
    components?: outputs.DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupComponent[];
    environment?: {[key: string]: string};
    powershellVersion?: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupCommandKey {
    keyVaultPassword?: outputs.DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupCommandKeyKeyVaultPassword;
    password?: string;
    targetName: string;
    userName: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupCommandKeyKeyVaultPassword {
    linkedServiceName: string;
    parameters?: {[key: string]: string};
    secretName: string;
    secretVersion?: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupComponent {
    keyVaultLicense?: outputs.DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupComponentKeyVaultLicense;
    license?: string;
    name: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressCustomSetupComponentKeyVaultLicense {
    linkedServiceName: string;
    parameters?: {[key: string]: string};
    secretName: string;
    secretVersion?: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisExpressVnetIntegration {
    subnetId: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisPackageStore {
    linkedServiceName: string;
    name: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisPipelineExternalComputeScale {
    numberOfExternalNodes?: number;
    numberOfPipelineNodes?: number;
    timeToLive?: number;
}

export interface DataFactoryIntegrationRuntimeAzureSsisProxy {
    path?: string;
    selfHostedIntegrationRuntimeName: string;
    stagingStorageLinkedServiceName: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryIntegrationRuntimeAzureSsisVnetIntegration {
    publicIps?: string[];
    subnetId?: string;
    subnetName?: string;
    vnetId?: string;
}

export interface DataFactoryIntegrationRuntimeAzureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryIntegrationRuntimeSelfHostedRbacAuthorization {
    resourceId: string;
}

export interface DataFactoryIntegrationRuntimeSelfHostedTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedCustomServiceIntegrationRuntime {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryLinkedCustomServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureBlobStorageKeyVaultSasToken {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureBlobStorageServicePrincipalLinkedKeyVaultKey {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureBlobStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureDatabricksInstancePool {
    clusterVersion: string;
    instancePoolId: string;
    maxNumberOfWorkers?: number;
    minNumberOfWorkers?: number;
}

export interface DataFactoryLinkedServiceAzureDatabricksKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureDatabricksNewClusterConfig {
    clusterVersion: string;
    customTags?: {[key: string]: string};
    driverNodeType?: string;
    initScripts?: string[];
    logDestination?: string;
    maxNumberOfWorkers?: number;
    minNumberOfWorkers?: number;
    nodeType: string;
    sparkConfig?: {[key: string]: string};
    sparkEnvironmentVariables?: {[key: string]: string};
}

export interface DataFactoryLinkedServiceAzureDatabricksTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureFileStorageKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureFileStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureFunctionKeyVaultKey {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureFunctionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureSearchTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureSqlDatabaseKeyVaultConnectionString {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureSqlDatabaseKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceAzureSqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceAzureTableStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceCosmosdbMongoapiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceCosmosdbTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceDataLakeStorageGen2Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceKeyVaultTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceKustoTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceMysqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceOdataBasicAuthentication {
    password: string;
    username: string;
}

export interface DataFactoryLinkedServiceOdataTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceOdbcBasicAuthentication {
    password: string;
    username: string;
}

export interface DataFactoryLinkedServiceOdbcTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServicePostgresqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceSftpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceSnowflakeKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceSnowflakeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceSqlServerKeyVaultConnectionString {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceSqlServerKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceSqlServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceSynapseKeyVaultPassword {
    linkedServiceName: string;
    secretName: string;
}

export interface DataFactoryLinkedServiceSynapseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryLinkedServiceWebTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryManagedPrivateEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataFactoryPipelineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTriggerBlobEventPipeline {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryTriggerBlobEventTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTriggerCustomEventPipeline {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryTriggerCustomEventTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTriggerSchedulePipeline {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryTriggerScheduleSchedule {
    daysOfMonths?: number[];
    daysOfWeeks?: string[];
    hours?: number[];
    minutes?: number[];
    monthlies?: outputs.DataFactoryTriggerScheduleScheduleMonthly[];
}

export interface DataFactoryTriggerScheduleScheduleMonthly {
    week?: number;
    weekday: string;
}

export interface DataFactoryTriggerScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTriggerTumblingWindowPipeline {
    name: string;
    parameters?: {[key: string]: string};
}

export interface DataFactoryTriggerTumblingWindowRetry {
    count: number;
    interval?: number;
}

export interface DataFactoryTriggerTumblingWindowTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataFactoryTriggerTumblingWindowTriggerDependency {
    offset?: string;
    size?: string;
    triggerName?: string;
}

export interface DataFactoryVstsConfiguration {
    accountName: string;
    branchName: string;
    projectName: string;
    publishingEnabled?: boolean;
    repositoryName: string;
    rootFolder: string;
    tenantId: string;
}

export interface DataProtectionBackupInstanceBlobStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataProtectionBackupInstanceDiskTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataProtectionBackupInstanceKubernetesClusterBackupDatasourceParameters {
    clusterScopedResourcesEnabled?: boolean;
    excludedNamespaces?: string[];
    excludedResourceTypes?: string[];
    includedNamespaces?: string[];
    includedResourceTypes?: string[];
    labelSelectors?: string[];
    volumeSnapshotEnabled?: boolean;
}

export interface DataProtectionBackupInstanceKubernetesClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupInstancePostgresqlFlexibleServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataProtectionBackupInstancePostgresqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataProtectionBackupPolicyBlobStorageRetentionRule {
    criteria: outputs.DataProtectionBackupPolicyBlobStorageRetentionRuleCriteria;
    lifeCycle: outputs.DataProtectionBackupPolicyBlobStorageRetentionRuleLifeCycle;
    name: string;
    priority: number;
}

export interface DataProtectionBackupPolicyBlobStorageRetentionRuleCriteria {
    absoluteCriteria?: string;
    daysOfMonths?: number[];
    daysOfWeeks?: string[];
    monthsOfYears?: string[];
    scheduledBackupTimes?: string[];
    weeksOfMonths?: string[];
}

export interface DataProtectionBackupPolicyBlobStorageRetentionRuleLifeCycle {
    dataStoreType: string;
    duration: string;
}

export interface DataProtectionBackupPolicyBlobStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupPolicyDiskRetentionRule {
    criteria: outputs.DataProtectionBackupPolicyDiskRetentionRuleCriteria;
    duration: string;
    name: string;
    priority: number;
}

export interface DataProtectionBackupPolicyDiskRetentionRuleCriteria {
    absoluteCriteria?: string;
}

export interface DataProtectionBackupPolicyDiskTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupPolicyKubernetesClusterDefaultRetentionRule {
    lifeCycles: outputs.DataProtectionBackupPolicyKubernetesClusterDefaultRetentionRuleLifeCycle[];
}

export interface DataProtectionBackupPolicyKubernetesClusterDefaultRetentionRuleLifeCycle {
    dataStoreType: string;
    duration: string;
}

export interface DataProtectionBackupPolicyKubernetesClusterRetentionRule {
    criteria: outputs.DataProtectionBackupPolicyKubernetesClusterRetentionRuleCriteria;
    lifeCycles: outputs.DataProtectionBackupPolicyKubernetesClusterRetentionRuleLifeCycle[];
    name: string;
    priority: number;
}

export interface DataProtectionBackupPolicyKubernetesClusterRetentionRuleCriteria {
    absoluteCriteria?: string;
    daysOfWeeks?: string[];
    monthsOfYears?: string[];
    scheduledBackupTimes?: string[];
    weeksOfMonths?: string[];
}

export interface DataProtectionBackupPolicyKubernetesClusterRetentionRuleLifeCycle {
    dataStoreType: string;
    duration: string;
}

export interface DataProtectionBackupPolicyKubernetesClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerDefaultRetentionRule {
    lifeCycles: outputs.DataProtectionBackupPolicyPostgresqlFlexibleServerDefaultRetentionRuleLifeCycle[];
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerDefaultRetentionRuleLifeCycle {
    dataStoreType: string;
    duration: string;
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerRetentionRule {
    criteria: outputs.DataProtectionBackupPolicyPostgresqlFlexibleServerRetentionRuleCriteria;
    lifeCycles: outputs.DataProtectionBackupPolicyPostgresqlFlexibleServerRetentionRuleLifeCycle[];
    name: string;
    priority: number;
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerRetentionRuleCriteria {
    absoluteCriteria?: string;
    daysOfWeeks?: string[];
    monthsOfYears?: string[];
    scheduledBackupTimes?: string[];
    weeksOfMonths?: string[];
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerRetentionRuleLifeCycle {
    dataStoreType: string;
    duration: string;
}

export interface DataProtectionBackupPolicyPostgresqlFlexibleServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupPolicyPostgresqlRetentionRule {
    criteria: outputs.DataProtectionBackupPolicyPostgresqlRetentionRuleCriteria;
    duration: string;
    name: string;
    priority: number;
}

export interface DataProtectionBackupPolicyPostgresqlRetentionRuleCriteria {
    absoluteCriteria?: string;
    daysOfWeeks?: string[];
    monthsOfYears?: string[];
    scheduledBackupTimes?: string[];
    weeksOfMonths?: string[];
}

export interface DataProtectionBackupPolicyPostgresqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataProtectionBackupVaultIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DataProtectionBackupVaultTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataProtectionResourceGuardTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataShareAccountIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DataShareAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataShareDatasetBlobStorageStorageAccount {
    name: string;
    resourceGroupName: string;
    subscriptionId: string;
}

export interface DataShareDatasetBlobStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataShareDatasetDataLakeGen2Timeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataShareDatasetKustoClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataShareDatasetKustoDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DataShareSnapshotSchedule {
    name: string;
    recurrence: string;
    startTime: string;
}

export interface DataShareTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabaseMigrationProjectTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabaseMigrationServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataboxEdgeDeviceDeviceProperty {
    capacity: number;
    configuredRoleTypes: string[];
    culture: string;
    hcsVersion: string;
    model: string;
    nodeCount: number;
    serialNumber: string;
    softwareVersion: string;
    status: string;
    timeZone: string;
    type: string;
}

export interface DataboxEdgeDeviceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabricksAccessConnectorIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DatabricksAccessConnectorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabricksVirtualNetworkPeeringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabricksWorkspaceCustomParameters {
    machineLearningWorkspaceId?: string;
    natGatewayName: string;
    noPublicIp?: boolean;
    privateSubnetName?: string;
    privateSubnetNetworkSecurityGroupAssociationId?: string;
    publicIpName: string;
    publicSubnetName?: string;
    publicSubnetNetworkSecurityGroupAssociationId?: string;
    storageAccountName: string;
    storageAccountSkuName: string;
    virtualNetworkId?: string;
    vnetAddressPrefix: string;
}

export interface DatabricksWorkspaceCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabricksWorkspaceManagedDiskIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DatabricksWorkspaceRootDbfsCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatabricksWorkspaceStorageAccountIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DatabricksWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatadogMonitorDatadogOrganization {
    apiKey: string;
    applicationKey: string;
    enterpriseAppId?: string;
    id: string;
    linkingAuthCode?: string;
    linkingClientId?: string;
    name: string;
    redirectUri?: string;
}

export interface DatadogMonitorIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DatadogMonitorSsoConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatadogMonitorTagRuleLog {
    aadLogEnabled?: boolean;
    filters?: outputs.DatadogMonitorTagRuleLogFilter[];
    resourceLogEnabled?: boolean;
    subscriptionLogEnabled?: boolean;
}

export interface DatadogMonitorTagRuleLogFilter {
    action: string;
    name: string;
    value: string;
}

export interface DatadogMonitorTagRuleMetric {
    filters?: outputs.DatadogMonitorTagRuleMetricFilter[];
}

export interface DatadogMonitorTagRuleMetricFilter {
    action: string;
    name: string;
    value: string;
}

export interface DatadogMonitorTagRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatadogMonitorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DatadogMonitorUser {
    email: string;
    name: string;
    phoneNumber?: string;
}

export interface DedicatedHardwareSecurityModuleManagementNetworkProfile {
    networkInterfacePrivateIpAddresses: string[];
    subnetId: string;
}

export interface DedicatedHardwareSecurityModuleNetworkProfile {
    networkInterfacePrivateIpAddresses: string[];
    subnetId: string;
}

export interface DedicatedHardwareSecurityModuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DedicatedHostGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DedicatedHostTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterCatalogCatalogAdogit {
    branch: string;
    keyVaultKeyUrl: string;
    path: string;
    uri: string;
}

export interface DevCenterCatalogCatalogGithub {
    branch: string;
    keyVaultKeyUrl: string;
    path: string;
    uri: string;
}

export interface DevCenterCatalogTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterDevBoxDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterEnvironmentTypeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterGalleryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DevCenterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DevCenterNetworkConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterProjectEnvironmentTypeIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DevCenterProjectEnvironmentTypeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterProjectEnvironmentTypeUserRoleAssignment {
    roles: string[];
    userId: string;
}

export interface DevCenterProjectTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevCenterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestGlobalVmShutdownScheduleNotificationSettings {
    email?: string;
    enabled: boolean;
    timeInMinutes?: number;
    webhookUrl?: string;
}

export interface DevTestGlobalVmShutdownScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestLabTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestLinuxVirtualMachineGalleryImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface DevTestLinuxVirtualMachineInboundNatRule {
    backendPort: number;
    frontendPort: number;
    protocol: string;
}

export interface DevTestLinuxVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestScheduleDailyRecurrence {
    time: string;
}

export interface DevTestScheduleHourlyRecurrence {
    minute: number;
}

export interface DevTestScheduleNotificationSettings {
    status?: string;
    timeInMinutes?: number;
    webhookUrl?: string;
}

export interface DevTestScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestScheduleWeeklyRecurrence {
    time: string;
    weekDays?: string[];
}

export interface DevTestVirtualNetworkSubnet {
    name: string;
    sharedPublicIpAddress?: outputs.DevTestVirtualNetworkSubnetSharedPublicIpAddress;
    useInVirtualMachineCreation?: string;
    usePublicIpAddress?: string;
}

export interface DevTestVirtualNetworkSubnetSharedPublicIpAddress {
    allowedPorts?: outputs.DevTestVirtualNetworkSubnetSharedPublicIpAddressAllowedPort[];
}

export interface DevTestVirtualNetworkSubnetSharedPublicIpAddressAllowedPort {
    backendPort?: number;
    transportProtocol?: string;
}

export interface DevTestVirtualNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DevTestWindowsVirtualMachineGalleryImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface DevTestWindowsVirtualMachineInboundNatRule {
    backendPort: number;
    frontendPort: number;
    protocol: string;
}

export interface DevTestWindowsVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DigitalTwinsEndpointEventgridTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DigitalTwinsEndpointEventhubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DigitalTwinsEndpointServicebusTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DigitalTwinsInstanceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DigitalTwinsInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DigitalTwinsTimeSeriesDatabaseConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DiskAccessTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DiskEncryptionSetIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface DiskEncryptionSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsARecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsAaaaRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsCaaRecordRecord {
    flags: number;
    tag: string;
    value: string;
}

export interface DnsCaaRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsCnameRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsMxRecordRecord {
    exchange: string;
    preference: string;
}

export interface DnsMxRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsNsRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsPtrRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsSrvRecordRecord {
    port: number;
    priority: number;
    target: string;
    weight: number;
}

export interface DnsSrvRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsTxtRecordRecord {
    value: string;
}

export interface DnsTxtRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DnsZoneSoaRecord {
    email: string;
    expireTime?: number;
    fqdn: string;
    hostName: string;
    minimumTtl?: number;
    refreshTime?: number;
    retryTime?: number;
    serialNumber?: number;
    tags?: {[key: string]: string};
    ttl?: number;
}

export interface DnsZoneTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ElasticCloudElasticsearchLogs {
    filteringTags?: outputs.ElasticCloudElasticsearchLogsFilteringTag[];
    sendActivityLogs?: boolean;
    sendAzureadLogs?: boolean;
    sendSubscriptionLogs?: boolean;
}

export interface ElasticCloudElasticsearchLogsFilteringTag {
    action: string;
    name: string;
    value: string;
}

export interface ElasticCloudElasticsearchTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ElasticSanSku {
    name: string;
    tier?: string;
}

export interface ElasticSanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ElasticSanVolumeCreateSource {
    sourceId: string;
    sourceType: string;
}

export interface ElasticSanVolumeGroupEncryption {
    currentVersionedKeyExpirationTimestamp: string;
    currentVersionedKeyId: string;
    keyVaultKeyId: string;
    lastKeyRotationTimestamp: string;
    userAssignedIdentityId?: string;
}

export interface ElasticSanVolumeGroupIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ElasticSanVolumeGroupNetworkRule {
    action?: string;
    subnetId: string;
}

export interface ElasticSanVolumeGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ElasticSanVolumeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EmailCommunicationServiceDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EmailCommunicationServiceDomainVerificationRecord {
    dkim2s: outputs.EmailCommunicationServiceDomainVerificationRecordDkim2[];
    dkims: outputs.EmailCommunicationServiceDomainVerificationRecordDkim[];
    dmarcs: outputs.EmailCommunicationServiceDomainVerificationRecordDmarc[];
    domains: outputs.EmailCommunicationServiceDomainVerificationRecordDomain[];
    spfs: outputs.EmailCommunicationServiceDomainVerificationRecordSpf[];
}

export interface EmailCommunicationServiceDomainVerificationRecordDkim {
    name: string;
    ttl: number;
    type: string;
    value: string;
}

export interface EmailCommunicationServiceDomainVerificationRecordDkim2 {
    name: string;
    ttl: number;
    type: string;
    value: string;
}

export interface EmailCommunicationServiceDomainVerificationRecordDmarc {
    name: string;
    ttl: number;
    type: string;
    value: string;
}

export interface EmailCommunicationServiceDomainVerificationRecordDomain {
    name: string;
    ttl: number;
    type: string;
    value: string;
}

export interface EmailCommunicationServiceDomainVerificationRecordSpf {
    name: string;
    ttl: number;
    type: string;
    value: string;
}

export interface EmailCommunicationServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventgridDomainIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface EventgridDomainInboundIpRule {
    action: string;
    ipMask: string;
}

export interface EventgridDomainInputMappingDefaultValues {
    dataVersion?: string;
    eventType?: string;
    subject?: string;
}

export interface EventgridDomainInputMappingFields {
    dataVersion?: string;
    eventTime?: string;
    eventType?: string;
    id?: string;
    subject?: string;
    topic?: string;
}

export interface EventgridDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventgridDomainTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface EventgridEventSubscriptionAdvancedFilter {
    boolEquals?: outputs.EventgridEventSubscriptionAdvancedFilterBoolEqual[];
    isNotNulls?: outputs.EventgridEventSubscriptionAdvancedFilterIsNotNull[];
    isNullOrUndefineds?: outputs.EventgridEventSubscriptionAdvancedFilterIsNullOrUndefined[];
    numberGreaterThanOrEquals?: outputs.EventgridEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
    numberGreaterThans?: outputs.EventgridEventSubscriptionAdvancedFilterNumberGreaterThan[];
    numberInRanges?: outputs.EventgridEventSubscriptionAdvancedFilterNumberInRange[];
    numberIns?: outputs.EventgridEventSubscriptionAdvancedFilterNumberIn[];
    numberLessThanOrEquals?: outputs.EventgridEventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
    numberLessThans?: outputs.EventgridEventSubscriptionAdvancedFilterNumberLessThan[];
    numberNotInRanges?: outputs.EventgridEventSubscriptionAdvancedFilterNumberNotInRange[];
    numberNotIns?: outputs.EventgridEventSubscriptionAdvancedFilterNumberNotIn[];
    stringBeginsWiths?: outputs.EventgridEventSubscriptionAdvancedFilterStringBeginsWith[];
    stringContains?: outputs.EventgridEventSubscriptionAdvancedFilterStringContain[];
    stringEndsWiths?: outputs.EventgridEventSubscriptionAdvancedFilterStringEndsWith[];
    stringIns?: outputs.EventgridEventSubscriptionAdvancedFilterStringIn[];
    stringNotBeginsWiths?: outputs.EventgridEventSubscriptionAdvancedFilterStringNotBeginsWith[];
    stringNotContains?: outputs.EventgridEventSubscriptionAdvancedFilterStringNotContain[];
    stringNotEndsWiths?: outputs.EventgridEventSubscriptionAdvancedFilterStringNotEndsWith[];
    stringNotIns?: outputs.EventgridEventSubscriptionAdvancedFilterStringNotIn[];
}

export interface EventgridEventSubscriptionAdvancedFilterBoolEqual {
    key: string;
    value: boolean;
}

export interface EventgridEventSubscriptionAdvancedFilterIsNotNull {
    key: string;
}

export interface EventgridEventSubscriptionAdvancedFilterIsNullOrUndefined {
    key: string;
}

export interface EventgridEventSubscriptionAdvancedFilterNumberGreaterThan {
    key: string;
    value: number;
}

export interface EventgridEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
    key: string;
    value: number;
}

export interface EventgridEventSubscriptionAdvancedFilterNumberIn {
    key: string;
    values: number[];
}

export interface EventgridEventSubscriptionAdvancedFilterNumberInRange {
    key: string;
    values: number[][];
}

export interface EventgridEventSubscriptionAdvancedFilterNumberLessThan {
    key: string;
    value: number;
}

export interface EventgridEventSubscriptionAdvancedFilterNumberLessThanOrEqual {
    key: string;
    value: number;
}

export interface EventgridEventSubscriptionAdvancedFilterNumberNotIn {
    key: string;
    values: number[];
}

export interface EventgridEventSubscriptionAdvancedFilterNumberNotInRange {
    key: string;
    values: number[][];
}

export interface EventgridEventSubscriptionAdvancedFilterStringBeginsWith {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringContain {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringEndsWith {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringIn {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringNotBeginsWith {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringNotContain {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringNotEndsWith {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAdvancedFilterStringNotIn {
    key: string;
    values: string[];
}

export interface EventgridEventSubscriptionAzureFunctionEndpoint {
    functionId: string;
    maxEventsPerBatch?: number;
    preferredBatchSizeInKilobytes?: number;
}

export interface EventgridEventSubscriptionDeadLetterIdentity {
    type: string;
    userAssignedIdentity?: string;
}

export interface EventgridEventSubscriptionDeliveryIdentity {
    type: string;
    userAssignedIdentity?: string;
}

export interface EventgridEventSubscriptionDeliveryProperty {
    headerName: string;
    secret?: boolean;
    sourceField?: string;
    type: string;
    value?: string;
}

export interface EventgridEventSubscriptionRetryPolicy {
    eventTimeToLive: number;
    maxDeliveryAttempts: number;
}

export interface EventgridEventSubscriptionStorageBlobDeadLetterDestination {
    storageAccountId: string;
    storageBlobContainerName: string;
}

export interface EventgridEventSubscriptionStorageQueueEndpoint {
    queueMessageTimeToLiveInSeconds?: number;
    queueName: string;
    storageAccountId: string;
}

export interface EventgridEventSubscriptionSubjectFilter {
    caseSensitive?: boolean;
    subjectBeginsWith?: string;
    subjectEndsWith?: string;
}

export interface EventgridEventSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventgridEventSubscriptionWebhookEndpoint {
    activeDirectoryAppIdOrUri?: string;
    activeDirectoryTenantId?: string;
    baseUrl: string;
    maxEventsPerBatch?: number;
    preferredBatchSizeInKilobytes?: number;
    url: string;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilter {
    boolEquals?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterBoolEqual[];
    isNotNulls?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterIsNotNull[];
    isNullOrUndefineds?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined[];
    numberGreaterThanOrEquals?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual[];
    numberGreaterThans?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan[];
    numberInRanges?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberInRange[];
    numberIns?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberIn[];
    numberLessThanOrEquals?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual[];
    numberLessThans?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberLessThan[];
    numberNotInRanges?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberNotInRange[];
    numberNotIns?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterNumberNotIn[];
    stringBeginsWiths?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringBeginsWith[];
    stringContains?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringContain[];
    stringEndsWiths?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringEndsWith[];
    stringIns?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringIn[];
    stringNotBeginsWiths?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith[];
    stringNotContains?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotContain[];
    stringNotEndsWiths?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith[];
    stringNotIns?: outputs.EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotIn[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterBoolEqual {
    key: string;
    value: boolean;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterIsNotNull {
    key: string;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterIsNullOrUndefined {
    key: string;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberGreaterThan {
    key: string;
    value: number;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberGreaterThanOrEqual {
    key: string;
    value: number;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberIn {
    key: string;
    values: number[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberInRange {
    key: string;
    values: number[][];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberLessThan {
    key: string;
    value: number;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberLessThanOrEqual {
    key: string;
    value: number;
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberNotIn {
    key: string;
    values: number[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterNumberNotInRange {
    key: string;
    values: number[][];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringBeginsWith {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringContain {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringEndsWith {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringIn {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotBeginsWith {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotContain {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotEndsWith {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAdvancedFilterStringNotIn {
    key: string;
    values: string[];
}

export interface EventgridSystemTopicEventSubscriptionAzureFunctionEndpoint {
    functionId: string;
    maxEventsPerBatch?: number;
    preferredBatchSizeInKilobytes?: number;
}

export interface EventgridSystemTopicEventSubscriptionDeadLetterIdentity {
    type: string;
    userAssignedIdentity?: string;
}

export interface EventgridSystemTopicEventSubscriptionDeliveryIdentity {
    type: string;
    userAssignedIdentity?: string;
}

export interface EventgridSystemTopicEventSubscriptionDeliveryProperty {
    headerName: string;
    secret?: boolean;
    sourceField?: string;
    type: string;
    value?: string;
}

export interface EventgridSystemTopicEventSubscriptionRetryPolicy {
    eventTimeToLive: number;
    maxDeliveryAttempts: number;
}

export interface EventgridSystemTopicEventSubscriptionStorageBlobDeadLetterDestination {
    storageAccountId: string;
    storageBlobContainerName: string;
}

export interface EventgridSystemTopicEventSubscriptionStorageQueueEndpoint {
    queueMessageTimeToLiveInSeconds?: number;
    queueName: string;
    storageAccountId: string;
}

export interface EventgridSystemTopicEventSubscriptionSubjectFilter {
    caseSensitive?: boolean;
    subjectBeginsWith?: string;
    subjectEndsWith?: string;
}

export interface EventgridSystemTopicEventSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventgridSystemTopicEventSubscriptionWebhookEndpoint {
    activeDirectoryAppIdOrUri?: string;
    activeDirectoryTenantId?: string;
    baseUrl: string;
    maxEventsPerBatch?: number;
    preferredBatchSizeInKilobytes?: number;
    url: string;
}

export interface EventgridSystemTopicIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface EventgridSystemTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventgridTopicIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface EventgridTopicInboundIpRule {
    action: string;
    ipMask: string;
}

export interface EventgridTopicInputMappingDefaultValues {
    dataVersion?: string;
    eventType?: string;
    subject?: string;
}

export interface EventgridTopicInputMappingFields {
    dataVersion?: string;
    eventTime?: string;
    eventType?: string;
    id?: string;
    subject?: string;
    topic?: string;
}

export interface EventgridTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubCaptureDescription {
    destination: outputs.EventhubCaptureDescriptionDestination;
    enabled: boolean;
    encoding: string;
    intervalInSeconds?: number;
    sizeLimitInBytes?: number;
    skipEmptyArchives?: boolean;
}

export interface EventhubCaptureDescriptionDestination {
    archiveNameFormat: string;
    blobContainerName: string;
    name: string;
    storageAccountId: string;
}

export interface EventhubClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubConsumerGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubNamespaceAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubNamespaceCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubNamespaceDisasterRecoveryConfigTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubNamespaceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface EventhubNamespaceNetworkRuleset {
    defaultAction: string;
    ipRules: outputs.EventhubNamespaceNetworkRulesetIpRule[];
    publicNetworkAccessEnabled: boolean;
    trustedServiceAccessEnabled: boolean;
    virtualNetworkRules: outputs.EventhubNamespaceNetworkRulesetVirtualNetworkRule[];
}

export interface EventhubNamespaceNetworkRulesetIpRule {
    action: string;
    ipMask: string;
}

export interface EventhubNamespaceNetworkRulesetVirtualNetworkRule {
    ignoreMissingVirtualNetworkServiceEndpoint: boolean;
    subnetId: string;
}

export interface EventhubNamespaceSchemaGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface EventhubNamespaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EventhubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRouteCircuitAuthorizationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ExpressRouteCircuitConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRouteCircuitPeeringIpv6 {
    enabled?: boolean;
    microsoftPeering?: outputs.ExpressRouteCircuitPeeringIpv6MicrosoftPeering;
    primaryPeerAddressPrefix: string;
    routeFilterId?: string;
    secondaryPeerAddressPrefix: string;
}

export interface ExpressRouteCircuitPeeringIpv6MicrosoftPeering {
    advertisedCommunities?: string[];
    advertisedPublicPrefixes?: string[];
    customerAsn?: number;
    routingRegistryName?: string;
}

export interface ExpressRouteCircuitPeeringMicrosoftPeeringConfig {
    advertisedCommunities?: string[];
    advertisedPublicPrefixes: string[];
    customerAsn?: number;
    routingRegistryName?: string;
}

export interface ExpressRouteCircuitPeeringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRouteCircuitSku {
    family: string;
    tier: string;
}

export interface ExpressRouteCircuitTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRouteConnectionRouting {
    associatedRouteTableId: string;
    inboundRouteMapId?: string;
    outboundRouteMapId?: string;
    propagatedRouteTable?: outputs.ExpressRouteConnectionRoutingPropagatedRouteTable;
}

export interface ExpressRouteConnectionRoutingPropagatedRouteTable {
    labels: string[];
    routeTableIds: string[];
}

export interface ExpressRouteConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRouteGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExpressRoutePortAuthorizationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ExpressRoutePortIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ExpressRoutePortLink1 {
    adminEnabled?: boolean;
    connectorType: string;
    id: string;
    interfaceName: string;
    macsecCakKeyvaultSecretId?: string;
    macsecCipher?: string;
    macsecCknKeyvaultSecretId?: string;
    macsecSciEnabled?: boolean;
    patchPanelId: string;
    rackId: string;
    routerName: string;
}

export interface ExpressRoutePortLink2 {
    adminEnabled?: boolean;
    connectorType: string;
    id: string;
    interfaceName: string;
    macsecCakKeyvaultSecretId?: string;
    macsecCipher?: string;
    macsecCknKeyvaultSecretId?: string;
    macsecSciEnabled?: boolean;
    patchPanelId: string;
    rackId: string;
    routerName: string;
}

export interface ExpressRoutePortTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ExtendedCustomLocationAuthentication {
    type?: string;
    value: string;
}

export interface ExtendedCustomLocationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FederatedIdentityCredentialTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallApplicationRuleCollectionRule {
    description?: string;
    fqdnTags?: string[];
    name: string;
    protocols?: outputs.FirewallApplicationRuleCollectionRuleProtocol[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
    targetFqdns?: string[];
}

export interface FirewallApplicationRuleCollectionRuleProtocol {
    port: number;
    type: string;
}

export interface FirewallApplicationRuleCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallIpConfiguration {
    name: string;
    privateIpAddress: string;
    publicIpAddressId?: string;
    subnetId?: string;
}

export interface FirewallManagementIpConfiguration {
    name: string;
    privateIpAddress: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface FirewallNatRuleCollectionRule {
    description?: string;
    destinationAddresses: string[];
    destinationPorts: string[];
    name: string;
    protocols: string[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
    translatedAddress: string;
    translatedPort: string;
}

export interface FirewallNatRuleCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallNetworkRuleCollectionRule {
    description?: string;
    destinationAddresses?: string[];
    destinationFqdns?: string[];
    destinationIpGroups?: string[];
    destinationPorts: string[];
    name: string;
    protocols: string[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
}

export interface FirewallNetworkRuleCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallPolicyDns {
    proxyEnabled?: boolean;
    servers?: string[];
}

export interface FirewallPolicyExplicitProxy {
    enablePacFile?: boolean;
    enabled?: boolean;
    httpPort?: number;
    httpsPort?: number;
    pacFile?: string;
    pacFilePort?: number;
}

export interface FirewallPolicyIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface FirewallPolicyInsights {
    defaultLogAnalyticsWorkspaceId: string;
    enabled: boolean;
    logAnalyticsWorkspaces?: outputs.FirewallPolicyInsightsLogAnalyticsWorkspace[];
    retentionInDays?: number;
}

export interface FirewallPolicyInsightsLogAnalyticsWorkspace {
    firewallLocation: string;
    id: string;
}

export interface FirewallPolicyIntrusionDetection {
    mode?: string;
    privateRanges?: string[];
    signatureOverrides?: outputs.FirewallPolicyIntrusionDetectionSignatureOverride[];
    trafficBypasses?: outputs.FirewallPolicyIntrusionDetectionTrafficBypass[];
}

export interface FirewallPolicyIntrusionDetectionSignatureOverride {
    id?: string;
    state?: string;
}

export interface FirewallPolicyIntrusionDetectionTrafficBypass {
    description?: string;
    destinationAddresses?: string[];
    destinationIpGroups?: string[];
    destinationPorts?: string[];
    name: string;
    protocol: string;
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
}

export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollection {
    action: string;
    name: string;
    priority: number;
    rules: outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule[];
}

export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRule {
    description?: string;
    destinationAddresses?: string[];
    destinationFqdnTags?: string[];
    destinationFqdns?: string[];
    destinationUrls?: string[];
    httpHeaders?: outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleHttpHeader[];
    name: string;
    protocols?: outputs.FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
    terminateTls?: boolean;
    webCategories?: string[];
}

export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleHttpHeader {
    name: string;
    value: string;
}

export interface FirewallPolicyRuleCollectionGroupApplicationRuleCollectionRuleProtocol {
    port: number;
    type: string;
}

export interface FirewallPolicyRuleCollectionGroupNatRuleCollection {
    action: string;
    name: string;
    priority: number;
    rules: outputs.FirewallPolicyRuleCollectionGroupNatRuleCollectionRule[];
}

export interface FirewallPolicyRuleCollectionGroupNatRuleCollectionRule {
    description?: string;
    destinationAddress?: string;
    destinationPorts?: string[];
    name: string;
    protocols: string[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
    translatedAddress?: string;
    translatedFqdn?: string;
    translatedPort: number;
}

export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollection {
    action: string;
    name: string;
    priority: number;
    rules: outputs.FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule[];
}

export interface FirewallPolicyRuleCollectionGroupNetworkRuleCollectionRule {
    description?: string;
    destinationAddresses?: string[];
    destinationFqdns?: string[];
    destinationIpGroups?: string[];
    destinationPorts: string[];
    name: string;
    protocols: string[];
    sourceAddresses?: string[];
    sourceIpGroups?: string[];
}

export interface FirewallPolicyRuleCollectionGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallPolicyThreatIntelligenceAllowlist {
    fqdns?: string[];
    ipAddresses?: string[];
}

export interface FirewallPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallPolicyTlsCertificate {
    keyVaultSecretId: string;
    name: string;
}

export interface FirewallTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FirewallVirtualHub {
    privateIpAddress: string;
    publicIpAddresses: string[];
    publicIpCount?: number;
    virtualHubId: string;
}

export interface FluidRelayServerIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface FluidRelayServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FrontdoorBackendPool {
    backends: outputs.FrontdoorBackendPoolBackend[];
    healthProbeName: string;
    id: string;
    loadBalancingName: string;
    name: string;
}

export interface FrontdoorBackendPoolBackend {
    address: string;
    enabled?: boolean;
    hostHeader: string;
    httpPort: number;
    httpsPort: number;
    priority?: number;
    weight?: number;
}

export interface FrontdoorBackendPoolHealthProbe {
    enabled?: boolean;
    id: string;
    intervalInSeconds?: number;
    name: string;
    path?: string;
    probeMethod?: string;
    protocol?: string;
}

export interface FrontdoorBackendPoolLoadBalancing {
    additionalLatencyMilliseconds?: number;
    id: string;
    name: string;
    sampleSize?: number;
    successfulSamplesRequired?: number;
}

export interface FrontdoorBackendPoolSetting {
    backendPoolsSendReceiveTimeoutSeconds?: number;
    enforceBackendPoolsCertificateNameCheck: boolean;
}

export interface FrontdoorCustomHttpsConfigurationCustomHttpsConfiguration {
    azureKeyVaultCertificateSecretName?: string;
    azureKeyVaultCertificateSecretVersion?: string;
    azureKeyVaultCertificateVaultId?: string;
    certificateSource?: string;
    minimumTlsVersion: string;
    provisioningState: string;
    provisioningSubstate: string;
}

export interface FrontdoorCustomHttpsConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FrontdoorExplicitResourceOrder {
    backendPoolHealthProbeIds: string[];
    backendPoolIds: string[];
    backendPoolLoadBalancingIds: string[];
    frontendEndpointIds: string[];
    routingRuleIds: string[];
}

export interface FrontdoorFirewallPolicyCustomRule {
    action: string;
    enabled?: boolean;
    matchConditions?: outputs.FrontdoorFirewallPolicyCustomRuleMatchCondition[];
    name: string;
    priority?: number;
    rateLimitDurationInMinutes?: number;
    rateLimitThreshold?: number;
    type: string;
}

export interface FrontdoorFirewallPolicyCustomRuleMatchCondition {
    matchValues: string[];
    matchVariable: string;
    negationCondition?: boolean;
    operator: string;
    selector?: string;
    transforms?: string[];
}

export interface FrontdoorFirewallPolicyManagedRule {
    exclusions?: outputs.FrontdoorFirewallPolicyManagedRuleExclusion[];
    overrides?: outputs.FrontdoorFirewallPolicyManagedRuleOverride[];
    type: string;
    version: string;
}

export interface FrontdoorFirewallPolicyManagedRuleExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface FrontdoorFirewallPolicyManagedRuleOverride {
    exclusions?: outputs.FrontdoorFirewallPolicyManagedRuleOverrideExclusion[];
    ruleGroupName: string;
    rules?: outputs.FrontdoorFirewallPolicyManagedRuleOverrideRule[];
}

export interface FrontdoorFirewallPolicyManagedRuleOverrideExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface FrontdoorFirewallPolicyManagedRuleOverrideRule {
    action: string;
    enabled?: boolean;
    exclusions?: outputs.FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion[];
    ruleId: string;
}

export interface FrontdoorFirewallPolicyManagedRuleOverrideRuleExclusion {
    matchVariable: string;
    operator: string;
    selector: string;
}

export interface FrontdoorFirewallPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FrontdoorFrontendEndpoint {
    hostName: string;
    id: string;
    name: string;
    sessionAffinityEnabled?: boolean;
    sessionAffinityTtlSeconds?: number;
    webApplicationFirewallPolicyLinkId?: string;
}

export interface FrontdoorRoutingRule {
    acceptedProtocols: string[];
    enabled?: boolean;
    forwardingConfiguration?: outputs.FrontdoorRoutingRuleForwardingConfiguration;
    frontendEndpoints: string[];
    id: string;
    name: string;
    patternsToMatches: string[];
    redirectConfiguration?: outputs.FrontdoorRoutingRuleRedirectConfiguration;
}

export interface FrontdoorRoutingRuleForwardingConfiguration {
    backendPoolName: string;
    cacheDuration?: string;
    cacheEnabled?: boolean;
    cacheQueryParameterStripDirective?: string;
    cacheQueryParameters?: string[];
    cacheUseDynamicCompression?: boolean;
    customForwardingPath?: string;
    forwardingProtocol?: string;
}

export interface FrontdoorRoutingRuleRedirectConfiguration {
    customFragment?: string;
    customHost?: string;
    customPath?: string;
    customQueryString?: string;
    redirectProtocol: string;
    redirectType: string;
}

export interface FrontdoorRulesEngineRule {
    action?: outputs.FrontdoorRulesEngineRuleAction;
    matchConditions?: outputs.FrontdoorRulesEngineRuleMatchCondition[];
    name: string;
    priority: number;
}

export interface FrontdoorRulesEngineRuleAction {
    requestHeaders?: outputs.FrontdoorRulesEngineRuleActionRequestHeader[];
    responseHeaders?: outputs.FrontdoorRulesEngineRuleActionResponseHeader[];
}

export interface FrontdoorRulesEngineRuleActionRequestHeader {
    headerActionType?: string;
    headerName?: string;
    value?: string;
}

export interface FrontdoorRulesEngineRuleActionResponseHeader {
    headerActionType?: string;
    headerName?: string;
    value?: string;
}

export interface FrontdoorRulesEngineRuleMatchCondition {
    negateCondition?: boolean;
    operator: string;
    selector?: string;
    transforms?: string[];
    values?: string[];
    variable?: string;
}

export interface FrontdoorRulesEngineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FrontdoorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppActiveSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppAuthSettings {
    activeDirectory?: outputs.FunctionAppAuthSettingsActiveDirectory;
    additionalLoginParams?: {[key: string]: string};
    allowedExternalRedirectUrls?: string[];
    defaultProvider?: string;
    enabled: boolean;
    facebook?: outputs.FunctionAppAuthSettingsFacebook;
    google?: outputs.FunctionAppAuthSettingsGoogle;
    issuer?: string;
    microsoft?: outputs.FunctionAppAuthSettingsMicrosoft;
    runtimeVersion?: string;
    tokenRefreshExtensionHours?: number;
    tokenStoreEnabled?: boolean;
    twitter?: outputs.FunctionAppAuthSettingsTwitter;
    unauthenticatedClientAction?: string;
}

export interface FunctionAppAuthSettingsActiveDirectory {
    allowedAudiences?: string[];
    clientId: string;
    clientSecret?: string;
}

export interface FunctionAppAuthSettingsFacebook {
    appId: string;
    appSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppAuthSettingsGoogle {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppAuthSettingsMicrosoft {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppAuthSettingsTwitter {
    consumerKey: string;
    consumerSecret: string;
}

export interface FunctionAppConnectionAuthentication {
    certificate?: string;
    clientId?: string;
    name?: string;
    principalId?: string;
    secret?: string;
    subscriptionId?: string;
    type: string;
}

export interface FunctionAppConnectionSecretStore {
    keyVaultId: string;
}

export interface FunctionAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface FunctionAppConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppFunctionFile {
    /**
     * The content of the file.
     */
    content: string;
    /**
     * The filename of the file to be uploaded.
     */
    name: string;
}

export interface FunctionAppFunctionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppHybridConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface FunctionAppSiteConfig {
    alwaysOn?: boolean;
    appScaleLimit: number;
    autoSwapSlotName?: string;
    cors?: outputs.FunctionAppSiteConfigCors;
    dotnetFrameworkVersion?: string;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.FunctionAppSiteConfigIpRestriction[];
    javaVersion?: string;
    linuxFxVersion: string;
    minTlsVersion: string;
    preWarmedInstanceCount: number;
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictions: outputs.FunctionAppSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled?: boolean;
}

export interface FunctionAppSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface FunctionAppSiteConfigIpRestriction {
    action: string;
    headers: outputs.FunctionAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface FunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface FunctionAppSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.FunctionAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface FunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface FunctionAppSiteCredential {
    password: string;
    username: string;
}

export interface FunctionAppSlotAuthSettings {
    activeDirectory?: outputs.FunctionAppSlotAuthSettingsActiveDirectory;
    additionalLoginParams?: {[key: string]: string};
    allowedExternalRedirectUrls?: string[];
    defaultProvider?: string;
    enabled: boolean;
    facebook?: outputs.FunctionAppSlotAuthSettingsFacebook;
    google?: outputs.FunctionAppSlotAuthSettingsGoogle;
    issuer?: string;
    microsoft?: outputs.FunctionAppSlotAuthSettingsMicrosoft;
    runtimeVersion?: string;
    tokenRefreshExtensionHours?: number;
    tokenStoreEnabled?: boolean;
    twitter?: outputs.FunctionAppSlotAuthSettingsTwitter;
    unauthenticatedClientAction?: string;
}

export interface FunctionAppSlotAuthSettingsActiveDirectory {
    allowedAudiences?: string[];
    clientId: string;
    clientSecret?: string;
}

export interface FunctionAppSlotAuthSettingsFacebook {
    appId: string;
    appSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppSlotAuthSettingsGoogle {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppSlotAuthSettingsMicrosoft {
    clientId: string;
    clientSecret: string;
    oauthScopes?: string[];
}

export interface FunctionAppSlotAuthSettingsTwitter {
    consumerKey: string;
    consumerSecret: string;
}

export interface FunctionAppSlotConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface FunctionAppSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface FunctionAppSlotSiteConfig {
    alwaysOn?: boolean;
    appScaleLimit: number;
    autoSwapSlotName?: string;
    cors?: outputs.FunctionAppSlotSiteConfigCors;
    dotnetFrameworkVersion?: string;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.FunctionAppSlotSiteConfigIpRestriction[];
    javaVersion?: string;
    linuxFxVersion: string;
    minTlsVersion: string;
    preWarmedInstanceCount: number;
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictions: outputs.FunctionAppSlotSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled?: boolean;
}

export interface FunctionAppSlotSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface FunctionAppSlotSiteConfigIpRestriction {
    action: string;
    headers: outputs.FunctionAppSlotSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface FunctionAppSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface FunctionAppSlotSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.FunctionAppSlotSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface FunctionAppSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface FunctionAppSlotSiteCredential {
    password: string;
    username: string;
}

export interface FunctionAppSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionAppSourceControl {
    branch: string;
    manualIntegration: boolean;
    repoUrl: string;
    rollbackEnabled: boolean;
    useMercurial: boolean;
}

export interface FunctionAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GalleryApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GalleryApplicationVersionManageAction {
    install: string;
    remove: string;
    update?: string;
}

export interface GalleryApplicationVersionSource {
    defaultConfigurationLink?: string;
    mediaLink: string;
}

export interface GalleryApplicationVersionTargetRegion {
    excludeFromLatest?: boolean;
    name: string;
    regionalReplicaCount: number;
    storageAccountType?: string;
}

export interface GalleryApplicationVersionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GetAadb2cDirectoryTimeouts {
    read?: string;
}

export interface GetActiveDirectoryDomainServiceNotification {
    additionalRecipients: string[];
    notifyDcAdmins: boolean;
    notifyGlobalAdmins: boolean;
}

export interface GetActiveDirectoryDomainServiceReplicaSet {
    domainControllerIpAddresses: string[];
    externalAccessIpAddress: string;
    id: string;
    location: string;
    serviceStatus: string;
    subnetId: string;
}

export interface GetActiveDirectoryDomainServiceSecureLdap {
    certificateExpiry: string;
    certificateThumbprint: string;
    enabled: boolean;
    externalAccessEnabled: boolean;
    publicCertificate: string;
}

export interface GetActiveDirectoryDomainServiceSecurity {
    kerberosArmoringEnabled: boolean;
    kerberosRc4EncryptionEnabled: boolean;
    ntlmV1Enabled: boolean;
    syncKerberosPasswords: boolean;
    syncNtlmPasswords: boolean;
    syncOnPremPasswords: boolean;
    tlsV1Enabled: boolean;
}

export interface GetActiveDirectoryDomainServiceTimeouts {
    read?: string;
}

export interface GetAdvisorRecommendationsRecommendation {
    category: string;
    description: string;
    impact: string;
    recommendationName: string;
    recommendationTypeId: string;
    resourceName: string;
    resourceType: string;
    suppressionNames: string[];
    updatedTime: string;
}

export interface GetAdvisorRecommendationsTimeouts {
    read?: string;
}

export interface GetApiManagementAdditionalLocation {
    capacity: number;
    gatewayRegionalUrl: string;
    location: string;
    privateIpAddresses: string[];
    publicIpAddressId: string;
    publicIpAddresses: string[];
    zones: string[];
}

export interface GetApiManagementApiSubscriptionKeyParameterName {
    header: string;
    query: string;
}

export interface GetApiManagementApiTimeouts {
    read?: string;
}

export interface GetApiManagementApiVersionSetTimeouts {
    read?: string;
}

export interface GetApiManagementGatewayHostNameConfigurationTimeouts {
    read?: string;
}

export interface GetApiManagementGatewayLocationData {
    city: string;
    district: string;
    name: string;
    region: string;
}

export interface GetApiManagementGatewayTimeouts {
    read?: string;
}

export interface GetApiManagementGroupTimeouts {
    read?: string;
}

export interface GetApiManagementHostnameConfiguration {
    developerPortals: outputs.GetApiManagementHostnameConfigurationDeveloperPortal[];
    managements: outputs.GetApiManagementHostnameConfigurationManagement[];
    portals: outputs.GetApiManagementHostnameConfigurationPortal[];
    proxies: outputs.GetApiManagementHostnameConfigurationProxy[];
    scms: outputs.GetApiManagementHostnameConfigurationScm[];
}

export interface GetApiManagementHostnameConfigurationDeveloperPortal {
    hostName: string;
    keyVaultId: string;
    negotiateClientCertificate: boolean;
}

export interface GetApiManagementHostnameConfigurationManagement {
    hostName: string;
    keyVaultId: string;
    negotiateClientCertificate: boolean;
}

export interface GetApiManagementHostnameConfigurationPortal {
    hostName: string;
    keyVaultId: string;
    negotiateClientCertificate: boolean;
}

export interface GetApiManagementHostnameConfigurationProxy {
    defaultSslBinding: boolean;
    hostName: string;
    keyVaultId: string;
    negotiateClientCertificate: boolean;
}

export interface GetApiManagementHostnameConfigurationScm {
    hostName: string;
    keyVaultId: string;
    negotiateClientCertificate: boolean;
}

export interface GetApiManagementIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetApiManagementProductTimeouts {
    read?: string;
}

export interface GetApiManagementTenantAccess {
    enabled: boolean;
    primaryKey: string;
    secondaryKey: string;
    tenantId: string;
}

export interface GetApiManagementTimeouts {
    read?: string;
}

export interface GetApiManagementUserTimeouts {
    read?: string;
}

export interface GetAppConfigurationEncryption {
    identityClientId: string;
    keyVaultKeyIdentifier: string;
}

export interface GetAppConfigurationIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetAppConfigurationKeyTimeouts {
    read?: string;
}

export interface GetAppConfigurationKeysItem {
    contentType: string;
    etag: string;
    key: string;
    label: string;
    locked: boolean;
    tags: {[key: string]: string};
    type: string;
    value: string;
    vaultKeyReference: string;
}

export interface GetAppConfigurationKeysTimeouts {
    read?: string;
}

export interface GetAppConfigurationPrimaryReadKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface GetAppConfigurationPrimaryWriteKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface GetAppConfigurationReplica {
    endpoint: string;
    id: string;
    location: string;
    name: string;
}

export interface GetAppConfigurationSecondaryReadKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface GetAppConfigurationSecondaryWriteKey {
    connectionString: string;
    id: string;
    secret: string;
}

export interface GetAppConfigurationTimeouts {
    read?: string;
}

export interface GetAppServiceCertificateOrderCertificate {
    certificateName: string;
    keyVaultId: string;
    keyVaultSecretName: string;
    provisioningState: string;
}

export interface GetAppServiceCertificateOrderTimeouts {
    read?: string;
}

export interface GetAppServiceCertificateTimeouts {
    read?: string;
}

export interface GetAppServiceConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetAppServiceEnvironmentV3ClusterSetting {
    name: string;
    value: string;
}

export interface GetAppServiceEnvironmentV3InboundNetworkDependency {
    description: string;
    ipAddresses: string[];
    ports: string[];
}

export interface GetAppServiceEnvironmentV3Timeouts {
    read?: string;
}

export interface GetAppServicePlanSkus {
    capacity: number;
    size: string;
    tier: string;
}

export interface GetAppServicePlanTimeouts {
    read?: string;
}

export interface GetAppServiceSiteConfig {
    acrUseManagedIdentityCredentials: boolean;
    acrUserManagedIdentityClientId: string;
    alwaysOn: boolean;
    appCommandLine: string;
    cors: outputs.GetAppServiceSiteConfigCor[];
    defaultDocuments: string[];
    dotnetFrameworkVersion: string;
    ftpsState: string;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictions: outputs.GetAppServiceSiteConfigIpRestriction[];
    javaContainer: string;
    javaContainerVersion: string;
    javaVersion: string;
    linuxFxVersion: string;
    localMysqlEnabled: boolean;
    managedPipelineMode: string;
    minTlsVersion: string;
    numberOfWorkers: number;
    phpVersion: string;
    pythonVersion: string;
    remoteDebuggingEnabled: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictions: outputs.GetAppServiceSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorkerProcess: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    windowsFxVersion: string;
}

export interface GetAppServiceSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetAppServiceSiteConfigIpRestriction {
    action: string;
    headers: outputs.GetAppServiceSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetAppServiceSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetAppServiceSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.GetAppServiceSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetAppServiceSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetAppServiceSiteCredential {
    password: string;
    username: string;
}

export interface GetAppServiceSourceControl {
    branch: string;
    manualIntegration: boolean;
    repoUrl: string;
    rollbackEnabled: boolean;
    useMercurial: boolean;
}

export interface GetAppServiceTimeouts {
    read?: string;
}

export interface GetApplicationGatewayAuthenticationCertificate {
    id: string;
    name: string;
}

export interface GetApplicationGatewayAutoscaleConfiguration {
    maxCapacity: number;
    minCapacity: number;
}

export interface GetApplicationGatewayBackendAddressPool {
    fqdns: string[];
    id: string;
    ipAddresses: string[];
    name: string;
}

export interface GetApplicationGatewayBackendHttpSetting {
    affinityCookieName: string;
    authenticationCertificates: outputs.GetApplicationGatewayBackendHttpSettingAuthenticationCertificate[];
    connectionDrainings: outputs.GetApplicationGatewayBackendHttpSettingConnectionDraining[];
    cookieBasedAffinity: string;
    hostName: string;
    id: string;
    name: string;
    path: string;
    pickHostNameFromBackendAddress: boolean;
    port: number;
    probeId: string;
    probeName: string;
    protocol: string;
    requestTimeout: number;
    trustedRootCertificateNames: string[];
}

export interface GetApplicationGatewayBackendHttpSettingAuthenticationCertificate {
    id: string;
    name: string;
}

export interface GetApplicationGatewayBackendHttpSettingConnectionDraining {
    drainTimeoutSec: number;
    enabled: boolean;
}

export interface GetApplicationGatewayCustomErrorConfiguration {
    customErrorPageUrl: string;
    id: string;
    statusCode: string;
}

export interface GetApplicationGatewayFrontendIpConfiguration {
    id: string;
    name: string;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    privateLinkConfigurationId: string;
    privateLinkConfigurationName: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetApplicationGatewayFrontendPort {
    id: string;
    name: string;
    port: number;
}

export interface GetApplicationGatewayGatewayIpConfiguration {
    id: string;
    name: string;
    subnetId: string;
}

export interface GetApplicationGatewayGlobal {
    requestBufferingEnabled: boolean;
    responseBufferingEnabled: boolean;
}

export interface GetApplicationGatewayHttpListener {
    customErrorConfigurations: outputs.GetApplicationGatewayHttpListenerCustomErrorConfiguration[];
    firewallPolicyId: string;
    frontendIpConfigurationId: string;
    frontendIpConfigurationName: string;
    frontendPortId: string;
    frontendPortName: string;
    hostName: string;
    hostNames: string[];
    id: string;
    name: string;
    protocol: string;
    requireSni: boolean;
    sslCertificateId: string;
    sslCertificateName: string;
    sslProfileId: string;
    sslProfileName: string;
}

export interface GetApplicationGatewayHttpListenerCustomErrorConfiguration {
    customErrorPageUrl: string;
    id: string;
    statusCode: string;
}

export interface GetApplicationGatewayIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetApplicationGatewayPrivateEndpointConnection {
    id: string;
    name: string;
}

export interface GetApplicationGatewayPrivateLinkConfiguration {
    id: string;
    ipConfigurations: outputs.GetApplicationGatewayPrivateLinkConfigurationIpConfiguration[];
    name: string;
}

export interface GetApplicationGatewayPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary: boolean;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    subnetId: string;
}

export interface GetApplicationGatewayProbe {
    host: string;
    id: string;
    interval: number;
    matches: outputs.GetApplicationGatewayProbeMatch[];
    minimumServers: number;
    name: string;
    path: string;
    pickHostNameFromBackendHttpSettings: boolean;
    port: number;
    protocol: string;
    timeout: number;
    unhealthyThreshold: number;
}

export interface GetApplicationGatewayProbeMatch {
    body: string;
    statusCodes: string[];
}

export interface GetApplicationGatewayRedirectConfiguration {
    id: string;
    includePath: boolean;
    includeQueryString: boolean;
    name: string;
    redirectType: string;
    targetListenerId: string;
    targetListenerName: string;
    targetUrl: string;
}

export interface GetApplicationGatewayRequestRoutingRule {
    backendAddressPoolId: string;
    backendAddressPoolName: string;
    backendHttpSettingsId: string;
    backendHttpSettingsName: string;
    httpListenerId: string;
    httpListenerName: string;
    id: string;
    name: string;
    priority: number;
    redirectConfigurationId: string;
    redirectConfigurationName: string;
    rewriteRuleSetId: string;
    rewriteRuleSetName: string;
    ruleType: string;
    urlPathMapId: string;
    urlPathMapName: string;
}

export interface GetApplicationGatewayRewriteRuleSet {
    id: string;
    name: string;
    rewriteRules: outputs.GetApplicationGatewayRewriteRuleSetRewriteRule[];
}

export interface GetApplicationGatewayRewriteRuleSetRewriteRule {
    conditions: outputs.GetApplicationGatewayRewriteRuleSetRewriteRuleCondition[];
    name: string;
    requestHeaderConfigurations: outputs.GetApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration[];
    responseHeaderConfigurations: outputs.GetApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration[];
    ruleSequence: number;
    urls: outputs.GetApplicationGatewayRewriteRuleSetRewriteRuleUrl[];
}

export interface GetApplicationGatewayRewriteRuleSetRewriteRuleCondition {
    ignoreCase: boolean;
    negate: boolean;
    pattern: string;
    variable: string;
}

export interface GetApplicationGatewayRewriteRuleSetRewriteRuleRequestHeaderConfiguration {
    headerName: string;
    headerValue: string;
}

export interface GetApplicationGatewayRewriteRuleSetRewriteRuleResponseHeaderConfiguration {
    headerName: string;
    headerValue: string;
}

export interface GetApplicationGatewayRewriteRuleSetRewriteRuleUrl {
    components: string;
    path: string;
    queryString: string;
    reroute: boolean;
}

export interface GetApplicationGatewaySkus {
    capacity: number;
    name: string;
    tier: string;
}

export interface GetApplicationGatewaySslCertificate {
    id: string;
    keyVaultSecretId: string;
    name: string;
    publicCertData: string;
}

export interface GetApplicationGatewaySslPolicy {
    cipherSuites: string[];
    disabledProtocols: string[];
    minProtocolVersion: string;
    policyName: string;
    policyType: string;
}

export interface GetApplicationGatewaySslProfile {
    id: string;
    name: string;
    sslPolicies: outputs.GetApplicationGatewaySslProfileSslPolicy[];
    trustedClientCertificateNames: string[];
    verifyClientCertificateIssuerDn: boolean;
    verifyClientCertificateRevocation: string;
}

export interface GetApplicationGatewaySslProfileSslPolicy {
    cipherSuites: string[];
    disabledProtocols: string[];
    minProtocolVersion: string;
    policyName: string;
    policyType: string;
}

export interface GetApplicationGatewayTimeouts {
    read?: string;
}

export interface GetApplicationGatewayTrustedClientCertificate {
    data: string;
    id: string;
    name: string;
}

export interface GetApplicationGatewayTrustedRootCertificate {
    id: string;
    keyVaultSecretId: string;
    name: string;
}

export interface GetApplicationGatewayUrlPathMap {
    defaultBackendAddressPoolId: string;
    defaultBackendAddressPoolName: string;
    defaultBackendHttpSettingsId: string;
    defaultBackendHttpSettingsName: string;
    defaultRedirectConfigurationId: string;
    defaultRedirectConfigurationName: string;
    defaultRewriteRuleSetId: string;
    defaultRewriteRuleSetName: string;
    id: string;
    name: string;
    pathRules: outputs.GetApplicationGatewayUrlPathMapPathRule[];
}

export interface GetApplicationGatewayUrlPathMapPathRule {
    backendAddressPoolId: string;
    backendAddressPoolName: string;
    backendHttpSettingsId: string;
    backendHttpSettingsName: string;
    firewallPolicyId: string;
    id: string;
    name: string;
    paths: string[];
    redirectConfigurationId: string;
    redirectConfigurationName: string;
    rewriteRuleSetId: string;
    rewriteRuleSetName: string;
}

export interface GetApplicationGatewayWafConfiguration {
    disabledRuleGroups: outputs.GetApplicationGatewayWafConfigurationDisabledRuleGroup[];
    enabled: boolean;
    exclusions: outputs.GetApplicationGatewayWafConfigurationExclusion[];
    fileUploadLimitMb: number;
    firewallMode: string;
    maxRequestBodySizeKb: number;
    requestBodyCheck: boolean;
    ruleSetType: string;
    ruleSetVersion: string;
}

export interface GetApplicationGatewayWafConfigurationDisabledRuleGroup {
    ruleGroupName: string;
    rules: number[];
}

export interface GetApplicationGatewayWafConfigurationExclusion {
    matchVariable: string;
    selector: string;
    selectorMatchOperator: string;
}

export interface GetApplicationInsightsTimeouts {
    read?: string;
}

export interface GetApplicationSecurityGroupTimeouts {
    read?: string;
}

export interface GetArcMachineAgent {
    extensionsAllowLists: outputs.GetArcMachineAgentExtensionsAllowList[];
    extensionsBlockLists: outputs.GetArcMachineAgentExtensionsBlockList[];
    extensionsEnabled: boolean;
    guestConfigurationEnabled: boolean;
    incomingConnectionsPorts: string[];
    proxyBypasses: string[];
    proxyUrl: string;
}

export interface GetArcMachineAgentExtensionsAllowList {
    publisher: string;
    type: string;
}

export interface GetArcMachineAgentExtensionsBlockList {
    publisher: string;
    type: string;
}

export interface GetArcMachineCloudMetadata {
    provider: string;
}

export interface GetArcMachineIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetArcMachineLocationData {
    city: string;
    countryOrRegion: string;
    district: string;
    name: string;
}

export interface GetArcMachineOsProfile {
    computerName: string;
    linuxes: outputs.GetArcMachineOsProfileLinux[];
    windows: outputs.GetArcMachineOsProfileWindow[];
}

export interface GetArcMachineOsProfileLinux {
    patches: outputs.GetArcMachineOsProfileLinuxPatch[];
}

export interface GetArcMachineOsProfileLinuxPatch {
    assessmentMode: string;
    patchMode: string;
}

export interface GetArcMachineOsProfileWindow {
    patches: outputs.GetArcMachineOsProfileWindowPatch[];
}

export interface GetArcMachineOsProfileWindowPatch {
    assessmentMode: string;
    patchMode: string;
}

export interface GetArcMachineServiceStatus {
    extensionServices: outputs.GetArcMachineServiceStatusExtensionService[];
    guestConfigurationServices: outputs.GetArcMachineServiceStatusGuestConfigurationService[];
}

export interface GetArcMachineServiceStatusExtensionService {
    startupType: string;
    status: string;
}

export interface GetArcMachineServiceStatusGuestConfigurationService {
    startupType: string;
    status: string;
}

export interface GetArcMachineTimeouts {
    read?: string;
}

export interface GetArcResourceBridgeApplianceIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetArcResourceBridgeApplianceTimeouts {
    read?: string;
}

export interface GetAttestationProviderTimeouts {
    read?: string;
}

export interface GetAutomationAccountIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetAutomationAccountPrivateEndpointConnection {
    id: string;
    name: string;
}

export interface GetAutomationAccountTimeouts {
    read?: string;
}

export interface GetAutomationRunbookTimeouts {
    read?: string;
}

export interface GetAutomationVariableBoolTimeouts {
    read?: string;
}

export interface GetAutomationVariableDatetimeTimeouts {
    read?: string;
}

export interface GetAutomationVariableIntTimeouts {
    read?: string;
}

export interface GetAutomationVariableObjectTimeouts {
    read?: string;
}

export interface GetAutomationVariableStringTimeouts {
    read?: string;
}

export interface GetAutomationVariablesBool {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: boolean;
}

export interface GetAutomationVariablesDatetime {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: string;
}

export interface GetAutomationVariablesEncrypted {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: string;
}

export interface GetAutomationVariablesInt {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: number;
}

export interface GetAutomationVariablesNull {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: string;
}

export interface GetAutomationVariablesObject {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: string;
}

export interface GetAutomationVariablesString {
    description: string;
    encrypted: boolean;
    id: string;
    name: string;
    value: string;
}

export interface GetAutomationVariablesTimeouts {
    read?: string;
}

export interface GetAvailabilitySetTimeouts {
    read?: string;
}

export interface GetBackupPolicyFileShareTimeouts {
    read?: string;
}

export interface GetBackupPolicyVmTimeouts {
    read?: string;
}

export interface GetBastionHostIpConfiguration {
    name: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetBastionHostTimeouts {
    read?: string;
}

export interface GetBatchAccountEncryption {
    keyVaultKeyId: string;
}

export interface GetBatchAccountKeyVaultReference {
    id: string;
    url: string;
}

export interface GetBatchAccountTimeouts {
    read?: string;
}

export interface GetBatchApplicationTimeouts {
    read?: string;
}

export interface GetBatchCertificateTimeouts {
    read?: string;
}

export interface GetBatchPoolAutoScale {
    evaluationInterval: string;
    formula: string;
}

export interface GetBatchPoolCertificate {
    id: string;
    storeLocation: string;
    storeName: string;
    visibilities: string[];
}

export interface GetBatchPoolContainerConfiguration {
    containerImageNames: string[];
    containerRegistries: outputs.GetBatchPoolContainerConfigurationContainerRegistry[];
    type: string;
}

export interface GetBatchPoolContainerConfigurationContainerRegistry {
    password: string;
    registryServer: string;
    userAssignedIdentityId: string;
    userName: string;
}

export interface GetBatchPoolDataDisk {
    caching: string;
    diskSizeGb: number;
    lun: number;
    storageAccountType: string;
}

export interface GetBatchPoolDiskEncryption {
    diskEncryptionTarget: string;
}

export interface GetBatchPoolExtension {
    autoUpgradeMinorVersion: boolean;
    name: string;
    protectedSettings: string;
    provisionAfterExtensions: string[];
    publisher: string;
    settingsJson: string;
    type: string;
    typeHandlerVersion: string;
}

export interface GetBatchPoolFixedScale {
    resizeTimeout: string;
    targetDedicatedNodes: number;
    targetLowPriorityNodes: number;
}

export interface GetBatchPoolMount {
    azureBlobFileSystems: outputs.GetBatchPoolMountAzureBlobFileSystem[];
    azureFileShares: outputs.GetBatchPoolMountAzureFileShare[];
    cifsMounts: outputs.GetBatchPoolMountCifsMount[];
    nfsMounts: outputs.GetBatchPoolMountNfsMount[];
}

export interface GetBatchPoolMountAzureBlobFileSystem {
    accountKey: string;
    accountName: string;
    blobfuseOptions: string;
    containerName: string;
    identityId: string;
    relativeMountPath: string;
    sasKey: string;
}

export interface GetBatchPoolMountAzureFileShare {
    accountKey: string;
    accountName: string;
    azureFileUrl: string;
    mountOptions: string;
    relativeMountPath: string;
}

export interface GetBatchPoolMountCifsMount {
    mountOptions: string;
    password: string;
    relativeMountPath: string;
    source: string;
    userName: string;
}

export interface GetBatchPoolMountNfsMount {
    mountOptions: string;
    relativeMountPath: string;
    source: string;
}

export interface GetBatchPoolNetworkConfiguration {
    acceleratedNetworkingEnabled: boolean;
    dynamicVnetAssignmentScope: string;
    endpointConfigurations: outputs.GetBatchPoolNetworkConfigurationEndpointConfiguration[];
    publicAddressProvisioningType: string;
    publicIps: string[];
    subnetId: string;
}

export interface GetBatchPoolNetworkConfigurationEndpointConfiguration {
    backendPort: number;
    frontendPortRange: string;
    name: string;
    networkSecurityGroupRules: outputs.GetBatchPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule[];
    protocol: string;
}

export interface GetBatchPoolNetworkConfigurationEndpointConfigurationNetworkSecurityGroupRule {
    access: string;
    priority: number;
    sourceAddressPrefix: string;
    sourcePortRanges: string[];
}

export interface GetBatchPoolNodePlacement {
    policy: string;
}

export interface GetBatchPoolStartTask {
    commandLine: string;
    commonEnvironmentProperties: {[key: string]: string};
    containers: outputs.GetBatchPoolStartTaskContainer[];
    resourceFiles: outputs.GetBatchPoolStartTaskResourceFile[];
    taskRetryMaximum: number;
    userIdentities: outputs.GetBatchPoolStartTaskUserIdentity[];
    waitForSuccess: boolean;
}

export interface GetBatchPoolStartTaskContainer {
    imageName: string;
    registries: outputs.GetBatchPoolStartTaskContainerRegistry[];
    runOptions: string;
    workingDirectory: string;
}

export interface GetBatchPoolStartTaskContainerRegistry {
    password: string;
    registryServer: string;
    userAssignedIdentityId: string;
    userName: string;
}

export interface GetBatchPoolStartTaskResourceFile {
    autoStorageContainerName: string;
    blobPrefix: string;
    fileMode: string;
    filePath: string;
    httpUrl: string;
    storageContainerUrl: string;
    userAssignedIdentityId: string;
}

export interface GetBatchPoolStartTaskUserIdentity {
    autoUsers: outputs.GetBatchPoolStartTaskUserIdentityAutoUser[];
    userName: string;
}

export interface GetBatchPoolStartTaskUserIdentityAutoUser {
    elevationLevel: string;
    scope: string;
}

export interface GetBatchPoolStorageImageReference {
    id: string;
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface GetBatchPoolTaskSchedulingPolicy {
    nodeFillType: string;
}

export interface GetBatchPoolTimeouts {
    read?: string;
}

export interface GetBatchPoolUserAccount {
    elevationLevel: string;
    linuxUserConfigurations: outputs.GetBatchPoolUserAccountLinuxUserConfiguration[];
    name: string;
    password: string;
    windowsUserConfigurations: outputs.GetBatchPoolUserAccountWindowsUserConfiguration[];
}

export interface GetBatchPoolUserAccountLinuxUserConfiguration {
    gid: number;
    sshPrivateKey: string;
    uid: number;
}

export interface GetBatchPoolUserAccountWindowsUserConfiguration {
    loginMode: string;
}

export interface GetBatchPoolWindow {
    enableAutomaticUpdates: boolean;
}

export interface GetBillingEnrollmentAccountScopeTimeouts {
    read?: string;
}

export interface GetBillingMcaAccountScopeTimeouts {
    read?: string;
}

export interface GetBillingMpaAccountScopeTimeouts {
    read?: string;
}

export interface GetBlueprintDefinitionTimeouts {
    read?: string;
}

export interface GetBlueprintPublishedVersionTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorCustomDomainTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorCustomDomainTl {
    cdnFrontdoorSecretId: string;
    certificateType: string;
    minimumTlsVersion: string;
}

export interface GetCdnFrontdoorEndpointTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorFirewallPolicyTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorOriginGroupHealthProbe {
    intervalInSeconds: number;
    path: string;
    protocol: string;
    requestType: string;
}

export interface GetCdnFrontdoorOriginGroupLoadBalancing {
    additionalLatencyInMilliseconds: number;
    sampleSize: number;
    successfulSamplesRequired: number;
}

export interface GetCdnFrontdoorOriginGroupTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorProfileTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorRuleSetTimeouts {
    read?: string;
}

export interface GetCdnFrontdoorSecretSecret {
    customerCertificates: outputs.GetCdnFrontdoorSecretSecretCustomerCertificate[];
}

export interface GetCdnFrontdoorSecretSecretCustomerCertificate {
    expirationDate: string;
    keyVaultCertificateId: string;
    subjectAlternativeNames: string[];
}

export interface GetCdnFrontdoorSecretTimeouts {
    read?: string;
}

export interface GetCdnProfileTimeouts {
    read?: string;
}

export interface GetClientConfigTimeouts {
    read?: string;
}

export interface GetCognitiveAccountIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetCognitiveAccountTimeouts {
    read?: string;
}

export interface GetCommunicationServiceTimeouts {
    read?: string;
}

export interface GetConfidentialLedgerAzureadBasedServicePrincipal {
    ledgerRoleName: string;
    principalId: string;
    tenantId: string;
}

export interface GetConfidentialLedgerCertificateBasedSecurityPrincipal {
    ledgerRoleName: string;
    pemPublicKey: string;
}

export interface GetConfidentialLedgerTimeouts {
    read?: string;
}

export interface GetConsumptionBudgetResourceGroupFilter {
    dimensions: outputs.GetConsumptionBudgetResourceGroupFilterDimension[];
    nots: outputs.GetConsumptionBudgetResourceGroupFilterNot[];
    tags: outputs.GetConsumptionBudgetResourceGroupFilterTag[];
}

export interface GetConsumptionBudgetResourceGroupFilterDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetResourceGroupFilterNot {
    dimensions: outputs.GetConsumptionBudgetResourceGroupFilterNotDimension[];
    tags: outputs.GetConsumptionBudgetResourceGroupFilterNotTag[];
}

export interface GetConsumptionBudgetResourceGroupFilterNotDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetResourceGroupFilterNotTag {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetResourceGroupFilterTag {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetResourceGroupNotification {
    contactEmails: string[];
    contactGroups: string[];
    contactRoles: string[];
    enabled: boolean;
    operator: string;
    threshold: number;
    thresholdType: string;
}

export interface GetConsumptionBudgetResourceGroupTimePeriod {
    endDate: string;
    startDate: string;
}

export interface GetConsumptionBudgetResourceGroupTimeouts {
    read?: string;
}

export interface GetConsumptionBudgetSubscriptionFilter {
    dimensions: outputs.GetConsumptionBudgetSubscriptionFilterDimension[];
    nots: outputs.GetConsumptionBudgetSubscriptionFilterNot[];
    tags: outputs.GetConsumptionBudgetSubscriptionFilterTag[];
}

export interface GetConsumptionBudgetSubscriptionFilterDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetSubscriptionFilterNot {
    dimensions: outputs.GetConsumptionBudgetSubscriptionFilterNotDimension[];
    tags: outputs.GetConsumptionBudgetSubscriptionFilterNotTag[];
}

export interface GetConsumptionBudgetSubscriptionFilterNotDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetSubscriptionFilterNotTag {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetSubscriptionFilterTag {
    name: string;
    operator: string;
    values: string[];
}

export interface GetConsumptionBudgetSubscriptionNotification {
    contactEmails: string[];
    contactGroups: string[];
    contactRoles: string[];
    enabled: boolean;
    operator: string;
    threshold: number;
    thresholdType: string;
}

export interface GetConsumptionBudgetSubscriptionTimePeriod {
    endDate: string;
    startDate: string;
}

export interface GetConsumptionBudgetSubscriptionTimeouts {
    read?: string;
}

export interface GetContainerAppDapr {
    appId: string;
    appPort: number;
    appProtocol: string;
}

export interface GetContainerAppEnvironmentCertificateTimeouts {
    read?: string;
}

export interface GetContainerAppEnvironmentTimeouts {
    read?: string;
}

export interface GetContainerAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetContainerAppIngress {
    allowInsecureConnections: boolean;
    customDomains: outputs.GetContainerAppIngressCustomDomain[];
    exposedPort: number;
    externalEnabled: boolean;
    fqdn: string;
    ipSecurityRestrictions: outputs.GetContainerAppIngressIpSecurityRestriction[];
    targetPort: number;
    trafficWeights: outputs.GetContainerAppIngressTrafficWeight[];
    transport: string;
}

export interface GetContainerAppIngressCustomDomain {
    certificateBindingType: string;
    certificateId: string;
    name: string;
}

export interface GetContainerAppIngressIpSecurityRestriction {
    action: string;
    description: string;
    ipAddressRange: string;
    name: string;
}

export interface GetContainerAppIngressTrafficWeight {
    label: string;
    latestRevision: boolean;
    percentage: number;
    revisionSuffix: string;
}

export interface GetContainerAppRegistry {
    identity: string;
    passwordSecretName: string;
    server: string;
    username: string;
}

export interface GetContainerAppSecret {
    identity: string;
    keyVaultSecretId: string;
    name: string;
    value: string;
}

export interface GetContainerAppTemplate {
    azureQueueScaleRules: outputs.GetContainerAppTemplateAzureQueueScaleRule[];
    containers: outputs.GetContainerAppTemplateContainer[];
    customScaleRules: outputs.GetContainerAppTemplateCustomScaleRule[];
    httpScaleRules: outputs.GetContainerAppTemplateHttpScaleRule[];
    initContainers: outputs.GetContainerAppTemplateInitContainer[];
    maxReplicas: number;
    minReplicas: number;
    revisionSuffix: string;
    tcpScaleRules: outputs.GetContainerAppTemplateTcpScaleRule[];
    volumes: outputs.GetContainerAppTemplateVolume[];
}

export interface GetContainerAppTemplateAzureQueueScaleRule {
    authentications: outputs.GetContainerAppTemplateAzureQueueScaleRuleAuthentication[];
    name: string;
    queueLength: number;
    queueName: string;
}

export interface GetContainerAppTemplateAzureQueueScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface GetContainerAppTemplateContainer {
    args: string[];
    commands: string[];
    cpu: number;
    envs: outputs.GetContainerAppTemplateContainerEnv[];
    ephemeralStorage: string;
    image: string;
    livenessProbes: outputs.GetContainerAppTemplateContainerLivenessProbe[];
    memory: string;
    name: string;
    readinessProbes: outputs.GetContainerAppTemplateContainerReadinessProbe[];
    startupProbes: outputs.GetContainerAppTemplateContainerStartupProbe[];
    volumeMounts: outputs.GetContainerAppTemplateContainerVolumeMount[];
}

export interface GetContainerAppTemplateContainerEnv {
    name: string;
    secretName: string;
    value: string;
}

export interface GetContainerAppTemplateContainerLivenessProbe {
    failureCountThreshold: number;
    headers: outputs.GetContainerAppTemplateContainerLivenessProbeHeader[];
    host: string;
    initialDelay: number;
    intervalSeconds: number;
    path: string;
    port: number;
    terminationGracePeriodSeconds: number;
    timeout: number;
    transport: string;
}

export interface GetContainerAppTemplateContainerLivenessProbeHeader {
    name: string;
    value: string;
}

export interface GetContainerAppTemplateContainerReadinessProbe {
    failureCountThreshold: number;
    headers: outputs.GetContainerAppTemplateContainerReadinessProbeHeader[];
    host: string;
    intervalSeconds: number;
    path: string;
    port: number;
    successCountThreshold: number;
    timeout: number;
    transport: string;
}

export interface GetContainerAppTemplateContainerReadinessProbeHeader {
    name: string;
    value: string;
}

export interface GetContainerAppTemplateContainerStartupProbe {
    failureCountThreshold: number;
    headers: outputs.GetContainerAppTemplateContainerStartupProbeHeader[];
    host: string;
    intervalSeconds: number;
    path: string;
    port: number;
    terminationGracePeriodSeconds: number;
    timeout: number;
    transport: string;
}

export interface GetContainerAppTemplateContainerStartupProbeHeader {
    name: string;
    value: string;
}

export interface GetContainerAppTemplateContainerVolumeMount {
    name: string;
    path: string;
}

export interface GetContainerAppTemplateCustomScaleRule {
    authentications: outputs.GetContainerAppTemplateCustomScaleRuleAuthentication[];
    customRuleType: string;
    metadata: {[key: string]: string};
    name: string;
}

export interface GetContainerAppTemplateCustomScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface GetContainerAppTemplateHttpScaleRule {
    authentications: outputs.GetContainerAppTemplateHttpScaleRuleAuthentication[];
    concurrentRequests: string;
    name: string;
}

export interface GetContainerAppTemplateHttpScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface GetContainerAppTemplateInitContainer {
    args: string[];
    commands: string[];
    cpu: number;
    envs: outputs.GetContainerAppTemplateInitContainerEnv[];
    ephemeralStorage: string;
    image: string;
    memory: string;
    name: string;
    volumeMounts: outputs.GetContainerAppTemplateInitContainerVolumeMount[];
}

export interface GetContainerAppTemplateInitContainerEnv {
    name: string;
    secretName: string;
    value: string;
}

export interface GetContainerAppTemplateInitContainerVolumeMount {
    name: string;
    path: string;
}

export interface GetContainerAppTemplateTcpScaleRule {
    authentications: outputs.GetContainerAppTemplateTcpScaleRuleAuthentication[];
    concurrentRequests: string;
    name: string;
}

export interface GetContainerAppTemplateTcpScaleRuleAuthentication {
    secretName: string;
    triggerParameter: string;
}

export interface GetContainerAppTemplateVolume {
    name: string;
    storageName: string;
    storageType: string;
}

export interface GetContainerAppTimeouts {
    read?: string;
}

export interface GetContainerGroupIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetContainerGroupTimeouts {
    read?: string;
}

export interface GetContainerRegistryCacheRuleTimeouts {
    read?: string;
}

export interface GetContainerRegistryScopeMapTimeouts {
    read?: string;
}

export interface GetContainerRegistryTimeouts {
    read?: string;
}

export interface GetContainerRegistryTokenTimeouts {
    read?: string;
}

export interface GetCosmosdbAccountCapability {
    name: string;
}

export interface GetCosmosdbAccountConsistencyPolicy {
    consistencyLevel: string;
    maxIntervalInSeconds: number;
    maxStalenessPrefix: number;
}

export interface GetCosmosdbAccountGeoLocation {
    failoverPriority: number;
    id: string;
    location: string;
}

export interface GetCosmosdbAccountTimeouts {
    read?: string;
}

export interface GetCosmosdbAccountVirtualNetworkRule {
    id: string;
}

export interface GetCosmosdbMongoDatabaseTimeouts {
    read?: string;
}

export interface GetCosmosdbRestorableDatabaseAccountsAccount {
    apiType: string;
    creationTime: string;
    deletionTime: string;
    id: string;
    restorableLocations: outputs.GetCosmosdbRestorableDatabaseAccountsAccountRestorableLocation[];
}

export interface GetCosmosdbRestorableDatabaseAccountsAccountRestorableLocation {
    creationTime: string;
    deletionTime: string;
    location: string;
    regionalDatabaseAccountInstanceId: string;
}

export interface GetCosmosdbRestorableDatabaseAccountsTimeouts {
    read?: string;
}

export interface GetCosmosdbSqlDatabaseAutoscaleSetting {
    maxThroughput: number;
}

export interface GetCosmosdbSqlDatabaseTimeouts {
    read?: string;
}

export interface GetCosmosdbSqlRoleDefinitionPermission {
    dataActions: string[];
}

export interface GetCosmosdbSqlRoleDefinitionTimeouts {
    read?: string;
}

export interface GetDashboardGrafanaAzureMonitorWorkspaceIntegration {
    resourceId: string;
}

export interface GetDashboardGrafanaIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDashboardGrafanaTimeouts {
    read?: string;
}

export interface GetDataFactoryGithubConfiguration {
    accountName: string;
    branchName: string;
    gitUrl: string;
    repositoryName: string;
    rootFolder: string;
}

export interface GetDataFactoryIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDataFactoryTimeouts {
    read?: string;
}

export interface GetDataFactoryTriggerScheduleSchedule {
    daysOfMonths: number[];
    daysOfWeeks: string[];
    hours: number[];
    minutes: number[];
    monthlies: outputs.GetDataFactoryTriggerScheduleScheduleMonthly[];
}

export interface GetDataFactoryTriggerScheduleScheduleMonthly {
    week: number;
    weekday: string;
}

export interface GetDataFactoryTriggerScheduleTimeouts {
    read?: string;
}

export interface GetDataFactoryTriggerSchedulesTimeouts {
    read?: string;
}

export interface GetDataFactoryVstsConfiguration {
    accountName: string;
    branchName: string;
    projectName: string;
    repositoryName: string;
    rootFolder: string;
    tenantId: string;
}

export interface GetDataProtectionBackupVaultIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDataProtectionBackupVaultTimeouts {
    read?: string;
}

export interface GetDataShareAccountIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDataShareAccountTimeouts {
    read?: string;
}

export interface GetDataShareDatasetBlobStorageStorageAccount {
    name: string;
    resourceGroupName: string;
    subscriptionId: string;
}

export interface GetDataShareDatasetBlobStorageTimeouts {
    read?: string;
}

export interface GetDataShareDatasetDataLakeGen2Timeouts {
    read?: string;
}

export interface GetDataShareDatasetKustoClusterTimeouts {
    read?: string;
}

export interface GetDataShareDatasetKustoDatabaseTimeouts {
    read?: string;
}

export interface GetDataShareSnapshotSchedule {
    name: string;
    recurrence: string;
    startTime: string;
}

export interface GetDataShareTimeouts {
    read?: string;
}

export interface GetDatabaseMigrationProjectTimeouts {
    read?: string;
}

export interface GetDatabaseMigrationServiceTimeouts {
    read?: string;
}

export interface GetDataboxEdgeDeviceDeviceProperty {
    capacity: number;
    configuredRoleTypes: string[];
    culture: string;
    hcsVersion: string;
    model: string;
    nodeCount: number;
    serialNumber: string;
    softwareVersion: string;
    status: string;
    timeZone: string;
    type: string;
}

export interface GetDataboxEdgeDeviceTimeouts {
    read?: string;
}

export interface GetDatabricksAccessConnectorIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDatabricksAccessConnectorTimeouts {
    read?: string;
}

export interface GetDatabricksWorkspaceManagedDiskIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDatabricksWorkspacePrivateEndpointConnectionConnection {
    actionRequired: string;
    description: string;
    name: string;
    status: string;
    workspacePrivateEndpointId: string;
}

export interface GetDatabricksWorkspacePrivateEndpointConnectionTimeouts {
    read?: string;
}

export interface GetDatabricksWorkspaceStorageAccountIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDatabricksWorkspaceTimeouts {
    read?: string;
}

export interface GetDedicatedHostGroupTimeouts {
    read?: string;
}

export interface GetDedicatedHostTimeouts {
    read?: string;
}

export interface GetDevTestLabTimeouts {
    read?: string;
}

export interface GetDevTestVirtualNetworkAllowedSubnet {
    allowPublicIp: string;
    labSubnetName: string;
    resourceId: string;
}

export interface GetDevTestVirtualNetworkSubnetOverride {
    labSubnetName: string;
    resourceId: string;
    useInVmCreationPermission: string;
    usePublicIpAddressPermission: string;
    virtualNetworkPoolName: string;
}

export interface GetDevTestVirtualNetworkTimeouts {
    read?: string;
}

export interface GetDigitalTwinsInstanceTimeouts {
    read?: string;
}

export interface GetDiskAccessTimeouts {
    read?: string;
}

export interface GetDiskEncryptionSetIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetDiskEncryptionSetTimeouts {
    read?: string;
}

export interface GetDnsARecordTimeouts {
    read?: string;
}

export interface GetDnsAaaaRecordTimeouts {
    read?: string;
}

export interface GetDnsCaaRecordRecord {
    flags: number;
    tag: string;
    value: string;
}

export interface GetDnsCaaRecordTimeouts {
    read?: string;
}

export interface GetDnsCnameRecordTimeouts {
    read?: string;
}

export interface GetDnsMxRecordRecord {
    exchange: string;
    preference: string;
}

export interface GetDnsMxRecordTimeouts {
    read?: string;
}

export interface GetDnsNsRecordTimeouts {
    read?: string;
}

export interface GetDnsPtrRecordTimeouts {
    read?: string;
}

export interface GetDnsSoaRecordTimeouts {
    read?: string;
}

export interface GetDnsSrvRecordRecord {
    port: number;
    priority: number;
    target: string;
    weight: number;
}

export interface GetDnsSrvRecordTimeouts {
    read?: string;
}

export interface GetDnsTxtRecordRecord {
    value: string;
}

export interface GetDnsTxtRecordTimeouts {
    read?: string;
}

export interface GetDnsZoneTimeouts {
    read?: string;
}

export interface GetElasticCloudElasticsearchLog {
    filteringTags: outputs.GetElasticCloudElasticsearchLogFilteringTag[];
    sendActivityLogs: boolean;
    sendAzureadLogs: boolean;
    sendSubscriptionLogs: boolean;
}

export interface GetElasticCloudElasticsearchLogFilteringTag {
    action: string;
    name: string;
    value: string;
}

export interface GetElasticCloudElasticsearchTimeouts {
    read?: string;
}

export interface GetElasticSanSkus {
    name: string;
    tier: string;
}

export interface GetElasticSanTimeouts {
    read?: string;
}

export interface GetElasticSanVolumeGroupEncryption {
    currentVersionedKeyExpirationTimestamp: string;
    currentVersionedKeyId: string;
    keyVaultKeyId: string;
    lastKeyRotationTimestamp: string;
    userAssignedIdentityId: string;
}

export interface GetElasticSanVolumeGroupIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetElasticSanVolumeGroupNetworkRule {
    action: string;
    subnetId: string;
}

export interface GetElasticSanVolumeGroupTimeouts {
    read?: string;
}

export interface GetElasticSanVolumeSnapshotTimeouts {
    read?: string;
}

export interface GetEventgridDomainIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetEventgridDomainInboundIpRule {
    action: string;
    ipMask: string;
}

export interface GetEventgridDomainInputMappingDefaultValue {
    dataVersion: string;
    eventType: string;
    subject: string;
}

export interface GetEventgridDomainInputMappingField {
    dataVersion: string;
    eventTime: string;
    eventType: string;
    id: string;
    subject: string;
    topic: string;
}

export interface GetEventgridDomainTimeouts {
    read?: string;
}

export interface GetEventgridDomainTopicTimeouts {
    read?: string;
}

export interface GetEventgridSystemTopicIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetEventgridSystemTopicTimeouts {
    read?: string;
}

export interface GetEventgridTopicTimeouts {
    read?: string;
}

export interface GetEventhubAuthorizationRuleTimeouts {
    read?: string;
}

export interface GetEventhubClusterTimeouts {
    read?: string;
}

export interface GetEventhubConsumerGroupTimeouts {
    read?: string;
}

export interface GetEventhubNamespaceAuthorizationRuleTimeouts {
    read?: string;
}

export interface GetEventhubNamespaceTimeouts {
    read?: string;
}

export interface GetEventhubSasTimeouts {
    read?: string;
}

export interface GetEventhubTimeouts {
    read?: string;
}

export interface GetExpressRouteCircuitPeering {
    azureAsn: number;
    peerAsn: number;
    peeringType: string;
    primaryPeerAddressPrefix: string;
    secondaryPeerAddressPrefix: string;
    sharedKey: string;
    vlanId: number;
}

export interface GetExpressRouteCircuitPeeringTimeouts {
    read?: string;
}

export interface GetExpressRouteCircuitServiceProviderProperty {
    bandwidthInMbps: number;
    peeringLocation: string;
    serviceProviderName: string;
}

export interface GetExpressRouteCircuitSkus {
    family: string;
    tier: string;
}

export interface GetExpressRouteCircuitTimeouts {
    read?: string;
}

export interface GetExtendedLocationsTimeouts {
    read?: string;
}

export interface GetFirewallIpConfiguration {
    name: string;
    privateIpAddress: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetFirewallManagementIpConfiguration {
    name: string;
    privateIpAddress: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetFirewallPolicyDn {
    networkRuleFqdnEnabled: boolean;
    proxyEnabled: boolean;
    servers: string[];
}

export interface GetFirewallPolicyThreatIntelligenceAllowlist {
    fqdns: string[];
    ipAddresses: string[];
}

export interface GetFirewallPolicyTimeouts {
    read?: string;
}

export interface GetFirewallTimeouts {
    read?: string;
}

export interface GetFirewallVirtualHub {
    privateIpAddress: string;
    publicIpAddresses: string[];
    publicIpCount: number;
    virtualHubId: string;
}

export interface GetFunctionAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetFunctionAppHostKeysTimeouts {
    read?: string;
}

export interface GetFunctionAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetFunctionAppSiteConfig {
    alwaysOn: boolean;
    appScaleLimit: number;
    autoSwapSlotName: string;
    cors: outputs.GetFunctionAppSiteConfigCor[];
    dotnetFrameworkVersion: string;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictions: outputs.GetFunctionAppSiteConfigIpRestriction[];
    javaVersion: string;
    linuxFxVersion: string;
    minTlsVersion: string;
    preWarmedInstanceCount: number;
    runtimeScaleMonitoringEnabled: boolean;
    scmIpRestrictions: outputs.GetFunctionAppSiteConfigScmIpRestriction[];
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorkerProcess: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
}

export interface GetFunctionAppSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetFunctionAppSiteConfigIpRestriction {
    action: string;
    headers: outputs.GetFunctionAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetFunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetFunctionAppSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.GetFunctionAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetFunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetFunctionAppSiteCredential {
    password: string;
    username: string;
}

export interface GetFunctionAppSourceControl {
    branch: string;
    manualIntegration: boolean;
    repoUrl: string;
    rollbackEnabled: boolean;
    useMercurial: boolean;
}

export interface GetFunctionAppTimeouts {
    read?: string;
}

export interface GetHdinsightClusterGateway {
    enabled: boolean;
    password: string;
    username: string;
}

export interface GetHdinsightClusterTimeouts {
    read?: string;
}

export interface GetHealthcareDicomServiceAuthentication {
    audiences: string[];
    authority: string;
}

export interface GetHealthcareDicomServiceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetHealthcareDicomServicePrivateEndpoint {
    id: string;
    name: string;
}

export interface GetHealthcareDicomServiceTimeouts {
    read?: string;
}

export interface GetHealthcareFhirServiceAuthentication {
    audience: string;
    authority: string;
    smartProxyEnabled: boolean;
}

export interface GetHealthcareFhirServiceCor {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    credentialsAllowed: boolean;
    maxAgeInSeconds: number;
}

export interface GetHealthcareFhirServiceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetHealthcareFhirServiceTimeouts {
    read?: string;
}

export interface GetHealthcareMedtechServiceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetHealthcareMedtechServiceTimeouts {
    read?: string;
}

export interface GetHealthcareServiceAuthenticationConfiguration {
    audience: string;
    authority: string;
    smartProxyEnabled: boolean;
}

export interface GetHealthcareServiceCorsConfiguration {
    allowCredentials: boolean;
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    maxAgeInSeconds: number;
}

export interface GetHealthcareServiceTimeouts {
    read?: string;
}

export interface GetHealthcareWorkspaceTimeouts {
    read?: string;
}

export interface GetImageDataDisk {
    blobUri: string;
    caching: string;
    lun: number;
    managedDiskId: string;
    sizeGb: number;
}

export interface GetImageOsDisk {
    blobUri: string;
    caching: string;
    managedDiskId: string;
    osState: string;
    osType: string;
    sizeGb: number;
}

export interface GetImageTimeouts {
    read?: string;
}

export interface GetImagesImage {
    dataDisks: outputs.GetImagesImageDataDisk[];
    location: string;
    name: string;
    osDisks: outputs.GetImagesImageOsDisk[];
    tags: {[key: string]: string};
    zoneResilient: boolean;
}

export interface GetImagesImageDataDisk {
    blobUri: string;
    caching: string;
    lun: number;
    managedDiskId: string;
    sizeGb: number;
}

export interface GetImagesImageOsDisk {
    blobUri: string;
    caching: string;
    diskEncryptionSetId: string;
    managedDiskId: string;
    osState: string;
    osType: string;
    sizeGb: number;
}

export interface GetImagesTimeouts {
    read?: string;
}

export interface GetIothubDpsSharedAccessPolicyTimeouts {
    read?: string;
}

export interface GetIothubDpsTimeouts {
    read?: string;
}

export interface GetIothubIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetIothubSharedAccessPolicyTimeouts {
    read?: string;
}

export interface GetIothubTimeouts {
    read?: string;
}

export interface GetIpGroupTimeouts {
    read?: string;
}

export interface GetIpGroupsTimeouts {
    read?: string;
}

export interface GetKeyVaultAccessPolicy {
    applicationId: string;
    certificatePermissions: string[];
    keyPermissions: string[];
    objectId: string;
    secretPermissions: string[];
    storagePermissions: string[];
    tenantId: string;
}

export interface GetKeyVaultAccessPolicyTimeouts {
    read?: string;
}

export interface GetKeyVaultCertificateCertificatePolicy {
    issuerParameters: outputs.GetKeyVaultCertificateCertificatePolicyIssuerParameter[];
    keyProperties: outputs.GetKeyVaultCertificateCertificatePolicyKeyProperty[];
    lifetimeActions: outputs.GetKeyVaultCertificateCertificatePolicyLifetimeAction[];
    secretProperties: outputs.GetKeyVaultCertificateCertificatePolicySecretProperty[];
    x509CertificateProperties: outputs.GetKeyVaultCertificateCertificatePolicyX509CertificateProperty[];
}

export interface GetKeyVaultCertificateCertificatePolicyIssuerParameter {
    name: string;
}

export interface GetKeyVaultCertificateCertificatePolicyKeyProperty {
    curve: string;
    exportable: boolean;
    keySize: number;
    keyType: string;
    reuseKey: boolean;
}

export interface GetKeyVaultCertificateCertificatePolicyLifetimeAction {
    actions: outputs.GetKeyVaultCertificateCertificatePolicyLifetimeActionAction[];
    triggers: outputs.GetKeyVaultCertificateCertificatePolicyLifetimeActionTrigger[];
}

export interface GetKeyVaultCertificateCertificatePolicyLifetimeActionAction {
    actionType: string;
}

export interface GetKeyVaultCertificateCertificatePolicyLifetimeActionTrigger {
    daysBeforeExpiry: number;
    lifetimePercentage: number;
}

export interface GetKeyVaultCertificateCertificatePolicySecretProperty {
    contentType: string;
}

export interface GetKeyVaultCertificateCertificatePolicyX509CertificateProperty {
    extendedKeyUsages: string[];
    keyUsages: string[];
    subject: string;
    subjectAlternativeNames: outputs.GetKeyVaultCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName[];
    validityInMonths: number;
}

export interface GetKeyVaultCertificateCertificatePolicyX509CertificatePropertySubjectAlternativeName {
    dnsNames: string[];
    emails: string[];
    upns: string[];
}

export interface GetKeyVaultCertificateDataTimeouts {
    read?: string;
}

export interface GetKeyVaultCertificateIssuerAdmin {
    emailAddress: string;
    firstName: string;
    lastName: string;
    phone: string;
}

export interface GetKeyVaultCertificateIssuerTimeouts {
    read?: string;
}

export interface GetKeyVaultCertificateTimeouts {
    read?: string;
}

export interface GetKeyVaultCertificatesCertificate {
    enabled: boolean;
    id: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetKeyVaultCertificatesTimeouts {
    read?: string;
}

export interface GetKeyVaultEncryptedValueTimeouts {
    read?: string;
}

export interface GetKeyVaultKeyTimeouts {
    read?: string;
}

export interface GetKeyVaultManagedHardwareSecurityModuleRoleDefinitionPermission {
    actions: string[];
    dataActions: string[];
    notActions: string[];
    notDataActions: string[];
}

export interface GetKeyVaultManagedHardwareSecurityModuleRoleDefinitionTimeouts {
    read?: string;
}

export interface GetKeyVaultManagedHardwareSecurityModuleTimeouts {
    read?: string;
}

export interface GetKeyVaultNetworkAcl {
    bypass: string;
    defaultAction: string;
    ipRules: string[];
    virtualNetworkSubnetIds: string[];
}

export interface GetKeyVaultSecretTimeouts {
    read?: string;
}

export interface GetKeyVaultSecretsSecret {
    enabled: boolean;
    id: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetKeyVaultSecretsTimeouts {
    read?: string;
}

export interface GetKeyVaultTimeouts {
    read?: string;
}

export interface GetKubernetesClusterAciConnectorLinux {
    subnetName: string;
}

export interface GetKubernetesClusterAgentPoolProfile {
    autoScalingEnabled: boolean;
    count: number;
    maxCount: number;
    maxPods: number;
    minCount: number;
    name: string;
    nodeLabels: {[key: string]: string};
    nodePublicIpEnabled: boolean;
    nodePublicIpPrefixId: string;
    nodeTaints: string[];
    orchestratorVersion: string;
    osDiskSizeGb: number;
    osType: string;
    tags: {[key: string]: string};
    type: string;
    upgradeSettings: outputs.GetKubernetesClusterAgentPoolProfileUpgradeSetting[];
    vmSize: string;
    vnetSubnetId: string;
    zones: string[];
}

export interface GetKubernetesClusterAgentPoolProfileUpgradeSetting {
    drainTimeoutInMinutes: number;
    maxSurge: string;
    nodeSoakDurationInMinutes: number;
}

export interface GetKubernetesClusterAzureActiveDirectoryRoleBasedAccessControl {
    adminGroupObjectIds: string[];
    azureRbacEnabled: boolean;
    tenantId: string;
}

export interface GetKubernetesClusterIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetKubernetesClusterIngressApplicationGateway {
    effectiveGatewayId: string;
    gatewayId: string;
    gatewayName: string;
    ingressApplicationGatewayIdentities: outputs.GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity[];
    subnetCidr: string;
    subnetId: string;
}

export interface GetKubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface GetKubernetesClusterKeyManagementService {
    keyVaultKeyId: string;
    keyVaultNetworkAccess: string;
}

export interface GetKubernetesClusterKeyVaultSecretsProvider {
    secretIdentities: outputs.GetKubernetesClusterKeyVaultSecretsProviderSecretIdentity[];
    secretRotationEnabled: boolean;
    secretRotationInterval: string;
}

export interface GetKubernetesClusterKeyVaultSecretsProviderSecretIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface GetKubernetesClusterKubeAdminConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    host: string;
    password: string;
    username: string;
}

export interface GetKubernetesClusterKubeConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    host: string;
    password: string;
    username: string;
}

export interface GetKubernetesClusterKubeletIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface GetKubernetesClusterLinuxProfile {
    adminUsername: string;
    sshKeys: outputs.GetKubernetesClusterLinuxProfileSshKey[];
}

export interface GetKubernetesClusterLinuxProfileSshKey {
    keyData: string;
}

export interface GetKubernetesClusterMicrosoftDefender {
    logAnalyticsWorkspaceId: string;
}

export interface GetKubernetesClusterNetworkProfile {
    dnsServiceIp: string;
    dockerBridgeCidr: string;
    loadBalancerSku: string;
    networkPlugin: string;
    networkPolicy: string;
    podCidr: string;
    serviceCidr: string;
}

export interface GetKubernetesClusterNodePoolTimeouts {
    read?: string;
}

export interface GetKubernetesClusterNodePoolUpgradeSetting {
    drainTimeoutInMinutes: number;
    maxSurge: string;
    nodeSoakDurationInMinutes: number;
}

export interface GetKubernetesClusterOmsAgent {
    logAnalyticsWorkspaceId: string;
    msiAuthForMonitoringEnabled: boolean;
    omsAgentIdentities: outputs.GetKubernetesClusterOmsAgentOmsAgentIdentity[];
}

export interface GetKubernetesClusterOmsAgentOmsAgentIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface GetKubernetesClusterServiceMeshProfile {
    certificateAuthorities: outputs.GetKubernetesClusterServiceMeshProfileCertificateAuthority[];
    externalIngressGatewayEnabled: boolean;
    internalIngressGatewayEnabled: boolean;
    mode: string;
    revisions: string[];
}

export interface GetKubernetesClusterServiceMeshProfileCertificateAuthority {
    certChainObjectName: string;
    certObjectName: string;
    keyObjectName: string;
    keyVaultId: string;
    rootCertObjectName: string;
}

export interface GetKubernetesClusterServicePrincipal {
    clientId: string;
}

export interface GetKubernetesClusterStorageProfile {
    blobDriverEnabled: boolean;
    diskDriverEnabled: boolean;
    fileDriverEnabled: boolean;
    snapshotControllerEnabled: boolean;
}

export interface GetKubernetesClusterTimeouts {
    read?: string;
}

export interface GetKubernetesClusterWindowsProfile {
    adminUsername: string;
}

export interface GetKubernetesNodePoolSnapshotTimeouts {
    read?: string;
}

export interface GetKubernetesServiceVersionsTimeouts {
    read?: string;
}

export interface GetKustoClusterIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetKustoClusterTimeouts {
    read?: string;
}

export interface GetKustoDatabaseTimeouts {
    read?: string;
}

export interface GetLbBackendAddressPoolBackendAddress {
    inboundNatRulePortMappings: outputs.GetLbBackendAddressPoolBackendAddressInboundNatRulePortMapping[];
    ipAddress: string;
    name: string;
    virtualNetworkId: string;
}

export interface GetLbBackendAddressPoolBackendAddressInboundNatRulePortMapping {
    backendPort: number;
    frontendPort: number;
    inboundNatRuleName: string;
}

export interface GetLbBackendAddressPoolBackendIpConfiguration {
    id: string;
}

export interface GetLbBackendAddressPoolTimeouts {
    read?: string;
}

export interface GetLbFrontendIpConfiguration {
    id: string;
    name: string;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    privateIpAddressVersion: string;
    publicIpAddressId: string;
    subnetId: string;
    zones: string[];
}

export interface GetLbOutboundRuleFrontendIpConfiguration {
    id: string;
    name: string;
}

export interface GetLbOutboundRuleTimeouts {
    read?: string;
}

export interface GetLbRuleTimeouts {
    read?: string;
}

export interface GetLbTimeouts {
    read?: string;
}

export interface GetLinuxFunctionAppAuthSetting {
    activeDirectories: outputs.GetLinuxFunctionAppAuthSettingActiveDirectory[];
    additionalLoginParameters: {[key: string]: string};
    allowedExternalRedirectUrls: string[];
    defaultProvider: string;
    enabled: boolean;
    facebooks: outputs.GetLinuxFunctionAppAuthSettingFacebook[];
    githubs: outputs.GetLinuxFunctionAppAuthSettingGithub[];
    googles: outputs.GetLinuxFunctionAppAuthSettingGoogle[];
    issuer: string;
    microsofts: outputs.GetLinuxFunctionAppAuthSettingMicrosoft[];
    runtimeVersion: string;
    tokenRefreshExtensionHours: number;
    tokenStoreEnabled: boolean;
    twitters: outputs.GetLinuxFunctionAppAuthSettingTwitter[];
    unauthenticatedClientAction: string;
}

export interface GetLinuxFunctionAppAuthSettingActiveDirectory {
    allowedAudiences: string[];
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
}

export interface GetLinuxFunctionAppAuthSettingFacebook {
    appId: string;
    appSecret: string;
    appSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingGithub {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingGoogle {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingMicrosoft {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingTwitter {
    consumerKey: string;
    consumerSecret: string;
    consumerSecretSettingName: string;
}

export interface GetLinuxFunctionAppAuthSettingsV2 {
    activeDirectoryV2s: outputs.GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2[];
    appleV2s: outputs.GetLinuxFunctionAppAuthSettingsV2AppleV2[];
    authEnabled: boolean;
    azureStaticWebAppV2s: outputs.GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2[];
    configFilePath: string;
    customOidcV2s: outputs.GetLinuxFunctionAppAuthSettingsV2CustomOidcV2[];
    defaultProvider: string;
    excludedPaths: string[];
    facebookV2s: outputs.GetLinuxFunctionAppAuthSettingsV2FacebookV2[];
    forwardProxyConvention: string;
    forwardProxyCustomHostHeaderName: string;
    forwardProxyCustomSchemeHeaderName: string;
    githubV2s: outputs.GetLinuxFunctionAppAuthSettingsV2GithubV2[];
    googleV2s: outputs.GetLinuxFunctionAppAuthSettingsV2GoogleV2[];
    httpRouteApiPrefix: string;
    logins: outputs.GetLinuxFunctionAppAuthSettingsV2Login[];
    microsoftV2s: outputs.GetLinuxFunctionAppAuthSettingsV2MicrosoftV2[];
    requireAuthentication: boolean;
    requireHttps: boolean;
    runtimeVersion: string;
    twitterV2s: outputs.GetLinuxFunctionAppAuthSettingsV2TwitterV2[];
    unauthenticatedAction: string;
}

export interface GetLinuxFunctionAppAuthSettingsV2ActiveDirectoryV2 {
    allowedApplications: string[];
    allowedAudiences: string[];
    allowedGroups: string[];
    allowedIdentities: string[];
    clientId: string;
    clientSecretCertificateThumbprint: string;
    clientSecretSettingName: string;
    jwtAllowedClientApplications: string[];
    jwtAllowedGroups: string[];
    loginParameters: {[key: string]: string};
    tenantAuthEndpoint: string;
    wwwAuthenticationDisabled: boolean;
}

export interface GetLinuxFunctionAppAuthSettingsV2AppleV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
    clientId: string;
}

export interface GetLinuxFunctionAppAuthSettingsV2CustomOidcV2 {
    authorisationEndpoint: string;
    certificationUri: string;
    clientCredentialMethod: string;
    clientId: string;
    clientSecretSettingName: string;
    issuerEndpoint: string;
    name: string;
    nameClaimType: string;
    openidConfigurationEndpoint: string;
    scopes: string[];
    tokenEndpoint: string;
}

export interface GetLinuxFunctionAppAuthSettingsV2FacebookV2 {
    appId: string;
    appSecretSettingName: string;
    graphApiVersion: string;
    loginScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingsV2GithubV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingsV2GoogleV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingsV2Login {
    allowedExternalRedirectUrls: string[];
    cookieExpirationConvention: string;
    cookieExpirationTime: string;
    logoutEndpoint: string;
    nonceExpirationTime: string;
    preserveUrlFragmentsForLogins: boolean;
    tokenRefreshExtensionTime: number;
    tokenStoreEnabled: boolean;
    tokenStorePath: string;
    tokenStoreSasSettingName: string;
    validateNonce: boolean;
}

export interface GetLinuxFunctionAppAuthSettingsV2MicrosoftV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxFunctionAppAuthSettingsV2TwitterV2 {
    consumerKey: string;
    consumerSecretSettingName: string;
}

export interface GetLinuxFunctionAppBackup {
    enabled: boolean;
    name: string;
    schedules: outputs.GetLinuxFunctionAppBackupSchedule[];
    storageAccountUrl: string;
}

export interface GetLinuxFunctionAppBackupSchedule {
    frequencyInterval: number;
    frequencyUnit: string;
    keepAtLeastOneBackup: boolean;
    lastExecutionTime: string;
    retentionPeriodDays: number;
    startTime: string;
}

export interface GetLinuxFunctionAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetLinuxFunctionAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetLinuxFunctionAppSiteConfig {
    alwaysOn: boolean;
    apiDefinitionUrl: string;
    apiManagementApiId: string;
    appCommandLine: string;
    appScaleLimit: number;
    appServiceLogs: outputs.GetLinuxFunctionAppSiteConfigAppServiceLog[];
    applicationInsightsConnectionString: string;
    applicationInsightsKey: string;
    applicationStacks: outputs.GetLinuxFunctionAppSiteConfigApplicationStack[];
    containerRegistryManagedIdentityClientId: string;
    containerRegistryUseManagedIdentity: boolean;
    cors: outputs.GetLinuxFunctionAppSiteConfigCor[];
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckEvictionTimeInMin: number;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictionDefaultAction: string;
    ipRestrictions: outputs.GetLinuxFunctionAppSiteConfigIpRestriction[];
    linuxFxVersion: string;
    loadBalancingMode: string;
    managedPipelineMode: string;
    minimumTlsVersion: string;
    preWarmedInstanceCount: number;
    remoteDebuggingEnabled: boolean;
    remoteDebuggingVersion: string;
    runtimeScaleMonitoringEnabled: boolean;
    scmIpRestrictionDefaultAction: string;
    scmIpRestrictions: outputs.GetLinuxFunctionAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorker: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    workerCount: number;
}

export interface GetLinuxFunctionAppSiteConfigAppServiceLog {
    diskQuotaMb: number;
    retentionPeriodDays: number;
}

export interface GetLinuxFunctionAppSiteConfigApplicationStack {
    dockers: outputs.GetLinuxFunctionAppSiteConfigApplicationStackDocker[];
    dotnetVersion: string;
    javaVersion: string;
    nodeVersion: string;
    powershellCoreVersion: string;
    pythonVersion: string;
    useCustomRuntime: boolean;
    useDotnetIsolatedRuntime: boolean;
}

export interface GetLinuxFunctionAppSiteConfigApplicationStackDocker {
    imageName: string;
    imageTag: string;
    registryPassword: string;
    registryUrl: string;
    registryUsername: string;
}

export interface GetLinuxFunctionAppSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetLinuxFunctionAppSiteConfigIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetLinuxFunctionAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLinuxFunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLinuxFunctionAppSiteConfigScmIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetLinuxFunctionAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLinuxFunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLinuxFunctionAppSiteCredential {
    name: string;
    password: string;
}

export interface GetLinuxFunctionAppStickySetting {
    appSettingNames: string[];
    connectionStringNames: string[];
}

export interface GetLinuxFunctionAppTimeouts {
    read?: string;
}

export interface GetLinuxWebAppAuthSetting {
    activeDirectories: outputs.GetLinuxWebAppAuthSettingActiveDirectory[];
    additionalLoginParameters: {[key: string]: string};
    allowedExternalRedirectUrls: string[];
    defaultProvider: string;
    enabled: boolean;
    facebooks: outputs.GetLinuxWebAppAuthSettingFacebook[];
    githubs: outputs.GetLinuxWebAppAuthSettingGithub[];
    googles: outputs.GetLinuxWebAppAuthSettingGoogle[];
    issuer: string;
    microsofts: outputs.GetLinuxWebAppAuthSettingMicrosoft[];
    runtimeVersion: string;
    tokenRefreshExtensionHours: number;
    tokenStoreEnabled: boolean;
    twitters: outputs.GetLinuxWebAppAuthSettingTwitter[];
    unauthenticatedClientAction: string;
}

export interface GetLinuxWebAppAuthSettingActiveDirectory {
    allowedAudiences: string[];
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
}

export interface GetLinuxWebAppAuthSettingFacebook {
    appId: string;
    appSecret: string;
    appSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxWebAppAuthSettingGithub {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxWebAppAuthSettingGoogle {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxWebAppAuthSettingMicrosoft {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetLinuxWebAppAuthSettingTwitter {
    consumerKey: string;
    consumerSecret: string;
    consumerSecretSettingName: string;
}

export interface GetLinuxWebAppAuthSettingsV2 {
    activeDirectoryV2s: outputs.GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2[];
    appleV2s: outputs.GetLinuxWebAppAuthSettingsV2AppleV2[];
    authEnabled: boolean;
    azureStaticWebAppV2s: outputs.GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2[];
    configFilePath: string;
    customOidcV2s: outputs.GetLinuxWebAppAuthSettingsV2CustomOidcV2[];
    defaultProvider: string;
    excludedPaths: string[];
    facebookV2s: outputs.GetLinuxWebAppAuthSettingsV2FacebookV2[];
    forwardProxyConvention: string;
    forwardProxyCustomHostHeaderName: string;
    forwardProxyCustomSchemeHeaderName: string;
    githubV2s: outputs.GetLinuxWebAppAuthSettingsV2GithubV2[];
    googleV2s: outputs.GetLinuxWebAppAuthSettingsV2GoogleV2[];
    httpRouteApiPrefix: string;
    logins: outputs.GetLinuxWebAppAuthSettingsV2Login[];
    microsoftV2s: outputs.GetLinuxWebAppAuthSettingsV2MicrosoftV2[];
    requireAuthentication: boolean;
    requireHttps: boolean;
    runtimeVersion: string;
    twitterV2s: outputs.GetLinuxWebAppAuthSettingsV2TwitterV2[];
    unauthenticatedAction: string;
}

export interface GetLinuxWebAppAuthSettingsV2ActiveDirectoryV2 {
    allowedApplications: string[];
    allowedAudiences: string[];
    allowedGroups: string[];
    allowedIdentities: string[];
    clientId: string;
    clientSecretCertificateThumbprint: string;
    clientSecretSettingName: string;
    jwtAllowedClientApplications: string[];
    jwtAllowedGroups: string[];
    loginParameters: {[key: string]: string};
    tenantAuthEndpoint: string;
    wwwAuthenticationDisabled: boolean;
}

export interface GetLinuxWebAppAuthSettingsV2AppleV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxWebAppAuthSettingsV2AzureStaticWebAppV2 {
    clientId: string;
}

export interface GetLinuxWebAppAuthSettingsV2CustomOidcV2 {
    authorisationEndpoint: string;
    certificationUri: string;
    clientCredentialMethod: string;
    clientId: string;
    clientSecretSettingName: string;
    issuerEndpoint: string;
    name: string;
    nameClaimType: string;
    openidConfigurationEndpoint: string;
    scopes: string[];
    tokenEndpoint: string;
}

export interface GetLinuxWebAppAuthSettingsV2FacebookV2 {
    appId: string;
    appSecretSettingName: string;
    graphApiVersion: string;
    loginScopes: string[];
}

export interface GetLinuxWebAppAuthSettingsV2GithubV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxWebAppAuthSettingsV2GoogleV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxWebAppAuthSettingsV2Login {
    allowedExternalRedirectUrls: string[];
    cookieExpirationConvention: string;
    cookieExpirationTime: string;
    logoutEndpoint: string;
    nonceExpirationTime: string;
    preserveUrlFragmentsForLogins: boolean;
    tokenRefreshExtensionTime: number;
    tokenStoreEnabled: boolean;
    tokenStorePath: string;
    tokenStoreSasSettingName: string;
    validateNonce: boolean;
}

export interface GetLinuxWebAppAuthSettingsV2MicrosoftV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetLinuxWebAppAuthSettingsV2TwitterV2 {
    consumerKey: string;
    consumerSecretSettingName: string;
}

export interface GetLinuxWebAppBackup {
    enabled: boolean;
    name: string;
    schedules: outputs.GetLinuxWebAppBackupSchedule[];
    storageAccountUrl: string;
}

export interface GetLinuxWebAppBackupSchedule {
    frequencyInterval: number;
    frequencyUnit: string;
    keepAtLeastOneBackup: boolean;
    lastExecutionTime: string;
    retentionPeriodDays: number;
    startTime: string;
}

export interface GetLinuxWebAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetLinuxWebAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetLinuxWebAppLog {
    applicationLogs: outputs.GetLinuxWebAppLogApplicationLog[];
    detailedErrorMessages: boolean;
    failedRequestTracing: boolean;
    httpLogs: outputs.GetLinuxWebAppLogHttpLog[];
}

export interface GetLinuxWebAppLogApplicationLog {
    azureBlobStorages: outputs.GetLinuxWebAppLogApplicationLogAzureBlobStorage[];
    fileSystemLevel: string;
}

export interface GetLinuxWebAppLogApplicationLogAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface GetLinuxWebAppLogHttpLog {
    azureBlobStorages: outputs.GetLinuxWebAppLogHttpLogAzureBlobStorage[];
    fileSystems: outputs.GetLinuxWebAppLogHttpLogFileSystem[];
}

export interface GetLinuxWebAppLogHttpLogAzureBlobStorage {
    retentionInDays: number;
    sasUrl: string;
}

export interface GetLinuxWebAppLogHttpLogFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface GetLinuxWebAppSiteConfig {
    alwaysOn: boolean;
    apiDefinitionUrl: string;
    apiManagementApiId: string;
    appCommandLine: string;
    applicationStacks: outputs.GetLinuxWebAppSiteConfigApplicationStack[];
    autoHealSettings: outputs.GetLinuxWebAppSiteConfigAutoHealSetting[];
    containerRegistryManagedIdentityClientId: string;
    containerRegistryUseManagedIdentity: boolean;
    cors: outputs.GetLinuxWebAppSiteConfigCor[];
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState: string;
    healthCheckEvictionTimeInMin: number;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictionDefaultAction: string;
    ipRestrictions: outputs.GetLinuxWebAppSiteConfigIpRestriction[];
    linuxFxVersion: string;
    loadBalancingMode: string;
    localMysqlEnabled: boolean;
    managedPipelineMode: string;
    minimumTlsVersion: string;
    remoteDebuggingEnabled: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction: string;
    scmIpRestrictions: outputs.GetLinuxWebAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorker: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    workerCount: number;
}

export interface GetLinuxWebAppSiteConfigApplicationStack {
    dockerImageName: string;
    dockerRegistryPassword: string;
    dockerRegistryUrl: string;
    dockerRegistryUsername: string;
    dotnetVersion: string;
    goVersion: string;
    javaServer: string;
    javaServerVersion: string;
    javaVersion: string;
    nodeVersion: string;
    phpVersion: string;
    pythonVersion: string;
    rubyVersion: string;
}

export interface GetLinuxWebAppSiteConfigAutoHealSetting {
    actions: outputs.GetLinuxWebAppSiteConfigAutoHealSettingAction[];
    triggers: outputs.GetLinuxWebAppSiteConfigAutoHealSettingTrigger[];
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingAction {
    actionType: string;
    minimumProcessExecutionTime: string;
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingTrigger {
    requests: outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequest[];
    slowRequestWithPaths: outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    slowRequests: outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
    statusCodes: outputs.GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerRequest {
    count: number;
    interval: string;
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path: string;
    timeTaken: string;
}

export interface GetLinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path: string;
    statusCodeRange: string;
    subStatus: number;
    win32StatusCode: number;
}

export interface GetLinuxWebAppSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetLinuxWebAppSiteConfigIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetLinuxWebAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLinuxWebAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLinuxWebAppSiteConfigScmIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetLinuxWebAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLinuxWebAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLinuxWebAppSiteCredential {
    name: string;
    password: string;
}

export interface GetLinuxWebAppStickySetting {
    appSettingNames: string[];
    connectionStringNames: string[];
}

export interface GetLinuxWebAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath: string;
    name: string;
    shareName: string;
    type: string;
}

export interface GetLinuxWebAppTimeouts {
    read?: string;
}

export interface GetLoadTestEncryption {
    identities: outputs.GetLoadTestEncryptionIdentity[];
    keyUrl: string;
}

export interface GetLoadTestEncryptionIdentity {
    identityId: string;
    type: string;
}

export interface GetLoadTestIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetLoadTestTimeouts {
    read?: string;
}

export interface GetLocalNetworkGatewayBgpSetting {
    asn: number;
    bgpPeeringAddress: string;
    peerWeight: number;
}

export interface GetLocalNetworkGatewayTimeouts {
    read?: string;
}

export interface GetLocationTimeouts {
    read?: string;
}

export interface GetLocationZoneMapping {
    logicalZone: string;
    physicalZone: string;
}

export interface GetLogAnalyticsWorkspaceTimeouts {
    read?: string;
}

export interface GetLogicAppIntegrationAccountTimeouts {
    read?: string;
}

export interface GetLogicAppStandardConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetLogicAppStandardIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetLogicAppStandardSiteConfig {
    alwaysOn?: boolean;
    appScaleLimit: number;
    autoSwapSlotName: string;
    cors?: outputs.GetLogicAppStandardSiteConfigCors;
    dotnetFrameworkVersion?: string;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.GetLogicAppStandardSiteConfigIpRestriction[];
    linuxFxVersion: string;
    minTlsVersion: string;
    preWarmedInstanceCount: number;
    publicNetworkAccessEnabled?: boolean;
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictions: outputs.GetLogicAppStandardSiteConfigScmIpRestriction[];
    scmMinTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled?: boolean;
}

export interface GetLogicAppStandardSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface GetLogicAppStandardSiteConfigIpRestriction {
    action: string;
    headers: outputs.GetLogicAppStandardSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLogicAppStandardSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLogicAppStandardSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.GetLogicAppStandardSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetLogicAppStandardSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetLogicAppStandardSiteCredential {
    password: string;
    username: string;
}

export interface GetLogicAppStandardTimeouts {
    read?: string;
}

export interface GetLogicAppWorkflowIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetLogicAppWorkflowTimeouts {
    read?: string;
}

export interface GetMachineLearningWorkspaceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetMachineLearningWorkspaceTimeouts {
    read?: string;
}

export interface GetMaintenanceConfigurationInstallPatch {
    linuxes: outputs.GetMaintenanceConfigurationInstallPatchLinux[];
    reboot: string;
    windows: outputs.GetMaintenanceConfigurationInstallPatchWindow[];
}

export interface GetMaintenanceConfigurationInstallPatchLinux {
    classificationsToIncludes: string[];
    packageNamesMaskToExcludes: string[];
    packageNamesMaskToIncludes: string[];
}

export interface GetMaintenanceConfigurationInstallPatchWindow {
    classificationsToIncludes: string[];
    kbNumbersToExcludes: string[];
    kbNumbersToIncludes: string[];
}

export interface GetMaintenanceConfigurationTimeouts {
    read?: string;
}

export interface GetMaintenanceConfigurationWindow {
    duration: string;
    expirationDateTime: string;
    recurEvery: string;
    startDateTime: string;
    timeZone: string;
}

export interface GetManagedApiTimeouts {
    read?: string;
}

export interface GetManagedApplicationDefinitionTimeouts {
    read?: string;
}

export interface GetManagedDiskEncryptionSetting {
    diskEncryptionKeys: outputs.GetManagedDiskEncryptionSettingDiskEncryptionKey[];
    enabled: boolean;
    keyEncryptionKeys: outputs.GetManagedDiskEncryptionSettingKeyEncryptionKey[];
}

export interface GetManagedDiskEncryptionSettingDiskEncryptionKey {
    secretUrl: string;
    sourceVaultId: string;
}

export interface GetManagedDiskEncryptionSettingKeyEncryptionKey {
    keyUrl: string;
    sourceVaultId: string;
}

export interface GetManagedDiskTimeouts {
    read?: string;
}

export interface GetManagementGroupTemplateDeploymentTimeouts {
    read?: string;
}

export interface GetManagementGroupTimeouts {
    read?: string;
}

export interface GetMapsAccountTimeouts {
    read?: string;
}

export interface GetMarketplaceAgreementTimeouts {
    read?: string;
}

export interface GetMobileNetworkAttachedDataNetworkNetworkAddressPortTranslation {
    icmpPinholeTimeoutInSeconds: number;
    pinholeMaximumNumber: number;
    portRanges: outputs.GetMobileNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange[];
    tcpPinholeTimeoutInSeconds: number;
    tcpPortReuseMinimumHoldTimeInSeconds: number;
    udpPinholeTimeoutInSeconds: number;
    udpPortReuseMinimumHoldTimeInSeconds: number;
}

export interface GetMobileNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange {
    maximum: number;
    minimum: number;
}

export interface GetMobileNetworkAttachedDataNetworkTimeouts {
    read?: string;
}

export interface GetMobileNetworkDataNetworkTimeouts {
    read?: string;
}

export interface GetMobileNetworkPacketCoreControlPlaneIdentity {
    identityIds: string[];
    type: string;
}

export interface GetMobileNetworkPacketCoreControlPlaneLocalDiagnosticsAccess {
    authenticationType: string;
    httpsServerCertificateUrl: string;
}

export interface GetMobileNetworkPacketCoreControlPlanePlatform {
    arcKubernetesClusterId: string;
    customLocationId: string;
    edgeDeviceId: string;
    stackHciClusterId: string;
    type: string;
}

export interface GetMobileNetworkPacketCoreControlPlaneTimeouts {
    read?: string;
}

export interface GetMobileNetworkPacketCoreDataPlaneTimeouts {
    read?: string;
}

export interface GetMobileNetworkServicePccRule {
    name: string;
    precedence: number;
    qosPolicies: outputs.GetMobileNetworkServicePccRuleQosPolicy[];
    serviceDataFlowTemplates: outputs.GetMobileNetworkServicePccRuleServiceDataFlowTemplate[];
    trafficControlEnabled: boolean;
}

export interface GetMobileNetworkServicePccRuleQosPolicy {
    allocationAndRetentionPriorityLevel: number;
    guaranteedBitRates: outputs.GetMobileNetworkServicePccRuleQosPolicyGuaranteedBitRate[];
    maximumBitRates: outputs.GetMobileNetworkServicePccRuleQosPolicyMaximumBitRate[];
    preemptionCapability: string;
    preemptionVulnerability: string;
    qosIndicator: number;
}

export interface GetMobileNetworkServicePccRuleQosPolicyGuaranteedBitRate {
    downlink: string;
    uplink: string;
}

export interface GetMobileNetworkServicePccRuleQosPolicyMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface GetMobileNetworkServicePccRuleServiceDataFlowTemplate {
    direction: string;
    name: string;
    ports: string[];
    protocols: string[];
    remoteIpLists: string[];
}

export interface GetMobileNetworkServiceServiceQosPolicy {
    allocationAndRetentionPriorityLevel: number;
    maximumBitRates: outputs.GetMobileNetworkServiceServiceQosPolicyMaximumBitRate[];
    preemptionCapability: string;
    preemptionVulnerability: string;
    qosIndicator: number;
}

export interface GetMobileNetworkServiceServiceQosPolicyMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface GetMobileNetworkServiceTimeouts {
    read?: string;
}

export interface GetMobileNetworkSimGroupIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetMobileNetworkSimGroupTimeouts {
    read?: string;
}

export interface GetMobileNetworkSimPolicySlice {
    dataNetworks: outputs.GetMobileNetworkSimPolicySliceDataNetwork[];
    defaultDataNetworkId: string;
    sliceId: string;
}

export interface GetMobileNetworkSimPolicySliceDataNetwork {
    additionalAllowedSessionTypes: string[];
    allocationAndRetentionPriorityLevel: number;
    allowedServicesIds: string[];
    dataNetworkId: string;
    defaultSessionType: string;
    maxBufferedPackets: number;
    preemptionCapability: string;
    preemptionVulnerability: string;
    qosIndicator: number;
    sessionAggregateMaximumBitRates: outputs.GetMobileNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate[];
}

export interface GetMobileNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface GetMobileNetworkSimPolicyTimeouts {
    read?: string;
}

export interface GetMobileNetworkSimPolicyUserEquipmentAggregateMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface GetMobileNetworkSimStaticIpConfiguration {
    attachedDataNetworkId: string;
    sliceId: string;
    staticIpv4Address: string;
}

export interface GetMobileNetworkSimTimeouts {
    read?: string;
}

export interface GetMobileNetworkSiteTimeouts {
    read?: string;
}

export interface GetMobileNetworkSliceSingleNetworkSliceSelectionAssistanceInformation {
    sliceDifferentiator: string;
    sliceServiceType: number;
}

export interface GetMobileNetworkSliceTimeouts {
    read?: string;
}

export interface GetMobileNetworkTimeouts {
    read?: string;
}

export interface GetMonitorActionGroupArmRoleReceiver {
    name: string;
    roleId: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupAutomationRunbookReceiver {
    automationAccountId: string;
    isGlobalRunbook: boolean;
    name: string;
    runbookName: string;
    serviceUri: string;
    useCommonAlertSchema: boolean;
    webhookResourceId: string;
}

export interface GetMonitorActionGroupAzureAppPushReceiver {
    emailAddress: string;
    name: string;
}

export interface GetMonitorActionGroupAzureFunctionReceiver {
    functionAppResourceId: string;
    functionName: string;
    httpTriggerUrl: string;
    name: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupEmailReceiver {
    emailAddress: string;
    name: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupEventHubReceiver {
    eventHubName: string;
    eventHubNamespace: string;
    name: string;
    subscriptionId: string;
    tenantId: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupItsmReceiver {
    connectionId: string;
    name: string;
    region: string;
    ticketConfiguration: string;
    workspaceId: string;
}

export interface GetMonitorActionGroupLogicAppReceiver {
    callbackUrl: string;
    name: string;
    resourceId: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupSmsReceiver {
    countryCode: string;
    name: string;
    phoneNumber: string;
}

export interface GetMonitorActionGroupTimeouts {
    read?: string;
}

export interface GetMonitorActionGroupVoiceReceiver {
    countryCode: string;
    name: string;
    phoneNumber: string;
}

export interface GetMonitorActionGroupWebhookReceiver {
    aadAuths: outputs.GetMonitorActionGroupWebhookReceiverAadAuth[];
    name: string;
    serviceUri: string;
    useCommonAlertSchema: boolean;
}

export interface GetMonitorActionGroupWebhookReceiverAadAuth {
    identifierUri: string;
    objectId: string;
    tenantId: string;
}

export interface GetMonitorDataCollectionEndpointTimeouts {
    read?: string;
}

export interface GetMonitorDataCollectionRuleDataFlow {
    builtInTransform: string;
    destinations: string[];
    outputStream: string;
    streams: string[];
    transformKql: string;
}

export interface GetMonitorDataCollectionRuleDataSource {
    dataImports: outputs.GetMonitorDataCollectionRuleDataSourceDataImport[];
    extensions: outputs.GetMonitorDataCollectionRuleDataSourceExtension[];
    iisLogs: outputs.GetMonitorDataCollectionRuleDataSourceIisLog[];
    logFiles: outputs.GetMonitorDataCollectionRuleDataSourceLogFile[];
    performanceCounters: outputs.GetMonitorDataCollectionRuleDataSourcePerformanceCounter[];
    platformTelemetries: outputs.GetMonitorDataCollectionRuleDataSourcePlatformTelemetry[];
    prometheusForwarders: outputs.GetMonitorDataCollectionRuleDataSourcePrometheusForwarder[];
    syslogs: outputs.GetMonitorDataCollectionRuleDataSourceSyslog[];
    windowsEventLogs: outputs.GetMonitorDataCollectionRuleDataSourceWindowsEventLog[];
    windowsFirewallLogs: outputs.GetMonitorDataCollectionRuleDataSourceWindowsFirewallLog[];
}

export interface GetMonitorDataCollectionRuleDataSourceDataImport {
    eventHubDataSources: outputs.GetMonitorDataCollectionRuleDataSourceDataImportEventHubDataSource[];
}

export interface GetMonitorDataCollectionRuleDataSourceDataImportEventHubDataSource {
    consumerGroup: string;
    name: string;
    stream: string;
}

export interface GetMonitorDataCollectionRuleDataSourceExtension {
    extensionJson: string;
    extensionName: string;
    inputDataSources: string[];
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourceIisLog {
    logDirectories: string[];
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourceLogFile {
    filePatterns: string[];
    format: string;
    name: string;
    settings: outputs.GetMonitorDataCollectionRuleDataSourceLogFileSetting[];
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourceLogFileSetting {
    texts: outputs.GetMonitorDataCollectionRuleDataSourceLogFileSettingText[];
}

export interface GetMonitorDataCollectionRuleDataSourceLogFileSettingText {
    recordStartTimestampFormat: string;
}

export interface GetMonitorDataCollectionRuleDataSourcePerformanceCounter {
    counterSpecifiers: string[];
    name: string;
    samplingFrequencyInSeconds: number;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourcePlatformTelemetry {
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourcePrometheusForwarder {
    labelIncludeFilters: outputs.GetMonitorDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilter[];
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourcePrometheusForwarderLabelIncludeFilter {
    label: string;
    value: string;
}

export interface GetMonitorDataCollectionRuleDataSourceSyslog {
    facilityNames: string[];
    logLevels: string[];
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDataSourceWindowsEventLog {
    name: string;
    streams: string[];
    xPathQueries: string[];
}

export interface GetMonitorDataCollectionRuleDataSourceWindowsFirewallLog {
    name: string;
    streams: string[];
}

export interface GetMonitorDataCollectionRuleDestination {
    azureMonitorMetrics: outputs.GetMonitorDataCollectionRuleDestinationAzureMonitorMetric[];
    eventHubDirects: outputs.GetMonitorDataCollectionRuleDestinationEventHubDirect[];
    eventHubs: outputs.GetMonitorDataCollectionRuleDestinationEventHub[];
    logAnalytics: outputs.GetMonitorDataCollectionRuleDestinationLogAnalytic[];
    monitorAccounts: outputs.GetMonitorDataCollectionRuleDestinationMonitorAccount[];
    storageBlobDirects: outputs.GetMonitorDataCollectionRuleDestinationStorageBlobDirect[];
    storageBlobs: outputs.GetMonitorDataCollectionRuleDestinationStorageBlob[];
    storageTableDirects: outputs.GetMonitorDataCollectionRuleDestinationStorageTableDirect[];
}

export interface GetMonitorDataCollectionRuleDestinationAzureMonitorMetric {
    name: string;
}

export interface GetMonitorDataCollectionRuleDestinationEventHub {
    eventHubId: string;
    name: string;
}

export interface GetMonitorDataCollectionRuleDestinationEventHubDirect {
    eventHubId: string;
    name: string;
}

export interface GetMonitorDataCollectionRuleDestinationLogAnalytic {
    name: string;
    workspaceResourceId: string;
}

export interface GetMonitorDataCollectionRuleDestinationMonitorAccount {
    monitorAccountId: string;
    name: string;
}

export interface GetMonitorDataCollectionRuleDestinationStorageBlob {
    containerName: string;
    name: string;
    storageAccountId: string;
}

export interface GetMonitorDataCollectionRuleDestinationStorageBlobDirect {
    containerName: string;
    name: string;
    storageAccountId: string;
}

export interface GetMonitorDataCollectionRuleDestinationStorageTableDirect {
    name: string;
    storageAccountId: string;
    tableName: string;
}

export interface GetMonitorDataCollectionRuleIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetMonitorDataCollectionRuleStreamDeclaration {
    columns: outputs.GetMonitorDataCollectionRuleStreamDeclarationColumn[];
    streamName: string;
}

export interface GetMonitorDataCollectionRuleStreamDeclarationColumn {
    name: string;
    type: string;
}

export interface GetMonitorDataCollectionRuleTimeouts {
    read?: string;
}

export interface GetMonitorDiagnosticCategoriesTimeouts {
    read?: string;
}

export interface GetMonitorScheduledQueryRulesAlertAction {
    actionGroups: string[];
    customWebhookPayload: string;
    emailSubject: string;
}

export interface GetMonitorScheduledQueryRulesAlertTimeouts {
    read?: string;
}

export interface GetMonitorScheduledQueryRulesAlertTrigger {
    metricTriggers: outputs.GetMonitorScheduledQueryRulesAlertTriggerMetricTrigger[];
    operator: string;
    threshold: number;
}

export interface GetMonitorScheduledQueryRulesAlertTriggerMetricTrigger {
    metricColumn: string;
    metricTriggerType: string;
    operator: string;
    threshold: number;
}

export interface GetMonitorScheduledQueryRulesLogCriteria {
    dimensions: outputs.GetMonitorScheduledQueryRulesLogCriteriaDimension[];
    metricName: string;
}

export interface GetMonitorScheduledQueryRulesLogCriteriaDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface GetMonitorScheduledQueryRulesLogTimeouts {
    read?: string;
}

export interface GetMonitorWorkspaceTimeouts {
    read?: string;
}

export interface GetMssqlDatabaseIdentity {
    identityIds: string[];
    type: string;
}

export interface GetMssqlDatabaseTimeouts {
    read?: string;
}

export interface GetMssqlElasticpoolSkus {
    capacity: number;
    family: string;
    name: string;
    tier: string;
}

export interface GetMssqlElasticpoolTimeouts {
    read?: string;
}

export interface GetMssqlManagedInstanceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetMssqlManagedInstanceTimeouts {
    read?: string;
}

export interface GetMssqlServerIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetMssqlServerTimeouts {
    read?: string;
}

export interface GetMysqlFlexibleServerHighAvailability {
    mode: string;
    standbyAvailabilityZone: string;
}

export interface GetMysqlFlexibleServerMaintenanceWindow {
    dayOfWeek: number;
    startHour: number;
    startMinute: number;
}

export interface GetMysqlFlexibleServerStorage {
    autoGrowEnabled: boolean;
    ioScalingEnabled: boolean;
    iops: number;
    sizeGb: number;
}

export interface GetMysqlFlexibleServerTimeouts {
    read?: string;
}

export interface GetNatGatewayTimeouts {
    read?: string;
}

export interface GetNetappAccountEncryptionTimeouts {
    read?: string;
}

export interface GetNetappAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetNetappAccountTimeouts {
    read?: string;
}

export interface GetNetappPoolTimeouts {
    read?: string;
}

export interface GetNetappSnapshotPolicyDailySchedule {
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface GetNetappSnapshotPolicyHourlySchedule {
    minute: number;
    snapshotsToKeep: number;
}

export interface GetNetappSnapshotPolicyMonthlySchedule {
    daysOfMonths: number[];
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface GetNetappSnapshotPolicyTimeouts {
    read?: string;
}

export interface GetNetappSnapshotPolicyWeeklySchedule {
    daysOfWeeks: string[];
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface GetNetappSnapshotTimeouts {
    read?: string;
}

export interface GetNetappVolumeDataProtectionReplication {
    endpointType: string;
    remoteVolumeLocation: string;
    remoteVolumeResourceId: string;
    replicationFrequency: string;
}

export interface GetNetappVolumeGroupSapHanaTimeouts {
    read?: string;
}

export interface GetNetappVolumeGroupSapHanaVolume {
    capacityPoolId: string;
    dataProtectionReplications: outputs.GetNetappVolumeGroupSapHanaVolumeDataProtectionReplication[];
    dataProtectionSnapshotPolicies: outputs.GetNetappVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy[];
    exportPolicyRules: outputs.GetNetappVolumeGroupSapHanaVolumeExportPolicyRule[];
    id: string;
    mountIpAddresses: string[];
    name: string;
    protocols: string[];
    proximityPlacementGroupId: string;
    securityStyle: string;
    serviceLevel: string;
    snapshotDirectoryVisible: boolean;
    storageQuotaInGb: number;
    subnetId: string;
    tags: {[key: string]: string};
    throughputInMibps: number;
    volumePath: string;
    volumeSpecName: string;
}

export interface GetNetappVolumeGroupSapHanaVolumeDataProtectionReplication {
    endpointType: string;
    remoteVolumeLocation: string;
    remoteVolumeResourceId: string;
    replicationFrequency: string;
}

export interface GetNetappVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy {
    snapshotPolicyId: string;
}

export interface GetNetappVolumeGroupSapHanaVolumeExportPolicyRule {
    allowedClients: string;
    nfsv3Enabled: boolean;
    nfsv41Enabled: boolean;
    rootAccessEnabled: boolean;
    ruleIndex: number;
    unixReadOnly: boolean;
    unixReadWrite: boolean;
}

export interface GetNetappVolumeQuotaRuleTimeouts {
    read?: string;
}

export interface GetNetappVolumeTimeouts {
    read?: string;
}

export interface GetNetworkDdosProtectionPlanTimeouts {
    read?: string;
}

export interface GetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolsIds: string[];
    applicationSecurityGroupIds: string[];
    gatewayLoadBalancerFrontendIpConfigurationId: string;
    loadBalancerBackendAddressPoolsIds: string[];
    loadBalancerInboundNatRulesIds: string[];
    name: string;
    primary: boolean;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    privateIpAddressVersion: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetNetworkInterfaceTimeouts {
    read?: string;
}

export interface GetNetworkManagerConnectivityConfigurationAppliesToGroup {
    globalMeshEnabled: boolean;
    groupConnectivity: string;
    networkGroupId: string;
    useHubGateway: boolean;
}

export interface GetNetworkManagerConnectivityConfigurationHub {
    resourceId: string;
    resourceType: string;
}

export interface GetNetworkManagerConnectivityConfigurationTimeouts {
    read?: string;
}

export interface GetNetworkManagerCrossTenantScope {
    managementGroups: string[];
    subscriptions: string[];
    tenantId: string;
}

export interface GetNetworkManagerNetworkGroupTimeouts {
    read?: string;
}

export interface GetNetworkManagerScope {
    managementGroupIds: string[];
    subscriptionIds: string[];
}

export interface GetNetworkManagerTimeouts {
    read?: string;
}

export interface GetNetworkSecurityGroupSecurityRule {
    access: string;
    description: string;
    destinationAddressPrefix: string;
    destinationAddressPrefixes: string[];
    destinationApplicationSecurityGroupIds: string[];
    destinationPortRange: string;
    destinationPortRanges: string[];
    direction: string;
    name: string;
    priority: number;
    protocol: string;
    sourceAddressPrefix: string;
    sourceAddressPrefixes: string[];
    sourceApplicationSecurityGroupIds: string[];
    sourcePortRange: string;
    sourcePortRanges: string[];
}

export interface GetNetworkSecurityGroupTimeouts {
    read?: string;
}

export interface GetNetworkServiceTagsTimeouts {
    read?: string;
}

export interface GetNetworkWatcherTimeouts {
    read?: string;
}

export interface GetNginxCertificateTimeouts {
    read?: string;
}

export interface GetNginxConfigurationConfigFile {
    content: string;
    virtualPath: string;
}

export interface GetNginxConfigurationProtectedFile {
    content: string;
    virtualPath: string;
}

export interface GetNginxConfigurationTimeouts {
    read?: string;
}

export interface GetNginxDeploymentAutoScaleProfile {
    maxCapacity: number;
    minCapacity: number;
    name: string;
}

export interface GetNginxDeploymentFrontendPrivate {
    allocationMethod: string;
    ipAddress: string;
    subnetId: string;
}

export interface GetNginxDeploymentFrontendPublic {
    ipAddresses: string[];
}

export interface GetNginxDeploymentIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetNginxDeploymentLoggingStorageAccount {
    containerName: string;
    name: string;
}

export interface GetNginxDeploymentNetworkInterface {
    subnetId: string;
}

export interface GetNginxDeploymentTimeouts {
    read?: string;
}

export interface GetNotificationHubApnsCredential {
    applicationMode: string;
    bundleId: string;
    keyId: string;
    teamId: string;
    token: string;
}

export interface GetNotificationHubGcmCredential {
    apiKey: string;
}

export interface GetNotificationHubNamespaceSkus {
    name: string;
}

export interface GetNotificationHubNamespaceTimeouts {
    read?: string;
}

export interface GetNotificationHubTimeouts {
    read?: string;
}

export interface GetOrchestratedVirtualMachineScaleSetIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetOrchestratedVirtualMachineScaleSetNetworkInterface {
    acceleratedNetworkingEnabled: boolean;
    dnsServers: string[];
    ipConfigurations: outputs.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
    ipForwardingEnabled: boolean;
    name: string;
    networkSecurityGroupId: string;
    primary: boolean;
}

export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolIds: string[];
    applicationSecurityGroupIds: string[];
    loadBalancerBackendAddressPoolIds: string[];
    loadBalancerInboundNatRulesIds: string[];
    name: string;
    primary: boolean;
    publicIpAddresses: outputs.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
    subnetId: string;
    version: string;
}

export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
    domainNameLabel: string;
    idleTimeoutInMinutes: number;
    ipTags: outputs.GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
    name: string;
    publicIpPrefixId: string;
    version: string;
}

export interface GetOrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
    tag: string;
    type: string;
}

export interface GetOrchestratedVirtualMachineScaleSetTimeouts {
    read?: string;
}

export interface GetPaloAltoLocalRulestackTimeouts {
    read?: string;
}

export interface GetPlatformImageTimeouts {
    read?: string;
}

export interface GetPolicyAssignmentIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetPolicyAssignmentNonComplianceMessage {
    content: string;
    policyDefinitionReferenceId: string;
}

export interface GetPolicyAssignmentTimeouts {
    read?: string;
}

export interface GetPolicyDefinitionBuiltInTimeouts {
    read?: string;
}

export interface GetPolicyDefinitionTimeouts {
    read?: string;
}

export interface GetPolicySetDefinitionPolicyDefinitionGroup {
    additionalMetadataResourceId: string;
    category: string;
    description: string;
    displayName: string;
    name: string;
}

export interface GetPolicySetDefinitionPolicyDefinitionReference {
    parameterValues: string;
    parameters: {[key: string]: string};
    policyDefinitionId: string;
    policyGroupNames: string[];
    referenceId: string;
}

export interface GetPolicySetDefinitionTimeouts {
    read?: string;
}

export interface GetPolicyVirtualMachineConfigurationAssignmentTimeouts {
    read?: string;
}

export interface GetPortalDashboardTimeouts {
    read?: string;
}

export interface GetPostgresqlFlexibleServerTimeouts {
    read?: string;
}

export interface GetPostgresqlServerIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetPostgresqlServerTimeouts {
    read?: string;
}

export interface GetPrivateDnsARecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsAaaaRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsCnameRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsMxRecordRecord {
    exchange: string;
    preference: number;
}

export interface GetPrivateDnsMxRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsPtrRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverDnsForwardingRulesetTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverForwardingRuleTargetDnsServer {
    ipAddress: string;
    port: number;
}

export interface GetPrivateDnsResolverForwardingRuleTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverInboundEndpointIpConfiguration {
    privateIpAddress: string;
    privateIpAllocationMethod: string;
    subnetId: string;
}

export interface GetPrivateDnsResolverInboundEndpointTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverOutboundEndpointTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverTimeouts {
    read?: string;
}

export interface GetPrivateDnsResolverVirtualNetworkLinkTimeouts {
    read?: string;
}

export interface GetPrivateDnsSoaRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsSrvRecordRecord {
    port: number;
    priority: number;
    target: string;
    weight: number;
}

export interface GetPrivateDnsSrvRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsTxtRecordRecord {
    value: string;
}

export interface GetPrivateDnsTxtRecordTimeouts {
    read?: string;
}

export interface GetPrivateDnsZoneTimeouts {
    read?: string;
}

export interface GetPrivateDnsZoneVirtualNetworkLinkTimeouts {
    read?: string;
}

export interface GetPrivateEndpointConnectionNetworkInterface {
    id: string;
    name: string;
}

export interface GetPrivateEndpointConnectionPrivateServiceConnection {
    name: string;
    privateIpAddress: string;
    requestResponse: string;
    status: string;
}

export interface GetPrivateEndpointConnectionTimeouts {
    read?: string;
}

export interface GetPrivateLinkServiceEndpointConnectionsPrivateEndpointConnection {
    actionRequired: string;
    connectionId: string;
    connectionName: string;
    description: string;
    privateEndpointId: string;
    privateEndpointName: string;
    status: string;
}

export interface GetPrivateLinkServiceEndpointConnectionsTimeouts {
    read?: string;
}

export interface GetPrivateLinkServiceNatIpConfiguration {
    name: string;
    primary: boolean;
    privateIpAddress: string;
    privateIpAddressVersion: string;
    subnetId: string;
}

export interface GetPrivateLinkServiceTimeouts {
    read?: string;
}

export interface GetProximityPlacementGroupTimeouts {
    read?: string;
}

export interface GetPublicIpPrefixTimeouts {
    read?: string;
}

export interface GetPublicIpTimeouts {
    read?: string;
}

export interface GetPublicIpsPublicIp {
    domainNameLabel: string;
    fqdn: string;
    id: string;
    ipAddress: string;
    name: string;
}

export interface GetPublicIpsTimeouts {
    read?: string;
}

export interface GetPublicMaintenanceConfigurationsConfig {
    description: string;
    duration: string;
    id: string;
    location: string;
    maintenanceScope: string;
    name: string;
    recurEvery: string;
    timeZone: string;
}

export interface GetPublicMaintenanceConfigurationsTimeouts {
    read?: string;
}

export interface GetRecoveryServicesVaultIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetRecoveryServicesVaultTimeouts {
    read?: string;
}

export interface GetRedisCachePatchSchedule {
    dayOfWeek: string;
    maintenanceWindow: string;
    startHourUtc: number;
}

export interface GetRedisCacheRedisConfiguration {
    activeDirectoryAuthenticationEnabled: boolean;
    aofBackupEnabled: boolean;
    aofStorageConnectionString0: string;
    aofStorageConnectionString1: string;
    authenticationEnabled: boolean;
    dataPersistenceAuthenticationMethod: string;
    maxclients: number;
    maxfragmentationmemoryReserved: number;
    maxmemoryDelta: number;
    maxmemoryPolicy: string;
    maxmemoryReserved: number;
    notifyKeyspaceEvents: string;
    rdbBackupEnabled: boolean;
    rdbBackupFrequency: number;
    rdbBackupMaxSnapshotCount: number;
    rdbStorageConnectionString: string;
    storageAccountSubscriptionId: string;
}

export interface GetRedisCacheTimeouts {
    read?: string;
}

export interface GetRedisEnterpriseDatabaseTimeouts {
    read?: string;
}

export interface GetResourceGroupTemplateDeploymentTimeouts {
    read?: string;
}

export interface GetResourceGroupTimeouts {
    read?: string;
}

export interface GetResourcesResource {
    id: string;
    location: string;
    name: string;
    resourceGroupName: string;
    tags: {[key: string]: string};
    type: string;
}

export interface GetResourcesTimeouts {
    read?: string;
}

export interface GetRoleDefinitionPermission {
    actions: string[];
    condition: string;
    conditionVersion: string;
    dataActions: string[];
    notActions: string[];
    notDataActions: string[];
}

export interface GetRoleDefinitionTimeouts {
    read?: string;
}

export interface GetRoleManagementPolicyActivationRule {
    approvalStages: outputs.GetRoleManagementPolicyActivationRuleApprovalStage[];
    maximumDuration: string;
    requireApproval: boolean;
    requireJustification: boolean;
    requireMultifactorAuthentication: boolean;
    requireTicketInfo: boolean;
    requiredConditionalAccessAuthenticationContext: string;
}

export interface GetRoleManagementPolicyActivationRuleApprovalStage {
    primaryApprovers: outputs.GetRoleManagementPolicyActivationRuleApprovalStagePrimaryApprover[];
}

export interface GetRoleManagementPolicyActivationRuleApprovalStagePrimaryApprover {
    objectId: string;
    type: string;
}

export interface GetRoleManagementPolicyActiveAssignmentRule {
    expirationRequired: boolean;
    expireAfter: string;
    requireJustification: boolean;
    requireMultifactorAuthentication: boolean;
    requireTicketInfo: boolean;
}

export interface GetRoleManagementPolicyEligibleAssignmentRule {
    expirationRequired: boolean;
    expireAfter: string;
}

export interface GetRoleManagementPolicyNotificationRule {
    activeAssignments: outputs.GetRoleManagementPolicyNotificationRuleActiveAssignment[];
    eligibleActivations: outputs.GetRoleManagementPolicyNotificationRuleEligibleActivation[];
    eligibleAssignments: outputs.GetRoleManagementPolicyNotificationRuleEligibleAssignment[];
}

export interface GetRoleManagementPolicyNotificationRuleActiveAssignment {
    adminNotifications: outputs.GetRoleManagementPolicyNotificationRuleActiveAssignmentAdminNotification[];
    approverNotifications: outputs.GetRoleManagementPolicyNotificationRuleActiveAssignmentApproverNotification[];
    assigneeNotifications: outputs.GetRoleManagementPolicyNotificationRuleActiveAssignmentAssigneeNotification[];
}

export interface GetRoleManagementPolicyNotificationRuleActiveAssignmentAdminNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleActiveAssignmentApproverNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleActiveAssignmentAssigneeNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleActivation {
    adminNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleActivationAdminNotification[];
    approverNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleActivationApproverNotification[];
    assigneeNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleActivationAssigneeNotification[];
}

export interface GetRoleManagementPolicyNotificationRuleEligibleActivationAdminNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleActivationApproverNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleActivationAssigneeNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleAssignment {
    adminNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleAssignmentAdminNotification[];
    approverNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleAssignmentApproverNotification[];
    assigneeNotifications: outputs.GetRoleManagementPolicyNotificationRuleEligibleAssignmentAssigneeNotification[];
}

export interface GetRoleManagementPolicyNotificationRuleEligibleAssignmentAdminNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleAssignmentApproverNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyNotificationRuleEligibleAssignmentAssigneeNotification {
    additionalRecipients: string[];
    defaultRecipients: boolean;
    notificationLevel: string;
}

export interface GetRoleManagementPolicyTimeouts {
    read?: string;
}

export interface GetRouteFilterRule {
    access: string;
    communities: string[];
    name: string;
    ruleType: string;
}

export interface GetRouteFilterTimeouts {
    read?: string;
}

export interface GetRouteTableRoute {
    addressPrefix: string;
    name: string;
    nextHopInIpAddress: string;
    nextHopType: string;
}

export interface GetRouteTableTimeouts {
    read?: string;
}

export interface GetSearchServiceIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetSearchServiceQueryKey {
    key: string;
    name: string;
}

export interface GetSearchServiceTimeouts {
    read?: string;
}

export interface GetSentinelAlertRuleAnomalyMultiSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    values: string[];
}

export interface GetSentinelAlertRuleAnomalyPrioritizedExcludeObservation {
    description: string;
    exclude: string;
    name: string;
    prioritize: string;
}

export interface GetSentinelAlertRuleAnomalyRequiredDataConnector {
    connectorId: string;
    dataTypes: string[];
}

export interface GetSentinelAlertRuleAnomalySingleSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    value: string;
}

export interface GetSentinelAlertRuleAnomalyThresholdObservation {
    description: string;
    max: string;
    min: string;
    name: string;
    value: string;
}

export interface GetSentinelAlertRuleAnomalyTimeouts {
    read?: string;
}

export interface GetSentinelAlertRuleTemplateNrtTemplate {
    description: string;
    query: string;
    severity: string;
    tactics: string[];
}

export interface GetSentinelAlertRuleTemplateScheduledTemplate {
    description: string;
    query: string;
    queryFrequency: string;
    queryPeriod: string;
    severity: string;
    tactics: string[];
    triggerOperator: string;
    triggerThreshold: number;
}

export interface GetSentinelAlertRuleTemplateSecurityIncidentTemplate {
    description: string;
    productFilter: string;
}

export interface GetSentinelAlertRuleTemplateTimeouts {
    read?: string;
}

export interface GetSentinelAlertRuleTimeouts {
    read?: string;
}

export interface GetServicePlanTimeouts {
    read?: string;
}

export interface GetServicebusNamespaceAuthorizationRuleTimeouts {
    read?: string;
}

export interface GetServicebusNamespaceDisasterRecoveryConfigTimeouts {
    read?: string;
}

export interface GetServicebusNamespaceTimeouts {
    read?: string;
}

export interface GetServicebusQueueAuthorizationRuleTimeouts {
    read?: string;
}

export interface GetServicebusQueueTimeouts {
    read?: string;
}

export interface GetServicebusSubscriptionTimeouts {
    read?: string;
}

export interface GetServicebusTopicAuthorizationRuleTimeouts {
    read?: string;
}

export interface GetServicebusTopicTimeouts {
    read?: string;
}

export interface GetSharedImageGalleryTimeouts {
    read?: string;
}

export interface GetSharedImageIdentifier {
    offer: string;
    publisher: string;
    sku: string;
}

export interface GetSharedImagePurchasePlan {
    name: string;
    product: string;
    publisher: string;
}

export interface GetSharedImageTimeouts {
    read?: string;
}

export interface GetSharedImageVersionTargetRegion {
    name: string;
    regionalReplicaCount: number;
    storageAccountType: string;
}

export interface GetSharedImageVersionTimeouts {
    read?: string;
}

export interface GetSharedImageVersionsImage {
    excludeFromLatest: boolean;
    id: string;
    location: string;
    managedImageId: string;
    name: string;
    tags: {[key: string]: string};
    targetRegions: outputs.GetSharedImageVersionsImageTargetRegion[];
}

export interface GetSharedImageVersionsImageTargetRegion {
    name: string;
    regionalReplicaCount: number;
    storageAccountType: string;
}

export interface GetSharedImageVersionsTimeouts {
    read?: string;
}

export interface GetSignalrServiceTimeouts {
    read?: string;
}

export interface GetSiteRecoveryFabricTimeouts {
    read?: string;
}

export interface GetSiteRecoveryProtectionContainerTimeouts {
    read?: string;
}

export interface GetSiteRecoveryReplicationPolicyTimeouts {
    read?: string;
}

export interface GetSiteRecoveryReplicationRecoveryPlanAzureToAzureSetting {
    primaryEdgeZone: string;
    primaryZone: string;
    recoveryEdgeZone: string;
    recoveryZone: string;
}

export interface GetSiteRecoveryReplicationRecoveryPlanRecoveryGroup {
    postActions: outputs.GetSiteRecoveryReplicationRecoveryPlanRecoveryGroupPostAction[][];
    preActions: outputs.GetSiteRecoveryReplicationRecoveryPlanRecoveryGroupPreAction[][];
    replicatedProtectedItems: string[];
    type: string;
}

export interface GetSiteRecoveryReplicationRecoveryPlanRecoveryGroupPostAction {
    fabricLocation: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction: string;
    name: string;
    runbookId: string;
    scriptPath: string;
    type: string;
}

export interface GetSiteRecoveryReplicationRecoveryPlanRecoveryGroupPreAction {
    fabricLocation: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction: string;
    name: string;
    runbookId: string;
    scriptPath: string;
    type: string;
}

export interface GetSiteRecoveryReplicationRecoveryPlanTimeouts {
    read?: string;
}

export interface GetSnapshotEncryptionSetting {
    diskEncryptionKeys: outputs.GetSnapshotEncryptionSettingDiskEncryptionKey[];
    enabled: boolean;
    keyEncryptionKeys: outputs.GetSnapshotEncryptionSettingKeyEncryptionKey[];
}

export interface GetSnapshotEncryptionSettingDiskEncryptionKey {
    secretUrl: string;
    sourceVaultId: string;
}

export interface GetSnapshotEncryptionSettingKeyEncryptionKey {
    keyUrl: string;
    sourceVaultId: string;
}

export interface GetSnapshotTimeouts {
    read?: string;
}

export interface GetSourceControlTokenTimeouts {
    read?: string;
}

export interface GetSpatialAnchorsAccountTimeouts {
    read?: string;
}

export interface GetSpringCloudAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetSpringCloudAppPersistentDisk {
    mountPath: string;
    sizeInGb: number;
}

export interface GetSpringCloudAppTimeouts {
    read?: string;
}

export interface GetSpringCloudServiceConfigServerGitSetting {
    httpBasicAuths: outputs.GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth[];
    label: string;
    repositories: outputs.GetSpringCloudServiceConfigServerGitSettingRepository[];
    searchPaths: string[];
    sshAuths: outputs.GetSpringCloudServiceConfigServerGitSettingSshAuth[];
    uri: string;
}

export interface GetSpringCloudServiceConfigServerGitSettingHttpBasicAuth {
    password: string;
    username: string;
}

export interface GetSpringCloudServiceConfigServerGitSettingRepository {
    httpBasicAuths: outputs.GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth[];
    label: string;
    name: string;
    patterns: string[];
    searchPaths: string[];
    sshAuths: outputs.GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth[];
    uri: string;
}

export interface GetSpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
    password: string;
    username: string;
}

export interface GetSpringCloudServiceConfigServerGitSettingRepositorySshAuth {
    hostKey: string;
    hostKeyAlgorithm: string;
    privateKey: string;
    strictHostKeyCheckingEnabled: boolean;
}

export interface GetSpringCloudServiceConfigServerGitSettingSshAuth {
    hostKey: string;
    hostKeyAlgorithm: string;
    privateKey: string;
    strictHostKeyCheckingEnabled: boolean;
}

export interface GetSpringCloudServiceRequiredNetworkTrafficRule {
    direction: string;
    fqdns: string[];
    ipAddresses: string[];
    port: number;
    protocol: string;
}

export interface GetSpringCloudServiceTimeouts {
    read?: string;
}

export interface GetSshPublicKeyTimeouts {
    read?: string;
}

export interface GetStackHciClusterIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetStackHciClusterTimeouts {
    read?: string;
}

export interface GetStaticWebAppBasicAuth {
    environments: string;
}

export interface GetStaticWebAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetStaticWebAppTimeouts {
    read?: string;
}

export interface GetStorageAccountAzureFilesAuthentication {
    activeDirectories: outputs.GetStorageAccountAzureFilesAuthenticationActiveDirectory[];
    defaultShareLevelPermission: string;
    directoryType: string;
}

export interface GetStorageAccountAzureFilesAuthenticationActiveDirectory {
    domainGuid: string;
    domainName: string;
    domainSid: string;
    forestName: string;
    netbiosDomainName: string;
    storageSid: string;
}

export interface GetStorageAccountBlobContainerSasPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    read: boolean;
    write: boolean;
}

export interface GetStorageAccountBlobContainerSasTimeouts {
    read?: string;
}

export interface GetStorageAccountCustomDomain {
    name: string;
}

export interface GetStorageAccountIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetStorageAccountSasPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    filter: boolean;
    list: boolean;
    process: boolean;
    read: boolean;
    tag: boolean;
    update: boolean;
    write: boolean;
}

export interface GetStorageAccountSasResourceTypes {
    container: boolean;
    object: boolean;
    service: boolean;
}

export interface GetStorageAccountSasServices {
    blob: boolean;
    file: boolean;
    queue: boolean;
    table: boolean;
}

export interface GetStorageAccountSasTimeouts {
    read?: string;
}

export interface GetStorageAccountTimeouts {
    read?: string;
}

export interface GetStorageBlobTimeouts {
    read?: string;
}

export interface GetStorageContainerTimeouts {
    read?: string;
}

export interface GetStorageContainersContainer {
    dataPlaneId: string;
    name: string;
    resourceManagerId: string;
}

export interface GetStorageContainersTimeouts {
    read?: string;
}

export interface GetStorageEncryptionScopeTimeouts {
    read?: string;
}

export interface GetStorageManagementPolicyRule {
    actions: outputs.GetStorageManagementPolicyRuleAction[];
    enabled: boolean;
    filters: outputs.GetStorageManagementPolicyRuleFilter[];
    name: string;
}

export interface GetStorageManagementPolicyRuleAction {
    baseBlobs: outputs.GetStorageManagementPolicyRuleActionBaseBlob[];
    snapshots: outputs.GetStorageManagementPolicyRuleActionSnapshot[];
    versions: outputs.GetStorageManagementPolicyRuleActionVersion[];
}

export interface GetStorageManagementPolicyRuleActionBaseBlob {
    autoTierToHotFromCoolEnabled: boolean;
    deleteAfterDaysSinceCreationGreaterThan: number;
    deleteAfterDaysSinceLastAccessTimeGreaterThan: number;
    deleteAfterDaysSinceModificationGreaterThan: number;
    tierToArchiveAfterDaysSinceCreationGreaterThan: number;
    tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
    tierToArchiveAfterDaysSinceModificationGreaterThan: number;
    tierToColdAfterDaysSinceCreationGreaterThan: number;
    tierToColdAfterDaysSinceLastAccessTimeGreaterThan: number;
    tierToColdAfterDaysSinceModificationGreaterThan: number;
    tierToCoolAfterDaysSinceCreationGreaterThan: number;
    tierToCoolAfterDaysSinceLastAccessTimeGreaterThan: number;
    tierToCoolAfterDaysSinceModificationGreaterThan: number;
}

export interface GetStorageManagementPolicyRuleActionSnapshot {
    changeTierToArchiveAfterDaysSinceCreation: number;
    changeTierToCoolAfterDaysSinceCreation: number;
    deleteAfterDaysSinceCreationGreaterThan: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
    tierToColdAfterDaysSinceCreationGreaterThan: number;
}

export interface GetStorageManagementPolicyRuleActionVersion {
    changeTierToArchiveAfterDaysSinceCreation: number;
    changeTierToCoolAfterDaysSinceCreation: number;
    deleteAfterDaysSinceCreation: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan: number;
    tierToColdAfterDaysSinceCreationGreaterThan: number;
}

export interface GetStorageManagementPolicyRuleFilter {
    blobTypes: string[];
    matchBlobIndexTags: outputs.GetStorageManagementPolicyRuleFilterMatchBlobIndexTag[];
    prefixMatches: string[];
}

export interface GetStorageManagementPolicyRuleFilterMatchBlobIndexTag {
    name: string;
    operation: string;
    value: string;
}

export interface GetStorageManagementPolicyTimeouts {
    read?: string;
}

export interface GetStorageQueueTimeouts {
    read?: string;
}

export interface GetStorageShareAcl {
    accessPolicies: outputs.GetStorageShareAclAccessPolicy[];
    id: string;
}

export interface GetStorageShareAclAccessPolicy {
    expiry: string;
    permissions: string;
    start: string;
}

export interface GetStorageShareTimeouts {
    read?: string;
}

export interface GetStorageSyncGroupTimeouts {
    read?: string;
}

export interface GetStorageSyncTimeouts {
    read?: string;
}

export interface GetStorageTableAcl {
    accessPolicies: outputs.GetStorageTableAclAccessPolicy[];
    id: string;
}

export interface GetStorageTableAclAccessPolicy {
    expiry: string;
    permissions: string;
    start: string;
}

export interface GetStorageTableEntitiesItem {
    partitionKey: string;
    properties: {[key: string]: string};
    rowKey: string;
}

export interface GetStorageTableEntitiesTimeouts {
    read?: string;
}

export interface GetStorageTableEntityTimeouts {
    read?: string;
}

export interface GetStorageTableTimeouts {
    read?: string;
}

export interface GetStreamAnalyticsJobIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetStreamAnalyticsJobTimeouts {
    read?: string;
}

export interface GetSubnetTimeouts {
    read?: string;
}

export interface GetSubscriptionTemplateDeploymentTimeouts {
    read?: string;
}

export interface GetSubscriptionTimeouts {
    read?: string;
}

export interface GetSubscriptionsSubscription {
    displayName: string;
    id: string;
    locationPlacementId: string;
    quotaId: string;
    spendingLimit: string;
    state: string;
    subscriptionId: string;
    tags: {[key: string]: string};
    tenantId: string;
}

export interface GetSubscriptionsTimeouts {
    read?: string;
}

export interface GetSynapseWorkspaceIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetSynapseWorkspaceTimeouts {
    read?: string;
}

export interface GetSystemCenterVirtualMachineManagerInventoryItemsInventoryItem {
    id: string;
    name: string;
    uuid: string;
}

export interface GetSystemCenterVirtualMachineManagerInventoryItemsTimeouts {
    read?: string;
}

export interface GetTemplateSpecVersionTimeouts {
    read?: string;
}

export interface GetTenantTemplateDeploymentTimeouts {
    read?: string;
}

export interface GetTrafficManagerGeographicalLocationTimeouts {
    read?: string;
}

export interface GetTrafficManagerProfileDnsConfig {
    relativeName: string;
    ttl: number;
}

export interface GetTrafficManagerProfileMonitorConfig {
    customHeaders: outputs.GetTrafficManagerProfileMonitorConfigCustomHeader[];
    expectedStatusCodeRanges: string[];
    intervalInSeconds: number;
    path: string;
    port: number;
    protocol: string;
    timeoutInSeconds: number;
    toleratedNumberOfFailures: number;
}

export interface GetTrafficManagerProfileMonitorConfigCustomHeader {
    name: string;
    value: string;
}

export interface GetTrafficManagerProfileTimeouts {
    read?: string;
}

export interface GetUserAssignedIdentityTimeouts {
    read?: string;
}

export interface GetVirtualDesktopApplicationGroupTimeouts {
    read?: string;
}

export interface GetVirtualDesktopHostPoolScheduledAgentUpdate {
    enabled: boolean;
    schedules: outputs.GetVirtualDesktopHostPoolScheduledAgentUpdateSchedule[];
    timezone: string;
    useSessionHostTimezone: boolean;
}

export interface GetVirtualDesktopHostPoolScheduledAgentUpdateSchedule {
    dayOfWeek: string;
    hourOfDay: number;
}

export interface GetVirtualDesktopHostPoolTimeouts {
    read?: string;
}

export interface GetVirtualDesktopWorkspaceTimeouts {
    read?: string;
}

export interface GetVirtualHubConnectionRouting {
    associatedRouteTableId: string;
    inboundRouteMapId: string;
    outboundRouteMapId: string;
    propagatedRouteTables: outputs.GetVirtualHubConnectionRoutingPropagatedRouteTable[];
    staticVnetLocalRouteOverrideCriteria: string;
    staticVnetRoutes: outputs.GetVirtualHubConnectionRoutingStaticVnetRoute[];
}

export interface GetVirtualHubConnectionRoutingPropagatedRouteTable {
    labels: string[];
    routeTableIds: string[];
}

export interface GetVirtualHubConnectionRoutingStaticVnetRoute {
    addressPrefixes: string[];
    name: string;
    nextHopIpAddress: string;
}

export interface GetVirtualHubConnectionTimeouts {
    read?: string;
}

export interface GetVirtualHubRouteTableRoute {
    destinations: string[];
    destinationsType: string;
    name: string;
    nextHop: string;
    nextHopType: string;
}

export interface GetVirtualHubRouteTableTimeouts {
    read?: string;
}

export interface GetVirtualHubTimeouts {
    read?: string;
}

export interface GetVirtualMachineIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetVirtualMachineScaleSetIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetVirtualMachineScaleSetInstance {
    computerName: string;
    instanceId: string;
    latestModelApplied: boolean;
    name: string;
    powerState: string;
    privateIpAddress: string;
    privateIpAddresses: string[];
    publicIpAddress: string;
    publicIpAddresses: string[];
    virtualMachineId: string;
    zone: string;
}

export interface GetVirtualMachineScaleSetNetworkInterface {
    dnsServers: string[];
    enableAcceleratedNetworking: boolean;
    enableIpForwarding: boolean;
    ipConfigurations: outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
    name: string;
    networkSecurityGroupId: string;
    primary: boolean;
}

export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolIds: string[];
    applicationSecurityGroupIds: string[];
    loadBalancerBackendAddressPoolIds: string[];
    loadBalancerInboundNatRulesIds: string[];
    name: string;
    primary: boolean;
    publicIpAddresses: outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
    subnetId: string;
    version: string;
}

export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
    domainNameLabel: string;
    idleTimeoutInMinutes: number;
    ipTags: outputs.GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
    name: string;
    publicIpPrefixId: string;
    version: string;
}

export interface GetVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
    tag: string;
    type: string;
}

export interface GetVirtualMachineScaleSetTimeouts {
    read?: string;
}

export interface GetVirtualMachineTimeouts {
    read?: string;
}

export interface GetVirtualNetworkGatewayBgpSetting {
    asn: number;
    peerWeight: number;
    peeringAddress: string;
}

export interface GetVirtualNetworkGatewayConnectionIpsecPolicy {
    dhGroup: string;
    ikeEncryption: string;
    ikeIntegrity: string;
    ipsecEncryption: string;
    ipsecIntegrity: string;
    pfsGroup: string;
    saDatasize: number;
    saLifetime: number;
}

export interface GetVirtualNetworkGatewayConnectionTimeouts {
    read?: string;
}

export interface GetVirtualNetworkGatewayConnectionTrafficSelectorPolicy {
    localAddressCidrs: string[];
    remoteAddressCidrs: string[];
}

export interface GetVirtualNetworkGatewayCustomRoute {
    addressPrefixes: string[];
}

export interface GetVirtualNetworkGatewayIpConfiguration {
    id: string;
    name: string;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface GetVirtualNetworkGatewayTimeouts {
    read?: string;
}

export interface GetVirtualNetworkGatewayVpnClientConfiguration {
    aadAudience: string;
    aadIssuer: string;
    aadTenant: string;
    addressSpaces: string[];
    radiusServerAddress: string;
    radiusServerSecret: string;
    revokedCertificates: outputs.GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
    rootCertificates: outputs.GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
    vpnClientProtocols: string[];
}

export interface GetVirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
    name: string;
    thumbprint: string;
}

export interface GetVirtualNetworkGatewayVpnClientConfigurationRootCertificate {
    name: string;
    publicCertData: string;
}

export interface GetVirtualNetworkTimeouts {
    read?: string;
}

export interface GetVirtualWanTimeouts {
    read?: string;
}

export interface GetVmwarePrivateCloudCircuit {
    expressRouteId: string;
    expressRoutePrivatePeeringId: string;
    primarySubnetCidr: string;
    secondarySubnetCidr: string;
}

export interface GetVmwarePrivateCloudManagementCluster {
    hosts: string[];
    id: number;
    size: number;
}

export interface GetVmwarePrivateCloudTimeouts {
    read?: string;
}

export interface GetVpnGatewayBgpSetting {
    asn: number;
    bgpPeeringAddress: string;
    instance0BgpPeeringAddresses: outputs.GetVpnGatewayBgpSettingInstance0BgpPeeringAddress[];
    instance1BgpPeeringAddresses: outputs.GetVpnGatewayBgpSettingInstance1BgpPeeringAddress[];
    peerWeight: number;
}

export interface GetVpnGatewayBgpSettingInstance0BgpPeeringAddress {
    customIps: string[];
    defaultIps: string[];
    ipConfigurationId: string;
    tunnelIps: string[];
}

export interface GetVpnGatewayBgpSettingInstance1BgpPeeringAddress {
    customIps: string[];
    defaultIps: string[];
    ipConfigurationId: string;
    tunnelIps: string[];
}

export interface GetVpnGatewayTimeouts {
    read?: string;
}

export interface GetWebApplicationFirewallPolicyTimeouts {
    read?: string;
}

export interface GetWebPubsubPrivateLinkResourceSharedPrivateLinkResourceType {
    description: string;
    subresourceName: string;
}

export interface GetWebPubsubPrivateLinkResourceTimeouts {
    read?: string;
}

export interface GetWebPubsubTimeouts {
    read?: string;
}

export interface GetWindowsFunctionAppAuthSetting {
    activeDirectories: outputs.GetWindowsFunctionAppAuthSettingActiveDirectory[];
    additionalLoginParameters: {[key: string]: string};
    allowedExternalRedirectUrls: string[];
    defaultProvider: string;
    enabled: boolean;
    facebooks: outputs.GetWindowsFunctionAppAuthSettingFacebook[];
    githubs: outputs.GetWindowsFunctionAppAuthSettingGithub[];
    googles: outputs.GetWindowsFunctionAppAuthSettingGoogle[];
    issuer: string;
    microsofts: outputs.GetWindowsFunctionAppAuthSettingMicrosoft[];
    runtimeVersion: string;
    tokenRefreshExtensionHours: number;
    tokenStoreEnabled: boolean;
    twitters: outputs.GetWindowsFunctionAppAuthSettingTwitter[];
    unauthenticatedClientAction: string;
}

export interface GetWindowsFunctionAppAuthSettingActiveDirectory {
    allowedAudiences: string[];
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
}

export interface GetWindowsFunctionAppAuthSettingFacebook {
    appId: string;
    appSecret: string;
    appSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingGithub {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingGoogle {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingMicrosoft {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingTwitter {
    consumerKey: string;
    consumerSecret: string;
    consumerSecretSettingName: string;
}

export interface GetWindowsFunctionAppAuthSettingsV2 {
    activeDirectoryV2s: outputs.GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2[];
    appleV2s: outputs.GetWindowsFunctionAppAuthSettingsV2AppleV2[];
    authEnabled: boolean;
    azureStaticWebAppV2s: outputs.GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2[];
    configFilePath: string;
    customOidcV2s: outputs.GetWindowsFunctionAppAuthSettingsV2CustomOidcV2[];
    defaultProvider: string;
    excludedPaths: string[];
    facebookV2s: outputs.GetWindowsFunctionAppAuthSettingsV2FacebookV2[];
    forwardProxyConvention: string;
    forwardProxyCustomHostHeaderName: string;
    forwardProxyCustomSchemeHeaderName: string;
    githubV2s: outputs.GetWindowsFunctionAppAuthSettingsV2GithubV2[];
    googleV2s: outputs.GetWindowsFunctionAppAuthSettingsV2GoogleV2[];
    httpRouteApiPrefix: string;
    logins: outputs.GetWindowsFunctionAppAuthSettingsV2Login[];
    microsoftV2s: outputs.GetWindowsFunctionAppAuthSettingsV2MicrosoftV2[];
    requireAuthentication: boolean;
    requireHttps: boolean;
    runtimeVersion: string;
    twitterV2s: outputs.GetWindowsFunctionAppAuthSettingsV2TwitterV2[];
    unauthenticatedAction: string;
}

export interface GetWindowsFunctionAppAuthSettingsV2ActiveDirectoryV2 {
    allowedApplications: string[];
    allowedAudiences: string[];
    allowedGroups: string[];
    allowedIdentities: string[];
    clientId: string;
    clientSecretCertificateThumbprint: string;
    clientSecretSettingName: string;
    jwtAllowedClientApplications: string[];
    jwtAllowedGroups: string[];
    loginParameters: {[key: string]: string};
    tenantAuthEndpoint: string;
    wwwAuthenticationDisabled: boolean;
}

export interface GetWindowsFunctionAppAuthSettingsV2AppleV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
    clientId: string;
}

export interface GetWindowsFunctionAppAuthSettingsV2CustomOidcV2 {
    authorisationEndpoint: string;
    certificationUri: string;
    clientCredentialMethod: string;
    clientId: string;
    clientSecretSettingName: string;
    issuerEndpoint: string;
    name: string;
    nameClaimType: string;
    openidConfigurationEndpoint: string;
    scopes: string[];
    tokenEndpoint: string;
}

export interface GetWindowsFunctionAppAuthSettingsV2FacebookV2 {
    appId: string;
    appSecretSettingName: string;
    graphApiVersion: string;
    loginScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingsV2GithubV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingsV2GoogleV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingsV2Login {
    allowedExternalRedirectUrls: string[];
    cookieExpirationConvention: string;
    cookieExpirationTime: string;
    logoutEndpoint: string;
    nonceExpirationTime: string;
    preserveUrlFragmentsForLogins: boolean;
    tokenRefreshExtensionTime: number;
    tokenStoreEnabled: boolean;
    tokenStorePath: string;
    tokenStoreSasSettingName: string;
    validateNonce: boolean;
}

export interface GetWindowsFunctionAppAuthSettingsV2MicrosoftV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsFunctionAppAuthSettingsV2TwitterV2 {
    consumerKey: string;
    consumerSecretSettingName: string;
}

export interface GetWindowsFunctionAppBackup {
    enabled: boolean;
    name: string;
    schedules: outputs.GetWindowsFunctionAppBackupSchedule[];
    storageAccountUrl: string;
}

export interface GetWindowsFunctionAppBackupSchedule {
    frequencyInterval: number;
    frequencyUnit: string;
    keepAtLeastOneBackup: boolean;
    lastExecutionTime: string;
    retentionPeriodDays: number;
    startTime: string;
}

export interface GetWindowsFunctionAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetWindowsFunctionAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetWindowsFunctionAppSiteConfig {
    alwaysOn: boolean;
    apiDefinitionUrl: string;
    apiManagementApiId: string;
    appCommandLine: string;
    appScaleLimit: number;
    appServiceLogs: outputs.GetWindowsFunctionAppSiteConfigAppServiceLog[];
    applicationInsightsConnectionString: string;
    applicationInsightsKey: string;
    applicationStacks: outputs.GetWindowsFunctionAppSiteConfigApplicationStack[];
    cors: outputs.GetWindowsFunctionAppSiteConfigCor[];
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckEvictionTimeInMin: number;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictionDefaultAction: string;
    ipRestrictions: outputs.GetWindowsFunctionAppSiteConfigIpRestriction[];
    loadBalancingMode: string;
    managedPipelineMode: string;
    minimumTlsVersion: string;
    preWarmedInstanceCount: number;
    remoteDebuggingEnabled: boolean;
    remoteDebuggingVersion: string;
    runtimeScaleMonitoringEnabled: boolean;
    scmIpRestrictionDefaultAction: string;
    scmIpRestrictions: outputs.GetWindowsFunctionAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorker: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    windowsFxVersion: string;
    workerCount: number;
}

export interface GetWindowsFunctionAppSiteConfigAppServiceLog {
    diskQuotaMb: number;
    retentionPeriodDays: number;
}

export interface GetWindowsFunctionAppSiteConfigApplicationStack {
    dotnetVersion: string;
    javaVersion: string;
    nodeVersion: string;
    powershellCoreVersion: string;
    useCustomRuntime: boolean;
    useDotnetIsolatedRuntime: boolean;
}

export interface GetWindowsFunctionAppSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetWindowsFunctionAppSiteConfigIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetWindowsFunctionAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetWindowsFunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetWindowsFunctionAppSiteConfigScmIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetWindowsFunctionAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetWindowsFunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetWindowsFunctionAppSiteCredential {
    name: string;
    password: string;
}

export interface GetWindowsFunctionAppStickySetting {
    appSettingNames: string[];
    connectionStringNames: string[];
}

export interface GetWindowsFunctionAppTimeouts {
    read?: string;
}

export interface GetWindowsWebAppAuthSetting {
    activeDirectories: outputs.GetWindowsWebAppAuthSettingActiveDirectory[];
    additionalLoginParameters: {[key: string]: string};
    allowedExternalRedirectUrls: string[];
    defaultProvider: string;
    enabled: boolean;
    facebooks: outputs.GetWindowsWebAppAuthSettingFacebook[];
    githubs: outputs.GetWindowsWebAppAuthSettingGithub[];
    googles: outputs.GetWindowsWebAppAuthSettingGoogle[];
    issuer: string;
    microsofts: outputs.GetWindowsWebAppAuthSettingMicrosoft[];
    runtimeVersion: string;
    tokenRefreshExtensionHours: number;
    tokenStoreEnabled: boolean;
    twitters: outputs.GetWindowsWebAppAuthSettingTwitter[];
    unauthenticatedClientAction: string;
}

export interface GetWindowsWebAppAuthSettingActiveDirectory {
    allowedAudiences: string[];
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
}

export interface GetWindowsWebAppAuthSettingFacebook {
    appId: string;
    appSecret: string;
    appSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsWebAppAuthSettingGithub {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsWebAppAuthSettingGoogle {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsWebAppAuthSettingMicrosoft {
    clientId: string;
    clientSecret: string;
    clientSecretSettingName: string;
    oauthScopes: string[];
}

export interface GetWindowsWebAppAuthSettingTwitter {
    consumerKey: string;
    consumerSecret: string;
    consumerSecretSettingName: string;
}

export interface GetWindowsWebAppAuthSettingsV2 {
    activeDirectoryV2s: outputs.GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2[];
    appleV2s: outputs.GetWindowsWebAppAuthSettingsV2AppleV2[];
    authEnabled: boolean;
    azureStaticWebAppV2s: outputs.GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2[];
    configFilePath: string;
    customOidcV2s: outputs.GetWindowsWebAppAuthSettingsV2CustomOidcV2[];
    defaultProvider: string;
    excludedPaths: string[];
    facebookV2s: outputs.GetWindowsWebAppAuthSettingsV2FacebookV2[];
    forwardProxyConvention: string;
    forwardProxyCustomHostHeaderName: string;
    forwardProxyCustomSchemeHeaderName: string;
    githubV2s: outputs.GetWindowsWebAppAuthSettingsV2GithubV2[];
    googleV2s: outputs.GetWindowsWebAppAuthSettingsV2GoogleV2[];
    httpRouteApiPrefix: string;
    logins: outputs.GetWindowsWebAppAuthSettingsV2Login[];
    microsoftV2s: outputs.GetWindowsWebAppAuthSettingsV2MicrosoftV2[];
    requireAuthentication: boolean;
    requireHttps: boolean;
    runtimeVersion: string;
    twitterV2s: outputs.GetWindowsWebAppAuthSettingsV2TwitterV2[];
    unauthenticatedAction: string;
}

export interface GetWindowsWebAppAuthSettingsV2ActiveDirectoryV2 {
    allowedApplications: string[];
    allowedAudiences: string[];
    allowedGroups: string[];
    allowedIdentities: string[];
    clientId: string;
    clientSecretCertificateThumbprint: string;
    clientSecretSettingName: string;
    jwtAllowedClientApplications: string[];
    jwtAllowedGroups: string[];
    loginParameters: {[key: string]: string};
    tenantAuthEndpoint: string;
    wwwAuthenticationDisabled: boolean;
}

export interface GetWindowsWebAppAuthSettingsV2AppleV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsWebAppAuthSettingsV2AzureStaticWebAppV2 {
    clientId: string;
}

export interface GetWindowsWebAppAuthSettingsV2CustomOidcV2 {
    authorisationEndpoint: string;
    certificationUri: string;
    clientCredentialMethod: string;
    clientId: string;
    clientSecretSettingName: string;
    issuerEndpoint: string;
    name: string;
    nameClaimType: string;
    openidConfigurationEndpoint: string;
    scopes: string[];
    tokenEndpoint: string;
}

export interface GetWindowsWebAppAuthSettingsV2FacebookV2 {
    appId: string;
    appSecretSettingName: string;
    graphApiVersion: string;
    loginScopes: string[];
}

export interface GetWindowsWebAppAuthSettingsV2GithubV2 {
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsWebAppAuthSettingsV2GoogleV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsWebAppAuthSettingsV2Login {
    allowedExternalRedirectUrls: string[];
    cookieExpirationConvention: string;
    cookieExpirationTime: string;
    logoutEndpoint: string;
    nonceExpirationTime: string;
    preserveUrlFragmentsForLogins: boolean;
    tokenRefreshExtensionTime: number;
    tokenStoreEnabled: boolean;
    tokenStorePath: string;
    tokenStoreSasSettingName: string;
    validateNonce: boolean;
}

export interface GetWindowsWebAppAuthSettingsV2MicrosoftV2 {
    allowedAudiences: string[];
    clientId: string;
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface GetWindowsWebAppAuthSettingsV2TwitterV2 {
    consumerKey: string;
    consumerSecretSettingName: string;
}

export interface GetWindowsWebAppBackup {
    enabled: boolean;
    name: string;
    schedules: outputs.GetWindowsWebAppBackupSchedule[];
    storageAccountUrl: string;
}

export interface GetWindowsWebAppBackupSchedule {
    frequencyInterval: number;
    frequencyUnit: string;
    keepAtLeastOneBackup: boolean;
    lastExecutionTime: string;
    retentionPeriodDays: number;
    startTime: string;
}

export interface GetWindowsWebAppConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface GetWindowsWebAppIdentity {
    identityIds: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface GetWindowsWebAppLog {
    applicationLogs: outputs.GetWindowsWebAppLogApplicationLog[];
    detailedErrorMessages: boolean;
    failedRequestTracing: boolean;
    httpLogs: outputs.GetWindowsWebAppLogHttpLog[];
}

export interface GetWindowsWebAppLogApplicationLog {
    azureBlobStorages: outputs.GetWindowsWebAppLogApplicationLogAzureBlobStorage[];
    fileSystemLevel: string;
}

export interface GetWindowsWebAppLogApplicationLogAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface GetWindowsWebAppLogHttpLog {
    azureBlobStorages: outputs.GetWindowsWebAppLogHttpLogAzureBlobStorage[];
    fileSystems: outputs.GetWindowsWebAppLogHttpLogFileSystem[];
}

export interface GetWindowsWebAppLogHttpLogAzureBlobStorage {
    retentionInDays: number;
    sasUrl: string;
}

export interface GetWindowsWebAppLogHttpLogFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface GetWindowsWebAppSiteConfig {
    alwaysOn: boolean;
    apiDefinitionUrl: string;
    apiManagementApiId: string;
    appCommandLine: string;
    applicationStacks: outputs.GetWindowsWebAppSiteConfigApplicationStack[];
    autoHealSettings: outputs.GetWindowsWebAppSiteConfigAutoHealSetting[];
    containerRegistryManagedIdentityClientId: string;
    containerRegistryUseManagedIdentity: boolean;
    cors: outputs.GetWindowsWebAppSiteConfigCor[];
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState: string;
    handlerMappings: outputs.GetWindowsWebAppSiteConfigHandlerMapping[];
    healthCheckEvictionTimeInMin: number;
    healthCheckPath: string;
    http2Enabled: boolean;
    ipRestrictionDefaultAction: string;
    ipRestrictions: outputs.GetWindowsWebAppSiteConfigIpRestriction[];
    loadBalancingMode: string;
    localMysqlEnabled: boolean;
    managedPipelineMode: string;
    minimumTlsVersion: string;
    remoteDebuggingEnabled: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction: string;
    scmIpRestrictions: outputs.GetWindowsWebAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction: boolean;
    use32BitWorker: boolean;
    virtualApplications: outputs.GetWindowsWebAppSiteConfigVirtualApplication[];
    vnetRouteAllEnabled: boolean;
    websocketsEnabled: boolean;
    windowsFxVersion: string;
    workerCount: number;
}

export interface GetWindowsWebAppSiteConfigApplicationStack {
    currentStack: string;
    dockerImageName: string;
    dockerRegistryPassword: string;
    dockerRegistryUrl: string;
    dockerRegistryUsername: string;
    dotnetCoreVersion: string;
    dotnetVersion: string;
    javaContainer: string;
    javaContainerVersion: string;
    javaEmbeddedServerEnabled: boolean;
    javaVersion: string;
    nodeVersion: string;
    phpVersion: string;
    python: boolean;
    pythonVersion: string;
    tomcatVersion: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSetting {
    actions: outputs.GetWindowsWebAppSiteConfigAutoHealSettingAction[];
    triggers: outputs.GetWindowsWebAppSiteConfigAutoHealSettingTrigger[];
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingAction {
    actionType: string;
    customActions: outputs.GetWindowsWebAppSiteConfigAutoHealSettingActionCustomAction[];
    minimumProcessExecutionTime: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingActionCustomAction {
    executable: string;
    parameters: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingTrigger {
    privateMemoryKb: number;
    requests: outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequest[];
    slowRequestWithPaths: outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    slowRequests: outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest[];
    statusCodes: outputs.GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerRequest {
    count: number;
    interval: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path: string;
    timeTaken: string;
}

export interface GetWindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path: string;
    statusCodeRange: string;
    subStatus: number;
    win32StatusCode: number;
}

export interface GetWindowsWebAppSiteConfigCor {
    allowedOrigins: string[];
    supportCredentials: boolean;
}

export interface GetWindowsWebAppSiteConfigHandlerMapping {
    arguments: string;
    extension: string;
    scriptProcessorPath: string;
}

export interface GetWindowsWebAppSiteConfigIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetWindowsWebAppSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetWindowsWebAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetWindowsWebAppSiteConfigScmIpRestriction {
    action: string;
    description: string;
    headers: outputs.GetWindowsWebAppSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface GetWindowsWebAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface GetWindowsWebAppSiteConfigVirtualApplication {
    physicalPath: string;
    preload: boolean;
    virtualDirectories: outputs.GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectory[];
    virtualPath: string;
}

export interface GetWindowsWebAppSiteConfigVirtualApplicationVirtualDirectory {
    physicalPath: string;
    virtualPath: string;
}

export interface GetWindowsWebAppSiteCredential {
    name: string;
    password: string;
}

export interface GetWindowsWebAppStickySetting {
    appSettingNames: string[];
    connectionStringNames: string[];
}

export interface GetWindowsWebAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath: string;
    name: string;
    shareName: string;
    type: string;
}

export interface GetWindowsWebAppTimeouts {
    read?: string;
}

export interface GraphServicesAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HdinsightHadoopClusterComponentVersion {
    hadoop: string;
}

export interface HdinsightHadoopClusterComputeIsolation {
    computeIsolationEnabled?: boolean;
    hostSku?: string;
}

export interface HdinsightHadoopClusterDiskEncryption {
    encryptionAlgorithm?: string;
    encryptionAtHostEnabled?: boolean;
    keyVaultKeyId?: string;
    keyVaultManagedIdentityId?: string;
}

export interface HdinsightHadoopClusterExtension {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightHadoopClusterGateway {
    password: string;
    username: string;
}

export interface HdinsightHadoopClusterMetastores {
    ambari?: outputs.HdinsightHadoopClusterMetastoresAmbari;
    hive?: outputs.HdinsightHadoopClusterMetastoresHive;
    oozie?: outputs.HdinsightHadoopClusterMetastoresOozie;
}

export interface HdinsightHadoopClusterMetastoresAmbari {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHadoopClusterMetastoresHive {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHadoopClusterMetastoresOozie {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHadoopClusterMonitor {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightHadoopClusterNetwork {
    connectionDirection?: string;
    privateLinkEnabled?: boolean;
}

export interface HdinsightHadoopClusterPrivateLinkConfiguration {
    groupId: string;
    ipConfiguration: outputs.HdinsightHadoopClusterPrivateLinkConfigurationIpConfiguration;
    name: string;
}

export interface HdinsightHadoopClusterPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary?: boolean;
    privateIpAddress?: string;
    privateIpAllocationMethod?: string;
    subnetId?: string;
}

export interface HdinsightHadoopClusterRoles {
    edgeNode?: outputs.HdinsightHadoopClusterRolesEdgeNode;
    headNode: outputs.HdinsightHadoopClusterRolesHeadNode;
    workerNode: outputs.HdinsightHadoopClusterRolesWorkerNode;
    zookeeperNode: outputs.HdinsightHadoopClusterRolesZookeeperNode;
}

export interface HdinsightHadoopClusterRolesEdgeNode {
    httpsEndpoints?: outputs.HdinsightHadoopClusterRolesEdgeNodeHttpsEndpoint[];
    installScriptActions: outputs.HdinsightHadoopClusterRolesEdgeNodeInstallScriptAction[];
    targetInstanceCount: number;
    uninstallScriptActions?: outputs.HdinsightHadoopClusterRolesEdgeNodeUninstallScriptAction[];
    vmSize: string;
}

export interface HdinsightHadoopClusterRolesEdgeNodeHttpsEndpoint {
    accessModes?: string[];
    destinationPort?: number;
    disableGatewayAuth?: boolean;
    privateIpAddress?: string;
    subDomainSuffix?: string;
}

export interface HdinsightHadoopClusterRolesEdgeNodeInstallScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHadoopClusterRolesEdgeNodeUninstallScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHadoopClusterRolesHeadNode {
    password?: string;
    scriptActions?: outputs.HdinsightHadoopClusterRolesHeadNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHadoopClusterRolesHeadNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHadoopClusterRolesWorkerNode {
    autoscale?: outputs.HdinsightHadoopClusterRolesWorkerNodeAutoscale;
    password?: string;
    scriptActions?: outputs.HdinsightHadoopClusterRolesWorkerNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    targetInstanceCount: number;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHadoopClusterRolesWorkerNodeAutoscale {
    capacity?: outputs.HdinsightHadoopClusterRolesWorkerNodeAutoscaleCapacity;
    recurrence?: outputs.HdinsightHadoopClusterRolesWorkerNodeAutoscaleRecurrence;
}

export interface HdinsightHadoopClusterRolesWorkerNodeAutoscaleCapacity {
    maxInstanceCount: number;
    minInstanceCount: number;
}

export interface HdinsightHadoopClusterRolesWorkerNodeAutoscaleRecurrence {
    schedules: outputs.HdinsightHadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
    timezone: string;
}

export interface HdinsightHadoopClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
    days: string[];
    targetInstanceCount: number;
    time: string;
}

export interface HdinsightHadoopClusterRolesWorkerNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHadoopClusterRolesZookeeperNode {
    password?: string;
    scriptActions?: outputs.HdinsightHadoopClusterRolesZookeeperNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHadoopClusterRolesZookeeperNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHadoopClusterSecurityProfile {
    aaddsResourceId: string;
    clusterUsersGroupDns?: string[];
    domainName: string;
    domainUserPassword: string;
    domainUsername: string;
    ldapsUrls: string[];
    msiResourceId: string;
}

export interface HdinsightHadoopClusterStorageAccount {
    isDefault: boolean;
    storageAccountKey: string;
    storageContainerId: string;
    storageResourceId?: string;
}

export interface HdinsightHadoopClusterStorageAccountGen2 {
    filesystemId: string;
    isDefault: boolean;
    managedIdentityResourceId: string;
    storageResourceId: string;
}

export interface HdinsightHadoopClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HdinsightHbaseClusterComponentVersion {
    hbase: string;
}

export interface HdinsightHbaseClusterComputeIsolation {
    computeIsolationEnabled?: boolean;
    hostSku?: string;
}

export interface HdinsightHbaseClusterDiskEncryption {
    encryptionAlgorithm?: string;
    encryptionAtHostEnabled?: boolean;
    keyVaultKeyId?: string;
    keyVaultManagedIdentityId?: string;
}

export interface HdinsightHbaseClusterExtension {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightHbaseClusterGateway {
    password: string;
    username: string;
}

export interface HdinsightHbaseClusterMetastores {
    ambari?: outputs.HdinsightHbaseClusterMetastoresAmbari;
    hive?: outputs.HdinsightHbaseClusterMetastoresHive;
    oozie?: outputs.HdinsightHbaseClusterMetastoresOozie;
}

export interface HdinsightHbaseClusterMetastoresAmbari {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHbaseClusterMetastoresHive {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHbaseClusterMetastoresOozie {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightHbaseClusterMonitor {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightHbaseClusterNetwork {
    connectionDirection?: string;
    privateLinkEnabled?: boolean;
}

export interface HdinsightHbaseClusterPrivateLinkConfiguration {
    groupId: string;
    ipConfiguration: outputs.HdinsightHbaseClusterPrivateLinkConfigurationIpConfiguration;
    name: string;
}

export interface HdinsightHbaseClusterPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary?: boolean;
    privateIpAddress?: string;
    privateIpAllocationMethod?: string;
    subnetId?: string;
}

export interface HdinsightHbaseClusterRoles {
    headNode: outputs.HdinsightHbaseClusterRolesHeadNode;
    workerNode: outputs.HdinsightHbaseClusterRolesWorkerNode;
    zookeeperNode: outputs.HdinsightHbaseClusterRolesZookeeperNode;
}

export interface HdinsightHbaseClusterRolesHeadNode {
    password?: string;
    scriptActions?: outputs.HdinsightHbaseClusterRolesHeadNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHbaseClusterRolesHeadNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHbaseClusterRolesWorkerNode {
    autoscale?: outputs.HdinsightHbaseClusterRolesWorkerNodeAutoscale;
    password?: string;
    scriptActions?: outputs.HdinsightHbaseClusterRolesWorkerNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    targetInstanceCount: number;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHbaseClusterRolesWorkerNodeAutoscale {
    recurrence?: outputs.HdinsightHbaseClusterRolesWorkerNodeAutoscaleRecurrence;
}

export interface HdinsightHbaseClusterRolesWorkerNodeAutoscaleRecurrence {
    schedules: outputs.HdinsightHbaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
    timezone: string;
}

export interface HdinsightHbaseClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
    days: string[];
    targetInstanceCount: number;
    time: string;
}

export interface HdinsightHbaseClusterRolesWorkerNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHbaseClusterRolesZookeeperNode {
    password?: string;
    scriptActions?: outputs.HdinsightHbaseClusterRolesZookeeperNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightHbaseClusterRolesZookeeperNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightHbaseClusterSecurityProfile {
    aaddsResourceId: string;
    clusterUsersGroupDns?: string[];
    domainName: string;
    domainUserPassword: string;
    domainUsername: string;
    ldapsUrls: string[];
    msiResourceId: string;
}

export interface HdinsightHbaseClusterStorageAccount {
    isDefault: boolean;
    storageAccountKey: string;
    storageContainerId: string;
    storageResourceId?: string;
}

export interface HdinsightHbaseClusterStorageAccountGen2 {
    filesystemId: string;
    isDefault: boolean;
    managedIdentityResourceId: string;
    storageResourceId: string;
}

export interface HdinsightHbaseClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HdinsightInteractiveQueryClusterComponentVersion {
    interactiveHive: string;
}

export interface HdinsightInteractiveQueryClusterComputeIsolation {
    computeIsolationEnabled?: boolean;
    hostSku?: string;
}

export interface HdinsightInteractiveQueryClusterDiskEncryption {
    encryptionAlgorithm?: string;
    encryptionAtHostEnabled?: boolean;
    keyVaultKeyId?: string;
    keyVaultManagedIdentityId?: string;
}

export interface HdinsightInteractiveQueryClusterExtension {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightInteractiveQueryClusterGateway {
    password: string;
    username: string;
}

export interface HdinsightInteractiveQueryClusterMetastores {
    ambari?: outputs.HdinsightInteractiveQueryClusterMetastoresAmbari;
    hive?: outputs.HdinsightInteractiveQueryClusterMetastoresHive;
    oozie?: outputs.HdinsightInteractiveQueryClusterMetastoresOozie;
}

export interface HdinsightInteractiveQueryClusterMetastoresAmbari {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightInteractiveQueryClusterMetastoresHive {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightInteractiveQueryClusterMetastoresOozie {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightInteractiveQueryClusterMonitor {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightInteractiveQueryClusterNetwork {
    connectionDirection?: string;
    privateLinkEnabled?: boolean;
}

export interface HdinsightInteractiveQueryClusterPrivateLinkConfiguration {
    groupId: string;
    ipConfiguration: outputs.HdinsightInteractiveQueryClusterPrivateLinkConfigurationIpConfiguration;
    name: string;
}

export interface HdinsightInteractiveQueryClusterPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary?: boolean;
    privateIpAddress?: string;
    privateIpAllocationMethod?: string;
    subnetId?: string;
}

export interface HdinsightInteractiveQueryClusterRoles {
    headNode: outputs.HdinsightInteractiveQueryClusterRolesHeadNode;
    workerNode: outputs.HdinsightInteractiveQueryClusterRolesWorkerNode;
    zookeeperNode: outputs.HdinsightInteractiveQueryClusterRolesZookeeperNode;
}

export interface HdinsightInteractiveQueryClusterRolesHeadNode {
    password?: string;
    scriptActions?: outputs.HdinsightInteractiveQueryClusterRolesHeadNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightInteractiveQueryClusterRolesHeadNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightInteractiveQueryClusterRolesWorkerNode {
    autoscale?: outputs.HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscale;
    password?: string;
    scriptActions?: outputs.HdinsightInteractiveQueryClusterRolesWorkerNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    targetInstanceCount: number;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscale {
    recurrence?: outputs.HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence;
}

export interface HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrence {
    schedules: outputs.HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
    timezone: string;
}

export interface HdinsightInteractiveQueryClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
    days: string[];
    targetInstanceCount: number;
    time: string;
}

export interface HdinsightInteractiveQueryClusterRolesWorkerNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightInteractiveQueryClusterRolesZookeeperNode {
    password?: string;
    scriptActions?: outputs.HdinsightInteractiveQueryClusterRolesZookeeperNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightInteractiveQueryClusterRolesZookeeperNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightInteractiveQueryClusterSecurityProfile {
    aaddsResourceId: string;
    clusterUsersGroupDns?: string[];
    domainName: string;
    domainUserPassword: string;
    domainUsername: string;
    ldapsUrls: string[];
    msiResourceId: string;
}

export interface HdinsightInteractiveQueryClusterStorageAccount {
    isDefault: boolean;
    storageAccountKey: string;
    storageContainerId: string;
    storageResourceId?: string;
}

export interface HdinsightInteractiveQueryClusterStorageAccountGen2 {
    filesystemId: string;
    isDefault: boolean;
    managedIdentityResourceId: string;
    storageResourceId: string;
}

export interface HdinsightInteractiveQueryClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HdinsightKafkaClusterComponentVersion {
    kafka: string;
}

export interface HdinsightKafkaClusterComputeIsolation {
    computeIsolationEnabled?: boolean;
    hostSku?: string;
}

export interface HdinsightKafkaClusterDiskEncryption {
    encryptionAlgorithm?: string;
    encryptionAtHostEnabled?: boolean;
    keyVaultKeyId?: string;
    keyVaultManagedIdentityId?: string;
}

export interface HdinsightKafkaClusterExtension {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightKafkaClusterGateway {
    password: string;
    username: string;
}

export interface HdinsightKafkaClusterMetastores {
    ambari?: outputs.HdinsightKafkaClusterMetastoresAmbari;
    hive?: outputs.HdinsightKafkaClusterMetastoresHive;
    oozie?: outputs.HdinsightKafkaClusterMetastoresOozie;
}

export interface HdinsightKafkaClusterMetastoresAmbari {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightKafkaClusterMetastoresHive {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightKafkaClusterMetastoresOozie {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightKafkaClusterMonitor {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightKafkaClusterNetwork {
    connectionDirection?: string;
    privateLinkEnabled?: boolean;
}

export interface HdinsightKafkaClusterPrivateLinkConfiguration {
    groupId: string;
    ipConfiguration: outputs.HdinsightKafkaClusterPrivateLinkConfigurationIpConfiguration;
    name: string;
}

export interface HdinsightKafkaClusterPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary?: boolean;
    privateIpAddress?: string;
    privateIpAllocationMethod?: string;
    subnetId?: string;
}

export interface HdinsightKafkaClusterRestProxy {
    securityGroupId: string;
    securityGroupName: string;
}

export interface HdinsightKafkaClusterRoles {
    headNode: outputs.HdinsightKafkaClusterRolesHeadNode;
    kafkaManagementNode?: outputs.HdinsightKafkaClusterRolesKafkaManagementNode;
    workerNode: outputs.HdinsightKafkaClusterRolesWorkerNode;
    zookeeperNode: outputs.HdinsightKafkaClusterRolesZookeeperNode;
}

export interface HdinsightKafkaClusterRolesHeadNode {
    password?: string;
    scriptActions?: outputs.HdinsightKafkaClusterRolesHeadNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightKafkaClusterRolesHeadNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightKafkaClusterRolesKafkaManagementNode {
    password?: string;
    scriptActions?: outputs.HdinsightKafkaClusterRolesKafkaManagementNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightKafkaClusterRolesKafkaManagementNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightKafkaClusterRolesWorkerNode {
    numberOfDisksPerNode: number;
    password?: string;
    scriptActions?: outputs.HdinsightKafkaClusterRolesWorkerNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    targetInstanceCount: number;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightKafkaClusterRolesWorkerNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightKafkaClusterRolesZookeeperNode {
    password?: string;
    scriptActions?: outputs.HdinsightKafkaClusterRolesZookeeperNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightKafkaClusterRolesZookeeperNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightKafkaClusterSecurityProfile {
    aaddsResourceId: string;
    clusterUsersGroupDns?: string[];
    domainName: string;
    domainUserPassword: string;
    domainUsername: string;
    ldapsUrls: string[];
    msiResourceId: string;
}

export interface HdinsightKafkaClusterStorageAccount {
    isDefault: boolean;
    storageAccountKey: string;
    storageContainerId: string;
    storageResourceId?: string;
}

export interface HdinsightKafkaClusterStorageAccountGen2 {
    filesystemId: string;
    isDefault: boolean;
    managedIdentityResourceId: string;
    storageResourceId: string;
}

export interface HdinsightKafkaClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HdinsightSparkClusterComponentVersion {
    spark: string;
}

export interface HdinsightSparkClusterComputeIsolation {
    computeIsolationEnabled?: boolean;
    hostSku?: string;
}

export interface HdinsightSparkClusterDiskEncryption {
    encryptionAlgorithm?: string;
    encryptionAtHostEnabled?: boolean;
    keyVaultKeyId?: string;
    keyVaultManagedIdentityId?: string;
}

export interface HdinsightSparkClusterExtension {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightSparkClusterGateway {
    password: string;
    username: string;
}

export interface HdinsightSparkClusterMetastores {
    ambari?: outputs.HdinsightSparkClusterMetastoresAmbari;
    hive?: outputs.HdinsightSparkClusterMetastoresHive;
    oozie?: outputs.HdinsightSparkClusterMetastoresOozie;
}

export interface HdinsightSparkClusterMetastoresAmbari {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightSparkClusterMetastoresHive {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightSparkClusterMetastoresOozie {
    databaseName: string;
    password: string;
    server: string;
    username: string;
}

export interface HdinsightSparkClusterMonitor {
    logAnalyticsWorkspaceId: string;
    primaryKey: string;
}

export interface HdinsightSparkClusterNetwork {
    connectionDirection?: string;
    privateLinkEnabled?: boolean;
}

export interface HdinsightSparkClusterPrivateLinkConfiguration {
    groupId: string;
    ipConfiguration: outputs.HdinsightSparkClusterPrivateLinkConfigurationIpConfiguration;
    name: string;
}

export interface HdinsightSparkClusterPrivateLinkConfigurationIpConfiguration {
    name: string;
    primary?: boolean;
    privateIpAddress?: string;
    privateIpAllocationMethod?: string;
    subnetId?: string;
}

export interface HdinsightSparkClusterRoles {
    headNode: outputs.HdinsightSparkClusterRolesHeadNode;
    workerNode: outputs.HdinsightSparkClusterRolesWorkerNode;
    zookeeperNode: outputs.HdinsightSparkClusterRolesZookeeperNode;
}

export interface HdinsightSparkClusterRolesHeadNode {
    password?: string;
    scriptActions?: outputs.HdinsightSparkClusterRolesHeadNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightSparkClusterRolesHeadNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightSparkClusterRolesWorkerNode {
    autoscale?: outputs.HdinsightSparkClusterRolesWorkerNodeAutoscale;
    password?: string;
    scriptActions?: outputs.HdinsightSparkClusterRolesWorkerNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    targetInstanceCount: number;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightSparkClusterRolesWorkerNodeAutoscale {
    capacity?: outputs.HdinsightSparkClusterRolesWorkerNodeAutoscaleCapacity;
    recurrence?: outputs.HdinsightSparkClusterRolesWorkerNodeAutoscaleRecurrence;
}

export interface HdinsightSparkClusterRolesWorkerNodeAutoscaleCapacity {
    maxInstanceCount: number;
    minInstanceCount: number;
}

export interface HdinsightSparkClusterRolesWorkerNodeAutoscaleRecurrence {
    schedules: outputs.HdinsightSparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule[];
    timezone: string;
}

export interface HdinsightSparkClusterRolesWorkerNodeAutoscaleRecurrenceSchedule {
    days: string[];
    targetInstanceCount: number;
    time: string;
}

export interface HdinsightSparkClusterRolesWorkerNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightSparkClusterRolesZookeeperNode {
    password?: string;
    scriptActions?: outputs.HdinsightSparkClusterRolesZookeeperNodeScriptAction[];
    sshKeys?: string[];
    subnetId?: string;
    username: string;
    virtualNetworkId?: string;
    vmSize: string;
}

export interface HdinsightSparkClusterRolesZookeeperNodeScriptAction {
    name: string;
    parameters?: string;
    uri: string;
}

export interface HdinsightSparkClusterSecurityProfile {
    aaddsResourceId: string;
    clusterUsersGroupDns?: string[];
    domainName: string;
    domainUserPassword: string;
    domainUsername: string;
    ldapsUrls: string[];
    msiResourceId: string;
}

export interface HdinsightSparkClusterStorageAccount {
    isDefault: boolean;
    storageAccountKey: string;
    storageContainerId: string;
    storageResourceId?: string;
}

export interface HdinsightSparkClusterStorageAccountGen2 {
    filesystemId: string;
    isDefault: boolean;
    managedIdentityResourceId: string;
    storageResourceId: string;
}

export interface HdinsightSparkClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthbotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareDicomServiceAuthentication {
    audiences: string[];
    authority: string;
}

export interface HealthcareDicomServiceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface HealthcareDicomServicePrivateEndpoint {
    id: string;
    name: string;
}

export interface HealthcareDicomServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareFhirServiceAuthentication {
    audience: string;
    authority: string;
    smartProxyEnabled?: boolean;
}

export interface HealthcareFhirServiceCors {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    credentialsAllowed?: boolean;
    maxAgeInSeconds?: number;
}

export interface HealthcareFhirServiceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface HealthcareFhirServiceOciArtifact {
    digest?: string;
    imageName?: string;
    loginServer: string;
}

export interface HealthcareFhirServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareMedtechServiceFhirDestinationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareMedtechServiceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface HealthcareMedtechServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareServiceAuthenticationConfiguration {
    audience?: string;
    authority?: string;
    smartProxyEnabled?: boolean;
}

export interface HealthcareServiceCorsConfiguration {
    allowCredentials?: boolean;
    allowedHeaders?: string[];
    allowedMethods?: string[];
    allowedOrigins?: string[];
    maxAgeInSeconds?: number;
}

export interface HealthcareServiceIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface HealthcareServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HealthcareWorkspacePrivateEndpointConnection {
    id: string;
    name: string;
}

export interface HealthcareWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HpcCacheAccessPolicyAccessRule {
    access: string;
    anonymousGid?: number;
    anonymousUid?: number;
    filter?: string;
    rootSquashEnabled?: boolean;
    scope: string;
    submountAccessEnabled?: boolean;
    suidEnabled?: boolean;
}

export interface HpcCacheAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HpcCacheBlobNfsTargetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HpcCacheBlobTargetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HpcCacheDefaultAccessPolicy {
    accessRules: outputs.HpcCacheDefaultAccessPolicyAccessRule[];
}

export interface HpcCacheDefaultAccessPolicyAccessRule {
    access: string;
    anonymousGid?: number;
    anonymousUid?: number;
    filter?: string;
    rootSquashEnabled?: boolean;
    scope: string;
    submountAccessEnabled?: boolean;
    suidEnabled?: boolean;
}

export interface HpcCacheDirectoryActiveDirectory {
    cacheNetbiosName: string;
    dnsPrimaryIp: string;
    dnsSecondaryIp?: string;
    domainName: string;
    domainNetbiosName: string;
    password: string;
    username: string;
}

export interface HpcCacheDirectoryFlatFile {
    groupFileUri: string;
    passwordFileUri: string;
}

export interface HpcCacheDirectoryLdap {
    baseDn: string;
    bind?: outputs.HpcCacheDirectoryLdapBind;
    certificateValidationUri?: string;
    downloadCertificateAutomatically?: boolean;
    encrypted?: boolean;
    server: string;
}

export interface HpcCacheDirectoryLdapBind {
    dn: string;
    password: string;
}

export interface HpcCacheDns {
    searchDomain?: string;
    servers: string[];
}

export interface HpcCacheIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface HpcCacheNfsTargetNamespaceJunction {
    accessPolicyName?: string;
    namespacePath: string;
    nfsExport: string;
    targetPath?: string;
}

export interface HpcCacheNfsTargetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface HpcCacheTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ImageDataDisk {
    blobUri: string;
    caching?: string;
    diskEncryptionSetId?: string;
    lun?: number;
    managedDiskId?: string;
    sizeGb: number;
    /**
     * The type of storage disk
     */
    storageType: string;
}

export interface ImageOsDisk {
    blobUri: string;
    caching?: string;
    diskEncryptionSetId?: string;
    managedDiskId: string;
    osState?: string;
    osType?: string;
    sizeGb: number;
    /**
     * The type of storage disk
     */
    storageType: string;
}

export interface ImageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IotSecurityDeviceGroupAllowRule {
    connectionFromIpsNotAlloweds?: string[];
    connectionToIpsNotAlloweds?: string[];
    localUsersNotAlloweds?: string[];
    processesNotAlloweds?: string[];
}

export interface IotSecurityDeviceGroupRangeRule {
    duration: string;
    max: number;
    min: number;
    type: string;
}

export interface IotSecurityDeviceGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IotSecuritySolutionAdditionalWorkspace {
    dataTypes: string[];
    workspaceId: string;
}

export interface IotSecuritySolutionRecommendationsEnabled {
    acrAuthentication?: boolean;
    agentSendUnutilizedMsg?: boolean;
    baseline?: boolean;
    edgeHubMemOptimize?: boolean;
    edgeLoggingOption?: boolean;
    inconsistentModuleSettings?: boolean;
    installAgent?: boolean;
    ipFilterDenyAll?: boolean;
    ipFilterPermissiveRule?: boolean;
    openPorts?: boolean;
    permissiveFirewallPolicy?: boolean;
    permissiveInputFirewallRules?: boolean;
    permissiveOutputFirewallRules?: boolean;
    privilegedDockerOptions?: boolean;
    sharedCredentials?: boolean;
    vulnerableTlsCipherSuite?: boolean;
}

export interface IotSecuritySolutionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IotcentralApplicationIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface IotcentralApplicationNetworkRuleSetIpRule {
    ipMask: string;
    name: string;
}

export interface IotcentralApplicationNetworkRuleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IotcentralApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IotcentralOrganizationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubCloudToDevice {
    defaultTtl?: string;
    feedbacks?: outputs.IothubCloudToDeviceFeedback[];
    maxDeliveryCount?: number;
}

export interface IothubCloudToDeviceFeedback {
    lockDuration?: string;
    maxDeliveryCount?: number;
    timeToLive?: string;
}

export interface IothubConsumerGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface IothubDeviceUpdateAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface IothubDeviceUpdateAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubDeviceUpdateInstanceDiagnosticStorageAccount {
    connectionString: string;
    id: string;
}

export interface IothubDeviceUpdateInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubDpsCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubDpsIpFilterRule {
    action: string;
    ipMask: string;
    name: string;
    target?: string;
}

export interface IothubDpsLinkedHub {
    allocationWeight?: number;
    applyAllocationPolicy?: boolean;
    connectionString: string;
    hostname: string;
    location: string;
}

export interface IothubDpsSharedAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubDpsSku {
    capacity: number;
    name: string;
}

export interface IothubDpsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEndpoint {
    authenticationType: string;
    batchFrequencyInSeconds: number;
    connectionString: string;
    containerName: string;
    encoding: string;
    endpointUri: string;
    entityPath: string;
    fileNameFormat: string;
    identityId: string;
    maxChunkSizeInBytes: number;
    name: string;
    resourceGroupName: string;
    type: string;
}

export interface IothubEndpointCosmosdbAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEndpointEventhubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEndpointServicebusQueueTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEndpointServicebusTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEndpointStorageContainerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubEnrichment {
    endpointNames: string[];
    key: string;
    value: string;
}

export interface IothubEnrichmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubFallbackRoute {
    condition?: string;
    enabled?: boolean;
    endpointNames: string[];
    source?: string;
}

export interface IothubFallbackRouteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubFileUpload {
    authenticationType?: string;
    connectionString: string;
    containerName: string;
    defaultTtl?: string;
    identityId?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    notifications?: boolean;
    sasTtl?: string;
}

export interface IothubFileUploadTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface IothubNetworkRuleSet {
    applyToBuiltinEventhubEndpoint?: boolean;
    defaultAction?: string;
    ipRules?: outputs.IothubNetworkRuleSetIpRule[];
}

export interface IothubNetworkRuleSetIpRule {
    action?: string;
    ipMask: string;
    name: string;
}

export interface IothubRoute {
    condition: string;
    enabled: boolean;
    endpointNames: string[];
    name: string;
    source: string;
}

export interface IothubRouteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubSharedAccessPolicy {
    keyName: string;
    permissions: string;
    primaryKey: string;
    secondaryKey: string;
}

export interface IothubSharedAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IothubSku {
    capacity: number;
    name: string;
}

export interface IothubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface IpGroupCidrTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface IpGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultAccessPolicy {
    applicationId: string;
    certificatePermissions: string[];
    keyPermissions: string[];
    objectId: string;
    secretPermissions: string[];
    storagePermissions: string[];
    tenantId: string;
}

export interface KeyVaultAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultCertificateCertificate {
    contents: string;
    password?: string;
}

export interface KeyVaultCertificateCertificateAttribute {
    created: string;
    enabled: boolean;
    expires: string;
    notBefore: string;
    recoveryLevel: string;
    updated: string;
}

export interface KeyVaultCertificateCertificatePolicy {
    issuerParameters: outputs.KeyVaultCertificateCertificatePolicyIssuerParameters;
    keyProperties: outputs.KeyVaultCertificateCertificatePolicyKeyProperties;
    lifetimeActions?: outputs.KeyVaultCertificateCertificatePolicyLifetimeAction[];
    secretProperties: outputs.KeyVaultCertificateCertificatePolicySecretProperties;
    x509CertificateProperties?: outputs.KeyVaultCertificateCertificatePolicyX509CertificateProperties;
}

export interface KeyVaultCertificateCertificatePolicyIssuerParameters {
    name: string;
}

export interface KeyVaultCertificateCertificatePolicyKeyProperties {
    curve: string;
    exportable: boolean;
    keySize: number;
    keyType: string;
    reuseKey: boolean;
}

export interface KeyVaultCertificateCertificatePolicyLifetimeAction {
    action: outputs.KeyVaultCertificateCertificatePolicyLifetimeActionAction;
    trigger: outputs.KeyVaultCertificateCertificatePolicyLifetimeActionTrigger;
}

export interface KeyVaultCertificateCertificatePolicyLifetimeActionAction {
    actionType: string;
}

export interface KeyVaultCertificateCertificatePolicyLifetimeActionTrigger {
    daysBeforeExpiry?: number;
    lifetimePercentage?: number;
}

export interface KeyVaultCertificateCertificatePolicySecretProperties {
    contentType: string;
}

export interface KeyVaultCertificateCertificatePolicyX509CertificateProperties {
    extendedKeyUsages: string[];
    keyUsages: string[];
    subject: string;
    subjectAlternativeNames?: outputs.KeyVaultCertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames;
    validityInMonths: number;
}

export interface KeyVaultCertificateCertificatePolicyX509CertificatePropertiesSubjectAlternativeNames {
    dnsNames?: string[];
    emails?: string[];
    upns?: string[];
}

export interface KeyVaultCertificateContactsContact {
    email: string;
    name?: string;
    phone?: string;
}

export interface KeyVaultCertificateContactsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultCertificateIssuerAdmin {
    emailAddress: string;
    firstName?: string;
    lastName?: string;
    phone?: string;
}

export interface KeyVaultCertificateIssuerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultContact {
    email: string;
    name?: string;
    phone?: string;
}

export interface KeyVaultKeyRotationPolicy {
    automatic?: outputs.KeyVaultKeyRotationPolicyAutomatic;
    expireAfter?: string;
    notifyBeforeExpiry?: string;
}

export interface KeyVaultKeyRotationPolicyAutomatic {
    timeAfterCreation?: string;
    timeBeforeExpiry?: string;
}

export interface KeyVaultKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultManagedHardwareSecurityModuleKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultManagedHardwareSecurityModuleNetworkAcls {
    bypass: string;
    defaultAction: string;
}

export interface KeyVaultManagedHardwareSecurityModuleRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KeyVaultManagedHardwareSecurityModuleRoleDefinitionPermission {
    actions?: string[];
    dataActions?: string[];
    notActions?: string[];
    notDataActions?: string[];
}

export interface KeyVaultManagedHardwareSecurityModuleRoleDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultManagedHardwareSecurityModuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultManagedStorageAccountSasTokenDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultManagedStorageAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultNetworkAcls {
    bypass: string;
    defaultAction: string;
    ipRules?: string[];
    virtualNetworkSubnetIds?: string[];
}

export interface KeyVaultSecretTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KeyVaultTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterAciConnectorLinux {
    connectorIdentities: outputs.KubernetesClusterAciConnectorLinuxConnectorIdentity[];
    subnetName: string;
}

export interface KubernetesClusterAciConnectorLinuxConnectorIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterApiServerAccessProfile {
    authorizedIpRanges?: string[];
}

export interface KubernetesClusterAutoScalerProfile {
    balanceSimilarNodeGroups?: boolean;
    emptyBulkDeleteMax: string;
    expander?: string;
    maxGracefulTerminationSec: string;
    maxNodeProvisioningTime?: string;
    maxUnreadyNodes?: number;
    maxUnreadyPercentage?: number;
    newPodScaleUpDelay: string;
    scaleDownDelayAfterAdd: string;
    scaleDownDelayAfterDelete: string;
    scaleDownDelayAfterFailure: string;
    scaleDownUnneeded: string;
    scaleDownUnready: string;
    scaleDownUtilizationThreshold: string;
    scanInterval: string;
    skipNodesWithLocalStorage?: boolean;
    skipNodesWithSystemPods?: boolean;
}

export interface KubernetesClusterAzureActiveDirectoryRoleBasedAccessControl {
    adminGroupObjectIds?: string[];
    azureRbacEnabled?: boolean;
    tenantId: string;
}

export interface KubernetesClusterConfidentialComputing {
    sgxQuoteHelperEnabled: boolean;
}

export interface KubernetesClusterDefaultNodePool {
    autoScalingEnabled?: boolean;
    capacityReservationGroupId?: string;
    fipsEnabled?: boolean;
    gpuInstance?: string;
    hostEncryptionEnabled?: boolean;
    hostGroupId?: string;
    kubeletConfig?: outputs.KubernetesClusterDefaultNodePoolKubeletConfig;
    kubeletDiskType: string;
    linuxOsConfig?: outputs.KubernetesClusterDefaultNodePoolLinuxOsConfig;
    maxCount?: number;
    maxPods: number;
    minCount?: number;
    name: string;
    nodeCount: number;
    nodeLabels: {[key: string]: string};
    nodeNetworkProfile?: outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfile;
    nodePublicIpEnabled?: boolean;
    nodePublicIpPrefixId?: string;
    onlyCriticalAddonsEnabled?: boolean;
    orchestratorVersion: string;
    osDiskSizeGb: number;
    osDiskType?: string;
    osSku: string;
    podSubnetId?: string;
    proximityPlacementGroupId?: string;
    scaleDownMode?: string;
    snapshotId?: string;
    tags?: {[key: string]: string};
    temporaryNameForRotation?: string;
    type?: string;
    ultraSsdEnabled?: boolean;
    upgradeSettings?: outputs.KubernetesClusterDefaultNodePoolUpgradeSettings;
    vmSize: string;
    vnetSubnetId?: string;
    workloadRuntime: string;
    zones?: string[];
}

export interface KubernetesClusterDefaultNodePoolKubeletConfig {
    allowedUnsafeSysctls?: string[];
    containerLogMaxLine?: number;
    containerLogMaxSizeMb?: number;
    cpuCfsQuotaEnabled?: boolean;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    imageGcHighThreshold?: number;
    imageGcLowThreshold?: number;
    podMaxPid?: number;
    topologyManagerPolicy?: string;
}

export interface KubernetesClusterDefaultNodePoolLinuxOsConfig {
    swapFileSizeMb?: number;
    sysctlConfig?: outputs.KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig;
    transparentHugePageDefrag?: string;
    transparentHugePageEnabled?: string;
}

export interface KubernetesClusterDefaultNodePoolLinuxOsConfigSysctlConfig {
    fsAioMaxNr?: number;
    fsFileMax?: number;
    fsInotifyMaxUserWatches?: number;
    fsNrOpen?: number;
    kernelThreadsMax?: number;
    netCoreNetdevMaxBacklog?: number;
    netCoreOptmemMax?: number;
    netCoreRmemDefault?: number;
    netCoreRmemMax?: number;
    netCoreSomaxconn?: number;
    netCoreWmemDefault?: number;
    netCoreWmemMax?: number;
    netIpv4IpLocalPortRangeMax?: number;
    netIpv4IpLocalPortRangeMin?: number;
    netIpv4NeighDefaultGcThresh1?: number;
    netIpv4NeighDefaultGcThresh2?: number;
    netIpv4NeighDefaultGcThresh3?: number;
    netIpv4TcpFinTimeout?: number;
    netIpv4TcpKeepaliveIntvl?: number;
    netIpv4TcpKeepaliveProbes?: number;
    netIpv4TcpKeepaliveTime?: number;
    netIpv4TcpMaxSynBacklog?: number;
    netIpv4TcpMaxTwBuckets?: number;
    netIpv4TcpTwReuse?: boolean;
    netNetfilterNfConntrackBuckets?: number;
    netNetfilterNfConntrackMax?: number;
    vmMaxMapCount?: number;
    vmSwappiness?: number;
    vmVfsCachePressure?: number;
}

export interface KubernetesClusterDefaultNodePoolNodeNetworkProfile {
    allowedHostPorts?: outputs.KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort[];
    applicationSecurityGroupIds?: string[];
    nodePublicIpTags?: {[key: string]: string};
}

export interface KubernetesClusterDefaultNodePoolNodeNetworkProfileAllowedHostPort {
    portEnd?: number;
    portStart?: number;
    protocol?: string;
}

export interface KubernetesClusterDefaultNodePoolUpgradeSettings {
    drainTimeoutInMinutes?: number;
    maxSurge: string;
    nodeSoakDurationInMinutes?: number;
}

export interface KubernetesClusterExtensionAksAssignedIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface KubernetesClusterExtensionPlan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
    version?: string;
}

export interface KubernetesClusterExtensionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterHttpProxyConfig {
    httpProxy?: string;
    httpsProxy?: string;
    noProxies?: string[];
    trustedCa?: string;
}

export interface KubernetesClusterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface KubernetesClusterIngressApplicationGateway {
    effectiveGatewayId: string;
    gatewayId?: string;
    gatewayName?: string;
    ingressApplicationGatewayIdentities: outputs.KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity[];
    subnetCidr?: string;
    subnetId?: string;
}

export interface KubernetesClusterIngressApplicationGatewayIngressApplicationGatewayIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterKeyManagementService {
    keyVaultKeyId: string;
    keyVaultNetworkAccess?: string;
}

export interface KubernetesClusterKeyVaultSecretsProvider {
    secretIdentities: outputs.KubernetesClusterKeyVaultSecretsProviderSecretIdentity[];
    secretRotationEnabled?: boolean;
    secretRotationInterval?: string;
}

export interface KubernetesClusterKeyVaultSecretsProviderSecretIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterKubeAdminConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    host: string;
    password: string;
    username: string;
}

export interface KubernetesClusterKubeConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    host: string;
    password: string;
    username: string;
}

export interface KubernetesClusterKubeletIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterLinuxProfile {
    adminUsername: string;
    sshKey: outputs.KubernetesClusterLinuxProfileSshKey;
}

export interface KubernetesClusterLinuxProfileSshKey {
    keyData: string;
}

export interface KubernetesClusterMaintenanceWindow {
    alloweds?: outputs.KubernetesClusterMaintenanceWindowAllowed[];
    notAlloweds?: outputs.KubernetesClusterMaintenanceWindowNotAllowed[];
}

export interface KubernetesClusterMaintenanceWindowAllowed {
    day: string;
    hours: number[];
}

export interface KubernetesClusterMaintenanceWindowAutoUpgrade {
    dayOfMonth?: number;
    dayOfWeek?: string;
    duration: number;
    frequency: string;
    interval: number;
    notAlloweds?: outputs.KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed[];
    startDate: string;
    startTime?: string;
    utcOffset?: string;
    weekIndex?: string;
}

export interface KubernetesClusterMaintenanceWindowAutoUpgradeNotAllowed {
    end: string;
    start: string;
}

export interface KubernetesClusterMaintenanceWindowNodeOs {
    dayOfMonth?: number;
    dayOfWeek?: string;
    duration: number;
    frequency: string;
    interval: number;
    notAlloweds?: outputs.KubernetesClusterMaintenanceWindowNodeOsNotAllowed[];
    startDate: string;
    startTime?: string;
    utcOffset?: string;
    weekIndex?: string;
}

export interface KubernetesClusterMaintenanceWindowNodeOsNotAllowed {
    end: string;
    start: string;
}

export interface KubernetesClusterMaintenanceWindowNotAllowed {
    end: string;
    start: string;
}

export interface KubernetesClusterMicrosoftDefender {
    logAnalyticsWorkspaceId: string;
}

export interface KubernetesClusterMonitorMetrics {
    annotationsAllowed?: string;
    labelsAllowed?: string;
}

export interface KubernetesClusterNetworkProfile {
    dnsServiceIp: string;
    ipVersions: string[];
    loadBalancerProfile?: outputs.KubernetesClusterNetworkProfileLoadBalancerProfile;
    loadBalancerSku?: string;
    natGatewayProfile?: outputs.KubernetesClusterNetworkProfileNatGatewayProfile;
    networkDataPlane?: string;
    networkMode: string;
    networkPlugin: string;
    networkPluginMode?: string;
    networkPolicy: string;
    outboundType?: string;
    podCidr: string;
    podCidrs: string[];
    serviceCidr: string;
    serviceCidrs: string[];
}

export interface KubernetesClusterNetworkProfileLoadBalancerProfile {
    effectiveOutboundIps: string[];
    idleTimeoutInMinutes?: number;
    managedOutboundIpCount: number;
    managedOutboundIpv6Count: number;
    outboundIpAddressIds?: string[];
    outboundIpPrefixIds?: string[];
    outboundPortsAllocated?: number;
}

export interface KubernetesClusterNetworkProfileNatGatewayProfile {
    effectiveOutboundIps: string[];
    idleTimeoutInMinutes?: number;
    managedOutboundIpCount: number;
}

export interface KubernetesClusterNodePoolKubeletConfig {
    allowedUnsafeSysctls?: string[];
    containerLogMaxLine?: number;
    containerLogMaxSizeMb?: number;
    cpuCfsQuotaEnabled?: boolean;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    imageGcHighThreshold?: number;
    imageGcLowThreshold?: number;
    podMaxPid?: number;
    topologyManagerPolicy?: string;
}

export interface KubernetesClusterNodePoolLinuxOsConfig {
    swapFileSizeMb?: number;
    sysctlConfig?: outputs.KubernetesClusterNodePoolLinuxOsConfigSysctlConfig;
    transparentHugePageDefrag?: string;
    transparentHugePageEnabled?: string;
}

export interface KubernetesClusterNodePoolLinuxOsConfigSysctlConfig {
    fsAioMaxNr?: number;
    fsFileMax?: number;
    fsInotifyMaxUserWatches?: number;
    fsNrOpen?: number;
    kernelThreadsMax?: number;
    netCoreNetdevMaxBacklog?: number;
    netCoreOptmemMax?: number;
    netCoreRmemDefault?: number;
    netCoreRmemMax?: number;
    netCoreSomaxconn?: number;
    netCoreWmemDefault?: number;
    netCoreWmemMax?: number;
    netIpv4IpLocalPortRangeMax?: number;
    netIpv4IpLocalPortRangeMin?: number;
    netIpv4NeighDefaultGcThresh1?: number;
    netIpv4NeighDefaultGcThresh2?: number;
    netIpv4NeighDefaultGcThresh3?: number;
    netIpv4TcpFinTimeout?: number;
    netIpv4TcpKeepaliveIntvl?: number;
    netIpv4TcpKeepaliveProbes?: number;
    netIpv4TcpKeepaliveTime?: number;
    netIpv4TcpMaxSynBacklog?: number;
    netIpv4TcpMaxTwBuckets?: number;
    netIpv4TcpTwReuse?: boolean;
    netNetfilterNfConntrackBuckets?: number;
    netNetfilterNfConntrackMax?: number;
    vmMaxMapCount?: number;
    vmSwappiness?: number;
    vmVfsCachePressure?: number;
}

export interface KubernetesClusterNodePoolNodeNetworkProfile {
    allowedHostPorts?: outputs.KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort[];
    applicationSecurityGroupIds?: string[];
    nodePublicIpTags?: {[key: string]: string};
}

export interface KubernetesClusterNodePoolNodeNetworkProfileAllowedHostPort {
    portEnd?: number;
    portStart?: number;
    protocol?: string;
}

export interface KubernetesClusterNodePoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterNodePoolUpgradeSettings {
    drainTimeoutInMinutes?: number;
    maxSurge: string;
    nodeSoakDurationInMinutes?: number;
}

export interface KubernetesClusterNodePoolWindowsProfile {
    outboundNatEnabled?: boolean;
}

export interface KubernetesClusterOmsAgent {
    logAnalyticsWorkspaceId: string;
    msiAuthForMonitoringEnabled?: boolean;
    omsAgentIdentities: outputs.KubernetesClusterOmsAgentOmsAgentIdentity[];
}

export interface KubernetesClusterOmsAgentOmsAgentIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterServiceMeshProfile {
    certificateAuthority?: outputs.KubernetesClusterServiceMeshProfileCertificateAuthority;
    externalIngressGatewayEnabled?: boolean;
    internalIngressGatewayEnabled?: boolean;
    mode: string;
    revisions: string[];
}

export interface KubernetesClusterServiceMeshProfileCertificateAuthority {
    certChainObjectName: string;
    certObjectName: string;
    keyObjectName: string;
    keyVaultId: string;
    rootCertObjectName: string;
}

export interface KubernetesClusterServicePrincipal {
    clientId: string;
    clientSecret: string;
}

export interface KubernetesClusterStorageProfile {
    blobDriverEnabled?: boolean;
    diskDriverEnabled?: boolean;
    fileDriverEnabled?: boolean;
    snapshotControllerEnabled?: boolean;
}

export interface KubernetesClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterTrustedAccessRoleBindingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesClusterWebAppRouting {
    dnsZoneIds: string[];
    webAppRoutingIdentities: outputs.KubernetesClusterWebAppRoutingWebAppRoutingIdentity[];
}

export interface KubernetesClusterWebAppRoutingWebAppRoutingIdentity {
    clientId: string;
    objectId: string;
    userAssignedIdentityId: string;
}

export interface KubernetesClusterWindowsProfile {
    adminPassword: string;
    adminUsername: string;
    gmsa?: outputs.KubernetesClusterWindowsProfileGmsa;
    license?: string;
}

export interface KubernetesClusterWindowsProfileGmsa {
    dnsServer: string;
    rootDomain: string;
}

export interface KubernetesClusterWorkloadAutoscalerProfile {
    kedaEnabled?: boolean;
    verticalPodAutoscalerEnabled?: boolean;
}

export interface KubernetesFleetManagerHubProfile {
    dnsPrefix: string;
    fqdn: string;
    kubernetesVersion: string;
}

export interface KubernetesFleetManagerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesFleetMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesFleetUpdateRunManagedClusterUpdate {
    nodeImageSelection?: outputs.KubernetesFleetUpdateRunManagedClusterUpdateNodeImageSelection;
    upgrade: outputs.KubernetesFleetUpdateRunManagedClusterUpdateUpgrade;
}

export interface KubernetesFleetUpdateRunManagedClusterUpdateNodeImageSelection {
    type: string;
}

export interface KubernetesFleetUpdateRunManagedClusterUpdateUpgrade {
    kubernetesVersion?: string;
    type: string;
}

export interface KubernetesFleetUpdateRunStage {
    afterStageWaitInSeconds?: number;
    groups: outputs.KubernetesFleetUpdateRunStageGroup[];
    name: string;
}

export interface KubernetesFleetUpdateRunStageGroup {
    name: string;
}

export interface KubernetesFleetUpdateRunTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesFleetUpdateStrategyStage {
    afterStageWaitInSeconds?: number;
    groups: outputs.KubernetesFleetUpdateStrategyStageGroup[];
    name: string;
}

export interface KubernetesFleetUpdateStrategyStageGroup {
    name: string;
}

export interface KubernetesFleetUpdateStrategyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KubernetesFluxConfigurationBlobStorage {
    accountKey?: string;
    containerId: string;
    localAuthReference?: string;
    managedIdentity?: outputs.KubernetesFluxConfigurationBlobStorageManagedIdentity;
    sasToken?: string;
    servicePrincipal?: outputs.KubernetesFluxConfigurationBlobStorageServicePrincipal;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
}

export interface KubernetesFluxConfigurationBlobStorageManagedIdentity {
    clientId: string;
}

export interface KubernetesFluxConfigurationBlobStorageServicePrincipal {
    clientCertificateBase64?: string;
    clientCertificatePassword?: string;
    clientCertificateSendChain?: boolean;
    clientId: string;
    clientSecret?: string;
    tenantId: string;
}

export interface KubernetesFluxConfigurationBucket {
    accessKey?: string;
    bucketName: string;
    localAuthReference?: string;
    secretKeyBase64?: string;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
    tlsEnabled?: boolean;
    url: string;
}

export interface KubernetesFluxConfigurationGitRepository {
    httpsCaCertBase64?: string;
    httpsKeyBase64?: string;
    httpsUser?: string;
    localAuthReference?: string;
    referenceType: string;
    referenceValue: string;
    sshKnownHostsBase64?: string;
    sshPrivateKeyBase64?: string;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
    url: string;
}

export interface KubernetesFluxConfigurationKustomization {
    dependsOns?: string[];
    garbageCollectionEnabled?: boolean;
    name: string;
    path?: string;
    recreatingEnabled?: boolean;
    retryIntervalInSeconds?: number;
    syncIntervalInSeconds?: number;
    timeoutInSeconds?: number;
}

export interface KubernetesFluxConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoAttachedDatabaseConfigurationSharing {
    externalTablesToExcludes?: string[];
    externalTablesToIncludes?: string[];
    materializedViewsToExcludes?: string[];
    materializedViewsToIncludes?: string[];
    tablesToExcludes?: string[];
    tablesToIncludes?: string[];
}

export interface KustoAttachedDatabaseConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoClusterCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoClusterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface KustoClusterLanguageExtension {
    image: string;
    name: string;
}

export interface KustoClusterManagedPrivateEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoClusterOptimizedAutoScale {
    maximumInstances: number;
    minimumInstances: number;
}

export interface KustoClusterPrincipalAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KustoClusterSku {
    capacity: number;
    name: string;
}

export interface KustoClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoClusterVirtualNetworkConfiguration {
    dataManagementPublicIpId: string;
    enginePublicIpId: string;
    subnetId: string;
}

export interface KustoCosmosdbDataConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KustoDatabasePrincipalAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KustoDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoEventgridDataConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoEventhubDataConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface KustoIothubDataConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface KustoScriptTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbBackendAddressPoolAddressInboundNatRulePortMapping {
    backendPort: number;
    frontendPort: number;
    inboundNatRuleName: string;
}

export interface LbBackendAddressPoolAddressTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbBackendAddressPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbBackendAddressPoolTunnelInterface {
    identifier: number;
    port: number;
    protocol: string;
    type: string;
}

export interface LbFrontendIpConfiguration {
    gatewayLoadBalancerFrontendIpConfigurationId: string;
    id: string;
    inboundNatRules: string[];
    loadBalancerRules: string[];
    name: string;
    outboundRules: string[];
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    privateIpAddressVersion: string;
    publicIpAddressId: string;
    publicIpPrefixId: string;
    subnetId: string;
    zones?: string[];
}

export interface LbNatPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbNatRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbOutboundRuleFrontendIpConfiguration {
    id: string;
    name: string;
}

export interface LbOutboundRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbProbeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LighthouseAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface LighthouseDefinitionAuthorization {
    delegatedRoleDefinitionIds?: string[];
    principalDisplayName?: string;
    principalId: string;
    roleDefinitionId: string;
}

export interface LighthouseDefinitionEligibleAuthorization {
    justInTimeAccessPolicy?: outputs.LighthouseDefinitionEligibleAuthorizationJustInTimeAccessPolicy;
    principalDisplayName?: string;
    principalId: string;
    roleDefinitionId: string;
}

export interface LighthouseDefinitionEligibleAuthorizationJustInTimeAccessPolicy {
    approvers?: outputs.LighthouseDefinitionEligibleAuthorizationJustInTimeAccessPolicyApprover[];
    maximumActivationDuration?: string;
    multiFactorAuthProvider?: string;
}

export interface LighthouseDefinitionEligibleAuthorizationJustInTimeAccessPolicyApprover {
    principalDisplayName?: string;
    principalId: string;
}

export interface LighthouseDefinitionPlan {
    name: string;
    product: string;
    publisher: string;
    version: string;
}

export interface LighthouseDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxFunctionAppAuthSettings {
    activeDirectory?: outputs.LinuxFunctionAppAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.LinuxFunctionAppAuthSettingsFacebook;
    github?: outputs.LinuxFunctionAppAuthSettingsGithub;
    google?: outputs.LinuxFunctionAppAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.LinuxFunctionAppAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.LinuxFunctionAppAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface LinuxFunctionAppAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface LinuxFunctionAppAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface LinuxFunctionAppAuthSettingsV2 {
    activeDirectoryV2?: outputs.LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.LinuxFunctionAppAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.LinuxFunctionAppAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.LinuxFunctionAppAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.LinuxFunctionAppAuthSettingsV2GithubV2;
    googleV2?: outputs.LinuxFunctionAppAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.LinuxFunctionAppAuthSettingsV2Login;
    microsoftV2?: outputs.LinuxFunctionAppAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.LinuxFunctionAppAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface LinuxFunctionAppAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface LinuxFunctionAppAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface LinuxFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface LinuxFunctionAppAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface LinuxFunctionAppAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface LinuxFunctionAppAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface LinuxFunctionAppBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.LinuxFunctionAppBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface LinuxFunctionAppBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface LinuxFunctionAppConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface LinuxFunctionAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxFunctionAppSiteConfig {
    /**
     * If this Linux Web App is Always On enabled. Defaults to `false`.
     */
    alwaysOn: boolean;
    /**
     * The URL of the API definition that describes this Linux Function App.
     */
    apiDefinitionUrl?: string;
    /**
     * The ID of the API Management API for this Linux Function App.
     */
    apiManagementApiId?: string;
    /**
     * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
     */
    appCommandLine?: string;
    /**
     * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
     */
    appScaleLimit: number;
    appServiceLogs?: outputs.LinuxFunctionAppSiteConfigAppServiceLogs;
    /**
     * The Connection String for linking the Linux Function App to Application Insights.
     */
    applicationInsightsConnectionString?: string;
    /**
     * The Instrumentation Key for connecting the Linux Function App to Application Insights.
     */
    applicationInsightsKey?: string;
    applicationStack?: outputs.LinuxFunctionAppSiteConfigApplicationStack;
    /**
     * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
     */
    containerRegistryManagedIdentityClientId?: string;
    /**
     * Should connections for Azure Container Registry use Managed Identity.
     */
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.LinuxFunctionAppSiteConfigCors;
    /**
     * Specifies a list of Default Documents for the Linux Web App.
     */
    defaultDocuments: string[];
    /**
     * Is detailed error logging enabled
     */
    detailedErrorLoggingEnabled: boolean;
    /**
     * The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
     */
    elasticInstanceMinimum: number;
    /**
     * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
     */
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    /**
     * The path to be checked for this function app health.
     */
    healthCheckPath?: string;
    /**
     * Specifies if the http2 protocol should be enabled. Defaults to `false`.
     */
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.LinuxFunctionAppSiteConfigIpRestriction[];
    /**
     * The Linux FX Version
     */
    linuxFxVersion: string;
    /**
     * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
     */
    loadBalancingMode?: string;
    /**
     * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
     */
    managedPipelineMode?: string;
    /**
     * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    minimumTlsVersion?: string;
    /**
     * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
     */
    preWarmedInstanceCount: number;
    /**
     * Should Remote Debugging be enabled. Defaults to `false`.
     */
    remoteDebuggingEnabled?: boolean;
    /**
     * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022``
     */
    remoteDebuggingVersion: string;
    /**
     * Should Functions Runtime Scale Monitoring be enabled.
     */
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.LinuxFunctionAppSiteConfigScmIpRestriction[];
    /**
     * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    scmMinimumTlsVersion?: string;
    /**
     * The SCM Type in use by the Linux Function App.
     */
    scmType: string;
    /**
     * Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
     */
    scmUseMainIpRestriction?: boolean;
    /**
     * Should the Linux Web App use a 32-bit worker.
     */
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    /**
     * Should Web Sockets be enabled. Defaults to `false`.
     */
    websocketsEnabled?: boolean;
    /**
     * The number of Workers for this Linux Function App.
     */
    workerCount: number;
}

export interface LinuxFunctionAppSiteConfigAppServiceLogs {
    /**
     * The amount of disk space to use for logs. Valid values are between `25` and `100`.
     */
    diskQuotaMb?: number;
    /**
     * The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
     */
    retentionPeriodDays?: number;
}

export interface LinuxFunctionAppSiteConfigApplicationStack {
    /**
     * A docker block
     */
    dockers?: outputs.LinuxFunctionAppSiteConfigApplicationStackDocker[];
    /**
     * The version of .Net. Possible values are `3.1`, `6.0` and `7.0`
     */
    dotnetVersion?: string;
    /**
     * The version of Java to use. Possible values are `8`, `11`, and `17`
     */
    javaVersion?: string;
    /**
     * The version of Node to use. Possible values include `12`, `14`, `16`, `18` and `20`
     */
    nodeVersion?: string;
    /**
     * The version of PowerShell Core to use. Possibles values are `7`, `7.2`, and `7.4`
     */
    powershellCoreVersion?: string;
    /**
     * The version of Python to use. Possible values include `3.12`, `3.11`, `3.10`, `3.9`, `3.8`, and `3.7`.
     */
    pythonVersion?: string;
    useCustomRuntime?: boolean;
    /**
     * Should the DotNet process use an isolated runtime. Defaults to `false`.
     */
    useDotnetIsolatedRuntime?: boolean;
}

export interface LinuxFunctionAppSiteConfigApplicationStackDocker {
    /**
     * The name of the Docker image to use.
     */
    imageName: string;
    /**
     * The image tag of the image to use.
     */
    imageTag: string;
    /**
     * The password for the account to use to connect to the registry.
     */
    registryPassword?: string;
    /**
     * The URL of the docker registry.
     */
    registryUrl: string;
    /**
     * The username to use for connections to the registry.
     */
    registryUsername?: string;
}

export interface LinuxFunctionAppSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface LinuxFunctionAppSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxFunctionAppSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxFunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxFunctionAppSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxFunctionAppSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxFunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxFunctionAppSiteCredential {
    name: string;
    password: string;
}

export interface LinuxFunctionAppSlotAuthSettings {
    activeDirectory?: outputs.LinuxFunctionAppSlotAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.LinuxFunctionAppSlotAuthSettingsFacebook;
    github?: outputs.LinuxFunctionAppSlotAuthSettingsGithub;
    google?: outputs.LinuxFunctionAppSlotAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.LinuxFunctionAppSlotAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.LinuxFunctionAppSlotAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface LinuxFunctionAppSlotAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface LinuxFunctionAppSlotAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface LinuxFunctionAppSlotAuthSettingsV2 {
    activeDirectoryV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2GithubV2;
    googleV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.LinuxFunctionAppSlotAuthSettingsV2Login;
    microsoftV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.LinuxFunctionAppSlotAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface LinuxFunctionAppSlotAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface LinuxFunctionAppSlotAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface LinuxFunctionAppSlotAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface LinuxFunctionAppSlotAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface LinuxFunctionAppSlotAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface LinuxFunctionAppSlotAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface LinuxFunctionAppSlotBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.LinuxFunctionAppSlotBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface LinuxFunctionAppSlotBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface LinuxFunctionAppSlotConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface LinuxFunctionAppSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxFunctionAppSlotSiteConfig {
    /**
     * If this Linux Web App is Always On enabled. Defaults to `false`.
     */
    alwaysOn: boolean;
    /**
     * The URL of the API definition that describes this Linux Function App.
     */
    apiDefinitionUrl?: string;
    /**
     * The ID of the API Management API for this Linux Function App.
     */
    apiManagementApiId?: string;
    /**
     * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
     */
    appCommandLine?: string;
    /**
     * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
     */
    appScaleLimit: number;
    appServiceLogs?: outputs.LinuxFunctionAppSlotSiteConfigAppServiceLogs;
    /**
     * The Connection String for linking the Linux Function App to Application Insights.
     */
    applicationInsightsConnectionString?: string;
    /**
     * The Instrumentation Key for connecting the Linux Function App to Application Insights.
     */
    applicationInsightsKey?: string;
    applicationStack?: outputs.LinuxFunctionAppSlotSiteConfigApplicationStack;
    autoSwapSlotName?: string;
    /**
     * The Client ID of the Managed Service Identity to use for connections to the Azure Container Registry.
     */
    containerRegistryManagedIdentityClientId?: string;
    /**
     * Should connections for Azure Container Registry use Managed Identity.
     */
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.LinuxFunctionAppSlotSiteConfigCors;
    /**
     * Specifies a list of Default Documents for the Linux Web App.
     */
    defaultDocuments: string[];
    /**
     * Is detailed error logging enabled
     */
    detailedErrorLoggingEnabled: boolean;
    /**
     * The number of minimum instances for this Linux Function App. Only affects apps on Elastic Premium plans.
     */
    elasticInstanceMinimum: number;
    /**
     * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
     */
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    /**
     * The path to be checked for this function app health.
     */
    healthCheckPath?: string;
    /**
     * Specifies if the http2 protocol should be enabled. Defaults to `false`.
     */
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.LinuxFunctionAppSlotSiteConfigIpRestriction[];
    /**
     * The Linux FX Version
     */
    linuxFxVersion: string;
    /**
     * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
     */
    loadBalancingMode?: string;
    /**
     * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
     */
    managedPipelineMode?: string;
    /**
     * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    minimumTlsVersion?: string;
    /**
     * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
     */
    preWarmedInstanceCount: number;
    /**
     * Should Remote Debugging be enabled. Defaults to `false`.
     */
    remoteDebuggingEnabled?: boolean;
    /**
     * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
     */
    remoteDebuggingVersion: string;
    /**
     * Should Functions Runtime Scale Monitoring be enabled.
     */
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.LinuxFunctionAppSlotSiteConfigScmIpRestriction[];
    /**
     * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    scmMinimumTlsVersion?: string;
    /**
     * The SCM Type in use by the Linux Function App.
     */
    scmType: string;
    /**
     * Should the Linux Function App `ip_restriction` configuration be used for the SCM also.
     */
    scmUseMainIpRestriction?: boolean;
    /**
     * Should the Linux Web App use a 32-bit worker.
     */
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    /**
     * Should Web Sockets be enabled. Defaults to `false`.
     */
    websocketsEnabled?: boolean;
    /**
     * The number of Workers for this Linux Function App.
     */
    workerCount: number;
}

export interface LinuxFunctionAppSlotSiteConfigAppServiceLogs {
    /**
     * The amount of disk space to use for logs. Valid values are between `25` and `100`.
     */
    diskQuotaMb?: number;
    /**
     * The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
     */
    retentionPeriodDays?: number;
}

export interface LinuxFunctionAppSlotSiteConfigApplicationStack {
    /**
     * A docker block
     */
    dockers?: outputs.LinuxFunctionAppSlotSiteConfigApplicationStackDocker[];
    /**
     * The version of .Net. Possible values are `3.1`, `6.0` and `7.0`
     */
    dotnetVersion?: string;
    /**
     * The version of Java to use. Possible values are `8`, `11`, and `17`
     */
    javaVersion?: string;
    /**
     * The version of Node to use. Possible values include `12`, `14`, `16`, `18` and `20`
     */
    nodeVersion?: string;
    /**
     * The version of PowerShell Core to use. Possibles values are `7`, `7.2`, and `7.4`
     */
    powershellCoreVersion?: string;
    /**
     * The version of Python to use. Possible values include `3.12`, `3.11`, `3.10`, `3.9`, `3.8`, and `3.7`.
     */
    pythonVersion?: string;
    useCustomRuntime?: boolean;
    /**
     * Should the DotNet process use an isolated runtime. Defaults to `false`.
     */
    useDotnetIsolatedRuntime?: boolean;
}

export interface LinuxFunctionAppSlotSiteConfigApplicationStackDocker {
    /**
     * The name of the Docker image to use.
     */
    imageName: string;
    /**
     * The image tag of the image to use.
     */
    imageTag: string;
    /**
     * The password for the account to use to connect to the registry.
     */
    registryPassword?: string;
    /**
     * The URL of the docker registry.
     */
    registryUrl: string;
    /**
     * The username to use for connections to the registry.
     */
    registryUsername?: string;
}

export interface LinuxFunctionAppSlotSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface LinuxFunctionAppSlotSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxFunctionAppSlotSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxFunctionAppSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxFunctionAppSlotSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxFunctionAppSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxFunctionAppSlotSiteCredential {
    name: string;
    password: string;
}

export interface LinuxFunctionAppSlotStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface LinuxFunctionAppSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxFunctionAppStickySettings {
    appSettingNames?: string[];
    connectionStringNames?: string[];
}

export interface LinuxFunctionAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface LinuxFunctionAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxVirtualMachineAdditionalCapabilities {
    hibernationEnabled?: boolean;
    ultraSsdEnabled?: boolean;
}

export interface LinuxVirtualMachineAdminSshKey {
    publicKey: string;
    username: string;
}

export interface LinuxVirtualMachineBootDiagnostics {
    storageAccountUri?: string;
}

export interface LinuxVirtualMachineGalleryApplication {
    automaticUpgradeEnabled?: boolean;
    configurationBlobUri?: string;
    order?: number;
    tag?: string;
    treatFailureAsDeploymentFailureEnabled?: boolean;
    versionId: string;
}

export interface LinuxVirtualMachineIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxVirtualMachineOsDisk {
    caching: string;
    diffDiskSettings?: outputs.LinuxVirtualMachineOsDiskDiffDiskSettings;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    name: string;
    secureVmDiskEncryptionSetId?: string;
    securityEncryptionType?: string;
    storageAccountType: string;
    writeAcceleratorEnabled?: boolean;
}

export interface LinuxVirtualMachineOsDiskDiffDiskSettings {
    option: string;
    placement?: string;
}

export interface LinuxVirtualMachineOsImageNotification {
    timeout?: string;
}

export interface LinuxVirtualMachinePlan {
    name: string;
    product: string;
    publisher: string;
}

export interface LinuxVirtualMachineScaleSetAdditionalCapabilities {
    ultraSsdEnabled?: boolean;
}

export interface LinuxVirtualMachineScaleSetAdminSshKey {
    publicKey: string;
    username: string;
}

export interface LinuxVirtualMachineScaleSetAutomaticInstanceRepair {
    action: string;
    enabled: boolean;
    gracePeriod: string;
}

export interface LinuxVirtualMachineScaleSetAutomaticOsUpgradePolicy {
    disableAutomaticRollback: boolean;
    enableAutomaticOsUpgrade: boolean;
}

export interface LinuxVirtualMachineScaleSetBootDiagnostics {
    storageAccountUri?: string;
}

export interface LinuxVirtualMachineScaleSetDataDisk {
    caching: string;
    createOption?: string;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    lun: number;
    name?: string;
    storageAccountType: string;
    ultraSsdDiskIopsReadWrite: number;
    ultraSsdDiskMbpsReadWrite: number;
    writeAcceleratorEnabled?: boolean;
}

export interface LinuxVirtualMachineScaleSetExtension {
    autoUpgradeMinorVersion?: boolean;
    automaticUpgradeEnabled?: boolean;
    forceUpdateTag?: string;
    name: string;
    protectedSettings?: string;
    protectedSettingsFromKeyVault?: outputs.LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: string;
    type: string;
    typeHandlerVersion: string;
}

export interface LinuxVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVaultId: string;
}

export interface LinuxVirtualMachineScaleSetGalleryApplication {
    configurationBlobUri?: string;
    order?: number;
    tag?: string;
    versionId: string;
}

export interface LinuxVirtualMachineScaleSetIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxVirtualMachineScaleSetNetworkInterface {
    dnsServers?: string[];
    enableAcceleratedNetworking?: boolean;
    enableIpForwarding?: boolean;
    ipConfigurations: outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
    name: string;
    networkSecurityGroupId?: string;
    primary?: boolean;
}

export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolIds?: string[];
    applicationSecurityGroupIds?: string[];
    loadBalancerBackendAddressPoolIds?: string[];
    loadBalancerInboundNatRulesIds?: string[];
    name: string;
    primary?: boolean;
    publicIpAddresses?: outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
    subnetId?: string;
    version?: string;
}

export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
    domainNameLabel?: string;
    idleTimeoutInMinutes: number;
    ipTags?: outputs.LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
    name: string;
    publicIpPrefixId?: string;
    version?: string;
}

export interface LinuxVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
    tag: string;
    type: string;
}

export interface LinuxVirtualMachineScaleSetOsDisk {
    caching: string;
    diffDiskSettings?: outputs.LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    secureVmDiskEncryptionSetId?: string;
    securityEncryptionType?: string;
    storageAccountType: string;
    writeAcceleratorEnabled?: boolean;
}

export interface LinuxVirtualMachineScaleSetOsDiskDiffDiskSettings {
    option: string;
    placement?: string;
}

export interface LinuxVirtualMachineScaleSetPlan {
    name: string;
    product: string;
    publisher: string;
}

export interface LinuxVirtualMachineScaleSetRollingUpgradePolicy {
    crossZoneUpgradesEnabled?: boolean;
    maxBatchInstancePercent: number;
    maxUnhealthyInstancePercent: number;
    maxUnhealthyUpgradedInstancePercent: number;
    maximumSurgeInstancesEnabled?: boolean;
    pauseTimeBetweenBatches: string;
    prioritizeUnhealthyInstancesEnabled?: boolean;
}

export interface LinuxVirtualMachineScaleSetScaleIn {
    forceDeletionEnabled?: boolean;
    rule?: string;
}

export interface LinuxVirtualMachineScaleSetSecret {
    certificates: outputs.LinuxVirtualMachineScaleSetSecretCertificate[];
    keyVaultId: string;
}

export interface LinuxVirtualMachineScaleSetSecretCertificate {
    url: string;
}

export interface LinuxVirtualMachineScaleSetSourceImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface LinuxVirtualMachineScaleSetSpotRestore {
    enabled?: boolean;
    timeout?: string;
}

export interface LinuxVirtualMachineScaleSetTerminationNotification {
    enabled: boolean;
    timeout?: string;
}

export interface LinuxVirtualMachineScaleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxVirtualMachineSecret {
    certificates: outputs.LinuxVirtualMachineSecretCertificate[];
    keyVaultId: string;
}

export interface LinuxVirtualMachineSecretCertificate {
    url: string;
}

export interface LinuxVirtualMachineSourceImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface LinuxVirtualMachineTerminationNotification {
    enabled: boolean;
    timeout?: string;
}

export interface LinuxVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxWebAppAuthSettings {
    activeDirectory?: outputs.LinuxWebAppAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.LinuxWebAppAuthSettingsFacebook;
    github?: outputs.LinuxWebAppAuthSettingsGithub;
    google?: outputs.LinuxWebAppAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.LinuxWebAppAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.LinuxWebAppAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface LinuxWebAppAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface LinuxWebAppAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface LinuxWebAppAuthSettingsV2 {
    activeDirectoryV2?: outputs.LinuxWebAppAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.LinuxWebAppAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.LinuxWebAppAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.LinuxWebAppAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.LinuxWebAppAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.LinuxWebAppAuthSettingsV2GithubV2;
    googleV2?: outputs.LinuxWebAppAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.LinuxWebAppAuthSettingsV2Login;
    microsoftV2?: outputs.LinuxWebAppAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.LinuxWebAppAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface LinuxWebAppAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface LinuxWebAppAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface LinuxWebAppAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface LinuxWebAppAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface LinuxWebAppAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface LinuxWebAppAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface LinuxWebAppBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.LinuxWebAppBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface LinuxWebAppBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface LinuxWebAppConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface LinuxWebAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxWebAppLogs {
    applicationLogs?: outputs.LinuxWebAppLogsApplicationLogs;
    detailedErrorMessages?: boolean;
    failedRequestTracing?: boolean;
    httpLogs?: outputs.LinuxWebAppLogsHttpLogs;
}

export interface LinuxWebAppLogsApplicationLogs {
    azureBlobStorage?: outputs.LinuxWebAppLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel: string;
}

export interface LinuxWebAppLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface LinuxWebAppLogsHttpLogs {
    azureBlobStorage?: outputs.LinuxWebAppLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.LinuxWebAppLogsHttpLogsFileSystem;
}

export interface LinuxWebAppLogsHttpLogsAzureBlobStorage {
    retentionInDays?: number;
    sasUrl: string;
}

export interface LinuxWebAppLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface LinuxWebAppSiteConfig {
    alwaysOn?: boolean;
    apiDefinitionUrl?: string;
    apiManagementApiId?: string;
    appCommandLine?: string;
    applicationStack?: outputs.LinuxWebAppSiteConfigApplicationStack;
    autoHealSetting?: outputs.LinuxWebAppSiteConfigAutoHealSetting;
    containerRegistryManagedIdentityClientId?: string;
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.LinuxWebAppSiteConfigCors;
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.LinuxWebAppSiteConfigIpRestriction[];
    linuxFxVersion: string;
    loadBalancingMode?: string;
    localMysqlEnabled?: boolean;
    managedPipelineMode?: string;
    minimumTlsVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.LinuxWebAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion?: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    websocketsEnabled?: boolean;
    workerCount: number;
}

export interface LinuxWebAppSiteConfigApplicationStack {
    dockerImageName?: string;
    dockerRegistryPassword?: string;
    dockerRegistryUrl?: string;
    dockerRegistryUsername?: string;
    dotnetVersion?: string;
    goVersion?: string;
    javaServer?: string;
    javaServerVersion?: string;
    javaVersion?: string;
    nodeVersion?: string;
    phpVersion?: string;
    pythonVersion?: string;
    rubyVersion?: string;
}

export interface LinuxWebAppSiteConfigAutoHealSetting {
    action?: outputs.LinuxWebAppSiteConfigAutoHealSettingAction;
    trigger?: outputs.LinuxWebAppSiteConfigAutoHealSettingTrigger;
}

export interface LinuxWebAppSiteConfigAutoHealSettingAction {
    actionType: string;
    minimumProcessExecutionTime: string;
}

export interface LinuxWebAppSiteConfigAutoHealSettingTrigger {
    requests?: outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerRequests;
    slowRequest?: outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest;
    slowRequestWithPaths?: outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    statusCodes?: outputs.LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface LinuxWebAppSiteConfigAutoHealSettingTriggerRequests {
    count: number;
    interval: string;
}

export interface LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface LinuxWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path?: string;
    timeTaken: string;
}

export interface LinuxWebAppSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path?: string;
    statusCodeRange: string;
    subStatus?: number;
    win32StatusCode?: number;
}

export interface LinuxWebAppSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface LinuxWebAppSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxWebAppSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxWebAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxWebAppSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxWebAppSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxWebAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxWebAppSiteCredential {
    name: string;
    password: string;
}

export interface LinuxWebAppSlotAuthSettings {
    activeDirectory?: outputs.LinuxWebAppSlotAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.LinuxWebAppSlotAuthSettingsFacebook;
    github?: outputs.LinuxWebAppSlotAuthSettingsGithub;
    google?: outputs.LinuxWebAppSlotAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.LinuxWebAppSlotAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.LinuxWebAppSlotAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface LinuxWebAppSlotAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface LinuxWebAppSlotAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface LinuxWebAppSlotAuthSettingsV2 {
    activeDirectoryV2?: outputs.LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.LinuxWebAppSlotAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.LinuxWebAppSlotAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.LinuxWebAppSlotAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.LinuxWebAppSlotAuthSettingsV2GithubV2;
    googleV2?: outputs.LinuxWebAppSlotAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.LinuxWebAppSlotAuthSettingsV2Login;
    microsoftV2?: outputs.LinuxWebAppSlotAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.LinuxWebAppSlotAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface LinuxWebAppSlotAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface LinuxWebAppSlotAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface LinuxWebAppSlotAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface LinuxWebAppSlotAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface LinuxWebAppSlotAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface LinuxWebAppSlotAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface LinuxWebAppSlotAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface LinuxWebAppSlotBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.LinuxWebAppSlotBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface LinuxWebAppSlotBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface LinuxWebAppSlotConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface LinuxWebAppSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LinuxWebAppSlotLogs {
    applicationLogs?: outputs.LinuxWebAppSlotLogsApplicationLogs;
    detailedErrorMessages?: boolean;
    failedRequestTracing?: boolean;
    httpLogs?: outputs.LinuxWebAppSlotLogsHttpLogs;
}

export interface LinuxWebAppSlotLogsApplicationLogs {
    azureBlobStorage?: outputs.LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel: string;
}

export interface LinuxWebAppSlotLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface LinuxWebAppSlotLogsHttpLogs {
    azureBlobStorage?: outputs.LinuxWebAppSlotLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.LinuxWebAppSlotLogsHttpLogsFileSystem;
}

export interface LinuxWebAppSlotLogsHttpLogsAzureBlobStorage {
    retentionInDays?: number;
    sasUrl: string;
}

export interface LinuxWebAppSlotLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface LinuxWebAppSlotSiteConfig {
    alwaysOn?: boolean;
    apiDefinitionUrl?: string;
    apiManagementApiId?: string;
    appCommandLine?: string;
    applicationStack?: outputs.LinuxWebAppSlotSiteConfigApplicationStack;
    autoHealSetting?: outputs.LinuxWebAppSlotSiteConfigAutoHealSetting;
    autoSwapSlotName?: string;
    containerRegistryManagedIdentityClientId?: string;
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.LinuxWebAppSlotSiteConfigCors;
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.LinuxWebAppSlotSiteConfigIpRestriction[];
    linuxFxVersion: string;
    loadBalancingMode?: string;
    localMysqlEnabled?: boolean;
    managedPipelineMode?: string;
    minimumTlsVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.LinuxWebAppSlotSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion?: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    websocketsEnabled?: boolean;
    workerCount: number;
}

export interface LinuxWebAppSlotSiteConfigApplicationStack {
    dockerImageName?: string;
    dockerRegistryPassword?: string;
    dockerRegistryUrl?: string;
    dockerRegistryUsername?: string;
    dotnetVersion?: string;
    goVersion?: string;
    javaServer?: string;
    javaServerVersion?: string;
    javaVersion?: string;
    nodeVersion?: string;
    phpVersion?: string;
    pythonVersion?: string;
    rubyVersion?: string;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSetting {
    action?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingAction;
    trigger?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTrigger;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingAction {
    actionType: string;
    minimumProcessExecutionTime: string;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingTrigger {
    requests?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests;
    slowRequest?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest;
    slowRequestWithPaths?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    statusCodes?: outputs.LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerRequests {
    count: number;
    interval: string;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path?: string;
    timeTaken: string;
}

export interface LinuxWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path?: string;
    statusCodeRange: string;
    subStatus?: number;
    win32StatusCode?: number;
}

export interface LinuxWebAppSlotSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface LinuxWebAppSlotSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxWebAppSlotSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxWebAppSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxWebAppSlotSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.LinuxWebAppSlotSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface LinuxWebAppSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LinuxWebAppSlotSiteCredential {
    name: string;
    password: string;
}

export interface LinuxWebAppSlotStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface LinuxWebAppSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LinuxWebAppStickySettings {
    appSettingNames?: string[];
    connectionStringNames?: string[];
}

export interface LinuxWebAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface LinuxWebAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LoadTestEncryption {
    identity: outputs.LoadTestEncryptionIdentity;
    keyUrl: string;
}

export interface LoadTestEncryptionIdentity {
    identityId: string;
    type: string;
}

export interface LoadTestIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LoadTestTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LocalNetworkGatewayBgpSettings {
    asn: number;
    bgpPeeringAddress: string;
    peerWeight?: number;
}

export interface LocalNetworkGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsClusterCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsClusterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LogAnalyticsClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsDataExportRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsDatasourceWindowsEventTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsDatasourceWindowsPerformanceCounterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsLinkedServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsLinkedStorageAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsQueryPackQueryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsQueryPackTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsSavedSearchTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface LogAnalyticsSolutionPlan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
}

export interface LogAnalyticsSolutionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsStorageInsightsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsWorkspaceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LogAnalyticsWorkspaceTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogAnalyticsWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppActionCustomTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppActionHttpRunAfter {
    actionName: string;
    actionResult: string;
}

export interface LogicAppActionHttpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountAgreementGuestIdentity {
    qualifier: string;
    value: string;
}

export interface LogicAppIntegrationAccountAgreementHostIdentity {
    qualifier: string;
    value: string;
}

export interface LogicAppIntegrationAccountAgreementTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountAssemblyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountBatchConfigurationReleaseCriteria {
    batchSize?: number;
    messageCount?: number;
    recurrence?: outputs.LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrence;
}

export interface LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrence {
    endTime?: string;
    frequency: string;
    interval: number;
    schedule?: outputs.LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceSchedule;
    startTime?: string;
    timeZone?: string;
}

export interface LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceSchedule {
    hours?: number[];
    minutes?: number[];
    monthDays?: number[];
    monthlies?: outputs.LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceScheduleMonthly[];
    weekDays?: string[];
}

export interface LogicAppIntegrationAccountBatchConfigurationReleaseCriteriaRecurrenceScheduleMonthly {
    week: number;
    weekday: string;
}

export interface LogicAppIntegrationAccountBatchConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountCertificateKeyVaultKey {
    keyName: string;
    keyVaultId: string;
    keyVersion?: string;
}

export interface LogicAppIntegrationAccountCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountMapTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountPartnerBusinessIdentity {
    qualifier: string;
    value: string;
}

export interface LogicAppIntegrationAccountPartnerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountSchemaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountSessionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppIntegrationAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppStandardConnectionString {
    name: string;
    type: string;
    value: string;
}

export interface LogicAppStandardIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LogicAppStandardSiteConfig {
    alwaysOn?: boolean;
    appScaleLimit: number;
    autoSwapSlotName: string;
    cors?: outputs.LogicAppStandardSiteConfigCors;
    dotnetFrameworkVersion?: string;
    elasticInstanceMinimum: number;
    ftpsState: string;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictions: outputs.LogicAppStandardSiteConfigIpRestriction[];
    linuxFxVersion: string;
    minTlsVersion: string;
    preWarmedInstanceCount: number;
    publicNetworkAccessEnabled?: boolean;
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictions: outputs.LogicAppStandardSiteConfigScmIpRestriction[];
    scmMinTlsVersion: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorkerProcess?: boolean;
    vnetRouteAllEnabled: boolean;
    websocketsEnabled?: boolean;
}

export interface LogicAppStandardSiteConfigCors {
    allowedOrigins: string[];
    supportCredentials?: boolean;
}

export interface LogicAppStandardSiteConfigIpRestriction {
    action: string;
    headers: outputs.LogicAppStandardSiteConfigIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface LogicAppStandardSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LogicAppStandardSiteConfigScmIpRestriction {
    action: string;
    headers: outputs.LogicAppStandardSiteConfigScmIpRestrictionHeader[];
    ipAddress: string;
    name: string;
    priority: number;
    serviceTag: string;
    virtualNetworkSubnetId: string;
}

export interface LogicAppStandardSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface LogicAppStandardSiteCredential {
    password: string;
    username: string;
}

export interface LogicAppStandardTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppTriggerCustomTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppTriggerHttpRequestTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppTriggerRecurrenceSchedule {
    atTheseHours?: number[];
    atTheseMinutes?: number[];
    onTheseDays?: string[];
}

export interface LogicAppTriggerRecurrenceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LogicAppWorkflowAccessControl {
    action?: outputs.LogicAppWorkflowAccessControlAction;
    content?: outputs.LogicAppWorkflowAccessControlContent;
    trigger?: outputs.LogicAppWorkflowAccessControlTrigger;
    workflowManagement?: outputs.LogicAppWorkflowAccessControlWorkflowManagement;
}

export interface LogicAppWorkflowAccessControlAction {
    allowedCallerIpAddressRanges: string[];
}

export interface LogicAppWorkflowAccessControlContent {
    allowedCallerIpAddressRanges: string[];
}

export interface LogicAppWorkflowAccessControlTrigger {
    allowedCallerIpAddressRanges: string[];
    openAuthenticationPolicies?: outputs.LogicAppWorkflowAccessControlTriggerOpenAuthenticationPolicy[];
}

export interface LogicAppWorkflowAccessControlTriggerOpenAuthenticationPolicy {
    claims: outputs.LogicAppWorkflowAccessControlTriggerOpenAuthenticationPolicyClaim[];
    name: string;
}

export interface LogicAppWorkflowAccessControlTriggerOpenAuthenticationPolicyClaim {
    name: string;
    value: string;
}

export interface LogicAppWorkflowAccessControlWorkflowManagement {
    allowedCallerIpAddressRanges: string[];
}

export interface LogicAppWorkflowIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface LogicAppWorkflowTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MachineLearningComputeClusterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MachineLearningComputeClusterScaleSettings {
    maxNodeCount: number;
    minNodeCount: number;
    scaleDownNodesAfterIdleDuration: string;
}

export interface MachineLearningComputeClusterSsh {
    adminPassword?: string;
    adminUsername: string;
    keyValue?: string;
}

export interface MachineLearningComputeClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MachineLearningComputeInstanceAssignToUser {
    objectId?: string;
    tenantId?: string;
}

export interface MachineLearningComputeInstanceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MachineLearningComputeInstanceSsh {
    port: number;
    publicKey: string;
    username: string;
}

export interface MachineLearningComputeInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MachineLearningDatastoreBlobstorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MachineLearningDatastoreDatalakeGen2Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MachineLearningDatastoreFileshareTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MachineLearningInferenceClusterIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MachineLearningInferenceClusterSsl {
    cert?: string;
    cname?: string;
    key?: string;
    leafDomainLabel?: string;
    overwriteExistingDomain?: boolean;
}

export interface MachineLearningInferenceClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MachineLearningSynapseSparkIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MachineLearningSynapseSparkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MachineLearningWorkspaceEncryption {
    keyId: string;
    keyVaultId: string;
    userAssignedIdentityId?: string;
}

export interface MachineLearningWorkspaceFeatureStore {
    computerSparkRuntimeVersion?: string;
    offlineConnectionName?: string;
    onlineConnectionName?: string;
}

export interface MachineLearningWorkspaceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MachineLearningWorkspaceManagedNetwork {
    isolationMode: string;
}

export interface MachineLearningWorkspaceServerlessCompute {
    publicIpEnabled?: boolean;
    subnetId?: string;
}

export interface MachineLearningWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MaintenanceAssignmentDedicatedHostTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MaintenanceAssignmentDynamicScopeFilter {
    locations?: string[];
    osTypes?: string[];
    resourceGroups?: string[];
    resourceTypes?: string[];
    tagFilter?: string;
    tags?: outputs.MaintenanceAssignmentDynamicScopeFilterTag[];
}

export interface MaintenanceAssignmentDynamicScopeFilterTag {
    tag: string;
    values: string[];
}

export interface MaintenanceAssignmentDynamicScopeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MaintenanceAssignmentVirtualMachineScaleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MaintenanceAssignmentVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MaintenanceConfigurationInstallPatches {
    linuxes?: outputs.MaintenanceConfigurationInstallPatchesLinux[];
    reboot?: string;
    windows?: outputs.MaintenanceConfigurationInstallPatchesWindow[];
}

export interface MaintenanceConfigurationInstallPatchesLinux {
    classificationsToIncludes?: string[];
    packageNamesMaskToExcludes?: string[];
    packageNamesMaskToIncludes?: string[];
}

export interface MaintenanceConfigurationInstallPatchesWindow {
    classificationsToIncludes?: string[];
    kbNumbersToExcludes?: string[];
    kbNumbersToIncludes?: string[];
}

export interface MaintenanceConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MaintenanceConfigurationWindow {
    duration?: string;
    expirationDateTime?: string;
    recurEvery?: string;
    startDateTime: string;
    timeZone: string;
}

export interface ManagedApplicationDefinitionAuthorization {
    roleDefinitionId: string;
    servicePrincipalId: string;
}

export interface ManagedApplicationDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagedApplicationPlan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
    version: string;
}

export interface ManagedApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagedDiskEncryptionSettings {
    diskEncryptionKey: outputs.ManagedDiskEncryptionSettingsDiskEncryptionKey;
    keyEncryptionKey?: outputs.ManagedDiskEncryptionSettingsKeyEncryptionKey;
}

export interface ManagedDiskEncryptionSettingsDiskEncryptionKey {
    secretUrl: string;
    sourceVaultId: string;
}

export interface ManagedDiskEncryptionSettingsKeyEncryptionKey {
    keyUrl: string;
    sourceVaultId: string;
}

export interface ManagedDiskSasTokenTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ManagedDiskTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagedLustreFileSystemEncryptionKey {
    keyUrl: string;
    sourceVaultId: string;
}

export interface ManagedLustreFileSystemHsmSetting {
    containerId: string;
    importPrefix?: string;
    loggingContainerId: string;
}

export interface ManagedLustreFileSystemIdentity {
    identityIds: string[];
    type: string;
}

export interface ManagedLustreFileSystemMaintenanceWindow {
    dayOfWeek: string;
    timeOfDayInUtc: string;
}

export interface ManagedLustreFileSystemTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementGroupPolicyAssignmentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ManagementGroupPolicyAssignmentNonComplianceMessage {
    content: string;
    policyDefinitionReferenceId?: string;
}

export interface ManagementGroupPolicyAssignmentOverride {
    selectors?: outputs.ManagementGroupPolicyAssignmentOverrideSelector[];
    value: string;
}

export interface ManagementGroupPolicyAssignmentOverrideSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ManagementGroupPolicyAssignmentResourceSelector {
    name?: string;
    selectors: outputs.ManagementGroupPolicyAssignmentResourceSelectorSelector[];
}

export interface ManagementGroupPolicyAssignmentResourceSelectorSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ManagementGroupPolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementGroupPolicyExemptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementGroupPolicyRemediationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementGroupSubscriptionAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ManagementGroupTemplateDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ManagementLockTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MapsAccountCors {
    allowedOrigins: string[];
}

export interface MapsAccountDataStore {
    storageAccountId?: string;
    uniqueName: string;
}

export interface MapsAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MapsAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MapsCreatorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MarketplaceAgreementTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MarketplaceRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MediaServicesAccountFilterPresentationTimeRange {
    endInUnits?: number;
    forceEnd?: boolean;
    liveBackoffInUnits?: number;
    presentationWindowInUnits?: number;
    startInUnits?: number;
    unitTimescaleInMilliseconds: number;
}

export interface MediaServicesAccountFilterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MediaServicesAccountFilterTrackSelection {
    conditions: outputs.MediaServicesAccountFilterTrackSelectionCondition[];
}

export interface MediaServicesAccountFilterTrackSelectionCondition {
    operation: string;
    property: string;
    value: string;
}

export interface MobileNetworkAttachedDataNetworkNetworkAddressPortTranslation {
    icmpPinholeTimeoutInSeconds?: number;
    pinholeMaximumNumber?: number;
    portRange?: outputs.MobileNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange;
    tcpPinholeTimeoutInSeconds?: number;
    tcpPortReuseMinimumHoldTimeInSeconds?: number;
    udpPinholeTimeoutInSeconds?: number;
    udpPortReuseMinimumHoldTimeInSeconds?: number;
}

export interface MobileNetworkAttachedDataNetworkNetworkAddressPortTranslationPortRange {
    maximum?: number;
    minimum?: number;
}

export interface MobileNetworkAttachedDataNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkDataNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkPacketCoreControlPlaneIdentity {
    identityIds: string[];
    type: string;
}

export interface MobileNetworkPacketCoreControlPlaneLocalDiagnosticsAccess {
    authenticationType: string;
    httpsServerCertificateUrl?: string;
}

export interface MobileNetworkPacketCoreControlPlanePlatform {
    arcKubernetesClusterId?: string;
    customLocationId?: string;
    edgeDeviceId?: string;
    stackHciClusterId?: string;
    type: string;
}

export interface MobileNetworkPacketCoreControlPlaneTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkPacketCoreDataPlaneTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkServicePccRule {
    name: string;
    precedence: number;
    qosPolicy?: outputs.MobileNetworkServicePccRuleQosPolicy;
    serviceDataFlowTemplates: outputs.MobileNetworkServicePccRuleServiceDataFlowTemplate[];
    trafficControlEnabled?: boolean;
}

export interface MobileNetworkServicePccRuleQosPolicy {
    allocationAndRetentionPriorityLevel?: number;
    guaranteedBitRate?: outputs.MobileNetworkServicePccRuleQosPolicyGuaranteedBitRate;
    maximumBitRate: outputs.MobileNetworkServicePccRuleQosPolicyMaximumBitRate;
    preemptionCapability?: string;
    preemptionVulnerability?: string;
    qosIndicator: number;
}

export interface MobileNetworkServicePccRuleQosPolicyGuaranteedBitRate {
    downlink: string;
    uplink: string;
}

export interface MobileNetworkServicePccRuleQosPolicyMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface MobileNetworkServicePccRuleServiceDataFlowTemplate {
    direction: string;
    name: string;
    ports?: string[];
    protocols: string[];
    remoteIpLists: string[];
}

export interface MobileNetworkServiceServiceQosPolicy {
    allocationAndRetentionPriorityLevel?: number;
    maximumBitRate: outputs.MobileNetworkServiceServiceQosPolicyMaximumBitRate;
    preemptionCapability?: string;
    preemptionVulnerability?: string;
    qosIndicator?: number;
}

export interface MobileNetworkServiceServiceQosPolicyMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface MobileNetworkServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkSimGroupIdentity {
    identityIds: string[];
    type: string;
}

export interface MobileNetworkSimGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkSimPolicySlice {
    dataNetworks: outputs.MobileNetworkSimPolicySliceDataNetwork[];
    defaultDataNetworkId: string;
    sliceId: string;
}

export interface MobileNetworkSimPolicySliceDataNetwork {
    additionalAllowedSessionTypes?: string[];
    allocationAndRetentionPriorityLevel?: number;
    allowedServicesIds: string[];
    dataNetworkId: string;
    defaultSessionType?: string;
    maxBufferedPackets?: number;
    preemptionCapability?: string;
    preemptionVulnerability?: string;
    qosIndicator: number;
    sessionAggregateMaximumBitRate: outputs.MobileNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate;
}

export interface MobileNetworkSimPolicySliceDataNetworkSessionAggregateMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface MobileNetworkSimPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkSimPolicyUserEquipmentAggregateMaximumBitRate {
    downlink: string;
    uplink: string;
}

export interface MobileNetworkSimStaticIpConfiguration {
    attachedDataNetworkId: string;
    sliceId: string;
    staticIpv4Address?: string;
}

export interface MobileNetworkSimTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkSiteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkSliceSingleNetworkSliceSelectionAssistanceInformation {
    sliceDifferentiator?: string;
    sliceServiceType: number;
}

export interface MobileNetworkSliceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MobileNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorAadDiagnosticSettingEnabledLog {
    category: string;
    retentionPolicy: outputs.MonitorAadDiagnosticSettingEnabledLogRetentionPolicy;
}

export interface MonitorAadDiagnosticSettingEnabledLogRetentionPolicy {
    days?: number;
    enabled?: boolean;
}

export interface MonitorAadDiagnosticSettingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorActionGroupArmRoleReceiver {
    name: string;
    roleId: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupAutomationRunbookReceiver {
    automationAccountId: string;
    isGlobalRunbook: boolean;
    name: string;
    runbookName: string;
    serviceUri: string;
    useCommonAlertSchema?: boolean;
    webhookResourceId: string;
}

export interface MonitorActionGroupAzureAppPushReceiver {
    emailAddress: string;
    name: string;
}

export interface MonitorActionGroupAzureFunctionReceiver {
    functionAppResourceId: string;
    functionName: string;
    httpTriggerUrl: string;
    name: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupEmailReceiver {
    emailAddress: string;
    name: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupEventHubReceiver {
    eventHubName: string;
    eventHubNamespace: string;
    name: string;
    subscriptionId: string;
    tenantId: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupItsmReceiver {
    connectionId: string;
    name: string;
    region: string;
    ticketConfiguration: string;
    workspaceId: string;
}

export interface MonitorActionGroupLogicAppReceiver {
    callbackUrl: string;
    name: string;
    resourceId: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupSmsReceiver {
    countryCode: string;
    name: string;
    phoneNumber: string;
}

export interface MonitorActionGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorActionGroupVoiceReceiver {
    countryCode: string;
    name: string;
    phoneNumber: string;
}

export interface MonitorActionGroupWebhookReceiver {
    aadAuth?: outputs.MonitorActionGroupWebhookReceiverAadAuth;
    name: string;
    serviceUri: string;
    useCommonAlertSchema?: boolean;
}

export interface MonitorActionGroupWebhookReceiverAadAuth {
    identifierUri: string;
    objectId: string;
    tenantId: string;
}

export interface MonitorActivityLogAlertAction {
    actionGroupId: string;
    webhookProperties?: {[key: string]: string};
}

export interface MonitorActivityLogAlertCriteria {
    caller?: string;
    category: string;
    level?: string;
    levels?: string[];
    operationName?: string;
    recommendationCategory?: string;
    recommendationImpact?: string;
    recommendationType?: string;
    resourceGroup?: string;
    resourceGroups?: string[];
    resourceHealth?: outputs.MonitorActivityLogAlertCriteriaResourceHealth;
    resourceId?: string;
    resourceIds?: string[];
    resourceProvider?: string;
    resourceProviders?: string[];
    resourceType?: string;
    resourceTypes?: string[];
    serviceHealth?: outputs.MonitorActivityLogAlertCriteriaServiceHealth;
    status?: string;
    statuses?: string[];
    subStatus?: string;
    subStatuses?: string[];
}

export interface MonitorActivityLogAlertCriteriaResourceHealth {
    currents?: string[];
    previouses?: string[];
    reasons?: string[];
}

export interface MonitorActivityLogAlertCriteriaServiceHealth {
    events?: string[];
    locations?: string[];
    services?: string[];
}

export interface MonitorActivityLogAlertTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorAlertProcessingRuleActionGroupCondition {
    alertContext?: outputs.MonitorAlertProcessingRuleActionGroupConditionAlertContext;
    alertRuleId?: outputs.MonitorAlertProcessingRuleActionGroupConditionAlertRuleId;
    alertRuleName?: outputs.MonitorAlertProcessingRuleActionGroupConditionAlertRuleName;
    description?: outputs.MonitorAlertProcessingRuleActionGroupConditionDescription;
    monitorCondition?: outputs.MonitorAlertProcessingRuleActionGroupConditionMonitorCondition;
    monitorService?: outputs.MonitorAlertProcessingRuleActionGroupConditionMonitorService;
    severity?: outputs.MonitorAlertProcessingRuleActionGroupConditionSeverity;
    signalType?: outputs.MonitorAlertProcessingRuleActionGroupConditionSignalType;
    targetResource?: outputs.MonitorAlertProcessingRuleActionGroupConditionTargetResource;
    targetResourceGroup?: outputs.MonitorAlertProcessingRuleActionGroupConditionTargetResourceGroup;
    targetResourceType?: outputs.MonitorAlertProcessingRuleActionGroupConditionTargetResourceType;
}

export interface MonitorAlertProcessingRuleActionGroupConditionAlertContext {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionAlertRuleId {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionAlertRuleName {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionDescription {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionMonitorCondition {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionMonitorService {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionSeverity {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionSignalType {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionTargetResource {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionTargetResourceGroup {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupConditionTargetResourceType {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleActionGroupSchedule {
    effectiveFrom?: string;
    effectiveUntil?: string;
    recurrence?: outputs.MonitorAlertProcessingRuleActionGroupScheduleRecurrence;
    timeZone?: string;
}

export interface MonitorAlertProcessingRuleActionGroupScheduleRecurrence {
    dailies?: outputs.MonitorAlertProcessingRuleActionGroupScheduleRecurrenceDaily[];
    monthlies?: outputs.MonitorAlertProcessingRuleActionGroupScheduleRecurrenceMonthly[];
    weeklies?: outputs.MonitorAlertProcessingRuleActionGroupScheduleRecurrenceWeekly[];
}

export interface MonitorAlertProcessingRuleActionGroupScheduleRecurrenceDaily {
    endTime: string;
    startTime: string;
}

export interface MonitorAlertProcessingRuleActionGroupScheduleRecurrenceMonthly {
    daysOfMonths: number[];
    endTime?: string;
    startTime?: string;
}

export interface MonitorAlertProcessingRuleActionGroupScheduleRecurrenceWeekly {
    daysOfWeeks: string[];
    endTime?: string;
    startTime?: string;
}

export interface MonitorAlertProcessingRuleActionGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorAlertProcessingRuleSuppressionCondition {
    alertContext?: outputs.MonitorAlertProcessingRuleSuppressionConditionAlertContext;
    alertRuleId?: outputs.MonitorAlertProcessingRuleSuppressionConditionAlertRuleId;
    alertRuleName?: outputs.MonitorAlertProcessingRuleSuppressionConditionAlertRuleName;
    description?: outputs.MonitorAlertProcessingRuleSuppressionConditionDescription;
    monitorCondition?: outputs.MonitorAlertProcessingRuleSuppressionConditionMonitorCondition;
    monitorService?: outputs.MonitorAlertProcessingRuleSuppressionConditionMonitorService;
    severity?: outputs.MonitorAlertProcessingRuleSuppressionConditionSeverity;
    signalType?: outputs.MonitorAlertProcessingRuleSuppressionConditionSignalType;
    targetResource?: outputs.MonitorAlertProcessingRuleSuppressionConditionTargetResource;
    targetResourceGroup?: outputs.MonitorAlertProcessingRuleSuppressionConditionTargetResourceGroup;
    targetResourceType?: outputs.MonitorAlertProcessingRuleSuppressionConditionTargetResourceType;
}

export interface MonitorAlertProcessingRuleSuppressionConditionAlertContext {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionAlertRuleId {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionAlertRuleName {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionDescription {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionMonitorCondition {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionMonitorService {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionSeverity {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionSignalType {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionTargetResource {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionTargetResourceGroup {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionConditionTargetResourceType {
    operator: string;
    values: string[];
}

export interface MonitorAlertProcessingRuleSuppressionSchedule {
    effectiveFrom?: string;
    effectiveUntil?: string;
    recurrence?: outputs.MonitorAlertProcessingRuleSuppressionScheduleRecurrence;
    timeZone?: string;
}

export interface MonitorAlertProcessingRuleSuppressionScheduleRecurrence {
    dailies?: outputs.MonitorAlertProcessingRuleSuppressionScheduleRecurrenceDaily[];
    monthlies?: outputs.MonitorAlertProcessingRuleSuppressionScheduleRecurrenceMonthly[];
    weeklies?: outputs.MonitorAlertProcessingRuleSuppressionScheduleRecurrenceWeekly[];
}

export interface MonitorAlertProcessingRuleSuppressionScheduleRecurrenceDaily {
    endTime: string;
    startTime: string;
}

export interface MonitorAlertProcessingRuleSuppressionScheduleRecurrenceMonthly {
    daysOfMonths: number[];
    endTime?: string;
    startTime?: string;
}

export interface MonitorAlertProcessingRuleSuppressionScheduleRecurrenceWeekly {
    daysOfWeeks: string[];
    endTime?: string;
    startTime?: string;
}

export interface MonitorAlertProcessingRuleSuppressionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorAlertPrometheusRuleGroupRule {
    actions?: outputs.MonitorAlertPrometheusRuleGroupRuleAction[];
    alert?: string;
    alertResolution?: outputs.MonitorAlertPrometheusRuleGroupRuleAlertResolution;
    annotations?: {[key: string]: string};
    enabled?: boolean;
    expression: string;
    for?: string;
    labels?: {[key: string]: string};
    record?: string;
    severity?: number;
}

export interface MonitorAlertPrometheusRuleGroupRuleAction {
    actionGroupId: string;
    actionProperties?: {[key: string]: string};
}

export interface MonitorAlertPrometheusRuleGroupRuleAlertResolution {
    autoResolved?: boolean;
    timeToResolve?: string;
}

export interface MonitorAlertPrometheusRuleGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorAutoscaleSettingNotification {
    email?: outputs.MonitorAutoscaleSettingNotificationEmail;
    webhooks?: outputs.MonitorAutoscaleSettingNotificationWebhook[];
}

export interface MonitorAutoscaleSettingNotificationEmail {
    customEmails?: string[];
    sendToSubscriptionAdministrator?: boolean;
    sendToSubscriptionCoAdministrator?: boolean;
}

export interface MonitorAutoscaleSettingNotificationWebhook {
    properties?: {[key: string]: string};
    serviceUri: string;
}

export interface MonitorAutoscaleSettingPredictive {
    lookAheadTime?: string;
    scaleMode: string;
}

export interface MonitorAutoscaleSettingProfile {
    capacity: outputs.MonitorAutoscaleSettingProfileCapacity;
    fixedDate?: outputs.MonitorAutoscaleSettingProfileFixedDate;
    name: string;
    recurrence?: outputs.MonitorAutoscaleSettingProfileRecurrence;
    rules?: outputs.MonitorAutoscaleSettingProfileRule[];
}

export interface MonitorAutoscaleSettingProfileCapacity {
    default: number;
    maximum: number;
    minimum: number;
}

export interface MonitorAutoscaleSettingProfileFixedDate {
    end: string;
    start: string;
    timezone?: string;
}

export interface MonitorAutoscaleSettingProfileRecurrence {
    days: string[];
    hours: number[];
    minutes: number[];
    timezone?: string;
}

export interface MonitorAutoscaleSettingProfileRule {
    metricTrigger: outputs.MonitorAutoscaleSettingProfileRuleMetricTrigger;
    scaleAction: outputs.MonitorAutoscaleSettingProfileRuleScaleAction;
}

export interface MonitorAutoscaleSettingProfileRuleMetricTrigger {
    dimensions?: outputs.MonitorAutoscaleSettingProfileRuleMetricTriggerDimension[];
    divideByInstanceCount?: boolean;
    metricName: string;
    metricNamespace?: string;
    metricResourceId: string;
    operator: string;
    statistic: string;
    threshold: number;
    timeAggregation: string;
    timeGrain: string;
    timeWindow: string;
}

export interface MonitorAutoscaleSettingProfileRuleMetricTriggerDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface MonitorAutoscaleSettingProfileRuleScaleAction {
    cooldown: string;
    direction: string;
    type: string;
    value: number;
}

export interface MonitorAutoscaleSettingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorDataCollectionEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorDataCollectionRuleAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorDataCollectionRuleDataFlow {
    builtInTransform?: string;
    destinations: string[];
    outputStream?: string;
    streams: string[];
    transformKql?: string;
}

export interface MonitorDataCollectionRuleDataSources {
    dataImport?: outputs.MonitorDataCollectionRuleDataSourcesDataImport;
    extensions?: outputs.MonitorDataCollectionRuleDataSourcesExtension[];
    iisLogs?: outputs.MonitorDataCollectionRuleDataSourcesIisLog[];
    logFiles?: outputs.MonitorDataCollectionRuleDataSourcesLogFile[];
    performanceCounters?: outputs.MonitorDataCollectionRuleDataSourcesPerformanceCounter[];
    platformTelemetries?: outputs.MonitorDataCollectionRuleDataSourcesPlatformTelemetry[];
    prometheusForwarders?: outputs.MonitorDataCollectionRuleDataSourcesPrometheusForwarder[];
    syslogs?: outputs.MonitorDataCollectionRuleDataSourcesSyslog[];
    windowsEventLogs?: outputs.MonitorDataCollectionRuleDataSourcesWindowsEventLog[];
    windowsFirewallLogs?: outputs.MonitorDataCollectionRuleDataSourcesWindowsFirewallLog[];
}

export interface MonitorDataCollectionRuleDataSourcesDataImport {
    eventHubDataSources: outputs.MonitorDataCollectionRuleDataSourcesDataImportEventHubDataSource[];
}

export interface MonitorDataCollectionRuleDataSourcesDataImportEventHubDataSource {
    consumerGroup?: string;
    name: string;
    stream: string;
}

export interface MonitorDataCollectionRuleDataSourcesExtension {
    extensionJson?: string;
    extensionName: string;
    inputDataSources?: string[];
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesIisLog {
    logDirectories?: string[];
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesLogFile {
    filePatterns: string[];
    format: string;
    name: string;
    settings?: outputs.MonitorDataCollectionRuleDataSourcesLogFileSettings;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesLogFileSettings {
    text: outputs.MonitorDataCollectionRuleDataSourcesLogFileSettingsText;
}

export interface MonitorDataCollectionRuleDataSourcesLogFileSettingsText {
    recordStartTimestampFormat: string;
}

export interface MonitorDataCollectionRuleDataSourcesPerformanceCounter {
    counterSpecifiers: string[];
    name: string;
    samplingFrequencyInSeconds: number;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesPlatformTelemetry {
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesPrometheusForwarder {
    labelIncludeFilters?: outputs.MonitorDataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter[];
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesPrometheusForwarderLabelIncludeFilter {
    label: string;
    value: string;
}

export interface MonitorDataCollectionRuleDataSourcesSyslog {
    facilityNames: string[];
    logLevels: string[];
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDataSourcesWindowsEventLog {
    name: string;
    streams: string[];
    xPathQueries: string[];
}

export interface MonitorDataCollectionRuleDataSourcesWindowsFirewallLog {
    name: string;
    streams: string[];
}

export interface MonitorDataCollectionRuleDestinations {
    azureMonitorMetrics?: outputs.MonitorDataCollectionRuleDestinationsAzureMonitorMetrics;
    eventHub?: outputs.MonitorDataCollectionRuleDestinationsEventHub;
    eventHubDirect?: outputs.MonitorDataCollectionRuleDestinationsEventHubDirect;
    logAnalytics?: outputs.MonitorDataCollectionRuleDestinationsLogAnalytic[];
    monitorAccounts?: outputs.MonitorDataCollectionRuleDestinationsMonitorAccount[];
    storageBlobDirects?: outputs.MonitorDataCollectionRuleDestinationsStorageBlobDirect[];
    storageBlobs?: outputs.MonitorDataCollectionRuleDestinationsStorageBlob[];
    storageTableDirects?: outputs.MonitorDataCollectionRuleDestinationsStorageTableDirect[];
}

export interface MonitorDataCollectionRuleDestinationsAzureMonitorMetrics {
    name: string;
}

export interface MonitorDataCollectionRuleDestinationsEventHub {
    eventHubId: string;
    name: string;
}

export interface MonitorDataCollectionRuleDestinationsEventHubDirect {
    eventHubId: string;
    name: string;
}

export interface MonitorDataCollectionRuleDestinationsLogAnalytic {
    name: string;
    workspaceResourceId: string;
}

export interface MonitorDataCollectionRuleDestinationsMonitorAccount {
    monitorAccountId: string;
    name: string;
}

export interface MonitorDataCollectionRuleDestinationsStorageBlob {
    containerName: string;
    name: string;
    storageAccountId: string;
}

export interface MonitorDataCollectionRuleDestinationsStorageBlobDirect {
    containerName: string;
    name: string;
    storageAccountId: string;
}

export interface MonitorDataCollectionRuleDestinationsStorageTableDirect {
    name: string;
    storageAccountId: string;
    tableName: string;
}

export interface MonitorDataCollectionRuleIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MonitorDataCollectionRuleStreamDeclaration {
    columns: outputs.MonitorDataCollectionRuleStreamDeclarationColumn[];
    streamName: string;
}

export interface MonitorDataCollectionRuleStreamDeclarationColumn {
    name: string;
    type: string;
}

export interface MonitorDataCollectionRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorDiagnosticSettingEnabledLog {
    category?: string;
    categoryGroup?: string;
    /**
     * @deprecated Deprecated
     */
    retentionPolicy?: outputs.MonitorDiagnosticSettingEnabledLogRetentionPolicy;
}

export interface MonitorDiagnosticSettingEnabledLogRetentionPolicy {
    days?: number;
    enabled: boolean;
}

export interface MonitorDiagnosticSettingMetric {
    category: string;
    enabled?: boolean;
    /**
     * @deprecated Deprecated
     */
    retentionPolicy?: outputs.MonitorDiagnosticSettingMetricRetentionPolicy;
}

export interface MonitorDiagnosticSettingMetricRetentionPolicy {
    days?: number;
    enabled: boolean;
}

export interface MonitorDiagnosticSettingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorLogProfileRetentionPolicy {
    days?: number;
    enabled: boolean;
}

export interface MonitorLogProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorMetricAlertAction {
    actionGroupId: string;
    webhookProperties?: {[key: string]: string};
}

export interface MonitorMetricAlertApplicationInsightsWebTestLocationAvailabilityCriteria {
    componentId: string;
    failedLocationCount: number;
    webTestId: string;
}

export interface MonitorMetricAlertCriteria {
    aggregation: string;
    dimensions?: outputs.MonitorMetricAlertCriteriaDimension[];
    metricName: string;
    metricNamespace: string;
    operator: string;
    skipMetricValidation?: boolean;
    threshold: number;
}

export interface MonitorMetricAlertCriteriaDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface MonitorMetricAlertDynamicCriteria {
    aggregation: string;
    alertSensitivity: string;
    dimensions?: outputs.MonitorMetricAlertDynamicCriteriaDimension[];
    evaluationFailureCount?: number;
    evaluationTotalCount?: number;
    ignoreDataBefore?: string;
    metricName: string;
    metricNamespace: string;
    operator: string;
    skipMetricValidation?: boolean;
}

export interface MonitorMetricAlertDynamicCriteriaDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface MonitorMetricAlertTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorPrivateLinkScopeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorPrivateLinkScopedServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MonitorScheduledQueryRulesAlertAction {
    actionGroups: string[];
    customWebhookPayload?: string;
    emailSubject?: string;
}

export interface MonitorScheduledQueryRulesAlertTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorScheduledQueryRulesAlertTrigger {
    metricTrigger?: outputs.MonitorScheduledQueryRulesAlertTriggerMetricTrigger;
    operator: string;
    threshold: number;
}

export interface MonitorScheduledQueryRulesAlertTriggerMetricTrigger {
    metricColumn?: string;
    metricTriggerType: string;
    operator: string;
    threshold: number;
}

export interface MonitorScheduledQueryRulesAlertV2Action {
    actionGroups?: string[];
    customProperties?: {[key: string]: string};
}

export interface MonitorScheduledQueryRulesAlertV2Criteria {
    dimensions?: outputs.MonitorScheduledQueryRulesAlertV2CriteriaDimension[];
    failingPeriods?: outputs.MonitorScheduledQueryRulesAlertV2CriteriaFailingPeriods;
    metricMeasureColumn?: string;
    operator: string;
    query: string;
    resourceIdColumn?: string;
    threshold: number;
    timeAggregationMethod: string;
}

export interface MonitorScheduledQueryRulesAlertV2CriteriaDimension {
    name: string;
    operator: string;
    values: string[];
}

export interface MonitorScheduledQueryRulesAlertV2CriteriaFailingPeriods {
    minimumFailingPeriodsToTriggerAlert: number;
    numberOfEvaluationPeriods: number;
}

export interface MonitorScheduledQueryRulesAlertV2Identity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MonitorScheduledQueryRulesAlertV2Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorScheduledQueryRulesLogCriteria {
    dimensions: outputs.MonitorScheduledQueryRulesLogCriteriaDimension[];
    metricName: string;
}

export interface MonitorScheduledQueryRulesLogCriteriaDimension {
    name: string;
    operator?: string;
    values: string[];
}

export interface MonitorScheduledQueryRulesLogTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorSmartDetectorAlertRuleActionGroup {
    emailSubject?: string;
    ids: string[];
    webhookPayload?: string;
}

export interface MonitorSmartDetectorAlertRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MonitorWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlDatabaseExtendedAuditingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlDatabaseIdentity {
    identityIds: string[];
    type: string;
}

export interface MssqlDatabaseImport {
    administratorLogin: string;
    administratorLoginPassword: string;
    authenticationType: string;
    storageAccountId?: string;
    storageKey: string;
    storageKeyType: string;
    storageUri: string;
}

export interface MssqlDatabaseLongTermRetentionPolicy {
    monthlyRetention: string;
    weekOfYear: number;
    weeklyRetention: string;
    yearlyRetention: string;
}

export interface MssqlDatabaseShortTermRetentionPolicy {
    backupIntervalInHours?: number;
    retentionDays: number;
}

export interface MssqlDatabaseThreatDetectionPolicy {
    disabledAlerts?: string[];
    emailAccountAdmins?: string;
    emailAddresses?: string[];
    retentionDays?: number;
    state?: string;
    storageAccountAccessKey?: string;
    storageEndpoint?: string;
}

export interface MssqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlDatabaseVulnerabilityAssessmentRuleBaselineBaselineResult {
    results: string[];
}

export interface MssqlDatabaseVulnerabilityAssessmentRuleBaselineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlElasticpoolPerDatabaseSettings {
    maxCapacity: number;
    minCapacity: number;
}

export interface MssqlElasticpoolSku {
    capacity: number;
    family?: string;
    name: string;
    tier: string;
}

export interface MssqlElasticpoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlFailoverGroupPartnerServer {
    id: string;
    location: string;
    role: string;
}

export interface MssqlFailoverGroupReadWriteEndpointFailoverPolicy {
    graceMinutes?: number;
    mode: string;
}

export interface MssqlFailoverGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlJobAgentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlJobCredentialTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedDatabaseLongTermRetentionPolicy {
    monthlyRetention: string;
    weekOfYear: number;
    weeklyRetention: string;
    yearlyRetention: string;
}

export interface MssqlManagedDatabasePointInTimeRestore {
    restorePointInTime: string;
    sourceDatabaseId: string;
}

export interface MssqlManagedDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceActiveDirectoryAdministratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceFailoverGroupPartnerRegion {
    location: string;
    role: string;
}

export interface MssqlManagedInstanceFailoverGroupReadWriteEndpointFailoverPolicy {
    graceMinutes?: number;
    mode: string;
}

export interface MssqlManagedInstanceFailoverGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MssqlManagedInstanceSecurityAlertPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceTransparentDataEncryptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlManagedInstanceVulnerabilityAssessmentRecurringScans {
    emailSubscriptionAdmins?: boolean;
    emails?: string[];
    enabled?: boolean;
}

export interface MssqlManagedInstanceVulnerabilityAssessmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlOutboundFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MssqlServerAzureadAdministrator {
    azureadAuthenticationOnly: boolean;
    loginUsername: string;
    objectId: string;
    tenantId: string;
}

export interface MssqlServerDnsAliasTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MssqlServerExtendedAuditingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlServerIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface MssqlServerMicrosoftSupportAuditingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlServerSecurityAlertPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlServerTransparentDataEncryptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlServerVulnerabilityAssessmentRecurringScans {
    emailSubscriptionAdmins?: boolean;
    emails?: string[];
    enabled?: boolean;
}

export interface MssqlServerVulnerabilityAssessmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlVirtualMachineAssessment {
    enabled?: boolean;
    runImmediately?: boolean;
    schedule?: outputs.MssqlVirtualMachineAssessmentSchedule;
}

export interface MssqlVirtualMachineAssessmentSchedule {
    dayOfWeek: string;
    monthlyOccurrence?: number;
    startTime: string;
    weeklyInterval?: number;
}

export interface MssqlVirtualMachineAutoBackup {
    encryptionEnabled?: boolean;
    encryptionPassword?: string;
    manualSchedule?: outputs.MssqlVirtualMachineAutoBackupManualSchedule;
    retentionPeriodInDays: number;
    storageAccountAccessKey: string;
    storageBlobEndpoint: string;
    systemDatabasesBackupEnabled?: boolean;
}

export interface MssqlVirtualMachineAutoBackupManualSchedule {
    daysOfWeeks?: string[];
    fullBackupFrequency: string;
    fullBackupStartHour: number;
    fullBackupWindowInHours: number;
    logBackupFrequencyInMinutes: number;
}

export interface MssqlVirtualMachineAutoPatching {
    dayOfWeek: string;
    maintenanceWindowDurationInMinutes: number;
    maintenanceWindowStartingHour: number;
}

export interface MssqlVirtualMachineAvailabilityGroupListenerLoadBalancerConfiguration {
    loadBalancerId: string;
    privateIpAddress: string;
    probePort: number;
    sqlVirtualMachineIds: string[];
    subnetId: string;
}

export interface MssqlVirtualMachineAvailabilityGroupListenerMultiSubnetIpConfiguration {
    privateIpAddress: string;
    sqlVirtualMachineId: string;
    subnetId: string;
}

export interface MssqlVirtualMachineAvailabilityGroupListenerReplica {
    commit: string;
    failoverMode: string;
    readableSecondary: string;
    role: string;
    sqlVirtualMachineId: string;
}

export interface MssqlVirtualMachineAvailabilityGroupListenerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MssqlVirtualMachineGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlVirtualMachineGroupWsfcDomainProfile {
    clusterBootstrapAccountName?: string;
    clusterOperatorAccountName?: string;
    clusterSubnetType: string;
    fqdn: string;
    organizationalUnitPath?: string;
    sqlServiceAccountName?: string;
    storageAccountPrimaryKey?: string;
    storageAccountUrl?: string;
}

export interface MssqlVirtualMachineKeyVaultCredential {
    keyVaultUrl: string;
    name: string;
    servicePrincipalName: string;
    servicePrincipalSecret: string;
}

export interface MssqlVirtualMachineSqlInstance {
    adhocWorkloadsOptimizationEnabled?: boolean;
    collation?: string;
    instantFileInitializationEnabled?: boolean;
    lockPagesInMemoryEnabled?: boolean;
    maxDop?: number;
    maxServerMemoryMb?: number;
    minServerMemoryMb?: number;
}

export interface MssqlVirtualMachineStorageConfiguration {
    dataSettings?: outputs.MssqlVirtualMachineStorageConfigurationDataSettings;
    diskType: string;
    logSettings?: outputs.MssqlVirtualMachineStorageConfigurationLogSettings;
    storageWorkloadType: string;
    systemDbOnDataDiskEnabled?: boolean;
    tempDbSettings?: outputs.MssqlVirtualMachineStorageConfigurationTempDbSettings;
}

export interface MssqlVirtualMachineStorageConfigurationDataSettings {
    defaultFilePath: string;
    luns: number[];
}

export interface MssqlVirtualMachineStorageConfigurationLogSettings {
    defaultFilePath: string;
    luns: number[];
}

export interface MssqlVirtualMachineStorageConfigurationTempDbSettings {
    dataFileCount?: number;
    dataFileGrowthInMb?: number;
    dataFileSizeMb?: number;
    defaultFilePath: string;
    logFileGrowthMb?: number;
    logFileSizeMb?: number;
    luns: number[];
}

export interface MssqlVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MssqlVirtualMachineWsfcDomainCredential {
    clusterBootstrapAccountPassword: string;
    clusterOperatorAccountPassword: string;
    sqlServiceAccountPassword: string;
}

export interface MssqlVirtualNetworkRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MysqlFlexibleDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface MysqlFlexibleServerActiveDirectoryAdministratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MysqlFlexibleServerConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MysqlFlexibleServerCustomerManagedKey {
    geoBackupKeyVaultKeyId?: string;
    geoBackupUserAssignedIdentityId?: string;
    keyVaultKeyId?: string;
    primaryUserAssignedIdentityId?: string;
}

export interface MysqlFlexibleServerFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MysqlFlexibleServerHighAvailability {
    mode: string;
    standbyAvailabilityZone?: string;
}

export interface MysqlFlexibleServerIdentity {
    identityIds: string[];
    type: string;
}

export interface MysqlFlexibleServerMaintenanceWindow {
    dayOfWeek?: number;
    startHour?: number;
    startMinute?: number;
}

export interface MysqlFlexibleServerStorage {
    autoGrowEnabled?: boolean;
    ioScalingEnabled?: boolean;
    iops: number;
    sizeGb: number;
}

export interface MysqlFlexibleServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NatGatewayPublicIpAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NatGatewayPublicIpPrefixAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NatGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappAccountActiveDirectory {
    /**
     * If enabled, AES encryption will be enabled for SMB communication.
     */
    aesEncryptionEnabled?: boolean;
    dnsServers: string[];
    domain: string;
    /**
     * Name of the active directory machine. This optional parameter is used only while creating kerberos volume.
     */
    kerberosAdName?: string;
    /**
     * IP address of the KDC server (usually same the DC). This optional parameter is used only while creating kerberos volume.
     */
    kerberosKdcIp?: string;
    /**
     * Specifies whether or not the LDAP traffic needs to be secured via TLS.
     */
    ldapOverTlsEnabled?: boolean;
    /**
     * Specifies whether or not the LDAP traffic needs to be signed.
     */
    ldapSigningEnabled?: boolean;
    /**
     * If enabled, NFS client local users can also (in addition to LDAP users) access the NFS volumes.
     */
    localNfsUsersWithLdapAllowed?: boolean;
    /**
     * The Organizational Unit (OU) within the Windows Active Directory where machines will be created. If blank, defaults to 'CN=Computers'
     */
    organizationalUnit?: string;
    password: string;
    /**
     * When LDAP over SSL/TLS is enabled, the LDAP client is required to have base64 encoded Active Directory Certificate Service's self-signed root CA certificate, this optional parameter is used only for dual protocol with LDAP user-mapping volumes.
     */
    serverRootCaCertificate?: string;
    /**
     * The Active Directory site the service will limit Domain Controller discovery to. If blank, defaults to 'Default-First-Site-Name'
     */
    siteName?: string;
    smbServerName: string;
    username: string;
}

export interface NetappAccountEncryptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface NetappAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappSnapshotPolicyDailySchedule {
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface NetappSnapshotPolicyHourlySchedule {
    minute: number;
    snapshotsToKeep: number;
}

export interface NetappSnapshotPolicyMonthlySchedule {
    daysOfMonths: number[];
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface NetappSnapshotPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappSnapshotPolicyWeeklySchedule {
    daysOfWeeks: string[];
    hour: number;
    minute: number;
    snapshotsToKeep: number;
}

export interface NetappSnapshotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetappVolumeDataProtectionReplication {
    endpointType?: string;
    remoteVolumeLocation: string;
    remoteVolumeResourceId: string;
    replicationFrequency: string;
}

export interface NetappVolumeDataProtectionSnapshotPolicy {
    snapshotPolicyId: string;
}

export interface NetappVolumeExportPolicyRule {
    allowedClients: string[];
    kerberos5ReadOnlyEnabled?: boolean;
    kerberos5ReadWriteEnabled?: boolean;
    kerberos5iReadOnlyEnabled?: boolean;
    kerberos5iReadWriteEnabled?: boolean;
    kerberos5pReadOnlyEnabled?: boolean;
    kerberos5pReadWriteEnabled?: boolean;
    protocolsEnableds?: string[];
    rootAccessEnabled?: boolean;
    ruleIndex: number;
    unixReadOnly?: boolean;
    unixReadWrite?: boolean;
}

export interface NetappVolumeGroupSapHanaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappVolumeGroupSapHanaVolume {
    capacityPoolId: string;
    dataProtectionReplication?: outputs.NetappVolumeGroupSapHanaVolumeDataProtectionReplication;
    dataProtectionSnapshotPolicy?: outputs.NetappVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy;
    exportPolicyRules: outputs.NetappVolumeGroupSapHanaVolumeExportPolicyRule[];
    id: string;
    mountIpAddresses: string[];
    name: string;
    protocols: string[];
    proximityPlacementGroupId?: string;
    securityStyle: string;
    serviceLevel: string;
    snapshotDirectoryVisible: boolean;
    storageQuotaInGb: number;
    subnetId: string;
    tags?: {[key: string]: string};
    throughputInMibps: number;
    volumePath: string;
    volumeSpecName: string;
}

export interface NetappVolumeGroupSapHanaVolumeDataProtectionReplication {
    endpointType?: string;
    remoteVolumeLocation: string;
    remoteVolumeResourceId: string;
    replicationFrequency: string;
}

export interface NetappVolumeGroupSapHanaVolumeDataProtectionSnapshotPolicy {
    snapshotPolicyId: string;
}

export interface NetappVolumeGroupSapHanaVolumeExportPolicyRule {
    allowedClients: string;
    nfsv3Enabled: boolean;
    nfsv41Enabled: boolean;
    rootAccessEnabled?: boolean;
    ruleIndex: number;
    unixReadOnly?: boolean;
    unixReadWrite?: boolean;
}

export interface NetappVolumeQuotaRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetappVolumeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkConnectionMonitorEndpoint {
    address?: string;
    coverageLevel?: string;
    excludedIpAddresses?: string[];
    filter?: outputs.NetworkConnectionMonitorEndpointFilter;
    includedIpAddresses?: string[];
    name: string;
    targetResourceId?: string;
    targetResourceType?: string;
}

export interface NetworkConnectionMonitorEndpointFilter {
    items?: outputs.NetworkConnectionMonitorEndpointFilterItem[];
    type?: string;
}

export interface NetworkConnectionMonitorEndpointFilterItem {
    address?: string;
    type?: string;
}

export interface NetworkConnectionMonitorTestConfiguration {
    httpConfiguration?: outputs.NetworkConnectionMonitorTestConfigurationHttpConfiguration;
    icmpConfiguration?: outputs.NetworkConnectionMonitorTestConfigurationIcmpConfiguration;
    name: string;
    preferredIpVersion?: string;
    protocol: string;
    successThreshold?: outputs.NetworkConnectionMonitorTestConfigurationSuccessThreshold;
    tcpConfiguration?: outputs.NetworkConnectionMonitorTestConfigurationTcpConfiguration;
    testFrequencyInSeconds?: number;
}

export interface NetworkConnectionMonitorTestConfigurationHttpConfiguration {
    method?: string;
    path?: string;
    port?: number;
    preferHttps?: boolean;
    requestHeaders?: outputs.NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader[];
    validStatusCodeRanges?: string[];
}

export interface NetworkConnectionMonitorTestConfigurationHttpConfigurationRequestHeader {
    name: string;
    value: string;
}

export interface NetworkConnectionMonitorTestConfigurationIcmpConfiguration {
    traceRouteEnabled?: boolean;
}

export interface NetworkConnectionMonitorTestConfigurationSuccessThreshold {
    checksFailedPercent?: number;
    roundTripTimeMs?: number;
}

export interface NetworkConnectionMonitorTestConfigurationTcpConfiguration {
    destinationPortBehavior?: string;
    port: number;
    traceRouteEnabled?: boolean;
}

export interface NetworkConnectionMonitorTestGroup {
    destinationEndpoints: string[];
    enabled?: boolean;
    name: string;
    sourceEndpoints: string[];
    testConfigurationNames: string[];
}

export interface NetworkConnectionMonitorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkDdosProtectionPlanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkFunctionAzureTrafficCollectorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkFunctionCollectorPolicyIpfxEmission {
    destinationTypes: string[];
}

export interface NetworkFunctionCollectorPolicyIpfxIngestion {
    sourceResourceIds: string[];
}

export interface NetworkFunctionCollectorPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkInterfaceApplicationGatewayBackendAddressPoolAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkInterfaceApplicationSecurityGroupAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkInterfaceBackendAddressPoolAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkInterfaceIpConfiguration {
    gatewayLoadBalancerFrontendIpConfigurationId: string;
    name: string;
    primary: boolean;
    privateIpAddress: string;
    privateIpAddressAllocation: string;
    privateIpAddressVersion?: string;
    publicIpAddressId?: string;
    subnetId?: string;
}

export interface NetworkInterfaceNatRuleAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkInterfaceSecurityGroupAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkInterfaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerAdminRuleCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerAdminRuleDestination {
    addressPrefix: string;
    addressPrefixType: string;
}

export interface NetworkManagerAdminRuleSource {
    addressPrefix: string;
    addressPrefixType: string;
}

export interface NetworkManagerAdminRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerConnectivityConfigurationAppliesToGroup {
    globalMeshEnabled?: boolean;
    groupConnectivity: string;
    networkGroupId: string;
    useHubGateway?: boolean;
}

export interface NetworkManagerConnectivityConfigurationHub {
    resourceId: string;
    resourceType: string;
}

export interface NetworkManagerConnectivityConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerCrossTenantScope {
    managementGroups: string[];
    subscriptions: string[];
    tenantId: string;
}

export interface NetworkManagerDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerManagementGroupConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerNetworkGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerScope {
    managementGroupIds?: string[];
    subscriptionIds?: string[];
}

export interface NetworkManagerScopeConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerSecurityAdminConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerStaticMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkManagerSubscriptionConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkManagerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkPacketCaptureFilter {
    localIpAddress?: string;
    localPort?: string;
    protocol: string;
    remoteIpAddress?: string;
    remotePort?: string;
}

export interface NetworkPacketCaptureStorageLocation {
    filePath?: string;
    storageAccountId?: string;
    storagePath: string;
}

export interface NetworkPacketCaptureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NetworkProfileContainerNetworkInterface {
    ipConfigurations: outputs.NetworkProfileContainerNetworkInterfaceIpConfiguration[];
    name: string;
}

export interface NetworkProfileContainerNetworkInterfaceIpConfiguration {
    name: string;
    subnetId: string;
}

export interface NetworkProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkSecurityGroupSecurityRule {
    access: string;
    description: string;
    destinationAddressPrefix: string;
    destinationAddressPrefixes: string[];
    destinationApplicationSecurityGroupIds: string[];
    destinationPortRange: string;
    destinationPortRanges: string[];
    direction: string;
    name: string;
    priority: number;
    protocol: string;
    sourceAddressPrefix: string;
    sourceAddressPrefixes: string[];
    sourceApplicationSecurityGroupIds: string[];
    sourcePortRange: string;
    sourcePortRanges: string[];
}

export interface NetworkSecurityGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkSecurityRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkWatcherFlowLogRetentionPolicy {
    days: number;
    enabled: boolean;
}

export interface NetworkWatcherFlowLogTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NetworkWatcherFlowLogTrafficAnalytics {
    enabled: boolean;
    intervalInMinutes?: number;
    workspaceId: string;
    workspaceRegion: string;
    workspaceResourceId: string;
}

export interface NetworkWatcherTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NewRelicMonitorIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface NewRelicMonitorPlan {
    billingCycle?: string;
    effectiveDate: string;
    planId?: string;
    usageType?: string;
}

export interface NewRelicMonitorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NewRelicMonitorUser {
    email: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
}

export interface NewRelicTagRuleLogTagFilter {
    action: string;
    name: string;
    value: string;
}

export interface NewRelicTagRuleMetricTagFilter {
    action: string;
    name: string;
    value: string;
}

export interface NewRelicTagRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NginxCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NginxConfigurationConfigFile {
    content: string;
    virtualPath: string;
}

export interface NginxConfigurationProtectedFile {
    content: string;
    virtualPath: string;
}

export interface NginxConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NginxDeploymentAutoScaleProfile {
    maxCapacity: number;
    minCapacity: number;
    name: string;
}

export interface NginxDeploymentFrontendPrivate {
    allocationMethod: string;
    ipAddress: string;
    subnetId: string;
}

export interface NginxDeploymentFrontendPublic {
    ipAddresses?: string[];
}

export interface NginxDeploymentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface NginxDeploymentLoggingStorageAccount {
    containerName?: string;
    name?: string;
}

export interface NginxDeploymentNetworkInterface {
    subnetId: string;
}

export interface NginxDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NotificationHubApnsCredential {
    applicationMode: string;
    bundleId: string;
    keyId: string;
    teamId: string;
    token: string;
}

export interface NotificationHubAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NotificationHubBrowserCredential {
    subject: string;
    vapidPrivateKey: string;
    vapidPublicKey: string;
}

export interface NotificationHubGcmCredential {
    apiKey: string;
}

export interface NotificationHubNamespaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface NotificationHubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrbitalContactProfileLink {
    channels: outputs.OrbitalContactProfileLinkChannel[];
    direction: string;
    name: string;
    polarization: string;
}

export interface OrbitalContactProfileLinkChannel {
    bandwidthMhz: number;
    centerFrequencyMhz: number;
    demodulationConfiguration?: string;
    endPoints: outputs.OrbitalContactProfileLinkChannelEndPoint[];
    modulationConfiguration?: string;
    name: string;
}

export interface OrbitalContactProfileLinkChannelEndPoint {
    endPointName: string;
    ipAddress?: string;
    port: string;
    protocol: string;
}

export interface OrbitalContactProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrbitalContactTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface OrbitalSpacecraftLink {
    bandwidthMhz: number;
    centerFrequencyMhz: number;
    direction: string;
    name: string;
    polarization: string;
}

export interface OrbitalSpacecraftTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface OrchestratedVirtualMachineScaleSetAdditionalCapabilities {
    ultraSsdEnabled?: boolean;
}

export interface OrchestratedVirtualMachineScaleSetAutomaticInstanceRepair {
    action: string;
    enabled: boolean;
    gracePeriod: string;
}

export interface OrchestratedVirtualMachineScaleSetBootDiagnostics {
    storageAccountUri?: string;
}

export interface OrchestratedVirtualMachineScaleSetDataDisk {
    caching: string;
    createOption?: string;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    lun: number;
    storageAccountType: string;
    ultraSsdDiskIopsReadWrite: number;
    ultraSsdDiskMbpsReadWrite: number;
    writeAcceleratorEnabled?: boolean;
}

export interface OrchestratedVirtualMachineScaleSetExtension {
    autoUpgradeMinorVersionEnabled?: boolean;
    extensionsToProvisionAfterVmCreations?: string[];
    failureSuppressionEnabled?: boolean;
    forceExtensionExecutionOnChange?: string;
    name: string;
    protectedSettings?: string;
    protectedSettingsFromKeyVault?: outputs.OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
    publisher: string;
    settings?: string;
    type: string;
    typeHandlerVersion: string;
}

export interface OrchestratedVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVaultId: string;
}

export interface OrchestratedVirtualMachineScaleSetIdentity {
    identityIds: string[];
    type: string;
}

export interface OrchestratedVirtualMachineScaleSetNetworkInterface {
    dnsServers?: string[];
    enableAcceleratedNetworking?: boolean;
    enableIpForwarding?: boolean;
    ipConfigurations: outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
    name: string;
    networkSecurityGroupId?: string;
    primary?: boolean;
}

export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolIds?: string[];
    applicationSecurityGroupIds?: string[];
    loadBalancerBackendAddressPoolIds?: string[];
    name: string;
    primary?: boolean;
    publicIpAddresses?: outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
    subnetId?: string;
    version?: string;
}

export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
    domainNameLabel?: string;
    idleTimeoutInMinutes: number;
    ipTags?: outputs.OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
    name: string;
    publicIpPrefixId?: string;
    skuName?: string;
    version?: string;
}

export interface OrchestratedVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
    tag: string;
    type: string;
}

export interface OrchestratedVirtualMachineScaleSetOsDisk {
    caching: string;
    diffDiskSettings?: outputs.OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    storageAccountType: string;
    writeAcceleratorEnabled?: boolean;
}

export interface OrchestratedVirtualMachineScaleSetOsDiskDiffDiskSettings {
    option: string;
    placement?: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfile {
    customData?: string;
    linuxConfiguration?: outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration;
    windowsConfiguration?: outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfiguration {
    adminPassword?: string;
    adminSshKeys?: outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey[];
    adminUsername: string;
    computerNamePrefix: string;
    disablePasswordAuthentication?: boolean;
    patchAssessmentMode?: string;
    patchMode?: string;
    provisionVmAgent?: boolean;
    secrets?: outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret[];
}

export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationAdminSshKey {
    publicKey: string;
    username: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecret {
    certificates: outputs.OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate[];
    keyVaultId: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileLinuxConfigurationSecretCertificate {
    url: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfiguration {
    additionalUnattendContents?: outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationAdditionalUnattendContent[];
    adminPassword: string;
    adminUsername: string;
    computerNamePrefix: string;
    enableAutomaticUpdates?: boolean;
    hotpatchingEnabled?: boolean;
    patchAssessmentMode?: string;
    patchMode?: string;
    provisionVmAgent?: boolean;
    secrets?: outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret[];
    timezone?: string;
    winrmListeners?: outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener[];
}

export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationAdditionalUnattendContent {
    content: string;
    setting: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecret {
    certificates: outputs.OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate[];
    keyVaultId: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationSecretCertificate {
    store: string;
    url: string;
}

export interface OrchestratedVirtualMachineScaleSetOsProfileWindowsConfigurationWinrmListener {
    certificateUrl?: string;
    protocol: string;
}

export interface OrchestratedVirtualMachineScaleSetPlan {
    name: string;
    product: string;
    publisher: string;
}

export interface OrchestratedVirtualMachineScaleSetPriorityMix {
    baseRegularCount?: number;
    regularPercentageAboveBase?: number;
}

export interface OrchestratedVirtualMachineScaleSetSourceImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface OrchestratedVirtualMachineScaleSetTerminationNotification {
    enabled: boolean;
    timeout?: string;
}

export interface OrchestratedVirtualMachineScaleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoLocalRulestackCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoLocalRulestackFqdnListTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoLocalRulestackOutboundTrustCertificateAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PaloAltoLocalRulestackOutboundUntrustCertificateAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PaloAltoLocalRulestackPrefixListTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoLocalRulestackRuleCategory {
    customUrls: string[];
    feeds?: string[];
}

export interface PaloAltoLocalRulestackRuleDestination {
    cidrs?: string[];
    countries?: string[];
    feeds?: string[];
    localRulestackFqdnListIds?: string[];
    localRulestackPrefixListIds?: string[];
}

export interface PaloAltoLocalRulestackRuleSource {
    cidrs?: string[];
    countries?: string[];
    feeds?: string[];
    localRulestackPrefixListIds?: string[];
}

export interface PaloAltoLocalRulestackRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoLocalRulestackTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDestinationNat {
    backendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDestinationNatBackendConfig;
    frontendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDestinationNatFrontendConfig;
    name: string;
    protocol: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDestinationNatBackendConfig {
    port: number;
    publicIpAddress: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDestinationNatFrontendConfig {
    port: number;
    publicIpAddressId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackDnsSettings {
    azureDnsServers: string[];
    dnsServers?: string[];
    useAzureDns?: boolean;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackNetworkProfile {
    egressNatIpAddressIds?: string[];
    egressNatIpAddresses: string[];
    ipOfTrustForUserDefinedRoutes: string;
    networkVirtualApplianceId: string;
    publicIpAddressIds: string[];
    publicIpAddresses: string[];
    trustedAddressRanges?: string[];
    trustedSubnetId: string;
    untrustedSubnetId: string;
    virtualHubId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubLocalRulestackTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaDestinationNat {
    backendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualHubPanoramaDestinationNatBackendConfig;
    frontendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualHubPanoramaDestinationNatFrontendConfig;
    name: string;
    protocol: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaDestinationNatBackendConfig {
    port: number;
    publicIpAddress: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaDestinationNatFrontendConfig {
    port: number;
    publicIpAddressId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaDnsSettings {
    azureDnsServers: string[];
    dnsServers?: string[];
    useAzureDns?: boolean;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaNetworkProfile {
    egressNatIpAddressIds?: string[];
    egressNatIpAddresses: string[];
    ipOfTrustForUserDefinedRoutes: string;
    networkVirtualApplianceId: string;
    publicIpAddressIds: string[];
    publicIpAddresses: string[];
    trustedAddressRanges?: string[];
    trustedSubnetId: string;
    untrustedSubnetId: string;
    virtualHubId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaPanorama {
    deviceGroupName: string;
    hostName: string;
    name: string;
    panoramaServer1: string;
    panoramaServer2: string;
    templateName: string;
    virtualMachineSshKey: string;
}

export interface PaloAltoNextGenerationFirewallVirtualHubPanoramaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDestinationNat {
    backendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatBackendConfig;
    frontendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatFrontendConfig;
    name: string;
    protocol: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatBackendConfig {
    port: number;
    publicIpAddress: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDestinationNatFrontendConfig {
    port: number;
    publicIpAddressId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackDnsSettings {
    azureDnsServers: string[];
    dnsServers?: string[];
    useAzureDns?: boolean;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfile {
    egressNatIpAddressIds?: string[];
    egressNatIpAddresses: string[];
    publicIpAddressIds: string[];
    publicIpAddresses: string[];
    trustedAddressRanges?: string[];
    vnetConfiguration: outputs.PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfileVnetConfiguration;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackNetworkProfileVnetConfiguration {
    ipOfTrustForUserDefinedRoutes: string;
    trustedSubnetId?: string;
    untrustedSubnetId?: string;
    virtualNetworkId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkLocalRulestackTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDestinationNat {
    backendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDestinationNatBackendConfig;
    frontendConfig?: outputs.PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDestinationNatFrontendConfig;
    name: string;
    protocol: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDestinationNatBackendConfig {
    port: number;
    publicIpAddress: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDestinationNatFrontendConfig {
    port: number;
    publicIpAddressId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaDnsSettings {
    azureDnsServers: string[];
    dnsServers?: string[];
    useAzureDns?: boolean;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaNetworkProfile {
    egressNatIpAddressIds?: string[];
    egressNatIpAddresses: string[];
    publicIpAddressIds: string[];
    publicIpAddresses: string[];
    trustedAddressRanges?: string[];
    vnetConfiguration: outputs.PaloAltoNextGenerationFirewallVirtualNetworkPanoramaNetworkProfileVnetConfiguration;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaNetworkProfileVnetConfiguration {
    ipOfTrustForUserDefinedRoutes: string;
    trustedSubnetId?: string;
    untrustedSubnetId?: string;
    virtualNetworkId: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaPanorama {
    deviceGroupName: string;
    hostName: string;
    name: string;
    panoramaServer1: string;
    panoramaServer2: string;
    templateName: string;
    virtualMachineSshKey: string;
}

export interface PaloAltoNextGenerationFirewallVirtualNetworkPanoramaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PaloAltoVirtualNetworkApplianceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PimActiveRoleAssignmentSchedule {
    expiration?: outputs.PimActiveRoleAssignmentScheduleExpiration;
    /**
     * The start date/time of the role assignment
     */
    startDateTime: string;
}

export interface PimActiveRoleAssignmentScheduleExpiration {
    /**
     * The duration of the role assignment in days
     */
    durationDays: number;
    /**
     * The duration of the role assignment in hours
     */
    durationHours: number;
    /**
     * The end date/time of the role assignment
     */
    endDateTime: string;
}

export interface PimActiveRoleAssignmentTicket {
    /**
     * User-supplied ticket number to be included with the request
     */
    number?: string;
    /**
     * User-supplied ticket system name to be included with the request
     */
    system?: string;
}

export interface PimActiveRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PimEligibleRoleAssignmentSchedule {
    expiration?: outputs.PimEligibleRoleAssignmentScheduleExpiration;
    /**
     * The start date/time
     */
    startDateTime: string;
}

export interface PimEligibleRoleAssignmentScheduleExpiration {
    /**
     * The duration of the eligible role assignment in days
     */
    durationDays: number;
    /**
     * The duration of the eligible role assignment in hours
     */
    durationHours: number;
    /**
     * The end date/time of the eligible role assignment
     */
    endDateTime: string;
}

export interface PimEligibleRoleAssignmentTicket {
    /**
     * User-supplied ticket number to be included with the request
     */
    number?: string;
    /**
     * User-supplied ticket system name to be included with the request
     */
    system?: string;
}

export interface PimEligibleRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PointToSiteVpnGatewayConnectionConfiguration {
    internetSecurityEnabled?: boolean;
    name: string;
    route?: outputs.PointToSiteVpnGatewayConnectionConfigurationRoute;
    vpnClientAddressPool: outputs.PointToSiteVpnGatewayConnectionConfigurationVpnClientAddressPool;
}

export interface PointToSiteVpnGatewayConnectionConfigurationRoute {
    associatedRouteTableId: string;
    inboundRouteMapId?: string;
    outboundRouteMapId?: string;
    propagatedRouteTable?: outputs.PointToSiteVpnGatewayConnectionConfigurationRoutePropagatedRouteTable;
}

export interface PointToSiteVpnGatewayConnectionConfigurationRoutePropagatedRouteTable {
    ids: string[];
    labels?: string[];
}

export interface PointToSiteVpnGatewayConnectionConfigurationVpnClientAddressPool {
    addressPrefixes: string[];
}

export interface PointToSiteVpnGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PolicyDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PolicySetDefinitionPolicyDefinitionGroup {
    additionalMetadataResourceId?: string;
    category?: string;
    description?: string;
    displayName?: string;
    name: string;
}

export interface PolicySetDefinitionPolicyDefinitionReference {
    parameterValues?: string;
    policyDefinitionId: string;
    policyGroupNames?: string[];
    referenceId: string;
}

export interface PolicySetDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PolicyVirtualMachineConfigurationAssignmentConfiguration {
    assignmentType?: string;
    contentHash: string;
    contentUri: string;
    parameters?: outputs.PolicyVirtualMachineConfigurationAssignmentConfigurationParameter[];
    version?: string;
}

export interface PolicyVirtualMachineConfigurationAssignmentConfigurationParameter {
    name: string;
    value: string;
}

export interface PolicyVirtualMachineConfigurationAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PortalDashboardTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PortalTenantConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlActiveDirectoryAdministratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PostgresqlDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PostgresqlFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PostgresqlFlexibleServerActiveDirectoryAdministratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PostgresqlFlexibleServerAuthentication {
    activeDirectoryAuthEnabled?: boolean;
    passwordAuthEnabled?: boolean;
    tenantId?: string;
}

export interface PostgresqlFlexibleServerConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlFlexibleServerCustomerManagedKey {
    geoBackupKeyVaultKeyId?: string;
    geoBackupUserAssignedIdentityId?: string;
    keyVaultKeyId: string;
    primaryUserAssignedIdentityId?: string;
}

export interface PostgresqlFlexibleServerDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PostgresqlFlexibleServerFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlFlexibleServerHighAvailability {
    mode: string;
    standbyAvailabilityZone?: string;
}

export interface PostgresqlFlexibleServerIdentity {
    identityIds: string[];
    type: string;
}

export interface PostgresqlFlexibleServerMaintenanceWindow {
    dayOfWeek?: number;
    startHour?: number;
    startMinute?: number;
}

export interface PostgresqlFlexibleServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlFlexibleServerVirtualEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlServerIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface PostgresqlServerKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlServerThreatDetectionPolicy {
    disabledAlerts?: string[];
    emailAccountAdmins?: boolean;
    emailAddresses?: string[];
    enabled?: boolean;
    retentionDays?: number;
    storageAccountAccessKey?: string;
    storageEndpoint?: string;
}

export interface PostgresqlServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PostgresqlVirtualNetworkRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PowerbiEmbeddedTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsARecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsAaaaRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsCnameRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsMxRecordRecord {
    exchange: string;
    preference: number;
}

export interface PrivateDnsMxRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsPtrRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverDnsForwardingRulesetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverForwardingRuleTargetDnsServer {
    ipAddress: string;
    port?: number;
}

export interface PrivateDnsResolverForwardingRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverInboundEndpointIpConfigurations {
    privateIpAddress: string;
    privateIpAllocationMethod?: string;
    subnetId: string;
}

export interface PrivateDnsResolverInboundEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverOutboundEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsResolverVirtualNetworkLinkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsSrvRecordRecord {
    port: number;
    priority: number;
    target: string;
    weight: number;
}

export interface PrivateDnsSrvRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsTxtRecordRecord {
    value: string;
}

export interface PrivateDnsTxtRecordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsZoneSoaRecord {
    email: string;
    expireTime?: number;
    fqdn: string;
    hostName: string;
    minimumTtl?: number;
    refreshTime?: number;
    retryTime?: number;
    serialNumber: number;
    tags?: {[key: string]: string};
    ttl?: number;
}

export interface PrivateDnsZoneTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateDnsZoneVirtualNetworkLinkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateEndpointApplicationSecurityGroupAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface PrivateEndpointCustomDnsConfig {
    fqdn: string;
    ipAddresses: string[];
}

export interface PrivateEndpointIpConfiguration {
    memberName: string;
    name: string;
    privateIpAddress: string;
    subresourceName?: string;
}

export interface PrivateEndpointNetworkInterface {
    id: string;
    name: string;
}

export interface PrivateEndpointPrivateDnsZoneConfig {
    id: string;
    name: string;
    privateDnsZoneId: string;
    recordSets: outputs.PrivateEndpointPrivateDnsZoneConfigRecordSet[];
}

export interface PrivateEndpointPrivateDnsZoneConfigRecordSet {
    fqdn: string;
    ipAddresses: string[];
    name: string;
    ttl: number;
    type: string;
}

export interface PrivateEndpointPrivateDnsZoneGroup {
    id: string;
    name: string;
    privateDnsZoneIds: string[];
}

export interface PrivateEndpointPrivateServiceConnection {
    isManualConnection: boolean;
    name: string;
    privateConnectionResourceAlias?: string;
    privateConnectionResourceId?: string;
    privateIpAddress: string;
    requestMessage?: string;
    subresourceNames?: string[];
}

export interface PrivateEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivateLinkServiceNatIpConfiguration {
    name: string;
    primary: boolean;
    privateIpAddress?: string;
    privateIpAddressVersion?: string;
    subnetId: string;
}

export interface PrivateLinkServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ProximityPlacementGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PublicIpPrefixTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PublicIpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PurviewAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface PurviewAccountManagedResource {
    eventHubNamespaceId: string;
    resourceGroupId: string;
    storageAccountId: string;
}

export interface PurviewAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RecoveryServicesVaultEncryption {
    infrastructureEncryptionEnabled: boolean;
    keyId: string;
    useSystemAssignedIdentity?: boolean;
    userAssignedIdentityId?: string;
}

export interface RecoveryServicesVaultIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface RecoveryServicesVaultMonitoring {
    alertsForAllJobFailuresEnabled?: boolean;
    alertsForCriticalOperationFailuresEnabled?: boolean;
}

export interface RecoveryServicesVaultResourceGuardAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface RecoveryServicesVaultTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedhatOpenshiftClusterApiServerProfile {
    ipAddress: string;
    url: string;
    visibility: string;
}

export interface RedhatOpenshiftClusterClusterProfile {
    domain: string;
    fipsEnabled?: boolean;
    managedResourceGroupName?: string;
    pullSecret?: string;
    resourceGroupId: string;
    version: string;
}

export interface RedhatOpenshiftClusterIngressProfile {
    ipAddress: string;
    name: string;
    visibility: string;
}

export interface RedhatOpenshiftClusterMainProfile {
    diskEncryptionSetId?: string;
    encryptionAtHostEnabled?: boolean;
    subnetId: string;
    vmSize: string;
}

export interface RedhatOpenshiftClusterNetworkProfile {
    outboundType?: string;
    podCidr: string;
    preconfiguredNetworkSecurityGroupEnabled?: boolean;
    serviceCidr: string;
}

export interface RedhatOpenshiftClusterServicePrincipal {
    clientId: string;
    clientSecret: string;
}

export interface RedhatOpenshiftClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedhatOpenshiftClusterWorkerProfile {
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    encryptionAtHostEnabled?: boolean;
    nodeCount: number;
    subnetId: string;
    vmSize: string;
}

export interface RedisCacheAccessPolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface RedisCacheAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisCacheIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface RedisCachePatchSchedule {
    dayOfWeek: string;
    maintenanceWindow?: string;
    startHourUtc?: number;
}

export interface RedisCacheRedisConfiguration {
    activeDirectoryAuthenticationEnabled?: boolean;
    aofBackupEnabled?: boolean;
    aofStorageConnectionString0?: string;
    aofStorageConnectionString1?: string;
    authenticationEnabled?: boolean;
    dataPersistenceAuthenticationMethod?: string;
    maxclients: number;
    maxfragmentationmemoryReserved: number;
    maxmemoryDelta: number;
    maxmemoryPolicy?: string;
    maxmemoryReserved: number;
    notifyKeyspaceEvents?: string;
    rdbBackupEnabled?: boolean;
    rdbBackupFrequency?: number;
    rdbBackupMaxSnapshotCount?: number;
    rdbStorageConnectionString?: string;
    storageAccountSubscriptionId?: string;
}

export interface RedisCacheTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisEnterpriseClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisEnterpriseDatabaseModule {
    args?: string;
    name: string;
    version: string;
}

export interface RedisEnterpriseDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisLinkedServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface RelayHybridConnectionAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RelayHybridConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RelayNamespaceAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RelayNamespaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceDeploymentScriptAzureCliContainer {
    containerGroupName?: string;
}

export interface ResourceDeploymentScriptAzureCliEnvironmentVariable {
    name: string;
    secureValue?: string;
    value?: string;
}

export interface ResourceDeploymentScriptAzureCliIdentity {
    identityIds: string[];
    type: string;
}

export interface ResourceDeploymentScriptAzureCliStorageAccount {
    key: string;
    name: string;
}

export interface ResourceDeploymentScriptAzureCliTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceDeploymentScriptAzurePowerShellContainer {
    containerGroupName?: string;
}

export interface ResourceDeploymentScriptAzurePowerShellEnvironmentVariable {
    name: string;
    secureValue?: string;
    value?: string;
}

export interface ResourceDeploymentScriptAzurePowerShellIdentity {
    identityIds: string[];
    type: string;
}

export interface ResourceDeploymentScriptAzurePowerShellStorageAccount {
    key: string;
    name: string;
}

export interface ResourceDeploymentScriptAzurePowerShellTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupCostManagementExportExportDataOptions {
    timeFrame: string;
    type: string;
}

export interface ResourceGroupCostManagementExportExportDataStorageLocation {
    containerId: string;
    rootFolderPath: string;
}

export interface ResourceGroupCostManagementExportTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupCostManagementViewDataset {
    aggregations: outputs.ResourceGroupCostManagementViewDatasetAggregation[];
    granularity: string;
    groupings?: outputs.ResourceGroupCostManagementViewDatasetGrouping[];
    sortings?: outputs.ResourceGroupCostManagementViewDatasetSorting[];
}

export interface ResourceGroupCostManagementViewDatasetAggregation {
    columnName: string;
    name: string;
}

export interface ResourceGroupCostManagementViewDatasetGrouping {
    name: string;
    type: string;
}

export interface ResourceGroupCostManagementViewDatasetSorting {
    direction: string;
    name: string;
}

export interface ResourceGroupCostManagementViewKpi {
    type: string;
}

export interface ResourceGroupCostManagementViewPivot {
    name: string;
    type: string;
}

export interface ResourceGroupCostManagementViewTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupPolicyAssignmentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ResourceGroupPolicyAssignmentNonComplianceMessage {
    content: string;
    policyDefinitionReferenceId?: string;
}

export interface ResourceGroupPolicyAssignmentOverride {
    selectors?: outputs.ResourceGroupPolicyAssignmentOverrideSelector[];
    value: string;
}

export interface ResourceGroupPolicyAssignmentOverrideSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ResourceGroupPolicyAssignmentResourceSelector {
    name?: string;
    selectors: outputs.ResourceGroupPolicyAssignmentResourceSelectorSelector[];
}

export interface ResourceGroupPolicyAssignmentResourceSelectorSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ResourceGroupPolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupPolicyExemptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupPolicyRemediationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupTemplateDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceManagementPrivateLinkAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ResourceManagementPrivateLinkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ResourcePolicyAssignmentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ResourcePolicyAssignmentNonComplianceMessage {
    content: string;
    policyDefinitionReferenceId?: string;
}

export interface ResourcePolicyAssignmentOverride {
    selectors?: outputs.ResourcePolicyAssignmentOverrideSelector[];
    value: string;
}

export interface ResourcePolicyAssignmentOverrideSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ResourcePolicyAssignmentResourceSelector {
    name?: string;
    selectors: outputs.ResourcePolicyAssignmentResourceSelectorSelector[];
}

export interface ResourcePolicyAssignmentResourceSelectorSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface ResourcePolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourcePolicyExemptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourcePolicyRemediationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ResourceProviderRegistrationFeature {
    name: string;
    registered: boolean;
}

export interface ResourceProviderRegistrationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RestorePointCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface RoleDefinitionPermission {
    actions?: string[];
    dataActions?: string[];
    notActions?: string[];
    notDataActions?: string[];
}

export interface RoleDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RoleManagementPolicyActivationRules {
    /**
     * The approval stages for the activation
     */
    approvalStage?: outputs.RoleManagementPolicyActivationRulesApprovalStage;
    /**
     * The time after which the an activation can be valid for
     */
    maximumDuration: string;
    /**
     * Whether an approval is required for activation
     */
    requireApproval: boolean;
    /**
     * Whether a justification is required during activation
     */
    requireJustification: boolean;
    /**
     * Whether multi-factor authentication is required during activation
     */
    requireMultifactorAuthentication: boolean;
    /**
     * Whether ticket information is required during activation
     */
    requireTicketInfo: boolean;
    /**
     * Whether a conditional access context is required during activation
     */
    requiredConditionalAccessAuthenticationContext: string;
}

export interface RoleManagementPolicyActivationRulesApprovalStage {
    /**
     * The IDs of the users or groups who can approve the activation
     */
    primaryApprovers: outputs.RoleManagementPolicyActivationRulesApprovalStagePrimaryApprover[];
}

export interface RoleManagementPolicyActivationRulesApprovalStagePrimaryApprover {
    /**
     * The ID of the object to act as an approver
     */
    objectId: string;
    /**
     * The type of object acting as an approver
     */
    type: string;
}

export interface RoleManagementPolicyActiveAssignmentRules {
    /**
     * Must the assignment have an expiry date
     */
    expirationRequired: boolean;
    /**
     * The duration after which assignments expire
     */
    expireAfter: string;
    /**
     * Whether a justification is required to make an assignment
     */
    requireJustification: boolean;
    /**
     * Whether multi-factor authentication is required to make an assignment
     */
    requireMultifactorAuthentication: boolean;
    /**
     * Whether ticket information is required to make an assignment
     */
    requireTicketInfo: boolean;
}

export interface RoleManagementPolicyEligibleAssignmentRules {
    /**
     * Must the assignment have an expiry date
     */
    expirationRequired: boolean;
    /**
     * The duration after which assignments expire
     */
    expireAfter: string;
}

export interface RoleManagementPolicyNotificationRules {
    /**
     * Notifications about active assignments
     */
    activeAssignments?: outputs.RoleManagementPolicyNotificationRulesActiveAssignments;
    /**
     * Notifications about activations of eligible assignments
     */
    eligibleActivations?: outputs.RoleManagementPolicyNotificationRulesEligibleActivations;
    /**
     * Notifications about eligible assignments
     */
    eligibleAssignments?: outputs.RoleManagementPolicyNotificationRulesEligibleAssignments;
}

export interface RoleManagementPolicyNotificationRulesActiveAssignments {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.RoleManagementPolicyNotificationRulesActiveAssignmentsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.RoleManagementPolicyNotificationRulesActiveAssignmentsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.RoleManagementPolicyNotificationRulesActiveAssignmentsAssigneeNotifications;
}

export interface RoleManagementPolicyNotificationRulesActiveAssignmentsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesActiveAssignmentsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesActiveAssignmentsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleActivations {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleActivationsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleActivationsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleActivationsAssigneeNotifications;
}

export interface RoleManagementPolicyNotificationRulesEligibleActivationsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleActivationsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleActivationsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleAssignments {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleAssignmentsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleAssignmentsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.RoleManagementPolicyNotificationRulesEligibleAssignmentsAssigneeNotifications;
}

export interface RoleManagementPolicyNotificationRulesEligibleAssignmentsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleAssignmentsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyNotificationRulesEligibleAssignmentsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface RoleManagementPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RouteFilterRule {
    access: string;
    communities: string[];
    name: string;
    ruleType: string;
}

export interface RouteFilterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RouteMapRule {
    actions?: outputs.RouteMapRuleAction[];
    matchCriterions?: outputs.RouteMapRuleMatchCriterion[];
    name: string;
    nextStepIfMatched?: string;
}

export interface RouteMapRuleAction {
    parameters?: outputs.RouteMapRuleActionParameter[];
    type: string;
}

export interface RouteMapRuleActionParameter {
    asPaths?: string[];
    communities?: string[];
    routePrefixes?: string[];
}

export interface RouteMapRuleMatchCriterion {
    asPaths?: string[];
    communities?: string[];
    matchCondition: string;
    routePrefixes?: string[];
}

export interface RouteMapTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RouteServerBgpConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface RouteServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RouteTableRoute {
    addressPrefix: string;
    name: string;
    nextHopInIpAddress: string;
    nextHopType: string;
}

export interface RouteTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RouteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SearchServiceIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface SearchServiceQueryKey {
    key: string;
    name: string;
}

export interface SearchServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SearchSharedPrivateLinkServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterAssessmentPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterAssessmentStatus {
    cause?: string;
    code: string;
    description?: string;
}

export interface SecurityCenterAssessmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterAutoProvisioningTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterAutomationAction {
    connectionString?: string;
    resourceId: string;
    triggerUrl?: string;
    type: string;
}

export interface SecurityCenterAutomationSource {
    eventSource: string;
    ruleSets?: outputs.SecurityCenterAutomationSourceRuleSet[];
}

export interface SecurityCenterAutomationSourceRuleSet {
    rules: outputs.SecurityCenterAutomationSourceRuleSetRule[];
}

export interface SecurityCenterAutomationSourceRuleSetRule {
    expectedValue: string;
    operator: string;
    propertyPath: string;
    propertyType: string;
}

export interface SecurityCenterAutomationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterContactTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterServerVulnerabilityAssessmentVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SecurityCenterServerVulnerabilityAssessmentsSettingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterSettingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterStorageDefenderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterSubscriptionPricingExtension {
    additionalExtensionProperties?: {[key: string]: string};
    name: string;
}

export interface SecurityCenterSubscriptionPricingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecurityCenterWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleAnomalyBuiltInMultiSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    values: string[];
}

export interface SentinelAlertRuleAnomalyBuiltInPrioritizedExcludeObservation {
    description: string;
    exclude: string;
    name: string;
    prioritize: string;
}

export interface SentinelAlertRuleAnomalyBuiltInRequiredDataConnector {
    connectorId: string;
    dataTypes: string[];
}

export interface SentinelAlertRuleAnomalyBuiltInSingleSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    value: string;
}

export interface SentinelAlertRuleAnomalyBuiltInThresholdObservation {
    description: string;
    max: string;
    min: string;
    name: string;
    value: string;
}

export interface SentinelAlertRuleAnomalyBuiltInTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleAnomalyDuplicateMultiSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    values: string[];
}

export interface SentinelAlertRuleAnomalyDuplicatePrioritizedExcludeObservation {
    description: string;
    exclude?: string;
    name: string;
    prioritize?: string;
}

export interface SentinelAlertRuleAnomalyDuplicateRequiredDataConnector {
    connectorId: string;
    dataTypes: string[];
}

export interface SentinelAlertRuleAnomalyDuplicateSingleSelectObservation {
    description: string;
    name: string;
    supportedValues: string[];
    value: string;
}

export interface SentinelAlertRuleAnomalyDuplicateThresholdObservation {
    description: string;
    max: string;
    min: string;
    name: string;
    value: string;
}

export interface SentinelAlertRuleAnomalyDuplicateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleFusionSource {
    enabled?: boolean;
    name: string;
    subTypes?: outputs.SentinelAlertRuleFusionSourceSubType[];
}

export interface SentinelAlertRuleFusionSourceSubType {
    enabled?: boolean;
    name: string;
    severitiesAlloweds: string[];
}

export interface SentinelAlertRuleFusionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleMachineLearningBehaviorAnalyticsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleMsSecurityIncidentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleNrtAlertDetailsOverride {
    descriptionFormat?: string;
    displayNameFormat?: string;
    dynamicProperties?: outputs.SentinelAlertRuleNrtAlertDetailsOverrideDynamicProperty[];
    severityColumnName?: string;
    tacticsColumnName?: string;
}

export interface SentinelAlertRuleNrtAlertDetailsOverrideDynamicProperty {
    name: string;
    value: string;
}

export interface SentinelAlertRuleNrtEntityMapping {
    entityType: string;
    fieldMappings: outputs.SentinelAlertRuleNrtEntityMappingFieldMapping[];
}

export interface SentinelAlertRuleNrtEntityMappingFieldMapping {
    columnName: string;
    identifier: string;
}

export interface SentinelAlertRuleNrtEventGrouping {
    aggregationMethod: string;
}

export interface SentinelAlertRuleNrtIncident {
    createIncidentEnabled: boolean;
    grouping: outputs.SentinelAlertRuleNrtIncidentGrouping;
}

export interface SentinelAlertRuleNrtIncidentGrouping {
    byAlertDetails?: string[];
    byCustomDetails?: string[];
    byEntities?: string[];
    enabled?: boolean;
    entityMatchingMethod?: string;
    lookbackDuration?: string;
    reopenClosedIncidents?: boolean;
}

export interface SentinelAlertRuleNrtSentinelEntityMapping {
    columnName: string;
}

export interface SentinelAlertRuleNrtTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleScheduledAlertDetailsOverride {
    descriptionFormat?: string;
    displayNameFormat?: string;
    dynamicProperties?: outputs.SentinelAlertRuleScheduledAlertDetailsOverrideDynamicProperty[];
    severityColumnName?: string;
    tacticsColumnName?: string;
}

export interface SentinelAlertRuleScheduledAlertDetailsOverrideDynamicProperty {
    name: string;
    value: string;
}

export interface SentinelAlertRuleScheduledEntityMapping {
    entityType: string;
    fieldMappings: outputs.SentinelAlertRuleScheduledEntityMappingFieldMapping[];
}

export interface SentinelAlertRuleScheduledEntityMappingFieldMapping {
    columnName: string;
    identifier: string;
}

export interface SentinelAlertRuleScheduledEventGrouping {
    aggregationMethod: string;
}

export interface SentinelAlertRuleScheduledIncident {
    createIncidentEnabled: boolean;
    grouping: outputs.SentinelAlertRuleScheduledIncidentGrouping;
}

export interface SentinelAlertRuleScheduledIncidentGrouping {
    byAlertDetails?: string[];
    byCustomDetails?: string[];
    byEntities?: string[];
    enabled?: boolean;
    entityMatchingMethod?: string;
    lookbackDuration?: string;
    reopenClosedIncidents?: boolean;
}

export interface SentinelAlertRuleScheduledSentinelEntityMapping {
    columnName: string;
}

export interface SentinelAlertRuleScheduledTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAlertRuleThreatIntelligenceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelAutomationRuleActionIncident {
    classification?: string;
    classificationComment?: string;
    labels?: string[];
    order: number;
    ownerId?: string;
    severity?: string;
    status?: string;
}

export interface SentinelAutomationRuleActionPlaybook {
    logicAppId: string;
    order: number;
    tenantId: string;
}

export interface SentinelAutomationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorAwsCloudTrailTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorAwsS3Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorAzureActiveDirectoryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorAzureAdvancedThreatProtectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorAzureSecurityCenterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorDynamics365Timeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorIotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorMicrosoftCloudAppSecurityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorMicrosoftDefenderAdvancedThreatProtectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorMicrosoftThreatIntelligenceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorMicrosoftThreatProtectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorOffice365ProjectTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorOffice365Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorOfficeAtpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorOfficeIrmTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorOfficePowerBiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelDataConnectorThreatIntelligenceTaxiiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelDataConnectorThreatIntelligenceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelLogAnalyticsWorkspaceOnboardingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SentinelMetadataAuthor {
    email?: string;
    link?: string;
    name?: string;
}

export interface SentinelMetadataCategory {
    domains?: string[];
    verticals?: string[];
}

export interface SentinelMetadataSource {
    id?: string;
    kind: string;
    name?: string;
}

export interface SentinelMetadataSupport {
    email?: string;
    link?: string;
    name?: string;
    tier: string;
}

export interface SentinelMetadataTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelThreatIntelligenceIndicatorExternalReference {
    description?: string;
    hashes?: {[key: string]: string};
    id: string;
    sourceName?: string;
    url?: string;
}

export interface SentinelThreatIntelligenceIndicatorGranularMarking {
    language?: string;
    markingRef?: string;
    selectors?: string[];
}

export interface SentinelThreatIntelligenceIndicatorKillChainPhase {
    name?: string;
}

export interface SentinelThreatIntelligenceIndicatorParsedPattern {
    patternTypeKey: string;
    patternTypeValues: outputs.SentinelThreatIntelligenceIndicatorParsedPatternPatternTypeValue[];
}

export interface SentinelThreatIntelligenceIndicatorParsedPatternPatternTypeValue {
    value: string;
    valueType: string;
}

export interface SentinelThreatIntelligenceIndicatorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelWatchlistItemTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SentinelWatchlistTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ServiceFabricClusterAzureActiveDirectory {
    clientApplicationId: string;
    clusterApplicationId: string;
    tenantId: string;
}

export interface ServiceFabricClusterCertificate {
    thumbprint: string;
    thumbprintSecondary?: string;
    x509StoreName: string;
}

export interface ServiceFabricClusterCertificateCommonNames {
    commonNames: outputs.ServiceFabricClusterCertificateCommonNamesCommonName[];
    x509StoreName: string;
}

export interface ServiceFabricClusterCertificateCommonNamesCommonName {
    certificateCommonName: string;
    certificateIssuerThumbprint?: string;
}

export interface ServiceFabricClusterClientCertificateCommonName {
    commonName: string;
    isAdmin: boolean;
    issuerThumbprint?: string;
}

export interface ServiceFabricClusterClientCertificateThumbprint {
    isAdmin: boolean;
    thumbprint: string;
}

export interface ServiceFabricClusterDiagnosticsConfig {
    blobEndpoint: string;
    protectedAccountKeyName: string;
    queueEndpoint: string;
    storageAccountName: string;
    tableEndpoint: string;
}

export interface ServiceFabricClusterFabricSetting {
    name: string;
    parameters?: {[key: string]: string};
}

export interface ServiceFabricClusterNodeType {
    applicationPorts?: outputs.ServiceFabricClusterNodeTypeApplicationPorts;
    capacities?: {[key: string]: string};
    clientEndpointPort: number;
    durabilityLevel?: string;
    ephemeralPorts?: outputs.ServiceFabricClusterNodeTypeEphemeralPorts;
    httpEndpointPort: number;
    instanceCount: number;
    isPrimary: boolean;
    isStateless?: boolean;
    multipleAvailabilityZones?: boolean;
    name: string;
    placementProperties?: {[key: string]: string};
    reverseProxyEndpointPort?: number;
}

export interface ServiceFabricClusterNodeTypeApplicationPorts {
    endPort: number;
    startPort: number;
}

export interface ServiceFabricClusterNodeTypeEphemeralPorts {
    endPort: number;
    startPort: number;
}

export interface ServiceFabricClusterReverseProxyCertificate {
    thumbprint: string;
    thumbprintSecondary?: string;
    x509StoreName: string;
}

export interface ServiceFabricClusterReverseProxyCertificateCommonNames {
    commonNames: outputs.ServiceFabricClusterReverseProxyCertificateCommonNamesCommonName[];
    x509StoreName: string;
}

export interface ServiceFabricClusterReverseProxyCertificateCommonNamesCommonName {
    certificateCommonName: string;
    certificateIssuerThumbprint?: string;
}

export interface ServiceFabricClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServiceFabricClusterUpgradePolicy {
    deltaHealthPolicy?: outputs.ServiceFabricClusterUpgradePolicyDeltaHealthPolicy;
    forceRestartEnabled?: boolean;
    healthCheckRetryTimeout?: string;
    healthCheckStableDuration?: string;
    healthCheckWaitDuration?: string;
    healthPolicy?: outputs.ServiceFabricClusterUpgradePolicyHealthPolicy;
    upgradeDomainTimeout?: string;
    upgradeReplicaSetCheckTimeout?: string;
    upgradeTimeout?: string;
}

export interface ServiceFabricClusterUpgradePolicyDeltaHealthPolicy {
    maxDeltaUnhealthyApplicationsPercent?: number;
    maxDeltaUnhealthyNodesPercent?: number;
    maxUpgradeDomainDeltaUnhealthyNodesPercent?: number;
}

export interface ServiceFabricClusterUpgradePolicyHealthPolicy {
    maxUnhealthyApplicationsPercent?: number;
    maxUnhealthyNodesPercent?: number;
}

export interface ServiceFabricManagedClusterAuthentication {
    activeDirectory?: outputs.ServiceFabricManagedClusterAuthenticationActiveDirectory;
    certificates?: outputs.ServiceFabricManagedClusterAuthenticationCertificate[];
}

export interface ServiceFabricManagedClusterAuthenticationActiveDirectory {
    clientApplicationId: string;
    clusterApplicationId: string;
    tenantId: string;
}

export interface ServiceFabricManagedClusterAuthenticationCertificate {
    commonName?: string;
    thumbprint: string;
    type: string;
}

export interface ServiceFabricManagedClusterCustomFabricSetting {
    parameter: string;
    section: string;
    value: string;
}

export interface ServiceFabricManagedClusterLbRule {
    backendPort: number;
    frontendPort: number;
    probeProtocol: string;
    probeRequestPath?: string;
    protocol: string;
}

export interface ServiceFabricManagedClusterNodeType {
    applicationPortRange: string;
    capacities?: {[key: string]: string};
    dataDiskSizeGb: number;
    dataDiskType?: string;
    ephemeralPortRange: string;
    id: string;
    multiplePlacementGroupsEnabled?: boolean;
    name: string;
    placementProperties?: {[key: string]: string};
    primary?: boolean;
    stateless?: boolean;
    vmImageOffer: string;
    vmImagePublisher: string;
    vmImageSku: string;
    vmImageVersion: string;
    vmInstanceCount: number;
    vmSecrets?: outputs.ServiceFabricManagedClusterNodeTypeVmSecret[];
    vmSize: string;
}

export interface ServiceFabricManagedClusterNodeTypeVmSecret {
    certificates: outputs.ServiceFabricManagedClusterNodeTypeVmSecretCertificate[];
    vaultId: string;
}

export interface ServiceFabricManagedClusterNodeTypeVmSecretCertificate {
    store: string;
    url: string;
}

export interface ServiceFabricManagedClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicePlanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusNamespaceAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusNamespaceCustomerManagedKey {
    identityId: string;
    infrastructureEncryptionEnabled?: boolean;
    keyVaultKeyId: string;
}

export interface ServicebusNamespaceDisasterRecoveryConfigTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusNamespaceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface ServicebusNamespaceNetworkRuleSet {
    defaultAction?: string;
    ipRules?: string[];
    networkRules?: outputs.ServicebusNamespaceNetworkRuleSetNetworkRule[];
    publicNetworkAccessEnabled?: boolean;
    trustedServicesAllowed?: boolean;
}

export interface ServicebusNamespaceNetworkRuleSetNetworkRule {
    ignoreMissingVnetServiceEndpoint?: boolean;
    subnetId: string;
}

export interface ServicebusNamespaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusQueueAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusQueueTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusSubscriptionClientScopedSubscription {
    clientId?: string;
    isClientScopedSubscriptionDurable: boolean;
    isClientScopedSubscriptionShareable?: boolean;
}

export interface ServicebusSubscriptionRuleCorrelationFilter {
    contentType?: string;
    correlationId?: string;
    label?: string;
    messageId?: string;
    properties?: {[key: string]: string};
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    to?: string;
}

export interface ServicebusSubscriptionRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusTopicAuthorizationRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicebusTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SharedImageGallerySharing {
    communityGallery?: outputs.SharedImageGallerySharingCommunityGallery;
    permission: string;
}

export interface SharedImageGallerySharingCommunityGallery {
    eula: string;
    name: string;
    prefix: string;
    publisherEmail: string;
    publisherUri: string;
}

export interface SharedImageGalleryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SharedImageIdentifier {
    offer: string;
    publisher: string;
    sku: string;
}

export interface SharedImagePurchasePlan {
    name: string;
    product?: string;
    publisher?: string;
}

export interface SharedImageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SharedImageVersionTargetRegion {
    diskEncryptionSetId?: string;
    excludeFromLatestEnabled?: boolean;
    name: string;
    regionalReplicaCount: number;
    storageAccountType?: string;
}

export interface SharedImageVersionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SignalrServiceCor {
    allowedOrigins: string[];
}

export interface SignalrServiceCustomCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SignalrServiceCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SignalrServiceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface SignalrServiceLiveTrace {
    connectivityLogsEnabled?: boolean;
    enabled?: boolean;
    httpRequestLogsEnabled?: boolean;
    messagingLogsEnabled?: boolean;
}

export interface SignalrServiceNetworkAclPrivateEndpoint {
    allowedRequestTypes?: string[];
    deniedRequestTypes?: string[];
    id: string;
}

export interface SignalrServiceNetworkAclPublicNetwork {
    allowedRequestTypes?: string[];
    deniedRequestTypes?: string[];
}

export interface SignalrServiceNetworkAclTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SignalrServiceSku {
    capacity: number;
    name: string;
}

export interface SignalrServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SignalrServiceUpstreamEndpoint {
    categoryPatterns: string[];
    eventPatterns: string[];
    hubPatterns: string[];
    urlTemplate: string;
    userAssignedIdentityId?: string;
}

export interface SignalrSharedPrivateLinkResourceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryFabricTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryHypervNetworkMappingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryHypervReplicationPolicyAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryHypervReplicationPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryNetworkMappingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryProtectionContainerMappingAutomaticUpdate {
    authenticationType?: string;
    automationAccountId?: string;
    enabled?: boolean;
}

export interface SiteRecoveryProtectionContainerMappingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryProtectionContainerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryReplicatedVmManagedDisk {
    diskId: string;
    stagingStorageAccountId: string;
    targetDiskEncryptionSetId: string;
    targetDiskEncryptions: outputs.SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryption[];
    targetDiskType: string;
    targetReplicaDiskType: string;
    targetResourceGroupId: string;
}

export interface SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryption {
    diskEncryptionKeys: outputs.SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryptionDiskEncryptionKey[];
    keyEncryptionKeys: outputs.SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryptionKeyEncryptionKey[];
}

export interface SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryptionDiskEncryptionKey {
    secretUrl: string;
    vaultId: string;
}

export interface SiteRecoveryReplicatedVmManagedDiskTargetDiskEncryptionKeyEncryptionKey {
    keyUrl: string;
    vaultId: string;
}

export interface SiteRecoveryReplicatedVmNetworkInterface {
    failoverTestPublicIpAddressId: string;
    failoverTestStaticIp: string;
    failoverTestSubnetName: string;
    recoveryPublicIpAddressId: string;
    sourceNetworkInterfaceId: string;
    targetStaticIp: string;
    targetSubnetName: string;
}

export interface SiteRecoveryReplicatedVmTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryReplicatedVmUnmanagedDisk {
    diskUri: string;
    stagingStorageAccountId: string;
    targetStorageAccountId: string;
}

export interface SiteRecoveryReplicationPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryReplicationRecoveryPlanAzureToAzureSettings {
    primaryEdgeZone?: string;
    primaryZone?: string;
    recoveryEdgeZone?: string;
    recoveryZone?: string;
}

export interface SiteRecoveryReplicationRecoveryPlanBootRecoveryGroup {
    postActions?: outputs.SiteRecoveryReplicationRecoveryPlanBootRecoveryGroupPostAction[];
    preActions?: outputs.SiteRecoveryReplicationRecoveryPlanBootRecoveryGroupPreAction[];
    replicatedProtectedItems?: string[];
}

export interface SiteRecoveryReplicationRecoveryPlanBootRecoveryGroupPostAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanBootRecoveryGroupPreAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanFailoverRecoveryGroup {
    postActions?: outputs.SiteRecoveryReplicationRecoveryPlanFailoverRecoveryGroupPostAction[];
    preActions?: outputs.SiteRecoveryReplicationRecoveryPlanFailoverRecoveryGroupPreAction[];
}

export interface SiteRecoveryReplicationRecoveryPlanFailoverRecoveryGroupPostAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanFailoverRecoveryGroupPreAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanShutdownRecoveryGroup {
    postActions?: outputs.SiteRecoveryReplicationRecoveryPlanShutdownRecoveryGroupPostAction[];
    preActions?: outputs.SiteRecoveryReplicationRecoveryPlanShutdownRecoveryGroupPreAction[];
}

export interface SiteRecoveryReplicationRecoveryPlanShutdownRecoveryGroupPostAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanShutdownRecoveryGroupPreAction {
    fabricLocation?: string;
    failOverDirections: string[];
    failOverTypes: string[];
    manualActionInstruction?: string;
    name: string;
    runbookId?: string;
    scriptPath?: string;
    type: string;
}

export interface SiteRecoveryReplicationRecoveryPlanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryServicesVaultHypervSiteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryVmwareReplicatedVmManagedDisk {
    diskId: string;
    logStorageAccountId?: string;
    targetDiskEncryptionSetId?: string;
    targetDiskType: string;
}

export interface SiteRecoveryVmwareReplicatedVmNetworkInterface {
    isPrimary: boolean;
    sourceMacAddress: string;
    targetStaticIp?: string;
    targetSubnetName?: string;
    testSubnetName?: string;
}

export interface SiteRecoveryVmwareReplicatedVmTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SiteRecoveryVmwareReplicationPolicyAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SiteRecoveryVmwareReplicationPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SnapshotEncryptionSettings {
    diskEncryptionKey: outputs.SnapshotEncryptionSettingsDiskEncryptionKey;
    keyEncryptionKey?: outputs.SnapshotEncryptionSettingsKeyEncryptionKey;
}

export interface SnapshotEncryptionSettingsDiskEncryptionKey {
    secretUrl: string;
    sourceVaultId: string;
}

export interface SnapshotEncryptionSettingsKeyEncryptionKey {
    keyUrl: string;
    sourceVaultId: string;
}

export interface SnapshotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SourceControlTokenTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpatialAnchorsAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAcceleratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SpringCloudActiveDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudApiPortalCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudApiPortalSso {
    clientId?: string;
    clientSecret?: string;
    issuerUri?: string;
    scopes?: string[];
}

export interface SpringCloudApiPortalTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAppCosmosdbAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAppCustomPersistentDisk {
    mountOptions?: string[];
    mountPath: string;
    readOnlyEnabled?: boolean;
    shareName: string;
    storageName: string;
}

export interface SpringCloudAppDynamicsApplicationPerformanceMonitoringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface SpringCloudAppIngressSettings {
    backendProtocol?: string;
    readTimeoutInSeconds?: number;
    sendTimeoutInSeconds?: number;
    sessionAffinity?: string;
    sessionCookieMaxAge?: number;
}

export interface SpringCloudAppMysqlAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAppPersistentDisk {
    mountPath?: string;
    sizeInGb: number;
}

export interface SpringCloudAppRedisAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudApplicationInsightsApplicationPerformanceMonitoringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudApplicationLiveViewTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SpringCloudBuildDeploymentQuota {
    cpu: string;
    memory: string;
}

export interface SpringCloudBuildDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudBuildPackBindingLaunch {
    properties?: {[key: string]: string};
    secrets?: {[key: string]: string};
}

export interface SpringCloudBuildPackBindingTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudBuilderBuildPackGroup {
    buildPackIds?: string[];
    name: string;
}

export interface SpringCloudBuilderStack {
    id: string;
    version: string;
}

export interface SpringCloudBuilderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SpringCloudConfigurationServiceRepository {
    caCertificateId?: string;
    hostKey?: string;
    hostKeyAlgorithm?: string;
    label: string;
    name: string;
    password?: string;
    patterns: string[];
    privateKey?: string;
    searchPaths?: string[];
    strictHostKeyChecking?: boolean;
    uri: string;
    username?: string;
}

export interface SpringCloudConfigurationServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudConnectionAuthentication {
    certificate?: string;
    clientId?: string;
    name?: string;
    principalId?: string;
    secret?: string;
    subscriptionId?: string;
    type: string;
}

export interface SpringCloudConnectionSecretStore {
    keyVaultId: string;
}

export interface SpringCloudConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudContainerDeploymentQuota {
    cpu: string;
    memory: string;
}

export interface SpringCloudContainerDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudCustomizedAcceleratorGitRepository {
    basicAuth?: outputs.SpringCloudCustomizedAcceleratorGitRepositoryBasicAuth;
    branch?: string;
    caCertificateId?: string;
    commit?: string;
    gitTag?: string;
    intervalInSeconds?: number;
    path?: string;
    sshAuth?: outputs.SpringCloudCustomizedAcceleratorGitRepositorySshAuth;
    url: string;
}

export interface SpringCloudCustomizedAcceleratorGitRepositoryBasicAuth {
    password: string;
    username: string;
}

export interface SpringCloudCustomizedAcceleratorGitRepositorySshAuth {
    hostKey?: string;
    hostKeyAlgorithm?: string;
    privateKey: string;
}

export interface SpringCloudCustomizedAcceleratorTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudDevToolPortalSso {
    clientId?: string;
    clientSecret?: string;
    metadataUrl?: string;
    scopes?: string[];
}

export interface SpringCloudDevToolPortalTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudDynatraceApplicationPerformanceMonitoringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudElasticApplicationPerformanceMonitoringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudGatewayApiMetadata {
    description?: string;
    documentationUrl?: string;
    serverUrl?: string;
    title?: string;
    version?: string;
}

export interface SpringCloudGatewayClientAuthorization {
    certificateIds?: string[];
    verificationEnabled?: boolean;
}

export interface SpringCloudGatewayCors {
    allowedHeaders?: string[];
    allowedMethods?: string[];
    allowedOriginPatterns?: string[];
    allowedOrigins?: string[];
    credentialsAllowed?: boolean;
    exposedHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface SpringCloudGatewayCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudGatewayLocalResponseCachePerInstance {
    size?: string;
    timeToLive?: string;
}

export interface SpringCloudGatewayLocalResponseCachePerRoute {
    size?: string;
    timeToLive?: string;
}

export interface SpringCloudGatewayQuota {
    cpu?: string;
    memory?: string;
}

export interface SpringCloudGatewayRouteConfigOpenApi {
    uri?: string;
}

export interface SpringCloudGatewayRouteConfigRoute {
    classificationTags?: string[];
    description?: string;
    filters?: string[];
    order: number;
    predicates?: string[];
    ssoValidationEnabled?: boolean;
    title?: string;
    tokenRelay?: boolean;
    uri?: string;
}

export interface SpringCloudGatewayRouteConfigTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudGatewaySso {
    clientId?: string;
    clientSecret?: string;
    issuerUri?: string;
    scopes?: string[];
}

export interface SpringCloudGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudJavaDeploymentQuota {
    cpu: string;
    memory: string;
}

export interface SpringCloudJavaDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudNewRelicApplicationPerformanceMonitoringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudServiceConfigServerGitSetting {
    httpBasicAuth?: outputs.SpringCloudServiceConfigServerGitSettingHttpBasicAuth;
    label?: string;
    repositories?: outputs.SpringCloudServiceConfigServerGitSettingRepository[];
    searchPaths?: string[];
    sshAuth?: outputs.SpringCloudServiceConfigServerGitSettingSshAuth;
    uri: string;
}

export interface SpringCloudServiceConfigServerGitSettingHttpBasicAuth {
    password: string;
    username: string;
}

export interface SpringCloudServiceConfigServerGitSettingRepository {
    httpBasicAuth?: outputs.SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth;
    label?: string;
    name: string;
    patterns?: string[];
    searchPaths?: string[];
    sshAuth?: outputs.SpringCloudServiceConfigServerGitSettingRepositorySshAuth;
    uri: string;
}

export interface SpringCloudServiceConfigServerGitSettingRepositoryHttpBasicAuth {
    password: string;
    username: string;
}

export interface SpringCloudServiceConfigServerGitSettingRepositorySshAuth {
    hostKey?: string;
    hostKeyAlgorithm?: string;
    privateKey: string;
    strictHostKeyCheckingEnabled?: boolean;
}

export interface SpringCloudServiceConfigServerGitSettingSshAuth {
    hostKey?: string;
    hostKeyAlgorithm?: string;
    privateKey: string;
    strictHostKeyCheckingEnabled?: boolean;
}

export interface SpringCloudServiceContainerRegistry {
    name: string;
    password: string;
    server: string;
    username: string;
}

export interface SpringCloudServiceDefaultBuildService {
    containerRegistryName?: string;
}

export interface SpringCloudServiceMarketplace {
    plan: string;
    product: string;
    publisher: string;
}

export interface SpringCloudServiceNetwork {
    appNetworkResourceGroup: string;
    appSubnetId: string;
    cidrRanges: string[];
    outboundType?: string;
    readTimeoutSeconds?: number;
    serviceRuntimeNetworkResourceGroup: string;
    serviceRuntimeSubnetId: string;
}

export interface SpringCloudServiceRequiredNetworkTrafficRule {
    direction: string;
    fqdns: string[];
    ipAddresses: string[];
    port: number;
    protocol: string;
}

export interface SpringCloudServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SpringCloudServiceTrace {
    connectionString?: string;
    sampleRate?: number;
}

export interface SpringCloudStorageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SshPublicKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StackHciClusterIdentity {
    principalId: string;
    tenantId: string;
    type: string;
}

export interface StackHciClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StackHciLogicalNetworkSubnet {
    addressPrefix?: string;
    ipAllocationMethod: string;
    ipPools?: outputs.StackHciLogicalNetworkSubnetIpPool[];
    routes?: outputs.StackHciLogicalNetworkSubnetRoute[];
    vlanId?: number;
}

export interface StackHciLogicalNetworkSubnetIpPool {
    end: string;
    start: string;
}

export interface StackHciLogicalNetworkSubnetRoute {
    addressPrefix: string;
    name: string;
    nextHopIpAddress: string;
}

export interface StackHciLogicalNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StaticSiteCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StaticSiteIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface StaticSiteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StaticWebAppBasicAuth {
    environments: string;
    password: string;
}

export interface StaticWebAppCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StaticWebAppFunctionAppRegistrationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StaticWebAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface StaticWebAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageAccountAzureFilesAuthentication {
    activeDirectory?: outputs.StorageAccountAzureFilesAuthenticationActiveDirectory;
    defaultShareLevelPermission?: string;
    directoryType: string;
}

export interface StorageAccountAzureFilesAuthenticationActiveDirectory {
    domainGuid: string;
    domainName: string;
    domainSid?: string;
    forestName?: string;
    netbiosDomainName?: string;
    storageSid?: string;
}

export interface StorageAccountBlobProperties {
    changeFeedEnabled?: boolean;
    changeFeedRetentionInDays?: number;
    containerDeleteRetentionPolicy?: outputs.StorageAccountBlobPropertiesContainerDeleteRetentionPolicy;
    corsRules?: outputs.StorageAccountBlobPropertiesCorsRule[];
    defaultServiceVersion: string;
    deleteRetentionPolicy?: outputs.StorageAccountBlobPropertiesDeleteRetentionPolicy;
    lastAccessTimeEnabled?: boolean;
    restorePolicy?: outputs.StorageAccountBlobPropertiesRestorePolicy;
    versioningEnabled?: boolean;
}

export interface StorageAccountBlobPropertiesContainerDeleteRetentionPolicy {
    days?: number;
}

export interface StorageAccountBlobPropertiesCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

export interface StorageAccountBlobPropertiesDeleteRetentionPolicy {
    days?: number;
    permanentDeleteEnabled?: boolean;
}

export interface StorageAccountBlobPropertiesRestorePolicy {
    days: number;
}

export interface StorageAccountCustomDomain {
    name: string;
    useSubdomain?: boolean;
}

export interface StorageAccountCustomerManagedKey {
    keyVaultKeyId?: string;
    managedHsmKeyId?: string;
    userAssignedIdentityId: string;
}

export interface StorageAccountCustomerManagedKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageAccountIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface StorageAccountImmutabilityPolicy {
    allowProtectedAppendWrites: boolean;
    periodSinceCreationInDays: number;
    state: string;
}

export interface StorageAccountLocalUserPermissionScope {
    permissions: outputs.StorageAccountLocalUserPermissionScopePermissions;
    resourceName: string;
    service: string;
}

export interface StorageAccountLocalUserPermissionScopePermissions {
    create?: boolean;
    delete?: boolean;
    list?: boolean;
    read?: boolean;
    write?: boolean;
}

export interface StorageAccountLocalUserSshAuthorizedKey {
    description?: string;
    key: string;
}

export interface StorageAccountLocalUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageAccountNetworkRules {
    bypasses: string[];
    defaultAction: string;
    ipRules: string[];
    privateLinkAccesses?: outputs.StorageAccountNetworkRulesPrivateLinkAccess[];
    virtualNetworkSubnetIds: string[];
}

export interface StorageAccountNetworkRulesPrivateLinkAccess {
    endpointResourceId: string;
    endpointTenantId: string;
}

export interface StorageAccountNetworkRulesTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageAccountQueueProperties {
    corsRules?: outputs.StorageAccountQueuePropertiesCorsRule[];
    hourMetrics?: outputs.StorageAccountQueuePropertiesHourMetrics;
    logging?: outputs.StorageAccountQueuePropertiesLogging;
    minuteMetrics?: outputs.StorageAccountQueuePropertiesMinuteMetrics;
}

export interface StorageAccountQueuePropertiesCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

export interface StorageAccountQueuePropertiesHourMetrics {
    enabled: boolean;
    includeApis?: boolean;
    retentionPolicyDays?: number;
    version: string;
}

export interface StorageAccountQueuePropertiesLogging {
    delete: boolean;
    read: boolean;
    retentionPolicyDays?: number;
    version: string;
    write: boolean;
}

export interface StorageAccountQueuePropertiesMinuteMetrics {
    enabled: boolean;
    includeApis?: boolean;
    retentionPolicyDays?: number;
    version: string;
}

export interface StorageAccountRouting {
    choice?: string;
    publishInternetEndpoints?: boolean;
    publishMicrosoftEndpoints?: boolean;
}

export interface StorageAccountSasPolicy {
    expirationAction?: string;
    expirationPeriod: string;
}

export interface StorageAccountShareProperties {
    corsRules?: outputs.StorageAccountSharePropertiesCorsRule[];
    retentionPolicy?: outputs.StorageAccountSharePropertiesRetentionPolicy;
    smb?: outputs.StorageAccountSharePropertiesSmb;
}

export interface StorageAccountSharePropertiesCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

export interface StorageAccountSharePropertiesRetentionPolicy {
    days?: number;
}

export interface StorageAccountSharePropertiesSmb {
    authenticationTypes?: string[];
    channelEncryptionTypes?: string[];
    kerberosTicketEncryptionTypes?: string[];
    multichannelEnabled?: boolean;
    versions?: string[];
}

export interface StorageAccountStaticWebsite {
    error404Document?: string;
    indexDocument?: string;
}

export interface StorageAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageBlobInventoryPolicyRule {
    filter?: outputs.StorageBlobInventoryPolicyRuleFilter;
    format: string;
    name: string;
    schedule: string;
    schemaFields: string[];
    scope: string;
    storageContainerName: string;
}

export interface StorageBlobInventoryPolicyRuleFilter {
    blobTypes: string[];
    excludePrefixes?: string[];
    includeBlobVersions?: boolean;
    includeDeleted?: boolean;
    includeSnapshots?: boolean;
    prefixMatches?: string[];
}

export interface StorageBlobInventoryPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageBlobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageContainerImmutabilityPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageContainerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageDataLakeGen2FilesystemAce {
    id?: string;
    permissions: string;
    scope?: string;
    type: string;
}

export interface StorageDataLakeGen2FilesystemTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageDataLakeGen2PathAce {
    id?: string;
    permissions: string;
    scope?: string;
    type: string;
}

export interface StorageDataLakeGen2PathTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageEncryptionScopeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageManagementPolicyRule {
    actions: outputs.StorageManagementPolicyRuleActions;
    enabled: boolean;
    filters: outputs.StorageManagementPolicyRuleFilters;
    name: string;
}

export interface StorageManagementPolicyRuleActions {
    baseBlob?: outputs.StorageManagementPolicyRuleActionsBaseBlob;
    snapshot?: outputs.StorageManagementPolicyRuleActionsSnapshot;
    version?: outputs.StorageManagementPolicyRuleActionsVersion;
}

export interface StorageManagementPolicyRuleActionsBaseBlob {
    autoTierToHotFromCoolEnabled?: boolean;
    deleteAfterDaysSinceCreationGreaterThan?: number;
    deleteAfterDaysSinceLastAccessTimeGreaterThan?: number;
    deleteAfterDaysSinceModificationGreaterThan?: number;
    tierToArchiveAfterDaysSinceCreationGreaterThan?: number;
    tierToArchiveAfterDaysSinceLastAccessTimeGreaterThan?: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
    tierToArchiveAfterDaysSinceModificationGreaterThan?: number;
    tierToColdAfterDaysSinceCreationGreaterThan?: number;
    tierToColdAfterDaysSinceLastAccessTimeGreaterThan?: number;
    tierToColdAfterDaysSinceModificationGreaterThan?: number;
    tierToCoolAfterDaysSinceCreationGreaterThan?: number;
    tierToCoolAfterDaysSinceLastAccessTimeGreaterThan?: number;
    tierToCoolAfterDaysSinceModificationGreaterThan?: number;
}

export interface StorageManagementPolicyRuleActionsSnapshot {
    changeTierToArchiveAfterDaysSinceCreation?: number;
    changeTierToCoolAfterDaysSinceCreation?: number;
    deleteAfterDaysSinceCreationGreaterThan?: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
    tierToColdAfterDaysSinceCreationGreaterThan?: number;
}

export interface StorageManagementPolicyRuleActionsVersion {
    changeTierToArchiveAfterDaysSinceCreation?: number;
    changeTierToCoolAfterDaysSinceCreation?: number;
    deleteAfterDaysSinceCreation?: number;
    tierToArchiveAfterDaysSinceLastTierChangeGreaterThan?: number;
    tierToColdAfterDaysSinceCreationGreaterThan?: number;
}

export interface StorageManagementPolicyRuleFilters {
    blobTypes: string[];
    matchBlobIndexTags?: outputs.StorageManagementPolicyRuleFiltersMatchBlobIndexTag[];
    prefixMatches?: string[];
}

export interface StorageManagementPolicyRuleFiltersMatchBlobIndexTag {
    name: string;
    operation?: string;
    value: string;
}

export interface StorageManagementPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverAgentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverJobDefinitionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverProjectTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverSourceEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverTargetEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageMoverTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageObjectReplicationRule {
    copyBlobsCreatedAfter?: string;
    destinationContainerName: string;
    filterOutBlobsWithPrefixes?: string[];
    name: string;
    sourceContainerName: string;
}

export interface StorageObjectReplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageQueueTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageShareAcl {
    accessPolicies?: outputs.StorageShareAclAccessPolicy[];
    id: string;
}

export interface StorageShareAclAccessPolicy {
    expiry?: string;
    permissions: string;
    start?: string;
}

export interface StorageShareDirectoryTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageShareFileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageShareTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageSyncCloudEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StorageSyncGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StorageSyncServerEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageSyncTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageTableAcl {
    accessPolicies?: outputs.StorageTableAclAccessPolicy[];
    id: string;
}

export interface StorageTableAclAccessPolicy {
    expiry: string;
    permissions: string;
    start: string;
}

export interface StorageTableEntityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StorageTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsFunctionJavascriptUdaInput {
    configurationParameter?: boolean;
    type: string;
}

export interface StreamAnalyticsFunctionJavascriptUdaOutput {
    type: string;
}

export interface StreamAnalyticsFunctionJavascriptUdaTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsFunctionJavascriptUdfInput {
    configurationParameter?: boolean;
    type: string;
}

export interface StreamAnalyticsFunctionJavascriptUdfOutput {
    type: string;
}

export interface StreamAnalyticsFunctionJavascriptUdfTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsJobIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface StreamAnalyticsJobJobStorageAccount {
    accountKey: string;
    accountName: string;
    authenticationMode?: string;
}

export interface StreamAnalyticsJobScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsJobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsManagedPrivateEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface StreamAnalyticsOutputBlobSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    format?: string;
    type: string;
}

export interface StreamAnalyticsOutputBlobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputCosmosdbTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputEventhubSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    format?: string;
    type: string;
}

export interface StreamAnalyticsOutputEventhubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputFunctionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputMssqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputPowerbiTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputServicebusQueueSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    format?: string;
    type: string;
}

export interface StreamAnalyticsOutputServicebusQueueTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputServicebusTopicSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    format?: string;
    type: string;
}

export interface StreamAnalyticsOutputServicebusTopicTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputSynapseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsOutputTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsReferenceInputBlobSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    type: string;
}

export interface StreamAnalyticsReferenceInputBlobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsReferenceInputMssqlTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsStreamInputBlobSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    type: string;
}

export interface StreamAnalyticsStreamInputBlobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsStreamInputEventhubSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    type: string;
}

export interface StreamAnalyticsStreamInputEventhubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsStreamInputEventhubV2Serialization {
    encoding?: string;
    fieldDelimiter?: string;
    type: string;
}

export interface StreamAnalyticsStreamInputEventhubV2Timeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface StreamAnalyticsStreamInputIothubSerialization {
    encoding?: string;
    fieldDelimiter?: string;
    type: string;
}

export interface StreamAnalyticsStreamInputIothubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubnetDelegation {
    name: string;
    serviceDelegation: outputs.SubnetDelegationServiceDelegation;
}

export interface SubnetDelegationServiceDelegation {
    actions?: string[];
    name: string;
}

export interface SubnetNatGatewayAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SubnetNetworkSecurityGroupAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SubnetRouteTableAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SubnetServiceEndpointStoragePolicyDefinition {
    description?: string;
    name: string;
    service?: string;
    serviceResources: string[];
}

export interface SubnetServiceEndpointStoragePolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubnetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionCostManagementExportExportDataOptions {
    timeFrame: string;
    type: string;
}

export interface SubscriptionCostManagementExportExportDataStorageLocation {
    containerId: string;
    rootFolderPath: string;
}

export interface SubscriptionCostManagementExportTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionCostManagementViewDataset {
    aggregations: outputs.SubscriptionCostManagementViewDatasetAggregation[];
    granularity: string;
    groupings?: outputs.SubscriptionCostManagementViewDatasetGrouping[];
    sortings?: outputs.SubscriptionCostManagementViewDatasetSorting[];
}

export interface SubscriptionCostManagementViewDatasetAggregation {
    columnName: string;
    name: string;
}

export interface SubscriptionCostManagementViewDatasetGrouping {
    name: string;
    type: string;
}

export interface SubscriptionCostManagementViewDatasetSorting {
    direction: string;
    name: string;
}

export interface SubscriptionCostManagementViewKpi {
    type: string;
}

export interface SubscriptionCostManagementViewPivot {
    name: string;
    type: string;
}

export interface SubscriptionCostManagementViewTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionPolicyAssignmentIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface SubscriptionPolicyAssignmentNonComplianceMessage {
    content: string;
    policyDefinitionReferenceId?: string;
}

export interface SubscriptionPolicyAssignmentOverride {
    selectors?: outputs.SubscriptionPolicyAssignmentOverrideSelector[];
    value: string;
}

export interface SubscriptionPolicyAssignmentOverrideSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface SubscriptionPolicyAssignmentResourceSelector {
    name?: string;
    selectors: outputs.SubscriptionPolicyAssignmentResourceSelectorSelector[];
}

export interface SubscriptionPolicyAssignmentResourceSelectorSelector {
    ins?: string[];
    kind: string;
    notIns?: string[];
}

export interface SubscriptionPolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionPolicyExemptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionPolicyRemediationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionTemplateDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseFirewallRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseIntegrationRuntimeAzureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseIntegrationRuntimeSelfHostedTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseLinkedServiceIntegrationRuntime {
    name: string;
    parameters?: {[key: string]: string};
}

export interface SynapseLinkedServiceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseManagedPrivateEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SynapsePrivateLinkHubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SynapseSparkPoolAutoPause {
    delayInMinutes: number;
}

export interface SynapseSparkPoolAutoScale {
    maxNodeCount: number;
    minNodeCount: number;
}

export interface SynapseSparkPoolLibraryRequirement {
    content: string;
    filename: string;
}

export interface SynapseSparkPoolSparkConfig {
    content: string;
    filename: string;
}

export interface SynapseSparkPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolExtendedAuditingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolRestore {
    pointInTime: string;
    sourceDatabaseId: string;
}

export interface SynapseSqlPoolSecurityAlertPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolVulnerabilityAssessmentBaselineBaseline {
    results: string[];
}

export interface SynapseSqlPoolVulnerabilityAssessmentBaselineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolVulnerabilityAssessmentRecurringScans {
    emailSubscriptionAdminsEnabled?: boolean;
    emails?: string[];
    enabled?: boolean;
}

export interface SynapseSqlPoolVulnerabilityAssessmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolWorkloadClassifierTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseSqlPoolWorkloadGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceAadAdminTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceAzureDevopsRepo {
    accountName: string;
    branchName: string;
    lastCommitId?: string;
    projectName: string;
    repositoryName: string;
    rootFolder: string;
    tenantId: string;
}

export interface SynapseWorkspaceCustomerManagedKey {
    keyName?: string;
    keyVersionlessId: string;
    userAssignedIdentityId?: string;
}

export interface SynapseWorkspaceExtendedAuditingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceGithubRepo {
    accountName: string;
    branchName: string;
    gitUrl?: string;
    lastCommitId?: string;
    repositoryName: string;
    rootFolder: string;
}

export interface SynapseWorkspaceIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface SynapseWorkspaceKeyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceSecurityAlertPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceSqlAadAdminTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynapseWorkspaceVulnerabilityAssessmentRecurringScans {
    emailSubscriptionAdminsEnabled?: boolean;
    emails?: string[];
    enabled?: boolean;
}

export interface SynapseWorkspaceVulnerabilityAssessmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SystemCenterVirtualMachineManagerAvailabilitySetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SystemCenterVirtualMachineManagerCloudTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SystemCenterVirtualMachineManagerServerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SystemCenterVirtualMachineManagerVirtualMachineTemplateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SystemCenterVirtualMachineManagerVirtualNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TenantTemplateDeploymentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TrafficManagerAzureEndpointCustomHeader {
    name: string;
    value: string;
}

export interface TrafficManagerAzureEndpointSubnet {
    first: string;
    last?: string;
    scope?: number;
}

export interface TrafficManagerAzureEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TrafficManagerExternalEndpointCustomHeader {
    name: string;
    value: string;
}

export interface TrafficManagerExternalEndpointSubnet {
    first: string;
    last?: string;
    scope?: number;
}

export interface TrafficManagerExternalEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TrafficManagerNestedEndpointCustomHeader {
    name: string;
    value: string;
}

export interface TrafficManagerNestedEndpointSubnet {
    first: string;
    last?: string;
    scope?: number;
}

export interface TrafficManagerNestedEndpointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TrafficManagerProfileDnsConfig {
    relativeName: string;
    ttl: number;
}

export interface TrafficManagerProfileMonitorConfig {
    customHeaders?: outputs.TrafficManagerProfileMonitorConfigCustomHeader[];
    expectedStatusCodeRanges?: string[];
    intervalInSeconds?: number;
    path?: string;
    port: number;
    protocol: string;
    timeoutInSeconds?: number;
    toleratedNumberOfFailures?: number;
}

export interface TrafficManagerProfileMonitorConfigCustomHeader {
    name: string;
    value: string;
}

export interface TrafficManagerProfileTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface UserAssignedIdentityTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopApplicationGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopHostPoolRegistrationInfoTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopHostPoolScheduledAgentUpdates {
    enabled?: boolean;
    schedules?: outputs.VirtualDesktopHostPoolScheduledAgentUpdatesSchedule[];
    timezone?: string;
    useSessionHostTimezone?: boolean;
}

export interface VirtualDesktopHostPoolScheduledAgentUpdatesSchedule {
    dayOfWeek: string;
    hourOfDay: number;
}

export interface VirtualDesktopHostPoolTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopScalingPlanHostPool {
    hostpoolId: string;
    scalingPlanEnabled: boolean;
}

export interface VirtualDesktopScalingPlanHostPoolAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopScalingPlanSchedule {
    daysOfWeeks: string[];
    name: string;
    offPeakLoadBalancingAlgorithm: string;
    offPeakStartTime: string;
    peakLoadBalancingAlgorithm: string;
    peakStartTime: string;
    rampDownCapacityThresholdPercent: number;
    rampDownForceLogoffUsers: boolean;
    rampDownLoadBalancingAlgorithm: string;
    rampDownMinimumHostsPercent: number;
    rampDownNotificationMessage: string;
    rampDownStartTime: string;
    rampDownStopHostsWhen: string;
    rampDownWaitTimeMinutes: number;
    rampUpCapacityThresholdPercent?: number;
    rampUpLoadBalancingAlgorithm: string;
    rampUpMinimumHostsPercent?: number;
    rampUpStartTime: string;
}

export interface VirtualDesktopScalingPlanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualDesktopWorkspaceApplicationGroupAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VirtualDesktopWorkspaceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubBgpConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubConnectionRouting {
    associatedRouteTableId: string;
    inboundRouteMapId?: string;
    outboundRouteMapId?: string;
    propagatedRouteTable?: outputs.VirtualHubConnectionRoutingPropagatedRouteTable;
    staticVnetLocalRouteOverrideCriteria?: string;
    staticVnetRoutes?: outputs.VirtualHubConnectionRoutingStaticVnetRoute[];
}

export interface VirtualHubConnectionRoutingPropagatedRouteTable {
    labels: string[];
    routeTableIds: string[];
}

export interface VirtualHubConnectionRoutingStaticVnetRoute {
    addressPrefixes?: string[];
    name?: string;
    nextHopIpAddress?: string;
}

export interface VirtualHubConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubIpTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubRoute {
    addressPrefixes: string[];
    nextHopIpAddress: string;
}

export interface VirtualHubRouteTableRoute {
    destinations: string[];
    destinationsType: string;
    name: string;
    nextHop: string;
    nextHopType?: string;
}

export interface VirtualHubRouteTableRouteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubRouteTableTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubRoutingIntentRoutingPolicy {
    destinations: string[];
    name: string;
    nextHop: string;
}

export interface VirtualHubRoutingIntentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubSecurityPartnerProviderTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualHubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineAdditionalCapabilities {
    ultraSsdEnabled: boolean;
}

export interface VirtualMachineAutomanageConfigurationAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VirtualMachineBootDiagnostics {
    enabled: boolean;
    storageUri: string;
}

export interface VirtualMachineDataDiskAttachmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVaultId: string;
}

export interface VirtualMachineExtensionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineGalleryApplicationAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface VirtualMachineImplicitDataDiskFromSourceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineOsProfile {
    adminPassword?: string;
    adminUsername: string;
    computerName: string;
    customData: string;
}

export interface VirtualMachineOsProfileLinuxConfig {
    disablePasswordAuthentication: boolean;
    sshKeys?: outputs.VirtualMachineOsProfileLinuxConfigSshKey[];
}

export interface VirtualMachineOsProfileLinuxConfigSshKey {
    keyData: string;
    path: string;
}

export interface VirtualMachineOsProfileSecret {
    sourceVaultId: string;
    vaultCertificates?: outputs.VirtualMachineOsProfileSecretVaultCertificate[];
}

export interface VirtualMachineOsProfileSecretVaultCertificate {
    certificateStore?: string;
    certificateUrl: string;
}

export interface VirtualMachineOsProfileWindowsConfig {
    additionalUnattendConfigs?: outputs.VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig[];
    enableAutomaticUpgrades?: boolean;
    provisionVmAgent?: boolean;
    timezone?: string;
    winrms?: outputs.VirtualMachineOsProfileWindowsConfigWinrm[];
}

export interface VirtualMachineOsProfileWindowsConfigAdditionalUnattendConfig {
    component: string;
    content: string;
    pass: string;
    settingName: string;
}

export interface VirtualMachineOsProfileWindowsConfigWinrm {
    certificateUrl?: string;
    protocol: string;
}

export interface VirtualMachinePacketCaptureFilter {
    localIpAddress?: string;
    localPort?: string;
    protocol: string;
    remoteIpAddress?: string;
    remotePort?: string;
}

export interface VirtualMachinePacketCaptureStorageLocation {
    filePath?: string;
    storageAccountId?: string;
    storagePath: string;
}

export interface VirtualMachinePacketCaptureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VirtualMachinePlan {
    name: string;
    product: string;
    publisher: string;
}

export interface VirtualMachineRestorePointCollectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineRestorePointTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VirtualMachineRunCommandErrorBlobManagedIdentity {
    clientId?: string;
    objectId?: string;
}

export interface VirtualMachineRunCommandInstanceView {
    endTime: string;
    errorMessage: string;
    executionMessage: string;
    executionState: string;
    exitCode: number;
    output: string;
    startTime: string;
}

export interface VirtualMachineRunCommandOutputBlobManagedIdentity {
    clientId?: string;
    objectId?: string;
}

export interface VirtualMachineRunCommandParameter {
    name: string;
    value: string;
}

export interface VirtualMachineRunCommandProtectedParameter {
    name: string;
    value: string;
}

export interface VirtualMachineRunCommandSource {
    commandId?: string;
    script?: string;
    scriptUri?: string;
    scriptUriManagedIdentity?: outputs.VirtualMachineRunCommandSourceScriptUriManagedIdentity;
}

export interface VirtualMachineRunCommandSourceScriptUriManagedIdentity {
    clientId?: string;
    objectId?: string;
}

export interface VirtualMachineRunCommandTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineScaleSetBootDiagnostics {
    enabled?: boolean;
    storageUri: string;
}

export interface VirtualMachineScaleSetExtension {
    autoUpgradeMinorVersion?: boolean;
    name: string;
    protectedSettings?: string;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: string;
    type: string;
    typeHandlerVersion: string;
}

export interface VirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVaultId: string;
}

export interface VirtualMachineScaleSetExtensionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineScaleSetIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface VirtualMachineScaleSetNetworkProfile {
    acceleratedNetworking?: boolean;
    dnsSettings?: outputs.VirtualMachineScaleSetNetworkProfileDnsSettings;
    ipConfigurations: outputs.VirtualMachineScaleSetNetworkProfileIpConfiguration[];
    ipForwarding?: boolean;
    name: string;
    networkSecurityGroupId?: string;
    primary: boolean;
}

export interface VirtualMachineScaleSetNetworkProfileDnsSettings {
    dnsServers: string[];
}

export interface VirtualMachineScaleSetNetworkProfileIpConfiguration {
    applicationGatewayBackendAddressPoolIds?: string[];
    applicationSecurityGroupIds?: string[];
    loadBalancerBackendAddressPoolIds?: string[];
    loadBalancerInboundNatRulesIds: string[];
    name: string;
    primary: boolean;
    publicIpAddressConfiguration?: outputs.VirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration;
    subnetId: string;
}

export interface VirtualMachineScaleSetNetworkProfileIpConfigurationPublicIpAddressConfiguration {
    domainNameLabel: string;
    idleTimeout: number;
    name: string;
}

export interface VirtualMachineScaleSetOsProfile {
    adminPassword?: string;
    adminUsername: string;
    computerNamePrefix: string;
    customData?: string;
}

export interface VirtualMachineScaleSetOsProfileLinuxConfig {
    disablePasswordAuthentication?: boolean;
    sshKeys?: outputs.VirtualMachineScaleSetOsProfileLinuxConfigSshKey[];
}

export interface VirtualMachineScaleSetOsProfileLinuxConfigSshKey {
    keyData?: string;
    path: string;
}

export interface VirtualMachineScaleSetOsProfileSecret {
    sourceVaultId: string;
    vaultCertificates?: outputs.VirtualMachineScaleSetOsProfileSecretVaultCertificate[];
}

export interface VirtualMachineScaleSetOsProfileSecretVaultCertificate {
    certificateStore?: string;
    certificateUrl: string;
}

export interface VirtualMachineScaleSetOsProfileWindowsConfig {
    additionalUnattendConfigs?: outputs.VirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig[];
    enableAutomaticUpgrades?: boolean;
    provisionVmAgent?: boolean;
    winrms?: outputs.VirtualMachineScaleSetOsProfileWindowsConfigWinrm[];
}

export interface VirtualMachineScaleSetOsProfileWindowsConfigAdditionalUnattendConfig {
    component: string;
    content: string;
    pass: string;
    settingName: string;
}

export interface VirtualMachineScaleSetOsProfileWindowsConfigWinrm {
    certificateUrl?: string;
    protocol: string;
}

export interface VirtualMachineScaleSetPacketCaptureFilter {
    localIpAddress?: string;
    localPort?: string;
    protocol: string;
    remoteIpAddress?: string;
    remotePort?: string;
}

export interface VirtualMachineScaleSetPacketCaptureMachineScope {
    excludeInstanceIds?: string[];
    includeInstanceIds?: string[];
}

export interface VirtualMachineScaleSetPacketCaptureStorageLocation {
    filePath?: string;
    storageAccountId?: string;
    storagePath: string;
}

export interface VirtualMachineScaleSetPacketCaptureTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VirtualMachineScaleSetPlan {
    name: string;
    product: string;
    publisher: string;
}

export interface VirtualMachineScaleSetRollingUpgradePolicy {
    maxBatchInstancePercent?: number;
    maxUnhealthyInstancePercent?: number;
    maxUnhealthyUpgradedInstancePercent?: number;
    pauseTimeBetweenBatches?: string;
}

export interface VirtualMachineScaleSetSku {
    capacity: number;
    name: string;
    tier: string;
}

export interface VirtualMachineScaleSetStorageProfileDataDisk {
    caching: string;
    createOption: string;
    diskSizeGb: number;
    lun: number;
    managedDiskType: string;
}

export interface VirtualMachineScaleSetStorageProfileImageReference {
    id?: string;
    offer?: string;
    publisher?: string;
    sku?: string;
    version?: string;
}

export interface VirtualMachineScaleSetStorageProfileOsDisk {
    caching: string;
    createOption: string;
    image?: string;
    managedDiskType: string;
    name?: string;
    osType?: string;
    vhdContainers?: string[];
}

export interface VirtualMachineScaleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualMachineStorageDataDisk {
    caching: string;
    createOption: string;
    diskSizeGb: number;
    lun: number;
    managedDiskId: string;
    managedDiskType: string;
    name: string;
    vhdUri?: string;
    writeAcceleratorEnabled?: boolean;
}

export interface VirtualMachineStorageImageReference {
    id?: string;
    offer?: string;
    publisher?: string;
    sku?: string;
    version: string;
}

export interface VirtualMachineStorageOsDisk {
    caching: string;
    createOption: string;
    diskSizeGb: number;
    imageUri?: string;
    managedDiskId: string;
    managedDiskType: string;
    name: string;
    osType: string;
    vhdUri?: string;
    writeAcceleratorEnabled?: boolean;
}

export interface VirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkDdosProtectionPlan {
    enable: boolean;
    id: string;
}

export interface VirtualNetworkDnsServersTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkEncryption {
    enforcement: string;
}

export interface VirtualNetworkGatewayBgpSettings {
    asn?: number;
    peerWeight?: number;
    peeringAddresses?: outputs.VirtualNetworkGatewayBgpSettingsPeeringAddress[];
}

export interface VirtualNetworkGatewayBgpSettingsPeeringAddress {
    apipaAddresses?: string[];
    defaultAddresses: string[];
    ipConfigurationName: string;
    tunnelIpAddresses: string[];
}

export interface VirtualNetworkGatewayConnectionCustomBgpAddresses {
    primary: string;
    secondary?: string;
}

export interface VirtualNetworkGatewayConnectionIpsecPolicy {
    dhGroup: string;
    ikeEncryption: string;
    ikeIntegrity: string;
    ipsecEncryption: string;
    ipsecIntegrity: string;
    pfsGroup: string;
    saDatasize: number;
    saLifetime: number;
}

export interface VirtualNetworkGatewayConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkGatewayConnectionTrafficSelectorPolicy {
    localAddressCidrs: string[];
    remoteAddressCidrs: string[];
}

export interface VirtualNetworkGatewayCustomRoute {
    addressPrefixes?: string[];
}

export interface VirtualNetworkGatewayIpConfiguration {
    name?: string;
    privateIpAddressAllocation?: string;
    publicIpAddressId: string;
    subnetId: string;
}

export interface VirtualNetworkGatewayNatRuleExternalMapping {
    addressSpace: string;
    portRange?: string;
}

export interface VirtualNetworkGatewayNatRuleInternalMapping {
    addressSpace: string;
    portRange?: string;
}

export interface VirtualNetworkGatewayNatRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkGatewayPolicyGroup {
    isDefault?: boolean;
    name: string;
    policyMembers: outputs.VirtualNetworkGatewayPolicyGroupPolicyMember[];
    priority?: number;
}

export interface VirtualNetworkGatewayPolicyGroupPolicyMember {
    name: string;
    type: string;
    value: string;
}

export interface VirtualNetworkGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkGatewayVpnClientConfiguration {
    aadAudience?: string;
    aadIssuer?: string;
    aadTenant?: string;
    addressSpaces: string[];
    ipsecPolicy?: outputs.VirtualNetworkGatewayVpnClientConfigurationIpsecPolicy;
    radiusServerAddress?: string;
    radiusServerSecret?: string;
    radiusServers?: outputs.VirtualNetworkGatewayVpnClientConfigurationRadiusServer[];
    revokedCertificates?: outputs.VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate[];
    rootCertificates?: outputs.VirtualNetworkGatewayVpnClientConfigurationRootCertificate[];
    virtualNetworkGatewayClientConnections?: outputs.VirtualNetworkGatewayVpnClientConfigurationVirtualNetworkGatewayClientConnection[];
    vpnAuthTypes: string[];
    vpnClientProtocols: string[];
}

export interface VirtualNetworkGatewayVpnClientConfigurationIpsecPolicy {
    dhGroup: string;
    ikeEncryption: string;
    ikeIntegrity: string;
    ipsecEncryption: string;
    ipsecIntegrity: string;
    pfsGroup: string;
    saDataSizeInKilobytes: number;
    saLifetimeInSeconds: number;
}

export interface VirtualNetworkGatewayVpnClientConfigurationRadiusServer {
    address: string;
    score: number;
    secret: string;
}

export interface VirtualNetworkGatewayVpnClientConfigurationRevokedCertificate {
    name: string;
    thumbprint: string;
}

export interface VirtualNetworkGatewayVpnClientConfigurationRootCertificate {
    name: string;
    publicCertData: string;
}

export interface VirtualNetworkGatewayVpnClientConfigurationVirtualNetworkGatewayClientConnection {
    addressPrefixes: string[];
    name: string;
    policyGroupNames: string[];
}

export interface VirtualNetworkPeeringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualNetworkSubnet {
    addressPrefixes: string[];
    defaultOutboundAccessEnabled: boolean;
    delegations: outputs.VirtualNetworkSubnetDelegation[];
    id: string;
    name: string;
    privateEndpointNetworkPolicies: string;
    privateLinkServiceNetworkPoliciesEnabled: boolean;
    routeTableId: string;
    securityGroup: string;
    serviceEndpointPolicyIds: string[];
    serviceEndpoints: string[];
}

export interface VirtualNetworkSubnetDelegation {
    name: string;
    serviceDelegations: outputs.VirtualNetworkSubnetDelegationServiceDelegation[];
}

export interface VirtualNetworkSubnetDelegationServiceDelegation {
    actions: string[];
    name: string;
}

export interface VirtualNetworkTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VirtualWanTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VmwareClusterTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VmwareExpressRouteAuthorizationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VmwareNetappVolumeAttachmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface VmwarePrivateCloudCircuit {
    expressRouteId: string;
    expressRoutePrivatePeeringId: string;
    primarySubnetCidr: string;
    secondarySubnetCidr: string;
}

export interface VmwarePrivateCloudManagementCluster {
    hosts: string[];
    id: number;
    size: number;
}

export interface VmwarePrivateCloudTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VoiceServicesCommunicationsGatewayServiceLocation {
    allowedMediaSourceAddressPrefixes?: string[];
    allowedSignalingSourceAddressPrefixes?: string[];
    esrpAddresses?: string[];
    location: string;
    operatorAddresses: string[];
}

export interface VoiceServicesCommunicationsGatewayTestLineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VoiceServicesCommunicationsGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnGatewayBgpSettings {
    asn: number;
    bgpPeeringAddress: string;
    instance0BgpPeeringAddress?: outputs.VpnGatewayBgpSettingsInstance0BgpPeeringAddress;
    instance1BgpPeeringAddress?: outputs.VpnGatewayBgpSettingsInstance1BgpPeeringAddress;
    peerWeight: number;
}

export interface VpnGatewayBgpSettingsInstance0BgpPeeringAddress {
    customIps: string[];
    defaultIps: string[];
    ipConfigurationId: string;
    tunnelIps: string[];
}

export interface VpnGatewayBgpSettingsInstance1BgpPeeringAddress {
    customIps: string[];
    defaultIps: string[];
    ipConfigurationId: string;
    tunnelIps: string[];
}

export interface VpnGatewayConnectionRouting {
    associatedRouteTable: string;
    inboundRouteMapId?: string;
    outboundRouteMapId?: string;
    propagatedRouteTable?: outputs.VpnGatewayConnectionRoutingPropagatedRouteTable;
}

export interface VpnGatewayConnectionRoutingPropagatedRouteTable {
    labels?: string[];
    routeTableIds: string[];
}

export interface VpnGatewayConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnGatewayConnectionTrafficSelectorPolicy {
    localAddressRanges: string[];
    remoteAddressRanges: string[];
}

export interface VpnGatewayConnectionVpnLink {
    bandwidthMbps?: number;
    bgpEnabled?: boolean;
    connectionMode?: string;
    customBgpAddresses?: outputs.VpnGatewayConnectionVpnLinkCustomBgpAddress[];
    egressNatRuleIds?: string[];
    ingressNatRuleIds?: string[];
    ipsecPolicies?: outputs.VpnGatewayConnectionVpnLinkIpsecPolicy[];
    localAzureIpAddressEnabled?: boolean;
    name: string;
    policyBasedTrafficSelectorEnabled?: boolean;
    protocol?: string;
    ratelimitEnabled?: boolean;
    routeWeight?: number;
    sharedKey?: string;
    vpnSiteLinkId: string;
}

export interface VpnGatewayConnectionVpnLinkCustomBgpAddress {
    ipAddress: string;
    ipConfigurationId: string;
}

export interface VpnGatewayConnectionVpnLinkIpsecPolicy {
    dhGroup: string;
    encryptionAlgorithm: string;
    ikeEncryptionAlgorithm: string;
    ikeIntegrityAlgorithm: string;
    integrityAlgorithm: string;
    pfsGroup: string;
    saDataSizeKb: number;
    saLifetimeSec: number;
}

export interface VpnGatewayNatRuleExternalMapping {
    addressSpace: string;
    portRange?: string;
}

export interface VpnGatewayNatRuleInternalMapping {
    addressSpace: string;
    portRange?: string;
}

export interface VpnGatewayNatRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnGatewayTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnServerConfigurationAzureActiveDirectoryAuthentication {
    audience: string;
    issuer: string;
    tenant: string;
}

export interface VpnServerConfigurationClientRevokedCertificate {
    name: string;
    thumbprint: string;
}

export interface VpnServerConfigurationClientRootCertificate {
    name: string;
    publicCertData: string;
}

export interface VpnServerConfigurationIpsecPolicy {
    dhGroup: string;
    ikeEncryption: string;
    ikeIntegrity: string;
    ipsecEncryption: string;
    ipsecIntegrity: string;
    pfsGroup: string;
    saDataSizeKilobytes: number;
    saLifetimeSeconds: number;
}

export interface VpnServerConfigurationPolicyGroupPolicy {
    name: string;
    type: string;
    value: string;
}

export interface VpnServerConfigurationPolicyGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnServerConfigurationRadius {
    clientRootCertificates?: outputs.VpnServerConfigurationRadiusClientRootCertificate[];
    serverRootCertificates?: outputs.VpnServerConfigurationRadiusServerRootCertificate[];
    servers?: outputs.VpnServerConfigurationRadiusServer[];
}

export interface VpnServerConfigurationRadiusClientRootCertificate {
    name: string;
    thumbprint: string;
}

export interface VpnServerConfigurationRadiusServer {
    address: string;
    score: number;
    secret: string;
}

export interface VpnServerConfigurationRadiusServerRootCertificate {
    name: string;
    publicCertData: string;
}

export interface VpnServerConfigurationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpnSiteLink {
    bgp?: outputs.VpnSiteLinkBgp;
    fqdn?: string;
    id: string;
    ipAddress?: string;
    name: string;
    providerName?: string;
    speedInMbps?: number;
}

export interface VpnSiteLinkBgp {
    asn: number;
    peeringAddress: string;
}

export interface VpnSiteO365Policy {
    trafficCategory?: outputs.VpnSiteO365PolicyTrafficCategory;
}

export interface VpnSiteO365PolicyTrafficCategory {
    allowEndpointEnabled?: boolean;
    defaultEndpointEnabled?: boolean;
    optimizeEndpointEnabled?: boolean;
}

export interface VpnSiteTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebAppActiveSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebAppHybridConnectionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebApplicationFirewallPolicyCustomRule {
    action: string;
    enabled?: boolean;
    groupRateLimitBy?: string;
    matchConditions: outputs.WebApplicationFirewallPolicyCustomRuleMatchCondition[];
    name?: string;
    priority: number;
    rateLimitDuration?: string;
    rateLimitThreshold?: number;
    ruleType: string;
}

export interface WebApplicationFirewallPolicyCustomRuleMatchCondition {
    matchValues?: string[];
    matchVariables: outputs.WebApplicationFirewallPolicyCustomRuleMatchConditionMatchVariable[];
    negationCondition?: boolean;
    operator: string;
    transforms?: string[];
}

export interface WebApplicationFirewallPolicyCustomRuleMatchConditionMatchVariable {
    selector?: string;
    variableName: string;
}

export interface WebApplicationFirewallPolicyManagedRules {
    exclusions?: outputs.WebApplicationFirewallPolicyManagedRulesExclusion[];
    managedRuleSets: outputs.WebApplicationFirewallPolicyManagedRulesManagedRuleSet[];
}

export interface WebApplicationFirewallPolicyManagedRulesExclusion {
    excludedRuleSet?: outputs.WebApplicationFirewallPolicyManagedRulesExclusionExcludedRuleSet;
    matchVariable: string;
    selector: string;
    selectorMatchOperator: string;
}

export interface WebApplicationFirewallPolicyManagedRulesExclusionExcludedRuleSet {
    ruleGroups?: outputs.WebApplicationFirewallPolicyManagedRulesExclusionExcludedRuleSetRuleGroup[];
    type?: string;
    version?: string;
}

export interface WebApplicationFirewallPolicyManagedRulesExclusionExcludedRuleSetRuleGroup {
    excludedRules?: string[];
    ruleGroupName: string;
}

export interface WebApplicationFirewallPolicyManagedRulesManagedRuleSet {
    ruleGroupOverrides?: outputs.WebApplicationFirewallPolicyManagedRulesManagedRuleSetRuleGroupOverride[];
    type?: string;
    version: string;
}

export interface WebApplicationFirewallPolicyManagedRulesManagedRuleSetRuleGroupOverride {
    ruleGroupName: string;
    rules?: outputs.WebApplicationFirewallPolicyManagedRulesManagedRuleSetRuleGroupOverrideRule[];
}

export interface WebApplicationFirewallPolicyManagedRulesManagedRuleSetRuleGroupOverrideRule {
    action?: string;
    enabled?: boolean;
    id: string;
}

export interface WebApplicationFirewallPolicyPolicySettings {
    enabled?: boolean;
    fileUploadLimitInMb?: number;
    jsChallengeCookieExpirationInMinutes?: number;
    logScrubbing?: outputs.WebApplicationFirewallPolicyPolicySettingsLogScrubbing;
    maxRequestBodySizeInKb?: number;
    mode?: string;
    requestBodyCheck?: boolean;
    requestBodyEnforcement?: boolean;
    requestBodyInspectLimitInKb?: number;
}

export interface WebApplicationFirewallPolicyPolicySettingsLogScrubbing {
    enabled?: boolean;
    rules?: outputs.WebApplicationFirewallPolicyPolicySettingsLogScrubbingRule[];
}

export interface WebApplicationFirewallPolicyPolicySettingsLogScrubbingRule {
    enabled?: boolean;
    matchVariable: string;
    /**
     * When matchVariable is a collection, operator used to specify which elements in the collection this rule applies to.
     */
    selector?: string;
    selectorMatchOperator?: string;
}

export interface WebApplicationFirewallPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebPubsubCustomCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface WebPubsubCustomDomainTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface WebPubsubHubEventHandler {
    auth?: outputs.WebPubsubHubEventHandlerAuth;
    systemEvents?: string[];
    urlTemplate: string;
    userEventPattern?: string;
}

export interface WebPubsubHubEventHandlerAuth {
    managedIdentityId: string;
}

export interface WebPubsubHubEventListener {
    eventhubName: string;
    eventhubNamespaceName: string;
    systemEventNameFilters?: string[];
    userEventNameFilters?: string[];
}

export interface WebPubsubHubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebPubsubIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WebPubsubLiveTrace {
    connectivityLogsEnabled?: boolean;
    enabled?: boolean;
    httpRequestLogsEnabled?: boolean;
    messagingLogsEnabled?: boolean;
}

export interface WebPubsubNetworkAclPrivateEndpoint {
    allowedRequestTypes?: string[];
    deniedRequestTypes?: string[];
    id: string;
}

export interface WebPubsubNetworkAclPublicNetwork {
    allowedRequestTypes?: string[];
    deniedRequestTypes?: string[];
}

export interface WebPubsubNetworkAclTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebPubsubSharedPrivateLinkResourceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebPubsubTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsFunctionAppAuthSettings {
    activeDirectory?: outputs.WindowsFunctionAppAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.WindowsFunctionAppAuthSettingsFacebook;
    github?: outputs.WindowsFunctionAppAuthSettingsGithub;
    google?: outputs.WindowsFunctionAppAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.WindowsFunctionAppAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.WindowsFunctionAppAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface WindowsFunctionAppAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface WindowsFunctionAppAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface WindowsFunctionAppAuthSettingsV2 {
    activeDirectoryV2?: outputs.WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.WindowsFunctionAppAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.WindowsFunctionAppAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.WindowsFunctionAppAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.WindowsFunctionAppAuthSettingsV2GithubV2;
    googleV2?: outputs.WindowsFunctionAppAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.WindowsFunctionAppAuthSettingsV2Login;
    microsoftV2?: outputs.WindowsFunctionAppAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.WindowsFunctionAppAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface WindowsFunctionAppAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface WindowsFunctionAppAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface WindowsFunctionAppAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface WindowsFunctionAppAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface WindowsFunctionAppAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface WindowsFunctionAppAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface WindowsFunctionAppBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.WindowsFunctionAppBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface WindowsFunctionAppBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface WindowsFunctionAppConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface WindowsFunctionAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsFunctionAppSiteConfig {
    /**
     * If this Windows Web App is Always On enabled. Defaults to `false`.
     */
    alwaysOn: boolean;
    /**
     * The URL of the API definition that describes this Windows Function App.
     */
    apiDefinitionUrl?: string;
    /**
     * The ID of the API Management API for this Windows Function App.
     */
    apiManagementApiId?: string;
    /**
     * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
     */
    appCommandLine?: string;
    /**
     * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
     */
    appScaleLimit: number;
    appServiceLogs?: outputs.WindowsFunctionAppSiteConfigAppServiceLogs;
    /**
     * The Connection String for linking the Windows Function App to Application Insights.
     */
    applicationInsightsConnectionString?: string;
    /**
     * The Instrumentation Key for connecting the Windows Function App to Application Insights.
     */
    applicationInsightsKey?: string;
    applicationStack?: outputs.WindowsFunctionAppSiteConfigApplicationStack;
    cors?: outputs.WindowsFunctionAppSiteConfigCors;
    /**
     * Specifies a list of Default Documents for the Windows Web App.
     */
    defaultDocuments: string[];
    /**
     * Is detailed error logging enabled
     */
    detailedErrorLoggingEnabled: boolean;
    /**
     * The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
     */
    elasticInstanceMinimum: number;
    /**
     * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
     */
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    /**
     * The path to be checked for this function app health.
     */
    healthCheckPath?: string;
    /**
     * Specifies if the http2 protocol should be enabled. Defaults to `false`.
     */
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.WindowsFunctionAppSiteConfigIpRestriction[];
    /**
     * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
     */
    loadBalancingMode?: string;
    /**
     * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
     */
    managedPipelineMode?: string;
    /**
     * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    minimumTlsVersion?: string;
    /**
     * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
     */
    preWarmedInstanceCount: number;
    /**
     * Should Remote Debugging be enabled. Defaults to `false`.
     */
    remoteDebuggingEnabled?: boolean;
    /**
     * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
     */
    remoteDebuggingVersion: string;
    /**
     * Should Functions Runtime Scale Monitoring be enabled.
     */
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.WindowsFunctionAppSiteConfigScmIpRestriction[];
    /**
     * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    scmMinimumTlsVersion?: string;
    /**
     * The SCM Type in use by the Windows Function App.
     */
    scmType: string;
    /**
     * Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
     */
    scmUseMainIpRestriction?: boolean;
    /**
     * Should the Windows Web App use a 32-bit worker.
     */
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    /**
     * Should Web Sockets be enabled. Defaults to `false`.
     */
    websocketsEnabled?: boolean;
    /**
     * The Windows FX Version string.
     */
    windowsFxVersion: string;
    /**
     * The number of Workers for this Windows Function App.
     */
    workerCount: number;
}

export interface WindowsFunctionAppSiteConfigAppServiceLogs {
    /**
     * The amount of disk space to use for logs. Valid values are between `25` and `100`.
     */
    diskQuotaMb?: number;
    /**
     * The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
     */
    retentionPeriodDays?: number;
}

export interface WindowsFunctionAppSiteConfigApplicationStack {
    /**
     * The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0` and `v7.0`
     */
    dotnetVersion?: string;
    /**
     * The version of Java to use. Possible values are `1.8`, `11` and `17`
     */
    javaVersion?: string;
    /**
     * The version of Node to use. Possible values include `12`, `14`, `16` and `18`
     */
    nodeVersion?: string;
    /**
     * The PowerShell Core version to use. Possible values are `7`, `7.2`, and `7.4`
     */
    powershellCoreVersion?: string;
    /**
     * Does the Function App use a custom Application Stack?
     */
    useCustomRuntime: boolean;
    /**
     * Should the DotNet process use an isolated runtime. Defaults to `false`.
     */
    useDotnetIsolatedRuntime: boolean;
}

export interface WindowsFunctionAppSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface WindowsFunctionAppSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsFunctionAppSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsFunctionAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsFunctionAppSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsFunctionAppSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsFunctionAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsFunctionAppSiteCredential {
    name: string;
    password: string;
}

export interface WindowsFunctionAppSlotAuthSettings {
    activeDirectory?: outputs.WindowsFunctionAppSlotAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.WindowsFunctionAppSlotAuthSettingsFacebook;
    github?: outputs.WindowsFunctionAppSlotAuthSettingsGithub;
    google?: outputs.WindowsFunctionAppSlotAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.WindowsFunctionAppSlotAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.WindowsFunctionAppSlotAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface WindowsFunctionAppSlotAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface WindowsFunctionAppSlotAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface WindowsFunctionAppSlotAuthSettingsV2 {
    activeDirectoryV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2GithubV2;
    googleV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.WindowsFunctionAppSlotAuthSettingsV2Login;
    microsoftV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.WindowsFunctionAppSlotAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface WindowsFunctionAppSlotAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface WindowsFunctionAppSlotAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface WindowsFunctionAppSlotAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface WindowsFunctionAppSlotAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface WindowsFunctionAppSlotAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface WindowsFunctionAppSlotAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface WindowsFunctionAppSlotBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.WindowsFunctionAppSlotBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface WindowsFunctionAppSlotBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface WindowsFunctionAppSlotConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface WindowsFunctionAppSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsFunctionAppSlotSiteConfig {
    /**
     * If this Windows Web App is Always On enabled. Defaults to `false`.
     */
    alwaysOn: boolean;
    /**
     * The URL of the API definition that describes this Windows Function App.
     */
    apiDefinitionUrl?: string;
    /**
     * The ID of the API Management API for this Windows Function App.
     */
    apiManagementApiId?: string;
    /**
     * The program and any arguments used to launch this app via the command line. (Example `node myapp.js`).
     */
    appCommandLine?: string;
    /**
     * The number of workers this function app can scale out to. Only applicable to apps on the Consumption and Premium plan.
     */
    appScaleLimit: number;
    appServiceLogs?: outputs.WindowsFunctionAppSlotSiteConfigAppServiceLogs;
    /**
     * The Connection String for linking the Windows Function App to Application Insights.
     */
    applicationInsightsConnectionString?: string;
    /**
     * The Instrumentation Key for connecting the Windows Function App to Application Insights.
     */
    applicationInsightsKey?: string;
    applicationStack?: outputs.WindowsFunctionAppSlotSiteConfigApplicationStack;
    autoSwapSlotName?: string;
    cors?: outputs.WindowsFunctionAppSlotSiteConfigCors;
    /**
     * Specifies a list of Default Documents for the Windows Web App.
     */
    defaultDocuments: string[];
    /**
     * Is detailed error logging enabled
     */
    detailedErrorLoggingEnabled: boolean;
    /**
     * The number of minimum instances for this Windows Function App. Only affects apps on Elastic Premium plans.
     */
    elasticInstanceMinimum: number;
    /**
     * State of FTP / FTPS service for this function app. Possible values include: `AllAllowed`, `FtpsOnly` and `Disabled`. Defaults to `Disabled`.
     */
    ftpsState?: string;
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Defaults to `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    /**
     * The path to be checked for this function app health.
     */
    healthCheckPath?: string;
    /**
     * Specifies if the http2 protocol should be enabled. Defaults to `false`.
     */
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.WindowsFunctionAppSlotSiteConfigIpRestriction[];
    /**
     * The Site load balancing mode. Possible values include: `WeightedRoundRobin`, `LeastRequests`, `LeastResponseTime`, `WeightedTotalTraffic`, `RequestHash`, `PerSiteRoundRobin`. Defaults to `LeastRequests` if omitted.
     */
    loadBalancingMode?: string;
    /**
     * The Managed Pipeline mode. Possible values include: `Integrated`, `Classic`. Defaults to `Integrated`.
     */
    managedPipelineMode?: string;
    /**
     * The configures the minimum version of TLS required for SSL requests. Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    minimumTlsVersion?: string;
    /**
     * The number of pre-warmed instances for this function app. Only affects apps on an Elastic Premium plan.
     */
    preWarmedInstanceCount: number;
    /**
     * Should Remote Debugging be enabled. Defaults to `false`.
     */
    remoteDebuggingEnabled?: boolean;
    /**
     * The Remote Debugging Version. Possible values include `VS2017`, `VS2019`, and `VS2022`
     */
    remoteDebuggingVersion: string;
    /**
     * Should Functions Runtime Scale Monitoring be enabled.
     */
    runtimeScaleMonitoringEnabled?: boolean;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.WindowsFunctionAppSlotSiteConfigScmIpRestriction[];
    /**
     * Configures the minimum version of TLS required for SSL requests to the SCM site Possible values include: `1.0`, `1.1`, and  `1.2`. Defaults to `1.2`.
     */
    scmMinimumTlsVersion?: string;
    /**
     * The SCM Type in use by the Windows Function App.
     */
    scmType: string;
    /**
     * Should the Windows Function App `ip_restriction` configuration be used for the SCM also.
     */
    scmUseMainIpRestriction?: boolean;
    /**
     * Should the Windows Function App use a 32-bit worker.
     */
    use32BitWorker?: boolean;
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    /**
     * Should Web Sockets be enabled. Defaults to `false`.
     */
    websocketsEnabled?: boolean;
    /**
     * The Windows FX Version string.
     */
    windowsFxVersion: string;
    /**
     * The number of Workers for this Windows Function App.
     */
    workerCount: number;
}

export interface WindowsFunctionAppSlotSiteConfigAppServiceLogs {
    /**
     * The amount of disk space to use for logs. Valid values are between `25` and `100`.
     */
    diskQuotaMb?: number;
    /**
     * The retention period for logs in days. Valid values are between `0` and `99999`. Defaults to `0` (never delete).
     */
    retentionPeriodDays?: number;
}

export interface WindowsFunctionAppSlotSiteConfigApplicationStack {
    /**
     * The version of .Net. Possible values are `v3.0`, `v4.0`, `v6.0` and `v7.0`
     */
    dotnetVersion?: string;
    /**
     * The version of Java to use. Possible values are `1.8`, `11` and `17`
     */
    javaVersion?: string;
    /**
     * The version of Node to use. Possible values include `12`, `14`, `16` and `18`
     */
    nodeVersion?: string;
    /**
     * The PowerShell Core version to use. Possible values are `7`, `7.2`, and `7.4`
     */
    powershellCoreVersion?: string;
    /**
     * Does the Function App use a custom Application Stack?
     */
    useCustomRuntime: boolean;
    /**
     * Should the DotNet process use an isolated runtime. Defaults to `false`.
     */
    useDotnetIsolatedRuntime: boolean;
}

export interface WindowsFunctionAppSlotSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface WindowsFunctionAppSlotSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsFunctionAppSlotSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsFunctionAppSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsFunctionAppSlotSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsFunctionAppSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsFunctionAppSlotSiteCredential {
    name: string;
    password: string;
}

export interface WindowsFunctionAppSlotStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface WindowsFunctionAppSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsFunctionAppStickySettings {
    appSettingNames?: string[];
    connectionStringNames?: string[];
}

export interface WindowsFunctionAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface WindowsFunctionAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsVirtualMachineAdditionalCapabilities {
    hibernationEnabled?: boolean;
    ultraSsdEnabled?: boolean;
}

export interface WindowsVirtualMachineAdditionalUnattendContent {
    content: string;
    setting: string;
}

export interface WindowsVirtualMachineBootDiagnostics {
    storageAccountUri?: string;
}

export interface WindowsVirtualMachineGalleryApplication {
    automaticUpgradeEnabled?: boolean;
    configurationBlobUri?: string;
    order?: number;
    tag?: string;
    treatFailureAsDeploymentFailureEnabled?: boolean;
    versionId: string;
}

export interface WindowsVirtualMachineIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsVirtualMachineOsDisk {
    caching: string;
    diffDiskSettings?: outputs.WindowsVirtualMachineOsDiskDiffDiskSettings;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    name: string;
    secureVmDiskEncryptionSetId?: string;
    securityEncryptionType?: string;
    storageAccountType: string;
    writeAcceleratorEnabled?: boolean;
}

export interface WindowsVirtualMachineOsDiskDiffDiskSettings {
    option: string;
    placement?: string;
}

export interface WindowsVirtualMachineOsImageNotification {
    timeout?: string;
}

export interface WindowsVirtualMachinePlan {
    name: string;
    product: string;
    publisher: string;
}

export interface WindowsVirtualMachineScaleSetAdditionalCapabilities {
    ultraSsdEnabled?: boolean;
}

export interface WindowsVirtualMachineScaleSetAdditionalUnattendContent {
    content: string;
    setting: string;
}

export interface WindowsVirtualMachineScaleSetAutomaticInstanceRepair {
    action: string;
    enabled: boolean;
    gracePeriod: string;
}

export interface WindowsVirtualMachineScaleSetAutomaticOsUpgradePolicy {
    disableAutomaticRollback: boolean;
    enableAutomaticOsUpgrade: boolean;
}

export interface WindowsVirtualMachineScaleSetBootDiagnostics {
    storageAccountUri?: string;
}

export interface WindowsVirtualMachineScaleSetDataDisk {
    caching: string;
    createOption?: string;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    lun: number;
    name?: string;
    storageAccountType: string;
    ultraSsdDiskIopsReadWrite: number;
    ultraSsdDiskMbpsReadWrite: number;
    writeAcceleratorEnabled?: boolean;
}

export interface WindowsVirtualMachineScaleSetExtension {
    autoUpgradeMinorVersion?: boolean;
    automaticUpgradeEnabled?: boolean;
    forceUpdateTag?: string;
    name: string;
    protectedSettings?: string;
    protectedSettingsFromKeyVault?: outputs.WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: string;
    type: string;
    typeHandlerVersion: string;
}

export interface WindowsVirtualMachineScaleSetExtensionProtectedSettingsFromKeyVault {
    secretUrl: string;
    sourceVaultId: string;
}

export interface WindowsVirtualMachineScaleSetGalleryApplication {
    configurationBlobUri?: string;
    order?: number;
    tag?: string;
    versionId: string;
}

export interface WindowsVirtualMachineScaleSetIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsVirtualMachineScaleSetNetworkInterface {
    dnsServers?: string[];
    enableAcceleratedNetworking?: boolean;
    enableIpForwarding?: boolean;
    ipConfigurations: outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration[];
    name: string;
    networkSecurityGroupId?: string;
    primary?: boolean;
}

export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfiguration {
    applicationGatewayBackendAddressPoolIds?: string[];
    applicationSecurityGroupIds?: string[];
    loadBalancerBackendAddressPoolIds?: string[];
    loadBalancerInboundNatRulesIds?: string[];
    name: string;
    primary?: boolean;
    publicIpAddresses?: outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress[];
    subnetId?: string;
    version?: string;
}

export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddress {
    domainNameLabel?: string;
    idleTimeoutInMinutes: number;
    ipTags?: outputs.WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag[];
    name: string;
    publicIpPrefixId?: string;
    version?: string;
}

export interface WindowsVirtualMachineScaleSetNetworkInterfaceIpConfigurationPublicIpAddressIpTag {
    tag: string;
    type: string;
}

export interface WindowsVirtualMachineScaleSetOsDisk {
    caching: string;
    diffDiskSettings?: outputs.WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings;
    diskEncryptionSetId?: string;
    diskSizeGb: number;
    secureVmDiskEncryptionSetId?: string;
    securityEncryptionType?: string;
    storageAccountType: string;
    writeAcceleratorEnabled?: boolean;
}

export interface WindowsVirtualMachineScaleSetOsDiskDiffDiskSettings {
    option: string;
    placement?: string;
}

export interface WindowsVirtualMachineScaleSetPlan {
    name: string;
    product: string;
    publisher: string;
}

export interface WindowsVirtualMachineScaleSetRollingUpgradePolicy {
    crossZoneUpgradesEnabled?: boolean;
    maxBatchInstancePercent: number;
    maxUnhealthyInstancePercent: number;
    maxUnhealthyUpgradedInstancePercent: number;
    maximumSurgeInstancesEnabled?: boolean;
    pauseTimeBetweenBatches: string;
    prioritizeUnhealthyInstancesEnabled?: boolean;
}

export interface WindowsVirtualMachineScaleSetScaleIn {
    forceDeletionEnabled?: boolean;
    rule?: string;
}

export interface WindowsVirtualMachineScaleSetSecret {
    certificates: outputs.WindowsVirtualMachineScaleSetSecretCertificate[];
    keyVaultId: string;
}

export interface WindowsVirtualMachineScaleSetSecretCertificate {
    store: string;
    url: string;
}

export interface WindowsVirtualMachineScaleSetSourceImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WindowsVirtualMachineScaleSetSpotRestore {
    enabled?: boolean;
    timeout?: string;
}

export interface WindowsVirtualMachineScaleSetTerminationNotification {
    enabled: boolean;
    timeout?: string;
}

export interface WindowsVirtualMachineScaleSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsVirtualMachineScaleSetWinrmListener {
    certificateUrl?: string;
    protocol: string;
}

export interface WindowsVirtualMachineSecret {
    certificates: outputs.WindowsVirtualMachineSecretCertificate[];
    keyVaultId: string;
}

export interface WindowsVirtualMachineSecretCertificate {
    store: string;
    url: string;
}

export interface WindowsVirtualMachineSourceImageReference {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WindowsVirtualMachineTerminationNotification {
    enabled: boolean;
    timeout?: string;
}

export interface WindowsVirtualMachineTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsVirtualMachineWinrmListener {
    certificateUrl?: string;
    protocol: string;
}

export interface WindowsWebAppAuthSettings {
    activeDirectory?: outputs.WindowsWebAppAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.WindowsWebAppAuthSettingsFacebook;
    github?: outputs.WindowsWebAppAuthSettingsGithub;
    google?: outputs.WindowsWebAppAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.WindowsWebAppAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.WindowsWebAppAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface WindowsWebAppAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface WindowsWebAppAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface WindowsWebAppAuthSettingsV2 {
    activeDirectoryV2?: outputs.WindowsWebAppAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.WindowsWebAppAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.WindowsWebAppAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.WindowsWebAppAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.WindowsWebAppAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.WindowsWebAppAuthSettingsV2GithubV2;
    googleV2?: outputs.WindowsWebAppAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.WindowsWebAppAuthSettingsV2Login;
    microsoftV2?: outputs.WindowsWebAppAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.WindowsWebAppAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface WindowsWebAppAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface WindowsWebAppAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface WindowsWebAppAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface WindowsWebAppAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface WindowsWebAppAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface WindowsWebAppAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface WindowsWebAppBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.WindowsWebAppBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface WindowsWebAppBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface WindowsWebAppConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface WindowsWebAppIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsWebAppLogs {
    applicationLogs?: outputs.WindowsWebAppLogsApplicationLogs;
    detailedErrorMessages?: boolean;
    failedRequestTracing?: boolean;
    httpLogs?: outputs.WindowsWebAppLogsHttpLogs;
}

export interface WindowsWebAppLogsApplicationLogs {
    azureBlobStorage?: outputs.WindowsWebAppLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel: string;
}

export interface WindowsWebAppLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface WindowsWebAppLogsHttpLogs {
    azureBlobStorage?: outputs.WindowsWebAppLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.WindowsWebAppLogsHttpLogsFileSystem;
}

export interface WindowsWebAppLogsHttpLogsAzureBlobStorage {
    retentionInDays?: number;
    sasUrl: string;
}

export interface WindowsWebAppLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface WindowsWebAppSiteConfig {
    alwaysOn?: boolean;
    apiDefinitionUrl?: string;
    apiManagementApiId?: string;
    appCommandLine?: string;
    applicationStack?: outputs.WindowsWebAppSiteConfigApplicationStack;
    autoHealSetting?: outputs.WindowsWebAppSiteConfigAutoHealSetting;
    containerRegistryManagedIdentityClientId?: string;
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.WindowsWebAppSiteConfigCors;
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState?: string;
    handlerMappings?: outputs.WindowsWebAppSiteConfigHandlerMapping[];
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.WindowsWebAppSiteConfigIpRestriction[];
    linuxFxVersion: string;
    loadBalancingMode?: string;
    localMysqlEnabled?: boolean;
    managedPipelineMode?: string;
    minimumTlsVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.WindowsWebAppSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion?: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorker?: boolean;
    virtualApplications?: outputs.WindowsWebAppSiteConfigVirtualApplication[];
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    websocketsEnabled?: boolean;
    windowsFxVersion: string;
    workerCount: number;
}

export interface WindowsWebAppSiteConfigApplicationStack {
    currentStack: string;
    dockerImageName?: string;
    dockerRegistryPassword?: string;
    dockerRegistryUrl?: string;
    dockerRegistryUsername?: string;
    /**
     * The version of DotNetCore to use.
     */
    dotnetCoreVersion?: string;
    dotnetVersion: string;
    /**
     * @deprecated Deprecated
     */
    javaContainer?: string;
    /**
     * @deprecated Deprecated
     */
    javaContainerVersion?: string;
    /**
     * Should the application use the embedded web server for the version of Java in use.
     */
    javaEmbeddedServerEnabled: boolean;
    javaVersion?: string;
    nodeVersion?: string;
    phpVersion: string;
    python?: boolean;
    tomcatVersion?: string;
}

export interface WindowsWebAppSiteConfigAutoHealSetting {
    action: outputs.WindowsWebAppSiteConfigAutoHealSettingAction;
    trigger: outputs.WindowsWebAppSiteConfigAutoHealSettingTrigger;
}

export interface WindowsWebAppSiteConfigAutoHealSettingAction {
    actionType: string;
    customAction?: outputs.WindowsWebAppSiteConfigAutoHealSettingActionCustomAction;
    minimumProcessExecutionTime: string;
}

export interface WindowsWebAppSiteConfigAutoHealSettingActionCustomAction {
    executable: string;
    parameters?: string;
}

export interface WindowsWebAppSiteConfigAutoHealSettingTrigger {
    privateMemoryKb?: number;
    requests?: outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerRequests;
    slowRequest?: outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest;
    slowRequestWithPaths?: outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    statusCodes?: outputs.WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface WindowsWebAppSiteConfigAutoHealSettingTriggerRequests {
    count: number;
    interval: string;
}

export interface WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface WindowsWebAppSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path?: string;
    timeTaken: string;
}

export interface WindowsWebAppSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path?: string;
    statusCodeRange: string;
    subStatus?: number;
    win32StatusCode?: number;
}

export interface WindowsWebAppSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface WindowsWebAppSiteConfigHandlerMapping {
    arguments?: string;
    extension: string;
    scriptProcessorPath: string;
}

export interface WindowsWebAppSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsWebAppSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsWebAppSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsWebAppSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsWebAppSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsWebAppSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsWebAppSiteConfigVirtualApplication {
    physicalPath: string;
    preload: boolean;
    virtualDirectories?: outputs.WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory[];
    virtualPath: string;
}

export interface WindowsWebAppSiteConfigVirtualApplicationVirtualDirectory {
    physicalPath?: string;
    virtualPath?: string;
}

export interface WindowsWebAppSiteCredential {
    name: string;
    password: string;
}

export interface WindowsWebAppSlotAuthSettings {
    activeDirectory?: outputs.WindowsWebAppSlotAuthSettingsActiveDirectory;
    /**
     * Specifies a map of Login Parameters to send to the OpenID Connect authorization endpoint when a user logs in.
     */
    additionalLoginParameters?: {[key: string]: string};
    /**
     * Specifies a list of External URLs that can be redirected to as part of logging in or logging out of the Windows Web App.
     */
    allowedExternalRedirectUrls: string[];
    /**
     * The default authentication provider to use when multiple providers are configured. Possible values include: `AzureActiveDirectory`, `Facebook`, `Google`, `MicrosoftAccount`, `Twitter`, `Github`.
     */
    defaultProvider: string;
    /**
     * Should the Authentication / Authorization feature be enabled?
     */
    enabled: boolean;
    facebook?: outputs.WindowsWebAppSlotAuthSettingsFacebook;
    github?: outputs.WindowsWebAppSlotAuthSettingsGithub;
    google?: outputs.WindowsWebAppSlotAuthSettingsGoogle;
    /**
     * The OpenID Connect Issuer URI that represents the entity which issues access tokens.
     */
    issuer?: string;
    microsoft?: outputs.WindowsWebAppSlotAuthSettingsMicrosoft;
    /**
     * The RuntimeVersion of the Authentication / Authorization feature in use.
     */
    runtimeVersion: string;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionHours?: number;
    /**
     * Should the Windows Web App durably store platform-specific security tokens that are obtained during login flows? Defaults to `false`.
     */
    tokenStoreEnabled?: boolean;
    twitter?: outputs.WindowsWebAppSlotAuthSettingsTwitter;
    /**
     * The action to take when an unauthenticated client attempts to access the app. Possible values include: `RedirectToLoginPage`, `AllowAnonymous`.
     */
    unauthenticatedClientAction: string;
}

export interface WindowsWebAppSlotAuthSettingsActiveDirectory {
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The Client Secret for the Client ID. Cannot be used with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The App Setting name that contains the client secret of the Client. Cannot be used with `client_secret`.
     */
    clientSecretSettingName?: string;
}

export interface WindowsWebAppSlotAuthSettingsFacebook {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The App Secret of the Facebook app used for Facebook Login. Cannot be specified with `app_secret_setting_name`.
     */
    appSecret?: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login. Cannot be specified with `app_secret`.
     */
    appSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes to be requested as part of Facebook Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsGithub {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The Client Secret of the GitHub app used for GitHub Login. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsGoogle {
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The client secret associated with the Google web application.  Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of Google Sign-In authentication. If not specified, "openid", "profile", and "email" are used as default scopes.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsMicrosoft {
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret_setting_name`.
     */
    clientSecret?: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication. Cannot be specified with `client_secret`.
     */
    clientSecretSettingName?: string;
    /**
     * The list of OAuth 2.0 scopes that will be requested as part of Microsoft Account authentication. If not specified, `wl.basic` is used as the default scope.
     */
    oauthScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsTwitter {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret_setting_name`.
     */
    consumerSecret?: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in. Cannot be specified with `consumer_secret`.
     */
    consumerSecretSettingName?: string;
}

export interface WindowsWebAppSlotAuthSettingsV2 {
    activeDirectoryV2?: outputs.WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2;
    appleV2?: outputs.WindowsWebAppSlotAuthSettingsV2AppleV2;
    /**
     * Should the AuthV2 Settings be enabled. Defaults to `false`
     */
    authEnabled?: boolean;
    azureStaticWebAppV2?: outputs.WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2;
    /**
     * The path to the App Auth settings. **Note:** Relative Paths are evaluated from the Site Root directory.
     */
    configFilePath?: string;
    customOidcV2s?: outputs.WindowsWebAppSlotAuthSettingsV2CustomOidcV2[];
    /**
     * The Default Authentication Provider to use when the `unauthenticated_action` is set to `RedirectToLoginPage`. Possible values include: `apple`, `azureactivedirectory`, `facebook`, `github`, `google`, `twitter` and the `name` of your `custom_oidc_v2` provider.
     */
    defaultProvider?: string;
    /**
     * The paths which should be excluded from the `unauthenticated_action` when it is set to `RedirectToLoginPage`.
     */
    excludedPaths?: string[];
    facebookV2?: outputs.WindowsWebAppSlotAuthSettingsV2FacebookV2;
    /**
     * The convention used to determine the url of the request made. Possible values include `ForwardProxyConventionNoProxy`, `ForwardProxyConventionStandard`, `ForwardProxyConventionCustom`. Defaults to `ForwardProxyConventionNoProxy`
     */
    forwardProxyConvention?: string;
    /**
     * The name of the header containing the host of the request.
     */
    forwardProxyCustomHostHeaderName?: string;
    /**
     * The name of the header containing the scheme of the request.
     */
    forwardProxyCustomSchemeHeaderName?: string;
    githubV2?: outputs.WindowsWebAppSlotAuthSettingsV2GithubV2;
    googleV2?: outputs.WindowsWebAppSlotAuthSettingsV2GoogleV2;
    /**
     * The prefix that should precede all the authentication and authorisation paths. Defaults to `/.auth`
     */
    httpRouteApiPrefix?: string;
    login: outputs.WindowsWebAppSlotAuthSettingsV2Login;
    microsoftV2?: outputs.WindowsWebAppSlotAuthSettingsV2MicrosoftV2;
    /**
     * Should the authentication flow be used for all requests.
     */
    requireAuthentication?: boolean;
    /**
     * Should HTTPS be required on connections? Defaults to true.
     */
    requireHttps?: boolean;
    /**
     * The Runtime Version of the Authentication and Authorisation feature of this App. Defaults to `~1`
     */
    runtimeVersion?: string;
    twitterV2?: outputs.WindowsWebAppSlotAuthSettingsV2TwitterV2;
    /**
     * The action to take for requests made without authentication. Possible values include `RedirectToLoginPage`, `AllowAnonymous`, `Return401`, and `Return403`. Defaults to `RedirectToLoginPage`.
     */
    unauthenticatedAction?: string;
}

export interface WindowsWebAppSlotAuthSettingsV2ActiveDirectoryV2 {
    /**
     * The list of allowed Applications for the Default Authorisation Policy.
     */
    allowedApplications?: string[];
    /**
     * Specifies a list of Allowed audience values to consider when validating JWTs issued by Azure Active Directory.
     */
    allowedAudiences?: string[];
    /**
     * The list of allowed Group Names for the Default Authorisation Policy.
     */
    allowedGroups?: string[];
    /**
     * The list of allowed Identities for the Default Authorisation Policy.
     */
    allowedIdentities?: string[];
    /**
     * The ID of the Client to use to authenticate with Azure Active Directory.
     */
    clientId: string;
    /**
     * The thumbprint of the certificate used for signing purposes.
     */
    clientSecretCertificateThumbprint?: string;
    /**
     * The App Setting name that contains the client secret of the Client.
     */
    clientSecretSettingName?: string;
    /**
     * A list of Allowed Client Applications in the JWT Claim.
     */
    jwtAllowedClientApplications?: string[];
    /**
     * A list of Allowed Groups in the JWT Claim.
     */
    jwtAllowedGroups?: string[];
    /**
     * A map of key-value pairs to send to the Authorisation Endpoint when a user logs in.
     */
    loginParameters?: {[key: string]: string};
    /**
     * The Azure Tenant Endpoint for the Authenticating Tenant. e.g. `https://login.microsoftonline.com/v2.0/{tenant-guid}/`.
     */
    tenantAuthEndpoint: string;
    /**
     * Should the www-authenticate provider should be omitted from the request? Defaults to `false`
     */
    wwwAuthenticationDisabled?: boolean;
}

export interface WindowsWebAppSlotAuthSettingsV2AppleV2 {
    /**
     * The OpenID Connect Client ID for the Apple web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Apple Login.
     */
    clientSecretSettingName: string;
    loginScopes: string[];
}

export interface WindowsWebAppSlotAuthSettingsV2AzureStaticWebAppV2 {
    /**
     * The ID of the Client to use to authenticate with Azure Static Web App Authentication.
     */
    clientId: string;
}

export interface WindowsWebAppSlotAuthSettingsV2CustomOidcV2 {
    /**
     * The endpoint to make the Authorisation Request.
     */
    authorisationEndpoint: string;
    /**
     * The endpoint that provides the keys necessary to validate the token.
     */
    certificationUri: string;
    /**
     * The Client Credential Method used. Currently the only supported value is `ClientSecretPost`.
     */
    clientCredentialMethod: string;
    /**
     * The ID of the Client to use to authenticate with this Custom OIDC.
     */
    clientId: string;
    /**
     * The App Setting name that contains the secret for this Custom OIDC Client.
     */
    clientSecretSettingName: string;
    /**
     * The endpoint that issued the Token.
     */
    issuerEndpoint: string;
    /**
     * The name of the Custom OIDC Authentication Provider.
     */
    name: string;
    /**
     * The name of the claim that contains the users name.
     */
    nameClaimType?: string;
    /**
     * The endpoint that contains all the configuration endpoints for this Custom OIDC provider.
     */
    openidConfigurationEndpoint: string;
    /**
     * The list of the scopes that should be requested while authenticating.
     */
    scopes?: string[];
    /**
     * The endpoint used to request a Token.
     */
    tokenEndpoint: string;
}

export interface WindowsWebAppSlotAuthSettingsV2FacebookV2 {
    /**
     * The App ID of the Facebook app used for login.
     */
    appId: string;
    /**
     * The app setting name that contains the `app_secret` value used for Facebook Login.
     */
    appSecretSettingName: string;
    /**
     * The version of the Facebook API to be used while logging in.
     */
    graphApiVersion: string;
    /**
     * Specifies a list of scopes to be requested as part of Facebook Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsV2GithubV2 {
    /**
     * The ID of the GitHub app used for login.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for GitHub Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of OAuth 2.0 scopes that will be requested as part of GitHub Login authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsV2GoogleV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Google Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OpenID Connect Client ID for the Google web application.
     */
    clientId: string;
    /**
     * The app setting name that contains the `client_secret` value used for Google Login.
     */
    clientSecretSettingName: string;
    /**
     * Specifies a list of Login scopes that will be requested as part of Google Sign-In authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsV2Login {
    /**
     * External URLs that can be redirected to as part of logging in or logging out of the app. This is an advanced setting typically only needed by Windows Store application backends. **Note:** URLs within the current domain are always implicitly allowed.
     */
    allowedExternalRedirectUrls?: string[];
    /**
     * The method by which cookies expire. Possible values include: `FixedTime`, and `IdentityProviderDerived`. Defaults to `FixedTime`.
     */
    cookieExpirationConvention?: string;
    /**
     * The time after the request is made when the session cookie should expire. Defaults to `08:00:00`.
     */
    cookieExpirationTime?: string;
    /**
     * The endpoint to which logout requests should be made.
     */
    logoutEndpoint?: string;
    /**
     * The time after the request is made when the nonce should expire. Defaults to `00:05:00`.
     */
    nonceExpirationTime?: string;
    /**
     * Should the fragments from the request be preserved after the login request is made. Defaults to `false`.
     */
    preserveUrlFragmentsForLogins?: boolean;
    /**
     * The number of hours after session token expiration that a session token can be used to call the token refresh API. Defaults to `72` hours.
     */
    tokenRefreshExtensionTime?: number;
    /**
     * Should the Token Store configuration Enabled. Defaults to `false`
     */
    tokenStoreEnabled?: boolean;
    /**
     * The directory path in the App Filesystem in which the tokens will be stored.
     */
    tokenStorePath?: string;
    /**
     * The name of the app setting which contains the SAS URL of the blob storage containing the tokens.
     */
    tokenStoreSasSettingName?: string;
    /**
     * Should the nonce be validated while completing the login flow. Defaults to `true`.
     */
    validateNonce?: boolean;
}

export interface WindowsWebAppSlotAuthSettingsV2MicrosoftV2 {
    /**
     * Specifies a list of Allowed Audiences that will be requested as part of Microsoft Sign-In authentication.
     */
    allowedAudiences?: string[];
    /**
     * The OAuth 2.0 client ID that was created for the app used for authentication.
     */
    clientId: string;
    /**
     * The app setting name containing the OAuth 2.0 client secret that was created for the app used for authentication.
     */
    clientSecretSettingName: string;
    /**
     * The list of Login scopes that will be requested as part of Microsoft Account authentication.
     */
    loginScopes?: string[];
}

export interface WindowsWebAppSlotAuthSettingsV2TwitterV2 {
    /**
     * The OAuth 1.0a consumer key of the Twitter application used for sign-in.
     */
    consumerKey: string;
    /**
     * The app setting name that contains the OAuth 1.0a consumer secret of the Twitter application used for sign-in.
     */
    consumerSecretSettingName: string;
}

export interface WindowsWebAppSlotBackup {
    /**
     * Should this backup job be enabled?
     */
    enabled?: boolean;
    /**
     * The name which should be used for this Backup.
     */
    name: string;
    schedule: outputs.WindowsWebAppSlotBackupSchedule;
    /**
     * The SAS URL to the container.
     */
    storageAccountUrl: string;
}

export interface WindowsWebAppSlotBackupSchedule {
    /**
     * How often the backup should be executed (e.g. for weekly backup, this should be set to `7` and `frequency_unit` should be set to `Day`).
     */
    frequencyInterval: number;
    /**
     * The unit of time for how often the backup should take place. Possible values include: `Day` and `Hour`.
     */
    frequencyUnit: string;
    /**
     * Should the service keep at least one backup, regardless of age of backup. Defaults to `false`.
     */
    keepAtLeastOneBackup?: boolean;
    /**
     * The time the backup was last attempted.
     */
    lastExecutionTime: string;
    /**
     * After how many days backups should be deleted.
     */
    retentionPeriodDays?: number;
    /**
     * When the schedule should start working in RFC-3339 format.
     */
    startTime: string;
}

export interface WindowsWebAppSlotConnectionString {
    /**
     * The name which should be used for this Connection.
     */
    name: string;
    /**
     * Type of database. Possible values include: `MySQL`, `SQLServer`, `SQLAzure`, `Custom`, `NotificationHub`, `ServiceBus`, `EventHub`, `APIHub`, `DocDb`, `RedisCache`, and `PostgreSQL`.
     */
    type: string;
    /**
     * The connection string value.
     */
    value: string;
}

export interface WindowsWebAppSlotIdentity {
    identityIds?: string[];
    principalId: string;
    tenantId: string;
    type: string;
}

export interface WindowsWebAppSlotLogs {
    applicationLogs?: outputs.WindowsWebAppSlotLogsApplicationLogs;
    detailedErrorMessages?: boolean;
    failedRequestTracing?: boolean;
    httpLogs?: outputs.WindowsWebAppSlotLogsHttpLogs;
}

export interface WindowsWebAppSlotLogsApplicationLogs {
    azureBlobStorage?: outputs.WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage;
    fileSystemLevel: string;
}

export interface WindowsWebAppSlotLogsApplicationLogsAzureBlobStorage {
    level: string;
    retentionInDays: number;
    sasUrl: string;
}

export interface WindowsWebAppSlotLogsHttpLogs {
    azureBlobStorage?: outputs.WindowsWebAppSlotLogsHttpLogsAzureBlobStorage;
    fileSystem?: outputs.WindowsWebAppSlotLogsHttpLogsFileSystem;
}

export interface WindowsWebAppSlotLogsHttpLogsAzureBlobStorage {
    retentionInDays?: number;
    sasUrl: string;
}

export interface WindowsWebAppSlotLogsHttpLogsFileSystem {
    retentionInDays: number;
    retentionInMb: number;
}

export interface WindowsWebAppSlotSiteConfig {
    alwaysOn?: boolean;
    apiDefinitionUrl?: string;
    apiManagementApiId?: string;
    appCommandLine?: string;
    applicationStack?: outputs.WindowsWebAppSlotSiteConfigApplicationStack;
    autoHealSetting?: outputs.WindowsWebAppSlotSiteConfigAutoHealSetting;
    autoSwapSlotName?: string;
    containerRegistryManagedIdentityClientId?: string;
    containerRegistryUseManagedIdentity?: boolean;
    cors?: outputs.WindowsWebAppSlotSiteConfigCors;
    defaultDocuments: string[];
    detailedErrorLoggingEnabled: boolean;
    ftpsState?: string;
    handlerMappings?: outputs.WindowsWebAppSlotSiteConfigHandlerMapping[];
    /**
     * The amount of time in minutes that a node is unhealthy before being removed from the load balancer. Possible values are between `2` and `10`. Only valid in conjunction with `health_check_path`
     */
    healthCheckEvictionTimeInMin?: number;
    healthCheckPath?: string;
    http2Enabled?: boolean;
    ipRestrictionDefaultAction?: string;
    ipRestrictions?: outputs.WindowsWebAppSlotSiteConfigIpRestriction[];
    loadBalancingMode?: string;
    localMysqlEnabled?: boolean;
    managedPipelineMode?: string;
    minimumTlsVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion: string;
    scmIpRestrictionDefaultAction?: string;
    scmIpRestrictions?: outputs.WindowsWebAppSlotSiteConfigScmIpRestriction[];
    scmMinimumTlsVersion?: string;
    scmType: string;
    scmUseMainIpRestriction?: boolean;
    use32BitWorker: boolean;
    virtualApplications?: outputs.WindowsWebAppSlotSiteConfigVirtualApplication[];
    /**
     * Should all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied? Defaults to `false`.
     */
    vnetRouteAllEnabled?: boolean;
    websocketsEnabled?: boolean;
    windowsFxVersion: string;
    workerCount: number;
}

export interface WindowsWebAppSlotSiteConfigApplicationStack {
    currentStack: string;
    dockerImageName?: string;
    dockerRegistryPassword?: string;
    dockerRegistryUrl?: string;
    dockerRegistryUsername?: string;
    /**
     * The version of DotNetCore to use.
     */
    dotnetCoreVersion?: string;
    dotnetVersion: string;
    /**
     * @deprecated Deprecated
     */
    javaContainer?: string;
    /**
     * @deprecated Deprecated
     */
    javaContainerVersion?: string;
    /**
     * Should the application use the embedded web server for the version of Java in use.
     */
    javaEmbeddedServerEnabled: boolean;
    javaVersion?: string;
    nodeVersion?: string;
    phpVersion: string;
    python?: boolean;
    tomcatVersion?: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSetting {
    action: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingAction;
    trigger: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTrigger;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingAction {
    actionType: string;
    customAction?: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction;
    minimumProcessExecutionTime: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingActionCustomAction {
    executable: string;
    parameters?: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingTrigger {
    privateMemoryKb?: number;
    requests?: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests;
    slowRequest?: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest;
    slowRequestWithPaths?: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPath[];
    statusCodes?: outputs.WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode[];
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerRequests {
    count: number;
    interval: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequest {
    count: number;
    interval: string;
    timeTaken: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerSlowRequestWithPath {
    count: number;
    interval: string;
    path?: string;
    timeTaken: string;
}

export interface WindowsWebAppSlotSiteConfigAutoHealSettingTriggerStatusCode {
    count: number;
    interval: string;
    path?: string;
    statusCodeRange: string;
    subStatus?: number;
    win32StatusCode?: number;
}

export interface WindowsWebAppSlotSiteConfigCors {
    /**
     * Specifies a list of origins that should be allowed to make cross-origin calls.
     */
    allowedOrigins?: string[];
    /**
     * Are credentials allowed in CORS requests? Defaults to `false`.
     */
    supportCredentials?: boolean;
}

export interface WindowsWebAppSlotSiteConfigHandlerMapping {
    arguments?: string;
    extension: string;
    scriptProcessorPath: string;
}

export interface WindowsWebAppSlotSiteConfigIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsWebAppSlotSiteConfigIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsWebAppSlotSiteConfigIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsWebAppSlotSiteConfigScmIpRestriction {
    /**
     * The action to take. Possible values are `Allow` or `Deny`.
     */
    action?: string;
    /**
     * The description of the IP restriction rule.
     */
    description?: string;
    headers?: outputs.WindowsWebAppSlotSiteConfigScmIpRestrictionHeader[];
    /**
     * The CIDR notation of the IP or IP Range to match. For example: `10.0.0.0/24` or `192.168.10.1/32` or `fe80::/64` or `13.107.6.152/31,13.107.128.0/22`
     */
    ipAddress?: string;
    /**
     * The name which should be used for this `ip_restriction`.
     */
    name: string;
    /**
     * The priority value of this `ip_restriction`.
     */
    priority?: number;
    /**
     * The Service Tag used for this IP Restriction.
     */
    serviceTag?: string;
    /**
     * The Virtual Network Subnet ID used for this IP Restriction.
     */
    virtualNetworkSubnetId?: string;
}

export interface WindowsWebAppSlotSiteConfigScmIpRestrictionHeader {
    xAzureFdids: string[];
    xFdHealthProbes: string[];
    xForwardedFors: string[];
    xForwardedHosts: string[];
}

export interface WindowsWebAppSlotSiteConfigVirtualApplication {
    physicalPath: string;
    preload: boolean;
    virtualDirectories?: outputs.WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory[];
    virtualPath: string;
}

export interface WindowsWebAppSlotSiteConfigVirtualApplicationVirtualDirectory {
    physicalPath?: string;
    virtualPath?: string;
}

export interface WindowsWebAppSlotSiteCredential {
    name: string;
    password: string;
}

export interface WindowsWebAppSlotStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface WindowsWebAppSlotTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WindowsWebAppStickySettings {
    appSettingNames?: string[];
    connectionStringNames?: string[];
}

export interface WindowsWebAppStorageAccount {
    accessKey: string;
    accountName: string;
    mountPath?: string;
    name: string;
    shareName: string;
    type: string;
}

export interface WindowsWebAppTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WorkloadsSapDiscoveryVirtualInstanceIdentity {
    identityIds: string[];
    type: string;
}

export interface WorkloadsSapDiscoveryVirtualInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceIdentity {
    identityIds: string[];
    type: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfiguration {
    appResourceGroupName: string;
    databaseType?: string;
    diskVolumeConfigurations?: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationDiskVolumeConfiguration[];
    secondaryIpEnabled?: boolean;
    subnetId: string;
    virtualMachineConfiguration: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfiguration;
    virtualMachineResourceNames?: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineResourceNames;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationDiskVolumeConfiguration {
    numberOfDisks: number;
    sizeInGb: number;
    skuName: string;
    volumeName: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfiguration {
    image: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfigurationImage;
    osProfile: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfigurationOsProfile;
    virtualMachineSize: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfigurationImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineConfigurationOsProfile {
    adminUsername: string;
    sshPrivateKey: string;
    sshPublicKey: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineResourceNames {
    dataDisks?: outputs.WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineResourceNamesDataDisk[];
    hostName?: string;
    networkInterfaceNames?: string[];
    osDiskName?: string;
    virtualMachineName?: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceSingleServerConfigurationVirtualMachineResourceNamesDataDisk {
    names: string[];
    volumeName: string;
}

export interface WorkloadsSapSingleNodeVirtualInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceIdentity {
    identityIds: string[];
    type: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfiguration {
    appResourceGroupName: string;
    applicationServerConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfiguration;
    centralServerConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfiguration;
    databaseServerConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfiguration;
    highAvailabilityType?: string;
    resourceNames?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNames;
    secondaryIpEnabled?: boolean;
    transportCreateAndMount?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationTransportCreateAndMount;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfiguration {
    instanceCount: number;
    subnetId: string;
    virtualMachineConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfiguration;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfiguration {
    image: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfigurationImage;
    osProfile: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfigurationOsProfile;
    virtualMachineSize: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfigurationImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationApplicationServerConfigurationVirtualMachineConfigurationOsProfile {
    adminUsername: string;
    sshPrivateKey: string;
    sshPublicKey: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfiguration {
    instanceCount: number;
    subnetId: string;
    virtualMachineConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfiguration;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfiguration {
    image: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfigurationImage;
    osProfile: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfigurationOsProfile;
    virtualMachineSize: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfigurationImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationCentralServerConfigurationVirtualMachineConfigurationOsProfile {
    adminUsername: string;
    sshPrivateKey: string;
    sshPublicKey: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfiguration {
    databaseType?: string;
    diskVolumeConfigurations?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationDiskVolumeConfiguration[];
    instanceCount: number;
    subnetId: string;
    virtualMachineConfiguration: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfiguration;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationDiskVolumeConfiguration {
    numberOfDisks: number;
    sizeInGb: number;
    skuName: string;
    volumeName: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfiguration {
    image: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfigurationImage;
    osProfile: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfigurationOsProfile;
    virtualMachineSize: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfigurationImage {
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationDatabaseServerConfigurationVirtualMachineConfigurationOsProfile {
    adminUsername: string;
    sshPrivateKey: string;
    sshPublicKey: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNames {
    applicationServer?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServer;
    centralServer?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServer;
    databaseServer?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServer;
    sharedStorage?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesSharedStorage;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServer {
    availabilitySetName?: string;
    virtualMachines?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServerVirtualMachine[];
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServerVirtualMachine {
    dataDisks?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServerVirtualMachineDataDisk[];
    hostName?: string;
    networkInterfaceNames?: string[];
    osDiskName?: string;
    virtualMachineName?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesApplicationServerVirtualMachineDataDisk {
    names: string[];
    volumeName: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServer {
    availabilitySetName?: string;
    loadBalancer?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerLoadBalancer;
    virtualMachines?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerVirtualMachine[];
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerLoadBalancer {
    backendPoolNames?: string[];
    frontendIpConfigurationNames?: string[];
    healthProbeNames?: string[];
    name?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerVirtualMachine {
    dataDisks?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerVirtualMachineDataDisk[];
    hostName?: string;
    networkInterfaceNames?: string[];
    osDiskName?: string;
    virtualMachineName?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesCentralServerVirtualMachineDataDisk {
    names: string[];
    volumeName: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServer {
    availabilitySetName?: string;
    loadBalancer?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerLoadBalancer;
    virtualMachines?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerVirtualMachine[];
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerLoadBalancer {
    backendPoolNames?: string[];
    frontendIpConfigurationNames?: string[];
    healthProbeNames?: string[];
    name?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerVirtualMachine {
    dataDisks?: outputs.WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerVirtualMachineDataDisk[];
    hostName?: string;
    networkInterfaceNames?: string[];
    osDiskName?: string;
    virtualMachineName?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesDatabaseServerVirtualMachineDataDisk {
    names: string[];
    volumeName: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationResourceNamesSharedStorage {
    accountName?: string;
    privateEndpointName?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceThreeTierConfigurationTransportCreateAndMount {
    resourceGroupId?: string;
    storageAccountName?: string;
}

export interface WorkloadsSapThreeTierVirtualInstanceTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export namespace config {
    export interface Features {
        apiManagements?: outputs.config.FeaturesApiManagement[];
        appConfigurations?: outputs.config.FeaturesAppConfiguration[];
        applicationInsights?: outputs.config.FeaturesApplicationInsight[];
        cognitiveAccounts?: outputs.config.FeaturesCognitiveAccount[];
        keyVaults?: outputs.config.FeaturesKeyVault[];
        logAnalyticsWorkspaces?: outputs.config.FeaturesLogAnalyticsWorkspace[];
        machineLearnings?: outputs.config.FeaturesMachineLearning[];
        managedDisks?: outputs.config.FeaturesManagedDisk[];
        postgresqlFlexibleServers?: outputs.config.FeaturesPostgresqlFlexibleServer[];
        recoveryServices?: outputs.config.FeaturesRecoveryService[];
        recoveryServicesVaults?: outputs.config.FeaturesRecoveryServicesVault[];
        resourceGroups?: outputs.config.FeaturesResourceGroup[];
        subscriptions?: outputs.config.FeaturesSubscription[];
        templateDeployments?: outputs.config.FeaturesTemplateDeployment[];
        virtualMachineScaleSets?: outputs.config.FeaturesVirtualMachineScaleSet[];
        virtualMachines?: outputs.config.FeaturesVirtualMachine[];
    }

    export interface FeaturesApiManagement {
        purgeSoftDeleteOnDestroy?: boolean;
        recoverSoftDeleted?: boolean;
    }

    export interface FeaturesAppConfiguration {
        purgeSoftDeleteOnDestroy?: boolean;
        recoverSoftDeleted?: boolean;
    }

    export interface FeaturesApplicationInsight {
        disableGeneratedRule?: boolean;
    }

    export interface FeaturesCognitiveAccount {
        purgeSoftDeleteOnDestroy?: boolean;
    }

    export interface FeaturesKeyVault {
        /**
         * When enabled soft-deleted `azurerm.KeyVault` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeleteOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultCertificate` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeletedCertificatesOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultManagedHardwareSecurityModuleKey` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeletedHardwareSecurityModuleKeysOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultManagedHardwareSecurityModule` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeletedHardwareSecurityModulesOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultKey` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeletedKeysOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultSecret` resources will be permanently deleted (e.g purged), when destroyed
         */
        purgeSoftDeletedSecretsOnDestroy?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultCertificate` resources will be restored, instead of creating new ones
         */
        recoverSoftDeletedCertificates?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultManagedHardwareSecurityModuleKey` resources will be restored, instead of creating new ones
         */
        recoverSoftDeletedHardwareSecurityModuleKeys?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVault` resources will be restored, instead of creating new ones
         */
        recoverSoftDeletedKeyVaults?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultKey` resources will be restored, instead of creating new ones
         */
        recoverSoftDeletedKeys?: boolean;
        /**
         * When enabled soft-deleted `azurerm.KeyVaultSecret` resources will be restored, instead of creating new ones
         */
        recoverSoftDeletedSecrets?: boolean;
    }

    export interface FeaturesLogAnalyticsWorkspace {
        permanentlyDeleteOnDestroy?: boolean;
    }

    export interface FeaturesMachineLearning {
        purgeSoftDeletedWorkspaceOnDestroy?: boolean;
    }

    export interface FeaturesManagedDisk {
        expandWithoutDowntime?: boolean;
    }

    export interface FeaturesPostgresqlFlexibleServer {
        restartServerOnConfigurationValueChange?: boolean;
    }

    export interface FeaturesRecoveryService {
        purgeProtectedItemsFromVaultOnDestroy?: boolean;
        vmBackupStopProtectionAndRetainDataOnDestroy?: boolean;
    }

    export interface FeaturesRecoveryServicesVault {
        recoverSoftDeletedBackupProtectedVm?: boolean;
    }

    export interface FeaturesResourceGroup {
        preventDeletionIfContainsResources?: boolean;
    }

    export interface FeaturesSubscription {
        preventCancellationOnDestroy?: boolean;
    }

    export interface FeaturesTemplateDeployment {
        deleteNestedItemsDuringDeletion: boolean;
    }

    export interface FeaturesVirtualMachine {
        deleteOsDiskOnDeletion?: boolean;
        detachImplicitDataDiskOnDeletion?: boolean;
        gracefulShutdown?: boolean;
        skipShutdownAndForceDelete?: boolean;
    }

    export interface FeaturesVirtualMachineScaleSet {
        forceDelete?: boolean;
        reimageOnManualUpgrade?: boolean;
        rollInstancesWhenRequired?: boolean;
        scaleToZeroBeforeDeletion?: boolean;
    }

}
