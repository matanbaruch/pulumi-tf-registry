// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BackupscheduleStorageBackup {
    createTime: string;
    name: string;
    objectUuid: string;
}

export interface BackupscheduleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FilesystemListenPort {
    host: string;
    name: string;
    port: number;
}

export interface FilesystemTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FirewallNetwork {
    createTime: string;
    networkName: string;
    networkUuid: string;
    objectName: string;
    objectUuid: string;
}

export interface FirewallRulesV4In {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface FirewallRulesV4Out {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface FirewallRulesV6In {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface FirewallRulesV6Out {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface FirewallTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetBackupListStorageBackup {
    capacity: number;
    createTime: string;
    name: string;
    objectUuid: string;
}

export interface GetBackupscheduleStorageBackup {
    createTime: string;
    name: string;
    objectUuid: string;
}

export interface GetFirewallNetwork {
    createTime: string;
    networkName: string;
    networkUuid: string;
    objectName: string;
    objectUuid: string;
}

export interface GetFirewallRulesV4In {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetFirewallRulesV4Out {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetFirewallRulesV6In {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetFirewallRulesV6Out {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetIsoimageServer {
    bootdevice: boolean;
    createTime: string;
    objectName: string;
    objectUuid: string;
}

export interface GetLoadbalancerBackendServer {
    host: string;
    proxyProtocol: string;
    weight: number;
}

export interface GetLoadbalancerForwardingRule {
    certificateUuid: string;
    letsencryptSsl: string;
    listenPort: number;
    mode: string;
    targetPort: number;
}

export interface GetNetworkAutoAssignedServer {
    ip: string;
    serverUuid: string;
}

export interface GetNetworkPinnedServer {
    ip: string;
    serverUuid: string;
}

export interface GetPaasListenPort {
    name: string;
    port: number;
}

export interface GetPaasParameter {
    param: string;
    type: string;
    value: string;
}

export interface GetPaasResourceLimit {
    limit: number;
    resource: string;
}

export interface GetServerHardwareProfileConfig {
    hypervExtensions: boolean;
    machinetype: string;
    nestedVirtualization: boolean;
    networkModel: string;
    serialInterface: boolean;
    serverRenice: boolean;
    storageDevice: string;
    usbController: string;
}

export interface GetServerNetwork {
    autoAssignedIp: string;
    bootdevice: boolean;
    createTime: string;
    firewallTemplateUuid: string;
    ip: string;
    mac: string;
    networkType: string;
    objectName: string;
    objectUuid: string;
    ordering: number;
    rulesV4Ins: outputs.GetServerNetworkRulesV4In[];
    rulesV4Outs: outputs.GetServerNetworkRulesV4Out[];
    rulesV6Ins: outputs.GetServerNetworkRulesV6In[];
    rulesV6Outs: outputs.GetServerNetworkRulesV6Out[];
}

export interface GetServerNetworkRulesV4In {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetServerNetworkRulesV4Out {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetServerNetworkRulesV6In {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetServerNetworkRulesV6Out {
    action: string;
    comment: string;
    dstCidr: string;
    dstPort: string;
    order: number;
    protocol: string;
    srcCidr: string;
    srcPort: string;
}

export interface GetServerStorage {
    bootdevice: boolean;
    bus: number;
    capacity: number;
    controller: number;
    createTime: string;
    lastUsedTemplate: string;
    licenseProductNo: number;
    lun: number;
    objectName: string;
    objectUuid: string;
    storageType: string;
    target: number;
}

export interface GetSnapshotscheduleSnapshot {
    createTime: string;
    name: string;
    objectUuid: string;
}

export interface GetSslCertificateFingerprint {
    md5: string;
    sha1: string;
    sha256: string;
}

export interface GetSslCertificateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Ipv4Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Ipv6Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface IsoimageServer {
    bootdevice: boolean;
    createTime: string;
    objectName: string;
    objectUuid: string;
}

export interface IsoimageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface K8sListenPort {
    name: string;
    port: number;
}

export interface K8sNodePool {
    /**
     * The cluster CIDR that will be used to generate the CIDR of nodes, services, and pods. The allowed CIDR prefix length is /16. If this field is empty, the default value is "10.244.0.0/16"
     */
    clusterCidr: string;
    /**
     * Enables cluster encryption via wireguard if true. Only available for GSK version 1.29 and above. Default is false.
     */
    clusterTrafficEncryption?: boolean;
    /**
     * Cores per worker node.
     */
    cores: number;
    /**
     * Memory per worker node (in GiB).
     */
    memory: number;
    /**
     * Name of node pool.
     */
    name: string;
    /**
     * Number of worker nodes.
     */
    nodeCount: number;
    /**
     * Rocket storage per worker node (in GiB).
     */
    rocketStorage?: number;
    /**
     * Storage per worker node (in GiB).
     */
    storage: number;
    /**
     * Storage type.
     */
    storageType: string;
    /**
     * Enable surge node to avoid resources shortage during the cluster upgrade.
     */
    surgeNode?: boolean;
}

export interface K8sTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LoadbalancerBackendServer {
    host: string;
    proxyProtocol?: string;
    weight?: number;
}

export interface LoadbalancerForwardingRule {
    /**
     * The UUID of a custom certificate.
     */
    certificateUuid?: string;
    /**
     * A valid domain name that points to the loadbalancer's IP address.
     */
    letsencryptSsl?: string;
    /**
     * Specifies the entry port of the load balancer.
     */
    listenPort: number;
    /**
     * Supports HTTP and TCP mode. Valid values: http, tcp.
     */
    mode: string;
    /**
     * Specifies the exit port that the load balancer uses to forward the traffic to the backend server.
     */
    targetPort: number;
}

export interface LoadbalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MariadbListenPort {
    host: string;
    name: string;
    port: number;
}

export interface MariadbTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MarketplaceApplicationImportTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MarketplaceApplicationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MemcachedListenPort {
    host: string;
    name: string;
    port: number;
}

export interface MemcachedTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Mysql80ListenPort {
    host: string;
    name: string;
    port: number;
}

export interface Mysql80Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MysqlListenPort {
    host: string;
    name: string;
    port: number;
}

export interface MysqlTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NetworkAutoAssignedServer {
    ip: string;
    serverUuid: string;
}

export interface NetworkPinnedServer {
    ip: string;
    serverUuid: string;
}

export interface NetworkTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ObjectStorageAccesskeyTimeouts {
    create?: string;
    delete?: string;
}

export interface ObjectStorageBucketTimeouts {
    create?: string;
    delete?: string;
}

export interface PaasListenPort {
    host: string;
    name: string;
    port: number;
}

export interface PaasParameter {
    param: string;
    type: string;
    value: string;
}

export interface PaasResourceLimit {
    limit: number;
    resource: string;
}

export interface PaasSecurityzoneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PaasTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PostgresqlListenPort {
    host: string;
    name: string;
    port: number;
}

export interface PostgresqlTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RedisCacheListenPort {
    host: string;
    name: string;
    port: number;
}

export interface RedisCacheTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RedisStoreListenPort {
    host: string;
    name: string;
    port: number;
}

export interface RedisStoreTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServerHardwareProfileConfig {
    hypervExtensions: boolean;
    machinetype: string;
    nestedVirtualization: boolean;
    networkModel: string;
    serialInterface: boolean;
    serverRenice: boolean;
    storageDevice: string;
    usbController: string;
}

export interface ServerNetwork {
    /**
     * DHCP IP which is automatically assigned to the server.
     */
    autoAssignedIp: string;
    bootdevice: boolean;
    createTime: string;
    firewallTemplateUuid?: string;
    /**
     * Manually assign DHCP IP to the server.
     */
    ip?: string;
    mac: string;
    networkType: string;
    objectName: string;
    objectUuid: string;
    /**
     * @deprecated Deprecated
     */
    ordering: number;
    rulesV4Ins?: outputs.ServerNetworkRulesV4In[];
    rulesV4Outs?: outputs.ServerNetworkRulesV4Out[];
    rulesV6Ins?: outputs.ServerNetworkRulesV6In[];
    rulesV6Outs?: outputs.ServerNetworkRulesV6Out[];
}

export interface ServerNetworkRulesV4In {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface ServerNetworkRulesV4Out {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface ServerNetworkRulesV6In {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface ServerNetworkRulesV6Out {
    /**
     * This defines what the firewall will do. Either accept or drop.
     */
    action: string;
    /**
     * Comment.
     */
    comment?: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then all IPs have access to this service.
     */
    dstCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    dstPort?: string;
    /**
     * The order at which the firewall will compare packets against its rules.
     * A packet will be compared against the first rule, it will either allow it to pass or block it
     * and it won't be matched against any other rules. However, if it does no match the rule,
     * then it will proceed onto rule 2. Packets that do not match any rules are blocked by default (Only for inbound).
     */
    order: number;
    /**
     * Either 'udp' or 'tcp'
     */
    protocol: string;
    /**
     * Either an IPv4/6 address or and IP Network in CIDR format. If this field is empty then this service has access to all IPs.
     */
    srcCidr?: string;
    /**
     * A Number between 1 and 65535, port ranges are seperated by a colon for FTP
     */
    srcPort?: string;
}

export interface ServerStorage {
    bootdevice: boolean;
    bus: number;
    capacity: number;
    controller: number;
    createTime: string;
    lastUsedTemplate: string;
    licenseProductNo: number;
    lun: number;
    objectName: string;
    objectUuid: string;
    storageType: string;
    target: number;
}

export interface ServerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SnapshotObjectStorageExport {
    /**
     * Access key
     */
    accessKey: string;
    /**
     * Bucket name
     */
    bucket: string;
    /**
     * Host of object storage. Must be of URL type. E.g: https://gos3.io
     */
    host: string;
    /**
     * Name of file (include file path)
     */
    object: string;
    private: boolean;
    /**
     * Secret key
     */
    secretKey: string;
    status: string;
}

export interface SnapshotRollback {
    /**
     * ID of the rollback request. Each rollback request has to have a unique id. ID can be any string value.
     */
    id: string;
    rollbackTime: string;
    status: string;
}

export interface SnapshotTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SnapshotscheduleSnapshot {
    createTime: string;
    name: string;
    objectUuid: string;
}

export interface SnapshotscheduleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SqlserverListenPort {
    host: string;
    name: string;
    port: number;
}

export interface SqlserverS3Backup {
    /**
     * Access key used to authenticate against Object Storage server.
     */
    backupAccessKey: string;
    /**
     * Object Storage bucket to upload backups to and restore backups from.
     */
    backupBucket: string;
    /**
     * Retention (in seconds) for local originals of backups. (0 for immediate removal once uploaded to Object Storage (default), higher values for delayed removal after the given time and once uploaded to Object Storage).
     */
    backupRetention?: number;
    /**
     * Secret key used to authenticate against Object Storage server.
     */
    backupSecretKey: string;
    /**
     * Object Storage server URL the bucket is located on.
     */
    backupServerUrl?: string;
}

export interface SqlserverTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SshkeyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SslCertificateFingerprint {
    md5: string;
    sha1: string;
    sha256: string;
}

export interface SslCertificateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface StorageCloneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface StorageImportTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface StorageTemplate {
    hostname?: string;
    password?: string;
    passwordType?: string;
    sshkeys?: string[];
    templateUuid: string;
}

export interface StorageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

