// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AddonDeploymentClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.AddonDeploymentClusterProfilePack[];
}

export interface AddonDeploymentClusterProfilePack {
    manifests?: outputs.AddonDeploymentClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface AddonDeploymentClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface AddonDeploymentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlertHttp {
    body: string;
    headers?: {[key: string]: string};
    method: string;
    url: string;
}

export interface AlertStatus {
    isSucceeded?: boolean;
    message?: string;
    time?: string;
}

export interface AlertTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApplianceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApplicationConfig {
    clusterContext: string;
    clusterGroupUid?: string;
    clusterName?: string;
    clusterUid?: string;
    limits?: outputs.ApplicationConfigLimit[];
}

export interface ApplicationConfigLimit {
    cpu?: number;
    memory?: number;
    storage?: number;
}

export interface ApplicationProfilePack {
    /**
     * The installation priority order of the app profile. The order of priority goes from lowest number to highest number. For example, a value of `-3` would be installed before an app profile with a higher number value. No upper and lower limits exist, and you may specify positive and negative integers. The default value is `0`.
     */
    installOrder?: number;
    /**
     * The manifest of the pack.
     */
    manifests?: outputs.ApplicationProfilePackManifest[];
    /**
     * The name of the specified pack.
     */
    name: string;
    /**
     * The various properties required by different database tiers eg: `databaseName` and `databaseVolumeSize` size for Redis etc.
     */
    properties?: {[key: string]: string};
    /**
     * The unique id of the registry to be used for the pack.
     */
    registryUid: string;
    /**
     * The unique id of the pack to be used as the source for the pack.
     */
    sourceAppTier?: string;
    /**
     * The identifier or version to label the pack.
     */
    tag?: string;
    /**
     * The type of Pack. Allowed values are `container`, `helm`, `manifest`, or `operator-instance`.
     */
    type?: string;
    /**
     * The unique id of the pack. This is a computed field and is not required to be set.
     */
    uid: string;
    /**
     * The values to be used for the pack. This is a stringified JSON object.
     */
    values?: string;
}

export interface ApplicationProfilePackManifest {
    /**
     * The content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest.
     */
    name: string;
    uid: string;
}

export interface ApplicationProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApplicationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BackupStorageLocationS3 {
    accessKey?: string;
    arn?: string;
    credentialType: string;
    externalId?: string;
    s3ForcePathStyle?: boolean;
    s3Url?: string;
    secretKey?: string;
}

export interface BackupStorageLocationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterAksBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterAksCloudConfig {
    controlPlaneCidr?: string;
    controlPlaneSubnetName?: string;
    controlPlaneSubnetSecurityGroupName?: string;
    /**
     * Whether to create a private cluster(API endpoint). Default is `false`.
     */
    privateCluster?: boolean;
    region: string;
    resourceGroup: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKey: string;
    subscriptionId: string;
    vnetCidrBlock?: string;
    vnetName?: string;
    vnetResourceGroup?: string;
    workerCidr?: string;
    workerSubnetName?: string;
    workerSubnetSecurityGroupName?: string;
}

export interface ClusterAksClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterAksClusterProfilePack[];
}

export interface ClusterAksClusterProfilePack {
    manifests?: outputs.ClusterAksClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterAksClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterAksClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterAksClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterAksClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterAksHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterAksLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterAksMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    diskSizeGb: number;
    instanceType: string;
    isSystemNodePool: boolean;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    name: string;
    nodes?: outputs.ClusterAksMachinePoolNode[];
    storageAccountType: string;
    taints?: outputs.ClusterAksMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterAksMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterAksMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterAksNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterAksScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterAksTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterAwsBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterAwsCloudConfig {
    /**
     * Control plane load balancer type. Valid values are `Internet-facing` and `internal`. Defaults to `` (empty string).
     */
    controlPlaneLb?: string;
    /**
     * The AWS region to deploy the cluster in.
     */
    region: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKeyName: string;
    /**
     * The VPC ID to deploy the cluster in. If not provided, VPC will be provisioned dynamically.
     */
    vpcId?: string;
}

export interface ClusterAwsClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterAwsClusterProfilePack[];
}

export interface ClusterAwsClusterProfilePack {
    manifests?: outputs.ClusterAwsClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterAwsClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterAwsClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterAwsClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterAwsClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterAwsHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterAwsLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterAwsMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Additional security groups to attach to the instance.
     */
    additionalSecurityGroups?: string[];
    /**
     * Mutually exclusive with `azs`. Use `az_subnets` for Static provisioning.
     */
    azSubnets?: {[key: string]: string};
    /**
     * Mutually exclusive with `az_subnets`. Use `azs` for Dynamic provisioning.
     */
    azs?: string[];
    /**
     * Capacity type is an instance type,  can be 'on-demand' or 'spot'. Defaults to 'on-demand'.
     */
    capacityType?: string;
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    /**
     * The disk size in GB for the machine pool nodes.
     */
    diskSizeGb?: number;
    /**
     * The instance type to use for the machine pool nodes.
     */
    instanceType: string;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    /**
     * Maximum price to bid for spot instances. Only applied when instance type is 'spot'.
     */
    maxPrice?: string;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    /**
     * The name of the machine pool.
     */
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterAwsMachinePoolNode[];
    taints?: outputs.ClusterAwsMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterAwsMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterAwsMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterAwsNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterAwsScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterAwsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterAzureBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterAzureCloudConfig {
    /**
     * Container name within your azure storage account.
     */
    containerName?: string;
    controlPlaneSubnet?: outputs.ClusterAzureCloudConfigControlPlaneSubnet;
    /**
     * Azure network resource group in which the cluster is to be provisioned.
     */
    networkResourceGroup?: string;
    /**
     * Azure region. This can be found in the Azure portal under `Resource groups`.
     */
    region: string;
    /**
     * Azure resource group. This can be found in the Azure portal under `Resource groups`.
     */
    resourceGroup: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKey: string;
    /**
     * Azure storage account name.
     */
    storageAccountName?: string;
    /**
     * Azure subscription ID. This can be found in the Azure portal under `Subscriptions`.
     */
    subscriptionId: string;
    /**
     * Azure virtual network cidr block in which the cluster is to be provisioned.
     */
    virtualNetworkCidrBlock?: string;
    /**
     * Azure virtual network in which the cluster is to be provisioned.
     */
    virtualNetworkName?: string;
    workerNodeSubnet?: outputs.ClusterAzureCloudConfigWorkerNodeSubnet;
}

export interface ClusterAzureCloudConfigControlPlaneSubnet {
    /**
     * CidrBlock is the CIDR block to be used when the provider creates a managed virtual network.
     */
    cidrBlock: string;
    /**
     * Name of the subnet.
     */
    name: string;
    /**
     * Network Security Group(NSG) to be attached to subnet.
     */
    securityGroupName?: string;
}

export interface ClusterAzureCloudConfigWorkerNodeSubnet {
    /**
     * CidrBlock is the CIDR block to be used when the provider creates a managed virtual network.
     */
    cidrBlock: string;
    /**
     * Name of the subnet.
     */
    name: string;
    /**
     * Network Security Group(NSG) to be attached to subnet.
     */
    securityGroupName?: string;
}

export interface ClusterAzureClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterAzureClusterProfilePack[];
}

export interface ClusterAzureClusterProfilePack {
    manifests?: outputs.ClusterAzureClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterAzureClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterAzureClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterAzureClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterAzureClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterAzureHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterAzureLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterAzureMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Availability zones for the machine pool. Check if your region provides availability zones on [the Azure documentation](https://learn.microsoft.com/en-us/azure/reliability/availability-zones-service-support#azure-regions-with-availability-zone-support). Default value is `[""]`.
     */
    azs?: string[];
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    /**
     * Disk configuration for the machine pool.
     */
    disk?: outputs.ClusterAzureMachinePoolDisk;
    /**
     * Azure instance type from the Azure portal.
     */
    instanceType: string;
    /**
     * Whether this machine pool is a system node pool. Default value is `false'.
     */
    isSystemNodePool?: boolean;
    /**
     * Name of the machine pool. This must be unique within the cluster.
     */
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterAzureMachinePoolNode[];
    /**
     * Operating system type for the machine pool. Valid values are `Linux` and `Windows`. Defaults to `Linux`.
     */
    osType?: string;
    taints?: outputs.ClusterAzureMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterAzureMachinePoolDisk {
    /**
     * Size of the disk in GB.
     */
    sizeGb: number;
    /**
     * Type of the disk. Valid values are `Standard_LRS`, `StandardSSD_LRS`, `Premium_LRS`.
     */
    type: string;
}

export interface ClusterAzureMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterAzureMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterAzureNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterAzureScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterAzureTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterCustomCloudBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterCustomCloudCloudConfig {
    /**
     * The values of the cloud config. The values are specified in YAML format.
     */
    values: string;
}

export interface ClusterCustomCloudClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterCustomCloudClusterProfilePack[];
}

export interface ClusterCustomCloudClusterProfilePack {
    manifests?: outputs.ClusterCustomCloudClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterCustomCloudClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterCustomCloudClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterCustomCloudClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterCustomCloudClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterCustomCloudLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterCustomCloudMachinePool {
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool. This will be derived from the replica value in the 'node_pool_config'.
     */
    count: number;
    /**
     * The name of the machine pool. This will be derived from the name value in the `node_pool_config`.
     */
    name: string;
    /**
     * The values of the node pool config. The values are specified in YAML format.
     */
    nodePoolConfig: string;
}

export interface ClusterCustomCloudNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterCustomCloudScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterCustomCloudTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterEdgeNativeBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterEdgeNativeCloudConfig {
    /**
     * A list of NTP servers to be used by the cluster.
     */
    ntpServers?: string[];
    /**
     * The Overlay (VPN) creates a virtual network, using techniques like VxLAN. It overlays the existing network infrastructure, enhancing connectivity either at Layer 2 or Layer 3, making it flexible and adaptable for various needs. For example, `100.64.192.0/24`
     */
    overlayCidrRange?: string;
    /**
     * List of public SSH (Secure Shell) to establish, administer, and communicate with remote clusters.
     */
    sshKeys?: string[];
    /**
     * The `vip` can be specified as either an IP address or a fully qualified domain name (FQDN). If `overlay_cidr_range` is set, the `vip` should be within the specified `overlay_cidr_range`. By default, the `vip` is set to the first IP address within the given `overlay_cidr_range`.
     */
    vip?: string;
}

export interface ClusterEdgeNativeClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterEdgeNativeClusterProfilePack[];
}

export interface ClusterEdgeNativeClusterProfilePack {
    manifests?: outputs.ClusterEdgeNativeClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterEdgeNativeClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterEdgeNativeClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterEdgeNativeClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterEdgeNativeClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterEdgeNativeHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterEdgeNativeLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterEdgeNativeMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    edgeHosts: outputs.ClusterEdgeNativeMachinePoolEdgeHost[];
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterEdgeNativeMachinePoolNode[];
    taints?: outputs.ClusterEdgeNativeMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterEdgeNativeMachinePoolEdgeHost {
    /**
     * Edge host name
     */
    hostName?: string;
    /**
     * Edge host id
     */
    hostUid: string;
    /**
     * Edge host static IP
     */
    staticIp?: string;
    /**
     * Two node role for edge host. Valid values are `primary` and `secondary`.
     */
    twoNodeRole?: string;
}

export interface ClusterEdgeNativeMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterEdgeNativeMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterEdgeNativeNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterEdgeNativeScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterEdgeNativeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterEdgeVsphereBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterEdgeVsphereCloudConfig {
    datacenter: string;
    folder: string;
    imageTemplateFolder?: string;
    networkSearchDomain?: string;
    networkType?: string;
    /**
     * Public SSH Key (Secure Shell) to establish, administer, and communicate with remote clusters, `ssh_key & ssh_keys` are mutually exclusive.
     */
    sshKey?: string;
    /**
     * List of public SSH (Secure Shell) keys to establish, administer, and communicate with remote clusters, `ssh_key & ssh_keys` are mutually exclusive.
     */
    sshKeys?: string[];
    staticIp?: boolean;
    vip: string;
}

export interface ClusterEdgeVsphereClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterEdgeVsphereClusterProfilePack[];
}

export interface ClusterEdgeVsphereClusterProfilePack {
    manifests?: outputs.ClusterEdgeVsphereClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterEdgeVsphereClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterEdgeVsphereClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterEdgeVsphereClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterEdgeVsphereClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterEdgeVsphereHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterEdgeVsphereLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterEdgeVsphereMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    instanceType: outputs.ClusterEdgeVsphereMachinePoolInstanceType;
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterEdgeVsphereMachinePoolNode[];
    placements: outputs.ClusterEdgeVsphereMachinePoolPlacement[];
    taints?: outputs.ClusterEdgeVsphereMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterEdgeVsphereMachinePoolInstanceType {
    cpu: number;
    diskSizeGb: number;
    memoryMb: number;
}

export interface ClusterEdgeVsphereMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterEdgeVsphereMachinePoolPlacement {
    cluster: string;
    datastore: string;
    id: string;
    network: string;
    resourcePool: string;
    staticIpPoolId?: string;
}

export interface ClusterEdgeVsphereMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterEdgeVsphereNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterEdgeVsphereScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterEdgeVsphereTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterEksBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterEksCloudConfig {
    /**
     * Mutually exclusive with `azs`. Use for Static provisioning.
     */
    azSubnets?: {[key: string]: string};
    /**
     * Mutually exclusive with `az_subnets`. Use for Dynamic provisioning.
     */
    azs?: string[];
    /**
     * The ARN of the KMS encryption key to use for the cluster. Refer to the [Enable Secrets Encryption for EKS Cluster](https://docs.spectrocloud.com/clusters/public-cloud/aws/enable-secrets-encryption-kms-key/) for additional guidance.
     */
    encryptionConfigArn?: string;
    /**
     * Choose between `private`, `public`, or `private_and_public` to define how communication is established with the endpoint for the managed Kubernetes API server and your cluster. The default value is `public`.
     */
    endpointAccess?: string;
    /**
     * List of CIDR blocks that define the allowed private access to the resource. Only requests originating from addresses within these CIDR blocks will be permitted to access the resource.
     */
    privateAccessCidrs?: string[];
    /**
     * List of CIDR blocks that define the allowed public access to the resource. Requests originating from addresses within these CIDR blocks will be permitted to access the resource. All other addresses will be denied access.
     */
    publicAccessCidrs?: string[];
    region: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKeyName?: string;
    vpcId?: string;
}

export interface ClusterEksClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterEksClusterProfilePack[];
}

export interface ClusterEksClusterProfilePack {
    manifests?: outputs.ClusterEksClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterEksClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterEksClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterEksClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterEksClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterEksFargateProfile {
    additionalTags?: {[key: string]: string};
    name: string;
    selectors: outputs.ClusterEksFargateProfileSelector[];
    subnets?: string[];
}

export interface ClusterEksFargateProfileSelector {
    labels?: {[key: string]: string};
    namespace: string;
}

export interface ClusterEksHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterEksLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterEksMachinePool {
    additionalLabels?: {[key: string]: string};
    azSubnets?: {[key: string]: string};
    azs?: string[];
    /**
     * Capacity type is an instance type,  can be 'on-demand' or 'spot'. Defaults to 'on-demand'.
     */
    capacityType?: string;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    diskSizeGb: number;
    eksLaunchTemplate?: outputs.ClusterEksMachinePoolEksLaunchTemplate;
    instanceType: string;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    maxPrice?: string;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    name: string;
    nodes?: outputs.ClusterEksMachinePoolNode[];
    taints?: outputs.ClusterEksMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterEksMachinePoolEksLaunchTemplate {
    /**
     * Additional security groups to attach to the instance.
     */
    additionalSecurityGroups?: string[];
    /**
     * The ID of the custom Amazon Machine Image (AMI).
     */
    amiId?: string;
    /**
     * The number of input/output operations per second (IOPS) for the root volume.
     */
    rootVolumeIops?: number;
    /**
     * The throughput of the root volume in MiB/s.
     */
    rootVolumeThroughput?: number;
    /**
     * The type of the root volume.
     */
    rootVolumeType?: string;
}

export interface ClusterEksMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterEksMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterEksNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterEksScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterEksTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterGcpBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterGcpCloudConfig {
    network?: string;
    project: string;
    region: string;
}

export interface ClusterGcpClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterGcpClusterProfilePack[];
}

export interface ClusterGcpClusterProfilePack {
    manifests?: outputs.ClusterGcpClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterGcpClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterGcpClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterGcpClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterGcpClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterGcpHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterGcpLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterGcpMachinePool {
    additionalLabels?: {[key: string]: string};
    azs: string[];
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    diskSizeGb?: number;
    instanceType: string;
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterGcpMachinePoolNode[];
    taints?: outputs.ClusterGcpMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterGcpMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterGcpMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterGcpNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterGcpScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterGcpTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterGkeBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterGkeCloudConfig {
    /**
     * GCP project name.
     */
    project: string;
    region: string;
}

export interface ClusterGkeClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterGkeClusterProfilePack[];
}

export interface ClusterGkeClusterProfilePack {
    manifests?: outputs.ClusterGkeClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterGkeClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterGkeClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterGkeClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterGkeClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterGkeHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterGkeLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterGkeMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    diskSizeGb?: number;
    instanceType: string;
    name: string;
    nodes?: outputs.ClusterGkeMachinePoolNode[];
    taints?: outputs.ClusterGkeMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterGkeMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterGkeMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterGkeNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterGkeScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterGkeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterGroupCluster {
    /**
     * The UID of the host cluster.
     */
    clusterUid: string;
    /**
     * The host DNS wildcard for the cluster. i.e. `*.dev` or `*test.com`
     */
    hostDns?: string;
}

export interface ClusterGroupClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterGroupClusterProfilePack[];
}

export interface ClusterGroupClusterProfilePack {
    manifests?: outputs.ClusterGroupClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterGroupClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterGroupConfig {
    /**
     * The CPU limit in millicores.
     */
    cpuMillicore?: number;
    /**
     * The host endpoint type. Allowed values are 'Ingress' or 'LoadBalancer'. Defaults to 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The Kubernetes distribution, allowed values are `k3s` and `cncf_k8s`.
     */
    k8sDistribution?: string;
    /**
     * The memory limit in megabytes (MB).
     */
    memoryInMb?: number;
    /**
     * The allowed oversubscription percentage.
     */
    oversubscriptionPercent?: number;
    /**
     * The storage limit in gigabytes (GB).
     */
    storageInGb?: number;
    values?: string;
}

export interface ClusterGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterImportClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterImportClusterProfilePack[];
}

export interface ClusterImportClusterProfilePack {
    manifests?: outputs.ClusterImportClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterImportClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterImportTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterMaasBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterMaasCloudConfig {
    /**
     * Domain name in which the cluster to be provisioned.
     */
    domain: string;
}

export interface ClusterMaasClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterMaasClusterProfilePack[];
}

export interface ClusterMaasClusterProfilePack {
    manifests?: outputs.ClusterMaasClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterMaasClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterMaasClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterMaasClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterMaasClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterMaasHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterMaasLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterMaasMachinePool {
    /**
     * Additional labels to be applied to the machine pool. Labels must be in the form of `key:value`.
     */
    additionalLabels?: {[key: string]: string};
    /**
     * Availability zones in which the machine pool nodes to be provisioned.
     */
    azs?: string[];
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    instanceType: outputs.ClusterMaasMachinePoolInstanceType;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    /**
     * Name of the machine pool.
     */
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    /**
     * Node tags to dynamically place nodes in a pool by using MAAS automatic tags. Specify the tag values that you want to apply to all nodes in the node pool.
     */
    nodeTags?: string[];
    nodes?: outputs.ClusterMaasMachinePoolNode[];
    placement: outputs.ClusterMaasMachinePoolPlacement;
    taints?: outputs.ClusterMaasMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterMaasMachinePoolInstanceType {
    /**
     * Minimum number of CPU required for the machine pool node.
     */
    minCpu: number;
    /**
     * Minimum memory in MB required for the machine pool node.
     */
    minMemoryMb: number;
}

export interface ClusterMaasMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterMaasMachinePoolPlacement {
    /**
     * This is a computed(read-only) ID of the placement that is used to connect to the Maas cloud.
     */
    id: string;
    /**
     * The name of the resource pool in the Maas cloud.
     */
    resourcePool: string;
}

export interface ClusterMaasMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterMaasNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterMaasScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterMaasTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterOpenstackBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterOpenstackCloudConfig {
    dnsServers: string[];
    domain: string;
    networkId?: string;
    project: string;
    region: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKey: string;
    subnetCidr: string;
    subnetId?: string;
}

export interface ClusterOpenstackClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterOpenstackClusterProfilePack[];
}

export interface ClusterOpenstackClusterProfilePack {
    manifests?: outputs.ClusterOpenstackClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterOpenstackClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterOpenstackClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterOpenstackClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterOpenstackClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterOpenstackHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterOpenstackLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterOpenstackMachinePool {
    additionalLabels?: {[key: string]: string};
    azs?: string[];
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    instanceType: string;
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterOpenstackMachinePoolNode[];
    subnetId?: string;
    taints?: outputs.ClusterOpenstackMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterOpenstackMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterOpenstackMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterOpenstackNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterOpenstackScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterOpenstackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterProfilePack {
    manifests?: outputs.ClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterProfileProfileVariables {
    variables: outputs.ClusterProfileProfileVariablesVariable[];
}

export interface ClusterProfileProfileVariablesVariable {
    /**
     * The default value of the variable.
     */
    defaultValue?: string;
    /**
     * The description of the variable.
     */
    description?: string;
    /**
     * The display name of the variable should be unique among variables.
     */
    displayName: string;
    /**
     * The format of the variable. Default is `string`, `format` field can only be set during cluster profile creation. Allowed formats include `string`, `number`, `boolean`, `ipv4`, `ipv4cidr`, `ipv6`, `version`.
     */
    format?: string;
    /**
     * If `hidden` is set to `true`, then variable will be hidden for overriding the value. By default the `hidden` flag will be set to `false`.
     */
    hidden?: boolean;
    /**
     * If `immutable` is set to `true`, then variable value can't be editable. By default the `immutable` flag will be set to `false`.
     */
    immutable?: boolean;
    /**
     * If `is_sensitive` is set to `true`, then default value will be masked. By default the `is_sensitive` flag will be set to false.
     */
    isSensitive?: boolean;
    /**
     * The name of the variable should be unique among variables.
     */
    name: string;
    /**
     * Regular expression pattern which the variable value must match.
     */
    regex?: string;
    /**
     * The `required` to specify if the variable is optional or mandatory. If it is mandatory then default value must be provided.
     */
    required?: boolean;
}

export interface ClusterProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterTkeBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterTkeCloudConfig {
    azSubnets?: {[key: string]: string};
    azs?: string[];
    endpointAccess?: string;
    publicAccessCidrs?: string[];
    region: string;
    /**
     * Public SSH key to be used for the cluster nodes.
     */
    sshKeyName?: string;
    vpcId?: string;
}

export interface ClusterTkeClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterTkeClusterProfilePack[];
}

export interface ClusterTkeClusterProfilePack {
    manifests?: outputs.ClusterTkeClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterTkeClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterTkeClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterTkeClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterTkeClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterTkeHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterTkeLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface ClusterTkeMachinePool {
    additionalLabels?: {[key: string]: string};
    azSubnets?: {[key: string]: string};
    azs?: string[];
    capacityType?: string;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    diskSizeGb: number;
    instanceType: string;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    maxPrice?: string;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    name: string;
    nodes?: outputs.ClusterTkeMachinePoolNode[];
    taints?: outputs.ClusterTkeMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterTkeMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterTkeMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterTkeNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterTkeScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterTkeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterVsphereBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface ClusterVsphereCloudConfig {
    /**
     * The name of the datacenter in vSphere. This is the name of the datacenter as it appears in vSphere.
     */
    datacenter: string;
    /**
     * The name of the folder in vSphere. This is the name of the folder as it appears in vSphere.
     */
    folder: string;
    /**
     * The name of the image template folder in vSphere. This is the name of the folder as it appears in vSphere.
     */
    imageTemplateFolder?: string;
    /**
     * The search domain to use for the cluster in case of DHCP.
     */
    networkSearchDomain?: string;
    /**
     * The type of network to use for the cluster. This can be `VIP` or `DDNS`.
     */
    networkType?: string;
    /**
     * A list of NTP servers to be used by the cluster.
     */
    ntpServers?: string[];
    /**
     * The SSH key to be used for the cluster. This is the public key that will be used to access the cluster nodes. `ssh_key & ssh_keys` are mutually exclusive.
     *
     * @deprecated Deprecated
     */
    sshKey?: string;
    /**
     * List of public SSH (Secure Shell) keys to establish, administer, and communicate with remote clusters, `ssh_key & ssh_keys` are mutually exclusive.
     */
    sshKeys?: string[];
    /**
     * Whether to use static IP addresses for the cluster. If `true`, the cluster will use static IP addresses. If `false`, the cluster will use DDNS. Default is `false`.
     */
    staticIp?: boolean;
}

export interface ClusterVsphereClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.ClusterVsphereClusterProfilePack[];
}

export interface ClusterVsphereClusterProfilePack {
    manifests?: outputs.ClusterVsphereClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface ClusterVsphereClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface ClusterVsphereClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.ClusterVsphereClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface ClusterVsphereClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface ClusterVsphereHostConfig {
    /**
     * The external traffic policy for the cluster.
     */
    externalTrafficPolicy?: string;
    /**
     * The type of endpoint for the cluster. Can be either 'Ingress' or 'LoadBalancer'. The default is 'Ingress'.
     */
    hostEndpointType?: string;
    /**
     * The host for the Ingress endpoint. Required if 'host_endpoint_type' is set to 'Ingress'.
     */
    ingressHost?: string;
    /**
     * The source ranges for the load balancer. Required if 'host_endpoint_type' is set to 'LoadBalancer'.
     */
    loadBalancerSourceRanges?: string;
}

export interface ClusterVsphereLocationConfig {
    /**
     * The country code of the country the cluster is located in.
     */
    countryCode?: string;
    /**
     * The name of the country.
     */
    countryName?: string;
    /**
     * The latitude coordinates value.
     */
    latitude: number;
    /**
     * The longitude coordinates value.
     */
    longitude: number;
    /**
     * The region code of where the cluster is located in.
     */
    regionCode?: string;
    /**
     * The name of the region.
     */
    regionName?: string;
}

export interface ClusterVsphereMachinePool {
    additionalLabels?: {[key: string]: string};
    /**
     * Whether this machine pool is a control plane. Defaults to `false`.
     */
    controlPlane?: boolean;
    /**
     * Whether this machine pool is a control plane and a worker. Defaults to `false`.
     */
    controlPlaneAsWorker?: boolean;
    /**
     * Number of nodes in the machine pool.
     */
    count: number;
    instanceType: outputs.ClusterVsphereMachinePoolInstanceType;
    /**
     * Maximum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    max?: number;
    /**
     * Minimum number of nodes in the machine pool. This is used for autoscaling the machine pool.
     */
    min?: number;
    /**
     * The name of the machine pool. This is used to identify the machine pool in the cluster.
     */
    name: string;
    /**
     * Minimum number of seconds node should be Ready, before the next node is selected for repave. Default value is `0`, Applicable only for worker pools.
     */
    nodeRepaveInterval?: number;
    nodes?: outputs.ClusterVsphereMachinePoolNode[];
    placements: outputs.ClusterVsphereMachinePoolPlacement[];
    taints?: outputs.ClusterVsphereMachinePoolTaint[];
    /**
     * Update strategy for the machine pool. Valid values are `RollingUpdateScaleOut` and `RollingUpdateScaleIn`.
     */
    updateStrategy?: string;
}

export interface ClusterVsphereMachinePoolInstanceType {
    /**
     * The number of CPUs.
     */
    cpu: number;
    /**
     * The size of the disk in GB.
     */
    diskSizeGb: number;
    /**
     * The amount of memory in MB.
     */
    memoryMb: number;
}

export interface ClusterVsphereMachinePoolNode {
    /**
     * The action to perform on the node. Valid values are: `cordon`, `uncordon`.
     */
    action: string;
    /**
     * The node_id of the node, For example `i-07f899a33dee624f7`
     */
    nodeId: string;
}

export interface ClusterVsphereMachinePoolPlacement {
    /**
     * The name of the cluster to use for the machine pool. As it appears in the vSphere.
     */
    cluster: string;
    /**
     * The name of the datastore to use for the machine pool. As it appears in the vSphere.
     */
    datastore: string;
    id: string;
    /**
     * The name of the network to use for the machine pool. As it appears in the vSphere.
     */
    network: string;
    /**
     * The name of the resource pool to use for the machine pool. As it appears in the vSphere.
     */
    resourcePool: string;
    /**
     * The ID of the static IP pool to use for the machine pool in case of static cluster placement.
     */
    staticIpPoolId?: string;
}

export interface ClusterVsphereMachinePoolTaint {
    /**
     * The effect of the taint. Allowed values are: `NoSchedule`, `PreferNoSchedule` or `NoExecute`.
     */
    effect: string;
    /**
     * The key of the taint.
     */
    key: string;
    /**
     * The value of the taint.
     */
    value: string;
}

export interface ClusterVsphereNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface ClusterVsphereScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface ClusterVsphereTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DatavolumeAddVolumeOptions {
    disk: outputs.DatavolumeAddVolumeOptionsDisk;
    name: string;
    volumeSource: outputs.DatavolumeAddVolumeOptionsVolumeSource;
}

export interface DatavolumeAddVolumeOptionsDisk {
    bus: string;
    name: string;
}

export interface DatavolumeAddVolumeOptionsVolumeSource {
    dataVolume: outputs.DatavolumeAddVolumeOptionsVolumeSourceDataVolume;
}

export interface DatavolumeAddVolumeOptionsVolumeSourceDataVolume {
    hotpluggable?: boolean;
    name: string;
}

export interface DatavolumeMetadata {
    /**
     * An unstructured key value map stored with the DataVolume that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations
     */
    annotations: {[key: string]: string};
    /**
     * A sequence number representing a specific generation of the desired state.
     */
    generation: number;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) the DataVolume. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
     */
    labels?: {[key: string]: string};
    /**
     * Name of the DataVolume, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
     */
    name: string;
    /**
     * Namespace defines the space within which name of the DataVolume must be unique.
     */
    namespace?: string;
    /**
     * An opaque value that represents the internal version of this DataVolume that can be used by clients to determine when DataVolume has changed. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     */
    resourceVersion: string;
    /**
     * A URL representing this DataVolume.
     */
    selfLink: string;
    /**
     * The unique in time and space value for this DataVolume. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
     */
    uid: string;
}

export interface DatavolumeSpec {
    /**
     * ContentType options: "kubevirt", "archive".
     */
    contentType?: string;
    /**
     * PVC is a pointer to the PVC Spec we want to use.
     */
    pvc: outputs.DatavolumeSpecPvc;
    /**
     * Source is the src of the data for the requested DataVolume.
     */
    source?: outputs.DatavolumeSpecSource;
}

export interface DatavolumeSpecPvc {
    /**
     * A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
     */
    accessModes: string[];
    /**
     * A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
     */
    resources: outputs.DatavolumeSpecPvcResources;
    /**
     * A label query over volumes to consider for binding.
     */
    selector?: outputs.DatavolumeSpecPvcSelector;
    /**
     * Name of the storage class requested by the claim
     */
    storageClassName: string;
    /**
     * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
     */
    volumeMode: string;
    /**
     * The binding reference to the PersistentVolume backing this claim.
     */
    volumeName: string;
}

export interface DatavolumeSpecPvcResources {
    /**
     * Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
     */
    limits?: {[key: string]: string};
    /**
     * Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
     */
    requests?: {[key: string]: string};
}

export interface DatavolumeSpecPvcSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.DatavolumeSpecPvcSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface DatavolumeSpecPvcSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface DatavolumeSpecSource {
    /**
     * DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.
     */
    blank?: outputs.DatavolumeSpecSourceBlank;
    /**
     * DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.
     */
    http?: outputs.DatavolumeSpecSourceHttp;
    /**
     * DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.
     */
    pvc?: outputs.DatavolumeSpecSourcePvc;
    /**
     * DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.
     */
    registry?: outputs.DatavolumeSpecSourceRegistry;
}

export interface DatavolumeSpecSourceBlank {
}

export interface DatavolumeSpecSourceHttp {
    /**
     * Cert_config_map provides a reference to the Registry certs.
     */
    certConfigMap?: string;
    /**
     * Secret_ref provides the secret reference needed to access the HTTP source.
     */
    secretRef?: string;
    /**
     * url is the URL of the http source.
     */
    url?: string;
}

export interface DatavolumeSpecSourcePvc {
    /**
     * The name of the PVC.
     */
    name?: string;
    /**
     * The namespace which the PVC located in.
     */
    namespace?: string;
}

export interface DatavolumeSpecSourceRegistry {
    /**
     * The registry URL of the image to download.
     */
    imageUrl?: string;
}

export interface DatavolumeStatus {
    /**
     * DataVolumePhase is the current phase of the DataVolume.
     */
    phase: string;
    /**
     * DataVolumePhase is the current phase of the DataVolume.
     */
    progress: string;
}

export interface DatavolumeTimeouts {
    create?: string;
    delete?: string;
}

export interface FilterMetadata {
    /**
     * The name of the filter.
     */
    name: string;
}

export interface FilterSpec {
    /**
     * Filter group of the filter.
     */
    filterGroup: outputs.FilterSpecFilterGroup;
}

export interface FilterSpecFilterGroup {
    /**
     * Conjunction operation of the filter group. Valid values are 'and' and 'or'.
     */
    conjunction: string;
    /**
     * List of filters in the filter group.
     */
    filters: outputs.FilterSpecFilterGroupFilter[];
}

export interface FilterSpecFilterGroupFilter {
    /**
     * Key of the filter.
     */
    key: string;
    /**
     * Negation flag of the filter condition.
     */
    negation?: boolean;
    /**
     * Operator of the filter. Valid values are 'eq'.
     */
    operator: string;
    /**
     * Values of the filter.
     */
    values: string[];
}

export interface FilterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetClusterProfilePack {
    manifests: outputs.GetClusterProfilePackManifest[];
    name: string;
    registryUid: string;
    tag: string;
    type: string;
    uid: string;
    values: string;
}

export interface GetClusterProfilePackManifest {
    content: string;
    name: string;
    uid: string;
}

export interface GetFilterMetadata {
    annotations: {[key: string]: string};
    labels: {[key: string]: string};
    name: string;
}

export interface GetFilterSpec {
    filterGroups: outputs.GetFilterSpecFilterGroup[];
}

export interface GetFilterSpecFilterGroup {
    conjunction: string;
    filters: outputs.GetFilterSpecFilterGroupFilter[];
}

export interface GetFilterSpecFilterGroupFilter {
    key: string;
    negation: boolean;
    operator: string;
    values: string[];
}

export interface MacroTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MacrosTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatecloudgatewayIppoolTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RegistryHelmCredentials {
    credentialType: string;
    password?: string;
    token?: string;
    username?: string;
}

export interface RegistryHelmTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RegistryOciCredentials {
    accessKey?: string;
    arn?: string;
    credentialType: string;
    externalId?: string;
    secretKey?: string;
}

export interface RegistryOciTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TeamProjectRoleMapping {
    /**
     * Project id to be associated with the team.
     */
    id: string;
    /**
     * List of project roles to be associated with the team.
     */
    roles: string[];
}

export interface TeamTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TeamWorkspaceRoleMapping {
    /**
     * Project id to be associated with the team.
     */
    id: string;
    /**
     * List of workspace roles to be associated with the team.
     */
    workspaces?: outputs.TeamWorkspaceRoleMappingWorkspace[];
}

export interface TeamWorkspaceRoleMappingWorkspace {
    /**
     * Workspace id to be associated with the team.
     */
    id: string;
    /**
     * List of workspace roles to be associated with the team.
     */
    roles?: string[];
}

export interface VirtualClusterBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface VirtualClusterCloudConfig {
    chartName?: string;
    chartRepo?: string;
    chartValues?: string;
    chartVersion?: string;
    k8sVersion?: string;
}

export interface VirtualClusterClusterProfile {
    /**
     * The ID of the cluster profile.
     */
    id: string;
    /**
     * For packs of type `spectro`, `helm`, and `manifest`, at least one pack must be specified.
     */
    packs?: outputs.VirtualClusterClusterProfilePack[];
}

export interface VirtualClusterClusterProfilePack {
    manifests?: outputs.VirtualClusterClusterProfilePackManifest[];
    /**
     * The name of the pack. The name must be unique within the cluster profile.
     */
    name: string;
    /**
     * The registry UID of the pack. The registry UID is the unique identifier of the registry. This attribute is required if there is more than one registry that contains a pack with the same name.
     */
    registryUid?: string;
    /**
     * The tag of the pack. The tag is the version of the pack. This attribute is required if the pack type is `spectro` or `helm`.
     */
    tag?: string;
    /**
     * The type of the pack. Allowed values are `spectro`, `manifest`, `helm`, or `oci`. The default value is spectro. If using an OCI registry for pack, set the type to `oci`.
     */
    type?: string;
    uid: string;
    /**
     * The values of the pack. The values are the configuration values of the pack. The values are specified in YAML format.
     */
    values?: string;
}

export interface VirtualClusterClusterProfilePackManifest {
    /**
     * The content of the manifest. The content is the YAML content of the manifest.
     */
    content: string;
    /**
     * The name of the manifest. The name must be unique within the pack.
     */
    name: string;
    uid: string;
}

export interface VirtualClusterClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.VirtualClusterClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface VirtualClusterClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface VirtualClusterLocationConfig {
    countryCode: string;
    countryName: string;
    latitude: number;
    longitude: number;
    regionCode: string;
    regionName: string;
}

export interface VirtualClusterNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

export interface VirtualClusterResource {
    maxCpu?: number;
    maxMemInMb?: number;
    maxStorageInGb?: number;
    minCpu?: number;
    minMemInMb?: number;
    minStorageInGb?: number;
}

export interface VirtualClusterScanPolicy {
    /**
     * The schedule for configuration scan.
     */
    configurationScanSchedule: string;
    /**
     * The schedule for conformance scan.
     */
    conformanceScanSchedule: string;
    /**
     * The schedule for penetration scan.
     */
    penetrationScanSchedule: string;
}

export interface VirtualClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VirtualMachineAffinity {
    /**
     * Node affinity scheduling rules for the pod.
     */
    nodeAffinity?: outputs.VirtualMachineAffinityNodeAffinity;
    /**
     * Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
     */
    podAffinity?: outputs.VirtualMachineAffinityPodAffinity;
    /**
     * Inter-pod topological affinity. rules that specify that certain pods should be placed in the same topological domain (e.g. same node, same rack, same zone, same power domain, etc.)
     */
    podAntiAffinity?: outputs.VirtualMachineAffinityPodAntiAffinity;
}

export interface VirtualMachineAffinityNodeAffinity {
    /**
     * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
     */
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    /**
     * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a node label update), the system may or may not try to eventually evict the pod from its node.
     */
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * A node selector term, associated with the corresponding weight.
     */
    preference: outputs.VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    /**
     * weight is in the range 1-100
     */
    weight: number;
}

export interface VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * List of node selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
}

export interface VirtualMachineAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
     */
    operator?: string;
    /**
     * Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * List of node selector terms. The terms are ORed.
     */
    nodeSelectorTerms?: outputs.VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    /**
     * List of node selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
}

export interface VirtualMachineAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
     */
    operator?: string;
    /**
     * Values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineAffinityPodAffinity {
    /**
     * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
     */
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    /**
     * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
     */
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * A pod affinity term, associated with the corresponding weight
     */
    podAffinityTerm: outputs.VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    /**
     * weight associated with matching the corresponding podAffinityTerm, in the range 1-100
     */
    weight: number;
}

export interface VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * A label query over a set of resources, in this case pods.
     */
    labelSelectors?: outputs.VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector[];
    /**
     * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
     */
    namespaces?: string[];
    /**
     * empty topology key is interpreted by the scheduler as 'all topologies'
     */
    topologyKey?: string;
}

export interface VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface VirtualMachineAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * A label query over a set of resources, in this case pods.
     */
    labelSelectors?: outputs.VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector[];
    /**
     * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
     */
    namespaces?: string[];
    /**
     * empty topology key is interpreted by the scheduler as 'all topologies'
     */
    topologyKey?: string;
}

export interface VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface VirtualMachineAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineAffinityPodAntiAffinity {
    /**
     * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, RequiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding MatchExpressions; the node(s) with the highest sum are the most preferred.
     */
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    /**
     * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each PodAffinityTerm are intersected, i.e. all terms must be satisfied.
     */
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * A pod affinity term, associated with the corresponding weight
     */
    podAffinityTerm: outputs.VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    /**
     * weight associated with matching the corresponding podAffinityTerm, in the range 1-100
     */
    weight: number;
}

export interface VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * A label query over a set of resources, in this case pods.
     */
    labelSelectors?: outputs.VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector[];
    /**
     * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
     */
    namespaces?: string[];
    /**
     * empty topology key is interpreted by the scheduler as 'all topologies'
     */
    topologyKey?: string;
}

export interface VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface VirtualMachineAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * A label query over a set of resources, in this case pods.
     */
    labelSelectors?: outputs.VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector[];
    /**
     * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means 'this pod's namespace'
     */
    namespaces?: string[];
    /**
     * empty topology key is interpreted by the scheduler as 'all topologies'
     */
    topologyKey?: string;
}

export interface VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface VirtualMachineAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineCpu {
    /**
     * Cores is the number of cores inside the vmi. Must be a value greater or equal 1
     */
    cores?: number;
    /**
     * Sockets is the number of sockets inside the vmi. Must be a value greater or equal 1.
     */
    sockets?: number;
    /**
     * Threads is the number of threads inside the vmi. Must be a value greater or equal 1.
     */
    threads?: number;
}

export interface VirtualMachineDataVolumeTemplate {
    /**
     * Standard DataVolume's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
     */
    metadata: outputs.VirtualMachineDataVolumeTemplateMetadata;
    /**
     * DataVolumeSpec defines our specification for a DataVolume type
     */
    spec: outputs.VirtualMachineDataVolumeTemplateSpec;
}

export interface VirtualMachineDataVolumeTemplateMetadata {
    /**
     * An unstructured key value map stored with the DataVolume that may be used to store arbitrary metadata. More info: http://kubernetes.io/docs/user-guide/annotations
     */
    annotations: {[key: string]: string};
    /**
     * A sequence number representing a specific generation of the desired state.
     */
    generation: number;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) the DataVolume. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
     */
    labels?: {[key: string]: string};
    /**
     * Name of the DataVolume, must be unique. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
     */
    name: string;
    /**
     * Namespace defines the space within which name of the DataVolume must be unique.
     */
    namespace?: string;
    /**
     * An opaque value that represents the internal version of this DataVolume that can be used by clients to determine when DataVolume has changed. Read more: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
     */
    resourceVersion: string;
    /**
     * A URL representing this DataVolume.
     */
    selfLink: string;
    /**
     * The unique in time and space value for this DataVolume. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
     */
    uid: string;
}

export interface VirtualMachineDataVolumeTemplateSpec {
    /**
     * ContentType options: "kubevirt", "archive".
     */
    contentType?: string;
    /**
     * PVC is a pointer to the PVC Spec we want to use.
     */
    pvc: outputs.VirtualMachineDataVolumeTemplateSpecPvc;
    /**
     * Source is the src of the data for the requested DataVolume.
     */
    source?: outputs.VirtualMachineDataVolumeTemplateSpecSource;
}

export interface VirtualMachineDataVolumeTemplateSpecPvc {
    /**
     * A set of the desired access modes the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1
     */
    accessModes: string[];
    /**
     * A list of the minimum resources the volume should have. More info: http://kubernetes.io/docs/user-guide/persistent-volumes#resources
     */
    resources: outputs.VirtualMachineDataVolumeTemplateSpecPvcResources;
    /**
     * A label query over volumes to consider for binding.
     */
    selector?: outputs.VirtualMachineDataVolumeTemplateSpecPvcSelector;
    /**
     * Name of the storage class requested by the claim
     */
    storageClassName: string;
    /**
     * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
     */
    volumeMode: string;
    /**
     * The binding reference to the PersistentVolume backing this claim.
     */
    volumeName: string;
}

export interface VirtualMachineDataVolumeTemplateSpecPvcResources {
    /**
     * Map describing the maximum amount of compute resources allowed. More info: http://kubernetes.io/docs/user-guide/compute-resources/
     */
    limits?: {[key: string]: string};
    /**
     * Map describing the minimum amount of compute resources required. If this is omitted for a container, it defaults to `limits` if that is explicitly specified, otherwise to an implementation-defined value. More info: http://kubernetes.io/docs/user-guide/compute-resources/
     */
    requests?: {[key: string]: string};
}

export interface VirtualMachineDataVolumeTemplateSpecPvcSelector {
    /**
     * A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.VirtualMachineDataVolumeTemplateSpecPvcSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of `match_expressions`, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface VirtualMachineDataVolumeTemplateSpecPvcSelectorMatchExpression {
    /**
     * The label key that the selector applies to.
     */
    key?: string;
    /**
     * A key's relationship to a set of values. Valid operators ard `In`, `NotIn`, `Exists` and `DoesNotExist`.
     */
    operator?: string;
    /**
     * An array of string values. If the operator is `In` or `NotIn`, the values array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the values array must be empty. This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface VirtualMachineDataVolumeTemplateSpecSource {
    /**
     * DataVolumeSourceBlank provides the parameters to create a Data Volume from an empty source.
     */
    blank?: outputs.VirtualMachineDataVolumeTemplateSpecSourceBlank;
    /**
     * DataVolumeSourceHTTP provides the parameters to create a Data Volume from an HTTP source.
     */
    http?: outputs.VirtualMachineDataVolumeTemplateSpecSourceHttp;
    /**
     * DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC.
     */
    pvc?: outputs.VirtualMachineDataVolumeTemplateSpecSourcePvc;
    /**
     * DataVolumeSourceRegistry provides the parameters to create a Data Volume from an existing PVC.
     */
    registry?: outputs.VirtualMachineDataVolumeTemplateSpecSourceRegistry;
}

export interface VirtualMachineDataVolumeTemplateSpecSourceBlank {
}

export interface VirtualMachineDataVolumeTemplateSpecSourceHttp {
    /**
     * Cert_config_map provides a reference to the Registry certs.
     */
    certConfigMap?: string;
    /**
     * Secret_ref provides the secret reference needed to access the HTTP source.
     */
    secretRef?: string;
    /**
     * url is the URL of the http source.
     */
    url?: string;
}

export interface VirtualMachineDataVolumeTemplateSpecSourcePvc {
    /**
     * The name of the PVC.
     */
    name?: string;
    /**
     * The namespace which the PVC located in.
     */
    namespace?: string;
}

export interface VirtualMachineDataVolumeTemplateSpecSourceRegistry {
    /**
     * The registry URL of the image to download.
     */
    imageUrl?: string;
}

export interface VirtualMachineDisk {
    /**
     * DiskDevice specifies as which device the disk should be added to the guest.
     */
    diskDevices: outputs.VirtualMachineDiskDiskDevice[];
    /**
     * Name is the device name
     */
    name: string;
    /**
     * Serial provides the ability to specify a serial number for the disk device.
     */
    serial?: string;
}

export interface VirtualMachineDiskDiskDevice {
    /**
     * Attach a volume as a disk to the vmi.
     */
    disks?: outputs.VirtualMachineDiskDiskDeviceDisk[];
}

export interface VirtualMachineDiskDiskDeviceDisk {
    /**
     * Bus indicates the type of disk device to emulate.
     */
    bus: string;
    /**
     * If specified, the virtual disk will be placed on the guests pci address with the specifed PCI address. For example: 0000:81:01.10
     */
    pciAddress?: string;
    /**
     * ReadOnly. Defaults to false.
     */
    readOnly?: boolean;
}

export interface VirtualMachineInterface {
    /**
     * Represents the Interface model, One of: e1000, e1000e, ne2k_pci, pcnet, rtl8139, virtio. Defaults to virtio.
     */
    interfaceBindingMethod: string;
    /**
     * Represents the method which will be used to connect the interface to the guest.
     */
    model?: string;
    /**
     * Logical name of the interface as well as a reference to the associated networks.
     */
    name: string;
}

export interface VirtualMachineLivenessProbe {
}

export interface VirtualMachineMemory {
    /**
     * Guest is the amount of memory allocated to the vmi. This value must be less than or equal to the limit if specified.
     */
    guest?: string;
    /**
     * Hugepages attribute specifies the hugepage size, for x86_64 architecture valid values are 1Gi and 2Mi.
     */
    hugepages?: string;
}

export interface VirtualMachineNetwork {
    /**
     * Network name.
     */
    name: string;
    /**
     * NetworkSource represents the network type and the source interface that should be connected to the virtual machine.
     */
    networkSource?: outputs.VirtualMachineNetworkNetworkSource;
}

export interface VirtualMachineNetworkNetworkSource {
    /**
     * Multus network.
     */
    multus?: outputs.VirtualMachineNetworkNetworkSourceMultus;
    /**
     * Pod network.
     */
    pod?: outputs.VirtualMachineNetworkNetworkSourcePod;
}

export interface VirtualMachineNetworkNetworkSourceMultus {
    /**
     * Select the default network and add it to the multus-cni.io/default-network annotation.
     */
    default?: boolean;
    /**
     * References to a NetworkAttachmentDefinition CRD object. Format: <networkName>, <namespace>/<networkName>. If namespace is not specified, VMI namespace is assumed.
     */
    networkName: string;
}

export interface VirtualMachineNetworkNetworkSourcePod {
    /**
     * CIDR for vm network.
     */
    vmNetworkCidr?: string;
}

export interface VirtualMachinePodDnsConfig {
    /**
     * A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
     */
    nameservers?: string[];
    /**
     * A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
     */
    options?: outputs.VirtualMachinePodDnsConfigOption[];
    /**
     * A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
     */
    searches?: string[];
}

export interface VirtualMachinePodDnsConfigOption {
    /**
     * Name of the option.
     */
    name: string;
    /**
     * Value of the option. Optional: Defaults to empty.
     */
    value?: string;
}

export interface VirtualMachineReadinessProbe {
}

export interface VirtualMachineResources {
    /**
     * Requests is the maximum amount of compute resources allowed. Valid resource keys are "memory" and "cpu"
     */
    limits?: {[key: string]: string};
    /**
     * Don't ask the scheduler to take the guest-management overhead into account. Instead put the overhead only into the container's memory limit. This can lead to crashes if all memory is in use on a node. Defaults to false.
     */
    overCommitGuestOverhead?: boolean;
    /**
     * Requests is a description of the initial vmi resources.
     */
    requests?: {[key: string]: string};
}

export interface VirtualMachineStatus {
    /**
     * Hold the state information of the VirtualMachine and its VirtualMachineInstance.
     */
    conditions: outputs.VirtualMachineStatusCondition[];
    /**
     * Created indicates if the virtual machine is created in the cluster.
     */
    created?: boolean;
    /**
     * Ready indicates if the virtual machine is running and ready.
     */
    ready?: boolean;
    /**
     * StateChangeRequests indicates a list of actions that should be taken on a VMI.
     */
    stateChangeRequests: outputs.VirtualMachineStatusStateChangeRequest[];
}

export interface VirtualMachineStatusCondition {
    /**
     * Condition message.
     */
    message?: string;
    /**
     * Condition reason.
     */
    reason?: string;
    /**
     * ConditionStatus represents the status of this VM condition, if the VM currently in the condition.
     */
    status?: string;
    /**
     * VirtualMachineConditionType represent the type of the VM as concluded from its VMi status.
     */
    type?: string;
}

export interface VirtualMachineStatusStateChangeRequest {
    /**
     * Indicates the type of action that is requested. e.g. Start or Stop.
     */
    action?: string;
    /**
     * Provides additional data in order to perform the Action.
     */
    data?: {[key: string]: string};
    /**
     * Indicates the UUID of an existing Virtual Machine Instance that this change request applies to -- if applicable.
     */
    uid?: string;
}

export interface VirtualMachineTimeouts {
    create?: string;
    delete?: string;
}

export interface VirtualMachineToleration {
    /**
     * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
     */
    effect?: string;
    /**
     * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
     */
    key?: string;
    /**
     * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
     */
    operator?: string;
    /**
     * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
     */
    tolerationSeconds?: string;
    /**
     * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
     */
    value?: string;
}

export interface VirtualMachineVolume {
    /**
     * Volume's name.
     */
    name: string;
    /**
     * VolumeSource represents the location and type of the mounted volume. Defaults to Disk, if no type is specified.
     */
    volumeSource: outputs.VirtualMachineVolumeVolumeSource;
}

export interface VirtualMachineVolumeVolumeSource {
    /**
     * CloudInitConfigDrive represents a cloud-init Config Drive user-data source.
     */
    cloudInitConfigDrive?: outputs.VirtualMachineVolumeVolumeSourceCloudInitConfigDrive;
    /**
     * Used to specify a cloud-init `noCloud` image. The image is expected to contain a disk image in a supported format. The disk image is extracted from the cloud-init `noCloud `image and used as the disk for the VM
     */
    cloudInitNoClouds?: outputs.VirtualMachineVolumeVolumeSourceCloudInitNoCloud[];
    /**
     * ConfigMapVolumeSource adapts a ConfigMap into a volume.
     */
    configMap?: outputs.VirtualMachineVolumeVolumeSourceConfigMap;
    /**
     * A container disk is a disk that is backed by a container image. The container image is expected to contain a disk image in a supported format. The disk image is extracted from the container image and used as the disk for the VM.
     */
    containerDisks?: outputs.VirtualMachineVolumeVolumeSourceContainerDisk[];
    /**
     * DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.
     */
    dataVolume?: outputs.VirtualMachineVolumeVolumeSourceDataVolume;
    /**
     * EmptyDisk represents a temporary disk which shares the VM's lifecycle.
     */
    emptyDisk?: outputs.VirtualMachineVolumeVolumeSourceEmptyDisk;
    /**
     * EphemeralVolumeSource represents a volume that is populated with the contents of a pod. Ephemeral volumes do not support ownership management or SELinux relabeling.
     */
    ephemeral?: outputs.VirtualMachineVolumeVolumeSourceEphemeral;
    /**
     * HostDisk represents a disk created on the host.
     */
    hostDisk?: outputs.VirtualMachineVolumeVolumeSourceHostDisk;
    /**
     * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
     */
    persistentVolumeClaim?: outputs.VirtualMachineVolumeVolumeSourcePersistentVolumeClaim;
    /**
     * ServiceAccountVolumeSource represents a reference to a service account.
     */
    serviceAccount?: outputs.VirtualMachineVolumeVolumeSourceServiceAccount;
}

export interface VirtualMachineVolumeVolumeSourceCloudInitConfigDrive {
    /**
     * NetworkData contains config drive inline cloud-init networkdata.
     */
    networkData?: string;
    /**
     * NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
     */
    networkDataBase64?: string;
    /**
     * NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
     */
    networkDataSecretRef?: outputs.VirtualMachineVolumeVolumeSourceCloudInitConfigDriveNetworkDataSecretRef;
    /**
     * UserData contains config drive inline cloud-init userdata.
     */
    userData?: string;
    /**
     * UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
     */
    userDataBase64?: string;
    /**
     * UserDataSecretRef references a k8s secret that contains config drive userdata.
     */
    userDataSecretRef?: outputs.VirtualMachineVolumeVolumeSourceCloudInitConfigDriveUserDataSecretRef;
}

export interface VirtualMachineVolumeVolumeSourceCloudInitConfigDriveNetworkDataSecretRef {
    /**
     * Name of the referent.
     */
    name: string;
}

export interface VirtualMachineVolumeVolumeSourceCloudInitConfigDriveUserDataSecretRef {
    /**
     * Name of the referent.
     */
    name: string;
}

export interface VirtualMachineVolumeVolumeSourceCloudInitNoCloud {
    /**
     * The user data to use for the cloud-init no cloud disk. This can be a local file path, a remote URL, or a registry URL.
     */
    userData: string;
}

export interface VirtualMachineVolumeVolumeSourceConfigMap {
    /**
     * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
     */
    defaultMode?: number;
    /**
     * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
     */
    items?: outputs.VirtualMachineVolumeVolumeSourceConfigMapItem[];
}

export interface VirtualMachineVolumeVolumeSourceConfigMapItem {
    key?: string;
}

export interface VirtualMachineVolumeVolumeSourceContainerDisk {
    /**
     * The URL of the container image to use as the disk. This can be a local file path, a remote URL, or a registry URL.
     */
    imageUrl: string;
}

export interface VirtualMachineVolumeVolumeSourceDataVolume {
    /**
     * Name represents the name of the DataVolume in the same namespace.
     */
    name: string;
}

export interface VirtualMachineVolumeVolumeSourceEmptyDisk {
    /**
     * Capacity of the sparse disk.
     */
    capacity: string;
}

export interface VirtualMachineVolumeVolumeSourceEphemeral {
    /**
     * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace.
     */
    persistentVolumeClaim?: outputs.VirtualMachineVolumeVolumeSourceEphemeralPersistentVolumeClaim;
}

export interface VirtualMachineVolumeVolumeSourceEphemeralPersistentVolumeClaim {
    /**
     * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
     */
    claimName: string;
    /**
     * Will force the ReadOnly setting in VolumeMounts. Default false.
     */
    readOnly?: boolean;
}

export interface VirtualMachineVolumeVolumeSourceHostDisk {
    /**
     * Path of the disk.
     */
    path: string;
    /**
     * Type of the disk, supported values are disk, directory, socket, char, block.
     */
    type: string;
}

export interface VirtualMachineVolumeVolumeSourcePersistentVolumeClaim {
    /**
     * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
     */
    claimName: string;
    /**
     * Will force the ReadOnly setting in VolumeMounts. Default false.
     */
    readOnly?: boolean;
}

export interface VirtualMachineVolumeVolumeSourceServiceAccount {
    /**
     * Name of the service account in the pod's namespace to use.
     */
    serviceAccountName: string;
}

export interface WorkspaceBackupPolicy {
    /**
     * The ID of the backup location to use for the backup.
     */
    backupLocationId: string;
    /**
     * The list of cluster UIDs to include in the backup. If `include_all_clusters` is set to `true`, then all clusters will be included.
     */
    clusterUids?: string[];
    /**
     * The number of hours after which the backup will be deleted. For example, if the expiry is set to 24, the backup will be deleted after 24 hours.
     */
    expiryInHour: number;
    /**
     * Whether to include all clusters in the backup. If set to false, only the clusters specified in `cluster_uids` will be included.
     */
    includeAllClusters?: boolean;
    /**
     * Whether to include the cluster resources in the backup. If set to false, only the cluster configuration and disks will be backed up. (Note: Starting with Palette version 4.6, the `include_cluster_resources` attribute will be changed to a string type, supporting the values `always`, `never`, and `auto`.)
     */
    includeClusterResources?: boolean;
    /**
     * Whether to include the disks in the backup. If set to false, only the cluster configuration will be backed up.
     */
    includeDisks?: boolean;
    /**
     * The list of Kubernetes namespaces to include in the backup. If not specified, all namespaces will be included.
     */
    namespaces?: string[];
    /**
     * Prefix for the backup name. The backup name will be of the format <prefix>-<cluster-name>-<timestamp>.
     */
    prefix: string;
    /**
     * The schedule for the backup. The schedule is specified in cron format. For example, to run the backup every day at 1:00 AM, the schedule should be set to `0 1 * * *`.
     */
    schedule: string;
}

export interface WorkspaceCluster {
    uid: string;
}

export interface WorkspaceClusterRbacBinding {
    /**
     * The Kubernetes namespace of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    namespace?: string;
    /**
     * The role of the RBAC binding. Required if 'type' is set to 'RoleBinding'.
     */
    role?: {[key: string]: string};
    subjects?: outputs.WorkspaceClusterRbacBindingSubject[];
    /**
     * The type of the RBAC binding. Can be one of the following values: `RoleBinding`, or `ClusterRoleBinding`.
     */
    type: string;
}

export interface WorkspaceClusterRbacBindingSubject {
    /**
     * The name of the subject. Required if 'type' is set to 'User' or 'Group'.
     */
    name: string;
    /**
     * The Kubernetes namespace of the subject. Required if 'type' is set to 'ServiceAccount'.
     */
    namespace?: string;
    /**
     * The type of the subject. Can be one of the following values: `User`, `Group`, or `ServiceAccount`.
     */
    type: string;
}

export interface WorkspaceNamespace {
    /**
     * List of images to disallow for the namespace. For example, `['nginx:latest', 'redis:latest']`
     */
    imagesBlacklists?: string[];
    /**
     * Name of the namespace. This is the name of the Kubernetes namespace in the cluster.
     */
    name: string;
    /**
     * Resource allocation for the namespace. This is a map containing the resource type and the resource value. For example, `{cpu_cores: '2', memory_MiB: '2048'}`
     */
    resourceAllocation: {[key: string]: string};
}

