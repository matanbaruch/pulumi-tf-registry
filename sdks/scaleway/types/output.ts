// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppleSiliconServerTimeouts {
    create?: string;
    default?: string;
}

export interface BaremetalServerIp {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface BaremetalServerIpv4 {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface BaremetalServerIpv6 {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface BaremetalServerOption {
    /**
     * Auto expire the option after this date
     */
    expiresAt: string;
    /**
     * IDs of the options
     */
    id: string;
    /**
     * name of the option
     */
    name: string;
}

export interface BaremetalServerPrivateNetwork {
    /**
     * The date and time of the creation of the private network
     */
    createdAt: string;
    /**
     * The private network ID
     */
    id: string;
    /**
     * The private network status
     */
    status: string;
    /**
     * The date and time of the last update of the private network
     */
    updatedAt: string;
    /**
     * The VLAN ID associated to the private network
     */
    vlan: number;
}

export interface BaremetalServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface BlockSnapshotTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface BlockVolumeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface CockpitAlertManagerContactPoint {
    /**
     * Email addresses for the alert receivers
     */
    email?: string;
}

export interface CockpitEndpoint {
    alertmanagerUrl: string;
    grafanaUrl: string;
    logsUrl: string;
    metricsUrl: string;
    tracesUrl: string;
}

export interface CockpitGrafanaUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface CockpitPushUrl {
    pushLogsUrl: string;
    pushMetricsUrl: string;
}

export interface CockpitSourceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface CockpitTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface CockpitTokenScopes {
    /**
     * Query logs
     */
    queryLogs?: boolean;
    /**
     * Query metrics
     */
    queryMetrics?: boolean;
    /**
     * Query traces
     */
    queryTraces?: boolean;
    /**
     * Setup alerts
     */
    setupAlerts?: boolean;
    /**
     * Setup logs rules
     */
    setupLogsRules?: boolean;
    /**
     * Setup metrics rules
     */
    setupMetricsRules?: boolean;
    /**
     * Write logs
     */
    writeLogs?: boolean;
    /**
     * Write metrics
     */
    writeMetrics?: boolean;
    /**
     * Write traces
     */
    writeTraces?: boolean;
}

export interface CockpitTokenTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

export interface ContainerCronTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerDomainTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerNamespaceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ContainerTriggerNats {
    /**
     * ID of the mnq nats account
     */
    accountId?: string;
    /**
     * Project ID of the project where the mnq sqs exists, defaults to provider project_id
     */
    projectId: string;
    /**
     * Region where the mnq sqs exists, defaults to function's region
     */
    region: string;
    /**
     * Subject to listen to
     */
    subject: string;
}

export interface ContainerTriggerSqs {
    /**
     * ID of the mnq namespace
     *
     * @deprecated Deprecated
     */
    namespaceId?: string;
    /**
     * Project ID of the project where the mnq sqs exists, defaults to provider project_id
     */
    projectId: string;
    /**
     * Name of the queue
     */
    queue: string;
    /**
     * Region where the mnq sqs exists, defaults to function's region
     */
    region: string;
}

export interface ContainerTriggerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DocumentdbDatabaseTimeouts {
    create?: string;
    default?: string;
    delete?: string;
}

export interface DocumentdbInstanceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DocumentdbPrivateNetworkEndpointPrivateNetwork {
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The private network ID
     */
    id: string;
    /**
     * The IP of your private network service
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of your private service
     */
    name: string;
    /**
     * The port of your private service
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface DocumentdbPrivateNetworkEndpointTimeouts {
    default?: string;
}

export interface DocumentdbPrivilegeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DocumentdbReadReplicaDirectAccess {
    /**
     * UUID of the endpoint (UUID format).
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface DocumentdbReadReplicaPrivateNetwork {
    /**
     * UUID of the endpoint (UUID format).
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set
     */
    ip: string;
    /**
     * Name of the endpoints
     */
    name: string;
    /**
     * TCP port of the endpoint
     */
    port: number;
    /**
     * UUID of the private network to be connected to the read replica (UUID format)
     */
    privateNetworkId: string;
    /**
     * The IP network address within the private subnet
     */
    serviceIp: string;
    /**
     * Private network zone
     */
    zone: string;
}

export interface DocumentdbReadReplicaTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DocumentdbUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DomainRecordGeoIp {
    /**
     * The list of matches
     */
    matches: outputs.DomainRecordGeoIpMatch[];
}

export interface DomainRecordGeoIpMatch {
    /**
     * List of continents (eg: EU for Europe, NA for North America, AS for Asia...). List of all continents code: https://api.scaleway.com/domain-private/v2beta1/continents
     */
    continents?: string[];
    /**
     * List of countries (eg: FR for France, US for the United States, GB for Great Britain...). List of all countries code: https://api.scaleway.com/domain-private/v2beta1/countries
     */
    countries?: string[];
    /**
     * The data of the match result
     */
    data: string;
}

export interface DomainRecordHttpService {
    /**
     * IPs to check
     */
    ips: string[];
    /**
     * Text to search
     */
    mustContain: string;
    /**
     * Strategy to return an IP from the IPs list
     */
    strategy: string;
    /**
     * URL to match the must_contain text to validate an IP
     */
    url: string;
    /**
     * User-agent used when checking the URL
     */
    userAgent?: string;
}

export interface DomainRecordTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DomainRecordView {
    /**
     * The data of the view record
     */
    data: string;
    /**
     * The subnet of the view
     */
    subnet: string;
}

export interface DomainRecordWeighted {
    /**
     * The weighted IP
     */
    ip: string;
    /**
     * The weight of the IP
     */
    weight: number;
}

export interface DomainZoneTimeouts {
    default?: string;
}

export interface FlexibleIpMacAddressTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FlexibleIpTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionCronTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionDomainTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionNamespaceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface FunctionTriggerNats {
    /**
     * ID of the mnq nats account
     */
    accountId?: string;
    /**
     * Project ID of the project where the mnq sqs exists, defaults to provider project_id
     */
    projectId: string;
    /**
     * Region where the mnq sqs exists, defaults to function's region
     */
    region: string;
    /**
     * Subject to listen to
     */
    subject: string;
}

export interface FunctionTriggerSqs {
    /**
     * ID of the mnq namespace
     *
     * @deprecated Deprecated
     */
    namespaceId?: string;
    /**
     * Project ID of the project where the mnq sqs exists, defaults to provider project_id
     */
    projectId: string;
    /**
     * Name of the queue
     */
    queue: string;
    /**
     * Region where the mnq sqs exists, defaults to function's region
     */
    region: string;
}

export interface FunctionTriggerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GetAvailabilityZonesTimeouts {
    read?: string;
}

export interface GetBaremetalOfferCpus {
    coreCount: number;
    frequency: number;
    name: string;
    threadCount: number;
}

export interface GetBaremetalOfferDisk {
    capacity: number;
    type: string;
}

export interface GetBaremetalOfferMemory {
    capacity: number;
    frequency: number;
    isEcc: boolean;
    type: string;
}

export interface GetBaremetalServerIp {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface GetBaremetalServerIpv4 {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface GetBaremetalServerIpv6 {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface GetBaremetalServerOption {
    expiresAt: string;
    id: string;
    name: string;
}

export interface GetBaremetalServerPrivateNetwork {
    createdAt: string;
    id: string;
    status: string;
    updatedAt: string;
    vlan: number;
}

export interface GetBillingConsumptionsConsumption {
    billedQuantity: string;
    categoryName: string;
    productName: string;
    projectId: string;
    sku: string;
    unit: string;
    value: string;
}

export interface GetBillingInvoicesInvoice {
    billingPeriod: string;
    dueDate: string;
    id: string;
    invoiceType: string;
    issuedDate: string;
    number: number;
    organizationName: string;
    sellerName: string;
    startDate: string;
    state: string;
    stopDate: string;
    totalDiscount: string;
    totalTax: string;
    totalTaxed: string;
    totalUndiscount: string;
    totalUntaxed: string;
}

export interface GetCockpitEndpoint {
    alertmanagerUrl: string;
    grafanaUrl: string;
    logsUrl: string;
    metricsUrl: string;
    tracesUrl: string;
}

export interface GetCockpitPushUrl {
    pushLogsUrl: string;
    pushMetricsUrl: string;
}

export interface GetDomainRecordGeoIp {
    matches: outputs.GetDomainRecordGeoIpMatch[];
}

export interface GetDomainRecordGeoIpMatch {
    continents: string[];
    countries: string[];
    data: string;
}

export interface GetDomainRecordHttpService {
    ips: string[];
    mustContain: string;
    strategy: string;
    url: string;
    userAgent: string;
}

export interface GetDomainRecordView {
    data: string;
    subnet: string;
}

export interface GetDomainRecordWeighted {
    ip: string;
    weight: number;
}

export interface GetFlexibleIpsIp {
    createdAt: string;
    description: string;
    id: string;
    ipAddress: string;
    macAddresses: outputs.GetFlexibleIpsIpMacAddress[];
    organizationId: string;
    projectId: string;
    reverse: string;
    status: string;
    tags: string[];
    updatedAt: string;
    zone: string;
}

export interface GetFlexibleIpsIpMacAddress {
    createdAt: string;
    id: string;
    macAddress: string;
    macType: string;
    status: string;
    updatedAt: string;
    zone: string;
}

export interface GetInstanceSecurityGroupInboundRule {
    action: string;
    ip: string;
    ipRange: string;
    port: number;
    portRange: string;
    protocol: string;
}

export interface GetInstanceSecurityGroupOutboundRule {
    action: string;
    ip: string;
    ipRange: string;
    port: number;
    portRange: string;
    protocol: string;
}

export interface GetInstanceServerPrivateNetwork {
    macAddress: string;
    pnId: string;
    pnicId: string;
    status: string;
    zone: string;
}

export interface GetInstanceServerPublicIp {
    address: string;
    id: string;
}

export interface GetInstanceServerRootVolume {
    boot: boolean;
    deleteOnTermination: boolean;
    name: string;
    sizeInGb: number;
    volumeId: string;
    volumeType: string;
}

export interface GetInstanceServersServer {
    bootType: string;
    bootscriptId: string;
    enableDynamicIp: boolean;
    enableIpv6: boolean;
    id: string;
    image: string;
    ipv6Address: string;
    ipv6Gateway: string;
    ipv6PrefixLength: number;
    name: string;
    organizationId: string;
    placementGroupId: string;
    placementGroupPolicyRespected: boolean;
    privateIp: string;
    projectId: string;
    publicIp: string;
    publicIps: outputs.GetInstanceServersServerPublicIp[];
    routedIpEnabled: boolean;
    securityGroupId: string;
    state: string;
    tags: string[];
    type: string;
    zone: string;
}

export interface GetInstanceServersServerPublicIp {
    address: string;
    id: string;
}

export interface GetInstanceSnapshotImport {
    bucket: string;
    key: string;
}

export interface GetIotDeviceCertificate {
    crt: string;
    key: string;
}

export interface GetIotDeviceMessageFilter {
    publishes: outputs.GetIotDeviceMessageFilterPublish[];
    subscribes: outputs.GetIotDeviceMessageFilterSubscribe[];
}

export interface GetIotDeviceMessageFilterPublish {
    policy: string;
    topics: string[];
}

export interface GetIotDeviceMessageFilterSubscribe {
    policy: string;
    topics: string[];
}

export interface GetIpamIpResource {
    /**
     * ID of the resource to filter for
     */
    id?: string;
    /**
     * Name of the resource to filter for
     */
    name?: string;
    /**
     * Type of resource to filter for
     */
    type: string;
}

export interface GetIpamIpsIp {
    address: string;
    createdAt: string;
    id: string;
    projectId: string;
    region: string;
    resources: outputs.GetIpamIpsIpResource[];
    tags: string[];
    updatedAt: string;
    zone: string;
}

export interface GetIpamIpsIpResource {
    id: string;
    macAddress: string;
    name: string;
    type: string;
}

export interface GetIpamIpsResource {
    /**
     * ID of the resource to filter for
     */
    id?: string;
    /**
     * Name of the resource to filter for
     */
    name?: string;
    /**
     * Type of resource to filter for
     */
    type: string;
}

export interface GetK8sClusterAutoUpgrade {
    enable: boolean;
    maintenanceWindowDay: string;
    maintenanceWindowStartHour: number;
}

export interface GetK8sClusterAutoscalerConfig {
    balanceSimilarNodeGroups: boolean;
    disableScaleDown: boolean;
    estimator: string;
    expander: string;
    expendablePodsPriorityCutoff: number;
    ignoreDaemonsetsUtilization: boolean;
    maxGracefulTerminationSec: number;
    scaleDownDelayAfterAdd: string;
    scaleDownUnneededTime: string;
    scaleDownUtilizationThreshold: number;
}

export interface GetK8sClusterKubeconfig {
    clusterCaCertificate: string;
    configFile: string;
    host: string;
    token: string;
}

export interface GetK8sClusterOpenIdConnectConfig {
    clientId: string;
    groupsClaims: string[];
    groupsPrefix: string;
    issuerUrl: string;
    requiredClaims: string[];
    usernameClaim: string;
    usernamePrefix: string;
}

export interface GetK8sPoolNode {
    name: string;
    publicIp: string;
    publicIpV6: string;
    status: string;
}

export interface GetK8sPoolUpgradePolicy {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetLbAclsAcl {
    actions: outputs.GetLbAclsAclAction[];
    createdAt: string;
    description: string;
    frontendId: string;
    id: string;
    index: number;
    matches: outputs.GetLbAclsAclMatch[];
    name: string;
    updateAt: string;
}

export interface GetLbAclsAclAction {
    redirects: outputs.GetLbAclsAclActionRedirect[];
    type: string;
}

export interface GetLbAclsAclActionRedirect {
    code: number;
    target: string;
    type: string;
}

export interface GetLbAclsAclMatch {
    httpFilter: string;
    httpFilterOption: string;
    httpFilterValues: string[];
    invert: boolean;
    ipSubnets: string[];
}

export interface GetLbBackendHealthCheckHttp {
    code: number;
    hostHeader: string;
    method: string;
    sni: string;
    uri: string;
}

export interface GetLbBackendHealthCheckTcp {
}

export interface GetLbBackendsBackend {
    createdAt: string;
    failoverHost: string;
    forwardPort: number;
    forwardPortAlgorithm: string;
    forwardProtocol: string;
    healthCheckDelay: string;
    healthCheckHttp: outputs.GetLbBackendsBackendHealthCheckHttp[];
    healthCheckHttps: outputs.GetLbBackendsBackendHealthCheckHttp[];
    healthCheckMaxRetries: number;
    healthCheckPort: number;
    healthCheckTcps: outputs.GetLbBackendsBackendHealthCheckTcp[];
    healthCheckTimeout: string;
    id: string;
    ignoreSslServerVerify: boolean;
    lbId: string;
    name: string;
    onMarkedDownAction: string;
    proxyProtocol: string;
    serverIps: string[];
    sslBridging: boolean;
    stickySessions: string;
    stickySessionsCookieName: string;
    timeoutConnect: string;
    timeoutServer: string;
    timeoutTunnel: string;
    updateAt: string;
}

export interface GetLbBackendsBackendHealthCheckHttp {
    code: number;
    hostHeader: string;
    method: string;
    sni: string;
    uri: string;
}

export interface GetLbBackendsBackendHealthCheckTcp {
}

export interface GetLbCertificateCustomCertificate {
    certificateChain: string;
}

export interface GetLbCertificateLetsencrypt {
    commonName: string;
    subjectAlternativeNames: string[];
}

export interface GetLbFrontendAcl {
    actions: outputs.GetLbFrontendAclAction[];
    createdAt: string;
    description: string;
    matches: outputs.GetLbFrontendAclMatch[];
    name: string;
    updatedAt: string;
}

export interface GetLbFrontendAclAction {
    redirects: outputs.GetLbFrontendAclActionRedirect[];
    type: string;
}

export interface GetLbFrontendAclActionRedirect {
    code: number;
    target: string;
    type: string;
}

export interface GetLbFrontendAclMatch {
    httpFilter: string;
    httpFilterOption: string;
    httpFilterValues: string[];
    invert: boolean;
    ipSubnets: string[];
}

export interface GetLbFrontendsFrontend {
    backendId: string;
    certificateIds: string[];
    createdAt: string;
    enableHttp3: boolean;
    id: string;
    inboundPort: number;
    lbId: string;
    name: string;
    timeoutClient: string;
    updateAt: string;
}

export interface GetLbIpsIp {
    id: string;
    ipAddress: string;
    lbId: string;
    organizationId: string;
    projectId: string;
    reverse: string;
    tags: string[];
    zone: string;
}

export interface GetLbPrivateNetwork {
    dhcpConfig: boolean;
    ipamIds: string[];
    privateNetworkId: string;
    staticConfigs: string[];
    status: string;
    zone: string;
}

export interface GetLbRoutesRoute {
    backendId: string;
    createdAt: string;
    frontendId: string;
    id: string;
    matchHostHeader: string;
    matchSni: string;
    updateAt: string;
}

export interface GetLbsLb {
    backendCount: number;
    createdAt: string;
    description: string;
    frontendCount: number;
    id: string;
    instances: outputs.GetLbsLbInstance[];
    ips: outputs.GetLbsLbIp[];
    name: string;
    organizationId: string;
    privateNetworkCount: number;
    projectId: string;
    routeCount: number;
    sslCompatibilityLevel: string;
    status: string;
    subscriber: string;
    tags: string[];
    type: string;
    updatedAt: string;
    zone: string;
}

export interface GetLbsLbInstance {
    createdAt: string;
    id: string;
    ipAddress: string;
    status: string;
    updatedAt: string;
    zone: string;
}

export interface GetLbsLbIp {
    id: string;
    ipAddress: string;
    lbId: string;
    organizationId: string;
    projectId: string;
    reverse: string;
    zone: string;
}

export interface GetObjectBucketCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders: string[];
    maxAgeSeconds: number;
}

export interface GetObjectBucketLifecycleRule {
    abortIncompleteMultipartUploadDays: number;
    enabled: boolean;
    expirations: outputs.GetObjectBucketLifecycleRuleExpiration[];
    id: string;
    prefix: string;
    tags: {[key: string]: string};
    transitions: outputs.GetObjectBucketLifecycleRuleTransition[];
}

export interface GetObjectBucketLifecycleRuleExpiration {
    days: number;
}

export interface GetObjectBucketLifecycleRuleTransition {
    days: number;
    storageClass: string;
}

export interface GetObjectBucketVersioning {
    enabled: boolean;
}

export interface GetRdbAclAclRule {
    description: string;
    ip: string;
}

export interface GetRdbInstanceLoadBalancer {
    endpointId: string;
    hostname: string;
    ip: string;
    name: string;
    port: number;
}

export interface GetRdbInstanceLogsPolicy {
    maxAgeRetention: number;
    totalDiskRetention: number;
}

export interface GetRdbInstancePrivateNetwork {
    enableIpam: boolean;
    endpointId: string;
    hostname: string;
    ip: string;
    ipNet: string;
    name: string;
    pnId: string;
    port: number;
    zone: string;
}

export interface GetRdbInstanceReadReplica {
    ip: string;
    name: string;
    port: number;
}

export interface GetRedisClusterAcl {
    description: string;
    id: string;
    ip: string;
}

export interface GetRedisClusterPrivateNetwork {
    endpointId: string;
    id: string;
    serviceIps: string[];
    zone: string;
}

export interface GetRedisClusterPublicNetwork {
    id: string;
    ips: string[];
    port: number;
}

export interface GetTemDomainReputation {
    previousScore: number;
    previousScoredAt: string;
    score: number;
    scoredAt: string;
    status: string;
}

export interface GetVpcGatewayNetworkIpamConfig {
    ipamIpId: string;
    pushDefaultRoute: boolean;
}

export interface GetVpcPrivateNetworkIpv4Subnet {
    address: string;
    createdAt: string;
    id: string;
    prefixLength: number;
    subnet: string;
    subnetMask: string;
    updatedAt: string;
}

export interface GetVpcPrivateNetworkIpv6Subnet {
    address: string;
    createdAt: string;
    id: string;
    prefixLength: number;
    subnet: string;
    subnetMask: string;
    updatedAt: string;
}

export interface GetVpcRoutesRoute {
    createdAt: string;
    description: string;
    destination: string;
    id: string;
    nexthopIp: string;
    nexthopName: string;
    nexthopPrivateNetworkId: string;
    nexthopResourceId: string;
    nexthopResourceType: string;
    region: string;
    tags: string[];
    vpcId: string;
}

export interface GetVpcsVpc {
    createdAt: string;
    id: string;
    isDefault: boolean;
    name: string;
    organizationId: string;
    projectId: string;
    region: string;
    tags: string[];
    updateAt: string;
}

export interface GetWebhostingCpanelUrl {
    dashboard: string;
    webmail: string;
}

export interface GetWebhostingOfferProduct {
    databasesQuota: number;
    emailAccountsQuota: number;
    emailStorageQuota: number;
    hostingStorageQuota: number;
    name: string;
    option: boolean;
    ram: number;
    supportIncluded: boolean;
    vCpu: number;
}

export interface GetWebhostingOption {
    id: string;
    name: string;
}

export interface IamPolicyRule {
    /**
     * ID of organization scoped to the rule. Only one of project_ids and organization_id may be set.
     */
    organizationId?: string;
    /**
     * Names of permission sets bound to the rule.
     */
    permissionSetNames: string[];
    /**
     * List of project IDs scoped to the rule. Only one of project_ids and organization_id may be set.
     */
    projectIds?: string[];
}

export interface InstanceImageAdditionalVolume {
    creationDate: string;
    exportUri: string;
    id: string;
    modificationDate: string;
    name: string;
    organization: string;
    project: string;
    server: {[key: string]: string};
    size: number;
    state: string;
    tags: string[];
    volumeType: string;
    zone: string;
}

export interface InstanceImageTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface InstanceIpReverseDnsTimeouts {
    create?: string;
    default?: string;
    update?: string;
}

export interface InstanceIpTimeouts {
    default?: string;
}

export interface InstancePlacementGroupTimeouts {
    default?: string;
}

export interface InstancePrivateNicTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface InstanceSecurityGroupInboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
     *
     * @deprecated Deprecated
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
     *
     * @deprecated Deprecated
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesInboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
     *
     * @deprecated Deprecated
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesOutboundRule {
    /**
     * Action when rule match request (drop or accept)
     */
    action: string;
    /**
     * Ip address for this rule (e.g: 1.1.1.1). Only one of ip or ip_range should be provided
     *
     * @deprecated Deprecated
     */
    ip?: string;
    /**
     * Ip range for this rule (e.g: 192.168.1.0/24). Only one of ip or ip_range should be provided
     */
    ipRange?: string;
    /**
     * Network port for this rule
     */
    port?: number;
    /**
     * Computed port range for this rule (e.g: 1-1024, 22-22)
     */
    portRange?: string;
    /**
     * Protocol for this rule (TCP, UDP, ICMP or ANY)
     */
    protocol?: string;
}

export interface InstanceSecurityGroupRulesTimeouts {
    default?: string;
}

export interface InstanceSecurityGroupTimeouts {
    default?: string;
}

export interface InstanceServerPrivateNetwork {
    /**
     * MAC address of the NIC
     */
    macAddress: string;
    /**
     * The Private Network ID
     */
    pnId: string;
    /**
     * The ID of the NIC
     */
    pnicId: string;
    /**
     * The private NIC state
     */
    status: string;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface InstanceServerPublicIp {
    /**
     * IP Address
     */
    address: string;
    /**
     * ID of the IP
     */
    id: string;
}

export interface InstanceServerRootVolume {
    /**
     * Set the volume where the boot the server
     */
    boot?: boolean;
    /**
     * Force deletion of the root volume on instanceSDK termination
     */
    deleteOnTermination?: boolean;
    /**
     * Name of the root volume
     */
    name: string;
    /**
     * Size of the root volume in gigabytes
     */
    sizeInGb: number;
    /**
     * Volume ID of the root volume
     */
    volumeId: string;
    /**
     * Volume type of the root volume
     */
    volumeType: string;
}

export interface InstanceServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface InstanceSnapshotImport {
    /**
     * Bucket containing qcow
     */
    bucket: string;
    /**
     * Key of the qcow file in the specified bucket
     */
    key: string;
}

export interface InstanceSnapshotTimeouts {
    create?: string;
    default?: string;
    delete?: string;
}

export interface InstanceUserDataTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface InstanceVolumeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface IotDeviceCertificate {
    /**
     * X509 PEM encoded certificate of the device
     */
    crt: string;
    /**
     * X509 PEM encoded key of the device
     */
    key: string;
}

export interface IotDeviceMessageFilters {
    /**
     * Rule to restrict topics the device can publish to
     */
    publish?: outputs.IotDeviceMessageFiltersPublish;
    /**
     * Rule to restrict topics the device can subscribe to
     */
    subscribe?: outputs.IotDeviceMessageFiltersSubscribe;
}

export interface IotDeviceMessageFiltersPublish {
    /**
     * Publish message filter policy
     */
    policy?: string;
    /**
     * List of topics in the set
     */
    topics?: string[];
}

export interface IotDeviceMessageFiltersSubscribe {
    /**
     * Subscribe message filter policy
     */
    policy?: string;
    /**
     * List of topics in the set
     */
    topics?: string[];
}

export interface IotHubTimeouts {
    default?: string;
}

export interface IotNetworkTimeouts {
    default?: string;
    delete?: string;
}

export interface IotRouteDatabase {
    /**
     * The database name
     */
    dbname: string;
    /**
     * The database hostname
     */
    host: string;
    /**
     * The database password
     */
    password: string;
    /**
     * The database port
     */
    port: number;
    /**
     * SQL query to be executed ($TOPIC and $PAYLOAD variables are available, see documentation)
     */
    query: string;
    /**
     * The database username
     */
    username: string;
}

export interface IotRouteRest {
    /**
     * The HTTP call extra headers
     */
    headers: {[key: string]: string};
    /**
     * The URI of the REST endpoint
     */
    uri: string;
    /**
     * The HTTP Verb used to call REST URI
     */
    verb: string;
}

export interface IotRouteS3 {
    /**
     * The name of the S3 route's destination bucket
     */
    bucketName: string;
    /**
     * The region of the S3 route's destination bucket
     */
    bucketRegion: string;
    /**
     * The string to prefix object names with
     */
    objectPrefix?: string;
    /**
     * How the S3 route's objects will be created: one per topic or one per message
     */
    strategy: string;
}

export interface IotRouteTimeouts {
    create?: string;
    default?: string;
}

export interface IpamIpResource {
    id: string;
    macAddress: string;
    name: string;
    type: string;
}

export interface IpamIpReverse {
    address: string;
    hostname: string;
}

export interface IpamIpReverseDnsTimeouts {
    create?: string;
    default?: string;
    update?: string;
}

export interface IpamIpSource {
    /**
     * Private Network the IP lives in if the IP is a private IP
     */
    privateNetworkId: string;
    /**
     * Private Network subnet the IP lives in if the IP is a private IP in a Private Network
     */
    subnetId: string;
    /**
     * Zone the IP lives in if the IP is a public zoned one
     */
    zonal: string;
}

export interface JobDefinitionCron {
    schedule: string;
    timezone: string;
}

export interface K8sClusterAutoUpgrade {
    /**
     * Enables the Kubernetes patch version auto upgrade
     */
    enable: boolean;
    /**
     * Day of the maintenance window
     */
    maintenanceWindowDay: string;
    /**
     * Start hour of the 2-hour maintenance window
     */
    maintenanceWindowStartHour: number;
}

export interface K8sClusterAutoscalerConfig {
    /**
     * Detect similar node groups and balance the number of nodes between them
     */
    balanceSimilarNodeGroups?: boolean;
    /**
     * Disable the scale down feature of the autoscaler
     */
    disableScaleDown?: boolean;
    /**
     * Type of resource estimator to be used in scale up
     */
    estimator?: string;
    /**
     * Type of node group expander to be used in scale up
     */
    expander?: string;
    /**
     * Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable
     */
    expendablePodsPriorityCutoff?: number;
    /**
     * Ignore DaemonSet pods when calculating resource utilization for scaling down
     */
    ignoreDaemonsetsUtilization?: boolean;
    /**
     * Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
     */
    maxGracefulTerminationSec?: number;
    /**
     * How long after scale up that scale down evaluation resumes
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * How long a node should be unneeded before it is eligible for scale down
     */
    scaleDownUnneededTime?: string;
    /**
     * Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
     */
    scaleDownUtilizationThreshold?: number;
}

export interface K8sClusterKubeconfig {
    clusterCaCertificate: string;
    configFile: string;
    host: string;
    token: string;
}

export interface K8sClusterOpenIdConnectConfig {
    /**
     * A client id that all tokens must be issued for
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group
     */
    groupsClaims?: string[];
    /**
     * Prefix prepended to group claims
     */
    groupsPrefix?: string;
    /**
     * URL of the provider which allows the API server to discover public signing keys
     */
    issuerUrl: string;
    /**
     * Multiple key=value pairs that describes a required claim in the ID Token
     */
    requiredClaims?: string[];
    /**
     * JWT claim to use as the user name
     */
    usernameClaim?: string;
    /**
     * Prefix prepended to username
     */
    usernamePrefix?: string;
}

export interface K8sClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface K8sPoolNode {
    name: string;
    publicIp: string;
    publicIpV6: string;
    status: string;
}

export interface K8sPoolTimeouts {
    create?: string;
    default?: string;
    update?: string;
}

export interface K8sPoolUpgradePolicy {
    /**
     * The maximum number of nodes to be created during the upgrade
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be not ready at the same time
     */
    maxUnavailable?: number;
}

export interface LbAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action
     */
    redirects?: outputs.LbAclActionRedirect[];
    /**
     * The action type
     */
    type: string;
}

export interface LbAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code?: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target?: string;
    /**
     * The redirect type
     */
    type?: string;
}

export interface LbAclMatch {
    /**
     * The HTTP filter to match
     */
    httpFilter?: string;
    /**
     * You can use this field with http_header_match acl type to set the header name to filter
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter
     */
    httpFilterValues?: string[];
    /**
     * If set to true, the condition will be of type "unless"
     */
    invert?: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match
     */
    ipSubnets?: string[];
}

export interface LbAclTimeouts {
    default?: string;
}

export interface LbBackendHealthCheckHttp {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The HTTP endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LbBackendHealthCheckHttps {
    /**
     * The expected HTTP status code
     */
    code?: number;
    /**
     * The HTTP host header to use for HC requests
     */
    hostHeader?: string;
    /**
     * The HTTP method to use for HC requests
     */
    method?: string;
    /**
     * The SNI to use for HC requests over SSL
     */
    sni?: string;
    /**
     * The HTTPS endpoint URL to call for HC requests
     */
    uri: string;
}

export interface LbBackendHealthCheckTcp {
}

export interface LbBackendTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbCertificateCustomCertificate {
    /**
     * The full PEM-formatted certificate chain
     */
    certificateChain: string;
}

export interface LbCertificateLetsencrypt {
    /**
     * The main domain name of the certificate
     */
    commonName: string;
    /**
     * The alternative domain names of the certificate
     */
    subjectAlternativeNames?: string[];
}

export interface LbCertificateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbFrontendAcl {
    /**
     * Action to undertake when an ACL filter matches
     */
    action: outputs.LbFrontendAclAction;
    /**
     * IsDate and time of ACL's creation (RFC 3339 format)
     */
    createdAt: string;
    /**
     * Description of the ACL
     */
    description?: string;
    /**
     * The ACL match rule
     */
    match: outputs.LbFrontendAclMatch;
    /**
     * The ACL name
     */
    name: string;
    /**
     * IsDate and time of ACL's update (RFC 3339 format)
     */
    updatedAt: string;
}

export interface LbFrontendAclAction {
    /**
     * Redirect parameters when using an ACL with `redirect` action
     */
    redirects?: outputs.LbFrontendAclActionRedirect[];
    /**
     * The action type
     */
    type: string;
}

export interface LbFrontendAclActionRedirect {
    /**
     * The HTTP redirect code to use
     */
    code?: number;
    /**
     * An URL can be used in case of a location redirect
     */
    target?: string;
    /**
     * The redirect type
     */
    type?: string;
}

export interface LbFrontendAclMatch {
    /**
     * The HTTP filter to match
     */
    httpFilter?: string;
    /**
     * You can use this field with http_header_match acl type to set the header name to filter
     */
    httpFilterOption?: string;
    /**
     * A list of possible values to match for the given HTTP filter
     */
    httpFilterValues?: string[];
    /**
     * If set to true, the condition will be of type "unless"
     */
    invert?: boolean;
    /**
     * A list of IPs or CIDR v4/v6 addresses of the client of the session to match
     */
    ipSubnets?: string[];
}

export interface LbFrontendTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface LbIpTimeouts {
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface LbPrivateNetwork {
    /**
     * Set to true if you want to let DHCP assign IP addresses
     */
    dhcpConfig: boolean;
    /**
     * IPAM ID of a pre-reserved IP address to assign to the Load Balancer on this Private Network
     */
    ipamIds: string[];
    /**
     * The Private Network ID
     */
    privateNetworkId: string;
    /**
     * Define an IP address in the subnet of your private network that will be assigned to your load balancer instance
     *
     * @deprecated Deprecated
     */
    staticConfigs?: string[];
    /**
     * The status of private network connection
     */
    status: string;
    zone: string;
}

export interface LbRouteTimeouts {
    default?: string;
}

export interface LbTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface MnqSnsCredentialsPermissions {
    /**
     * Allow manage the associated resource
     */
    canManage: boolean;
    /**
     * Allow publish messages to the service
     */
    canPublish: boolean;
    /**
     * Allow receive messages from the service
     */
    canReceive: boolean;
}

export interface MnqSqsCredentialsPermissions {
    /**
     * Allow manage the associated resource
     */
    canManage: boolean;
    /**
     * Allow publish messages to the service
     */
    canPublish: boolean;
    /**
     * Allow receive messages from the service
     */
    canReceive: boolean;
}

export interface MnqSqsQueueTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ObjectBucketAclAccessControlPolicy {
    grants?: outputs.ObjectBucketAclAccessControlPolicyGrant[];
    /**
     * Configuration block of the bucket project owner's display organization ID.
     */
    owner: outputs.ObjectBucketAclAccessControlPolicyOwner;
}

export interface ObjectBucketAclAccessControlPolicyGrant {
    /**
     * Configuration block for the project being granted permissions.
     */
    grantee?: outputs.ObjectBucketAclAccessControlPolicyGrantGrantee;
    /**
     * Logging permissions assigned to the grantee for the bucket.
     */
    permission: string;
}

export interface ObjectBucketAclAccessControlPolicyGrantGrantee {
    displayName: string;
    /**
     * The project ID owner of the grantee.
     */
    id: string;
    /**
     * Type of grantee. Valid values: `CanonicalUser`
     */
    type: string;
}

export interface ObjectBucketAclAccessControlPolicyOwner {
    /**
     * The project ID of the grantee.
     */
    displayName: string;
    /**
     * The display ID of the project.
     */
    id: string;
}

export interface ObjectBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface ObjectBucketLifecycleRule {
    /**
     * Specifies the number of days after initiating a multipart upload when the multipart upload must be completed
     */
    abortIncompleteMultipartUploadDays?: number;
    /**
     * Specifies if the configuration rule is Enabled or Disabled
     */
    enabled: boolean;
    /**
     * Specifies a period in the object's expire
     */
    expiration?: outputs.ObjectBucketLifecycleRuleExpiration;
    /**
     * Unique identifier for the rule
     */
    id: string;
    /**
     * The prefix identifying one or more objects to which the rule applies
     */
    prefix?: string;
    /**
     * The tags associated with the bucket lifecycle
     */
    tags?: {[key: string]: string};
    /**
     * Define when objects transition to another storage class
     */
    transitions?: outputs.ObjectBucketLifecycleRuleTransition[];
}

export interface ObjectBucketLifecycleRuleExpiration {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days: number;
}

export interface ObjectBucketLifecycleRuleTransition {
    /**
     * Specifies the number of days after object creation when the specific rule action takes effect
     */
    days?: number;
    /**
     * Specifies the Scaleway Object Storage class to which you want the object to transition
     */
    storageClass: string;
}

export interface ObjectBucketLockConfigurationRule {
    defaultRetention: outputs.ObjectBucketLockConfigurationRuleDefaultRetention;
}

export interface ObjectBucketLockConfigurationRuleDefaultRetention {
    /**
     * The number of days that you want to specify for the default retention period.
     */
    days?: number;
    /**
     * The default Object Lock retention mode you want to apply to new objects placed in the specified bucket.
     */
    mode: string;
    /**
     * The number of years that you want to specify for the default retention period.
     */
    years?: number;
}

export interface ObjectBucketPolicyTimeouts {
    default?: string;
}

export interface ObjectBucketTimeouts {
    default?: string;
}

export interface ObjectBucketVersioning {
    /**
     * Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state
     */
    enabled: boolean;
}

export interface ObjectBucketWebsiteConfigurationErrorDocument {
    key: string;
}

export interface ObjectBucketWebsiteConfigurationIndexDocument {
    suffix: string;
}

export interface ObjectTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbAclAclRule {
    /**
     * Description of the rule
     */
    description: string;
    /**
     * Target IP of the rules
     */
    ip: string;
}

export interface RdbAclTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbDatabaseBackupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbDatabaseTimeouts {
    create?: string;
    default?: string;
    delete?: string;
}

export interface RdbInstanceLoadBalancer {
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your load balancer service
     */
    ip: string;
    /**
     * The name of your load balancer service
     */
    name: string;
    /**
     * The port of your load balancer service
     */
    port: number;
}

export interface RdbInstanceLogsPolicy {
    /**
     * The max age (in days) of remote logs to keep on the Database Instance
     */
    maxAgeRetention: number;
    /**
     * The max disk size of remote logs to keep on the Database Instance.
     */
    totalDiskRetention: number;
}

export interface RdbInstancePrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * The endpoint ID
     */
    endpointId: string;
    /**
     * The hostname of your endpoint
     */
    hostname: string;
    /**
     * The IP of your Instance within the private service
     */
    ip: string;
    /**
     * The IP with the given mask within the private subnet
     */
    ipNet: string;
    /**
     * The name of your private service
     */
    name: string;
    /**
     * The private network ID
     */
    pnId: string;
    /**
     * The port of your private service
     */
    port: number;
    /**
     * The zone you want to attach the resource to
     */
    zone: string;
}

export interface RdbInstanceReadReplica {
    ip: string;
    name: string;
    port: number;
}

export interface RdbInstanceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbPrivilegeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbReadReplicaDirectAccess {
    /**
     * UUID of the endpoint (UUID format).
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set.
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
     */
    ip: string;
    /**
     * Name of the endpoint.
     */
    name: string;
    /**
     * TCP port of the endpoint.
     */
    port: number;
}

export interface RdbReadReplicaPrivateNetwork {
    /**
     * Whether or not the private network endpoint should be configured with IPAM
     */
    enableIpam: boolean;
    /**
     * UUID of the endpoint (UUID format).
     */
    endpointId: string;
    /**
     * Hostname of the endpoint. Only one of ip and hostname may be set
     */
    hostname: string;
    /**
     * IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set
     */
    ip: string;
    /**
     * Name of the endpoints
     */
    name: string;
    /**
     * TCP port of the endpoint
     */
    port: number;
    /**
     * UUID of the private network to be connected to the read replica (UUID format)
     */
    privateNetworkId: string;
    /**
     * The IP network address within the private subnet
     */
    serviceIp: string;
    /**
     * Private network zone
     */
    zone: string;
}

export interface RdbReadReplicaTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RdbUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RedisClusterAcl {
    /**
     * Description of the rule.
     */
    description: string;
    /**
     * ID of the rule (UUID format).
     */
    id: string;
    /**
     * IPv4 network address of the rule (IP network in a CIDR format).
     */
    ip: string;
}

export interface RedisClusterPrivateNetwork {
    /**
     * UUID of the endpoint to be connected to the cluster
     */
    endpointId: string;
    /**
     * UUID of the private network to be connected to the cluster
     */
    id: string;
    /**
     * List of IPv4 addresses of the private network with a CIDR notation
     */
    serviceIps: string[];
    /**
     * The zone of the resource
     */
    zone: string;
}

export interface RedisClusterPublicNetwork {
    id: string;
    ips: string[];
    /**
     * TCP port of the endpoint
     */
    port: number;
}

export interface RedisClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface RegistryNamespaceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SdbSqlDatabaseTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SecretTimeouts {
    default?: string;
}

export interface SecretVersionTimeouts {
    default?: string;
}

export interface TemDomainReputation {
    previousScore: number;
    previousScoredAt: string;
    score: number;
    scoredAt: string;
    status: string;
}

export interface TemDomainTimeouts {
    default?: string;
    delete?: string;
}

export interface TemDomainValidationTimeouts {
    create?: string;
    default?: string;
    delete?: string;
}

export interface VpcGatewayNetworkIpamConfig {
    /**
     * Use this IPAM-booked IP ID as the Gateway's IP in this Private Network
     */
    ipamIpId: string;
    /**
     * Defines whether the default route is enabled on that Gateway Network
     */
    pushDefaultRoute?: boolean;
}

export interface VpcGatewayNetworkTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface VpcPrivateNetworkIpv4Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The subnet ID
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface VpcPrivateNetworkIpv6Subnet {
    /**
     * The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet
     */
    address: string;
    /**
     * The date and time of the creation of the subnet
     */
    createdAt: string;
    /**
     * The subnet ID
     */
    id: string;
    /**
     * The length of the network prefix, e.g., 24 for a 255.255.255.0 mask
     */
    prefixLength: number;
    /**
     * The subnet CIDR
     */
    subnet: string;
    /**
     * The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
     */
    subnetMask: string;
    /**
     * The date and time of the last update of the subnet
     */
    updatedAt: string;
}

export interface VpcPublicGatewayDhcpReservationTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpcPublicGatewayIpReverseDnsTimeouts {
    create?: string;
    default?: string;
    update?: string;
}

export interface VpcPublicGatewayPatRuleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpcPublicGatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface WebhostingCpanelUrl {
    dashboard: string;
    webmail: string;
}

export interface WebhostingOption {
    id: string;
    name: string;
}

export interface WebhostingTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    read?: string;
}

