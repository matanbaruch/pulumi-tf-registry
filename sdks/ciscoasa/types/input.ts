// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessInRulesRule {
    active?: pulumi.Input<boolean>;
    destination: pulumi.Input<string>;
    destinationService: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    permit?: pulumi.Input<boolean>;
    source: pulumi.Input<string>;
    sourceService?: pulumi.Input<string>;
    timeRange?: pulumi.Input<string>;
}

export interface AccessOutRulesRule {
    active?: pulumi.Input<boolean>;
    destination: pulumi.Input<string>;
    destinationService: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    permit?: pulumi.Input<boolean>;
    source: pulumi.Input<string>;
    sourceService?: pulumi.Input<string>;
    timeRange?: pulumi.Input<string>;
}

export interface AclRule {
    active?: pulumi.Input<boolean>;
    destination: pulumi.Input<string>;
    destinationService: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    logInterval?: pulumi.Input<number>;
    logStatus?: pulumi.Input<string>;
    permit?: pulumi.Input<boolean>;
    remarks?: pulumi.Input<pulumi.Input<string>[]>;
    source: pulumi.Input<string>;
    sourceService?: pulumi.Input<string>;
}

export interface DhcpServerOption {
    code: pulumi.Input<number>;
    type: pulumi.Input<string>;
    value1: pulumi.Input<string>;
    value2?: pulumi.Input<string>;
}

export interface InterfacePhysicalIpAddress {
    dhcps?: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpAddressDhcp>[]>;
    statics?: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpAddressStatic>[]>;
}

export interface InterfacePhysicalIpAddressDhcp {
    dhcpBroadcast: pulumi.Input<boolean>;
    dhcpClients: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpAddressDhcpDhcpClient>[]>;
    dhcpOptionUsingMac: pulumi.Input<boolean>;
}

export interface InterfacePhysicalIpAddressDhcpDhcpClient {
    metric: pulumi.Input<number>;
    primaryTrackId: pulumi.Input<number>;
    setDefaultRoute: pulumi.Input<boolean>;
    slaTrackingSettings: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpAddressDhcpDhcpClientSlaTrackingSetting>[]>;
    trackingEnabled: pulumi.Input<boolean>;
}

export interface InterfacePhysicalIpAddressDhcpDhcpClientSlaTrackingSetting {
    dataSizeInBytes: pulumi.Input<number>;
    frequencyInSeconds: pulumi.Input<number>;
    numPackets: pulumi.Input<number>;
    slaId: pulumi.Input<number>;
    thresholdInMilliseconds: pulumi.Input<number>;
    timeoutInMilliseconds: pulumi.Input<number>;
    tos: pulumi.Input<number>;
    trackedIp: pulumi.Input<string>;
}

export interface InterfacePhysicalIpAddressStatic {
    ip: pulumi.Input<string>;
    netMask: pulumi.Input<string>;
}

export interface InterfacePhysicalIpv6Info {
    autoConfig?: pulumi.Input<boolean>;
    dadAttempts?: pulumi.Input<number>;
    enabled?: pulumi.Input<boolean>;
    enforceEui64?: pulumi.Input<boolean>;
    ipv6Addresses?: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpv6InfoIpv6Address>[]>;
    linkLocalAddresses?: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpv6InfoLinkLocalAddress>[]>;
    managedAddressConfig?: pulumi.Input<boolean>;
    nDiscoveryPrefixLists?: pulumi.Input<pulumi.Input<inputs.InterfacePhysicalIpv6InfoNDiscoveryPrefixList>[]>;
    nsInterval?: pulumi.Input<number>;
    otherStatefulConfig?: pulumi.Input<boolean>;
    reachableTime?: pulumi.Input<number>;
    routerAdvertInterval?: pulumi.Input<number>;
    routerAdvertIntervalUnit?: pulumi.Input<string>;
    routerAdvertLifetime?: pulumi.Input<number>;
    suppressRouterAdvert?: pulumi.Input<boolean>;
}

export interface InterfacePhysicalIpv6InfoIpv6Address {
    address: pulumi.Input<string>;
    prefixLength: pulumi.Input<number>;
    standby: pulumi.Input<string>;
}

export interface InterfacePhysicalIpv6InfoLinkLocalAddress {
    address: pulumi.Input<string>;
    standby: pulumi.Input<string>;
}

export interface InterfacePhysicalIpv6InfoNDiscoveryPrefixList {
    defaultPrefix: pulumi.Input<boolean>;
    hasDuration: pulumi.Input<boolean>;
    noAdvertise: pulumi.Input<boolean>;
    offLink: pulumi.Input<boolean>;
    preferredLifetime: pulumi.Input<number>;
    validLifetime: pulumi.Input<number>;
}

export interface InterfaceVlanIpAddress {
    dhcps?: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpAddressDhcp>[]>;
    statics?: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpAddressStatic>[]>;
}

export interface InterfaceVlanIpAddressDhcp {
    dhcpBroadcast: pulumi.Input<boolean>;
    dhcpClients: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpAddressDhcpDhcpClient>[]>;
    dhcpOptionUsingMac: pulumi.Input<boolean>;
}

export interface InterfaceVlanIpAddressDhcpDhcpClient {
    metric: pulumi.Input<number>;
    primaryTrackId: pulumi.Input<number>;
    setDefaultRoute: pulumi.Input<boolean>;
    slaTrackingSettings: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpAddressDhcpDhcpClientSlaTrackingSetting>[]>;
    trackingEnabled: pulumi.Input<boolean>;
}

export interface InterfaceVlanIpAddressDhcpDhcpClientSlaTrackingSetting {
    dataSizeInBytes: pulumi.Input<number>;
    frequencyInSeconds: pulumi.Input<number>;
    numPackets: pulumi.Input<number>;
    slaId: pulumi.Input<number>;
    thresholdInMilliseconds: pulumi.Input<number>;
    timeoutInMilliseconds: pulumi.Input<number>;
    tos: pulumi.Input<number>;
    trackedIp: pulumi.Input<string>;
}

export interface InterfaceVlanIpAddressStatic {
    ip: pulumi.Input<string>;
    netMask: pulumi.Input<string>;
}

export interface InterfaceVlanIpv6Info {
    autoConfig?: pulumi.Input<boolean>;
    dadAttempts?: pulumi.Input<number>;
    enabled?: pulumi.Input<boolean>;
    enforceEui64?: pulumi.Input<boolean>;
    ipv6Addresses?: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpv6InfoIpv6Address>[]>;
    linkLocalAddresses?: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpv6InfoLinkLocalAddress>[]>;
    managedAddressConfig?: pulumi.Input<boolean>;
    nDiscoveryPrefixLists?: pulumi.Input<pulumi.Input<inputs.InterfaceVlanIpv6InfoNDiscoveryPrefixList>[]>;
    nsInterval?: pulumi.Input<number>;
    otherStatefulConfig?: pulumi.Input<boolean>;
    reachableTime?: pulumi.Input<number>;
    routerAdvertInterval?: pulumi.Input<number>;
    routerAdvertIntervalUnit?: pulumi.Input<string>;
    routerAdvertLifetime?: pulumi.Input<number>;
    suppressRouterAdvert?: pulumi.Input<boolean>;
}

export interface InterfaceVlanIpv6InfoIpv6Address {
    address: pulumi.Input<string>;
    prefixLength: pulumi.Input<number>;
    standby: pulumi.Input<string>;
}

export interface InterfaceVlanIpv6InfoLinkLocalAddress {
    address: pulumi.Input<string>;
    standby: pulumi.Input<string>;
}

export interface InterfaceVlanIpv6InfoNDiscoveryPrefixList {
    defaultPrefix: pulumi.Input<boolean>;
    hasDuration: pulumi.Input<boolean>;
    noAdvertise: pulumi.Input<boolean>;
    offLink: pulumi.Input<boolean>;
    preferredLifetime: pulumi.Input<number>;
    validLifetime: pulumi.Input<number>;
}

export interface TimerangeValue {
    end: pulumi.Input<string>;
    periodics?: pulumi.Input<pulumi.Input<inputs.TimerangeValuePeriodic>[]>;
    start: pulumi.Input<string>;
}

export interface TimerangeValuePeriodic {
    endHour: pulumi.Input<number>;
    endMinute: pulumi.Input<number>;
    frequency: pulumi.Input<string>;
    startHour: pulumi.Input<number>;
    startMinute: pulumi.Input<number>;
}
