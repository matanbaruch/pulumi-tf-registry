// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ElasticsearchClusterSettingsElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchClusterSettingsPersistent {
    /**
     * Defines the setting in the cluster.
     */
    settings: outputs.ElasticsearchClusterSettingsPersistentSetting[];
}

export interface ElasticsearchClusterSettingsPersistentSetting {
    /**
     * The name of the setting to set and track.
     */
    name: string;
    /**
     * The value of the setting to set and track.
     */
    value?: string;
    /**
     * The list of values to be set for the key, where the list is required.
     */
    valueLists?: string[];
}

export interface ElasticsearchClusterSettingsTransient {
    /**
     * Defines the setting in the cluster.
     */
    settings: outputs.ElasticsearchClusterSettingsTransientSetting[];
}

export interface ElasticsearchClusterSettingsTransientSetting {
    /**
     * The name of the setting to set and track.
     */
    name: string;
    /**
     * The value of the setting to set and track.
     */
    value?: string;
    /**
     * The list of values to be set for the key, where the list is required.
     */
    valueLists?: string[];
}

export interface ElasticsearchComponentTemplateElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchComponentTemplateTemplate {
    /**
     * Alias to add.
     */
    aliases?: outputs.ElasticsearchComponentTemplateTemplateAlias[];
    /**
     * Mapping for fields in the index. Should be specified as a JSON object of field mappings. See the documentation (https://www.elastic.co/guide/en/elasticsearch/reference/current/explicit-mapping.html) for more details
     */
    mappings?: string;
    /**
     * Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
     */
    settings?: string;
}

export interface ElasticsearchComponentTemplateTemplateAlias {
    /**
     * Query used to limit documents the alias can access.
     */
    filter?: string;
    /**
     * Value used to route indexing operations to a specific shard. If specified, this overwrites the routing value for indexing operations.
     */
    indexRouting?: string;
    /**
     * If true, the alias is hidden.
     */
    isHidden?: boolean;
    /**
     * If true, the index is the write index for the alias.
     */
    isWriteIndex?: boolean;
    /**
     * The alias name. Index alias names support date math. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/date-math-index-names.html
     */
    name: string;
    /**
     * Value used to route indexing and search operations to a specific shard.
     */
    routing?: string;
    /**
     * Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
     */
    searchRouting?: string;
}

export interface ElasticsearchDataStreamElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchDataStreamIndex {
    indexName: string;
    indexUuid: string;
}

export interface ElasticsearchEnrichPolicyElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchIndexAlias {
    /**
     * Query used to limit documents the alias can access.
     */
    filter?: string;
    /**
     * Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
     */
    indexRouting?: string;
    /**
     * If true, the alias is hidden.
     */
    isHidden?: boolean;
    /**
     * If true, the index is the write index for the alias.
     */
    isWriteIndex?: boolean;
    /**
     * Index alias name.
     */
    name: string;
    /**
     * Value used to route indexing and search operations to a specific shard.
     */
    routing?: string;
    /**
     * Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
     */
    searchRouting?: string;
}

export interface ElasticsearchIndexElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchIndexLifecycleCold {
    /**
     * Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
     */
    allocate?: outputs.ElasticsearchIndexLifecycleColdAllocate;
    /**
     * Roll up documents within a fixed interval to a single summary document. Reduces the index footprint by storing time series data at reduced granularity.
     */
    downsample?: outputs.ElasticsearchIndexLifecycleColdDownsample;
    /**
     * Freeze the index to minimize its memory footprint.
     */
    freeze?: outputs.ElasticsearchIndexLifecycleColdFreeze;
    /**
     * Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include._tier_preference" index setting.
     */
    migrate?: outputs.ElasticsearchIndexLifecycleColdMigrate;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.ElasticsearchIndexLifecycleColdReadonly;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.ElasticsearchIndexLifecycleColdSearchableSnapshot;
    /**
     * Sets the priority of the index as soon as the policy enters the hot, warm, or cold phase. Higher priority indices are recovered before indices with lower priorities following a node restart. Default priority is 1.
     */
    setPriority?: outputs.ElasticsearchIndexLifecycleColdSetPriority;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.ElasticsearchIndexLifecycleColdUnfollow;
}

export interface ElasticsearchIndexLifecycleColdAllocate {
    /**
     * Assigns an index to nodes that have none of the specified custom attributes. Must be valid JSON document.
     */
    exclude?: string;
    /**
     * Assigns an index to nodes that have at least one of the specified custom attributes. Must be valid JSON document.
     */
    include?: string;
    /**
     * Number of replicas to assign to the index. Default: `0`
     */
    numberOfReplicas?: number;
    /**
     * Assigns an index to nodes that have all of the specified custom attributes. Must be valid JSON document.
     */
    require?: string;
    /**
     * The maximum number of shards for the index on a single Elasticsearch node. Defaults to `-1` (unlimited). Supported from Elasticsearch version **7.16**
     */
    totalShardsPerNode?: number;
}

export interface ElasticsearchIndexLifecycleColdDownsample {
    /**
     * Downsampling interval
     */
    fixedInterval: string;
    /**
     * Downsampling interval
     */
    waitTimeout: string;
}

export interface ElasticsearchIndexLifecycleColdFreeze {
    /**
     * Controls whether ILM freezes the index.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleColdMigrate {
    /**
     * Controls whether ILM automatically migrates the index during this phase.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleColdReadonly {
    /**
     * Controls whether ILM makes the index read-only.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleColdSearchableSnapshot {
    /**
     * Force merges the managed index to one segment.
     */
    forceMergeIndex?: boolean;
    /**
     * Repository used to store the snapshot.
     */
    snapshotRepository: string;
}

export interface ElasticsearchIndexLifecycleColdSetPriority {
    /**
     * The priority for the index. Must be 0 or greater.
     */
    priority: number;
}

export interface ElasticsearchIndexLifecycleColdUnfollow {
    /**
     * Controls whether ILM makes the follower index a regular one.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleDelete {
    /**
     * Permanently removes the index.
     */
    delete?: outputs.ElasticsearchIndexLifecycleDeleteDelete;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
     */
    waitForSnapshot?: outputs.ElasticsearchIndexLifecycleDeleteWaitForSnapshot;
}

export interface ElasticsearchIndexLifecycleDeleteDelete {
    /**
     * Deletes the searchable snapshot created in a previous phase.
     */
    deleteSearchableSnapshot?: boolean;
}

export interface ElasticsearchIndexLifecycleDeleteWaitForSnapshot {
    /**
     * Name of the SLM policy that the delete action should wait for.
     */
    policy: string;
}

export interface ElasticsearchIndexLifecycleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchIndexLifecycleFrozen {
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.ElasticsearchIndexLifecycleFrozenSearchableSnapshot;
}

export interface ElasticsearchIndexLifecycleFrozenSearchableSnapshot {
    /**
     * Force merges the managed index to one segment.
     */
    forceMergeIndex?: boolean;
    /**
     * Repository used to store the snapshot.
     */
    snapshotRepository: string;
}

export interface ElasticsearchIndexLifecycleHot {
    /**
     * Roll up documents within a fixed interval to a single summary document. Reduces the index footprint by storing time series data at reduced granularity.
     */
    downsample?: outputs.ElasticsearchIndexLifecycleHotDownsample;
    /**
     * Force merges the index into the specified maximum number of segments. This action makes the index read-only.
     */
    forcemerge?: outputs.ElasticsearchIndexLifecycleHotForcemerge;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.ElasticsearchIndexLifecycleHotReadonly;
    /**
     * Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
     */
    rollover?: outputs.ElasticsearchIndexLifecycleHotRollover;
    /**
     * Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
     */
    searchableSnapshot?: outputs.ElasticsearchIndexLifecycleHotSearchableSnapshot;
    /**
     * Sets the priority of the index as soon as the policy enters the hot, warm, or cold phase. Higher priority indices are recovered before indices with lower priorities following a node restart. Default priority is 1.
     */
    setPriority?: outputs.ElasticsearchIndexLifecycleHotSetPriority;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    shrink?: outputs.ElasticsearchIndexLifecycleHotShrink;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.ElasticsearchIndexLifecycleHotUnfollow;
}

export interface ElasticsearchIndexLifecycleHotDownsample {
    /**
     * Downsampling interval
     */
    fixedInterval: string;
    /**
     * Downsampling interval
     */
    waitTimeout: string;
}

export interface ElasticsearchIndexLifecycleHotForcemerge {
    /**
     * Codec used to compress the document store.
     */
    indexCodec?: string;
    /**
     * Number of segments to merge to. To fully merge the index, set to 1.
     */
    maxNumSegments: number;
}

export interface ElasticsearchIndexLifecycleHotReadonly {
    /**
     * Controls whether ILM makes the index read-only.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleHotRollover {
    /**
     * Triggers rollover after the maximum elapsed time from index creation is reached.
     */
    maxAge?: string;
    /**
     * Triggers rollover after the specified maximum number of documents is reached.
     */
    maxDocs?: number;
    /**
     * Triggers rollover when the largest primary shard in the index reaches a certain size.
     */
    maxPrimaryShardSize?: string;
    /**
     * Triggers rollover when the index reaches a certain size.
     */
    maxSize?: string;
    /**
     * Prevents rollover until after the minimum elapsed time from index creation is reached. Supported from Elasticsearch version **8.4**
     */
    minAge?: string;
    /**
     * Prevents rollover until after the specified minimum number of documents is reached. Supported from Elasticsearch version **8.4**
     */
    minDocs?: number;
    /**
     * Prevents rollover until the largest primary shard in the index reaches a certain number of documents. Supported from Elasticsearch version **8.4**
     */
    minPrimaryShardDocs?: number;
    /**
     * Prevents rollover until the largest primary shard in the index reaches a certain size. Supported from Elasticsearch version **8.4**
     */
    minPrimaryShardSize?: string;
    /**
     * Prevents rollover until the index reaches a certain size.
     */
    minSize?: string;
}

export interface ElasticsearchIndexLifecycleHotSearchableSnapshot {
    /**
     * Force merges the managed index to one segment.
     */
    forceMergeIndex?: boolean;
    /**
     * Repository used to store the snapshot.
     */
    snapshotRepository: string;
}

export interface ElasticsearchIndexLifecycleHotSetPriority {
    /**
     * The priority for the index. Must be 0 or greater.
     */
    priority: number;
}

export interface ElasticsearchIndexLifecycleHotShrink {
    /**
     * If true, the shrunken index is made writable by removing the write block.
     */
    allowWriteAfterShrink?: boolean;
    /**
     * The max primary shard size for the target index.
     */
    maxPrimaryShardSize?: string;
    /**
     * Number of shards to shrink to.
     */
    numberOfShards?: number;
}

export interface ElasticsearchIndexLifecycleHotUnfollow {
    /**
     * Controls whether ILM makes the follower index a regular one.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleWarm {
    /**
     * Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
     */
    allocate?: outputs.ElasticsearchIndexLifecycleWarmAllocate;
    /**
     * Roll up documents within a fixed interval to a single summary document. Reduces the index footprint by storing time series data at reduced granularity.
     */
    downsample?: outputs.ElasticsearchIndexLifecycleWarmDownsample;
    /**
     * Force merges the index into the specified maximum number of segments. This action makes the index read-only.
     */
    forcemerge?: outputs.ElasticsearchIndexLifecycleWarmForcemerge;
    /**
     * Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include._tier_preference" index setting.
     */
    migrate?: outputs.ElasticsearchIndexLifecycleWarmMigrate;
    /**
     * ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
     */
    minAge: string;
    /**
     * Makes the index read-only.
     */
    readonly?: outputs.ElasticsearchIndexLifecycleWarmReadonly;
    /**
     * Sets the priority of the index as soon as the policy enters the hot, warm, or cold phase. Higher priority indices are recovered before indices with lower priorities following a node restart. Default priority is 1.
     */
    setPriority?: outputs.ElasticsearchIndexLifecycleWarmSetPriority;
    /**
     * Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
     */
    shrink?: outputs.ElasticsearchIndexLifecycleWarmShrink;
    /**
     * Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
     */
    unfollow?: outputs.ElasticsearchIndexLifecycleWarmUnfollow;
}

export interface ElasticsearchIndexLifecycleWarmAllocate {
    /**
     * Assigns an index to nodes that have none of the specified custom attributes. Must be valid JSON document.
     */
    exclude?: string;
    /**
     * Assigns an index to nodes that have at least one of the specified custom attributes. Must be valid JSON document.
     */
    include?: string;
    /**
     * Number of replicas to assign to the index. Default: `0`
     */
    numberOfReplicas?: number;
    /**
     * Assigns an index to nodes that have all of the specified custom attributes. Must be valid JSON document.
     */
    require?: string;
    /**
     * The maximum number of shards for the index on a single Elasticsearch node. Defaults to `-1` (unlimited). Supported from Elasticsearch version **7.16**
     */
    totalShardsPerNode?: number;
}

export interface ElasticsearchIndexLifecycleWarmDownsample {
    /**
     * Downsampling interval
     */
    fixedInterval: string;
    /**
     * Downsampling interval
     */
    waitTimeout: string;
}

export interface ElasticsearchIndexLifecycleWarmForcemerge {
    /**
     * Codec used to compress the document store.
     */
    indexCodec?: string;
    /**
     * Number of segments to merge to. To fully merge the index, set to 1.
     */
    maxNumSegments: number;
}

export interface ElasticsearchIndexLifecycleWarmMigrate {
    /**
     * Controls whether ILM automatically migrates the index during this phase.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleWarmReadonly {
    /**
     * Controls whether ILM makes the index read-only.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexLifecycleWarmSetPriority {
    /**
     * The priority for the index. Must be 0 or greater.
     */
    priority: number;
}

export interface ElasticsearchIndexLifecycleWarmShrink {
    /**
     * If true, the shrunken index is made writable by removing the write block.
     */
    allowWriteAfterShrink?: boolean;
    /**
     * The max primary shard size for the target index.
     */
    maxPrimaryShardSize?: string;
    /**
     * Number of shards to shrink to.
     */
    numberOfShards?: number;
}

export interface ElasticsearchIndexLifecycleWarmUnfollow {
    /**
     * Controls whether ILM makes the follower index a regular one.
     */
    enabled?: boolean;
}

export interface ElasticsearchIndexSettings {
    /**
     * Defines the setting for the index.
     */
    settings: outputs.ElasticsearchIndexSettingsSetting[];
}

export interface ElasticsearchIndexSettingsSetting {
    /**
     * The name of the setting to set and track.
     */
    name: string;
    /**
     * The value of the setting to set and track.
     */
    value: string;
}

export interface ElasticsearchIndexTemplateDataStream {
    /**
     * If `true`, the data stream supports custom routing. Defaults to `false`. Available only in **8.x**
     */
    allowCustomRouting?: boolean;
    /**
     * If true, the data stream is hidden.
     */
    hidden?: boolean;
}

export interface ElasticsearchIndexTemplateElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchIndexTemplateTemplate {
    /**
     * Alias to add.
     */
    aliases?: outputs.ElasticsearchIndexTemplateTemplateAlias[];
    /**
     * Mapping for fields in the index. Should be specified as a JSON object of field mappings. See the documentation (https://www.elastic.co/guide/en/elasticsearch/reference/current/explicit-mapping.html) for more details
     */
    mappings?: string;
    /**
     * Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
     */
    settings?: string;
}

export interface ElasticsearchIndexTemplateTemplateAlias {
    /**
     * Query used to limit documents the alias can access.
     */
    filter?: string;
    /**
     * Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
     */
    indexRouting?: string;
    /**
     * If true, the alias is hidden.
     */
    isHidden?: boolean;
    /**
     * If true, the index is the write index for the alias.
     */
    isWriteIndex?: boolean;
    /**
     * The alias name.
     */
    name: string;
    /**
     * Value used to route indexing and search operations to a specific shard.
     */
    routing?: string;
    /**
     * Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
     */
    searchRouting?: string;
}

export interface ElasticsearchIngestPipelineElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchLogstashPipelineElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchScriptElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSecurityApiKeyElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSecurityRoleApplication {
    /**
     * The name of the application to which this entry applies.
     */
    application: string;
    /**
     * A list of strings, where each element is the name of an application privilege or action.
     */
    privileges: string[];
    /**
     * A list resources to which the privileges are applied.
     */
    resources: string[];
}

export interface ElasticsearchSecurityRoleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSecurityRoleIndex {
    /**
     * Include matching restricted indices in names parameter. Usage is strongly discouraged as it can grant unrestricted operations on critical data, make the entire system unstable or leak sensitive information.
     */
    allowRestrictedIndices?: boolean;
    /**
     * The document fields that the owners of the role have read access to.
     */
    fieldSecurity?: outputs.ElasticsearchSecurityRoleIndexFieldSecurity;
    /**
     * A list of indices (or index name patterns) to which the permissions in this entry apply.
     */
    names: string[];
    /**
     * The index level privileges that the owners of the role have on the specified indices.
     */
    privileges: string[];
    /**
     * A search query that defines the documents the owners of the role have read access to.
     */
    query?: string;
}

export interface ElasticsearchSecurityRoleIndexFieldSecurity {
    /**
     * List of the fields to which the grants will not be applied.
     */
    excepts?: string[];
    /**
     * List of the fields to grant the access to.
     */
    grants?: string[];
}

export interface ElasticsearchSecurityRoleMappingElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSecuritySystemUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSecurityUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSnapshotLifecycleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSnapshotRepositoryAzure {
    /**
     * Specifies the path within the container to the repository data.
     */
    basePath: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * Azure named client to use.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Container name. You must create the Azure container before creating the repository.
     */
    container: string;
    /**
     * Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
     */
    locationMode?: string;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface ElasticsearchSnapshotRepositoryElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface ElasticsearchSnapshotRepositoryFs {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Location of the shared filesystem used to store and retrieve snapshots.
     */
    location: string;
    /**
     * Maximum number of snapshots the repository can contain.
     */
    maxNumberOfSnapshots?: number;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface ElasticsearchSnapshotRepositoryGcs {
    /**
     * Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
     */
    basePath: string;
    /**
     * The name of the bucket to be used for snapshots.
     */
    bucket: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * The name of the client to use to connect to Google Cloud Storage.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
}

export interface ElasticsearchSnapshotRepositoryHdfs {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Whether to load the default Hadoop configuration or not.
     */
    loadDefaults?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * The file path within the filesystem where data is stored/loaded.
     */
    path: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * The uri address for hdfs. ex: "hdfs://<host>:<port>/".
     */
    uri: string;
}

export interface ElasticsearchSnapshotRepositoryS3 {
    /**
     * Specifies the path to the repository data within its bucket.
     */
    basePath: string;
    /**
     * Name of the S3 bucket to use for snapshots.
     */
    bucket: string;
    /**
     * Minimum threshold below which the chunk is uploaded using a single request.
     */
    bufferSize: string;
    /**
     * The S3 repository supports all S3 canned ACLs.
     */
    cannedAcl?: string;
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * The name of the S3 client to use to connect to S3.
     */
    client?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, path style access pattern will be used.
     */
    pathStyleAccess?: boolean;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * When true, files are encrypted server-side using AES-256 algorithm.
     */
    serverSideEncryption?: boolean;
    /**
     * Sets the S3 storage class for objects stored in the snapshot repository.
     */
    storageClass?: string;
}

export interface ElasticsearchSnapshotRepositoryUrl {
    /**
     * Maximum size of files in snapshots.
     */
    chunkSize?: string;
    /**
     * If true, metadata files, such as index mappings and settings, are compressed in snapshots.
     */
    compress?: boolean;
    /**
     * Maximum number of retries for http and https URLs.
     */
    httpMaxRetries?: number;
    /**
     * Maximum wait time for data transfers over a connection.
     */
    httpSocketTimeout?: string;
    /**
     * Maximum number of snapshots the repository can contain.
     */
    maxNumberOfSnapshots?: number;
    /**
     * Maximum snapshot restore rate per node.
     */
    maxRestoreBytesPerSec?: string;
    /**
     * Maximum snapshot creation rate per node.
     */
    maxSnapshotBytesPerSec?: string;
    /**
     * If true, the repository is read-only.
     */
    readonly?: boolean;
    /**
     * URL location of the root of the shared filesystem repository.
     */
    url: string;
}

export interface ElasticsearchTransformDestination {
    /**
     * The destination index for the transform.
     */
    index: string;
    /**
     * The unique identifier for an ingest pipeline.
     */
    pipeline?: string;
}

export interface ElasticsearchTransformRetentionPolicy {
    /**
     * Specifies that the transform uses a time field to set the retention policy. This is currently the only supported option.
     */
    time: outputs.ElasticsearchTransformRetentionPolicyTime;
}

export interface ElasticsearchTransformRetentionPolicyTime {
    /**
     * The date field that is used to calculate the age of the document.
     */
    field: string;
    /**
     * Specifies the maximum age of a document in the destination index.
     */
    maxAge: string;
}

export interface ElasticsearchTransformSource {
    /**
     * The source indices for the transform.
     */
    indices: string[];
    /**
     * A query clause that retrieves a subset of data from the source index.
     */
    query?: string;
    /**
     * Definitions of search-time runtime fields that can be used by the transform.
     */
    runtimeMappings?: string;
}

export interface ElasticsearchTransformSync {
    /**
     * Specifies that the transform uses a time field to synchronize the source and destination indices. This is currently the only supported option.
     */
    time: outputs.ElasticsearchTransformSyncTime;
}

export interface ElasticsearchTransformSyncTime {
    /**
     * The time delay between the current time and the latest input data time. The default value is 60s.
     */
    delay?: string;
    /**
     * The date field that is used to identify new documents in the source.
     */
    field: string;
}

export interface FleetIntegrationPolicyInput {
    /**
     * Enable the input.
     */
    enabled?: boolean;
    /**
     * The identifier of the input.
     */
    inputId: string;
    /**
     * Input streams as JSON.
     */
    streamsJson: string;
    /**
     * Input variables as JSON.
     */
    varsJson: string;
}

export interface FleetOutputSsl {
    /**
     * Client SSL certificate.
     */
    certificate: string;
    /**
     * Server SSL certificate authorities.
     */
    certificateAuthorities?: string[];
    /**
     * Client SSL certificate key.
     */
    key: string;
}

export interface GetElasticsearchInfoVersion {
    buildDate: string;
    buildFlavor: string;
    buildHash: string;
    buildSnapshot: boolean;
    buildType: string;
    luceneVersion: string;
    minimumIndexCompatibilityVersion: string;
    minimumWireCompatibilityVersion: string;
    number: string;
}

export interface GetElasticsearchSecurityRoleApplication {
    application: string;
    privileges: string[];
    resources: string[];
}

export interface GetElasticsearchSecurityRoleElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetElasticsearchSecurityRoleIndex {
    allowRestrictedIndices: boolean;
    fieldSecurities: outputs.GetElasticsearchSecurityRoleIndexFieldSecurity[];
    names: string[];
    privileges: string[];
    query: string;
}

export interface GetElasticsearchSecurityRoleIndexFieldSecurity {
    excepts: string[];
    grants: string[];
}

export interface GetElasticsearchSecurityRoleMappingElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetElasticsearchSecurityUserElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetElasticsearchSnapshotRepositoryAzure {
    basePath: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    container: string;
    locationMode: string;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetElasticsearchSnapshotRepositoryElasticsearchConnection {
    /**
     * API Key to use for authentication to Elasticsearch
     */
    apiKey?: string;
    /**
     * Bearer Token to use for authentication to Elasticsearch
     */
    bearerToken?: string;
    /**
     * PEM-encoded custom Certificate Authority certificate
     */
    caData?: string;
    /**
     * Path to a custom Certificate Authority certificate
     */
    caFile?: string;
    /**
     * PEM encoded certificate for client auth
     */
    certData?: string;
    /**
     * Path to a file containing the PEM encoded certificate for client auth
     */
    certFile?: string;
    endpoints?: string[];
    /**
     * ES Client Authentication field to be used with the bearer token
     */
    esClientAuthentication?: string;
    /**
     * Disable TLS certificate validation
     */
    insecure?: boolean;
    /**
     * PEM encoded private key for client auth
     */
    keyData?: string;
    /**
     * Path to a file containing the PEM encoded private key for client auth
     */
    keyFile?: string;
    /**
     * Password to use for API authentication to Elasticsearch.
     */
    password?: string;
    /**
     * Username to use for API authentication to Elasticsearch.
     */
    username?: string;
}

export interface GetElasticsearchSnapshotRepositoryF {
    chunkSize: string;
    compress: boolean;
    location: string;
    maxNumberOfSnapshots: number;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetElasticsearchSnapshotRepositoryGc {
    basePath: string;
    bucket: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
}

export interface GetElasticsearchSnapshotRepositoryHdf {
    chunkSize: string;
    compress: boolean;
    loadDefaults: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    path: string;
    readonly: boolean;
    uri: string;
}

export interface GetElasticsearchSnapshotRepositoryS3 {
    basePath: string;
    bucket: string;
    bufferSize: string;
    cannedAcl: string;
    chunkSize: string;
    client: string;
    compress: boolean;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    pathStyleAccess: boolean;
    readonly: boolean;
    serverSideEncryption: boolean;
    storageClass: string;
}

export interface GetElasticsearchSnapshotRepositoryUrl {
    chunkSize: string;
    compress: boolean;
    httpMaxRetries: number;
    httpSocketTimeout: string;
    maxNumberOfSnapshots: number;
    maxRestoreBytesPerSec: string;
    maxSnapshotBytesPerSec: string;
    readonly: boolean;
    url: string;
}

export interface GetFleetEnrollmentTokensToken {
    active: boolean;
    apiKey: string;
    apiKeyId: string;
    createdAt: string;
    keyId: string;
    name: string;
    policyId: string;
}

export interface GetKibanaSecurityRoleElasticsearch {
    clusters: string[];
    indices: outputs.GetKibanaSecurityRoleElasticsearchIndex[];
    runAs: string[];
}

export interface GetKibanaSecurityRoleElasticsearchIndex {
    fieldSecurities: outputs.GetKibanaSecurityRoleElasticsearchIndexFieldSecurity[];
    names: string[];
    privileges: string[];
    query: string;
}

export interface GetKibanaSecurityRoleElasticsearchIndexFieldSecurity {
    excepts: string[];
    grants: string[];
}

export interface GetKibanaSecurityRoleKibana {
    bases: string[];
    features: outputs.GetKibanaSecurityRoleKibanaFeature[];
    spaces: string[];
}

export interface GetKibanaSecurityRoleKibanaFeature {
    name: string;
    privileges: string[];
}

export interface GetKibanaSpacesSpace {
    /**
     * The hexadecimal color code used in the space avatar. By default, the color is automatically generated from the space name.
     */
    color: string;
    /**
     * The description for the space.
     */
    description?: string;
    /**
     * The list of disabled features for the space. To get a list of available feature IDs, use the Features API (https://www.elastic.co/guide/en/kibana/master/features-api-get.html).
     */
    disabledFeatures?: string[];
    /**
     * Internal identifier of the resource.
     */
    id: string;
    /**
     * The data-URL encoded image to display in the space avatar.
     */
    imageUrl?: string;
    /**
     * The initials shown in the space avatar. By default, the initials are automatically generated from the space name. Initials must be 1 or 2 characters.
     */
    initials: string;
    /**
     * The display name for the space.
     */
    name: string;
}

export interface KibanaAlertingRuleAction {
    /**
     * The group name, which affects when the action runs (for example, when the threshold is met or when the alert is recovered). Each rule type has a list of valid action group names.
     */
    group?: string;
    /**
     * The identifier for the connector saved object.
     */
    id: string;
    /**
     * The parameters for the action, which are sent to the connector.
     */
    params: string;
}

export interface KibanaDataViewDataView {
    /**
     * Allows the Data view saved object to exist before the data is available.
     */
    allowNoIndex: boolean;
    /**
     * Map of field attributes by field name.
     */
    fieldAttrs?: {[key: string]: outputs.KibanaDataViewDataViewFieldAttrs};
    /**
     * Map of field formats by field name.
     */
    fieldFormats?: {[key: string]: outputs.KibanaDataViewDataViewFieldFormats};
    /**
     * Saved object ID.
     */
    id: string;
    /**
     * The Data view name.
     */
    name: string;
    /**
     * Array of space IDs for sharing the Data view between multiple spaces.
     */
    namespaces?: string[];
    /**
     * Map of runtime field definitions by field name.
     */
    runtimeFieldMap?: {[key: string]: outputs.KibanaDataViewDataViewRuntimeFieldMap};
    /**
     * List of field names you want to filter out in Discover.
     */
    sourceFilters?: string[];
    /**
     * Timestamp field name, which you use for time-based Data views.
     */
    timeFieldName: string;
    /**
     * Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (*).
     */
    title: string;
}

export interface KibanaDataViewDataViewFieldAttrs {
    /**
     * Popularity count for the field.
     */
    count?: number;
    /**
     * Custom label for the field.
     */
    customLabel?: string;
}

export interface KibanaDataViewDataViewFieldFormats {
    id: string;
    params?: outputs.KibanaDataViewDataViewFieldFormatsParams;
}

export interface KibanaDataViewDataViewFieldFormatsParams {
    pattern?: string;
}

export interface KibanaDataViewDataViewRuntimeFieldMap {
    /**
     * Script of the runtime field.
     */
    scriptSource: string;
    /**
     * Mapping type of the runtime field. For more information, check [Field data types](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/mapping-types.html).
     */
    type: string;
}

export interface KibanaImportSavedObjectsError {
    error: outputs.KibanaImportSavedObjectsErrorError;
    id: string;
    meta: outputs.KibanaImportSavedObjectsErrorMeta;
    title: string;
    type: string;
}

export interface KibanaImportSavedObjectsErrorError {
    type: string;
}

export interface KibanaImportSavedObjectsErrorMeta {
    icon: string;
    title: string;
}

export interface KibanaImportSavedObjectsSuccessResult {
    destinationId: string;
    id: string;
    meta: outputs.KibanaImportSavedObjectsSuccessResultMeta;
    type: string;
}

export interface KibanaImportSavedObjectsSuccessResultMeta {
    icon: string;
    title: string;
}

export interface KibanaSecurityRoleElasticsearch {
    /**
     * List of the cluster privileges.
     */
    clusters?: string[];
    /**
     * A list of indices permissions entries.
     */
    indices?: outputs.KibanaSecurityRoleElasticsearchIndex[];
    /**
     * A list of usernames the owners of this role can impersonate.
     */
    runAs?: string[];
}

export interface KibanaSecurityRoleElasticsearchIndex {
    /**
     * The document fields that the owners of the role have read access to.
     */
    fieldSecurity?: outputs.KibanaSecurityRoleElasticsearchIndexFieldSecurity;
    /**
     * A list of indices (or index name patterns) to which the permissions in this entry apply.
     */
    names: string[];
    /**
     * The index level privileges that the owners of the role have on the specified indices.
     */
    privileges: string[];
    /**
     * A search query that defines the documents the owners of the role have read access to.
     */
    query?: string;
}

export interface KibanaSecurityRoleElasticsearchIndexFieldSecurity {
    /**
     * List of the fields to which the grants will not be applied.
     */
    excepts?: string[];
    /**
     * List of the fields to grant the access to.
     */
    grants?: string[];
}

export interface KibanaSecurityRoleKibana {
    /**
     * A base privilege. When specified, the base must be ["all"] or ["read"]. When the base privileges are specified, you are unable to use the "feature" section.
     */
    bases?: string[];
    /**
     * List of privileges for specific features. When the feature privileges are specified, you are unable to use the "base" section.
     */
    features?: outputs.KibanaSecurityRoleKibanaFeature[];
    /**
     * The spaces to apply the privileges to. To grant access to all spaces, set to ["*"], or omit the value.
     */
    spaces: string[];
}

export interface KibanaSecurityRoleKibanaFeature {
    /**
     * Feature name.
     */
    name: string;
    /**
     * Feature privileges.
     */
    privileges: string[];
}

export interface KibanaSloApmAvailabilityIndicator {
    environment: string;
    filter?: string;
    index: string;
    service: string;
    transactionName: string;
    transactionType: string;
}

export interface KibanaSloApmLatencyIndicator {
    environment: string;
    filter?: string;
    index: string;
    service: string;
    threshold: number;
    transactionName: string;
    transactionType: string;
}

export interface KibanaSloHistogramCustomIndicator {
    filter?: string;
    good: outputs.KibanaSloHistogramCustomIndicatorGood;
    index: string;
    timestampField?: string;
    total: outputs.KibanaSloHistogramCustomIndicatorTotal;
}

export interface KibanaSloHistogramCustomIndicatorGood {
    aggregation: string;
    field: string;
    filter?: string;
    from?: number;
    to?: number;
}

export interface KibanaSloHistogramCustomIndicatorTotal {
    aggregation: string;
    field: string;
    filter?: string;
    from?: number;
    to?: number;
}

export interface KibanaSloKqlCustomIndicator {
    filter?: string;
    good?: string;
    index: string;
    timestampField?: string;
    total?: string;
}

export interface KibanaSloMetricCustomIndicator {
    filter?: string;
    good: outputs.KibanaSloMetricCustomIndicatorGood;
    index: string;
    timestampField?: string;
    total: outputs.KibanaSloMetricCustomIndicatorTotal;
}

export interface KibanaSloMetricCustomIndicatorGood {
    equation: string;
    metrics: outputs.KibanaSloMetricCustomIndicatorGoodMetric[];
}

export interface KibanaSloMetricCustomIndicatorGoodMetric {
    aggregation: string;
    field: string;
    filter?: string;
    name: string;
}

export interface KibanaSloMetricCustomIndicatorTotal {
    equation: string;
    metrics: outputs.KibanaSloMetricCustomIndicatorTotalMetric[];
}

export interface KibanaSloMetricCustomIndicatorTotalMetric {
    aggregation: string;
    field: string;
    filter?: string;
    name: string;
}

export interface KibanaSloObjective {
    target: number;
    timesliceTarget?: number;
    timesliceWindow?: string;
}

export interface KibanaSloSettings {
    frequency: string;
    syncDelay: string;
}

export interface KibanaSloTimeWindow {
    duration: string;
    type: string;
}

export interface KibanaSyntheticsMonitorAlert {
    status?: outputs.KibanaSyntheticsMonitorAlertStatus;
    tls?: outputs.KibanaSyntheticsMonitorAlertTls;
}

export interface KibanaSyntheticsMonitorAlertStatus {
    enabled?: boolean;
}

export interface KibanaSyntheticsMonitorAlertTls {
    enabled?: boolean;
}

export interface KibanaSyntheticsMonitorHttp {
    /**
     * The check request settings.. Raw JSON object, use `jsonencode` function to represent JSON
     */
    check?: string;
    /**
     * Whether to ping using the ipv4 protocol.
     */
    ipv4?: boolean;
    /**
     * Whether to ping using the ipv6 protocol.
     */
    ipv6?: boolean;
    /**
     * The maximum number of redirects to follow. Default: `0`
     */
    maxRedirects?: number;
    /**
     * The mode of the monitor. Can be "all" or "any". If youre using a DNS-load balancer and want to ping every IP address for the specified hostname, you should use all.
     */
    mode?: string;
    /**
     * The password for authenticating with the server. The credentials are passed with the request.
     */
    password?: string;
    /**
     * Additional headers to send to proxies during CONNECT requests.. Raw JSON object, use `jsonencode` function to represent JSON
     */
    proxyHeader?: string;
    /**
     * The URL of the proxy to use for this monitor.
     */
    proxyUrl?: string;
    /**
     * Controls the indexing of the HTTP response body contents to the `http.response.body.contents` field.. Raw JSON object, use `jsonencode` function to represent JSON
     */
    response?: string;
    /**
     * List of allowed SSL/TLS versions.
     */
    sslSupportedProtocols?: string[];
    /**
     * Controls the verification of server certificates.
     */
    sslVerificationMode?: string;
    /**
     * URL to monitor.
     */
    url: string;
    /**
     * The username for authenticating with the server. The credentials are passed with the request.
     */
    username?: string;
}

export interface KibanaSyntheticsMonitorTcp {
    /**
     * The expected answer.
     */
    checkReceive?: string;
    /**
     * An optional payload string to send to the remote host.
     */
    checkSend?: string;
    /**
     * The host to monitor; it can be an IP address or a hostname. The host can include the port using a colon (e.g., "example.com:9200").
     */
    host: string;
    /**
     * The URL of the SOCKS5 proxy to use when connecting to the server. The value must be a URL with a scheme of `socks5://`. If the SOCKS5 proxy server requires client authentication, then a username and password can be embedded in the URL. When using a proxy, hostnames are resolved on the proxy server instead of on the client. You can change this behavior by setting the `proxy_use_local_resolver` option.
     */
    proxyUrl?: string;
    /**
     * A Boolean value that determines whether hostnames are resolved locally instead of being resolved on the proxy server. The default value is false, which means that name resolution occurs on the proxy server.
     */
    proxyUseLocalResolver?: boolean;
    /**
     * List of allowed SSL/TLS versions.
     */
    sslSupportedProtocols?: string[];
    /**
     * Controls the verification of server certificates.
     */
    sslVerificationMode?: string;
}

export interface KibanaSyntheticsPrivateLocationGeo {
    /**
     * The latitude of the location.
     */
    lat: number;
    /**
     * The longitude of the location.
     */
    lon: number;
}

export namespace config {
    export interface Elasticsearch {
        /**
         * API Key to use for authentication to Elasticsearch
         */
        apiKey?: string;
        /**
         * Bearer Token to use for authentication to Elasticsearch
         */
        bearerToken?: string;
        /**
         * PEM-encoded custom Certificate Authority certificate
         */
        caData?: string;
        /**
         * Path to a custom Certificate Authority certificate
         */
        caFile?: string;
        /**
         * PEM encoded certificate for client auth
         */
        certData?: string;
        /**
         * Path to a file containing the PEM encoded certificate for client auth
         */
        certFile?: string;
        endpoints?: string[];
        /**
         * ES Client Authentication field to be used with the bearer token
         */
        esClientAuthentication?: string;
        /**
         * Disable TLS certificate validation
         */
        insecure?: boolean;
        /**
         * PEM encoded private key for client auth
         */
        keyData?: string;
        /**
         * Path to a file containing the PEM encoded private key for client auth
         */
        keyFile?: string;
        /**
         * Password to use for API authentication to Elasticsearch.
         */
        password?: string;
        /**
         * Username to use for API authentication to Elasticsearch.
         */
        username?: string;
    }

    export interface Fleet {
        /**
         * API Key to use for authentication to Fleet.
         */
        apiKey?: string;
        /**
         * A list of paths to CA certificates to validate the certificate presented by the Fleet server.
         */
        caCerts?: string[];
        endpoint?: string;
        /**
         * Disable TLS certificate validation
         */
        insecure?: boolean;
        /**
         * Password to use for API authentication to Fleet.
         */
        password?: string;
        /**
         * Username to use for API authentication to Fleet.
         */
        username?: string;
    }

    export interface Kibana {
        /**
         * API Key to use for authentication to Kibana
         */
        apiKey?: string;
        /**
         * A list of paths to CA certificates to validate the certificate presented by the Kibana server.
         */
        caCerts?: string[];
        endpoints?: string[];
        /**
         * Disable TLS certificate validation
         */
        insecure?: boolean;
        /**
         * Password to use for API authentication to Kibana.
         */
        password?: string;
        /**
         * Username to use for API authentication to Kibana.
         */
        username?: string;
    }

}
