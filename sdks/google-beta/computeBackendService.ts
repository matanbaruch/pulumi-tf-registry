// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class ComputeBackendService extends pulumi.CustomResource {
    /**
     * Get an existing ComputeBackendService resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ComputeBackendServiceState, opts?: pulumi.CustomResourceOptions): ComputeBackendService {
        return new ComputeBackendService(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'google-beta:index/computeBackendService:ComputeBackendService';

    /**
     * Returns true if the given object is an instance of ComputeBackendService.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ComputeBackendService {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ComputeBackendService.__pulumiType;
    }

    /**
     * Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set to 0, the cookie is non-persistent and
     * lasts only until the end of the browser session (or equivalent). The maximum allowed value for TTL is one day. When the
     * load balancing scheme is INTERNAL, this field is not used.
     */
    public readonly affinityCookieTtlSec!: pulumi.Output<number | undefined>;
    /**
     * The set of backends that serve this BackendService.
     */
    public readonly backends!: pulumi.Output<outputs.ComputeBackendServiceBackend[] | undefined>;
    /**
     * Cloud CDN configuration for this BackendService.
     */
    public readonly cdnPolicy!: pulumi.Output<outputs.ComputeBackendServiceCdnPolicy | undefined>;
    /**
     * Settings controlling the volume of connections to a backend service. This field is applicable only when the
     * load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
     */
    public readonly circuitBreakers!: pulumi.Output<outputs.ComputeBackendServiceCircuitBreakers | undefined>;
    /**
     * Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header. Possible values:
     * ["AUTOMATIC", "DISABLED"]
     */
    public readonly compressionMode!: pulumi.Output<string | undefined>;
    /**
     * Time for which instance will be drained (not accept new connections, but still work to finish started).
     */
    public readonly connectionDrainingTimeoutSec!: pulumi.Output<number | undefined>;
    /**
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or
     * other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular
     * destination host will be lost when one or more hosts are added/removed from the destination service. This field
     * specifies parameters that control consistent hashing. This field only applies if the load_balancing_scheme is set to
     * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is set to MAGLEV or RING_HASH.
     */
    public readonly consistentHash!: pulumi.Output<outputs.ComputeBackendServiceConsistentHash | undefined>;
    /**
     * Creation timestamp in RFC3339 text format.
     */
    public /*out*/ readonly creationTimestamp!: pulumi.Output<string>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied requests.
     */
    public readonly customRequestHeaders!: pulumi.Output<string[] | undefined>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied responses.
     */
    public readonly customResponseHeaders!: pulumi.Output<string[] | undefined>;
    /**
     * An optional description of this resource.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * The resource URL for the edge security policy associated with this backend service.
     */
    public readonly edgeSecurityPolicy!: pulumi.Output<string | undefined>;
    /**
     * If true, enable Cloud CDN for this BackendService.
     */
    public readonly enableCdn!: pulumi.Output<boolean | undefined>;
    /**
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking.
     */
    public /*out*/ readonly fingerprint!: pulumi.Output<string>;
    /**
     * The unique identifier for the resource. This identifier is defined by the server.
     */
    public /*out*/ readonly generatedId!: pulumi.Output<number>;
    /**
     * The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health checking this BackendService. Currently
     * at most one health check can be specified. A health check must be specified unless the backend service uses an internet
     * or serverless NEG as a backend. For internal load balancing, a URL to a HealthCheck resource must be specified instead.
     */
    public readonly healthChecks!: pulumi.Output<string[] | undefined>;
    /**
     * Settings for enabling Cloud Identity Aware Proxy
     */
    public readonly iap!: pulumi.Output<outputs.ComputeBackendServiceIap | undefined>;
    /**
     * Indicates whether the backend service will be used with internal or external load balancing. A backend service created
     * for one type of load balancing cannot be used with the other. For more information, refer to [Choosing a load
     * balancer](https://cloud.google.com/load-balancing/docs/backend-service). Default value: "EXTERNAL" Possible values:
     * ["EXTERNAL", "INTERNAL_SELF_MANAGED", "INTERNAL_MANAGED", "EXTERNAL_MANAGED"]
     */
    public readonly loadBalancingScheme!: pulumi.Output<string | undefined>;
    /**
     * A list of locality load balancing policies to be used in order of preference. Either the policy or the customPolicy
     * field should be set. Overrides any value set in the localityLbPolicy field. localityLbPolicies is only supported when
     * the BackendService is referenced by a URL Map that is referenced by a target gRPC proxy that has the
     * validateForProxyless field set to true.
     */
    public readonly localityLbPolicies!: pulumi.Output<outputs.ComputeBackendServiceLocalityLbPolicy[] | undefined>;
    /**
     * The load balancing algorithm used within the scope of the locality. The possible values are: * 'ROUND_ROBIN': This is a
     * simple policy in which each healthy backend is selected in round robin order. * 'LEAST_REQUEST': An O(1) algorithm which
     * selects two random healthy hosts and picks the host which has fewer active requests. * 'RING_HASH': The ring/modulo hash
     * load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a
     * host from a set of N hosts only affects 1/N of the requests. * 'RANDOM': The load balancer selects a random healthy
     * host. * 'ORIGINAL_DESTINATION': Backend host is selected based on the client connection metadata, i.e., connections are
     * opened to the same address as the destination address of the incoming connection before the connection was redirected to
     * the load balancer. * 'MAGLEV': used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as
     * ring hash but has faster table lookup build times and host selection times. For more information about Maglev, refer to
     * https://ai.google/research/pubs/pub44824 * 'WEIGHTED_MAGLEV': Per-instance weighted Load Balancing via health check
     * reported weights. If set, the Backend Service must configure a non legacy HTTP-based Health Check, and health check
     * replies are expected to contain non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to specify the
     * per-instance weights. If set, Load Balancing is weight based on the per-instance weights reported in the last processed
     * health check replies, as long as every instance either reported a valid weight or had UNAVAILABLE_WEIGHT. Otherwise,
     * Load Balancing remains equal-weight. This field is applicable to either: * A regional backend service with the
     * service_protocol set to HTTP, HTTPS, or HTTP2, and loadBalancingScheme set to INTERNAL_MANAGED. * A global backend
     * service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. * A regional backend service with
     * loadBalancingScheme set to EXTERNAL (External Network Load Balancing). Only MAGLEV and WEIGHTED_MAGLEV values are
     * possible for External Network Load Balancing. The default is MAGLEV. If session_affinity is not NONE, and this field is
     * not set to MAGLEV, WEIGHTED_MAGLEV, or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and
     * RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has
     * validate_for_proxyless field set to true. Possible values: ["ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM",
     * "ORIGINAL_DESTINATION", "MAGLEV", "WEIGHTED_MAGLEV"]
     */
    public readonly localityLbPolicy!: pulumi.Output<string | undefined>;
    /**
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is
     * enabled, logs will be exported to Stackdriver.
     */
    public readonly logConfig!: pulumi.Output<outputs.ComputeBackendServiceLogConfig | undefined>;
    /**
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and
     * comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression 'a-z?' which
     * means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or
     * digit, except the last character, which cannot be a dash.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Settings controlling eviction of unhealthy hosts from the load balancing pool. Applicable backend service types can be a
     * global backend service with the loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
     */
    public readonly outlierDetection!: pulumi.Output<outputs.ComputeBackendServiceOutlierDetection | undefined>;
    /**
     * Name of backend port. The same name should appear in the instance groups referenced by this service. Required when the
     * load balancing scheme is EXTERNAL.
     */
    public readonly portName!: pulumi.Output<string>;
    public readonly project!: pulumi.Output<string>;
    /**
     * The protocol this BackendService uses to communicate with backends. The default is HTTP. **NOTE**: HTTP2 is only valid
     * for beta HTTP/2 load balancer types and may result in errors if used with the GA API. **NOTE**: With protocol
     * “UNSPECIFIED”, the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing with
     * TCP/UDP/L3_DEFAULT Forwarding Rule protocol. Possible values: ["HTTP", "HTTPS", "HTTP2", "TCP", "SSL", "GRPC",
     * "UNSPECIFIED"]
     */
    public readonly protocol!: pulumi.Output<string>;
    /**
     * The security policy associated with this backend service.
     */
    public readonly securityPolicy!: pulumi.Output<string | undefined>;
    /**
     * The security settings that apply to this backend service. This field is applicable to either a regional backend service
     * with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED; or a global
     * backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     */
    public readonly securitySettings!: pulumi.Output<outputs.ComputeBackendServiceSecuritySettings | undefined>;
    public /*out*/ readonly selfLink!: pulumi.Output<string>;
    /**
     * URL to networkservices.ServiceLbPolicy resource. Can only be set if load balancing scheme is EXTERNAL, EXTERNAL_MANAGED,
     * INTERNAL_MANAGED or INTERNAL_SELF_MANAGED and the scope is global.
     */
    public readonly serviceLbPolicy!: pulumi.Output<string | undefined>;
    /**
     * Type of session affinity to use. The default is NONE. Session affinity is not applicable if the protocol is UDP.
     * Possible values: ["NONE", "CLIENT_IP", "CLIENT_IP_PORT_PROTO", "CLIENT_IP_PROTO", "GENERATED_COOKIE", "HEADER_FIELD",
     * "HTTP_COOKIE"]
     */
    public readonly sessionAffinity!: pulumi.Output<string>;
    /**
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,
     * [Backend service settings](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices). The default is 30
     * seconds. The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
     */
    public readonly timeoutSec!: pulumi.Output<number>;
    public readonly timeouts!: pulumi.Output<outputs.ComputeBackendServiceTimeouts | undefined>;

    /**
     * Create a ComputeBackendService resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: ComputeBackendServiceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ComputeBackendServiceArgs | ComputeBackendServiceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ComputeBackendServiceState | undefined;
            resourceInputs["affinityCookieTtlSec"] = state ? state.affinityCookieTtlSec : undefined;
            resourceInputs["backends"] = state ? state.backends : undefined;
            resourceInputs["cdnPolicy"] = state ? state.cdnPolicy : undefined;
            resourceInputs["circuitBreakers"] = state ? state.circuitBreakers : undefined;
            resourceInputs["compressionMode"] = state ? state.compressionMode : undefined;
            resourceInputs["connectionDrainingTimeoutSec"] = state ? state.connectionDrainingTimeoutSec : undefined;
            resourceInputs["consistentHash"] = state ? state.consistentHash : undefined;
            resourceInputs["creationTimestamp"] = state ? state.creationTimestamp : undefined;
            resourceInputs["customRequestHeaders"] = state ? state.customRequestHeaders : undefined;
            resourceInputs["customResponseHeaders"] = state ? state.customResponseHeaders : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["edgeSecurityPolicy"] = state ? state.edgeSecurityPolicy : undefined;
            resourceInputs["enableCdn"] = state ? state.enableCdn : undefined;
            resourceInputs["fingerprint"] = state ? state.fingerprint : undefined;
            resourceInputs["generatedId"] = state ? state.generatedId : undefined;
            resourceInputs["healthChecks"] = state ? state.healthChecks : undefined;
            resourceInputs["iap"] = state ? state.iap : undefined;
            resourceInputs["loadBalancingScheme"] = state ? state.loadBalancingScheme : undefined;
            resourceInputs["localityLbPolicies"] = state ? state.localityLbPolicies : undefined;
            resourceInputs["localityLbPolicy"] = state ? state.localityLbPolicy : undefined;
            resourceInputs["logConfig"] = state ? state.logConfig : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["outlierDetection"] = state ? state.outlierDetection : undefined;
            resourceInputs["portName"] = state ? state.portName : undefined;
            resourceInputs["project"] = state ? state.project : undefined;
            resourceInputs["protocol"] = state ? state.protocol : undefined;
            resourceInputs["securityPolicy"] = state ? state.securityPolicy : undefined;
            resourceInputs["securitySettings"] = state ? state.securitySettings : undefined;
            resourceInputs["selfLink"] = state ? state.selfLink : undefined;
            resourceInputs["serviceLbPolicy"] = state ? state.serviceLbPolicy : undefined;
            resourceInputs["sessionAffinity"] = state ? state.sessionAffinity : undefined;
            resourceInputs["timeoutSec"] = state ? state.timeoutSec : undefined;
            resourceInputs["timeouts"] = state ? state.timeouts : undefined;
        } else {
            const args = argsOrState as ComputeBackendServiceArgs | undefined;
            resourceInputs["affinityCookieTtlSec"] = args ? args.affinityCookieTtlSec : undefined;
            resourceInputs["backends"] = args ? args.backends : undefined;
            resourceInputs["cdnPolicy"] = args ? args.cdnPolicy : undefined;
            resourceInputs["circuitBreakers"] = args ? args.circuitBreakers : undefined;
            resourceInputs["compressionMode"] = args ? args.compressionMode : undefined;
            resourceInputs["connectionDrainingTimeoutSec"] = args ? args.connectionDrainingTimeoutSec : undefined;
            resourceInputs["consistentHash"] = args ? args.consistentHash : undefined;
            resourceInputs["customRequestHeaders"] = args ? args.customRequestHeaders : undefined;
            resourceInputs["customResponseHeaders"] = args ? args.customResponseHeaders : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["edgeSecurityPolicy"] = args ? args.edgeSecurityPolicy : undefined;
            resourceInputs["enableCdn"] = args ? args.enableCdn : undefined;
            resourceInputs["healthChecks"] = args ? args.healthChecks : undefined;
            resourceInputs["iap"] = args ? args.iap : undefined;
            resourceInputs["loadBalancingScheme"] = args ? args.loadBalancingScheme : undefined;
            resourceInputs["localityLbPolicies"] = args ? args.localityLbPolicies : undefined;
            resourceInputs["localityLbPolicy"] = args ? args.localityLbPolicy : undefined;
            resourceInputs["logConfig"] = args ? args.logConfig : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["outlierDetection"] = args ? args.outlierDetection : undefined;
            resourceInputs["portName"] = args ? args.portName : undefined;
            resourceInputs["project"] = args ? args.project : undefined;
            resourceInputs["protocol"] = args ? args.protocol : undefined;
            resourceInputs["securityPolicy"] = args ? args.securityPolicy : undefined;
            resourceInputs["securitySettings"] = args ? args.securitySettings : undefined;
            resourceInputs["serviceLbPolicy"] = args ? args.serviceLbPolicy : undefined;
            resourceInputs["sessionAffinity"] = args ? args.sessionAffinity : undefined;
            resourceInputs["timeoutSec"] = args ? args.timeoutSec : undefined;
            resourceInputs["timeouts"] = args ? args.timeouts : undefined;
            resourceInputs["creationTimestamp"] = undefined /*out*/;
            resourceInputs["fingerprint"] = undefined /*out*/;
            resourceInputs["generatedId"] = undefined /*out*/;
            resourceInputs["selfLink"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ComputeBackendService.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering ComputeBackendService resources.
 */
export interface ComputeBackendServiceState {
    /**
     * Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set to 0, the cookie is non-persistent and
     * lasts only until the end of the browser session (or equivalent). The maximum allowed value for TTL is one day. When the
     * load balancing scheme is INTERNAL, this field is not used.
     */
    affinityCookieTtlSec?: pulumi.Input<number>;
    /**
     * The set of backends that serve this BackendService.
     */
    backends?: pulumi.Input<pulumi.Input<inputs.ComputeBackendServiceBackend>[]>;
    /**
     * Cloud CDN configuration for this BackendService.
     */
    cdnPolicy?: pulumi.Input<inputs.ComputeBackendServiceCdnPolicy>;
    /**
     * Settings controlling the volume of connections to a backend service. This field is applicable only when the
     * load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
     */
    circuitBreakers?: pulumi.Input<inputs.ComputeBackendServiceCircuitBreakers>;
    /**
     * Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header. Possible values:
     * ["AUTOMATIC", "DISABLED"]
     */
    compressionMode?: pulumi.Input<string>;
    /**
     * Time for which instance will be drained (not accept new connections, but still work to finish started).
     */
    connectionDrainingTimeoutSec?: pulumi.Input<number>;
    /**
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or
     * other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular
     * destination host will be lost when one or more hosts are added/removed from the destination service. This field
     * specifies parameters that control consistent hashing. This field only applies if the load_balancing_scheme is set to
     * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is set to MAGLEV or RING_HASH.
     */
    consistentHash?: pulumi.Input<inputs.ComputeBackendServiceConsistentHash>;
    /**
     * Creation timestamp in RFC3339 text format.
     */
    creationTimestamp?: pulumi.Input<string>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied requests.
     */
    customRequestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied responses.
     */
    customResponseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An optional description of this resource.
     */
    description?: pulumi.Input<string>;
    /**
     * The resource URL for the edge security policy associated with this backend service.
     */
    edgeSecurityPolicy?: pulumi.Input<string>;
    /**
     * If true, enable Cloud CDN for this BackendService.
     */
    enableCdn?: pulumi.Input<boolean>;
    /**
     * Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking.
     */
    fingerprint?: pulumi.Input<string>;
    /**
     * The unique identifier for the resource. This identifier is defined by the server.
     */
    generatedId?: pulumi.Input<number>;
    /**
     * The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health checking this BackendService. Currently
     * at most one health check can be specified. A health check must be specified unless the backend service uses an internet
     * or serverless NEG as a backend. For internal load balancing, a URL to a HealthCheck resource must be specified instead.
     */
    healthChecks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Settings for enabling Cloud Identity Aware Proxy
     */
    iap?: pulumi.Input<inputs.ComputeBackendServiceIap>;
    /**
     * Indicates whether the backend service will be used with internal or external load balancing. A backend service created
     * for one type of load balancing cannot be used with the other. For more information, refer to [Choosing a load
     * balancer](https://cloud.google.com/load-balancing/docs/backend-service). Default value: "EXTERNAL" Possible values:
     * ["EXTERNAL", "INTERNAL_SELF_MANAGED", "INTERNAL_MANAGED", "EXTERNAL_MANAGED"]
     */
    loadBalancingScheme?: pulumi.Input<string>;
    /**
     * A list of locality load balancing policies to be used in order of preference. Either the policy or the customPolicy
     * field should be set. Overrides any value set in the localityLbPolicy field. localityLbPolicies is only supported when
     * the BackendService is referenced by a URL Map that is referenced by a target gRPC proxy that has the
     * validateForProxyless field set to true.
     */
    localityLbPolicies?: pulumi.Input<pulumi.Input<inputs.ComputeBackendServiceLocalityLbPolicy>[]>;
    /**
     * The load balancing algorithm used within the scope of the locality. The possible values are: * 'ROUND_ROBIN': This is a
     * simple policy in which each healthy backend is selected in round robin order. * 'LEAST_REQUEST': An O(1) algorithm which
     * selects two random healthy hosts and picks the host which has fewer active requests. * 'RING_HASH': The ring/modulo hash
     * load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a
     * host from a set of N hosts only affects 1/N of the requests. * 'RANDOM': The load balancer selects a random healthy
     * host. * 'ORIGINAL_DESTINATION': Backend host is selected based on the client connection metadata, i.e., connections are
     * opened to the same address as the destination address of the incoming connection before the connection was redirected to
     * the load balancer. * 'MAGLEV': used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as
     * ring hash but has faster table lookup build times and host selection times. For more information about Maglev, refer to
     * https://ai.google/research/pubs/pub44824 * 'WEIGHTED_MAGLEV': Per-instance weighted Load Balancing via health check
     * reported weights. If set, the Backend Service must configure a non legacy HTTP-based Health Check, and health check
     * replies are expected to contain non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to specify the
     * per-instance weights. If set, Load Balancing is weight based on the per-instance weights reported in the last processed
     * health check replies, as long as every instance either reported a valid weight or had UNAVAILABLE_WEIGHT. Otherwise,
     * Load Balancing remains equal-weight. This field is applicable to either: * A regional backend service with the
     * service_protocol set to HTTP, HTTPS, or HTTP2, and loadBalancingScheme set to INTERNAL_MANAGED. * A global backend
     * service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. * A regional backend service with
     * loadBalancingScheme set to EXTERNAL (External Network Load Balancing). Only MAGLEV and WEIGHTED_MAGLEV values are
     * possible for External Network Load Balancing. The default is MAGLEV. If session_affinity is not NONE, and this field is
     * not set to MAGLEV, WEIGHTED_MAGLEV, or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and
     * RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has
     * validate_for_proxyless field set to true. Possible values: ["ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM",
     * "ORIGINAL_DESTINATION", "MAGLEV", "WEIGHTED_MAGLEV"]
     */
    localityLbPolicy?: pulumi.Input<string>;
    /**
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is
     * enabled, logs will be exported to Stackdriver.
     */
    logConfig?: pulumi.Input<inputs.ComputeBackendServiceLogConfig>;
    /**
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and
     * comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression 'a-z?' which
     * means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or
     * digit, except the last character, which cannot be a dash.
     */
    name?: pulumi.Input<string>;
    /**
     * Settings controlling eviction of unhealthy hosts from the load balancing pool. Applicable backend service types can be a
     * global backend service with the loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
     */
    outlierDetection?: pulumi.Input<inputs.ComputeBackendServiceOutlierDetection>;
    /**
     * Name of backend port. The same name should appear in the instance groups referenced by this service. Required when the
     * load balancing scheme is EXTERNAL.
     */
    portName?: pulumi.Input<string>;
    project?: pulumi.Input<string>;
    /**
     * The protocol this BackendService uses to communicate with backends. The default is HTTP. **NOTE**: HTTP2 is only valid
     * for beta HTTP/2 load balancer types and may result in errors if used with the GA API. **NOTE**: With protocol
     * “UNSPECIFIED”, the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing with
     * TCP/UDP/L3_DEFAULT Forwarding Rule protocol. Possible values: ["HTTP", "HTTPS", "HTTP2", "TCP", "SSL", "GRPC",
     * "UNSPECIFIED"]
     */
    protocol?: pulumi.Input<string>;
    /**
     * The security policy associated with this backend service.
     */
    securityPolicy?: pulumi.Input<string>;
    /**
     * The security settings that apply to this backend service. This field is applicable to either a regional backend service
     * with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED; or a global
     * backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     */
    securitySettings?: pulumi.Input<inputs.ComputeBackendServiceSecuritySettings>;
    selfLink?: pulumi.Input<string>;
    /**
     * URL to networkservices.ServiceLbPolicy resource. Can only be set if load balancing scheme is EXTERNAL, EXTERNAL_MANAGED,
     * INTERNAL_MANAGED or INTERNAL_SELF_MANAGED and the scope is global.
     */
    serviceLbPolicy?: pulumi.Input<string>;
    /**
     * Type of session affinity to use. The default is NONE. Session affinity is not applicable if the protocol is UDP.
     * Possible values: ["NONE", "CLIENT_IP", "CLIENT_IP_PORT_PROTO", "CLIENT_IP_PROTO", "GENERATED_COOKIE", "HEADER_FIELD",
     * "HTTP_COOKIE"]
     */
    sessionAffinity?: pulumi.Input<string>;
    /**
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,
     * [Backend service settings](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices). The default is 30
     * seconds. The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
     */
    timeoutSec?: pulumi.Input<number>;
    timeouts?: pulumi.Input<inputs.ComputeBackendServiceTimeouts>;
}

/**
 * The set of arguments for constructing a ComputeBackendService resource.
 */
export interface ComputeBackendServiceArgs {
    /**
     * Lifetime of cookies in seconds if session_affinity is GENERATED_COOKIE. If set to 0, the cookie is non-persistent and
     * lasts only until the end of the browser session (or equivalent). The maximum allowed value for TTL is one day. When the
     * load balancing scheme is INTERNAL, this field is not used.
     */
    affinityCookieTtlSec?: pulumi.Input<number>;
    /**
     * The set of backends that serve this BackendService.
     */
    backends?: pulumi.Input<pulumi.Input<inputs.ComputeBackendServiceBackend>[]>;
    /**
     * Cloud CDN configuration for this BackendService.
     */
    cdnPolicy?: pulumi.Input<inputs.ComputeBackendServiceCdnPolicy>;
    /**
     * Settings controlling the volume of connections to a backend service. This field is applicable only when the
     * load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
     */
    circuitBreakers?: pulumi.Input<inputs.ComputeBackendServiceCircuitBreakers>;
    /**
     * Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header. Possible values:
     * ["AUTOMATIC", "DISABLED"]
     */
    compressionMode?: pulumi.Input<string>;
    /**
     * Time for which instance will be drained (not accept new connections, but still work to finish started).
     */
    connectionDrainingTimeoutSec?: pulumi.Input<number>;
    /**
     * Consistent Hash-based load balancing can be used to provide soft session affinity based on HTTP headers, cookies or
     * other properties. This load balancing policy is applicable only for HTTP connections. The affinity to a particular
     * destination host will be lost when one or more hosts are added/removed from the destination service. This field
     * specifies parameters that control consistent hashing. This field only applies if the load_balancing_scheme is set to
     * INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is set to MAGLEV or RING_HASH.
     */
    consistentHash?: pulumi.Input<inputs.ComputeBackendServiceConsistentHash>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied requests.
     */
    customRequestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Headers that the HTTP/S load balancer should add to proxied responses.
     */
    customResponseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * An optional description of this resource.
     */
    description?: pulumi.Input<string>;
    /**
     * The resource URL for the edge security policy associated with this backend service.
     */
    edgeSecurityPolicy?: pulumi.Input<string>;
    /**
     * If true, enable Cloud CDN for this BackendService.
     */
    enableCdn?: pulumi.Input<boolean>;
    /**
     * The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource for health checking this BackendService. Currently
     * at most one health check can be specified. A health check must be specified unless the backend service uses an internet
     * or serverless NEG as a backend. For internal load balancing, a URL to a HealthCheck resource must be specified instead.
     */
    healthChecks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Settings for enabling Cloud Identity Aware Proxy
     */
    iap?: pulumi.Input<inputs.ComputeBackendServiceIap>;
    /**
     * Indicates whether the backend service will be used with internal or external load balancing. A backend service created
     * for one type of load balancing cannot be used with the other. For more information, refer to [Choosing a load
     * balancer](https://cloud.google.com/load-balancing/docs/backend-service). Default value: "EXTERNAL" Possible values:
     * ["EXTERNAL", "INTERNAL_SELF_MANAGED", "INTERNAL_MANAGED", "EXTERNAL_MANAGED"]
     */
    loadBalancingScheme?: pulumi.Input<string>;
    /**
     * A list of locality load balancing policies to be used in order of preference. Either the policy or the customPolicy
     * field should be set. Overrides any value set in the localityLbPolicy field. localityLbPolicies is only supported when
     * the BackendService is referenced by a URL Map that is referenced by a target gRPC proxy that has the
     * validateForProxyless field set to true.
     */
    localityLbPolicies?: pulumi.Input<pulumi.Input<inputs.ComputeBackendServiceLocalityLbPolicy>[]>;
    /**
     * The load balancing algorithm used within the scope of the locality. The possible values are: * 'ROUND_ROBIN': This is a
     * simple policy in which each healthy backend is selected in round robin order. * 'LEAST_REQUEST': An O(1) algorithm which
     * selects two random healthy hosts and picks the host which has fewer active requests. * 'RING_HASH': The ring/modulo hash
     * load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a
     * host from a set of N hosts only affects 1/N of the requests. * 'RANDOM': The load balancer selects a random healthy
     * host. * 'ORIGINAL_DESTINATION': Backend host is selected based on the client connection metadata, i.e., connections are
     * opened to the same address as the destination address of the incoming connection before the connection was redirected to
     * the load balancer. * 'MAGLEV': used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as
     * ring hash but has faster table lookup build times and host selection times. For more information about Maglev, refer to
     * https://ai.google/research/pubs/pub44824 * 'WEIGHTED_MAGLEV': Per-instance weighted Load Balancing via health check
     * reported weights. If set, the Backend Service must configure a non legacy HTTP-based Health Check, and health check
     * replies are expected to contain non-standard HTTP response header field X-Load-Balancing-Endpoint-Weight to specify the
     * per-instance weights. If set, Load Balancing is weight based on the per-instance weights reported in the last processed
     * health check replies, as long as every instance either reported a valid weight or had UNAVAILABLE_WEIGHT. Otherwise,
     * Load Balancing remains equal-weight. This field is applicable to either: * A regional backend service with the
     * service_protocol set to HTTP, HTTPS, or HTTP2, and loadBalancingScheme set to INTERNAL_MANAGED. * A global backend
     * service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED. * A regional backend service with
     * loadBalancingScheme set to EXTERNAL (External Network Load Balancing). Only MAGLEV and WEIGHTED_MAGLEV values are
     * possible for External Network Load Balancing. The default is MAGLEV. If session_affinity is not NONE, and this field is
     * not set to MAGLEV, WEIGHTED_MAGLEV, or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and
     * RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has
     * validate_for_proxyless field set to true. Possible values: ["ROUND_ROBIN", "LEAST_REQUEST", "RING_HASH", "RANDOM",
     * "ORIGINAL_DESTINATION", "MAGLEV", "WEIGHTED_MAGLEV"]
     */
    localityLbPolicy?: pulumi.Input<string>;
    /**
     * This field denotes the logging options for the load balancer traffic served by this backend service. If logging is
     * enabled, logs will be exported to Stackdriver.
     */
    logConfig?: pulumi.Input<inputs.ComputeBackendServiceLogConfig>;
    /**
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and
     * comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression 'a-z?' which
     * means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or
     * digit, except the last character, which cannot be a dash.
     */
    name?: pulumi.Input<string>;
    /**
     * Settings controlling eviction of unhealthy hosts from the load balancing pool. Applicable backend service types can be a
     * global backend service with the loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL_MANAGED.
     */
    outlierDetection?: pulumi.Input<inputs.ComputeBackendServiceOutlierDetection>;
    /**
     * Name of backend port. The same name should appear in the instance groups referenced by this service. Required when the
     * load balancing scheme is EXTERNAL.
     */
    portName?: pulumi.Input<string>;
    project?: pulumi.Input<string>;
    /**
     * The protocol this BackendService uses to communicate with backends. The default is HTTP. **NOTE**: HTTP2 is only valid
     * for beta HTTP/2 load balancer types and may result in errors if used with the GA API. **NOTE**: With protocol
     * “UNSPECIFIED”, the backend service can be used by Layer 4 Internal Load Balancing or Network Load Balancing with
     * TCP/UDP/L3_DEFAULT Forwarding Rule protocol. Possible values: ["HTTP", "HTTPS", "HTTP2", "TCP", "SSL", "GRPC",
     * "UNSPECIFIED"]
     */
    protocol?: pulumi.Input<string>;
    /**
     * The security policy associated with this backend service.
     */
    securityPolicy?: pulumi.Input<string>;
    /**
     * The security settings that apply to this backend service. This field is applicable to either a regional backend service
     * with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED; or a global
     * backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED.
     */
    securitySettings?: pulumi.Input<inputs.ComputeBackendServiceSecuritySettings>;
    /**
     * URL to networkservices.ServiceLbPolicy resource. Can only be set if load balancing scheme is EXTERNAL, EXTERNAL_MANAGED,
     * INTERNAL_MANAGED or INTERNAL_SELF_MANAGED and the scope is global.
     */
    serviceLbPolicy?: pulumi.Input<string>;
    /**
     * Type of session affinity to use. The default is NONE. Session affinity is not applicable if the protocol is UDP.
     * Possible values: ["NONE", "CLIENT_IP", "CLIENT_IP_PORT_PROTO", "CLIENT_IP_PROTO", "GENERATED_COOKIE", "HEADER_FIELD",
     * "HTTP_COOKIE"]
     */
    sessionAffinity?: pulumi.Input<string>;
    /**
     * The backend service timeout has a different meaning depending on the type of load balancer. For more information see,
     * [Backend service settings](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices). The default is 30
     * seconds. The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds.
     */
    timeoutSec?: pulumi.Input<number>;
    timeouts?: pulumi.Input<inputs.ComputeBackendServiceTimeouts>;
}
