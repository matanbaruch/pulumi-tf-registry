// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppOnboardingCitrixvdiAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlCloudConfig>;
    /**
     * Custom DNS setup
     */
    dnsCustom?: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlDnsCustom>;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlDnsService>;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: pulumi.Input<string>;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlHealthCheckInfo>;
    id?: pulumi.Input<string>;
    /**
     * server domain name or IP
     */
    internalDomain: pulumi.Input<string>;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlProtocols>;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlSslCert>;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: pulumi.Input<boolean>;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingCitrixvdiAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: pulumi.Input<string>;
    /**
     * Attach Point id details
     */
    attachPointId?: pulumi.Input<string>;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: pulumi.Input<boolean>;
    backendIpAddressDns?: pulumi.Input<boolean>;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: pulumi.Input<string>;
    /**
     * Name of the region where app is available, e.g: us-west2, westus etc
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
    /**
     * Available options, MAINTAIN & MODIFY
     */
    tgwAppRoutetable?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: pulumi.Input<string>;
    /**
     * DNS Server List
     */
    dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingCitrixvdiAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: pulumi.Input<string>;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiAppUrlHealthCheckInfo {
    enabled?: pulumi.Input<boolean>;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiAppUrlProtocols {
    isValidProtocolPort?: pulumi.Input<boolean>;
    /**
     * Customized websocket paths
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * target port number
     */
    port: pulumi.Input<number>;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: pulumi.Input<string>;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingCitrixvdiAppUrlSslCert {
    /**
     * Select from already existing certificates(In certificate TAB)
     */
    existingCert?: pulumi.Input<string>;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: pulumi.Input<boolean>;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: pulumi.Input<pulumi.Input<inputs.AppOnboardingCitrixvdiAppUrlSslCertUploadCert>[]>;
}

export interface AppOnboardingCitrixvdiAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: pulumi.Input<string>;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: pulumi.Input<string>;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: pulumi.Input<string>;
}

export interface AppOnboardingCitrixvdiTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlCloudConfig>;
    /**
     * Custom DNS setup
     */
    dnsCustom?: pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlDnsCustom>;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlDnsService>;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType?: pulumi.Input<string>;
    /**
     * Application health check config from edge
     */
    healthCheckInfo?: pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlHealthCheckInfo>;
    id?: pulumi.Input<string>;
    /**
     * server domain name or IP
     */
    internalDomain: pulumi.Input<string>;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlSslCert>;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: pulumi.Input<boolean>;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption?: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingCloudsvcAppUrlCloudConfigEdgeRegion {
    buckets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of the region where app is available
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: pulumi.Input<string>;
    /**
     * DNS Server List
     */
    dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingCloudsvcAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: pulumi.Input<string>;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcAppUrlHealthCheckInfo {
    enabled?: pulumi.Input<boolean>;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcAppUrlSslCert {
    /**
     * Select from already existing certificates(In certificate TAB)
     */
    existingCert?: pulumi.Input<string>;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: pulumi.Input<boolean>;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: pulumi.Input<pulumi.Input<inputs.AppOnboardingCloudsvcAppUrlSslCertUploadCert>[]>;
}

export interface AppOnboardingCloudsvcAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingCloudsvcTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface AppOnboardingDnsAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingDnsAppUrlCloudConfig>;
    id?: pulumi.Input<string>;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: pulumi.Input<pulumi.Input<inputs.AppOnboardingDnsAppUrlProtocol>[]>;
    /**
     * Service Ip Address
     */
    serviceIp?: pulumi.Input<string>;
    /**
     * Select if the target needs to be assigned a specific IP address or it could be auto-generated. Even if manually assigned, the address needs to be from the service core IP pool. Default method is to auto generate an IP address from the service core pool.
     */
    serviceIpType: pulumi.Input<string>;
}

export interface AppOnboardingDnsAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingDnsAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingDnsAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: pulumi.Input<string>;
    /**
     * Attach Point id details
     */
    attachPointId?: pulumi.Input<string>;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: pulumi.Input<boolean>;
    backendIpAddressDns?: pulumi.Input<boolean>;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: pulumi.Input<string>;
    /**
     * Name of the region where app is available
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
    tgwAppRoutetable?: pulumi.Input<string>;
}

export interface AppOnboardingDnsAppUrlProtocol {
    isValidProtocolPort?: pulumi.Input<boolean>;
    /**
     * Customized websocket paths
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * target port number
     */
    portLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol?: pulumi.Input<string>;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingDnsCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingDnsTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingFqdnAppUrlCloudConfig>;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: pulumi.Input<string>;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: pulumi.Input<inputs.AppOnboardingFqdnAppUrlHealthCheckInfo>;
    id?: pulumi.Input<string>;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: pulumi.Input<pulumi.Input<inputs.AppOnboardingFqdnAppUrlProtocol>[]>;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: pulumi.Input<boolean>;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingFqdnAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingFqdnAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: pulumi.Input<string>;
    /**
     * Attach Point id details
     */
    attachPointId?: pulumi.Input<string>;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: pulumi.Input<boolean>;
    backendIpAddressDns?: pulumi.Input<boolean>;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: pulumi.Input<string>;
    /**
     * Custom DNS setup
     */
    dnsCustom?: pulumi.Input<inputs.AppOnboardingFqdnAppUrlCloudConfigEdgeRegionDnsCustom>;
    /**
     * Name of the region where app is available
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
    tgwAppRoutetable?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnAppUrlCloudConfigEdgeRegionDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: pulumi.Input<string>;
    /**
     * DNS Server List
     */
    dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingFqdnAppUrlHealthCheckInfo {
    enabled?: pulumi.Input<boolean>;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnAppUrlProtocol {
    isValidProtocolPort?: pulumi.Input<boolean>;
    /**
     * Customized websocket paths
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * target port number
     */
    portLists: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: pulumi.Input<string>;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingFqdnCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: pulumi.Input<string>;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: pulumi.Input<string>;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: pulumi.Input<string>;
}

export interface AppOnboardingFqdnTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingJumpboxAppUrlCloudConfig>;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: pulumi.Input<inputs.AppOnboardingJumpboxAppUrlDnsService>;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType?: pulumi.Input<string>;
    /**
     * Application health check config from edge
     */
    healthCheckInfo?: pulumi.Input<inputs.AppOnboardingJumpboxAppUrlHealthCheckInfo>;
    id?: pulumi.Input<string>;
    /**
     * server domain name or IP
     */
    internalDomain: pulumi.Input<string>;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: pulumi.Input<inputs.AppOnboardingJumpboxAppUrlSslCert>;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: pulumi.Input<boolean>;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud application account name
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption?: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingJumpboxAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingJumpboxAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: pulumi.Input<string>;
    /**
     * Attach Point id details
     */
    attachPointId?: pulumi.Input<string>;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: pulumi.Input<boolean>;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: pulumi.Input<string>;
    /**
     * Name of the region where app is available
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
    tgwAppRoutetable?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: pulumi.Input<string>;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxAppUrlHealthCheckInfo {
    enabled?: pulumi.Input<boolean>;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxAppUrlSslCert {
    /**
     * Select from already existing certificates(In Certificate TAB)
     */
    existingCert?: pulumi.Input<string>;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: pulumi.Input<boolean>;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: pulumi.Input<pulumi.Input<inputs.AppOnboardingJumpboxAppUrlSslCertUploadCert>[]>;
}

export interface AppOnboardingJumpboxAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingJumpboxTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface AppOnboardingWebAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: pulumi.Input<string>;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: pulumi.Input<string>;
    cloudConfig: pulumi.Input<inputs.AppOnboardingWebAppUrlCloudConfig>;
    /**
     * Custom DNS setup
     */
    dnsCustom?: pulumi.Input<inputs.AppOnboardingWebAppUrlDnsCustom>;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: pulumi.Input<inputs.AppOnboardingWebAppUrlDnsService>;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: pulumi.Input<string>;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: pulumi.Input<inputs.AppOnboardingWebAppUrlHealthCheckInfo>;
    id?: pulumi.Input<string>;
    /**
     * server domain name or IP
     */
    internalDomain: pulumi.Input<string>;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: pulumi.Input<inputs.AppOnboardingWebAppUrlProtocols>;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: pulumi.Input<inputs.AppOnboardingWebAppUrlSslCert>;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: pulumi.Input<boolean>;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: pulumi.Input<string>;
}

export interface AppOnboardingWebAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: pulumi.Input<string>;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: pulumi.Input<string>;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: pulumi.Input<string>;
    edgeRegions?: pulumi.Input<pulumi.Input<inputs.AppOnboardingWebAppUrlCloudConfigEdgeRegion>[]>;
    hasPrivateConnectionOptions?: pulumi.Input<boolean>;
    isShowConnectionOptions?: pulumi.Input<boolean>;
}

export interface AppOnboardingWebAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: pulumi.Input<string>;
    /**
     * Attach Point id details
     */
    attachPointId?: pulumi.Input<string>;
    /**
     * if Set to true, auto discoverers available endpoints
     */
    backendIpAddressDiscover: pulumi.Input<boolean>;
    backendIpAddressDns?: pulumi.Input<boolean>;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: pulumi.Input<string>;
    /**
     * Name of the region where app is available
     */
    regionName?: pulumi.Input<string>;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: pulumi.Input<string>;
    tgwAppRoutetable?: pulumi.Input<string>;
}

export interface AppOnboardingWebAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: pulumi.Input<string>;
    /**
     * DNS Server List
     */
    dnsServers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingWebAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: pulumi.Input<string>;
    /**
     * Type of DNS service: e.g: manual, route 53, prosimo
     */
    type: pulumi.Input<string>;
}

export interface AppOnboardingWebAppUrlHealthCheckInfo {
    enabled?: pulumi.Input<boolean>;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: pulumi.Input<string>;
}

export interface AppOnboardingWebAppUrlProtocols {
    isValidProtocolPort?: pulumi.Input<boolean>;
    /**
     * Customized websocket paths
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * target port number
     */
    port: pulumi.Input<number>;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: pulumi.Input<string>;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: pulumi.Input<boolean>;
}

export interface AppOnboardingWebAppUrlSslCert {
    /**
     * Select from already existing certificates(In Certificate TAB)
     */
    existingCert?: pulumi.Input<string>;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: pulumi.Input<boolean>;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: pulumi.Input<pulumi.Input<inputs.AppOnboardingWebAppUrlSslCertUploadCert>[]>;
}

export interface AppOnboardingWebAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface AppOnboardingWebCustomizePolicy {
    name?: pulumi.Input<string>;
}

export interface AppOnboardingWebSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: pulumi.Input<string>;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: pulumi.Input<string>;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: pulumi.Input<string>;
}

export interface AppOnboardingWebTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface CacheRulesAppDomain {
    domain?: pulumi.Input<string>;
    id?: pulumi.Input<string>;
}

export interface CacheRulesBypassInfo {
    respHdrs?: pulumi.Input<pulumi.Input<inputs.CacheRulesBypassInfoRespHdr>[]>;
}

export interface CacheRulesBypassInfoRespHdr {
    contentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    xJenkinsSessions?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CacheRulesPathPattern {
    bypassUri: pulumi.Input<boolean>;
    isDefault: pulumi.Input<boolean>;
    isNewPath: pulumi.Input<boolean>;
    /**
     * Path to store cache
     */
    path: pulumi.Input<string>;
    settings: pulumi.Input<pulumi.Input<inputs.CacheRulesPathPatternSetting>[]>;
    status: pulumi.Input<string>;
}

export interface CacheRulesPathPatternSetting {
    cacheControlIgnored: pulumi.Input<boolean>;
    cookieIgnored: pulumi.Input<boolean>;
    queryParameterIgnored: pulumi.Input<boolean>;
    ttls: pulumi.Input<pulumi.Input<inputs.CacheRulesPathPatternSettingTtl>[]>;
    type: pulumi.Input<string>;
    userIdIgnored: pulumi.Input<boolean>;
}

export interface CacheRulesPathPatternSettingTtl {
    enabled: pulumi.Input<boolean>;
    time: pulumi.Input<number>;
    timeUnit: pulumi.Input<string>;
}

export interface CertificatesUploadCaCert {
    /**
     * Path to the  CA certificate
     */
    certPath?: pulumi.Input<string>;
}

export interface CertificatesUploadClientCert {
    /**
     * Path to the certificate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to the private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface CertificatesUploadDomainCert {
    /**
     * Path to the certficate
     */
    certPath?: pulumi.Input<string>;
    /**
     * Path to the private key
     */
    privateKeyPath?: pulumi.Input<string>;
}

export interface CloudCredsAws {
    /**
     * Access Key options
     */
    accessKeys?: pulumi.Input<inputs.CloudCredsAwsAccessKeys>;
    /**
     * IAM Role options
     */
    iamRole?: pulumi.Input<inputs.CloudCredsAwsIamRole>;
    /**
     * Select preferred Authorization option, e.g: IAM Role, Access Keys
     */
    preferredAuth: pulumi.Input<string>;
}

export interface CloudCredsAwsAccessKeys {
    /**
     * Acces Key ID, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * Secret Key ID
     */
    secretKeyId: pulumi.Input<string>;
}

export interface CloudCredsAwsIamRole {
    /**
     * External ID, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html
     */
    externalId: pulumi.Input<string>;
    /**
     * Role ARN, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html
     */
    roleArn: pulumi.Input<string>;
}

export interface CloudCredsAzure {
    clientId: pulumi.Input<string>;
    secretId: pulumi.Input<string>;
    /**
     * Subscription ID, ref: https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id
     */
    subscriptionId: pulumi.Input<string>;
    /**
     * Tenant ID
     */
    tenantId: pulumi.Input<string>;
}

export interface CloudCredsBulk {
    accountId?: pulumi.Input<string>;
    externalId: pulumi.Input<string>;
    /**
     * Path of GCP credential file to upload.
     */
    filePath?: pulumi.Input<string>;
    /**
     * Tenant ID
     */
    keyType?: pulumi.Input<string>;
}

export interface CloudCredsGcp {
    authProviderX509CertUrl?: pulumi.Input<string>;
    authUri?: pulumi.Input<string>;
    clientEmail?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientX509CertUrl?: pulumi.Input<string>;
    /**
     * Path of GCP credential file to upload.
     */
    filePath: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    tokenUri?: pulumi.Input<string>;
    /**
     * Type of Credential, e.g: Service Account
     */
    type?: pulumi.Input<string>;
}

export interface DpProfileInprofileList {
    criterias: pulumi.Input<pulumi.Input<inputs.DpProfileInprofileListCriteria>[]>;
    /**
     * Select end point security profiles from the list. If the list is empty, profile needs to created first
     */
    edrProfiles?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set TRUE if you want to enable the profile, else false
     */
    enabled: pulumi.Input<boolean>;
    id?: pulumi.Input<string>;
    /**
     * Profile name
     */
    name: pulumi.Input<string>;
    /**
     * Risk level of the profile, e.g: high, medium, low
     */
    riskLevel: pulumi.Input<string>;
}

export interface DpProfileInprofileListCriteria {
    /**
     * Set disk encryption status, e.g: enabled, disabled
     */
    diskEncryptionStatus?: pulumi.Input<string>;
    /**
     * The user's device should match one of the domains selected from the dropdown
     */
    domainOfInterests?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set firewall status, e.g: enabled, disabled
     */
    firewallStatus?: pulumi.Input<string>;
    /**
     * OS type, e.g: windows, mac
     */
    os: pulumi.Input<string>;
    /**
     * select one of is, is-notm is-atleast
     */
    osOperator?: pulumi.Input<string>;
    /**
     * Os version details
     */
    osVersions?: pulumi.Input<pulumi.Input<inputs.DpProfileInprofileListCriteriaOsVersion>[]>;
    /**
     * Select the processes that should be running. If more than one process is added, all of them should be running
     */
    runningProcesses?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DpProfileInprofileListCriteriaOsVersion {
    /**
     * OS Build Number, e.g: 11(21H2) 22000, 10(1511) 10586 etc
     */
    build?: pulumi.Input<string>;
    /**
     * Patch details, e.g: 1540, 1358 etc
     */
    patch?: pulumi.Input<string>;
}

export interface DpSettingsTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface DynamicRiskThreshold {
    /**
     * Set the value to true to enable the risk profile
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Name of the risk settings, e.g: alert, mfa, lockUser
     */
    name: pulumi.Input<string>;
    /**
     * Threshold value
     */
    value: pulumi.Input<number>;
}

export interface EdgeNodeSizeSetting {
    bandwidthRanges?: pulumi.Input<pulumi.Input<inputs.EdgeNodeSizeSettingBandwidthRange>[]>;
}

export interface EdgeNodeSizeSettingBandwidthRange {
    /**
     * Maximum Bandwidth Range
     */
    max: pulumi.Input<number>;
    /**
     * Minimum Bandwidth Range
     */
    min: pulumi.Input<number>;
}

export interface EdgeTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface EdrIntegrationCrowdstrike {
    criterias: pulumi.Input<pulumi.Input<inputs.EdrIntegrationCrowdstrikeCriteria>[]>;
    id?: pulumi.Input<string>;
    /**
     * Endpoint Security Integration name
     */
    name: pulumi.Input<string>;
    /**
     * Select EDR Vendor, for now only CrowdStrike is supported.
     */
    vendor: pulumi.Input<string>;
}

export interface EdrIntegrationCrowdstrikeCriteria {
    /**
     * Activate sensor, e.g: enabled, disabled
     */
    sensorActive: pulumi.Input<string>;
    /**
     * Status, e.g: enabled, disabled
     */
    status: pulumi.Input<string>;
    /**
     * Zero Trust Access Score
     */
    ztaScores: pulumi.Input<pulumi.Input<inputs.EdrIntegrationCrowdstrikeCriteriaZtaScore>[]>;
}

export interface EdrIntegrationCrowdstrikeCriteriaZtaScore {
    from: pulumi.Input<number>;
    to: pulumi.Input<number>;
}

export interface EdrProfileAuth {
    baseUrl: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    customerId: pulumi.Input<string>;
    mssp: pulumi.Input<boolean>;
}

export interface FirewallManagerLicenseSetting {
    /**
     * Firewall Family
     */
    firewallFamily: pulumi.Input<string>;
    /**
     * Instance Family
     */
    instanceFamily: pulumi.Input<string>;
    /**
     * Mode of license, e.g: Bring your own license (BYOL) Pay as you go (PAYG)
     */
    licenseMode: pulumi.Input<string>;
    /**
     * License Type, e.g: Bundle1, Bundle2
     */
    licenseType?: pulumi.Input<string>;
}

export interface FirewallManagerTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface GeoLocationAllowList {
    cityName?: pulumi.Input<string>;
    countryName: pulumi.Input<string>;
    stateName?: pulumi.Input<string>;
}

export interface GroupingDetail {
    apps?: pulumi.Input<pulumi.Input<inputs.GroupingDetailApp>[]>;
    names?: pulumi.Input<pulumi.Input<inputs.GroupingDetailName>[]>;
    ranges?: pulumi.Input<pulumi.Input<string>[]>;
    times?: pulumi.Input<pulumi.Input<inputs.GroupingDetailTime>[]>;
}

export interface GroupingDetailApp {
    id?: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface GroupingDetailName {
    id?: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface GroupingDetailTime {
    from: pulumi.Input<string>;
    timezone: pulumi.Input<string>;
    to: pulumi.Input<string>;
}

export interface IdpOidc {
    adminEmail?: pulumi.Input<string>;
    apiClientId?: pulumi.Input<string>;
    apiFile?: pulumi.Input<string>;
    apiSecretId?: pulumi.Input<string>;
    apiToken?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    customerId?: pulumi.Input<string>;
    domain?: pulumi.Input<string>;
    envId?: pulumi.Input<string>;
    filePath?: pulumi.Input<string>;
    /**
     * Choose between eu, asia, us, default
     */
    region?: pulumi.Input<string>;
    secretId?: pulumi.Input<string>;
}

export interface IdpPartner {
    /**
     * List of apps
     */
    apps: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of partner domain urls
     */
    userDomains: pulumi.Input<pulumi.Input<string>[]>;
}

export interface IdpSaml {
    adminEmail?: pulumi.Input<string>;
    apiClientId?: pulumi.Input<string>;
    apiFile?: pulumi.Input<string>;
    apiSecretId?: pulumi.Input<string>;
    apiToken?: pulumi.Input<string>;
    customerId?: pulumi.Input<string>;
    domain?: pulumi.Input<string>;
    envId?: pulumi.Input<string>;
    filePath?: pulumi.Input<string>;
    metadata?: pulumi.Input<string>;
    metadataUrl?: pulumi.Input<string>;
    /**
     * Choose between eu, asia, us, default
     */
    region?: pulumi.Input<string>;
}

export interface InternetEgressMatch {
    matchEntries?: pulumi.Input<pulumi.Input<inputs.InternetEgressMatchMatchEntry>[]>;
}

export interface InternetEgressMatchMatchEntry {
    /**
     * Operation of the selected property, available options are Is, Is NOT
     */
    operation?: pulumi.Input<string>;
    /**
     * Select property of selected type
     */
    property?: pulumi.Input<string>;
    /**
     * Select policy match condition type i.e. - fqdn
     */
    type?: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<inputs.InternetEgressMatchMatchEntryValue>[]>;
}

export interface InternetEgressMatchMatchEntryValue {
    inputitems?: pulumi.Input<pulumi.Input<inputs.InternetEgressMatchMatchEntryValueInputitem>[]>;
}

export interface InternetEgressMatchMatchEntryValueInputitem {
    /**
     * Input domain/fqdn value
     */
    id?: pulumi.Input<string>;
}

export interface InternetEgressNamespace {
    namespaceEntries?: pulumi.Input<pulumi.Input<inputs.InternetEgressNamespaceNamespaceEntry>[]>;
}

export interface InternetEgressNamespaceNamespaceEntry {
    /**
     * Name of the network
     */
    name?: pulumi.Input<string>;
}

export interface InternetEgressNetwork {
    networkEntries?: pulumi.Input<pulumi.Input<inputs.InternetEgressNetworkNetworkEntry>[]>;
}

export interface InternetEgressNetworkGroup {
    networkGroupEntries?: pulumi.Input<pulumi.Input<inputs.InternetEgressNetworkGroupNetworkGroupEntry>[]>;
}

export interface InternetEgressNetworkGroupNetworkGroupEntry {
    /**
     * Name of the network-group
     */
    name?: pulumi.Input<string>;
}

export interface InternetEgressNetworkNetworkEntry {
    /**
     * Name of the network
     */
    name?: pulumi.Input<string>;
}

export interface ManagedFirewallAccessDetail {
    /**
     * Name of Keypair, applicable when `Existing key pair` option has been selected
     */
    keyPairName?: pulumi.Input<string>;
    /**
     * Password
     */
    password: pulumi.Input<string>;
    /**
     * Public Key details when selected option is `Provide public key`
     */
    publicKey?: pulumi.Input<string>;
    /**
     * Should be one of Generate new key pair/Provide public key
     */
    selectOptionForSsh: pulumi.Input<string>;
    /**
     * UserName
     */
    username: pulumi.Input<string>;
}

export interface ManagedFirewallAssignment {
    /**
     * Device Group Name
     */
    deviceGroup: pulumi.Input<string>;
    /**
     * Name of Template
     */
    templateName: pulumi.Input<string>;
}

export interface ManagedFirewallScalingSetting {
    /**
     * Default Capacity
     */
    desired: pulumi.Input<number>;
    /**
     * Maximum Capacity
     */
    max: pulumi.Input<number>;
    /**
     * Minimum Capacity
     */
    min: pulumi.Input<number>;
}

export interface ManagedFirewallTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface NamespaceAssign {
    /**
     * Name of the networks to be assigned to the namespace
     */
    sourceNetworks?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface NamespaceExportExport {
    /**
     * List of namespaces where network would be exported
     */
    namespaces?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of the network to be exported to other namespace
     */
    sourceNetwork?: pulumi.Input<string>;
}

export interface NamespaceExportTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface NamespaceTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface NetworkOnboardingPrivateCloud {
    /**
     * cloud application account name.
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * subnet cider list
     */
    subnets?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface NetworkOnboardingPublicCloud {
    /**
     * cloud application account name.
     */
    cloudCredsName: pulumi.Input<string>;
    cloudNetworks: pulumi.Input<pulumi.Input<inputs.NetworkOnboardingPublicCloudCloudNetwork>[]>;
    /**
     * public or private cloud
     */
    cloudType?: pulumi.Input<string>;
    /**
     * connector
     */
    connectType?: pulumi.Input<string>;
    /**
     * public or private cloud
     */
    connectionOption: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    /**
     * Name of cloud region
     */
    regionName: pulumi.Input<string>;
}

export interface NetworkOnboardingPublicCloudCloudNetwork {
    /**
     * transit-gateway, vpc-peering & public(Only applicable if connector placement is in WorkLoad VPC)
     */
    connectivityType?: pulumi.Input<string>;
    /**
     * Infra VPC/Infra VNET, Workload VPC/Workload VNET or none.
     */
    connectorPlacement: pulumi.Input<string>;
    connectorSettings?: pulumi.Input<pulumi.Input<inputs.NetworkOnboardingPublicCloudCloudNetworkConnectorSetting>[]>;
    /**
     * (Required if transit-gateway is selected) tgw-id
     */
    hubId?: pulumi.Input<string>;
    /**
     * Service Insertion Endpoint, applicable when connector is placed in Workload VPC
     */
    serviceInsertionEndpointSubnets?: pulumi.Input<string>;
    /**
     * subnet cider list
     */
    subnets?: pulumi.Input<pulumi.Input<inputs.NetworkOnboardingPublicCloudCloudNetworkSubnet>[]>;
    /**
     * VNET ID
     */
    vnet?: pulumi.Input<string>;
    /**
     * VPC ID
     */
    vpc?: pulumi.Input<string>;
}

export interface NetworkOnboardingPublicCloudCloudNetworkConnectorSetting {
    /**
     * Available Options: <1 Gbps, 1-5 Gbps, 5-10 Gbps, >10 Gbps
     */
    bandwidth?: pulumi.Input<string>;
    /**
     * Applicable for AWS
     */
    bandwidthRanges?: pulumi.Input<pulumi.Input<inputs.NetworkOnboardingPublicCloudCloudNetworkConnectorSettingBandwidthRange>[]>;
    /**
     * connector subnet cider list, Applicable when connector placement is in workload VPC/VNET
     */
    connectorSubnets?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Available Options wrt cloud and bandwidth :Cloud_Provider: AWS:Bandwidth:  <1 Gbps, Available Options: t3.medium/t3a.medium/c5.largeBandwidth:  1-5 Gbps, Available Options: c5a.large/c5.xlarge/c5a.xlarge/c5n.xlargeBandwidth: 5-10 Gbps, Available Options: c5a.8xlarge/c5.9xlargeBandwidth: >10 Gbps, Available Options: c5n.9xlarge/c5a.16xlarge/c5.18xlarge/c5n.18xlargeCloud_Provider: AZURE:For AZURE Default Connector settings are used,hence user does not have to specify is explicitlyProvided values: Bandwidth: <1 Gbps, Instance Type: Standard_A2_v2Cloud_Provider: GCP:Bandwidth:  <1 Gbps, Available Options: e2-standard-2Bandwidth:  1-5 Gbps, Available Options: e2-standard-4Bandwidth: 5-10 Gbps, Available Options: e2-standard-8/e2-standard-16Bandwidth: >10 Gbps, Available Options: c2-standard-16
     */
    instanceType?: pulumi.Input<string>;
}

export interface NetworkOnboardingPublicCloudCloudNetworkConnectorSettingBandwidthRange {
    /**
     * Minimum Bandwidth Range
     */
    max: pulumi.Input<number>;
    /**
     * Minimum Bandwidth Range
     */
    min: pulumi.Input<number>;
}

export interface NetworkOnboardingPublicCloudCloudNetworkSubnet {
    /**
     * Ip Range
     */
    subnet?: pulumi.Input<string>;
    /**
     * Virtual Subnet
     */
    virtualSubnet?: pulumi.Input<string>;
}

export interface NetworkOnboardingTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface NetworkPrefixPrefixRouteTable {
    /**
     * CIDR range
     */
    ipPrefix: pulumi.Input<string>;
    /**
     * List of Cloud Regions: e.g: us-east-1, eastus
     */
    routeTables: pulumi.Input<pulumi.Input<inputs.NetworkPrefixPrefixRouteTableRouteTable>[]>;
}

export interface NetworkPrefixPrefixRouteTableRouteTable {
    /**
     * Name of the route table
     */
    routeTable: pulumi.Input<string>;
}

export interface NetworkPrefixTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface PolicyDetail {
    /**
     * policy action, e.g: allow, deny
     */
    actions: pulumi.Input<string>;
    /**
     * set this to true to trigger the alert as per policy config
     */
    alert?: pulumi.Input<boolean>;
    /**
     * App details to attach to the policy
     */
    apps?: pulumi.Input<pulumi.Input<inputs.PolicyDetailApp>[]>;
    /**
     * set this to true to bypass policy
     */
    bypass?: pulumi.Input<boolean>;
    /**
     * set it to true to enable internet access
     */
    internetTrafficEnabled?: pulumi.Input<boolean>;
    /**
     * set this to true to lock the user defined in policy
     */
    lockUsers?: pulumi.Input<boolean>;
    matches: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatch>[]>;
    /**
     * set this to true to trigger
     */
    mfa?: pulumi.Input<boolean>;
    /**
     * Network details to attach to the policy
     */
    networks?: pulumi.Input<pulumi.Input<inputs.PolicyDetailNetwork>[]>;
    /**
     * set this to true to skip waf
     */
    skipwaf?: pulumi.Input<boolean>;
}

export interface PolicyDetailApp {
    selecteditems?: pulumi.Input<pulumi.Input<inputs.PolicyDetailAppSelecteditem>[]>;
}

export interface PolicyDetailAppSelecteditem {
    /**
     * Name of the app
     */
    name?: pulumi.Input<string>;
}

export interface PolicyDetailMatch {
    matchEntries?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntry>[]>;
}

export interface PolicyDetailMatchMatchEntry {
    /**
     * Operation of the selected property, available options are Id, Is NOT, Contains, Does NOT contain, Starts with, Ends with, In, NOT in, Is at least, Between
     */
    operation?: pulumi.Input<string>;
    /**
     * Select property of selected type
     */
    property?: pulumi.Input<string>;
    /**
     * Select policy match condition type, for access policy options are users, location, idp, devices, time, url, device-posture, fqdn and advanced. For transit type options are time, url, networkacl, fqdn, egressfqdns, prosimonetworks, networks and advanced
     */
    type: pulumi.Input<string>;
    values?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValue>[]>;
}

export interface PolicyDetailMatchMatchEntryValue {
    inputitems?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValueInputitem>[]>;
    selectedgroups?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValueSelectedgroup>[]>;
    selecteditems?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValueSelecteditem>[]>;
}

export interface PolicyDetailMatchMatchEntryValueInputitem {
    /**
     * Only applicable for type egressfqdn
     */
    egressFqdnDetails?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValueInputitemEgressFqdnDetail>[]>;
    /**
     * Only applicable for type networkacl
     */
    ipDetails?: pulumi.Input<pulumi.Input<inputs.PolicyDetailMatchMatchEntryValueInputitemIpDetail>[]>;
    /**
     * Input value name
     */
    name?: pulumi.Input<string>;
}

export interface PolicyDetailMatchMatchEntryValueInputitemEgressFqdnDetail {
    /**
     * FQDNs which need to be excluded
     */
    fqdnInverseMatches?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * FQDNs which need to be included
     */
    fqdnMatches?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of protocols
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source IP list
     */
    sourceIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target port list
     */
    targetPorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PolicyDetailMatchMatchEntryValueInputitemIpDetail {
    /**
     * List of protocols
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source IP list
     */
    sourceIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source port list
     */
    sourcePorts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target IP list
     */
    targetIps?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Target port list
     */
    targetPorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PolicyDetailMatchMatchEntryValueSelectedgroup {
    /**
     * Input value name
     */
    name?: pulumi.Input<string>;
}

export interface PolicyDetailMatchMatchEntryValueSelecteditem {
    /**
     * City name, only applicable for type location
     */
    cityName?: pulumi.Input<string>;
    /**
     * Country name, only applicable for type location
     */
    countryName?: pulumi.Input<string>;
    /**
     * Selected value name
     */
    name?: pulumi.Input<string>;
    /**
     * State name, only applicable for type location
     */
    stateName?: pulumi.Input<string>;
}

export interface PolicyDetailNetwork {
    selecteditems?: pulumi.Input<pulumi.Input<inputs.PolicyDetailNetworkSelecteditem>[]>;
}

export interface PolicyDetailNetworkSelecteditem {
    /**
     * Name of the network
     */
    name?: pulumi.Input<string>;
}

export interface PrivateLinkMappingHostedZone {
    /**
     * Target Domain name
     */
    domainName: pulumi.Input<string>;
    /**
     * Private Hosted Zones
     */
    privateHostedZone: pulumi.Input<string>;
    /**
     * Name of the source VPC
     */
    vpcName: pulumi.Input<string>;
}

export interface PrivateLinkMappingTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface PrivateLinkSourceCloudSource {
    cloudNetworks?: pulumi.Input<pulumi.Input<inputs.PrivateLinkSourceCloudSourceCloudNetwork>[]>;
    id?: pulumi.Input<string>;
    subnets: pulumi.Input<pulumi.Input<inputs.PrivateLinkSourceCloudSourceSubnet>[]>;
}

export interface PrivateLinkSourceCloudSourceCloudNetwork {
    /**
     * Name of source VPC/VNET.
     */
    name: pulumi.Input<string>;
}

export interface PrivateLinkSourceCloudSourceSubnet {
    /**
     * Subnet Details
     */
    cidr: pulumi.Input<string>;
}

export interface PrivateLinkSourceTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface RegionalPrefixSelectedRegion {
    /**
     * List of Cloud Regions: e.g: us-east-1, eastus
     */
    cloudRegions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * CSP Details: E.G: AZURE/GCP/AWS
     */
    cloudType: pulumi.Input<string>;
}

export interface RegionalPrefixTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface ServiceInsertionIpRule {
    /**
     * Target Ip Address
     */
    destinationAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Destination Port
     */
    destinationPorts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Protocols
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source Ip Address
     */
    sourceAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Source Port
     */
    sourcePorts?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ServiceInsertionSource {
    networks?: pulumi.Input<pulumi.Input<inputs.ServiceInsertionSourceNetwork>[]>;
}

export interface ServiceInsertionSourceNetwork {
    /**
     * Source Network Name
     */
    name?: pulumi.Input<string>;
}

export interface ServiceInsertionTarget {
    apps?: pulumi.Input<pulumi.Input<inputs.ServiceInsertionTargetApp>[]>;
    networks?: pulumi.Input<pulumi.Input<inputs.ServiceInsertionTargetNetwork>[]>;
}

export interface ServiceInsertionTargetApp {
    /**
     * Target App Name
     */
    name?: pulumi.Input<string>;
}

export interface ServiceInsertionTargetNetwork {
    /**
     * Target Network Name
     */
    name?: pulumi.Input<string>;
}

export interface SharedServicesRegion {
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: pulumi.Input<string>;
    /**
     * EX: us-west-2, eu-east-1
     */
    cloudRegion: pulumi.Input<string>;
    /**
     * Gateway Load Balance Service Name
     */
    gatewayLb: pulumi.Input<string>;
    /**
     * Resource group name, applicable only for AZURE
     */
    resourceGroup?: pulumi.Input<string>;
}

export interface SharedServicesTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface UserSettingsAllowList {
    createdtime?: pulumi.Input<string>;
    /**
     * User Email
     */
    email: pulumi.Input<string>;
    /**
     * Reason to allow
     */
    reason: pulumi.Input<string>;
}

export interface VisualTransitTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface VisualTransitTransitInput {
    /**
     * Cloud Region, e.g: us-east-2, westus
     */
    cloudRegion: pulumi.Input<string>;
    /**
     * Cloud Type, e.g: AWS, AZURE, GCP
     */
    cloudType: pulumi.Input<string>;
    /**
     * Resource ID, computed post resource creation
     */
    id?: pulumi.Input<string>;
    /**
     * Transit Deployment Config
     */
    transitDeployments: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeployment>[]>;
}

export interface VisualTransitTransitInputTransitDeployment {
    /**
     * TWG details
     */
    tgws?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentTgw>[]>;
    /**
     * VHUB details
     */
    vhubs?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentVhub>[]>;
    /**
     * VNET Details
     */
    vnets?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentVnet>[]>;
    /**
     * VPC Details
     */
    vpcs?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentVpc>[]>;
}

export interface VisualTransitTransitInputTransitDeploymentTgw {
    /**
     * AWS account Details: Applicable while creating a new TGW
     */
    account?: pulumi.Input<string>;
    /**
     * Action on TGW, e.g: ADD, MOD, DEL
     */
    action: pulumi.Input<string>;
    /**
     * TGW connection Details
     */
    connections?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentTgwConnection>[]>;
    /**
     * TGW ID
     */
    id?: pulumi.Input<string>;
    /**
     * Name of TGW
     */
    name?: pulumi.Input<string>;
}

export interface VisualTransitTransitInputTransitDeploymentTgwConnection {
    /**
     * Connection Action, e.g: ADD, DEL
     */
    action: pulumi.Input<string>;
    /**
     * Name of VPC if connection type is VPC
     */
    name?: pulumi.Input<string>;
    /**
     * Type of connection, e.g: EDGE, VPC
     */
    type: pulumi.Input<string>;
}

export interface VisualTransitTransitInputTransitDeploymentVhub {
    /**
     * Azure account Details: Applicable while creating a new vHUB
     */
    account?: pulumi.Input<string>;
    /**
     * Action on VHUB, e.g: ADD, MOD, DEL. ADD action would create a new vHUB
     */
    action: pulumi.Input<string>;
    /**
     * Address space of vHUB, Applicable while creating a new vHUB
     */
    addressSpace?: pulumi.Input<string>;
    /**
     * VHUB connection Details
     */
    connections?: pulumi.Input<pulumi.Input<inputs.VisualTransitTransitInputTransitDeploymentVhubConnection>[]>;
    /**
     * Name of VHUB
     */
    name: pulumi.Input<string>;
    /**
     * vWAN Details, Applicable while creating a new vHUB
     */
    vwan?: pulumi.Input<string>;
}

export interface VisualTransitTransitInputTransitDeploymentVhubConnection {
    /**
     * Connection Action, e.g: ADD, DEL
     */
    action: pulumi.Input<string>;
    /**
     * Name of VNET if connection type is VNET
     */
    name?: pulumi.Input<string>;
    /**
     * Type of connection, e.g: EDGE, VNET
     */
    type: pulumi.Input<string>;
}

export interface VisualTransitTransitInputTransitDeploymentVnet {
    /**
     * Action on VNET, e.g: ADD, DEL
     */
    action: pulumi.Input<string>;
    /**
     * Name of VNET
     */
    name: pulumi.Input<string>;
}

export interface VisualTransitTransitInputTransitDeploymentVpc {
    /**
     * Action on VPC, e.g: ADD, DEL
     */
    action: pulumi.Input<string>;
    /**
     * Name of VPC
     */
    name: pulumi.Input<string>;
}

export interface WafRulesets {
    basic?: pulumi.Input<inputs.WafRulesetsBasic>;
    owaspCrsV32?: pulumi.Input<inputs.WafRulesetsOwaspCrsV32>;
}

export interface WafRulesetsBasic {
    /**
     * List of basic rules sets waf would apply
     */
    ruleGroups: pulumi.Input<pulumi.Input<string>[]>;
}

export interface WafRulesetsOwaspCrsV32 {
    /**
     * OWASP Modsecurity Core Ruleset v3.2  waf would apply
     */
    ruleGroups: pulumi.Input<pulumi.Input<string>[]>;
}
