// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppOnboardingCitrixvdiAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: string;
    cloudConfig: outputs.AppOnboardingCitrixvdiAppUrlCloudConfig;
    /**
     * Custom DNS setup
     */
    dnsCustom?: outputs.AppOnboardingCitrixvdiAppUrlDnsCustom;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: outputs.AppOnboardingCitrixvdiAppUrlDnsService;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: string;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: outputs.AppOnboardingCitrixvdiAppUrlHealthCheckInfo;
    id: string;
    /**
     * server domain name or IP
     */
    internalDomain: string;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: outputs.AppOnboardingCitrixvdiAppUrlProtocols;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: outputs.AppOnboardingCitrixvdiAppUrlSslCert;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: boolean;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: string;
}

export interface AppOnboardingCitrixvdiAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingCitrixvdiAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingCitrixvdiAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: string;
    /**
     * Attach Point id details
     */
    attachPointId?: string;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: boolean;
    backendIpAddressDns?: boolean;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: string[];
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: string;
    /**
     * Name of the region where app is available, e.g: us-west2, westus etc
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
    /**
     * Available options, MAINTAIN & MODIFY
     */
    tgwAppRoutetable?: string;
}

export interface AppOnboardingCitrixvdiAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: string;
    /**
     * DNS Server List
     */
    dnsServers?: string[];
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: boolean;
}

export interface AppOnboardingCitrixvdiAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: string;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: string;
}

export interface AppOnboardingCitrixvdiAppUrlHealthCheckInfo {
    enabled?: boolean;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: string;
}

export interface AppOnboardingCitrixvdiAppUrlProtocols {
    isValidProtocolPort: boolean;
    /**
     * Customized websocket paths
     */
    paths?: string[];
    /**
     * target port number
     */
    port: number;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: string;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: boolean;
}

export interface AppOnboardingCitrixvdiAppUrlSslCert {
    /**
     * Select from already existing certificates(In certificate TAB)
     */
    existingCert?: string;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: boolean;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: outputs.AppOnboardingCitrixvdiAppUrlSslCertUploadCert[];
}

export interface AppOnboardingCitrixvdiAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: string;
    /**
     * Path to private key
     */
    privateKeyPath?: string;
}

export interface AppOnboardingCitrixvdiCustomizePolicy {
    name?: string;
}

export interface AppOnboardingCitrixvdiSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: string;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: string;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: string;
}

export interface AppOnboardingCitrixvdiTimeouts {
    create?: string;
    delete?: string;
}

export interface AppOnboardingCloudsvcAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: string;
    cloudConfig: outputs.AppOnboardingCloudsvcAppUrlCloudConfig;
    /**
     * Custom DNS setup
     */
    dnsCustom?: outputs.AppOnboardingCloudsvcAppUrlDnsCustom;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: outputs.AppOnboardingCloudsvcAppUrlDnsService;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType?: string;
    /**
     * Application health check config from edge
     */
    healthCheckInfo?: outputs.AppOnboardingCloudsvcAppUrlHealthCheckInfo;
    id: string;
    /**
     * server domain name or IP
     */
    internalDomain: string;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: outputs.AppOnboardingCloudsvcAppUrlSslCert;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: boolean;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: string;
}

export interface AppOnboardingCloudsvcAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption?: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingCloudsvcAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingCloudsvcAppUrlCloudConfigEdgeRegion {
    buckets?: string[];
    /**
     * Name of the region where app is available
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
}

export interface AppOnboardingCloudsvcAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: string;
    /**
     * DNS Server List
     */
    dnsServers?: string[];
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: boolean;
}

export interface AppOnboardingCloudsvcAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: string;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: string;
}

export interface AppOnboardingCloudsvcAppUrlHealthCheckInfo {
    enabled?: boolean;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: string;
}

export interface AppOnboardingCloudsvcAppUrlSslCert {
    /**
     * Select from already existing certificates(In certificate TAB)
     */
    existingCert?: string;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: boolean;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: outputs.AppOnboardingCloudsvcAppUrlSslCertUploadCert[];
}

export interface AppOnboardingCloudsvcAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: string;
    /**
     * Path to private key
     */
    privateKeyPath?: string;
}

export interface AppOnboardingCloudsvcCustomizePolicy {
    name?: string;
}

export interface AppOnboardingCloudsvcTimeouts {
    create?: string;
    delete?: string;
}

export interface AppOnboardingDnsAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    cloudConfig: outputs.AppOnboardingDnsAppUrlCloudConfig;
    id: string;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: outputs.AppOnboardingDnsAppUrlProtocol[];
    /**
     * Service Ip Address
     */
    serviceIp?: string;
    /**
     * Select if the target needs to be assigned a specific IP address or it could be auto-generated. Even if manually assigned, the address needs to be from the service core IP pool. Default method is to auto generate an IP address from the service core pool.
     */
    serviceIpType: string;
}

export interface AppOnboardingDnsAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingDnsAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingDnsAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: string;
    /**
     * Attach Point id details
     */
    attachPointId?: string;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: boolean;
    backendIpAddressDns?: boolean;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: string[];
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: string;
    /**
     * Name of the region where app is available
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
    tgwAppRoutetable?: string;
}

export interface AppOnboardingDnsAppUrlProtocol {
    isValidProtocolPort: boolean;
    /**
     * Customized websocket paths
     */
    paths?: string[];
    /**
     * target port number
     */
    portLists?: string[];
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol?: string;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: boolean;
}

export interface AppOnboardingDnsCustomizePolicy {
    name?: string;
}

export interface AppOnboardingDnsTimeouts {
    create?: string;
    delete?: string;
}

export interface AppOnboardingFqdnAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: string;
    cloudConfig: outputs.AppOnboardingFqdnAppUrlCloudConfig;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: string;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: outputs.AppOnboardingFqdnAppUrlHealthCheckInfo;
    id: string;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: outputs.AppOnboardingFqdnAppUrlProtocol[];
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: boolean;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: string;
}

export interface AppOnboardingFqdnAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingFqdnAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingFqdnAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: string;
    /**
     * Attach Point id details
     */
    attachPointId?: string;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: boolean;
    backendIpAddressDns?: boolean;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: string[];
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: string;
    /**
     * Custom DNS setup
     */
    dnsCustom?: outputs.AppOnboardingFqdnAppUrlCloudConfigEdgeRegionDnsCustom;
    /**
     * Name of the region where app is available
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
    tgwAppRoutetable?: string;
}

export interface AppOnboardingFqdnAppUrlCloudConfigEdgeRegionDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: string;
    /**
     * DNS Server List
     */
    dnsServers?: string[];
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: boolean;
}

export interface AppOnboardingFqdnAppUrlHealthCheckInfo {
    enabled?: boolean;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: string;
}

export interface AppOnboardingFqdnAppUrlProtocol {
    isValidProtocolPort: boolean;
    /**
     * Customized websocket paths
     */
    paths?: string[];
    /**
     * target port number
     */
    portLists: string[];
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: string;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: boolean;
}

export interface AppOnboardingFqdnCustomizePolicy {
    name?: string;
}

export interface AppOnboardingFqdnSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: string;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: string;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: string;
}

export interface AppOnboardingFqdnTimeouts {
    create?: string;
    delete?: string;
}

export interface AppOnboardingJumpboxAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: string;
    cloudConfig: outputs.AppOnboardingJumpboxAppUrlCloudConfig;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: outputs.AppOnboardingJumpboxAppUrlDnsService;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType?: string;
    /**
     * Application health check config from edge
     */
    healthCheckInfo?: outputs.AppOnboardingJumpboxAppUrlHealthCheckInfo;
    id: string;
    /**
     * server domain name or IP
     */
    internalDomain: string;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: outputs.AppOnboardingJumpboxAppUrlSslCert;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: boolean;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: string;
}

export interface AppOnboardingJumpboxAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud application account name
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption?: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingJumpboxAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingJumpboxAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: string;
    /**
     * Attach Point id details
     */
    attachPointId?: string;
    /**
     * if Set to true, auto discovers available endpoints
     */
    backendIpAddressDiscover: boolean;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: string[];
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: string;
    /**
     * Name of the region where app is available
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
    tgwAppRoutetable?: string;
}

export interface AppOnboardingJumpboxAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: string;
    /**
     * Type of DNS service: e.g: Manual, Route 53, Prosimo
     */
    type: string;
}

export interface AppOnboardingJumpboxAppUrlHealthCheckInfo {
    enabled?: boolean;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: string;
}

export interface AppOnboardingJumpboxAppUrlSslCert {
    /**
     * Select from already existing certificates(In Certificate TAB)
     */
    existingCert?: string;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: boolean;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: outputs.AppOnboardingJumpboxAppUrlSslCertUploadCert[];
}

export interface AppOnboardingJumpboxAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: string;
    /**
     * Path to private key
     */
    privateKeyPath?: string;
}

export interface AppOnboardingJumpboxCustomizePolicy {
    name?: string;
}

export interface AppOnboardingJumpboxTimeouts {
    create?: string;
    delete?: string;
}

export interface AppOnboardingWebAppUrl {
    /**
     * Fqdn of the app that user would access after onboarding
     */
    appFqdn: string;
    /**
     * Cache Rules for your App Domains
     */
    cacheRule?: string;
    cloudConfig: outputs.AppOnboardingWebAppUrlCloudConfig;
    /**
     * Custom DNS setup
     */
    dnsCustom?: outputs.AppOnboardingWebAppUrlDnsCustom;
    /**
     * In order to enable users to access an application using the external domain via the Prosimo fabric, you need to set up a new canonical name (CNAME) record redirect in your origin domain name system (DNS) record.
     */
    dnsService?: outputs.AppOnboardingWebAppUrlDnsService;
    /**
     * Type of Domain: e.g custom or prosimo
     */
    domainType: string;
    /**
     * Application health check config from edge
     */
    healthCheckInfo: outputs.AppOnboardingWebAppUrlHealthCheckInfo;
    id: string;
    /**
     * server domain name or IP
     */
    internalDomain: string;
    /**
     * Protocol that prosimo edge uses to connect to App
     */
    protocols: outputs.AppOnboardingWebAppUrlProtocols;
    /**
     * set up secure communication between the user and the application via the fabric, there are 3 options: Upload a Certificate, Generate a new certificate or Use an existing certificate
     */
    sslCert?: outputs.AppOnboardingWebAppUrlSslCert;
    /**
     * Set True to onboard subdomains of the application else False
     */
    subdomainIncluded?: boolean;
    /**
     * WAF Policies for your App Domains, applicable when the Edge to App Protocol is either HTTP or HTTPS.
     */
    wafPolicyName?: string;
}

export interface AppOnboardingWebAppUrlCloudConfig {
    /**
     * Wheather app is hosted in Public cloud like AWS/AZURE/GCP or private DC. Available options PRIVATE/PUBLIC
     */
    appHostedType?: string;
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * Public, if the app domain has a public IP address / DNS A record on the internet currently, and the Prosimo Edge should connect to the application using a public connection.Private, if the application only has a private IP address, and Edge should connect to it over a private connection.
     */
    connectionOption: string;
    /**
     * Applicable only if  app_hosted_type is PRIVATE, IP of the app hosted in PRIVATE DC
     */
    dcAppIp?: string;
    edgeRegions?: outputs.AppOnboardingWebAppUrlCloudConfigEdgeRegion[];
    hasPrivateConnectionOptions?: boolean;
    isShowConnectionOptions?: boolean;
}

export interface AppOnboardingWebAppUrlCloudConfigEdgeRegion {
    /**
     * App network id details
     */
    appNetworkId?: string;
    /**
     * Attach Point id details
     */
    attachPointId?: string;
    /**
     * if Set to true, auto discoverers available endpoints
     */
    backendIpAddressDiscover: boolean;
    backendIpAddressDns?: boolean;
    /**
     * Pass endpoints manually.
     */
    backendIpAddressManuals?: string[];
    /**
     * Connection option for private connection: e.g: peering/transitGateway/awsPrivateLink/azurePrivateLink/azureTransitVnet/vwanHub
     */
    connOption?: string;
    /**
     * Name of the region where app is available
     */
    regionName?: string;
    /**
     * Type of region: e.g:active, backup etc
     */
    regionType?: string;
    tgwAppRoutetable?: string;
}

export interface AppOnboardingWebAppUrlDnsCustom {
    /**
     * DNS App name
     */
    dnsApp?: string;
    /**
     * DNS Server List
     */
    dnsServers?: string[];
    /**
     * Health check to ensure application domains being resolved by dns servers
     */
    isHealthcheckEnabled?: boolean;
}

export interface AppOnboardingWebAppUrlDnsService {
    /**
     * Cloud creds for route 53
     */
    awsRoute53CloudCredsName?: string;
    /**
     * Type of DNS service: e.g: manual, route 53, prosimo
     */
    type: string;
}

export interface AppOnboardingWebAppUrlHealthCheckInfo {
    enabled?: boolean;
    /**
     * HealthCheck Endpoints
     */
    endpoint?: string;
}

export interface AppOnboardingWebAppUrlProtocols {
    isValidProtocolPort: boolean;
    /**
     * Customized websocket paths
     */
    paths?: string[];
    /**
     * target port number
     */
    port: number;
    /**
     * Protocol type, e.g: “http”, “https”, “ssh”, “vnc”, or “rdp
     */
    protocol: string;
    /**
     * Set to true if tou would like prosimo edges to communicate with app via websocket
     */
    webSocketEnabled?: boolean;
}

export interface AppOnboardingWebAppUrlSslCert {
    /**
     * Select from already existing certificates(In Certificate TAB)
     */
    existingCert?: string;
    /**
     * Set this to true if you want prosimo to generate new certificates
     */
    generateCert?: boolean;
    /**
     * Upload the certificate if the certificates are already available for application
     */
    uploadCerts?: outputs.AppOnboardingWebAppUrlSslCertUploadCert[];
}

export interface AppOnboardingWebAppUrlSslCertUploadCert {
    /**
     * Path to certificate
     */
    certPath?: string;
    /**
     * Path to private key
     */
    privateKeyPath?: string;
}

export interface AppOnboardingWebCustomizePolicy {
    name?: string;
}

export interface AppOnboardingWebSamlRewrite {
    /**
     * Required while selecting SAML based authentication
     */
    metadata?: string;
    /**
     * Required while selecting SAML based authentication
     */
    metadataUrl?: string;
    /**
     * Type of authentication: e.g. SAML, OIDC, Others
     */
    selectedAuthType?: string;
}

export interface AppOnboardingWebTimeouts {
    create?: string;
    delete?: string;
}

export interface CacheRulesAppDomain {
    domain?: string;
    id?: string;
}

export interface CacheRulesBypassInfo {
    respHdrs?: outputs.CacheRulesBypassInfoRespHdr[];
}

export interface CacheRulesBypassInfoRespHdr {
    contentTypes?: string[];
    xJenkinsSessions?: string[];
}

export interface CacheRulesPathPattern {
    bypassUri: boolean;
    isDefault: boolean;
    isNewPath: boolean;
    /**
     * Path to store cache
     */
    path: string;
    settings: outputs.CacheRulesPathPatternSetting[];
    status: string;
}

export interface CacheRulesPathPatternSetting {
    cacheControlIgnored: boolean;
    cookieIgnored: boolean;
    queryParameterIgnored: boolean;
    ttls: outputs.CacheRulesPathPatternSettingTtl[];
    type: string;
    userIdIgnored: boolean;
}

export interface CacheRulesPathPatternSettingTtl {
    enabled: boolean;
    time: number;
    timeUnit: string;
}

export interface CertificatesUploadCaCert {
    /**
     * Path to the  CA certificate
     */
    certPath?: string;
}

export interface CertificatesUploadClientCert {
    /**
     * Path to the certificate
     */
    certPath?: string;
    /**
     * Path to the private key
     */
    privateKeyPath?: string;
}

export interface CertificatesUploadDomainCert {
    /**
     * Path to the certficate
     */
    certPath?: string;
    /**
     * Path to the private key
     */
    privateKeyPath?: string;
}

export interface CloudCredsAws {
    /**
     * Access Key options
     */
    accessKeys?: outputs.CloudCredsAwsAccessKeys;
    /**
     * IAM Role options
     */
    iamRole?: outputs.CloudCredsAwsIamRole;
    /**
     * Select preferred Authorization option, e.g: IAM Role, Access Keys
     */
    preferredAuth: string;
}

export interface CloudCredsAwsAccessKeys {
    /**
     * Acces Key ID, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html
     */
    accessKeyId: string;
    /**
     * Secret Key ID
     */
    secretKeyId: string;
}

export interface CloudCredsAwsIamRole {
    /**
     * External ID, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html
     */
    externalId: string;
    /**
     * Role ARN, ref: https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html
     */
    roleArn: string;
}

export interface CloudCredsAzure {
    clientId: string;
    secretId: string;
    /**
     * Subscription ID, ref: https://learn.microsoft.com/en-us/azure/azure-portal/get-subscription-tenant-id
     */
    subscriptionId: string;
    /**
     * Tenant ID
     */
    tenantId: string;
}

export interface CloudCredsBulk {
    accountId?: string;
    externalId: string;
    /**
     * Path of GCP credential file to upload.
     */
    filePath?: string;
    /**
     * Tenant ID
     */
    keyType?: string;
}

export interface CloudCredsGcp {
    authProviderX509CertUrl: string;
    authUri: string;
    clientEmail: string;
    clientId: string;
    clientX509CertUrl: string;
    /**
     * Path of GCP credential file to upload.
     */
    filePath: string;
    projectId: string;
    tokenUri: string;
    /**
     * Type of Credential, e.g: Service Account
     */
    type?: string;
}

export interface DpProfileInprofileList {
    criterias: outputs.DpProfileInprofileListCriteria[];
    /**
     * Select end point security profiles from the list. If the list is empty, profile needs to created first
     */
    edrProfiles?: string[];
    /**
     * Set TRUE if you want to enable the profile, else false
     */
    enabled: boolean;
    id: string;
    /**
     * Profile name
     */
    name: string;
    /**
     * Risk level of the profile, e.g: high, medium, low
     */
    riskLevel: string;
}

export interface DpProfileInprofileListCriteria {
    /**
     * Set disk encryption status, e.g: enabled, disabled
     */
    diskEncryptionStatus?: string;
    /**
     * The user's device should match one of the domains selected from the dropdown
     */
    domainOfInterests?: string[];
    /**
     * Set firewall status, e.g: enabled, disabled
     */
    firewallStatus?: string;
    /**
     * OS type, e.g: windows, mac
     */
    os: string;
    /**
     * select one of is, is-notm is-atleast
     */
    osOperator?: string;
    /**
     * Os version details
     */
    osVersions?: outputs.DpProfileInprofileListCriteriaOsVersion[];
    /**
     * Select the processes that should be running. If more than one process is added, all of them should be running
     */
    runningProcesses?: string[];
}

export interface DpProfileInprofileListCriteriaOsVersion {
    /**
     * OS Build Number, e.g: 11(21H2) 22000, 10(1511) 10586 etc
     */
    build?: string;
    /**
     * Patch details, e.g: 1540, 1358 etc
     */
    patch?: string;
}

export interface DpSettingsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DynamicRiskThreshold {
    /**
     * Set the value to true to enable the risk profile
     */
    enabled: boolean;
    /**
     * Name of the risk settings, e.g: alert, mfa, lockUser
     */
    name: string;
    /**
     * Threshold value
     */
    value: number;
}

export interface EdgeNodeSizeSetting {
    bandwidthRanges?: outputs.EdgeNodeSizeSettingBandwidthRange[];
}

export interface EdgeNodeSizeSettingBandwidthRange {
    /**
     * Maximum Bandwidth Range
     */
    max: number;
    /**
     * Minimum Bandwidth Range
     */
    min: number;
}

export interface EdgeTimeouts {
    create?: string;
    delete?: string;
}

export interface EdrIntegrationCrowdstrike {
    criterias: outputs.EdrIntegrationCrowdstrikeCriteria[];
    id: string;
    /**
     * Endpoint Security Integration name
     */
    name: string;
    /**
     * Select EDR Vendor, for now only CrowdStrike is supported.
     */
    vendor: string;
}

export interface EdrIntegrationCrowdstrikeCriteria {
    /**
     * Activate sensor, e.g: enabled, disabled
     */
    sensorActive: string;
    /**
     * Status, e.g: enabled, disabled
     */
    status: string;
    /**
     * Zero Trust Access Score
     */
    ztaScores: outputs.EdrIntegrationCrowdstrikeCriteriaZtaScore[];
}

export interface EdrIntegrationCrowdstrikeCriteriaZtaScore {
    from: number;
    to: number;
}

export interface EdrProfileAuth {
    baseUrl: string;
    clientId: string;
    clientSecret: string;
    customerId: string;
    mssp: boolean;
}

export interface FirewallManagerLicenseSetting {
    /**
     * Firewall Family
     */
    firewallFamily: string;
    /**
     * Instance Family
     */
    instanceFamily: string;
    /**
     * Mode of license, e.g: Bring your own license (BYOL) Pay as you go (PAYG)
     */
    licenseMode: string;
    /**
     * License Type, e.g: Bundle1, Bundle2
     */
    licenseType?: string;
}

export interface FirewallManagerTimeouts {
    create?: string;
    delete?: string;
}

export interface GeoLocationAllowList {
    cityName?: string;
    countryName: string;
    stateName?: string;
}

export interface GetAppOnboardingOnboardedApp {
    addresstype: string;
    appAccessType: string;
    appName: string;
    appid: string;
    apponboardtype: string;
    appsamlrewrite: string;
    apptype: string;
    appurls: outputs.GetAppOnboardingOnboardedAppAppurl[];
    deployed: boolean;
    dnsDiscovery: boolean;
    enablemulticloud: boolean;
    idpId: string;
    interactiontype: string;
    onboardtype: string;
    optimizeAppExperience: boolean;
    optoption: string;
    policyUpdated: boolean;
    policygroupid: string;
    status: string;
    teamId: string;
}

export interface GetAppOnboardingOnboardedAppAppurl {
    appfqdn: string;
    cacheruleid: string;
    certid: string;
    cloudkeyid: string;
    connectionoption: string;
    dnsservices: outputs.GetAppOnboardingOnboardedAppAppurlDnsservice[];
    domaintype: string;
    extProtocols: outputs.GetAppOnboardingOnboardedAppAppurlExtProtocol[];
    healthcheckinfos: outputs.GetAppOnboardingOnboardedAppAppurlHealthcheckinfo[];
    id: string;
    internaldomain: string;
    pappfqdn: string;
    protocols: outputs.GetAppOnboardingOnboardedAppAppurlProtocol[];
    regions: outputs.GetAppOnboardingOnboardedAppAppurlRegion[];
    subdomainincluded: boolean;
    teamid: string;
}

export interface GetAppOnboardingOnboardedAppAppurlDnsservice {
    configured: boolean;
    id: string;
    type: string;
}

export interface GetAppOnboardingOnboardedAppAppurlExtProtocol {
    port: number;
    protocol: string;
}

export interface GetAppOnboardingOnboardedAppAppurlHealthcheckinfo {
    enabled: boolean;
    endpoint: string;
}

export interface GetAppOnboardingOnboardedAppAppurlProtocol {
    isvalidprotocolport: boolean;
    paths: string[];
    port: number;
    portlists: string[];
    protocol: string;
    websocketenabled: boolean;
}

export interface GetAppOnboardingOnboardedAppAppurlRegion {
    connoption: string;
    endpoints: outputs.GetAppOnboardingOnboardedAppAppurlRegionEndpoint[];
    id: string;
    name: string;
    regiontype: string;
}

export interface GetAppOnboardingOnboardedAppAppurlRegionEndpoint {
    appip: string;
    appnetworkid: string;
}

export interface GetCertificatesCert {
    ca: string;
    certificate: string;
    certificatehash: string;
    createdtime: string;
    dn: string;
    expirytime: string;
    generatedby: string;
    id: string;
    issuetime: string;
    isteamcert: boolean;
    keysize: string;
    notified: boolean;
    pstatus: string;
    publickeyalgorithm: string;
    san: string;
    signingalgorithm: string;
    teamid: string;
    updatedtime: string;
}

export interface GetCloudCredsCloudCred {
    aws: outputs.GetCloudCredsCloudCredAw[];
    azures: outputs.GetCloudCredsCloudCredAzure[];
    cloudtype: string;
    gcps: outputs.GetCloudCredsCloudCredGcp[];
    nickname: string;
}

export interface GetCloudCredsCloudCredAw {
    accessKeys: outputs.GetCloudCredsCloudCredAwAccessKey[];
    iamRoles: outputs.GetCloudCredsCloudCredAwIamRole[];
    preferredAuth: string;
}

export interface GetCloudCredsCloudCredAwAccessKey {
    accessKeyId: string;
    secretKeyId: string;
}

export interface GetCloudCredsCloudCredAwIamRole {
    externalId: string;
    roleArn: string;
}

export interface GetCloudCredsCloudCredAzure {
    clientId: string;
    secretId: string;
    subscriptionId: string;
    tenantId: string;
}

export interface GetCloudCredsCloudCredGcp {
    authProviderX509CertUrl: string;
    authUri: string;
    clientEmail: string;
    clientId: string;
    clientX509CertUrl: string;
    filePath: string;
    projectId: string;
    serviceAccount: string;
    tokenUri: string;
    type: string;
}

export interface GetDiscoveredNetworksDiscoveredNetwork {
    accountname: string;
    cloudtype: string;
    id: string;
    name: string;
    regions: outputs.GetDiscoveredNetworksDiscoveredNetworkRegion[];
}

export interface GetDiscoveredNetworksDiscoveredNetworkRegion {
    cloudCredsId: string;
    id: string;
    name: string;
    vpcCount: number;
    vpcs: outputs.GetDiscoveredNetworksDiscoveredNetworkRegionVpc[];
}

export interface GetDiscoveredNetworksDiscoveredNetworkRegionVpc {
    cidr: string;
    id: string;
    name: string;
    network: string;
    regionId: string;
    subnetCount: number;
}

export interface GetEdgeEdge {
    appnames: string[];
    appusedcount: number;
    byoresourcedetails: outputs.GetEdgeEdgeByoresourcedetail[];
    city: string;
    cloudkeyid: string;
    cloudregion: string;
    cloudtype: string;
    clustername: string;
    clustertype: string;
    country: string;
    createdtime: string;
    edgeconnectivitycount: number;
    fabricconnectinfos: outputs.GetEdgeEdgeFabricconnectinfo[];
    flavor: string;
    id: string;
    locationid: string;
    networkinfos: outputs.GetEdgeEdgeNetworkinfo[];
    networknames: string[];
    networkusedcount: number;
    nickname: string;
    nodesizesettings: outputs.GetEdgeEdgeNodesizesetting[];
    pappfqdn: string;
    privateip: string;
    privatelinksourcenames: string[];
    privatelinkusedcount: number;
    publicip: string;
    ranchertoken: string;
    regstatus: string;
    sharedservicecount: number;
    sharedservicenames: string[];
    state: string;
    status: string;
    subnet: string;
    teamid: string;
    token: string;
    tokenactivated: boolean;
    updatedtime: string;
    wgexternalendpoint: string;
    wginternalendpoint: string;
}

export interface GetEdgeEdgeByoresourcedetail {
    vpcid: string;
}

export interface GetEdgeEdgeFabricconnectinfo {
    attachments: outputs.GetEdgeEdgeFabricconnectinfoAttachment[];
    cloudtype: string;
    haspublic: boolean;
    id: string;
    name: string;
    teamid: string;
}

export interface GetEdgeEdgeFabricconnectinfoAttachment {
    attachtype: string;
    conntype: string;
    id: string;
    pappfqdn: string;
    weight: number;
}

export interface GetEdgeEdgeNetworkinfo {
    ilbdns: string;
    vpcid: string;
}

export interface GetEdgeEdgeNodesizesetting {
    bandwidth: string;
    bandwidthname: string;
    bandwidthranges: outputs.GetEdgeEdgeNodesizesettingBandwidthrange[];
    instancetype: string;
}

export interface GetEdgeEdgeNodesizesettingBandwidthrange {
    max: number;
    min: number;
}

export interface GetIdpIdpList {
    apiCredProvided: string;
    authType: string;
    idpid: string;
    idpname: string;
    selectType: string;
}

export interface GetNamespaceNamespaceList {
    assignednetworks: outputs.GetNamespaceNamespaceListAssignednetwork[];
    createdtime: string;
    exportednetworks: outputs.GetNamespaceNamespaceListExportednetwork[];
    id: string;
    importednetworks: outputs.GetNamespaceNamespaceListImportednetwork[];
    name: string;
    nid: number;
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNamespaceNamespaceListAssignednetwork {
    networks: outputs.GetNamespaceNamespaceListAssignednetworkNetwork[];
}

export interface GetNamespaceNamespaceListAssignednetworkNetwork {
    createdtime: string;
    deployed: boolean;
    exportable: boolean;
    id: string;
    name: string;
    namespaceid: string;
    namespacename: string;
    namespacenid: number;
    pamcname: string;
    policyupdated: boolean;
    progress: number;
    publicclouds: outputs.GetNamespaceNamespaceListAssignednetworkNetworkPubliccloud[];
    securities: outputs.GetNamespaceNamespaceListAssignednetworkNetworkSecurity[];
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkPubliccloud {
    cloud: string;
    cloudkeyid: string;
    cloudnetworks: outputs.GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetwork[];
    cloudregion: string;
    cloudtype: string;
    connectionoption: string;
    id: string;
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetwork {
    cloudnetworkid: string;
    connectivitytype: string;
    connectorgrpid: string;
    connectorplacement: string;
    connectorsettings: outputs.GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkConnectorsetting[];
    edgeconnectivityid: string;
    hubid: string;
    id: string;
    subnets: outputs.GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkSubnet[];
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkConnectorsetting {
    bandwidth: string;
    bandwidthname: string;
    bandwidthranges: outputs.GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange[];
    cloudnetworkid: string;
    instancetype: string;
    subnets: string[];
    updatestatus: string;
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange {
    max: number;
    min: number;
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkPubliccloudCloudnetworkSubnet {
    subnet: string;
    virtualSubnet: string;
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkSecurity {
    policies: outputs.GetNamespaceNamespaceListAssignednetworkNetworkSecurityPolicy[];
}

export interface GetNamespaceNamespaceListAssignednetworkNetworkSecurityPolicy {
    id: string;
    name: string;
}

export interface GetNamespaceNamespaceListExportednetwork {
    networks: outputs.GetNamespaceNamespaceListExportednetworkNetwork[];
}

export interface GetNamespaceNamespaceListExportednetworkNetwork {
    createdtime: string;
    deployed: boolean;
    exportable: boolean;
    id: string;
    name: string;
    namespaceid: string;
    namespacename: string;
    namespacenid: number;
    pamcname: string;
    policyupdated: boolean;
    progress: number;
    publicclouds: outputs.GetNamespaceNamespaceListExportednetworkNetworkPubliccloud[];
    securities: outputs.GetNamespaceNamespaceListExportednetworkNetworkSecurity[];
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNamespaceNamespaceListExportednetworkNetworkPubliccloud {
    cloud: string;
    cloudkeyid: string;
    cloudnetworks: outputs.GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetwork[];
    cloudregion: string;
    cloudtype: string;
    connectionoption: string;
    id: string;
}

export interface GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetwork {
    cloudnetworkid: string;
    connectivitytype: string;
    connectorgrpid: string;
    connectorplacement: string;
    connectorsettings: outputs.GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkConnectorsetting[];
    edgeconnectivityid: string;
    hubid: string;
    id: string;
    subnets: outputs.GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkSubnet[];
}

export interface GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkConnectorsetting {
    bandwidth: string;
    bandwidthname: string;
    bandwidthranges: outputs.GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange[];
    cloudnetworkid: string;
    instancetype: string;
    subnets: string[];
    updatestatus: string;
}

export interface GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange {
    max: number;
    min: number;
}

export interface GetNamespaceNamespaceListExportednetworkNetworkPubliccloudCloudnetworkSubnet {
    subnet: string;
    virtualSubnet: string;
}

export interface GetNamespaceNamespaceListExportednetworkNetworkSecurity {
    policies: outputs.GetNamespaceNamespaceListExportednetworkNetworkSecurityPolicy[];
}

export interface GetNamespaceNamespaceListExportednetworkNetworkSecurityPolicy {
    id: string;
    name: string;
}

export interface GetNamespaceNamespaceListImportednetwork {
    networks: outputs.GetNamespaceNamespaceListImportednetworkNetwork[];
}

export interface GetNamespaceNamespaceListImportednetworkNetwork {
    createdtime: string;
    deployed: boolean;
    exportable: boolean;
    id: string;
    name: string;
    namespaceid: string;
    namespacename: string;
    namespacenid: number;
    pamcname: string;
    policyupdated: boolean;
    progress: number;
    publicclouds: outputs.GetNamespaceNamespaceListImportednetworkNetworkPubliccloud[];
    securities: outputs.GetNamespaceNamespaceListImportednetworkNetworkSecurity[];
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNamespaceNamespaceListImportednetworkNetworkPubliccloud {
    cloud: string;
    cloudkeyid: string;
    cloudnetworks: outputs.GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetwork[];
    cloudregion: string;
    cloudtype: string;
    connectionoption: string;
    id: string;
}

export interface GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetwork {
    cloudnetworkid: string;
    connectivitytype: string;
    connectorgrpid: string;
    connectorplacement: string;
    connectorsettings: outputs.GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkConnectorsetting[];
    edgeconnectivityid: string;
    hubid: string;
    id: string;
    subnets: outputs.GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkSubnet[];
}

export interface GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkConnectorsetting {
    bandwidth: string;
    bandwidthname: string;
    bandwidthranges: outputs.GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange[];
    cloudnetworkid: string;
    instancetype: string;
    subnets: string[];
    updatestatus: string;
}

export interface GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange {
    max: number;
    min: number;
}

export interface GetNamespaceNamespaceListImportednetworkNetworkPubliccloudCloudnetworkSubnet {
    subnet: string;
    virtualSubnet: string;
}

export interface GetNamespaceNamespaceListImportednetworkNetworkSecurity {
    policies: outputs.GetNamespaceNamespaceListImportednetworkNetworkSecurityPolicy[];
}

export interface GetNamespaceNamespaceListImportednetworkNetworkSecurityPolicy {
    id: string;
    name: string;
}

export interface GetNetworkOnboardingOnboardedNetwork {
    createdtime: string;
    id: string;
    name: string;
    namespaceId: string;
    namespaceName: string;
    namespaceNid: number;
    pamcname: string;
    policyUpdated: boolean;
    publicclouds: outputs.GetNetworkOnboardingOnboardedNetworkPubliccloud[];
    securities: outputs.GetNetworkOnboardingOnboardedNetworkSecurity[];
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNetworkOnboardingOnboardedNetworkPubliccloud {
    cloud: string;
    cloudkeyid: string;
    cloudnetworks: outputs.GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetwork[];
    cloudregion: string;
    cloudtype: string;
    connectionoption: string;
    id: string;
}

export interface GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetwork {
    cloudnetworkid: string;
    connectivitytype: string;
    connectorgrpid: string;
    connectorplacement: string;
    connectorsettings: outputs.GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkConnectorsetting[];
    edgeconnectivityid: string;
    hubid: string;
    id: string;
    subnets: outputs.GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkSubnet[];
}

export interface GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkConnectorsetting {
    bandwidth: string;
    bandwidthname: string;
    bandwidthranges: outputs.GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange[];
    cloudnetworkid: string;
    instancetype: string;
    subnets: string[];
    updatestatus: string;
}

export interface GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkConnectorsettingBandwidthrange {
    max: number;
    min: number;
}

export interface GetNetworkOnboardingOnboardedNetworkPubliccloudCloudnetworkSubnet {
    subnet: string;
    virtualSubnet: string;
}

export interface GetNetworkOnboardingOnboardedNetworkSecurity {
    policies: outputs.GetNetworkOnboardingOnboardedNetworkSecurityPolicy[];
}

export interface GetNetworkOnboardingOnboardedNetworkSecurityPolicy {
    id: string;
    name: string;
}

export interface GetNetworkPrefixNetworkPrefixList {
    cloudkeyid: string;
    cloudnetworkid: string;
    cloudnetworkname: string;
    cloudregion: string;
    createdtime: string;
    csp: string;
    enabled: boolean;
    id: string;
    overwriteroute: boolean;
    prefixroutetables: outputs.GetNetworkPrefixNetworkPrefixListPrefixroutetable[];
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetNetworkPrefixNetworkPrefixListPrefixroutetable {
    prefix: string;
    routetables: outputs.GetNetworkPrefixNetworkPrefixListPrefixroutetableRoutetable[];
}

export interface GetNetworkPrefixNetworkPrefixListPrefixroutetableRoutetable {
    id: string;
    name: string;
}

export interface GetPolicyAccessPolicy {
    appAccessType: string;
    createdtime: string;
    details: outputs.GetPolicyAccessPolicyDetail[];
    devicePostureConfigured: boolean;
    id: string;
    name: string;
    teamid: string;
    type: string;
    updatedtime: string;
}

export interface GetPolicyAccessPolicyDetail {
    actions: string[];
    apps: outputs.GetPolicyAccessPolicyDetailApp[];
    matches: outputs.GetPolicyAccessPolicyDetailMatch[];
    networks: outputs.GetPolicyAccessPolicyDetailNetwork[];
}

export interface GetPolicyAccessPolicyDetailApp {
    selecteditems: outputs.GetPolicyAccessPolicyDetailAppSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailAppSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatch {
    advanceds: outputs.GetPolicyAccessPolicyDetailMatchAdvanced[];
    devicepostureprofiles: outputs.GetPolicyAccessPolicyDetailMatchDevicepostureprofile[];
    devices: outputs.GetPolicyAccessPolicyDetailMatchDevice[];
    fqdns: outputs.GetPolicyAccessPolicyDetailMatchFqdn[];
    idps: outputs.GetPolicyAccessPolicyDetailMatchIdp[];
    networks: outputs.GetPolicyAccessPolicyDetailMatchNetwork[];
    times: outputs.GetPolicyAccessPolicyDetailMatchTime[];
    urls: outputs.GetPolicyAccessPolicyDetailMatchUrl[];
    users: outputs.GetPolicyAccessPolicyDetailMatchUser[];
}

export interface GetPolicyAccessPolicyDetailMatchAdvanced {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchAdvancedValue[];
}

export interface GetPolicyAccessPolicyDetailMatchAdvancedValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchAdvancedValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchAdvancedValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchAdvancedValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchAdvancedValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchDevice {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchDeviceValue[];
}

export interface GetPolicyAccessPolicyDetailMatchDeviceValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchDeviceValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchDeviceValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchDeviceValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchDeviceValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchDevicepostureprofile {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchDevicepostureprofileValue[];
}

export interface GetPolicyAccessPolicyDetailMatchDevicepostureprofileValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchDevicepostureprofileValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchDevicepostureprofileValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchDevicepostureprofileValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchDevicepostureprofileValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchFqdn {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchFqdnValue[];
}

export interface GetPolicyAccessPolicyDetailMatchFqdnValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchFqdnValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchFqdnValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchFqdnValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchFqdnValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchIdp {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchIdpValue[];
}

export interface GetPolicyAccessPolicyDetailMatchIdpValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchIdpValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchIdpValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchIdpValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchIdpValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchNetwork {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchNetworkValue[];
}

export interface GetPolicyAccessPolicyDetailMatchNetworkValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchNetworkValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchNetworkValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchNetworkValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchNetworkValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchTime {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchTimeValue[];
}

export interface GetPolicyAccessPolicyDetailMatchTimeValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchTimeValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchTimeValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchTimeValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchTimeValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchUrl {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchUrlValue[];
}

export interface GetPolicyAccessPolicyDetailMatchUrlValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchUrlValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchUrlValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchUrlValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchUrlValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchUser {
    operations: string;
    property: string;
    values: outputs.GetPolicyAccessPolicyDetailMatchUserValue[];
}

export interface GetPolicyAccessPolicyDetailMatchUserValue {
    inputitems: outputs.GetPolicyAccessPolicyDetailMatchUserValueInputitem[];
    selecteditems: outputs.GetPolicyAccessPolicyDetailMatchUserValueSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailMatchUserValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailMatchUserValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyAccessPolicyDetailNetwork {
    selecteditems: outputs.GetPolicyAccessPolicyDetailNetworkSelecteditem[];
}

export interface GetPolicyAccessPolicyDetailNetworkSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicy {
    appAccessType: string;
    createdtime: string;
    details: outputs.GetPolicyTransitPolicyDetail[];
    devicePostureConfigured: boolean;
    id: string;
    name: string;
    teamid: string;
    type: string;
    updatedtime: string;
}

export interface GetPolicyTransitPolicyDetail {
    actions: string[];
    apps: outputs.GetPolicyTransitPolicyDetailApp[];
    matches: outputs.GetPolicyTransitPolicyDetailMatch[];
    networks: outputs.GetPolicyTransitPolicyDetailNetwork[];
}

export interface GetPolicyTransitPolicyDetailApp {
    selecteditems: outputs.GetPolicyTransitPolicyDetailAppSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailAppSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatch {
    advanceds: outputs.GetPolicyTransitPolicyDetailMatchAdvanced[];
    fqdns: outputs.GetPolicyTransitPolicyDetailMatchFqdn[];
    networkacls: outputs.GetPolicyTransitPolicyDetailMatchNetworkacl[];
    prosimonetworks: outputs.GetPolicyTransitPolicyDetailMatchProsimonetwork[];
    times: outputs.GetPolicyTransitPolicyDetailMatchTime[];
    urls: outputs.GetPolicyTransitPolicyDetailMatchUrl[];
}

export interface GetPolicyTransitPolicyDetailMatchAdvanced {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchAdvancedValue[];
}

export interface GetPolicyTransitPolicyDetailMatchAdvancedValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchAdvancedValueInputitem[];
    selecteditems: outputs.GetPolicyTransitPolicyDetailMatchAdvancedValueSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailMatchAdvancedValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchAdvancedValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchFqdn {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchFqdnValue[];
}

export interface GetPolicyTransitPolicyDetailMatchFqdnValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchFqdnValueInputitem[];
    selecteditems: outputs.GetPolicyTransitPolicyDetailMatchFqdnValueSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailMatchFqdnValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchFqdnValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchNetworkacl {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchNetworkaclValue[];
}

export interface GetPolicyTransitPolicyDetailMatchNetworkaclValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchNetworkaclValueInputitem[];
}

export interface GetPolicyTransitPolicyDetailMatchNetworkaclValueInputitem {
    keyvalues: outputs.GetPolicyTransitPolicyDetailMatchNetworkaclValueInputitemKeyvalue[];
}

export interface GetPolicyTransitPolicyDetailMatchNetworkaclValueInputitemKeyvalue {
    protocols: string[];
    sourceips: string[];
    sourceports: string[];
    targetips: string[];
    targetports: string[];
}

export interface GetPolicyTransitPolicyDetailMatchProsimonetwork {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchProsimonetworkValue[];
}

export interface GetPolicyTransitPolicyDetailMatchProsimonetworkValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchProsimonetworkValueInputitem[];
    selecteditems: outputs.GetPolicyTransitPolicyDetailMatchProsimonetworkValueSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailMatchProsimonetworkValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchProsimonetworkValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchTime {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchTimeValue[];
}

export interface GetPolicyTransitPolicyDetailMatchTimeValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchTimeValueInputitem[];
    selecteditems: outputs.GetPolicyTransitPolicyDetailMatchTimeValueSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailMatchTimeValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchTimeValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchUrl {
    operations: string;
    property: string;
    values: outputs.GetPolicyTransitPolicyDetailMatchUrlValue[];
}

export interface GetPolicyTransitPolicyDetailMatchUrlValue {
    inputitems: outputs.GetPolicyTransitPolicyDetailMatchUrlValueInputitem[];
    selecteditems: outputs.GetPolicyTransitPolicyDetailMatchUrlValueSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailMatchUrlValueInputitem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailMatchUrlValueSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPolicyTransitPolicyDetailNetwork {
    selecteditems: outputs.GetPolicyTransitPolicyDetailNetworkSelecteditem[];
}

export interface GetPolicyTransitPolicyDetailNetworkSelecteditem {
    itemid: string;
    itemname: string;
}

export interface GetPrivateLinksPrivateLink {
    cloudcredsid: string;
    cloudsources: outputs.GetPrivateLinksPrivateLinkCloudsource[];
    createdtime: string;
    credentials: outputs.GetPrivateLinksPrivateLinkCredential[];
    deleted: boolean;
    edges: outputs.GetPrivateLinksPrivateLinkEdge[];
    id: string;
    inuse: boolean;
    name: string;
    policies: outputs.GetPrivateLinksPrivateLinkPolicy[];
    ports: outputs.GetPrivateLinksPrivateLinkPort[];
    region: string;
    totalcount: number;
    updatedtime: string;
}

export interface GetPrivateLinksPrivateLinkCloudsource {
    cloudnetworks: outputs.GetPrivateLinksPrivateLinkCloudsourceCloudnetwork[];
    createdtime: string;
    deleted: boolean;
    hostedzones: outputs.GetPrivateLinksPrivateLinkCloudsourceHostedzone[];
    id: string;
    records: outputs.GetPrivateLinksPrivateLinkCloudsourceRecord[];
    subnets: outputs.GetPrivateLinksPrivateLinkCloudsourceSubnet[];
    updatedtime: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceCloudnetwork {
    id: string;
    name: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceHostedzone {
    cloudcredentialsid: string;
    createdtime: string;
    hostedzoneid: string;
    id: string;
    name: string;
    prosimomanaged: boolean;
    region: string;
    status: string;
    teamid: string;
    updatedtime: string;
    vpcid: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceRecord {
    createdtime: string;
    hostedzoneid: string;
    id: string;
    record: string;
    status: string;
    target: string;
    teamid: string;
    ttl: number;
    type: string;
    updatedtime: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceSubnet {
    cidr: string;
    createdtime: string;
    deleted: boolean;
    endpoints: outputs.GetPrivateLinksPrivateLinkCloudsourceSubnetEndpoint[];
    id: string;
    updatedtime: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceSubnetEndpoint {
    appid: string;
    appname: string;
    domain: string;
    domainid: string;
    endpoint: string;
    id: string;
    name: string;
    policyid: string;
    protoports: outputs.GetPrivateLinksPrivateLinkCloudsourceSubnetEndpointProtoport[];
    status: string;
}

export interface GetPrivateLinksPrivateLinkCloudsourceSubnetEndpointProtoport {
    paths: string[];
    port: number;
    portlists: string[];
    protocol: string;
    websocketenabled: boolean;
}

export interface GetPrivateLinksPrivateLinkCredential {
    cloud: string;
    credentials: string;
    id: string;
    type: string;
}

export interface GetPrivateLinksPrivateLinkEdge {
    cloud: string;
    cloudcredsid: string;
    domain: string;
    id: string;
    name: string;
    networkinfos: outputs.GetPrivateLinksPrivateLinkEdgeNetworkinfo[];
    region: string;
}

export interface GetPrivateLinksPrivateLinkEdgeNetworkinfo {
    ilbdns: string;
    vpcid: string;
}

export interface GetPrivateLinksPrivateLinkPolicy {
    id: string;
    status: string;
    target: string;
}

export interface GetPrivateLinksPrivateLinkPort {
    appid: string;
    createdtime: string;
    domainid: string;
    edgeid: string;
    id: string;
    plsid: string;
    port: number;
    status: string;
    teamid: string;
    updatedtime: string;
}

export interface GetRegionalPrefixRegionalPrefixList {
    createdtime: string;
    enabled: boolean;
    id: string;
    overwriteroute: boolean;
    prefixes: string[];
    regions: outputs.GetRegionalPrefixRegionalPrefixListRegion[];
    status: string;
    teamid: string;
    type: string;
    updatedtime: string;
}

export interface GetRegionalPrefixRegionalPrefixListRegion {
    all: boolean;
    selecteds: outputs.GetRegionalPrefixRegionalPrefixListRegionSelected[];
}

export interface GetRegionalPrefixRegionalPrefixListRegionSelected {
    csp: string;
    names: string[];
}

export interface GetServiceInsertionServiceInsertion {
    cloudregion: string;
    cloudtype: string;
    createdtime: string;
    gwloadbalancerid: string;
    id: string;
    iprules: outputs.GetServiceInsertionServiceInsertionIprule[];
    name: string;
    prosimomanagedrouting: boolean;
    regionid: string;
    resourcegroup: string;
    routetables: string[];
    routingmanagedby: string;
    serviceid: string;
    servicename: string;
    sharedservicecreds: string;
    sources: outputs.GetServiceInsertionServiceInsertionSource[];
    status: string;
    targets: outputs.GetServiceInsertionServiceInsertionTarget[];
    type: string;
    updatedtime: string;
    vnetforpeering: string;
}

export interface GetServiceInsertionServiceInsertionIprule {
    destaddrs: string[];
    destports: string[];
    id: string;
    protocols: string[];
    srcaddrs: string[];
    srcports: string[];
}

export interface GetServiceInsertionServiceInsertionSource {
    networks: outputs.GetServiceInsertionServiceInsertionSourceNetwork[];
}

export interface GetServiceInsertionServiceInsertionSourceNetwork {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GetServiceInsertionServiceInsertionTarget {
    apps: outputs.GetServiceInsertionServiceInsertionTargetApp[];
    networks: outputs.GetServiceInsertionServiceInsertionTargetNetwork[];
}

export interface GetServiceInsertionServiceInsertionTargetApp {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GetServiceInsertionServiceInsertionTargetNetwork {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GetSharedServicesSharedServiceList {
    createdtime: string;
    deployed: boolean;
    id: string;
    name: string;
    progress: number;
    serviceinserts: outputs.GetSharedServicesSharedServiceListServiceinsert[];
    status: string;
    type: string;
    updatedtime: string;
}

export interface GetSharedServicesSharedServiceListServiceinsert {
    id: string;
    name: string;
    namespaceid: string;
    namespacenid: number;
    regionid: string;
    sources: outputs.GetSharedServicesSharedServiceListServiceinsertSource[];
    targets: outputs.GetSharedServicesSharedServiceListServiceinsertTarget[];
    type: string;
}

export interface GetSharedServicesSharedServiceListServiceinsertSource {
    networks: outputs.GetSharedServicesSharedServiceListServiceinsertSourceNetwork[];
}

export interface GetSharedServicesSharedServiceListServiceinsertSourceNetwork {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GetSharedServicesSharedServiceListServiceinsertTarget {
    apps: outputs.GetSharedServicesSharedServiceListServiceinsertTargetApp[];
    networks: outputs.GetSharedServicesSharedServiceListServiceinsertTargetNetwork[];
}

export interface GetSharedServicesSharedServiceListServiceinsertTargetApp {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GetSharedServicesSharedServiceListServiceinsertTargetNetwork {
    cidrs: string[];
    id: string;
    name: string;
}

export interface GroupingDetail {
    apps?: outputs.GroupingDetailApp[];
    names?: outputs.GroupingDetailName[];
    ranges?: string[];
    times?: outputs.GroupingDetailTime[];
}

export interface GroupingDetailApp {
    id: string;
    name: string;
}

export interface GroupingDetailName {
    id: string;
    name: string;
}

export interface GroupingDetailTime {
    from: string;
    timezone: string;
    to: string;
}

export interface IdpOidc {
    adminEmail?: string;
    apiClientId?: string;
    apiFile: string;
    apiSecretId?: string;
    apiToken?: string;
    clientId?: string;
    customerId?: string;
    domain?: string;
    envId?: string;
    filePath?: string;
    /**
     * Choose between eu, asia, us, default
     */
    region?: string;
    secretId?: string;
}

export interface IdpPartner {
    /**
     * List of apps
     */
    apps: string[];
    /**
     * List of partner domain urls
     */
    userDomains: string[];
}

export interface IdpSaml {
    adminEmail?: string;
    apiClientId?: string;
    apiFile: string;
    apiSecretId?: string;
    apiToken?: string;
    customerId?: string;
    domain?: string;
    envId?: string;
    filePath?: string;
    metadata?: string;
    metadataUrl?: string;
    /**
     * Choose between eu, asia, us, default
     */
    region?: string;
}

export interface InternetEgressMatch {
    matchEntries?: outputs.InternetEgressMatchMatchEntry[];
}

export interface InternetEgressMatchMatchEntry {
    /**
     * Operation of the selected property, available options are Is, Is NOT
     */
    operation?: string;
    /**
     * Select property of selected type
     */
    property?: string;
    /**
     * Select policy match condition type i.e. - fqdn
     */
    type?: string;
    values?: outputs.InternetEgressMatchMatchEntryValue[];
}

export interface InternetEgressMatchMatchEntryValue {
    inputitems?: outputs.InternetEgressMatchMatchEntryValueInputitem[];
}

export interface InternetEgressMatchMatchEntryValueInputitem {
    /**
     * Input domain/fqdn value
     */
    id?: string;
}

export interface InternetEgressNamespace {
    namespaceEntries?: outputs.InternetEgressNamespaceNamespaceEntry[];
}

export interface InternetEgressNamespaceNamespaceEntry {
    /**
     * Name of the network
     */
    name?: string;
}

export interface InternetEgressNetwork {
    networkEntries?: outputs.InternetEgressNetworkNetworkEntry[];
}

export interface InternetEgressNetworkGroup {
    networkGroupEntries?: outputs.InternetEgressNetworkGroupNetworkGroupEntry[];
}

export interface InternetEgressNetworkGroupNetworkGroupEntry {
    /**
     * Name of the network-group
     */
    name?: string;
}

export interface InternetEgressNetworkNetworkEntry {
    /**
     * Name of the network
     */
    name?: string;
}

export interface ManagedFirewallAccessDetail {
    /**
     * Name of Keypair, applicable when `Existing key pair` option has been selected
     */
    keyPairName?: string;
    /**
     * Password
     */
    password: string;
    /**
     * Public Key details when selected option is `Provide public key`
     */
    publicKey?: string;
    /**
     * Should be one of Generate new key pair/Provide public key
     */
    selectOptionForSsh: string;
    /**
     * UserName
     */
    username: string;
}

export interface ManagedFirewallAssignment {
    /**
     * Device Group Name
     */
    deviceGroup: string;
    /**
     * Name of Template
     */
    templateName: string;
}

export interface ManagedFirewallScalingSetting {
    /**
     * Default Capacity
     */
    desired: number;
    /**
     * Maximum Capacity
     */
    max: number;
    /**
     * Minimum Capacity
     */
    min: number;
}

export interface ManagedFirewallTimeouts {
    create?: string;
    delete?: string;
}

export interface NamespaceAssign {
    /**
     * Name of the networks to be assigned to the namespace
     */
    sourceNetworks?: string[];
}

export interface NamespaceExportExport {
    /**
     * List of namespaces where network would be exported
     */
    namespaces?: string[];
    /**
     * Name of the network to be exported to other namespace
     */
    sourceNetwork?: string;
}

export interface NamespaceExportTimeouts {
    create?: string;
    delete?: string;
}

export interface NamespaceTimeouts {
    create?: string;
    delete?: string;
}

export interface NetworkOnboardingPrivateCloud {
    /**
     * cloud application account name.
     */
    cloudCredsName: string;
    /**
     * subnet cider list
     */
    subnets?: string[];
}

export interface NetworkOnboardingPublicCloud {
    /**
     * cloud application account name.
     */
    cloudCredsName: string;
    cloudNetworks: outputs.NetworkOnboardingPublicCloudCloudNetwork[];
    /**
     * public or private cloud
     */
    cloudType?: string;
    /**
     * connector
     */
    connectType?: string;
    /**
     * public or private cloud
     */
    connectionOption: string;
    id: string;
    /**
     * Name of cloud region
     */
    regionName: string;
}

export interface NetworkOnboardingPublicCloudCloudNetwork {
    /**
     * transit-gateway, vpc-peering & public(Only applicable if connector placement is in WorkLoad VPC)
     */
    connectivityType?: string;
    /**
     * Infra VPC/Infra VNET, Workload VPC/Workload VNET or none.
     */
    connectorPlacement: string;
    connectorSettings?: outputs.NetworkOnboardingPublicCloudCloudNetworkConnectorSetting[];
    /**
     * (Required if transit-gateway is selected) tgw-id
     */
    hubId?: string;
    /**
     * Service Insertion Endpoint, applicable when connector is placed in Workload VPC
     */
    serviceInsertionEndpointSubnets?: string;
    /**
     * subnet cider list
     */
    subnets?: outputs.NetworkOnboardingPublicCloudCloudNetworkSubnet[];
    /**
     * VNET ID
     */
    vnet?: string;
    /**
     * VPC ID
     */
    vpc?: string;
}

export interface NetworkOnboardingPublicCloudCloudNetworkConnectorSetting {
    /**
     * Available Options: <1 Gbps, 1-5 Gbps, 5-10 Gbps, >10 Gbps
     */
    bandwidth?: string;
    /**
     * Applicable for AWS
     */
    bandwidthRanges?: outputs.NetworkOnboardingPublicCloudCloudNetworkConnectorSettingBandwidthRange[];
    /**
     * connector subnet cider list, Applicable when connector placement is in workload VPC/VNET
     */
    connectorSubnets?: string[];
    /**
     * Available Options wrt cloud and bandwidth :Cloud_Provider: AWS:Bandwidth:  <1 Gbps, Available Options: t3.medium/t3a.medium/c5.largeBandwidth:  1-5 Gbps, Available Options: c5a.large/c5.xlarge/c5a.xlarge/c5n.xlargeBandwidth: 5-10 Gbps, Available Options: c5a.8xlarge/c5.9xlargeBandwidth: >10 Gbps, Available Options: c5n.9xlarge/c5a.16xlarge/c5.18xlarge/c5n.18xlargeCloud_Provider: AZURE:For AZURE Default Connector settings are used,hence user does not have to specify is explicitlyProvided values: Bandwidth: <1 Gbps, Instance Type: Standard_A2_v2Cloud_Provider: GCP:Bandwidth:  <1 Gbps, Available Options: e2-standard-2Bandwidth:  1-5 Gbps, Available Options: e2-standard-4Bandwidth: 5-10 Gbps, Available Options: e2-standard-8/e2-standard-16Bandwidth: >10 Gbps, Available Options: c2-standard-16
     */
    instanceType?: string;
}

export interface NetworkOnboardingPublicCloudCloudNetworkConnectorSettingBandwidthRange {
    /**
     * Minimum Bandwidth Range
     */
    max: number;
    /**
     * Minimum Bandwidth Range
     */
    min: number;
}

export interface NetworkOnboardingPublicCloudCloudNetworkSubnet {
    /**
     * Ip Range
     */
    subnet?: string;
    /**
     * Virtual Subnet
     */
    virtualSubnet?: string;
}

export interface NetworkOnboardingTimeouts {
    create?: string;
    delete?: string;
}

export interface NetworkPrefixPrefixRouteTable {
    /**
     * CIDR range
     */
    ipPrefix: string;
    /**
     * List of Cloud Regions: e.g: us-east-1, eastus
     */
    routeTables: outputs.NetworkPrefixPrefixRouteTableRouteTable[];
}

export interface NetworkPrefixPrefixRouteTableRouteTable {
    /**
     * Name of the route table
     */
    routeTable: string;
}

export interface NetworkPrefixTimeouts {
    create?: string;
    delete?: string;
}

export interface PolicyDetail {
    /**
     * policy action, e.g: allow, deny
     */
    actions: string;
    /**
     * set this to true to trigger the alert as per policy config
     */
    alert?: boolean;
    /**
     * App details to attach to the policy
     */
    apps?: outputs.PolicyDetailApp[];
    /**
     * set this to true to bypass policy
     */
    bypass?: boolean;
    /**
     * set it to true to enable internet access
     */
    internetTrafficEnabled?: boolean;
    /**
     * set this to true to lock the user defined in policy
     */
    lockUsers?: boolean;
    matches: outputs.PolicyDetailMatch[];
    /**
     * set this to true to trigger
     */
    mfa?: boolean;
    /**
     * Network details to attach to the policy
     */
    networks?: outputs.PolicyDetailNetwork[];
    /**
     * set this to true to skip waf
     */
    skipwaf?: boolean;
}

export interface PolicyDetailApp {
    selecteditems?: outputs.PolicyDetailAppSelecteditem[];
}

export interface PolicyDetailAppSelecteditem {
    /**
     * Name of the app
     */
    name?: string;
}

export interface PolicyDetailMatch {
    matchEntries?: outputs.PolicyDetailMatchMatchEntry[];
}

export interface PolicyDetailMatchMatchEntry {
    /**
     * Operation of the selected property, available options are Id, Is NOT, Contains, Does NOT contain, Starts with, Ends with, In, NOT in, Is at least, Between
     */
    operation?: string;
    /**
     * Select property of selected type
     */
    property?: string;
    /**
     * Select policy match condition type, for access policy options are users, location, idp, devices, time, url, device-posture, fqdn and advanced. For transit type options are time, url, networkacl, fqdn, egressfqdns, prosimonetworks, networks and advanced
     */
    type: string;
    values?: outputs.PolicyDetailMatchMatchEntryValue[];
}

export interface PolicyDetailMatchMatchEntryValue {
    inputitems?: outputs.PolicyDetailMatchMatchEntryValueInputitem[];
    selectedgroups?: outputs.PolicyDetailMatchMatchEntryValueSelectedgroup[];
    selecteditems?: outputs.PolicyDetailMatchMatchEntryValueSelecteditem[];
}

export interface PolicyDetailMatchMatchEntryValueInputitem {
    /**
     * Only applicable for type egressfqdn
     */
    egressFqdnDetails?: outputs.PolicyDetailMatchMatchEntryValueInputitemEgressFqdnDetail[];
    /**
     * Only applicable for type networkacl
     */
    ipDetails?: outputs.PolicyDetailMatchMatchEntryValueInputitemIpDetail[];
    /**
     * Input value name
     */
    name?: string;
}

export interface PolicyDetailMatchMatchEntryValueInputitemEgressFqdnDetail {
    /**
     * FQDNs which need to be excluded
     */
    fqdnInverseMatches?: string[];
    /**
     * FQDNs which need to be included
     */
    fqdnMatches?: string[];
    /**
     * List of protocols
     */
    protocols?: string[];
    /**
     * Source IP list
     */
    sourceIps?: string[];
    /**
     * Target port list
     */
    targetPorts?: string[];
}

export interface PolicyDetailMatchMatchEntryValueInputitemIpDetail {
    /**
     * List of protocols
     */
    protocols?: string[];
    /**
     * Source IP list
     */
    sourceIps?: string[];
    /**
     * Source port list
     */
    sourcePorts?: string[];
    /**
     * Target IP list
     */
    targetIps?: string[];
    /**
     * Target port list
     */
    targetPorts?: string[];
}

export interface PolicyDetailMatchMatchEntryValueSelectedgroup {
    /**
     * Input value name
     */
    name?: string;
}

export interface PolicyDetailMatchMatchEntryValueSelecteditem {
    /**
     * City name, only applicable for type location
     */
    cityName?: string;
    /**
     * Country name, only applicable for type location
     */
    countryName?: string;
    /**
     * Selected value name
     */
    name?: string;
    /**
     * State name, only applicable for type location
     */
    stateName?: string;
}

export interface PolicyDetailNetwork {
    selecteditems?: outputs.PolicyDetailNetworkSelecteditem[];
}

export interface PolicyDetailNetworkSelecteditem {
    /**
     * Name of the network
     */
    name?: string;
}

export interface PrivateLinkMappingHostedZone {
    /**
     * Target Domain name
     */
    domainName: string;
    /**
     * Private Hosted Zones
     */
    privateHostedZone: string;
    /**
     * Name of the source VPC
     */
    vpcName: string;
}

export interface PrivateLinkMappingTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivateLinkSourceCloudSource {
    cloudNetworks?: outputs.PrivateLinkSourceCloudSourceCloudNetwork[];
    id: string;
    subnets: outputs.PrivateLinkSourceCloudSourceSubnet[];
}

export interface PrivateLinkSourceCloudSourceCloudNetwork {
    /**
     * Name of source VPC/VNET.
     */
    name: string;
}

export interface PrivateLinkSourceCloudSourceSubnet {
    /**
     * Subnet Details
     */
    cidr: string;
}

export interface PrivateLinkSourceTimeouts {
    create?: string;
    delete?: string;
}

export interface RegionalPrefixSelectedRegion {
    /**
     * List of Cloud Regions: e.g: us-east-1, eastus
     */
    cloudRegions: string[];
    /**
     * CSP Details: E.G: AZURE/GCP/AWS
     */
    cloudType: string;
}

export interface RegionalPrefixTimeouts {
    create?: string;
    delete?: string;
}

export interface ServiceInsertionIpRule {
    /**
     * Target Ip Address
     */
    destinationAddresses?: string[];
    /**
     * Destination Port
     */
    destinationPorts?: string[];
    /**
     * Protocols
     */
    protocols?: string[];
    /**
     * Source Ip Address
     */
    sourceAddresses?: string[];
    /**
     * Source Port
     */
    sourcePorts?: string[];
}

export interface ServiceInsertionSource {
    networks?: outputs.ServiceInsertionSourceNetwork[];
}

export interface ServiceInsertionSourceNetwork {
    /**
     * Source Network Name
     */
    name?: string;
}

export interface ServiceInsertionTarget {
    apps?: outputs.ServiceInsertionTargetApp[];
    networks?: outputs.ServiceInsertionTargetNetwork[];
}

export interface ServiceInsertionTargetApp {
    /**
     * Target App Name
     */
    name?: string;
}

export interface ServiceInsertionTargetNetwork {
    /**
     * Target Network Name
     */
    name?: string;
}

export interface SharedServicesRegion {
    /**
     * cloud account under which application is hosted
     */
    cloudCredsName: string;
    /**
     * EX: us-west-2, eu-east-1
     */
    cloudRegion: string;
    /**
     * Gateway Load Balance Service Name
     */
    gatewayLb: string;
    /**
     * Resource group name, applicable only for AZURE
     */
    resourceGroup?: string;
}

export interface SharedServicesTimeouts {
    create?: string;
    delete?: string;
}

export interface UserSettingsAllowList {
    createdtime: string;
    /**
     * User Email
     */
    email: string;
    /**
     * Reason to allow
     */
    reason: string;
}

export interface VisualTransitTimeouts {
    create?: string;
    delete?: string;
}

export interface VisualTransitTransitInput {
    /**
     * Cloud Region, e.g: us-east-2, westus
     */
    cloudRegion: string;
    /**
     * Cloud Type, e.g: AWS, AZURE, GCP
     */
    cloudType: string;
    /**
     * Resource ID, computed post resource creation
     */
    id: string;
    /**
     * Transit Deployment Config
     */
    transitDeployments: outputs.VisualTransitTransitInputTransitDeployment[];
}

export interface VisualTransitTransitInputTransitDeployment {
    /**
     * TWG details
     */
    tgws?: outputs.VisualTransitTransitInputTransitDeploymentTgw[];
    /**
     * VHUB details
     */
    vhubs?: outputs.VisualTransitTransitInputTransitDeploymentVhub[];
    /**
     * VNET Details
     */
    vnets?: outputs.VisualTransitTransitInputTransitDeploymentVnet[];
    /**
     * VPC Details
     */
    vpcs?: outputs.VisualTransitTransitInputTransitDeploymentVpc[];
}

export interface VisualTransitTransitInputTransitDeploymentTgw {
    /**
     * AWS account Details: Applicable while creating a new TGW
     */
    account?: string;
    /**
     * Action on TGW, e.g: ADD, MOD, DEL
     */
    action: string;
    /**
     * TGW connection Details
     */
    connections?: outputs.VisualTransitTransitInputTransitDeploymentTgwConnection[];
    /**
     * TGW ID
     */
    id?: string;
    /**
     * Name of TGW
     */
    name?: string;
}

export interface VisualTransitTransitInputTransitDeploymentTgwConnection {
    /**
     * Connection Action, e.g: ADD, DEL
     */
    action: string;
    /**
     * Name of VPC if connection type is VPC
     */
    name?: string;
    /**
     * Type of connection, e.g: EDGE, VPC
     */
    type: string;
}

export interface VisualTransitTransitInputTransitDeploymentVhub {
    /**
     * Azure account Details: Applicable while creating a new vHUB
     */
    account?: string;
    /**
     * Action on VHUB, e.g: ADD, MOD, DEL. ADD action would create a new vHUB
     */
    action: string;
    /**
     * Address space of vHUB, Applicable while creating a new vHUB
     */
    addressSpace?: string;
    /**
     * VHUB connection Details
     */
    connections?: outputs.VisualTransitTransitInputTransitDeploymentVhubConnection[];
    /**
     * Name of VHUB
     */
    name: string;
    /**
     * vWAN Details, Applicable while creating a new vHUB
     */
    vwan?: string;
}

export interface VisualTransitTransitInputTransitDeploymentVhubConnection {
    /**
     * Connection Action, e.g: ADD, DEL
     */
    action: string;
    /**
     * Name of VNET if connection type is VNET
     */
    name?: string;
    /**
     * Type of connection, e.g: EDGE, VNET
     */
    type: string;
}

export interface VisualTransitTransitInputTransitDeploymentVnet {
    /**
     * Action on VNET, e.g: ADD, DEL
     */
    action: string;
    /**
     * Name of VNET
     */
    name: string;
}

export interface VisualTransitTransitInputTransitDeploymentVpc {
    /**
     * Action on VPC, e.g: ADD, DEL
     */
    action: string;
    /**
     * Name of VPC
     */
    name: string;
}

export interface WafRulesets {
    basic?: outputs.WafRulesetsBasic;
    owaspCrsV32?: outputs.WafRulesetsOwaspCrsV32;
}

export interface WafRulesetsBasic {
    /**
     * List of basic rules sets waf would apply
     */
    ruleGroups: string[];
}

export interface WafRulesetsOwaspCrsV32 {
    /**
     * OWASP Modsecurity Core Ruleset v3.2  waf would apply
     */
    ruleGroups: string[];
}

