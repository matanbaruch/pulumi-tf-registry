// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ArchitectDatatableProperty {
    /**
     * Default value of the property. This is converted to the proper type for non-strings (e.g. set 'true' or 'false' for booleans).
     */
    default?: string;
    /**
     * Name of the property.
     */
    name: string;
    /**
     * Display title of the property.
     */
    title?: string;
    /**
     * Type of the property (boolean | string | integer | number).
     */
    type: string;
}

export interface ArchitectEmergencygroupEmergencyCallFlow {
    /**
     * The ID of the connected call flow.
     */
    emergencyFlowId: string;
    /**
     * The IDs of the connected IVRs.
     */
    ivrIds: string[];
}

export interface ArchitectGrammarLanguageDtmfFileData {
    /**
     * Hash value of the file content. Used to detect changes.
     */
    fileContentHash: string;
    /**
     * The name of the file as defined by the user.
     */
    fileName: string;
    /**
     * The extension of the file.
     */
    fileType: string;
}

export interface ArchitectGrammarLanguageVoiceFileData {
    /**
     * Hash value of the file content. Used to detect changes.
     */
    fileContentHash: string;
    /**
     * The name of the file as defined by the user.
     */
    fileName: string;
    /**
     * The extension of the file.
     */
    fileType: string;
}

export interface ArchitectUserPromptResource {
    fileContentHash: string;
    filename: string;
    language: string;
    text: string;
    ttsString: string;
}

export interface AuthRolePermissionPolicy {
    /**
     * Actions allowed on the entity or '*' for all. e.g. 'add'
     */
    actionSets: string[];
    /**
     * Conditions specific to this resource. This is only applicable to some permission types.
     */
    conditions?: outputs.AuthRolePermissionPolicyConditions;
    /**
     * Permission domain. e.g 'directory'
     */
    domain: string;
    /**
     * Permission entity or '*' for all. e.g. 'user'
     */
    entityName: string;
}

export interface AuthRolePermissionPolicyConditions {
    /**
     * Conjunction for condition terms (AND | OR).
     */
    conjunction: string;
    /**
     * Terms of the condition.
     */
    terms: outputs.AuthRolePermissionPolicyConditionsTerm[];
}

export interface AuthRolePermissionPolicyConditionsTerm {
    /**
     * Operands for this condition.
     */
    operands: outputs.AuthRolePermissionPolicyConditionsTermOperand[];
    /**
     * Operator type (EQ | IN | GE | GT | LE | LT).
     */
    operator: string;
    /**
     * Variable name being compared. This varies depending on the permission.
     */
    variableName: string;
}

export interface AuthRolePermissionPolicyConditionsTermOperand {
    /**
     * Queue ID for QUEUE types.
     */
    queueId?: string;
    /**
     * Value type (USER | QUEUE | SCALAR | VARIABLE).
     */
    type: string;
    /**
     * User ID for USER types.
     */
    userId?: string;
    /**
     * Value for operand. For USER or QUEUE types, use user_id or queue_id instead.
     */
    value?: string;
}

export interface ConversationsMessagingSettingsContent {
    /**
     * Settings relating to facebook and instagram stories feature
     */
    story?: outputs.ConversationsMessagingSettingsContentStory;
}

export interface ConversationsMessagingSettingsContentStory {
    /**
     * Setting relating to Story Mentions
     */
    mention?: outputs.ConversationsMessagingSettingsContentStoryMention;
    /**
     * Setting relating to Story Replies
     */
    reply?: outputs.ConversationsMessagingSettingsContentStoryReply;
}

export interface ConversationsMessagingSettingsContentStoryMention {
    /**
     * Valid values: Enabled, Disabled.
     */
    inbound?: string;
}

export interface ConversationsMessagingSettingsContentStoryReply {
    /**
     * Valid values: Enabled, Disabled.
     */
    inbound?: string;
}

export interface ConversationsMessagingSettingsEvent {
    /**
     * Settings regarding typing events
     */
    typing?: outputs.ConversationsMessagingSettingsEventTyping;
}

export interface ConversationsMessagingSettingsEventTyping {
    /**
     * Should typing indication Events be sent
     */
    on?: outputs.ConversationsMessagingSettingsEventTypingOn;
}

export interface ConversationsMessagingSettingsEventTypingOn {
    /**
     * Status for the Inbound Direction. Valid values: Enabled, Disabled.
     */
    inbound?: string;
    /**
     * Status for the outbound Direction. Valid values: Enabled, Disabled.
     */
    outbound?: string;
}

export interface ConversationsMessagingSupportedcontentMediaTypes {
    /**
     * Specify allowed media types for inbound and outbound messages. If this field is empty, all inbound and outbound media will be blocked.
     */
    allow?: outputs.ConversationsMessagingSupportedcontentMediaTypesAllow;
}

export interface ConversationsMessagingSupportedcontentMediaTypesAllow {
    /**
     * List of media types allowed for inbound messages from customers. If inbound messages from a customer contain media that is not in this list, the media will be dropped from the outbound message.
     */
    inbounds?: outputs.ConversationsMessagingSupportedcontentMediaTypesAllowInbound[];
    /**
     * List of media types allowed for outbound messages to customers. If an outbound message is sent that contains media that is not in this list, the message will not be sent.
     */
    outbounds?: outputs.ConversationsMessagingSupportedcontentMediaTypesAllowOutbound[];
}

export interface ConversationsMessagingSupportedcontentMediaTypesAllowInbound {
    /**
     * The media type string as defined by RFC 2046. You can define specific types such as 'image/jpeg', 'video/mpeg', or specify wild cards for a range of types, 'image/*', or all types '*&#47;*'. See https://www.iana.org/assignments/media-types/media-types.xhtml for a list of registered media types.
     */
    type?: string;
}

export interface ConversationsMessagingSupportedcontentMediaTypesAllowOutbound {
    /**
     * The media type string as defined by RFC 2046. You can define specific types such as 'image/jpeg', 'video/mpeg', or specify wild cards for a range of types, 'image/*', or all types '*&#47;*'. See https://www.iana.org/assignments/media-types/media-types.xhtml for a list of registered media types.
     */
    type?: string;
}

export interface ExternalcontactsContactAddress {
    /**
     * Contact address 1.
     */
    address1?: string;
    /**
     * Contact address 2.
     */
    address2?: string;
    /**
     * Contact address city.
     */
    city?: string;
    /**
     * Contact address country code.
     */
    countryCode?: string;
    /**
     * Contact address postal code.
     */
    postalCode?: string;
    /**
     * Contact address state.
     */
    state?: string;
}

export interface ExternalcontactsContactCellPhone {
    /**
     * If contact accept SMS.
     */
    acceptsSms?: boolean;
    /**
     * Phone number country code.
     */
    countryCode: string;
    /**
     * Display string of the phone number.
     */
    display: string;
    /**
     * Phone number in e164 format.
     */
    e164: string;
    /**
     * Phone extension.
     */
    extension?: number;
}

export interface ExternalcontactsContactFacebookId {
    /**
     * Contact whatsapp display name.
     */
    displayName?: string;
    /**
     * Contact facebook scoped id.
     */
    ids?: outputs.ExternalcontactsContactFacebookIdId[];
}

export interface ExternalcontactsContactFacebookIdId {
    /**
     * Contact facebook scoped id.
     */
    scopedId?: string;
}

export interface ExternalcontactsContactHomePhone {
    /**
     * If contact accept SMS.
     */
    acceptsSms?: boolean;
    /**
     * Phone number country code.
     */
    countryCode: string;
    /**
     * Display string of the phone number.
     */
    display: string;
    /**
     * Phone number in e164 format.
     */
    e164: string;
    /**
     * Phone extension.
     */
    extension?: number;
}

export interface ExternalcontactsContactLineId {
    /**
     * Contact line display name.
     */
    displayName?: string;
    /**
     * Contact line id.
     */
    ids?: outputs.ExternalcontactsContactLineIdId[];
}

export interface ExternalcontactsContactLineIdId {
    /**
     * Contact line id.
     */
    userId?: string;
}

export interface ExternalcontactsContactOtherPhone {
    /**
     * If contact accept SMS.
     */
    acceptsSms?: boolean;
    /**
     * Phone number country code.
     */
    countryCode: string;
    /**
     * Display string of the phone number.
     */
    display: string;
    /**
     * Phone number in e164 format.
     */
    e164: string;
    /**
     * Phone extension.
     */
    extension?: number;
}

export interface ExternalcontactsContactTwitterId {
    /**
     * Contact twitter id.
     */
    id?: string;
    /**
     * Contact twitter name.
     */
    name?: string;
    /**
     * Contact twitter account url.
     */
    profileUrl: string;
    /**
     * Contact twitter screen name.
     */
    screenName?: string;
}

export interface ExternalcontactsContactWhatsappId {
    /**
     * Contact whatsapp display name.
     */
    displayName: string;
    /**
     * Contact whatsapp phone number.
     */
    phoneNumbers: outputs.ExternalcontactsContactWhatsappIdPhoneNumber[];
}

export interface ExternalcontactsContactWhatsappIdPhoneNumber {
    /**
     * If contact accept SMS.
     */
    acceptsSms?: boolean;
    /**
     * Phone number country code.
     */
    countryCode: string;
    /**
     * Display string of the phone number.
     */
    display: string;
    /**
     * Phone number in e164 format.
     */
    e164: string;
    /**
     * Phone extension.
     */
    extension?: number;
}

export interface ExternalcontactsContactWorkPhone {
    /**
     * If contact accept SMS.
     */
    acceptsSms?: boolean;
    /**
     * Phone number country code.
     */
    countryCode: string;
    /**
     * Display string of the phone number.
     */
    display: string;
    /**
     * Phone number in e164 format.
     */
    e164: string;
    /**
     * Phone extension.
     */
    extension?: number;
}

export interface GroupAddress {
    /**
     * Phone extension.
     */
    extension?: string;
    /**
     * Phone number for this contact type. Must be in an E.164 number format.
     */
    number?: string;
    /**
     * Contact type of the address. (GROUPRING | GROUPPHONE)
     */
    type: string;
}

export interface GroupRolesRole {
    /**
     * Division IDs applied to this resource. If not set, the home division will be used. '*' may be set for all divisions.
     */
    divisionIds?: string[];
    /**
     * Role ID.
     */
    roleId: string;
}

export interface IdpAdfsTimeouts {
    read?: string;
    update?: string;
}

export interface IdpGenericTimeouts {
    read?: string;
    update?: string;
}

export interface IdpGsuiteTimeouts {
    read?: string;
    update?: string;
}

export interface IdpOktaTimeouts {
    read?: string;
    update?: string;
}

export interface IdpOneloginTimeouts {
    read?: string;
    update?: string;
}

export interface IdpPingTimeouts {
    read?: string;
    update?: string;
}

export interface IdpSalesforceTimeouts {
    read?: string;
    update?: string;
}

export interface IntegrationActionConfigRequest {
    /**
     * Map of headers in name, value pairs to include in request.
     */
    headers?: {[key: string]: string};
    /**
     * Velocity template to define request body sent to 3rd party service. Any instances of '${' must be properly escaped as '$${'
     */
    requestTemplate: string;
    /**
     * HTTP method to use for request (GET | PUT | POST | PATCH | DELETE).
     */
    requestType: string;
    /**
     * URL that may include placeholders for requests to 3rd party service.
     */
    requestUrlTemplate: string;
}

export interface IntegrationActionConfigResponse {
    /**
     * Velocity template to build response to return from Action. Any instances of '${' must be properly escaped as '$${'.
     */
    successTemplate: string;
    /**
     * Map 'attribute name' and 'JSON path' pairs used to extract data from REST response.
     */
    translationMap?: {[key: string]: string};
    /**
     * Map 'attribute name' and 'default value' pairs used as fallback values if JSON path extraction fails for specified key.
     */
    translationMapDefaults?: {[key: string]: string};
}

export interface IntegrationConfig {
    /**
     * Integration advanced config (JSON string).
     */
    advanced: string;
    /**
     * Credentials required for the integration. The required keys are indicated in the credentials property of the Integration Type.
     */
    credentials?: {[key: string]: string};
    /**
     * Integration name.
     */
    name: string;
    /**
     * Integration notes.
     */
    notes?: string;
    /**
     * Integration config properties (JSON string).
     */
    properties: string;
}

export interface IntegrationCustomAuthActionConfigRequest {
    /**
     * Map of headers in name, value pairs to include in request.
     */
    headers?: {[key: string]: string};
    /**
     * Velocity template to define request body sent to 3rd party service. Any instances of '${' must be properly escaped as '$${'
     */
    requestTemplate: string;
    /**
     * HTTP method to use for request (GET | PUT | POST | PATCH | DELETE).
     */
    requestType: string;
    /**
     * URL that may include placeholders for requests to 3rd party service.
     */
    requestUrlTemplate: string;
}

export interface IntegrationCustomAuthActionConfigResponse {
    /**
     * Velocity template to build response to return from Action. Any instances of '${' must be properly escaped as '$${'.
     */
    successTemplate: string;
    /**
     * Map 'attribute name' and 'JSON path' pairs used to extract data from REST response.
     */
    translationMap?: {[key: string]: string};
    /**
     * Map 'attribute name' and 'default value' pairs used as fallback values if JSON path extraction fails for specified key.
     */
    translationMapDefaults?: {[key: string]: string};
}

export interface IntegrationFacebookTimeouts {
    read?: string;
    update?: string;
}

export interface JourneyActionMapAction {
    /**
     * Action template associated with the action map. For media type contentOffer.
     */
    actionTemplateId?: string;
    /**
     * Architect Flow Id and input contract. For media type architectFlow.
     */
    architectFlowFields?: outputs.JourneyActionMapActionArchitectFlowFields;
    /**
     * Whether this action should be throttled. Defaults to `true`.
     */
    isPacingEnabled?: boolean;
    /**
     * Media type of action. Valid values: webchat, webMessagingOffer, contentOffer, architectFlow, openAction.
     */
    mediaType: string;
    /**
     * Admin-configurable fields of an open action. For media type openAction.
     */
    openActionFields?: outputs.JourneyActionMapActionOpenActionFields;
    /**
     * Admin-configurable fields of a web messaging offer action. For media type webMessagingOffer.
     */
    webMessagingOfferFields?: outputs.JourneyActionMapActionWebMessagingOfferFields;
}

export interface JourneyActionMapActionArchitectFlowFields {
    /**
     * The architect flow.
     */
    architectFlowId: string;
    /**
     * Collection of Architect Flow Request Mappings to use.
     */
    flowRequestMappings?: outputs.JourneyActionMapActionArchitectFlowFieldsFlowRequestMapping[];
}

export interface JourneyActionMapActionArchitectFlowFieldsFlowRequestMapping {
    /**
     * Type of the value supplied. Valid values: String, Number, Integer, Boolean.
     */
    attributeType: string;
    /**
     * Method of finding value to use with Attribute. Valid values: Lookup, HardCoded.
     */
    mappingType: string;
    /**
     * Name of the Integration Action Attribute to supply the value for
     */
    name: string;
    /**
     * Value to supply for the specified Attribute
     */
    value: string;
}

export interface JourneyActionMapActionMapScheduleGroups {
    /**
     * The actions map's associated schedule group.
     */
    actionMapScheduleGroupId: string;
    /**
     * The action map's associated emergency schedule group.
     */
    emergencyActionMapScheduleGroupId?: string;
}

export interface JourneyActionMapActionOpenActionFields {
    /**
     * Custom fields defined in the schema referenced by the open action type selected.
     */
    configurationFields?: string;
    /**
     * The specific type of the open action.
     */
    openAction: outputs.JourneyActionMapActionOpenActionFieldsOpenAction;
}

export interface JourneyActionMapActionOpenActionFieldsOpenAction {
    /**
     * Id.
     */
    id: string;
    /**
     * Name.
     */
    name: string;
}

export interface JourneyActionMapActionWebMessagingOfferFields {
    /**
     * Flow to be invoked, overrides default flow when specified.
     */
    architectFlowId?: string;
    /**
     * Text value to be used when inviting a visitor to engage with a web messaging offer.
     */
    offerText?: string;
}

export interface JourneyActionMapActivation {
    /**
     * Activation delay time amount.
     */
    delayInSeconds?: number;
    /**
     * Type of activation. Valid values: immediate, on-next-visit, on-next-session, delay.
     */
    type: string;
}

export interface JourneyActionMapPageUrlCondition {
    /**
     * The comparison operator. Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith.
     */
    operator: string;
    /**
     * The URL condition value.
     */
    values: string[];
}

export interface JourneyActionMapTriggerWithEventCondition {
    /**
     * The name of the event for which this condition can be satisfied.
     */
    eventName?: string;
    /**
     * The event key.
     */
    key: string;
    /**
     * The comparison operator. Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith. Defaults to `equal`.
     */
    operator?: string;
    /**
     * The session type for which this condition can be satisfied. Valid values: web, app.
     */
    sessionType: string;
    /**
     * The stream type for which this condition can be satisfied. Valid values: Web, App.
     */
    streamType: string;
    /**
     * The event values.
     */
    values: string[];
}

export interface JourneyActionMapTriggerWithOutcomeProbabilityCondition {
    /**
     * Probability value for the selected outcome at or above which the action map will trigger.
     */
    maximumProbability: number;
    /**
     * The outcome ID.
     */
    outcomeId: string;
    /**
     * Additional probability condition, where if set, the action map will trigger if the current outcome probability is lower or equal to the value.
     */
    probability?: number;
}

export interface JourneyActionMapTriggerWithOutcomeQuantileCondition {
    /**
     * If set, this Condition is met when max_quantile_threshold is met, AND the current quantile of the OutcomeScore is below this fallback_quantile_threshold. Range 0.00-1.00
     */
    fallbackQuantileThreshold?: number;
    /**
     * This Outcome Quantile Condition is met when sessionMaxQuantile of the OutcomeScore is above this value, (unless fallbackQuantile is set). Range 0.00-1.00
     */
    maxQuantileThreshold: number;
    /**
     * The outcome ID.
     */
    outcomeId: string;
}

export interface JourneyActionTemplateContentOffer {
    /**
     * Body text of the content offer.
     */
    body?: string;
    /**
     * Properties customizing the call to action button on the content offer.
     */
    callToActions?: outputs.JourneyActionTemplateContentOfferCallToAction[];
    /**
     * The display mode used by Genesys Widgets when displaying the content offer.
     */
    displayMode: string;
    /**
     * Headline displayed above the body text of the content offer.
     */
    headline?: string;
    /**
     * URL for image displayed on the content offer.
     */
    imageUrl?: string;
    /**
     * The layout mode used by Genesys Widgets when displaying the content offer.
     */
    layoutMode: string;
    /**
     * Properties customizing the styling of the content offer.
     */
    styles?: outputs.JourneyActionTemplateContentOfferStyle[];
    /**
     * Title in the header of the content offer.
     */
    title?: string;
}

export interface JourneyActionTemplateContentOfferCallToAction {
    /**
     * Where should the URL be opened when the user clicks on the call to action button.
     */
    target?: string;
    /**
     * Text displayed on the call to action button.
     */
    text?: string;
    /**
     * URL to open when user clicks on the call to action button.
     */
    url: string;
}

export interface JourneyActionTemplateContentOfferStyle {
    /**
     * Properties for customizing the appearance of the body text.
     */
    bodies?: outputs.JourneyActionTemplateContentOfferStyleBody[];
    /**
     * Properties for customizing the appearance of the close button.
     */
    closeButtons?: outputs.JourneyActionTemplateContentOfferStyleCloseButton[];
    /**
     * Properties for customizing the appearance of the CTA button.
     */
    ctaButtons?: outputs.JourneyActionTemplateContentOfferStyleCtaButton[];
    /**
     * Properties for customizing the appearance of the headline text.
     */
    headlines?: outputs.JourneyActionTemplateContentOfferStyleHeadline[];
    /**
     * Properties for customizing the appearance of the content offer.
     */
    offers?: outputs.JourneyActionTemplateContentOfferStyleOffer[];
    /**
     * Properties for customizing the positioning of the content offer.
     */
    positions?: outputs.JourneyActionTemplateContentOfferStylePosition[];
    /**
     * Properties for customizing the appearance of the title text.
     */
    titles?: outputs.JourneyActionTemplateContentOfferStyleTitle[];
}

export interface JourneyActionTemplateContentOfferStyleBody {
    /**
     * Color of the text.
     */
    color?: string;
    /**
     * Font of the text.
     */
    font?: string;
    /**
     * Font size of the text.
     */
    fontSize?: string;
    /**
     * Text alignment.
     */
    textAlign?: string;
}

export interface JourneyActionTemplateContentOfferStyleCloseButton {
    /**
     * Color of button.
     */
    color?: string;
    /**
     * Opacity of button.
     */
    opacity?: number;
}

export interface JourneyActionTemplateContentOfferStyleCtaButton {
    /**
     * Background color of the CTA button.
     */
    backgroundColor?: string;
    /**
     * Color of the text.
     */
    color?: string;
    /**
     * Font of the text.
     */
    font?: string;
    /**
     * Font size of the text.
     */
    fontSize?: string;
    /**
     * Text alignment.
     */
    textAlign?: string;
}

export interface JourneyActionTemplateContentOfferStyleHeadline {
    /**
     * Color of the text.
     */
    color?: string;
    /**
     * Font of the text.
     */
    font?: string;
    /**
     * Font size of the text.
     */
    fontSize?: string;
    /**
     * Text alignment.
     */
    textAlign?: string;
}

export interface JourneyActionTemplateContentOfferStyleOffer {
    /**
     * Background color of the offer.
     */
    backgroundColor?: string;
    /**
     * Text color of the offer.
     */
    color?: string;
    /**
     * Padding of the offer.
     */
    padding?: string;
}

export interface JourneyActionTemplateContentOfferStylePosition {
    /**
     * Bottom positioning offset.
     */
    bottom?: string;
    /**
     * Left positioning offset.
     */
    left?: string;
    /**
     * Right positioning offset.
     */
    right?: string;
    /**
     * Top positioning offset.
     */
    top?: string;
}

export interface JourneyActionTemplateContentOfferStyleTitle {
    /**
     * Color of the text.
     */
    color?: string;
    /**
     * Font of the text.
     */
    font?: string;
    /**
     * Font size of the text.
     */
    fontSize?: string;
    /**
     * Text alignment.
     */
    textAlign?: string;
}

export interface JourneyOutcomeAssociatedValueField {
    /**
     * The data type of the value field.Valid values: Number, Integer.
     */
    dataType: string;
    /**
     * The field name for extracting value from event.
     */
    name: string;
}

export interface JourneyOutcomeContext {
    /**
     * A list of one or more patterns to match.
     */
    patterns: outputs.JourneyOutcomeContextPattern[];
}

export interface JourneyOutcomeContextPattern {
    /**
     * A list of one or more criteria to satisfy.
     */
    criterias: outputs.JourneyOutcomeContextPatternCriteria[];
}

export interface JourneyOutcomeContextPatternCriteria {
    /**
     * The entity to match the pattern against.Valid values: visit.
     */
    entityType: string;
    /**
     * The criteria key.
     */
    key: string;
    /**
     * The comparison operator. Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith. Defaults to `equal`.
     */
    operator?: string;
    /**
     * Should criteria be case insensitive.
     */
    shouldIgnoreCase: boolean;
    /**
     * The criteria values.
     */
    values: string[];
}

export interface JourneyOutcomeJourney {
    /**
     * A list of zero or more patterns to match.
     */
    patterns: outputs.JourneyOutcomeJourneyPattern[];
}

export interface JourneyOutcomeJourneyPattern {
    /**
     * The number of times the pattern must match.
     */
    count: number;
    /**
     * A list of one or more criteria to satisfy.
     */
    criterias: outputs.JourneyOutcomeJourneyPatternCriteria[];
    /**
     * The name of the event for which this pattern can be matched on.
     */
    eventName?: string;
    /**
     * The session type for which this pattern can be matched on. Valid values: web, app.
     */
    sessionType: string;
    /**
     * The stream type for which this pattern can be matched on. Valid values: Web, App.
     */
    streamType: string;
}

export interface JourneyOutcomeJourneyPatternCriteria {
    /**
     * The criteria key.
     */
    key: string;
    /**
     * The comparison operator.Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith. Defaults to `equal`.
     */
    operator?: string;
    /**
     * Should criteria be case insensitive.
     */
    shouldIgnoreCase: boolean;
    /**
     * The criteria values.
     */
    values: string[];
}

export interface JourneySegmentContext {
    /**
     * A list of one or more patterns to match.
     */
    patterns: outputs.JourneySegmentContextPattern[];
}

export interface JourneySegmentContextPattern {
    /**
     * A list of one or more criteria to satisfy.
     */
    criterias: outputs.JourneySegmentContextPatternCriteria[];
}

export interface JourneySegmentContextPatternCriteria {
    /**
     * The entity to match the pattern against.Valid values: visit.
     */
    entityType: string;
    /**
     * The criteria key.
     */
    key: string;
    /**
     * The comparison operator. Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith. Defaults to `equal`.
     */
    operator?: string;
    /**
     * Should criteria be case insensitive.
     */
    shouldIgnoreCase: boolean;
    /**
     * The criteria values.
     */
    values: string[];
}

export interface JourneySegmentJourney {
    /**
     * A list of zero or more patterns to match.
     */
    patterns: outputs.JourneySegmentJourneyPattern[];
}

export interface JourneySegmentJourneyPattern {
    /**
     * The number of times the pattern must match.
     */
    count: number;
    /**
     * A list of one or more criteria to satisfy.
     */
    criterias: outputs.JourneySegmentJourneyPatternCriteria[];
    /**
     * The name of the event for which this pattern can be matched on.
     */
    eventName?: string;
    /**
     * The session type for which this pattern can be matched on. Valid values: web, app.
     */
    sessionType: string;
    /**
     * The stream type for which this pattern can be matched on. Valid values: Web, App.
     */
    streamType: string;
}

export interface JourneySegmentJourneyPatternCriteria {
    /**
     * The criteria key.
     */
    key: string;
    /**
     * The comparison operator.Valid values: containsAll, containsAny, notContainsAll, notContainsAny, equal, notEqual, greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual, startsWith, endsWith. Defaults to `equal`.
     */
    operator?: string;
    /**
     * Should criteria be case insensitive.
     */
    shouldIgnoreCase: boolean;
    /**
     * The criteria values.
     */
    values: string[];
}

export interface JourneyViewsElement {
    /**
     * Attributes on an element in a journey view.
     */
    attributes: outputs.JourneyViewsElementAttributes;
    /**
     * A set of filters on an element within a journey view.
     */
    filter?: outputs.JourneyViewsElementFilter;
    /**
     * A list of JourneyViewLink objects, listing the elements downstream of this element.
     */
    followedBies?: outputs.JourneyViewsElementFollowedBy[];
    /**
     * The unique identifier of the element within the elements list.
     */
    id: string;
    /**
     * The unique name of the element within the view.
     */
    name: string;
}

export interface JourneyViewsElementAttributes {
    /**
     * The identifier for the element based on its type.
     */
    id?: string;
    /**
     * The source for the element (e.g. IVR, Voice, Chat). Used for informational purposes only.
     */
    source?: string;
    /**
     * The type of the element (e.g. Event).Valid values: Event.
     */
    type: string;
}

export interface JourneyViewsElementFilter {
    /**
     * A filter on an element within a journey view.
     */
    predicates?: outputs.JourneyViewsElementFilterPredicate[];
    /**
     * Boolean operation to apply to the provided predicates and clauses. Valid values: And.
     */
    type: string;
}

export interface JourneyViewsElementFilterPredicate {
    /**
     * The element's attribute being filtered on
     */
    dimension: string;
    /**
     * set this to true if no specific value to be considered.
     */
    noValue?: boolean;
    /**
     * Optional operator, default is Matches. Valid values: Matches.Valid values: Matches, NotMatches. Defaults to `Matches`.
     */
    operator?: string;
    /**
     * The identifier for the element based on its type.
     */
    values: string[];
}

export interface JourneyViewsElementFollowedBy {
    /**
     * A time constraint on this link, which requires a customer must complete the downstream element after this amount of time to be counted..
     */
    constraintAfter?: outputs.JourneyViewsElementFollowedByConstraintAfter;
    /**
     * A time constraint on this link, which requires a customer to complete the downstream element within this amount of time to be counted.
     */
    constraintWithin?: outputs.JourneyViewsElementFollowedByConstraintWithin;
    /**
     * The type of events that will be counted. Note: Concurrent will override any JourneyViewLinkTimeConstraint. Default is Sequential.Valid values: All, Concurrent, Sequential.
     */
    eventCountType?: string;
    /**
     * The identifier of the element downstream.
     */
    id: string;
    /**
     * Other (secondary) attributes on which this link should join the customers being counted.
     */
    joinAttributes?: string[];
}

export interface JourneyViewsElementFollowedByConstraintAfter {
    /**
     * The unit for the link's time constraint.Valid values: Seconds, Minutes, Hours, Days, Weeks, Months.
     */
    unit?: string;
    /**
     * The value for the link's time constraint.
     */
    value?: number;
}

export interface JourneyViewsElementFollowedByConstraintWithin {
    /**
     * The unit for the link's time constraint.Valid values: Seconds, Minutes, Hours, Days, Weeks, Months.
     */
    unit?: string;
    /**
     * The value for the link's time constraint.
     */
    value?: number;
}

export interface KnowledgeCategoryKnowledgeCategory {
    /**
     * Knowledge base description
     */
    description?: string;
    /**
     * Knowledge base name. Changing the name attribute will cause the knowledge_category resource to be dropped and recreated with a new ID.
     */
    name: string;
    /**
     * Knowledge category parent id
     */
    parentId?: string;
}

export interface KnowledgeDocumentKnowledgeDocument {
    /**
     * List of alternate phrases related to the title which improves search results.
     */
    alternatives?: outputs.KnowledgeDocumentKnowledgeDocumentAlternative[];
    /**
     * The name of the category associated with the document.
     */
    categoryName?: string;
    /**
     * The names of labels associated with the document.
     */
    labelNames?: string[];
    /**
     * Document title
     */
    title: string;
    /**
     * Indicates if the knowledge document should be included in search results.
     */
    visible: boolean;
}

export interface KnowledgeDocumentKnowledgeDocumentAlternative {
    /**
     * Autocomplete enabled for the alternate phrase.
     */
    autocomplete?: boolean;
    /**
     * Alternate phrasing to the document title.
     */
    phrase: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariation {
    /**
     * The content for the variation.
     */
    body?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBody;
    /**
     * The version of the document.
     */
    documentVersion?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationDocumentVersion;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBody {
    /**
     * The content for the variation.
     */
    blocks: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlock[];
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlock {
    /**
     * Image. It must contain a value if the type of the block is Image.
     */
    image?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockImage;
    /**
     * List. It must contain a value if the type of the block is UnorderedList or OrderedList.
     */
    list?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockList;
    /**
     * Paragraph. It must contain a value if the type of the block is Paragraph.
     */
    paragraph?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraph;
    /**
     * The type of the block for the body. This determines which body block object (paragraph, list, video or image) would have a value.
     */
    type: string;
    /**
     * Video. It must contain a value if the type of the block is Video.
     */
    video?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockVideo;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockImage {
    /**
     * The URL of the page that the hyperlink goes to.
     */
    hyperlink?: string;
    /**
     * The URL for the image.
     */
    url: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockList {
    /**
     * The list of items for an OrderedList or an UnorderedList.
     */
    blocks?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlock[];
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlock {
    /**
     * The list of items for an OrderedList or an UnorderedList.
     */
    blocks: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlock[];
    /**
     * The type of the list block.
     */
    type: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlock {
    /**
     * Image. It must contain a value if the type of the block is Image.
     */
    image?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlockImage;
    /**
     * Text. It must contain a value if the type of the block is Text.
     */
    text?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlockText;
    /**
     * The type of the content block.
     */
    type: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlockImage {
    /**
     * The URL of the page that the hyperlink goes to.
     */
    hyperlink?: string;
    /**
     * The URL for the image.
     */
    url: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockListBlockBlockText {
    /**
     * The URL of the page that the hyperlink goes to.
     */
    hyperlink?: string;
    /**
     * The unique list of marks (whether it is bold and/or underlined etc.) for the text. Valid values: Bold | Italic | Underline
     */
    marks?: string[];
    /**
     * Text.
     */
    text: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraph {
    /**
     * The content for the variation.
     */
    blocks?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlock[];
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlock {
    /**
     * Image. It must contain a value if the type of the block is Image.
     */
    image?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlockImage;
    /**
     * Text. It must contain a value if the type of the block is Text.
     */
    text?: outputs.KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlockText;
    /**
     * The type of the content block.
     */
    type: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlockImage {
    /**
     * The URL of the page that the hyperlink goes to.
     */
    hyperlink?: string;
    /**
     * The URL for the image.
     */
    url: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockParagraphBlockText {
    /**
     * The URL of the page that the hyperlink goes to.
     */
    hyperlink?: string;
    /**
     * The unique list of marks (whether it is bold and/or underlined etc.) for the text. Valid values: Bold | Italic | Underline
     */
    marks?: string[];
    /**
     * Text.
     */
    text: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationBodyBlockVideo {
    /**
     * The URL for the video.
     */
    url: string;
}

export interface KnowledgeDocumentVariationKnowledgeDocumentVariationDocumentVersion {
    /**
     * Id
     */
    id: string;
}

export interface KnowledgeLabelKnowledgeLabel {
    /**
     * The color for the label.
     */
    color: string;
    /**
     * The name of the label.
     */
    name: string;
}

export interface KnowledgeV1CategoryKnowledgeCategory {
    /**
     * Knowledge base description
     */
    description?: string;
    /**
     * Knowledge base name. Changing the name attribute will cause the knowledge_category resource to be dropped and recreated with a new ID.
     */
    name: string;
    /**
     * Knowledge category parent id
     */
    parentId?: string;
}

export interface KnowledgeV1DocumentKnowledgeDocument {
    /**
     * Article details
     */
    article?: outputs.KnowledgeV1DocumentKnowledgeDocumentArticle;
    /**
     * List of knowledge base category names for the document
     */
    categories?: string[];
    /**
     * External Url to the document
     */
    externalUrl?: string;
    /**
     * Faq document details
     */
    faq?: outputs.KnowledgeV1DocumentKnowledgeDocumentFaq;
    /**
     * Document type according to assigned template
     */
    type?: string;
}

export interface KnowledgeV1DocumentKnowledgeDocumentArticle {
    /**
     * List of Alternative questions related to the title which helps in improving the likelihood of a match to user query.
     */
    alternatives?: string[];
    /**
     * Presigned URL to retrieve the document content.
     */
    contentLocationUrl?: string;
    /**
     * The title of the Article.
     */
    title?: string;
}

export interface KnowledgeV1DocumentKnowledgeDocumentFaq {
    /**
     * List of Alternative questions related to the answer which helps in improving the likelihood of a match to user query
     */
    alternatives?: string[];
    /**
     * The answer for this FAQ
     */
    answer?: string;
    /**
     * The question for this FAQ
     */
    question?: string;
}

export interface LocationAddress {
    /**
     * Location city.
     */
    city: string;
    /**
     * Country abbreviation.
     */
    country: string;
    /**
     * Location state. Required for countries with states.
     */
    state?: string;
    /**
     * Street address 1.
     */
    street1: string;
    /**
     * Street address 2.
     */
    street2?: string;
    /**
     * Location zip code.
     */
    zipCode: string;
}

export interface LocationEmergencyNumber {
    /**
     * Emergency phone number.  Must be in an E.164 number format.
     */
    number: string;
    /**
     * Type of emergency number (default | elin). Defaults to `default`.
     */
    type?: string;
}

export interface OauthClientRole {
    /**
     * Division associated with the given role which forms a grant. If not set, the home division will be used. '*' may be set for all divisions.
     */
    divisionId: string;
    /**
     * Role to be associated with the given division which forms a grant.
     */
    roleId: string;
}

export interface OrganizationAuthenticationSettingsPasswordRequirements {
    /**
     * Length of time (in days) before a password must be changed
     */
    expirationDays?: number;
    /**
     * Minimum age of the password (in seconds) before it can be changed
     */
    minimumAgeSeconds?: number;
    /**
     * The minimum number of numerals (0-9) that must be included in passwords
     */
    minimumDigits?: number;
    /**
     * The minimum character length for passwords
     */
    minimumLength?: number;
    /**
     * The minimum number of characters required for passwords
     */
    minimumLetters?: number;
    /**
     * The minimum number of lower case letters that must be included in passwords
     */
    minimumLower?: number;
    /**
     * The minimum number of special characters that must be included in passwords
     */
    minimumSpecials?: number;
    /**
     * The minimum number of upper case letters that must be included in passwords
     */
    minimumUpper?: number;
}

export interface OutboundAttemptLimitRecallEntries {
    answeringMachine?: outputs.OutboundAttemptLimitRecallEntriesAnsweringMachine;
    busy?: outputs.OutboundAttemptLimitRecallEntriesBusy;
    fax?: outputs.OutboundAttemptLimitRecallEntriesFax;
    noAnswer?: outputs.OutboundAttemptLimitRecallEntriesNoAnswer;
}

export interface OutboundAttemptLimitRecallEntriesAnsweringMachine {
    /**
     * Number of minutes between attempts. Must be greater than or equal to 5.
     */
    minutesBetweenAttempts: number;
    /**
     * Number of recall attempts. Must be less than max_attempts_per_contact.
     */
    nbrAttempts: number;
}

export interface OutboundAttemptLimitRecallEntriesBusy {
    /**
     * Number of minutes between attempts. Must be greater than or equal to 5.
     */
    minutesBetweenAttempts: number;
    /**
     * Number of recall attempts. Must be less than max_attempts_per_contact.
     */
    nbrAttempts: number;
}

export interface OutboundAttemptLimitRecallEntriesFax {
    /**
     * Number of minutes between attempts. Must be greater than or equal to 5.
     */
    minutesBetweenAttempts: number;
    /**
     * Number of recall attempts. Must be less than max_attempts_per_contact.
     */
    nbrAttempts: number;
}

export interface OutboundAttemptLimitRecallEntriesNoAnswer {
    /**
     * Number of minutes between attempts. Must be greater than or equal to 5.
     */
    minutesBetweenAttempts: number;
    /**
     * Number of recall attempts. Must be less than max_attempts_per_contact.
     */
    nbrAttempts: number;
}

export interface OutboundCallabletimesetCallableTime {
    /**
     * The time intervals for which it is acceptable to place outbound calls.
     */
    timeSlots: outputs.OutboundCallabletimesetCallableTimeTimeSlot[];
    /**
     * The time zone for the time slots; for example, Africa/Abidjan
     */
    timeZoneId: string;
}

export interface OutboundCallabletimesetCallableTimeTimeSlot {
    /**
     * The day of the interval. Valid values: [1-7], representing Monday through Sunday
     */
    day: number;
    /**
     * The start time of the interval as an ISO-8601 string, i.e. HH:mm:ss
     */
    startTime: string;
    /**
     * The end time of the interval as an ISO-8601 string, i.e. HH:mm:ss
     */
    stopTime: string;
}

export interface OutboundCallanalysisresponsesetResponses {
    callableBusy?: outputs.OutboundCallanalysisresponsesetResponsesCallableBusy;
    callableDisconnect?: outputs.OutboundCallanalysisresponsesetResponsesCallableDisconnect;
    callableFax?: outputs.OutboundCallanalysisresponsesetResponsesCallableFax;
    callableLineconnected?: outputs.OutboundCallanalysisresponsesetResponsesCallableLineconnected;
    callableMachine?: outputs.OutboundCallanalysisresponsesetResponsesCallableMachine;
    callableNoanswer?: outputs.OutboundCallanalysisresponsesetResponsesCallableNoanswer;
    callablePerson?: outputs.OutboundCallanalysisresponsesetResponsesCallablePerson;
    callableSit?: outputs.OutboundCallanalysisresponsesetResponsesCallableSit;
    uncallableNotfound?: outputs.OutboundCallanalysisresponsesetResponsesUncallableNotfound;
    uncallableSit?: outputs.OutboundCallanalysisresponsesetResponsesUncallableSit;
}

export interface OutboundCallanalysisresponsesetResponsesCallableBusy {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableDisconnect {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableFax {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableLineconnected {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableMachine {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableNoanswer {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallablePerson {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesCallableSit {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesUncallableNotfound {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCallanalysisresponsesetResponsesUncallableSit {
    /**
     * Parameter for this reaction. For transfer_flow, this would be the outbound flow id.
     */
    data?: string;
    /**
     * Name of the parameter for this reaction. For transfer_flow, this would be the outbound flow name.
     */
    name?: string;
    /**
     * The reaction to take for a given call analysis result.
     */
    reactionType: string;
}

export interface OutboundCampaignContactSort {
    /**
     * The direction in which to sort contacts. Defaults to `ASC`.
     */
    direction?: string;
    /**
     * The field name by which to sort contacts.
     */
    fieldName: string;
    /**
     * Whether or not the column contains numeric data. Defaults to `false`.
     */
    numeric?: boolean;
}

export interface OutboundCampaignDynamicContactQueueingSettings {
    /**
     * Whether to sort contacts dynamically.
     */
    sort: boolean;
}

export interface OutboundCampaignDynamicLineBalancingSettings {
    /**
     * Indicates that this campaign is subject of dynamic line balancing.
     */
    enabled?: boolean;
    /**
     * Relative weight of this campaign in dynamic line balancing.
     */
    relativeWeight?: number;
}

export interface OutboundCampaignPhoneColumn {
    /**
     * The name of the phone column.
     */
    columnName: string;
}

export interface OutboundCampaignruleCampaignRuleAction {
    /**
     * The action to take on the campaignRuleActionEntities
     * (turnOnCampaign | turnOffCampaign | turnOnSequence | turnOffSequence | setCampaignPriority | recycleCampaign | setCampaignDialingMode).
     */
    actionType: string;
    /**
     * The list of entities that this action will apply to.
     */
    campaignRuleActionEntities: outputs.OutboundCampaignruleCampaignRuleActionCampaignRuleActionEntity[];
    /**
     * The ID of the CampaignRuleAction.
     */
    id: string;
    /**
     * The parameters for the CampaignRuleAction. Required for certain actionTypes.
     */
    parameters?: outputs.OutboundCampaignruleCampaignRuleActionParameter[];
}

export interface OutboundCampaignruleCampaignRuleActionCampaignRuleActionEntity {
    /**
     * The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. Changing the outboundCampaignRuleEntityCampaignRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.
     */
    campaignIds?: string[];
    /**
     * The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. Changing the outboundCampaignRuleEntitySequenceRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.
     */
    sequenceIds?: string[];
    /**
     * If true, the CampaignRuleAction will apply to the same entity that triggered the CampaignRuleCondition. Defaults to `false`.
     */
    useTriggeringEntity?: boolean;
}

export interface OutboundCampaignruleCampaignRuleActionParameter {
    /**
     * The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action (agentless | preview | power | predictive | progressive | external).
     */
    dialingMode?: string;
    /**
     * The operator for comparison. Required for a CampaignRuleCondition.
     */
    operator?: string;
    /**
     * The priority to set a campaign to (1 | 2 | 3 | 4 | 5). Required for the 'setCampaignPriority' action.
     */
    priority?: string;
    /**
     * The value for comparison. Required for a CampaignRuleCondition.
     */
    value?: string;
}

export interface OutboundCampaignruleCampaignRuleCondition {
    /**
     * The type of condition to evaluate (campaignProgress | campaignAgents).
     */
    conditionType: string;
    /**
     * The ID of the CampaignRuleCondition.
     */
    id: string;
    /**
     * The parameters for the CampaignRuleCondition.
     */
    parameters: outputs.OutboundCampaignruleCampaignRuleConditionParameter[];
}

export interface OutboundCampaignruleCampaignRuleConditionParameter {
    /**
     * The dialing mode to set a campaign to. Required for the 'setCampaignDialingMode' action (agentless | preview | power | predictive | progressive | external).
     */
    dialingMode?: string;
    /**
     * The operator for comparison. Required for a CampaignRuleCondition.
     */
    operator?: string;
    /**
     * The priority to set a campaign to (1 | 2 | 3 | 4 | 5). Required for the 'setCampaignPriority' action.
     */
    priority?: string;
    /**
     * The value for comparison. Required for a CampaignRuleCondition.
     */
    value?: string;
}

export interface OutboundCampaignruleCampaignRuleEntities {
    /**
     * The list of campaigns for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a campaign. Changing the outboundCampaignRuleEntityCampaignRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.
     */
    campaignIds?: string[];
    /**
     * The list of sequences for a CampaignRule to monitor. Required if the CampaignRule has any conditions that run on a sequence. Changing the outboundCampaignRuleEntitySequenceRuleId attribute will cause the outbound_campaignrule object to be dropped and recreated with a new ID.
     */
    sequenceIds?: string[];
}

export interface OutboundContactListColumnDataTypeSpecification {
    /**
     * The data type of the column selected for dynamic queueing (TEXT, NUMERIC or TIMESTAMP)
     */
    columnDataType: string;
    /**
     * The column name of a column selected for dynamic queueing.
     */
    columnName: string;
    /**
     * The maximum length of the numeric column selected for dynamic queueing.
     */
    max?: number;
    /**
     * The maximum length of the text column selected for dynamic queueing.
     */
    maxLength: number;
    /**
     * The minimum length of the numeric column selected for dynamic queueing.
     */
    min?: number;
}

export interface OutboundContactListContactContactableStatus {
    /**
     * A map of individual contact method columns to whether the individual column is contactable for the associated media type.
     */
    columnStatuses?: outputs.OutboundContactListContactContactableStatusColumnStatus[];
    /**
     * Indicates whether or not the entire contact is contactable for the associated media type.
     */
    contactable: boolean;
    /**
     * The key which identifies the media type (Voice, SMS and Email).
     */
    mediaType: string;
}

export interface OutboundContactListContactContactableStatusColumnStatus {
    /**
     * The key which identifies the contact method column.
     */
    column: string;
    /**
     * Indicates whether or not an individual contact method column is contactable.
     */
    contactable: boolean;
}

export interface OutboundContactListContactPhoneNumberStatus {
    /**
     * Indicates whether or not a phone number is callable.
     */
    callable: boolean;
    /**
     * Phone number column identifier.
     */
    key: string;
}

export interface OutboundContactListEmailColumn {
    /**
     * The name of the email column.
     */
    columnName: string;
    /**
     * A column that indicates the timezone to use for a given contact when checking contactable times.
     */
    contactableTimeColumn?: string;
    /**
     * Indicates the type of the email column. For example, 'work' or 'personal'.
     */
    type: string;
}

export interface OutboundContactListPhoneColumn {
    /**
     * A column that indicates the timezone to use for a given contact when checking callable times. Not allowed if 'automaticTimeZoneMapping' is set to true.
     */
    callableTimeColumn?: string;
    /**
     * The name of the phone column.
     */
    columnName: string;
    /**
     * Indicates the type of the phone column. For example, 'cell' or 'home'.
     */
    type: string;
}

export interface OutboundContactListTemplateColumnDataTypeSpecification {
    /**
     * The data type of the column selected for dynamic queueing (TEXT, NUMERIC or TIMESTAMP)
     */
    columnDataType: string;
    /**
     * The column name of a column selected for dynamic queueing.
     */
    columnName: string;
    /**
     * The maximum length of the numeric column selected for dynamic queueing.
     */
    max?: number;
    /**
     * The maximum length of the text column selected for dynamic queueing.
     */
    maxLength: number;
    /**
     * The minimum length of the numeric column selected for dynamic queueing.
     */
    min?: number;
}

export interface OutboundContactListTemplateEmailColumn {
    /**
     * The name of the email column.
     */
    columnName: string;
    /**
     * A column that indicates the timezone to use for a given contact when checking contactable times.
     */
    contactableTimeColumn?: string;
    /**
     * Indicates the type of the email column. For example, 'work' or 'personal'.
     */
    type: string;
}

export interface OutboundContactListTemplatePhoneColumn {
    /**
     * A column that indicates the timezone to use for a given contact when checking callable times. Not allowed if 'automaticTimeZoneMapping' is set to true.
     */
    callableTimeColumn?: string;
    /**
     * The name of the phone column.
     */
    columnName: string;
    /**
     * Indicates the type of the phone column. For example, 'cell' or 'home'.
     */
    type: string;
}

export interface OutboundContactlistfilterClause {
    /**
     * How to join predicates together.
     */
    filterType: string;
    /**
     * Conditions to filter the contacts by.
     */
    predicates?: outputs.OutboundContactlistfilterClausePredicate[];
}

export interface OutboundContactlistfilterClausePredicate {
    /**
     * Contact list column from the contact list filter's contact list.
     */
    column?: string;
    /**
     * The type of data in the contact column.
     */
    columnType?: string;
    /**
     * Inverts the result of the predicate (i.e., if the predicate returns true, inverting it will return false).
     */
    inverted: boolean;
    /**
     * The operator for this contact list filter predicate.
     */
    operator: string;
    /**
     * Value with which to compare the contact's data. This could be text, a number, or a relative time. A value for relative time should follow the format PxxDTyyHzzM, where xx, yy, and zz specify the days, hours and minutes. For example, a value of P01DT08H30M corresponds to 1 day, 8 hours, and 30 minutes from now. To specify a time in the past, include a negative sign before each numeric value. For example, a value of P-01DT-08H-30M corresponds to 1 day, 8 hours, and 30 minutes in the past. You can also do things like P01DT00H-30M, which would correspond to 23 hours and 30 minutes from now (1 day - 30 minutes).
     */
    value?: string;
    /**
     * A range of values. Required for operators BETWEEN and IN.
     */
    varRange?: outputs.OutboundContactlistfilterClausePredicateVarRange;
}

export interface OutboundContactlistfilterClausePredicateVarRange {
    /**
     * A set of values that the contact data should be in. Required for the IN operator.
     */
    inSets?: string[];
    /**
     * The maximum value of the range. Required for the operator BETWEEN.
     */
    max?: string;
    /**
     * Whether or not to include the maximum in the range.
     */
    maxInclusive?: boolean;
    /**
     * The minimum value of the range. Required for the operator BETWEEN.
     */
    min?: string;
    /**
     * Whether or not to include the minimum in the range.
     */
    minInclusive?: boolean;
}

export interface OutboundDnclistEntry {
    /**
     * Expiration date for DNC phone numbers in yyyy-MM-ddTHH:mmZ format.
     */
    expirationDate?: string;
    /**
     * Phone numbers to add to a DNC list. Only possible if the dncSourceType is rds.  Phone numbers must be in an E.164 number format.
     */
    phoneNumbers?: string[];
}

export interface OutboundFilespecificationtemplateColumnInformation {
    /**
     * Column name. Mandatory for Fixed position/length file format.
     */
    columnName?: string;
    /**
     * 0 based column number in delimited file format.
     */
    columnNumber?: number;
    /**
     * Column width. Mandatory for Fixed position/length file format.
     */
    length?: number;
    /**
     * Zero-based position of the first column's character. Mandatory for Fixed position/length file format.
     */
    startPosition?: number;
}

export interface OutboundFilespecificationtemplatePreprocessingRule {
    /**
     * The regular expression to which file lines are to be matched
     */
    find?: string;
    /**
     * Replaces all matching substrings in every line.
     */
    global?: boolean;
    /**
     * Enables case-insensitive matching.
     */
    ignoreCase?: boolean;
    /**
     * The string to be substituted for each match.
     */
    replaceWith?: string;
}

export interface OutboundMessagingcampaignContactSort {
    /**
     * The direction in which to sort contacts. Defaults to `ASC`.
     */
    direction?: string;
    /**
     * The field name by which to sort contacts.
     */
    fieldName: string;
    /**
     * Whether or not the column contains numeric data. Defaults to `false`.
     */
    numeric?: boolean;
}

export interface OutboundMessagingcampaignSmsConfig {
    /**
     * The content template used to formulate the message to send to the contact. Either message_column or content_template_id is required.
     */
    contentTemplateId?: string;
    /**
     * The Contact List column specifying the message to send to the contact. Either message_column or content_template_id is required.
     */
    messageColumn?: string;
    /**
     * The Contact List column specifying the phone number to send a message to.
     */
    phoneColumn: string;
    /**
     * A phone number provisioned for SMS communications in E.164 format. E.g. +13175555555 or +34234234234
     */
    senderSmsPhoneNumber: string;
}

export interface OutboundRulesetRule {
    /**
     * The list of actions to be taken if the conditions are true.
     */
    actions: outputs.OutboundRulesetRuleAction[];
    /**
     * The category of the rule.
     */
    category: string;
    /**
     * A list of Conditions. All of the Conditions must evaluate to true to trigger the actions.
     */
    conditions: outputs.OutboundRulesetRuleCondition[];
    /**
     * The name of the rule.
     */
    name: string;
    /**
     * The ranked order of the rule. Rules are processed from lowest number to highest.
     */
    order?: number;
}

export interface OutboundRulesetRuleAction {
    /**
     * Additional type specification for this DialerAction.
     */
    actionTypeName: string;
    /**
     * The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionBehavior.
     */
    agentWrapupField?: string;
    /**
     * The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionBehavior.
     */
    callAnalysisResultField?: string;
    /**
     * A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionBehavior.
     */
    contactColumnToDataActionFieldMappings?: outputs.OutboundRulesetRuleActionContactColumnToDataActionFieldMapping[];
    /**
     * The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionBehavior.
     */
    contactIdField?: string;
    /**
     * The Data Action to use for this action. Required for a dataActionBehavior.
     */
    dataActionId?: string;
    /**
     * A map of key-value pairs pertinent to the DialerAction. Different types of DialerActions require different properties. MODIFY_CONTACT_ATTRIBUTE with an updateOption of SET takes a contact column as the key and accepts any value. SCHEDULE_CALLBACK takes a key 'callbackOffset' that specifies how far in the future the callback should be scheduled, in minutes. SET_CALLER_ID takes two keys: 'callerAddress', which should be the caller id phone number, and 'callerName'. For either key, you can also specify a column on the contact to get the value from. To do this, specify 'contact.Column', where 'Column' is the name of the contact column from which to get the value. SET_SKILLS takes a key 'skills' with an array of skill ids wrapped into a string (Example: {'skills': '['skillIdHere']'} ).
     */
    properties: {[key: string]: string};
    /**
     * The type of this DialerAction.
     */
    type: string;
    /**
     * Specifies how a contact attribute should be updated. Required for MODIFY_CONTACT_ATTRIBUTE.
     */
    updateOption?: string;
}

export interface OutboundRulesetRuleActionContactColumnToDataActionFieldMapping {
    /**
     * The name of a contact column whose data will be passed to the data action
     */
    contactColumnName: string;
    /**
     * The name of an input field from the data action that the contact column data will be passed to
     */
    dataActionField: string;
}

export interface OutboundRulesetRuleCondition {
    /**
     * The input field from the data action that the agentWrapup will be passed to for this condition. Valid for a wrapup dataActionCondition.
     */
    agentWrapupField?: string;
    /**
     * An attribute name associated with this Condition. Required for a contactAttributeCondition.
     */
    attributeName?: string;
    /**
     * The input field from the data action that the callAnalysisResult will be passed to for this condition. Valid for a wrapup dataActionCondition.
     */
    callAnalysisResultField?: string;
    /**
     * List of wrap-up code identifiers. Required for a wrapupCondition.
     */
    codes: string[];
    /**
     * A list of mappings defining which contact data fields will be passed to which data action input fields for this condition. Valid for a dataActionCondition.
     */
    contactColumnToDataActionFieldMappings?: outputs.OutboundRulesetRuleConditionContactColumnToDataActionFieldMapping[];
    /**
     * The input field from the data action that the contactId will be passed to for this condition. Valid for a dataActionCondition.
     */
    contactIdField?: string;
    /**
     * The Data Action to use for this condition. Required for a dataActionCondition.
     */
    dataActionId?: string;
    /**
     * The result of this condition if the data action returns a result indicating there was no data. Required for a DataActionCondition.
     */
    dataNotFoundResolution?: boolean;
    /**
     * If true, inverts the result of evaluating this Condition. Default is false.
     */
    inverted?: boolean;
    /**
     * An operation with which to evaluate the Condition. Not used for a DataActionCondition.
     */
    operator: string;
    /**
     * A list of predicates defining the comparisons to use for this condition. Required for a dataActionCondition.
     */
    predicates?: outputs.OutboundRulesetRuleConditionPredicate[];
    /**
     * A value associated with the property type of this Condition. Required for a contactPropertyCondition.
     */
    property?: string;
    /**
     * The type of the property associated with this Condition. Required for a contactPropertyCondition.
     */
    propertyType?: string;
    /**
     * The type of the condition.
     */
    type?: string;
    /**
     * A value associated with this Condition. This could be text, a number, or a relative time. Not used for a DataActionCondition.
     */
    value?: string;
    /**
     * The type of the value associated with this Condition. Not used for a DataActionCondition.
     */
    valueType?: string;
}

export interface OutboundRulesetRuleConditionContactColumnToDataActionFieldMapping {
    /**
     * The name of a contact column whose data will be passed to the data action
     */
    contactColumnName: string;
    /**
     * The name of an input field from the data action that the contact column data will be passed to
     */
    dataActionField: string;
}

export interface OutboundRulesetRuleConditionPredicate {
    /**
     * The value to compare against for this condition
     */
    comparisonValue: string;
    /**
     * If true, inverts the result of evaluating this Predicate. Default is false.
     */
    inverted: boolean;
    /**
     * The name of an output field from the data action's output to use for this condition
     */
    outputField: string;
    /**
     * The result of this predicate if the requested output field is missing from the data action's result
     */
    outputFieldMissingResolution: boolean;
    /**
     * The operation with which to evaluate this condition
     */
    outputOperator: string;
}

export interface OutboundSettingsAutomaticTimeZoneMapping {
    /**
     * The time intervals to use for automatic time zone mapping.
     */
    callableWindows?: outputs.OutboundSettingsAutomaticTimeZoneMappingCallableWindows;
    /**
     * The countries that are supported for automatic time zone mapping.
     */
    supportedCountries?: string[];
}

export interface OutboundSettingsAutomaticTimeZoneMappingCallableWindows {
    /**
     * The time interval to place outbound calls, for contacts that can be mapped to a time zone.
     */
    mapped?: outputs.OutboundSettingsAutomaticTimeZoneMappingCallableWindowsMapped;
    /**
     * The time interval and time zone to place outbound calls, for contacts that cannot be mapped to a time zone.
     */
    unmapped?: outputs.OutboundSettingsAutomaticTimeZoneMappingCallableWindowsUnmapped;
}

export interface OutboundSettingsAutomaticTimeZoneMappingCallableWindowsMapped {
    /**
     * The earliest time to dial a contact. Valid format is HH:mm
     */
    earliestCallableTime?: string;
    /**
     * The latest time to dial a contact. Valid format is HH:mm.
     */
    latestCallableTime?: string;
}

export interface OutboundSettingsAutomaticTimeZoneMappingCallableWindowsUnmapped {
    /**
     * The earliest time to dial a contact. Valid format is HH:mm.
     */
    earliestCallableTime?: string;
    /**
     * The latest time to dial a contact. Valid format is HH:mm.
     */
    latestCallableTime?: string;
    /**
     * The time zone to use for contacts that cannot be mapped.
     */
    timeZoneId?: string;
}

export interface OutboundWrapupcodemappingsMapping {
    /**
     * The set of wrap-up flags.
     */
    flags: string[];
    /**
     * The wrap-up code identifier.
     */
    wrapupCodeId: string;
}

export interface ProcessautomationTriggerTarget {
    /**
     * Id of the target the trigger is configured to hit
     */
    id: string;
    /**
     * Type of the target the trigger is configured to hit
     */
    type: string;
    /**
     * Optional config for the target. Until the feature gets enabled will always operate in TopLevelPrimitives mode.
     */
    workflowTargetSettings?: outputs.ProcessautomationTriggerTargetWorkflowTargetSettings;
}

export interface ProcessautomationTriggerTargetWorkflowTargetSettings {
    /**
     * The data format to use when invoking target.
     */
    dataFormat?: string;
}

export interface QualityFormsEvaluationQuestionGroup {
    /**
     * Specifies whether to default answers to highest score. Defaults to `false`.
     */
    defaultAnswersToHighest?: boolean;
    /**
     * Specifies whether to default answers to not applicable. Defaults to `false`.
     */
    defaultAnswersToNa?: boolean;
    /**
     * ID of the question group.
     */
    id: string;
    /**
     * Specifies whether a manual weight is set. Defaults to `true`.
     */
    manualWeight?: boolean;
    /**
     * Specifies whether a not applicable answer is enabled. Defaults to `false`.
     */
    naEnabled?: boolean;
    /**
     * Name of display question in question group.
     */
    name: string;
    /**
     * Questions inside the group
     */
    questions: outputs.QualityFormsEvaluationQuestionGroupQuestion[];
    /**
     * Defines conditions where question would be visible
     */
    visibilityCondition?: outputs.QualityFormsEvaluationQuestionGroupVisibilityCondition;
    /**
     * Points per question
     */
    weight: number;
}

export interface QualityFormsEvaluationQuestionGroupQuestion {
    /**
     * Options from which to choose an answer for this question.
     */
    answerOptions: outputs.QualityFormsEvaluationQuestionGroupQuestionAnswerOption[];
    /**
     * Specifies whether comments are required. Defaults to `false`.
     */
    commentsRequired?: boolean;
    /**
     * Help text for the question.
     */
    helpText?: string;
    /**
     * ID of the question.
     */
    id: string;
    /**
     * True if the question is a critical question Defaults to `false`.
     */
    isCritical?: boolean;
    /**
     * True if the question is a fatal question Defaults to `false`.
     */
    isKill?: boolean;
    /**
     * Specifies whether a not applicable answer is enabled. Defaults to `false`.
     */
    naEnabled?: boolean;
    /**
     * Individual question
     */
    text: string;
    /**
     * Defines conditions where question would be visible
     */
    visibilityCondition?: outputs.QualityFormsEvaluationQuestionGroupQuestionVisibilityCondition;
}

export interface QualityFormsEvaluationQuestionGroupQuestionAnswerOption {
    /**
     * The ID for the answer option.
     */
    id: string;
    text: string;
    value: number;
}

export interface QualityFormsEvaluationQuestionGroupQuestionVisibilityCondition {
    /**
     * Valid Values: AND, OR
     */
    combiningOperation: string;
    /**
     * A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
     */
    predicates: string[];
}

export interface QualityFormsEvaluationQuestionGroupVisibilityCondition {
    /**
     * Valid Values: AND, OR
     */
    combiningOperation: string;
    /**
     * A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
     */
    predicates: string[];
}

export interface QualityFormsSurveyQuestionGroup {
    /**
     * The ID of the survey question group.
     */
    id: string;
    /**
     * Specifies whether a not applicable answer is enabled. Defaults to `false`.
     */
    naEnabled?: boolean;
    /**
     * Name of display question in question group.
     */
    name: string;
    /**
     * Questions inside the group
     */
    questions: outputs.QualityFormsSurveyQuestionGroupQuestion[];
    /**
     * Defines conditions where question would be visible
     */
    visibilityCondition?: outputs.QualityFormsSurveyQuestionGroupVisibilityCondition;
}

export interface QualityFormsSurveyQuestionGroupQuestion {
    /**
     * Options from which to choose an answer for this question.
     */
    answerOptions?: outputs.QualityFormsSurveyQuestionGroupQuestionAnswerOption[];
    /**
     * Prompt for details explaining the chosen NPS score. Used by NPS questions.
     */
    explanationPrompt?: string;
    /**
     * Help text for the question.
     */
    helpText?: string;
    /**
     * The ID of the survey question.
     */
    id: string;
    /**
     * How many characters are allowed in the text response to this question. Used by NPS and Free Text question types.
     */
    maxResponseCharacters?: number;
    /**
     * Specifies whether a not applicable answer is enabled. Defaults to `false`.
     */
    naEnabled?: boolean;
    /**
     * Individual question
     */
    text: string;
    /**
     * Valid Values: multipleChoiceQuestion, freeTextQuestion, npsQuestion, readOnlyTextBlockQuestion Defaults to `multipleChoiceQuestion`.
     */
    type?: string;
    /**
     * Defines conditions where question would be visible
     */
    visibilityCondition?: outputs.QualityFormsSurveyQuestionGroupQuestionVisibilityCondition;
}

export interface QualityFormsSurveyQuestionGroupQuestionAnswerOption {
    /**
     * Options from which to choose an answer for this question.
     */
    assistanceConditions?: outputs.QualityFormsSurveyQuestionGroupQuestionAnswerOptionAssistanceCondition[];
    /**
     * The ID of the survey answer option.
     */
    id: string;
    text: string;
    value: number;
}

export interface QualityFormsSurveyQuestionGroupQuestionAnswerOptionAssistanceCondition {
    /**
     * List of assistance conditions which are combined together with a logical AND operator. Eg ( assistanceCondtion1 && assistanceCondition2 ) wherein assistanceCondition could be ( EXISTS topic1 || topic2 || ... ) or (NOTEXISTS topic3 || topic4 || ...).
     */
    operator: string;
    /**
     * List of topicIds within the assistance condition which would be combined together using logical OR operator. Eg ( topicId_1 || topicId_2 ) .
     */
    topicIds?: string[];
}

export interface QualityFormsSurveyQuestionGroupQuestionVisibilityCondition {
    /**
     * Valid Values: AND, OR
     */
    combiningOperation: string;
    /**
     * A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
     */
    predicates: string[];
}

export interface QualityFormsSurveyQuestionGroupVisibilityCondition {
    /**
     * Valid Values: AND, OR
     */
    combiningOperation: string;
    /**
     * A list of strings, each representing the location in the form of the Answer Option to depend on. In the format of "/form/questionGroup/{questionGroupIndex}/question/{questionIndex}/answer/{answerIndex}" or, to assume the current question group, "../question/{questionIndex}/answer/{answerIndex}". Note: Indexes are zero-based
     */
    predicates: string[];
}

export interface RecordingMediaRetentionPolicyActions {
    /**
     * true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.
     */
    alwaysDelete?: boolean;
    assignCalibrations?: outputs.RecordingMediaRetentionPolicyActionsAssignCalibration[];
    assignEvaluations?: outputs.RecordingMediaRetentionPolicyActionsAssignEvaluation[];
    assignMeteredAssignmentByAgents?: outputs.RecordingMediaRetentionPolicyActionsAssignMeteredAssignmentByAgent[];
    assignMeteredEvaluations?: outputs.RecordingMediaRetentionPolicyActionsAssignMeteredEvaluation[];
    assignSurveys?: outputs.RecordingMediaRetentionPolicyActionsAssignSurvey[];
    /**
     * true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.
     */
    deleteRecording?: boolean;
    initiateScreenRecording?: outputs.RecordingMediaRetentionPolicyActionsInitiateScreenRecording;
    /**
     * Policy action for exporting recordings using an integration to 3rd party s3.
     */
    integrationExport?: outputs.RecordingMediaRetentionPolicyActionsIntegrationExport;
    mediaTranscriptions?: outputs.RecordingMediaRetentionPolicyActionsMediaTranscription[];
    /**
     * true to retain the recording associated with the conversation.
     */
    retainRecording?: boolean;
    retentionDuration?: outputs.RecordingMediaRetentionPolicyActionsRetentionDuration;
}

export interface RecordingMediaRetentionPolicyActionsAssignCalibration {
    calibratorId?: string;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    expertEvaluatorId?: string;
}

export interface RecordingMediaRetentionPolicyActionsAssignEvaluation {
    evaluationFormId?: string;
    userId?: string;
}

export interface RecordingMediaRetentionPolicyActionsAssignMeteredAssignmentByAgent {
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyActionsAssignMeteredAssignmentByAgentTimeInterval;
    timeZone?: string;
}

export interface RecordingMediaRetentionPolicyActionsAssignMeteredAssignmentByAgentTimeInterval {
    days?: number;
    months?: number;
    weeks?: number;
}

export interface RecordingMediaRetentionPolicyActionsAssignMeteredEvaluation {
    assignToActiveUser?: boolean;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyActionsAssignMeteredEvaluationTimeInterval;
}

export interface RecordingMediaRetentionPolicyActionsAssignMeteredEvaluationTimeInterval {
    days?: number;
    hours?: number;
}

export interface RecordingMediaRetentionPolicyActionsAssignSurvey {
    /**
     * The UUID reference to the flow associated with this survey.
     */
    flowId?: string;
    /**
     * An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. Defaults to `R1/P0M`.
     */
    inviteTimeInterval?: string;
    /**
     * Validated email domain, required
     */
    sendingDomain: string;
    /**
     * User together with sendingDomain used to send email, null to use no-reply
     */
    sendingUser?: string;
    /**
     * The survey form used for this survey.
     */
    surveyFormName?: string;
}

export interface RecordingMediaRetentionPolicyActionsInitiateScreenRecording {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyActionsInitiateScreenRecordingArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyActionsInitiateScreenRecordingDeleteRetention;
    recordAcw?: boolean;
}

export interface RecordingMediaRetentionPolicyActionsInitiateScreenRecordingArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyActionsInitiateScreenRecordingDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyActionsIntegrationExport {
    /**
     * The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
     */
    integrationId?: string;
    /**
     * True if the policy should export screen recordings in addition to the other conversation media. Defaults to `true`.
     */
    shouldExportScreenRecordings?: boolean;
}

export interface RecordingMediaRetentionPolicyActionsMediaTranscription {
    displayName?: string;
    integrationId?: string;
    transcriptionProvider?: string;
}

export interface RecordingMediaRetentionPolicyActionsRetentionDuration {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyActionsRetentionDurationArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyActionsRetentionDurationDeleteRetention;
}

export interface RecordingMediaRetentionPolicyActionsRetentionDurationArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyActionsRetentionDurationDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyConditions {
    dateRanges?: string[];
    directions?: string[];
    duration?: outputs.RecordingMediaRetentionPolicyConditionsDuration;
    forQueueIds?: string[];
    forUserIds?: string[];
    mediaTypes?: string[];
    timeAllowed?: outputs.RecordingMediaRetentionPolicyConditionsTimeAllowed;
    wrapupCodeIds?: string[];
}

export interface RecordingMediaRetentionPolicyConditionsDuration {
    durationMode?: string;
    durationOperator?: string;
    durationRange?: string;
    durationTarget?: string;
}

export interface RecordingMediaRetentionPolicyConditionsTimeAllowed {
    empty?: boolean;
    timeSlots?: outputs.RecordingMediaRetentionPolicyConditionsTimeAllowedTimeSlot[];
    timeZoneId?: string;
}

export interface RecordingMediaRetentionPolicyConditionsTimeAllowedTimeSlot {
    /**
     * Day for this time slot, Monday = 1 ... Sunday = 7
     */
    day?: number;
    /**
     * start time in xx:xx:xx.xxx format
     */
    startTime?: string;
    /**
     * stop time in xx:xx:xx.xxx format
     */
    stopTime?: string;
}

export interface RecordingMediaRetentionPolicyMediaPolicies {
    /**
     * Conditions and actions for calls
     */
    callPolicy?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicy;
    /**
     * Conditions and actions for calls
     */
    chatPolicy?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicy;
    /**
     * Conditions and actions for calls
     */
    emailPolicy?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicy;
    /**
     * Conditions and actions for calls
     */
    messagePolicy?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicy;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicy {
    /**
     * Actions applied when specified conditions are met
     */
    actions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActions;
    /**
     * Conditions for when actions should be applied
     */
    conditions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditions;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActions {
    /**
     * true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.
     */
    alwaysDelete?: boolean;
    assignCalibrations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignCalibration[];
    assignEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignEvaluation[];
    assignMeteredAssignmentByAgents?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredAssignmentByAgent[];
    assignMeteredEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredEvaluation[];
    assignSurveys?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignSurvey[];
    /**
     * true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.
     */
    deleteRecording?: boolean;
    initiateScreenRecording?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecording;
    /**
     * Policy action for exporting recordings using an integration to 3rd party s3.
     */
    integrationExport?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsIntegrationExport;
    mediaTranscriptions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsMediaTranscription[];
    /**
     * true to retain the recording associated with the conversation.
     */
    retainRecording?: boolean;
    retentionDuration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDuration;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignCalibration {
    calibratorId?: string;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    expertEvaluatorId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignEvaluation {
    evaluationFormId?: string;
    userId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredAssignmentByAgent {
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredAssignmentByAgentTimeInterval;
    timeZone?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredAssignmentByAgentTimeInterval {
    days?: number;
    months?: number;
    weeks?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredEvaluation {
    assignToActiveUser?: boolean;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredEvaluationTimeInterval;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignMeteredEvaluationTimeInterval {
    days?: number;
    hours?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsAssignSurvey {
    /**
     * The UUID reference to the flow associated with this survey.
     */
    flowId?: string;
    /**
     * An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. Defaults to `R1/P0M`.
     */
    inviteTimeInterval?: string;
    /**
     * Validated email domain, required
     */
    sendingDomain: string;
    /**
     * User together with sendingDomain used to send email, null to use no-reply
     */
    sendingUser?: string;
    /**
     * The survey form used for this survey.
     */
    surveyFormName?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecording {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecordingArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecordingDeleteRetention;
    recordAcw?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecordingArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsInitiateScreenRecordingDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsIntegrationExport {
    /**
     * The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
     */
    integrationId?: string;
    /**
     * True if the policy should export screen recordings in addition to the other conversation media. Defaults to `true`.
     */
    shouldExportScreenRecordings?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsMediaTranscription {
    displayName?: string;
    integrationId?: string;
    transcriptionProvider?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDuration {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDurationArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDurationDeleteRetention;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDurationArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyActionsRetentionDurationDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditions {
    dateRanges?: string[];
    directions?: string[];
    duration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsDuration;
    forQueueIds?: string[];
    forUserIds?: string[];
    languageIds?: string[];
    timeAllowed?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsTimeAllowed;
    wrapupCodeIds?: string[];
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsDuration {
    durationMode?: string;
    durationOperator?: string;
    durationRange?: string;
    durationTarget?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsTimeAllowed {
    empty?: boolean;
    timeSlots?: outputs.RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsTimeAllowedTimeSlot[];
    timeZoneId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesCallPolicyConditionsTimeAllowedTimeSlot {
    /**
     * Day for this time slot, Monday = 1 ... Sunday = 7
     */
    day?: number;
    /**
     * start time in xx:xx:xx.xxx format
     */
    startTime?: string;
    /**
     * stop time in xx:xx:xx.xxx format
     */
    stopTime?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicy {
    /**
     * Actions applied when specified conditions are met
     */
    actions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActions;
    /**
     * Conditions for when actions should be applied
     */
    conditions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditions;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActions {
    /**
     * true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.
     */
    alwaysDelete?: boolean;
    assignCalibrations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignCalibration[];
    assignEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignEvaluation[];
    assignMeteredAssignmentByAgents?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredAssignmentByAgent[];
    assignMeteredEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredEvaluation[];
    assignSurveys?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignSurvey[];
    /**
     * true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.
     */
    deleteRecording?: boolean;
    initiateScreenRecording?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecording;
    /**
     * Policy action for exporting recordings using an integration to 3rd party s3.
     */
    integrationExport?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsIntegrationExport;
    mediaTranscriptions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsMediaTranscription[];
    /**
     * true to retain the recording associated with the conversation.
     */
    retainRecording?: boolean;
    retentionDuration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDuration;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignCalibration {
    calibratorId?: string;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    expertEvaluatorId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignEvaluation {
    evaluationFormId?: string;
    userId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredAssignmentByAgent {
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredAssignmentByAgentTimeInterval;
    timeZone?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredAssignmentByAgentTimeInterval {
    days?: number;
    months?: number;
    weeks?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredEvaluation {
    assignToActiveUser?: boolean;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredEvaluationTimeInterval;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignMeteredEvaluationTimeInterval {
    days?: number;
    hours?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsAssignSurvey {
    /**
     * The UUID reference to the flow associated with this survey.
     */
    flowId?: string;
    /**
     * An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. Defaults to `R1/P0M`.
     */
    inviteTimeInterval?: string;
    /**
     * Validated email domain, required
     */
    sendingDomain: string;
    /**
     * User together with sendingDomain used to send email, null to use no-reply
     */
    sendingUser?: string;
    /**
     * The survey form used for this survey.
     */
    surveyFormName?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecording {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecordingArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecordingDeleteRetention;
    recordAcw?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecordingArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsInitiateScreenRecordingDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsIntegrationExport {
    /**
     * The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
     */
    integrationId?: string;
    /**
     * True if the policy should export screen recordings in addition to the other conversation media. Defaults to `true`.
     */
    shouldExportScreenRecordings?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsMediaTranscription {
    displayName?: string;
    integrationId?: string;
    transcriptionProvider?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDuration {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDurationArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDurationDeleteRetention;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDurationArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyActionsRetentionDurationDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditions {
    dateRanges?: string[];
    duration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsDuration;
    forQueueIds?: string[];
    forUserIds?: string[];
    languageIds?: string[];
    timeAllowed?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsTimeAllowed;
    wrapupCodeIds?: string[];
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsDuration {
    durationMode?: string;
    durationOperator?: string;
    durationRange?: string;
    durationTarget?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsTimeAllowed {
    empty?: boolean;
    timeSlots?: outputs.RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsTimeAllowedTimeSlot[];
    timeZoneId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesChatPolicyConditionsTimeAllowedTimeSlot {
    /**
     * Day for this time slot, Monday = 1 ... Sunday = 7
     */
    day?: number;
    /**
     * start time in xx:xx:xx.xxx format
     */
    startTime?: string;
    /**
     * stop time in xx:xx:xx.xxx format
     */
    stopTime?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicy {
    /**
     * Actions applied when specified conditions are met
     */
    actions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActions;
    /**
     * Conditions for when actions should be applied
     */
    conditions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditions;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActions {
    /**
     * true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.
     */
    alwaysDelete?: boolean;
    assignCalibrations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignCalibration[];
    assignEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignEvaluation[];
    assignMeteredAssignmentByAgents?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredAssignmentByAgent[];
    assignMeteredEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredEvaluation[];
    assignSurveys?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignSurvey[];
    /**
     * true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.
     */
    deleteRecording?: boolean;
    initiateScreenRecording?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecording;
    /**
     * Policy action for exporting recordings using an integration to 3rd party s3.
     */
    integrationExport?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsIntegrationExport;
    mediaTranscriptions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsMediaTranscription[];
    /**
     * true to retain the recording associated with the conversation.
     */
    retainRecording?: boolean;
    retentionDuration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDuration;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignCalibration {
    calibratorId?: string;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    expertEvaluatorId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignEvaluation {
    evaluationFormId?: string;
    userId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredAssignmentByAgent {
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredAssignmentByAgentTimeInterval;
    timeZone?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredAssignmentByAgentTimeInterval {
    days?: number;
    months?: number;
    weeks?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredEvaluation {
    assignToActiveUser?: boolean;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredEvaluationTimeInterval;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignMeteredEvaluationTimeInterval {
    days?: number;
    hours?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsAssignSurvey {
    /**
     * The UUID reference to the flow associated with this survey.
     */
    flowId?: string;
    /**
     * An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. Defaults to `R1/P0M`.
     */
    inviteTimeInterval?: string;
    /**
     * Validated email domain, required
     */
    sendingDomain: string;
    /**
     * User together with sendingDomain used to send email, null to use no-reply
     */
    sendingUser?: string;
    /**
     * The survey form used for this survey.
     */
    surveyFormName?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecording {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecordingArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecordingDeleteRetention;
    recordAcw?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecordingArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsInitiateScreenRecordingDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsIntegrationExport {
    /**
     * The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
     */
    integrationId?: string;
    /**
     * True if the policy should export screen recordings in addition to the other conversation media. Defaults to `true`.
     */
    shouldExportScreenRecordings?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsMediaTranscription {
    displayName?: string;
    integrationId?: string;
    transcriptionProvider?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDuration {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDurationArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDurationDeleteRetention;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDurationArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyActionsRetentionDurationDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditions {
    dateRanges?: string[];
    forQueueIds?: string[];
    forUserIds?: string[];
    languageIds?: string[];
    timeAllowed?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditionsTimeAllowed;
    wrapupCodeIds?: string[];
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditionsTimeAllowed {
    empty?: boolean;
    timeSlots?: outputs.RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditionsTimeAllowedTimeSlot[];
    timeZoneId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesEmailPolicyConditionsTimeAllowedTimeSlot {
    /**
     * Day for this time slot, Monday = 1 ... Sunday = 7
     */
    day?: number;
    /**
     * start time in xx:xx:xx.xxx format
     */
    startTime?: string;
    /**
     * stop time in xx:xx:xx.xxx format
     */
    stopTime?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicy {
    /**
     * Actions applied when specified conditions are met
     */
    actions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActions;
    /**
     * Conditions for when actions should be applied
     */
    conditions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditions;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActions {
    /**
     * true to delete the recording associated with the conversation regardless of the values of retainRecording or deleteRecording.
     */
    alwaysDelete?: boolean;
    assignCalibrations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignCalibration[];
    assignEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignEvaluation[];
    assignMeteredAssignmentByAgents?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredAssignmentByAgent[];
    assignMeteredEvaluations?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredEvaluation[];
    assignSurveys?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignSurvey[];
    /**
     * true to delete the recording associated with the conversation. If retainRecording = true, this will be ignored.
     */
    deleteRecording?: boolean;
    initiateScreenRecording?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecording;
    /**
     * Policy action for exporting recordings using an integration to 3rd party s3.
     */
    integrationExport?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsIntegrationExport;
    mediaTranscriptions?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsMediaTranscription[];
    /**
     * true to retain the recording associated with the conversation.
     */
    retainRecording?: boolean;
    retentionDuration?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDuration;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignCalibration {
    calibratorId?: string;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    expertEvaluatorId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignEvaluation {
    evaluationFormId?: string;
    userId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredAssignmentByAgent {
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredAssignmentByAgentTimeInterval;
    timeZone?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredAssignmentByAgentTimeInterval {
    days?: number;
    months?: number;
    weeks?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredEvaluation {
    assignToActiveUser?: boolean;
    evaluationFormId?: string;
    evaluatorIds?: string[];
    maxNumberEvaluations?: number;
    timeInterval?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredEvaluationTimeInterval;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignMeteredEvaluationTimeInterval {
    days?: number;
    hours?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsAssignSurvey {
    /**
     * The UUID reference to the flow associated with this survey.
     */
    flowId?: string;
    /**
     * An ISO 8601 repeated interval consisting of the number of repetitions, the start datetime, and the interval (e.g. R2/2018-03-01T13:00:00Z/P1M10DT2H30M). Total duration must not exceed 90 days. Defaults to `R1/P0M`.
     */
    inviteTimeInterval?: string;
    /**
     * Validated email domain, required
     */
    sendingDomain: string;
    /**
     * User together with sendingDomain used to send email, null to use no-reply
     */
    sendingUser?: string;
    /**
     * The survey form used for this survey.
     */
    surveyFormName?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecording {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecordingArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecordingDeleteRetention;
    recordAcw?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecordingArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsInitiateScreenRecordingDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsIntegrationExport {
    /**
     * The aws-s3-recording-bulk-actions-integration that the policy uses for exports.
     */
    integrationId?: string;
    /**
     * True if the policy should export screen recordings in addition to the other conversation media. Defaults to `true`.
     */
    shouldExportScreenRecordings?: boolean;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsMediaTranscription {
    displayName?: string;
    integrationId?: string;
    transcriptionProvider?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDuration {
    archiveRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDurationArchiveRetention;
    deleteRetention?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDurationDeleteRetention;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDurationArchiveRetention {
    days?: number;
    storageMedium?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyActionsRetentionDurationDeleteRetention {
    days?: number;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditions {
    dateRanges?: string[];
    forQueueIds?: string[];
    forUserIds?: string[];
    languageIds?: string[];
    timeAllowed?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditionsTimeAllowed;
    wrapupCodeIds?: string[];
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditionsTimeAllowed {
    empty?: boolean;
    timeSlots?: outputs.RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditionsTimeAllowedTimeSlot[];
    timeZoneId?: string;
}

export interface RecordingMediaRetentionPolicyMediaPoliciesMessagePolicyConditionsTimeAllowedTimeSlot {
    /**
     * Day for this time slot, Monday = 1 ... Sunday = 7
     */
    day?: number;
    /**
     * start time in xx:xx:xx.xxx format
     */
    startTime?: string;
    /**
     * stop time in xx:xx:xx.xxx format
     */
    stopTime?: string;
}

export interface RecordingMediaRetentionPolicyPolicyErrors {
    policyErrorMessages?: outputs.RecordingMediaRetentionPolicyPolicyErrorsPolicyErrorMessage[];
}

export interface RecordingMediaRetentionPolicyPolicyErrorsPolicyErrorMessage {
    correlationId?: string;
    errorCode?: string;
    /**
     * Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
     */
    insertDate?: string;
    statusCode?: number;
    userMessage?: {[key: string]: string};
    userParams?: outputs.RecordingMediaRetentionPolicyPolicyErrorsPolicyErrorMessageUserParam[];
    userParamsMessage?: string;
}

export interface RecordingMediaRetentionPolicyPolicyErrorsPolicyErrorMessageUserParam {
    key?: string;
    value?: string;
}

export interface ResponsemanagementResponseFooter {
    /**
     * Specifies the canned response template where the footer can be used.Valid values: Campaign.
     */
    applicableResources?: string[];
    /**
     * Specifies the type represented by Footer.Valid values: Signature.
     */
    type?: string;
}

export interface ResponsemanagementResponseMessagingTemplate {
    /**
     * Defines a messaging template for a WhatsApp messaging channel
     */
    whatsApp?: outputs.ResponsemanagementResponseMessagingTemplateWhatsApp;
}

export interface ResponsemanagementResponseMessagingTemplateWhatsApp {
    /**
     * The messaging template language configured for this template. This is a WhatsApp specific value. For example, 'en_US'
     */
    language: string;
    /**
     * The messaging template name.
     */
    name: string;
    /**
     * The messaging template namespace.
     */
    namespace: string;
}

export interface ResponsemanagementResponseSubstitution {
    /**
     * Response substitution default value.
     */
    defaultValue?: string;
    /**
     * Response substitution description.
     */
    description?: string;
    /**
     * Response substitution identifier.
     */
    id: string;
}

export interface ResponsemanagementResponseText {
    /**
     * Response text content.
     */
    content: string;
    /**
     * Response text content type.
     */
    contentType?: string;
}

export interface RoutingEmailRouteAutoBcc {
    /**
     * Email address.
     */
    email: string;
    /**
     * Name associated with the email.
     */
    name?: string;
}

export interface RoutingEmailRouteReplyEmailAddress {
    /**
     * Domain of the route.
     */
    domainId: string;
    /**
     * ID of the route.
     */
    routeId?: string;
    /**
     * Use this route as the reply email address. If true you will use the route id for this resource as the reply and you
     * 							              can not set a route. If you set this value to false (or leave the attribute off)you must set a route id. Defaults to `false`.
     */
    selfReferenceRoute?: boolean;
}

export interface RoutingQueueAgentOwnedRouting {
    /**
     * Enable Agent Owned Callbacks
     */
    enableAgentOwnedCallbacks: boolean;
    /**
     * Max Owned Call Back Delay Hours >= 7
     */
    maxOwnedCallbackDelayHours: number;
    /**
     * Auto End Delay Seconds Must be >= 7
     */
    maxOwnedCallbackHours: number;
}

export interface RoutingQueueBullseyeRing {
    /**
     * Seconds to wait in this ring before moving to the next.
     */
    expansionTimeoutSeconds: number;
    memberGroups?: outputs.RoutingQueueBullseyeRingMemberGroup[];
    /**
     * Skill IDs to remove on ring exit.
     */
    skillsToRemoves?: string[];
}

export interface RoutingQueueBullseyeRingMemberGroup {
    /**
     * ID (GUID) for Group, SkillGroup, Team
     */
    memberGroupId: string;
    /**
     * The type of the member group. Accepted values: TEAM, GROUP, SKILLGROUP
     */
    memberGroupType: string;
}

export interface RoutingQueueConditionalGroupRoutingRule {
    /**
     * The limit value, beyond which a rule evaluates as true.
     */
    conditionValue: number;
    /**
     * The queue being evaluated for this rule. For rule 1, this is always the current queue, so should not be specified.
     */
    evaluatedQueueId?: string;
    /**
     * The group(s) to activate if the rule evaluates as true.
     */
    groups: outputs.RoutingQueueConditionalGroupRoutingRuleGroup[];
    /**
     * The queue metric being evaluated. Valid values: EstimatedWaitTime, ServiceLevel. Defaults to `EstimatedWaitTime`.
     */
    metric?: string;
    /**
     * The operator that compares the actual value against the condition value. Valid values: GreaterThan, GreaterThanOrEqualTo, LessThan, LessThanOrEqualTo.
     */
    operator: string;
    /**
     * The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule. For the final rule, this is ignored, so need not be specified. Defaults to `2`.
     */
    waitSeconds?: number;
}

export interface RoutingQueueConditionalGroupRoutingRuleGroup {
    /**
     * ID (GUID) for Group, SkillGroup, Team
     */
    memberGroupId: string;
    /**
     * The type of the member group. Accepted values: TEAM, GROUP, SKILLGROUP
     */
    memberGroupType: string;
}

export interface RoutingQueueDirectRouting {
    /**
     * The queue default time a Direct Routing interaction will wait for an agent before it goes to configured backup. Defaults to `60`.
     */
    agentWaitSeconds?: number;
    /**
     * Direct Routing default backup queue id (if none supplied this queue will be used as backup).
     */
    backupQueueId: string;
    /**
     * Boolean indicating if user Direct Routing addresses should be used outbound on behalf of queue in place of Queue address for calls. Defaults to `true`.
     */
    callUseAgentAddressOutbound?: boolean;
    /**
     * Boolean indicating if user Direct Routing addresses should be used outbound on behalf of queue in place of Queue address for emails. Defaults to `true`.
     */
    emailUseAgentAddressOutbound?: boolean;
    /**
     * Boolean indicating if user Direct Routing addresses should be used outbound on behalf of queue in place of Queue address for messages. Defaults to `true`.
     */
    messageUseAgentAddressOutbound?: boolean;
    /**
     * Boolean indicating if Direct Routing interactions should wait for the targeted agent by default. Defaults to `false`.
     */
    waitForAgent?: boolean;
}

export interface RoutingQueueMediaSettingsCall {
    /**
     * Alerting timeout in seconds. Must be >= 7
     */
    alertingTimeoutSec: number;
    /**
     * Auto Dial Delay Seconds.
     */
    autoDialDelaySeconds?: number;
    /**
     * Auto End Delay Seconds.
     */
    autoEndDelaySeconds?: number;
    /**
     * Auto-Answer for digital channels(Email, Message) Defaults to `false`.
     */
    enableAutoAnswer?: boolean;
    /**
     * Auto Dail and End Defaults to `false`.
     */
    enableAutoDialAndEnd?: boolean;
    /**
     * Service Level target in milliseconds. Must be >= 1000
     */
    serviceLevelDurationMs: number;
    /**
     * The desired Service Level. A float value between 0 and 1.
     */
    serviceLevelPercentage: number;
}

export interface RoutingQueueMediaSettingsCallback {
    /**
     * Alerting timeout in seconds. Must be >= 7
     */
    alertingTimeoutSec: number;
    /**
     * Auto Dial Delay Seconds.
     */
    autoDialDelaySeconds?: number;
    /**
     * Auto End Delay Seconds.
     */
    autoEndDelaySeconds?: number;
    /**
     * Auto-Answer for digital channels(Email, Message) Defaults to `false`.
     */
    enableAutoAnswer?: boolean;
    /**
     * Auto Dail and End Defaults to `false`.
     */
    enableAutoDialAndEnd?: boolean;
    /**
     * Service Level target in milliseconds. Must be >= 1000
     */
    serviceLevelDurationMs: number;
    /**
     * The desired Service Level. A float value between 0 and 1.
     */
    serviceLevelPercentage: number;
}

export interface RoutingQueueMediaSettingsChat {
    /**
     * Alerting timeout in seconds. Must be >= 7
     */
    alertingTimeoutSec: number;
    /**
     * Auto Dial Delay Seconds.
     */
    autoDialDelaySeconds?: number;
    /**
     * Auto End Delay Seconds.
     */
    autoEndDelaySeconds?: number;
    /**
     * Auto-Answer for digital channels(Email, Message) Defaults to `false`.
     */
    enableAutoAnswer?: boolean;
    /**
     * Auto Dail and End Defaults to `false`.
     */
    enableAutoDialAndEnd?: boolean;
    /**
     * Service Level target in milliseconds. Must be >= 1000
     */
    serviceLevelDurationMs: number;
    /**
     * The desired Service Level. A float value between 0 and 1.
     */
    serviceLevelPercentage: number;
}

export interface RoutingQueueMediaSettingsEmail {
    /**
     * Alerting timeout in seconds. Must be >= 7
     */
    alertingTimeoutSec: number;
    /**
     * Auto Dial Delay Seconds.
     */
    autoDialDelaySeconds?: number;
    /**
     * Auto End Delay Seconds.
     */
    autoEndDelaySeconds?: number;
    /**
     * Auto-Answer for digital channels(Email, Message) Defaults to `false`.
     */
    enableAutoAnswer?: boolean;
    /**
     * Auto Dail and End Defaults to `false`.
     */
    enableAutoDialAndEnd?: boolean;
    /**
     * Service Level target in milliseconds. Must be >= 1000
     */
    serviceLevelDurationMs: number;
    /**
     * The desired Service Level. A float value between 0 and 1.
     */
    serviceLevelPercentage: number;
}

export interface RoutingQueueMediaSettingsMessage {
    /**
     * Alerting timeout in seconds. Must be >= 7
     */
    alertingTimeoutSec: number;
    /**
     * Auto Dial Delay Seconds.
     */
    autoDialDelaySeconds?: number;
    /**
     * Auto End Delay Seconds.
     */
    autoEndDelaySeconds?: number;
    /**
     * Auto-Answer for digital channels(Email, Message) Defaults to `false`.
     */
    enableAutoAnswer?: boolean;
    /**
     * Auto Dail and End Defaults to `false`.
     */
    enableAutoDialAndEnd?: boolean;
    /**
     * Service Level target in milliseconds. Must be >= 1000
     */
    serviceLevelDurationMs: number;
    /**
     * The desired Service Level. A float value between 0 and 1.
     */
    serviceLevelPercentage: number;
}

export interface RoutingQueueMember {
    ringNum: number;
    userId: string;
}

export interface RoutingQueueOutboundEmailAddress {
    /**
     * Unique ID of the email domain. e.g. "test.example.com"
     */
    domainId: string;
    /**
     * Unique ID of the email route.
     */
    routeId: string;
}

export interface RoutingQueueRoutingRule {
    /**
     * Matching operator (MEETS_THRESHOLD | ANY). MEETS_THRESHOLD matches any agent with a score at or above the rule's threshold. ANY matches all specified agents, regardless of score. Defaults to `MEETS_THRESHOLD`.
     */
    operator?: string;
    /**
     * Threshold required for routing attempt (generally an agent score). Ignored for operator ANY.
     */
    threshold?: number;
    /**
     * Seconds to wait in this rule before moving to the next. Defaults to `5`.
     */
    waitSeconds?: number;
}

export interface RoutingSettingsContactcenter {
    /**
     * Strip skills from transfer
     */
    removeSkillsFromBlindTransfer?: boolean;
}

export interface RoutingSettingsTranscription {
    /**
     * Setting to enable/disable content search
     */
    contentSearchEnabled?: boolean;
    /**
     * Boolean flag indicating whether low latency transcription via Notification API is enabled
     */
    lowLatencyTranscriptionEnabled?: boolean;
    /**
     * Setting to enable/disable PCI DSS Redaction
     */
    pciDssRedactionEnabled?: boolean;
    /**
     * Setting to enable/disable PII Redaction
     */
    piiRedactionEnabled?: boolean;
    /**
     * Setting to enable/disable transcription capability.Valid values: Disabled, EnabledGlobally, EnabledQueueFlow
     */
    transcription?: string;
    /**
     * Configure confidence threshold. The possible values are from 1 to 100
     */
    transcriptionConfidenceThreshold?: number;
}

export interface RoutingUtilizationCall {
    /**
     * Block this media type when on a non-ACD conversation. Defaults to `false`.
     */
    includeNonAcd?: boolean;
    /**
     * Set of other media types that can interrupt this media type (call | callback | chat | email | message).
     */
    interruptibleMediaTypes?: string[];
    /**
     * Maximum capacity of conversations of this media type. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationCallback {
    /**
     * Block this media type when on a non-ACD conversation. Defaults to `false`.
     */
    includeNonAcd?: boolean;
    /**
     * Set of other media types that can interrupt this media type (call | callback | chat | email | message).
     */
    interruptibleMediaTypes?: string[];
    /**
     * Maximum capacity of conversations of this media type. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationChat {
    /**
     * Block this media type when on a non-ACD conversation. Defaults to `false`.
     */
    includeNonAcd?: boolean;
    /**
     * Set of other media types that can interrupt this media type (call | callback | chat | email | message).
     */
    interruptibleMediaTypes?: string[];
    /**
     * Maximum capacity of conversations of this media type. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationEmail {
    /**
     * Block this media type when on a non-ACD conversation. Defaults to `false`.
     */
    includeNonAcd?: boolean;
    /**
     * Set of other media types that can interrupt this media type (call | callback | chat | email | message).
     */
    interruptibleMediaTypes?: string[];
    /**
     * Maximum capacity of conversations of this media type. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationLabelUtilization {
    /**
     * Set of other labels that can interrupt this label.
     */
    interruptingLabelIds?: string[];
    /**
     * Id of the label being configured.
     */
    labelId: string;
    /**
     * Maximum capacity of conversations with this label. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationMessage {
    /**
     * Block this media type when on a non-ACD conversation. Defaults to `false`.
     */
    includeNonAcd?: boolean;
    /**
     * Set of other media types that can interrupt this media type (call | callback | chat | email | message).
     */
    interruptibleMediaTypes?: string[];
    /**
     * Maximum capacity of conversations of this media type. Value must be between 0 and 25.
     */
    maximumCapacity: number;
}

export interface RoutingUtilizationTimeouts {
    read?: string;
    update?: string;
}

export interface TaskManagementWorkitemScoredAgent {
    /**
     * The agent id
     */
    agentId: string;
    /**
     * Agent's score for the workitem, from 0 - 100, higher being better
     */
    score: number;
}

export interface TelephonyProvidersEdgesPhoneCapabilities {
    /**
     * Allow Reboot
     */
    allowReboot?: boolean;
    /**
     * CDM
     */
    cdm?: boolean;
    /**
     * Dual Registers
     */
    dualRegisters?: boolean;
    /**
     * HardwareId Type
     */
    hardwareIdType?: string;
    /**
     * Media Codecs
     */
    mediaCodecs?: string[];
    /**
     * No Cloud Provisioning
     */
    noCloudProvisioning?: boolean;
    /**
     * No Rebalance
     */
    noRebalance?: boolean;
    /**
     * Provisions
     */
    provisions?: boolean;
    /**
     * Registers
     */
    registers?: boolean;
}

export interface TelephonyProvidersEdgesPhoneLineProperties {
    /**
     * DID for standalone phones. Each phone number must be in an E.164 phone number format.
     */
    lineAddresses: string[];
    /**
     * Station remote property for phones. No validation is provided
     */
    remoteAddresses?: string[];
}

export interface TelephonyProvidersEdgesPhonebasesettingsCapabilities {
    /**
     * Allow Reboot
     */
    allowReboot?: boolean;
    /**
     * CDM
     */
    cdm?: boolean;
    /**
     * Dual Registers
     */
    dualRegisters?: boolean;
    /**
     * HardwareId Type
     */
    hardwareIdType?: string;
    /**
     * Media Codecs
     */
    mediaCodecs?: string[];
    /**
     * No Cloud Provisioning
     */
    noCloudProvisioning?: boolean;
    /**
     * No Rebalance
     */
    noRebalance?: boolean;
    /**
     * Provisions
     */
    provisions?: boolean;
    /**
     * Registers
     */
    registers?: boolean;
}

export interface TelephonyProvidersEdgesSiteEdgeAutoUpdateConfig {
    /**
     * Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS
     */
    end: string;
    /**
     * A reoccurring rule for updating the Edges assigned to the site. The only supported frequencies are daily and weekly. Weekly frequencies require a day list with at least oneday specified. All other configurations are not supported.
     */
    rrule: string;
    /**
     * Date time is represented as an ISO-8601 string without a timezone. For example: yyyy-MM-ddTHH:mm:ss.SSS
     */
    start: string;
    /**
     * The timezone of the window in which any updates to the edges assigned to the site can be applied. The minimum size of the window is 2 hours.
     */
    timeZone: string;
}

export interface TelephonyProvidersEdgesSiteNumberPlan {
    /**
     * Used to classify this number plan
     */
    classification: string;
    /**
     * Allowed values are between 1-20 digits.
     */
    digitLength?: outputs.TelephonyProvidersEdgesSiteNumberPlanDigitLength;
    /**
     * Use regular expression capture groups to build the normalized number
     */
    matchFormat?: string;
    matchType: string;
    /**
     * The name of the entity.
     */
    name: string;
    /**
     * Use regular expression capture groups to build the normalized number
     */
    normalizedFormat?: string;
    /**
     * Numbers must be 2-9 digits long. Numbers within ranges must be the same length. (e.g. 888, 888-999, 55555-77777, 800).
     */
    numbers?: outputs.TelephonyProvidersEdgesSiteNumberPlanNumber[];
}

export interface TelephonyProvidersEdgesSiteNumberPlanDigitLength {
    end?: string;
    start?: string;
}

export interface TelephonyProvidersEdgesSiteNumberPlanNumber {
    end?: string;
    start?: string;
}

export interface TelephonyProvidersEdgesSiteOutboundRoute {
    classificationTypes: string[];
    description: string;
    distribution: string;
    enabled: boolean;
    externalTrunkBaseIds: string[];
    name: string;
}

export interface TelephonyProvidersEdgesSiteOutboundRouteOutboundRoute {
    classificationTypes: string[];
    description: string;
    distribution: string;
    enabled: boolean;
    externalTrunkBaseIds: string[];
    name: string;
}

export interface UserAddress {
    otherEmails: outputs.UserAddressOtherEmail[];
    phoneNumbers: outputs.UserAddressPhoneNumber[];
}

export interface UserAddressOtherEmail {
    address: string;
    type: string;
}

export interface UserAddressPhoneNumber {
    extension: string;
    mediaType: string;
    number: string;
    type: string;
}

export interface UserEmployerInfo {
    dateHire: string;
    employeeId: string;
    employeeType: string;
    officialName: string;
}

export interface UserLocation {
    locationId: string;
    notes: string;
}

export interface UserRolesRole {
    /**
     * Division IDs applied to this resource. If not set, the home division will be used. '*' may be set for all divisions.
     */
    divisionIds?: string[];
    /**
     * Role ID.
     */
    roleId: string;
}

export interface UserRoutingLanguage {
    languageId: string;
    proficiency: number;
}

export interface UserRoutingSkill {
    proficiency: number;
    skillId: string;
}

export interface UserRoutingUtilization {
    callbacks: outputs.UserRoutingUtilizationCallback[];
    calls: outputs.UserRoutingUtilizationCall[];
    chats: outputs.UserRoutingUtilizationChat[];
    emails: outputs.UserRoutingUtilizationEmail[];
    labelUtilizations: outputs.UserRoutingUtilizationLabelUtilization[];
    messages: outputs.UserRoutingUtilizationMessage[];
}

export interface UserRoutingUtilizationCall {
    includeNonAcd: boolean;
    interruptibleMediaTypes: string[];
    maximumCapacity: number;
}

export interface UserRoutingUtilizationCallback {
    includeNonAcd: boolean;
    interruptibleMediaTypes: string[];
    maximumCapacity: number;
}

export interface UserRoutingUtilizationChat {
    includeNonAcd: boolean;
    interruptibleMediaTypes: string[];
    maximumCapacity: number;
}

export interface UserRoutingUtilizationEmail {
    includeNonAcd: boolean;
    interruptibleMediaTypes: string[];
    maximumCapacity: number;
}

export interface UserRoutingUtilizationLabelUtilization {
    interruptingLabelIds: string[];
    labelId: string;
    maximumCapacity: number;
}

export interface UserRoutingUtilizationMessage {
    includeNonAcd: boolean;
    interruptibleMediaTypes: string[];
    maximumCapacity: number;
}

export interface WebdeploymentsConfigurationAuthenticationSettings {
    /**
     * Indicate if these auth is required for this deployment. If, for example, this flag is set to true then webmessaging sessions can not send messages unless the end-user is authenticated.
     */
    enabled: boolean;
    /**
     * The integration identifier which contains the auth settings required on the deployment.
     */
    integrationId: string;
}

export interface WebdeploymentsConfigurationCobrowse {
    /**
     * Whether agent can take control over customer's screen or not
     */
    allowAgentControl: boolean;
    /**
     * Whether agent can use navigation feature over customer's screen or not
     */
    allowAgentNavigation: boolean;
    /**
     * List of channels through which cobrowse is available (for now only Webmessaging and Voice)
     */
    channels?: string[];
    /**
     * Whether or not cobrowse is enabled
     */
    enabled: boolean;
    /**
     * List of CSS selectors which should be masked when screen sharing is active
     */
    maskSelectors?: string[];
    /**
     * Pause criteria that will pause cobrowse if some of them are met in the user's URL
     */
    pauseCriterias?: outputs.WebdeploymentsConfigurationCobrowsePauseCriteria[];
    /**
     * List of CSS selectors which should be read-only when screen sharing is active
     */
    readonlySelectors?: string[];
}

export interface WebdeploymentsConfigurationCobrowsePauseCriteria {
    /**
     * The condition to be applied to the `url_fragment`. Conditions are 'includes', 'does_not_include', 'starts_with', 'ends_with', 'equals'
     */
    condition: string;
    /**
     * A string representing a part of the URL that, when matched according to the specified condition, will trigger a pause in the cobrowse session
     */
    urlFragment: string;
}

export interface WebdeploymentsConfigurationCustomI18nLabel {
    /**
     * Language of localized labels in homescreen app (eg. en-us, de-de)
     */
    language?: string;
    /**
     * Contains localized labels used in homescreen app
     */
    localizedLabels?: outputs.WebdeploymentsConfigurationCustomI18nLabelLocalizedLabel[];
}

export interface WebdeploymentsConfigurationCustomI18nLabelLocalizedLabel {
    /**
     * Contains localized label key used in messenger homescreen
     */
    key: string;
    /**
     * Contains localized label value used in messenger homescreen
     */
    value: string;
}

export interface WebdeploymentsConfigurationJourneyEvents {
    /**
     * Details about a selector event trigger
     */
    clickEvents?: outputs.WebdeploymentsConfigurationJourneyEventsClickEvent[];
    /**
     * Whether or not journey event collection is enabled Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * List of parameters to be excluded from the query string
     */
    excludedQueryParameters?: string[];
    /**
     * Details about a forms tracking event trigger
     */
    formTrackEvents?: outputs.WebdeploymentsConfigurationJourneyEventsFormTrackEvent[];
    /**
     * Details about an idle event trigger
     */
    idleEvents?: outputs.WebdeploymentsConfigurationJourneyEventsIdleEvent[];
    /**
     * Details about a selector event trigger
     */
    inViewportEvents?: outputs.WebdeploymentsConfigurationJourneyEventsInViewportEvent[];
    /**
     * Controls how the pageview events are tracked.Valid values: Auto, Once, Off
     */
    pageviewConfig?: string;
    /**
     * Details about a scroll percentage event trigger
     */
    scrollDepthEvents?: outputs.WebdeploymentsConfigurationJourneyEventsScrollDepthEvent[];
    /**
     * List of query parameters used for search (e.g. 'q')
     */
    searchQueryParameters?: string[];
    /**
     * Whether or not to keep the URL fragment
     */
    shouldKeepUrlFragment?: boolean;
}

export interface WebdeploymentsConfigurationJourneyEventsClickEvent {
    /**
     * Name of event triggered when element matching selector is interacted with
     */
    eventName: string;
    /**
     * Element that triggers event
     */
    selector: string;
}

export interface WebdeploymentsConfigurationJourneyEventsFormTrackEvent {
    /**
     * Whether to capture the form data in the form abandoned event
     */
    captureDataOnFormAbandon: boolean;
    /**
     * Whether to capture the form data in the form submitted event
     */
    captureDataOnFormSubmit: boolean;
    /**
     * Prefix for the form submitted or abandoned event name
     */
    formName: string;
    /**
     * Form element that triggers the form submitted or abandoned event
     */
    selector: string;
}

export interface WebdeploymentsConfigurationJourneyEventsIdleEvent {
    /**
     * Name of event triggered after period of inactivity
     */
    eventName: string;
    /**
     * Number of seconds of inactivity before an event is triggered
     */
    idleAfterSeconds?: number;
}

export interface WebdeploymentsConfigurationJourneyEventsInViewportEvent {
    /**
     * Name of event triggered when element matching selector is interacted with
     */
    eventName: string;
    /**
     * Element that triggers event
     */
    selector: string;
}

export interface WebdeploymentsConfigurationJourneyEventsScrollDepthEvent {
    /**
     * Name of event triggered after scrolling to the specified percentage
     */
    eventName: string;
    /**
     * Percentage of a webpage at which an event is triggered
     */
    percentage: number;
}

export interface WebdeploymentsConfigurationMessenger {
    /**
     * The apps embedded in the messenger
     */
    apps?: outputs.WebdeploymentsConfigurationMessengerApps;
    /**
     * Whether or not messenger is enabled
     */
    enabled: boolean;
    /**
     * File upload settings for messenger
     */
    fileUpload?: outputs.WebdeploymentsConfigurationMessengerFileUpload;
    /**
     * The settings for the home screen
     */
    homeScreen?: outputs.WebdeploymentsConfigurationMessengerHomeScreen;
    /**
     * The settings for the launcher button
     */
    launcherButton?: outputs.WebdeploymentsConfigurationMessengerLauncherButton;
    /**
     * The style settings for messenger
     */
    styles?: outputs.WebdeploymentsConfigurationMessengerStyles;
}

export interface WebdeploymentsConfigurationMessengerApps {
    /**
     * Conversation settings that handles chats within the messenger
     */
    conversations?: outputs.WebdeploymentsConfigurationMessengerAppsConversations;
    /**
     * The knowledge base config for messenger
     */
    knowledge?: outputs.WebdeploymentsConfigurationMessengerAppsKnowledge;
}

export interface WebdeploymentsConfigurationMessengerAppsConversations {
    /**
     * The auto start for the messenger conversation
     */
    autoStartEnabled: boolean;
    /**
     * The conversation clear settings for the messenger app
     */
    conversationClearEnabled: boolean;
    /**
     * The conversation disconnect for the messenger app
     */
    conversationDisconnect?: outputs.WebdeploymentsConfigurationMessengerAppsConversationsConversationDisconnect;
    /**
     * The toggle to enable or disable conversations
     */
    enabled: boolean;
    /**
     * The humanize conversations settings for the messenger app
     */
    humanize?: outputs.WebdeploymentsConfigurationMessengerAppsConversationsHumanize;
    /**
     * The markdown for the messenger app
     */
    markdownEnabled: boolean;
    /**
     * The toggle to enable or disable typing indicator for messenger
     */
    showAgentTypingIndicator: boolean;
    /**
     * The toggle to enable or disable typing indicator for messenger
     */
    showUserTypingIndicator: boolean;
}

export interface WebdeploymentsConfigurationMessengerAppsConversationsConversationDisconnect {
    /**
     * whether or not conversation disconnect setting is enabled
     */
    enabled?: boolean;
    /**
     * Conversation disconnect type
     */
    type?: string;
}

export interface WebdeploymentsConfigurationMessengerAppsConversationsHumanize {
    /**
     * Bot messenger profile setting
     */
    bot?: outputs.WebdeploymentsConfigurationMessengerAppsConversationsHumanizeBot;
    /**
     * Whether or not humanize conversations setting is enabled
     */
    enabled?: boolean;
}

export interface WebdeploymentsConfigurationMessengerAppsConversationsHumanizeBot {
    /**
     * The avatar URL of the bot
     */
    avatarUrl?: string;
    /**
     * The name of the bot
     */
    name?: string;
}

export interface WebdeploymentsConfigurationMessengerAppsKnowledge {
    /**
     * whether or not knowledge base is enabled
     */
    enabled?: boolean;
    /**
     * The knowledge base for messenger
     */
    knowledgeBaseId?: string;
}

export interface WebdeploymentsConfigurationMessengerFileUpload {
    /**
     * The list of supported file upload modes
     */
    modes?: outputs.WebdeploymentsConfigurationMessengerFileUploadMode[];
}

export interface WebdeploymentsConfigurationMessengerFileUploadMode {
    /**
     * A list of supported content types for uploading files.Valid values: image/jpeg, image/gif, image/png
     */
    fileTypes?: string[];
    /**
     * The maximum file size for file uploads in kilobytes. Default is 10240 (10 MB)
     */
    maxFileSizeKb?: number;
}

export interface WebdeploymentsConfigurationMessengerHomeScreen {
    /**
     * Whether or not home screen is enabled
     */
    enabled: boolean;
    /**
     * URL for custom logo to appear in home screen
     */
    logoUrl: string;
}

export interface WebdeploymentsConfigurationMessengerLauncherButton {
    /**
     * The visibility settings for the button.Valid values: On, Off, OnDemand
     */
    visibility?: string;
}

export interface WebdeploymentsConfigurationMessengerStyles {
    /**
     * The primary color of messenger in hexadecimal
     */
    primaryColor?: string;
}

export interface WebdeploymentsConfigurationPosition {
    /**
     * The alignment for position
     */
    alignment?: string;
    /**
     * The bottomspace value for position
     */
    bottomSpace?: number;
    /**
     * The sidespace value for position
     */
    sideSpace?: number;
}

export interface WebdeploymentsConfigurationSupportCenter {
    /**
     * Customizable display texts for knowledge portal
     */
    customMessages?: outputs.WebdeploymentsConfigurationSupportCenterCustomMessage[];
    /**
     * Whether or not knowledge portal (previously support center) is enabled
     */
    enabled: boolean;
    /**
     * Featured categories for knowledge portal (previously support center) home screen
     */
    enabledCategories?: outputs.WebdeploymentsConfigurationSupportCenterEnabledCategory[];
    /**
     * Whether or not requesting customer feedback on article content and article search results is enabled
     */
    feedbackEnabled?: boolean;
    /**
     * The knowledge base for knowledge portal (previously support center)
     */
    knowledgeBaseId?: string;
    /**
     * Router type for knowledge portal
     */
    routerType?: string;
    /**
     * Available screens for the knowledge portal with its modules
     */
    screens?: outputs.WebdeploymentsConfigurationSupportCenterScreen[];
    /**
     * Style attributes for knowledge portal (previously support center)
     */
    styleSetting?: outputs.WebdeploymentsConfigurationSupportCenterStyleSetting;
}

export interface WebdeploymentsConfigurationSupportCenterCustomMessage {
    /**
     * Default value for the custom message
     */
    defaultValue: string;
    /**
     * The custom message type. (Welcome or Fallback)
     */
    type: string;
}

export interface WebdeploymentsConfigurationSupportCenterEnabledCategory {
    /**
     * The knowledge base category id
     */
    categoryId: string;
    /**
     * Source URL for the featured category
     */
    imageUri?: string;
}

export interface WebdeploymentsConfigurationSupportCenterScreen {
    /**
     * Module settings for the screen, valid modules for each screenType: Home: Search, Categories, TopViewedArticles; Category: Search, Categories; SearchResults: Search, Results; Article: Search, Article;
     */
    moduleSettings: outputs.WebdeploymentsConfigurationSupportCenterScreenModuleSetting[];
    /**
     * The type of the screen
     */
    type: string;
}

export interface WebdeploymentsConfigurationSupportCenterScreenModuleSetting {
    /**
     * Whether the Support Center Compact Category Module Template is active or not
     */
    compactCategoryModuleTemplateActive?: boolean;
    /**
     * Detailed category module template settings
     */
    detailedCategoryModuleTemplate?: outputs.WebdeploymentsConfigurationSupportCenterScreenModuleSettingDetailedCategoryModuleTemplate;
    /**
     * Whether or not knowledge portal (previously support center) screen module is enabled
     */
    enabled: boolean;
    /**
     * Screen module type
     */
    type: string;
}

export interface WebdeploymentsConfigurationSupportCenterScreenModuleSettingDetailedCategoryModuleTemplate {
    /**
     * Whether the Support Center Detailed Category Module Template is active or not
     */
    active: boolean;
    /**
     * Whether the Support Center Detailed Category Module Sidebar is active or not
     */
    sidebarEnabled: boolean;
}

export interface WebdeploymentsConfigurationSupportCenterStyleSetting {
    /**
     * Knowledge portal (previously support center) global customizations
     */
    globalStyleSetting?: outputs.WebdeploymentsConfigurationSupportCenterStyleSettingGlobalStyleSetting;
    /**
     * Knowledge portal (previously support center) hero customizations
     */
    heroStyleSetting?: outputs.WebdeploymentsConfigurationSupportCenterStyleSettingHeroStyleSetting;
}

export interface WebdeploymentsConfigurationSupportCenterStyleSettingGlobalStyleSetting {
    /**
     * Global background color, in hexadecimal format, eg #ffffff
     */
    backgroundColor: string;
    /**
     * Global font family
     */
    fontFamily: string;
    /**
     * Global primary color, in hexadecimal format, eg #ffffff
     */
    primaryColor: string;
    /**
     * Global dark primary color, in hexadecimal format, eg #ffffff
     */
    primaryColorDark: string;
    /**
     * Global light primary color, in hexadecimal format, eg #ffffff
     */
    primaryColorLight: string;
    /**
     * Global text color, in hexadecimal format, eg #ffffff
     */
    textColor: string;
}

export interface WebdeploymentsConfigurationSupportCenterStyleSettingHeroStyleSetting {
    /**
     * Background color for hero section, in hexadecimal format, eg #ffffff
     */
    backgroundColor: string;
    /**
     * Background image for hero section
     */
    imageUri: string;
    /**
     * Text color for hero section, in hexadecimal format, eg #ffffff
     */
    textColor: string;
}

export interface WebdeploymentsDeploymentConfiguration {
    id: string;
    version: string;
}

export interface WidgetDeploymentClientConfig {
    /**
     * Url endpoint to perform_authentication
     */
    authenticationUrl?: string;
    /**
     * Skin for the webchat user. (basic, modern-caret-skin)
     */
    webchatSkin?: string;
}

export namespace config {
    export interface Proxy {
        auth?: outputs.config.ProxyAuth;
        /**
         * Host for the proxy can be set with the `GENESYSCLOUD_PROXY_HOST` environment variable.
         */
        host?: string;
        /**
         * Port for the proxy can be set with the `GENESYSCLOUD_PROXY_PORT` environment variable.
         */
        port?: string;
        /**
         * Protocol for the proxy can be set with the `GENESYSCLOUD_PROXY_PROTOCOL` environment variable.
         */
        protocol?: string;
    }

    export interface ProxyAuth {
        /**
         * Password for the Auth can be set with the `GENESYSCLOUD_PROXY_AUTH_PASSWORD` environment variable.
         */
        password?: string;
        /**
         * UserName for the Auth can be set with the `GENESYSCLOUD_PROXY_AUTH_USERNAME` environment variable.
         */
        username?: string;
    }

}
