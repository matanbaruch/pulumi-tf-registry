// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export function getKafkaClusterV3Instance(args: GetKafkaClusterV3InstanceArgs, opts?: pulumi.InvokeOptions): Promise<GetKafkaClusterV3InstanceResult> {

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("instaclustr:index/getKafkaClusterV3Instance:getKafkaClusterV3Instance", {
        "allowDeleteTopics": args.allowDeleteTopics,
        "autoCreateTopics": args.autoCreateTopics,
        "bundledUseOnly": args.bundledUseOnly,
        "clientBrokerAuthWithMtls": args.clientBrokerAuthWithMtls,
        "clientToClusterEncryption": args.clientToClusterEncryption,
        "collocatedZookeepers": args.collocatedZookeepers,
        "currentClusterOperationStatus": args.currentClusterOperationStatus,
        "dataCentres": args.dataCentres,
        "dedicatedKraftControllers": args.dedicatedKraftControllers,
        "dedicatedZookeepers": args.dedicatedZookeepers,
        "defaultNumberOfPartitions": args.defaultNumberOfPartitions,
        "defaultReplicationFactor": args.defaultReplicationFactor,
        "defaultUserPassword": args.defaultUserPassword,
        "description": args.description,
        "id": args.id,
        "kafkaVersion": args.kafkaVersion,
        "karapaceRestProxies": args.karapaceRestProxies,
        "karapaceSchemaRegistries": args.karapaceSchemaRegistries,
        "krafts": args.krafts,
        "name": args.name,
        "pciComplianceMode": args.pciComplianceMode,
        "privateNetworkCluster": args.privateNetworkCluster,
        "resizeSettings": args.resizeSettings,
        "restProxies": args.restProxies,
        "schemaRegistries": args.schemaRegistries,
        "slaTier": args.slaTier,
        "status": args.status,
        "tieredStorages": args.tieredStorages,
        "twoFactorDeletes": args.twoFactorDeletes,
    }, opts, utilities.getPackage());
}

/**
 * A collection of arguments for invoking getKafkaClusterV3Instance.
 */
export interface GetKafkaClusterV3InstanceArgs {
    allowDeleteTopics?: boolean;
    autoCreateTopics?: boolean;
    bundledUseOnly?: boolean;
    clientBrokerAuthWithMtls?: boolean;
    clientToClusterEncryption?: boolean;
    collocatedZookeepers?: inputs.GetKafkaClusterV3InstanceCollocatedZookeeper[];
    currentClusterOperationStatus?: string;
    dataCentres?: inputs.GetKafkaClusterV3InstanceDataCentre[];
    dedicatedKraftControllers?: inputs.GetKafkaClusterV3InstanceDedicatedKraftController[];
    dedicatedZookeepers?: inputs.GetKafkaClusterV3InstanceDedicatedZookeeper[];
    defaultNumberOfPartitions?: number;
    defaultReplicationFactor?: number;
    defaultUserPassword?: string;
    description?: string;
    id: string;
    kafkaVersion?: string;
    karapaceRestProxies?: inputs.GetKafkaClusterV3InstanceKarapaceRestProxy[];
    karapaceSchemaRegistries?: inputs.GetKafkaClusterV3InstanceKarapaceSchemaRegistry[];
    krafts?: inputs.GetKafkaClusterV3InstanceKraft[];
    name?: string;
    pciComplianceMode?: boolean;
    privateNetworkCluster?: boolean;
    resizeSettings?: inputs.GetKafkaClusterV3InstanceResizeSetting[];
    restProxies?: inputs.GetKafkaClusterV3InstanceRestProxy[];
    schemaRegistries?: inputs.GetKafkaClusterV3InstanceSchemaRegistry[];
    slaTier?: string;
    status?: string;
    tieredStorages?: inputs.GetKafkaClusterV3InstanceTieredStorage[];
    twoFactorDeletes?: inputs.GetKafkaClusterV3InstanceTwoFactorDelete[];
}

/**
 * A collection of values returned by getKafkaClusterV3Instance.
 */
export interface GetKafkaClusterV3InstanceResult {
    readonly allowDeleteTopics: boolean;
    readonly autoCreateTopics: boolean;
    readonly bundledUseOnly: boolean;
    readonly clientBrokerAuthWithMtls: boolean;
    readonly clientToClusterEncryption: boolean;
    readonly collocatedZookeepers?: outputs.GetKafkaClusterV3InstanceCollocatedZookeeper[];
    readonly currentClusterOperationStatus: string;
    readonly dataCentres?: outputs.GetKafkaClusterV3InstanceDataCentre[];
    readonly dedicatedKraftControllers?: outputs.GetKafkaClusterV3InstanceDedicatedKraftController[];
    readonly dedicatedZookeepers?: outputs.GetKafkaClusterV3InstanceDedicatedZookeeper[];
    readonly defaultNumberOfPartitions: number;
    readonly defaultReplicationFactor: number;
    readonly defaultUserPassword: string;
    readonly description: string;
    readonly id: string;
    readonly kafkaVersion: string;
    readonly karapaceRestProxies?: outputs.GetKafkaClusterV3InstanceKarapaceRestProxy[];
    readonly karapaceSchemaRegistries?: outputs.GetKafkaClusterV3InstanceKarapaceSchemaRegistry[];
    readonly krafts?: outputs.GetKafkaClusterV3InstanceKraft[];
    readonly name: string;
    readonly pciComplianceMode: boolean;
    readonly privateNetworkCluster: boolean;
    readonly resizeSettings?: outputs.GetKafkaClusterV3InstanceResizeSetting[];
    readonly restProxies?: outputs.GetKafkaClusterV3InstanceRestProxy[];
    readonly schemaRegistries?: outputs.GetKafkaClusterV3InstanceSchemaRegistry[];
    readonly slaTier: string;
    readonly status: string;
    readonly tieredStorages?: outputs.GetKafkaClusterV3InstanceTieredStorage[];
    readonly twoFactorDeletes?: outputs.GetKafkaClusterV3InstanceTwoFactorDelete[];
}
export function getKafkaClusterV3InstanceOutput(args: GetKafkaClusterV3InstanceOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetKafkaClusterV3InstanceResult> {
    return pulumi.output(args).apply((a: any) => getKafkaClusterV3Instance(a, opts))
}

/**
 * A collection of arguments for invoking getKafkaClusterV3Instance.
 */
export interface GetKafkaClusterV3InstanceOutputArgs {
    allowDeleteTopics?: pulumi.Input<boolean>;
    autoCreateTopics?: pulumi.Input<boolean>;
    bundledUseOnly?: pulumi.Input<boolean>;
    clientBrokerAuthWithMtls?: pulumi.Input<boolean>;
    clientToClusterEncryption?: pulumi.Input<boolean>;
    collocatedZookeepers?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceCollocatedZookeeperArgs>[]>;
    currentClusterOperationStatus?: pulumi.Input<string>;
    dataCentres?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceDataCentreArgs>[]>;
    dedicatedKraftControllers?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceDedicatedKraftControllerArgs>[]>;
    dedicatedZookeepers?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceDedicatedZookeeperArgs>[]>;
    defaultNumberOfPartitions?: pulumi.Input<number>;
    defaultReplicationFactor?: pulumi.Input<number>;
    defaultUserPassword?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    id: pulumi.Input<string>;
    kafkaVersion?: pulumi.Input<string>;
    karapaceRestProxies?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceKarapaceRestProxyArgs>[]>;
    karapaceSchemaRegistries?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceKarapaceSchemaRegistryArgs>[]>;
    krafts?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceKraftArgs>[]>;
    name?: pulumi.Input<string>;
    pciComplianceMode?: pulumi.Input<boolean>;
    privateNetworkCluster?: pulumi.Input<boolean>;
    resizeSettings?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceResizeSettingArgs>[]>;
    restProxies?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceRestProxyArgs>[]>;
    schemaRegistries?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceSchemaRegistryArgs>[]>;
    slaTier?: pulumi.Input<string>;
    status?: pulumi.Input<string>;
    tieredStorages?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceTieredStorageArgs>[]>;
    twoFactorDeletes?: pulumi.Input<pulumi.Input<inputs.GetKafkaClusterV3InstanceTwoFactorDeleteArgs>[]>;
}
