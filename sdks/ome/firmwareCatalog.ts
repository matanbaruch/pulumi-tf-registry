// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class FirmwareCatalog extends pulumi.CustomResource {
    /**
     * Get an existing FirmwareCatalog resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: FirmwareCatalogState, opts?: pulumi.CustomResourceOptions): FirmwareCatalog {
        return new FirmwareCatalog(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'ome:index/firmwareCatalog:FirmwareCatalog';

    /**
     * Returns true if the given object is an instance of FirmwareCatalog.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is FirmwareCatalog {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === FirmwareCatalog.__pulumiType;
    }

    /**
     * Associated Baselines.
     */
    public /*out*/ readonly associatedBaselines!: pulumi.Output<outputs.FirmwareCatalogAssociatedBaseline[]>;
    /**
     * Baseline Location.
     */
    public /*out*/ readonly baselineLocation!: pulumi.Output<string>;
    /**
     * Bundles Count.
     */
    public /*out*/ readonly bundlesCount!: pulumi.Output<number>;
    /**
     * Catalog File Path. Path on the share to gather catalog data. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    public readonly catalogFilePath!: pulumi.Output<string | undefined>;
    /**
     * Catalog Refresh Schedule, when using automatic catalog update the schedule is required for cadence of the update. If
     * catalog_update_type is set to manual, this field is ignored.
     */
    public readonly catalogRefreshSchedule!: pulumi.Output<outputs.FirmwareCatalogCatalogRefreshSchedule>;
    /**
     * Catalog Update Type. Sets the frequency of catalog updates. Defaults to Manual. If set to automatic, the
     * catalog_refresh_schedule field will need to be set. Options are (Manual, Automatic).
     */
    public readonly catalogUpdateType!: pulumi.Output<string>;
    /**
     * Create Date.
     */
    public /*out*/ readonly createDate!: pulumi.Output<string>;
    /**
     * Domain. The domain for the catalog. This field is optional and only used for share_types (CIFS).
     */
    public readonly domain!: pulumi.Output<string | undefined>;
    /**
     * Filename.
     */
    public /*out*/ readonly filename!: pulumi.Output<string>;
    /**
     * Last Update.
     */
    public /*out*/ readonly lastUpdate!: pulumi.Output<string>;
    /**
     * Manifest Identifier.
     */
    public /*out*/ readonly manifestIdentifier!: pulumi.Output<string>;
    /**
     * Manifest Version.
     */
    public /*out*/ readonly manifestVersion!: pulumi.Output<string>;
    /**
     * Name of the new catalog.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Next Update.
     */
    public /*out*/ readonly nextUpdate!: pulumi.Output<string>;
    /**
     * Owner ID.
     */
    public /*out*/ readonly ownerId!: pulumi.Output<number>;
    /**
     * Predcessor Identifier.
     */
    public /*out*/ readonly predcessorIdentifier!: pulumi.Output<string>;
    /**
     * Release Identifier.
     */
    public /*out*/ readonly releaseIdentifier!: pulumi.Output<string>;
    /**
     * Repository.
     */
    public /*out*/ readonly repository!: pulumi.Output<outputs.FirmwareCatalogRepository>;
    /**
     * Share Address. Gives the Ipv4, Ipv6, or FQDN of the share. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    public readonly shareAddress!: pulumi.Output<string | undefined>;
    /**
     * Share Password. The password related to the share address. This field is required for share_types (CIFS, HTTPS)
     */
    public readonly sharePassword!: pulumi.Output<string | undefined>;
    /**
     * Share Type, the type of share the catalog will pull from, Defaults to Dell. The different options will have different
     * required fields to work properly. Options are (DELL, NFS, CIFS, HTTP, HTTPS).
     */
    public readonly shareType!: pulumi.Output<string>;
    /**
     * Share User. The username related to the share address. This field is required for share_types (CIFS, HTTPS).
     */
    public readonly shareUser!: pulumi.Output<string | undefined>;
    /**
     * Source path.
     */
    public /*out*/ readonly sourcePath!: pulumi.Output<string>;
    /**
     * Status.
     */
    public /*out*/ readonly status!: pulumi.Output<string>;
    /**
     * Task ID.
     */
    public /*out*/ readonly taskId!: pulumi.Output<number>;

    /**
     * Create a FirmwareCatalog resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: FirmwareCatalogArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: FirmwareCatalogArgs | FirmwareCatalogState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as FirmwareCatalogState | undefined;
            resourceInputs["associatedBaselines"] = state ? state.associatedBaselines : undefined;
            resourceInputs["baselineLocation"] = state ? state.baselineLocation : undefined;
            resourceInputs["bundlesCount"] = state ? state.bundlesCount : undefined;
            resourceInputs["catalogFilePath"] = state ? state.catalogFilePath : undefined;
            resourceInputs["catalogRefreshSchedule"] = state ? state.catalogRefreshSchedule : undefined;
            resourceInputs["catalogUpdateType"] = state ? state.catalogUpdateType : undefined;
            resourceInputs["createDate"] = state ? state.createDate : undefined;
            resourceInputs["domain"] = state ? state.domain : undefined;
            resourceInputs["filename"] = state ? state.filename : undefined;
            resourceInputs["lastUpdate"] = state ? state.lastUpdate : undefined;
            resourceInputs["manifestIdentifier"] = state ? state.manifestIdentifier : undefined;
            resourceInputs["manifestVersion"] = state ? state.manifestVersion : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["nextUpdate"] = state ? state.nextUpdate : undefined;
            resourceInputs["ownerId"] = state ? state.ownerId : undefined;
            resourceInputs["predcessorIdentifier"] = state ? state.predcessorIdentifier : undefined;
            resourceInputs["releaseIdentifier"] = state ? state.releaseIdentifier : undefined;
            resourceInputs["repository"] = state ? state.repository : undefined;
            resourceInputs["shareAddress"] = state ? state.shareAddress : undefined;
            resourceInputs["sharePassword"] = state ? state.sharePassword : undefined;
            resourceInputs["shareType"] = state ? state.shareType : undefined;
            resourceInputs["shareUser"] = state ? state.shareUser : undefined;
            resourceInputs["sourcePath"] = state ? state.sourcePath : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["taskId"] = state ? state.taskId : undefined;
        } else {
            const args = argsOrState as FirmwareCatalogArgs | undefined;
            resourceInputs["catalogFilePath"] = args ? args.catalogFilePath : undefined;
            resourceInputs["catalogRefreshSchedule"] = args ? args.catalogRefreshSchedule : undefined;
            resourceInputs["catalogUpdateType"] = args ? args.catalogUpdateType : undefined;
            resourceInputs["domain"] = args ? args.domain : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["shareAddress"] = args ? args.shareAddress : undefined;
            resourceInputs["sharePassword"] = args?.sharePassword ? pulumi.secret(args.sharePassword) : undefined;
            resourceInputs["shareType"] = args ? args.shareType : undefined;
            resourceInputs["shareUser"] = args ? args.shareUser : undefined;
            resourceInputs["associatedBaselines"] = undefined /*out*/;
            resourceInputs["baselineLocation"] = undefined /*out*/;
            resourceInputs["bundlesCount"] = undefined /*out*/;
            resourceInputs["createDate"] = undefined /*out*/;
            resourceInputs["filename"] = undefined /*out*/;
            resourceInputs["lastUpdate"] = undefined /*out*/;
            resourceInputs["manifestIdentifier"] = undefined /*out*/;
            resourceInputs["manifestVersion"] = undefined /*out*/;
            resourceInputs["nextUpdate"] = undefined /*out*/;
            resourceInputs["ownerId"] = undefined /*out*/;
            resourceInputs["predcessorIdentifier"] = undefined /*out*/;
            resourceInputs["releaseIdentifier"] = undefined /*out*/;
            resourceInputs["repository"] = undefined /*out*/;
            resourceInputs["sourcePath"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["taskId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["sharePassword"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(FirmwareCatalog.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering FirmwareCatalog resources.
 */
export interface FirmwareCatalogState {
    /**
     * Associated Baselines.
     */
    associatedBaselines?: pulumi.Input<pulumi.Input<inputs.FirmwareCatalogAssociatedBaseline>[]>;
    /**
     * Baseline Location.
     */
    baselineLocation?: pulumi.Input<string>;
    /**
     * Bundles Count.
     */
    bundlesCount?: pulumi.Input<number>;
    /**
     * Catalog File Path. Path on the share to gather catalog data. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    catalogFilePath?: pulumi.Input<string>;
    /**
     * Catalog Refresh Schedule, when using automatic catalog update the schedule is required for cadence of the update. If
     * catalog_update_type is set to manual, this field is ignored.
     */
    catalogRefreshSchedule?: pulumi.Input<inputs.FirmwareCatalogCatalogRefreshSchedule>;
    /**
     * Catalog Update Type. Sets the frequency of catalog updates. Defaults to Manual. If set to automatic, the
     * catalog_refresh_schedule field will need to be set. Options are (Manual, Automatic).
     */
    catalogUpdateType?: pulumi.Input<string>;
    /**
     * Create Date.
     */
    createDate?: pulumi.Input<string>;
    /**
     * Domain. The domain for the catalog. This field is optional and only used for share_types (CIFS).
     */
    domain?: pulumi.Input<string>;
    /**
     * Filename.
     */
    filename?: pulumi.Input<string>;
    /**
     * Last Update.
     */
    lastUpdate?: pulumi.Input<string>;
    /**
     * Manifest Identifier.
     */
    manifestIdentifier?: pulumi.Input<string>;
    /**
     * Manifest Version.
     */
    manifestVersion?: pulumi.Input<string>;
    /**
     * Name of the new catalog.
     */
    name?: pulumi.Input<string>;
    /**
     * Next Update.
     */
    nextUpdate?: pulumi.Input<string>;
    /**
     * Owner ID.
     */
    ownerId?: pulumi.Input<number>;
    /**
     * Predcessor Identifier.
     */
    predcessorIdentifier?: pulumi.Input<string>;
    /**
     * Release Identifier.
     */
    releaseIdentifier?: pulumi.Input<string>;
    /**
     * Repository.
     */
    repository?: pulumi.Input<inputs.FirmwareCatalogRepository>;
    /**
     * Share Address. Gives the Ipv4, Ipv6, or FQDN of the share. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    shareAddress?: pulumi.Input<string>;
    /**
     * Share Password. The password related to the share address. This field is required for share_types (CIFS, HTTPS)
     */
    sharePassword?: pulumi.Input<string>;
    /**
     * Share Type, the type of share the catalog will pull from, Defaults to Dell. The different options will have different
     * required fields to work properly. Options are (DELL, NFS, CIFS, HTTP, HTTPS).
     */
    shareType?: pulumi.Input<string>;
    /**
     * Share User. The username related to the share address. This field is required for share_types (CIFS, HTTPS).
     */
    shareUser?: pulumi.Input<string>;
    /**
     * Source path.
     */
    sourcePath?: pulumi.Input<string>;
    /**
     * Status.
     */
    status?: pulumi.Input<string>;
    /**
     * Task ID.
     */
    taskId?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a FirmwareCatalog resource.
 */
export interface FirmwareCatalogArgs {
    /**
     * Catalog File Path. Path on the share to gather catalog data. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    catalogFilePath?: pulumi.Input<string>;
    /**
     * Catalog Refresh Schedule, when using automatic catalog update the schedule is required for cadence of the update. If
     * catalog_update_type is set to manual, this field is ignored.
     */
    catalogRefreshSchedule?: pulumi.Input<inputs.FirmwareCatalogCatalogRefreshSchedule>;
    /**
     * Catalog Update Type. Sets the frequency of catalog updates. Defaults to Manual. If set to automatic, the
     * catalog_refresh_schedule field will need to be set. Options are (Manual, Automatic).
     */
    catalogUpdateType?: pulumi.Input<string>;
    /**
     * Domain. The domain for the catalog. This field is optional and only used for share_types (CIFS).
     */
    domain?: pulumi.Input<string>;
    /**
     * Name of the new catalog.
     */
    name?: pulumi.Input<string>;
    /**
     * Share Address. Gives the Ipv4, Ipv6, or FQDN of the share. This field is required for share_types (NFS, CIFS, HTTP,
     * HTTPS)
     */
    shareAddress?: pulumi.Input<string>;
    /**
     * Share Password. The password related to the share address. This field is required for share_types (CIFS, HTTPS)
     */
    sharePassword?: pulumi.Input<string>;
    /**
     * Share Type, the type of share the catalog will pull from, Defaults to Dell. The different options will have different
     * required fields to work properly. Options are (DELL, NFS, CIFS, HTTP, HTTPS).
     */
    shareType?: pulumi.Input<string>;
    /**
     * Share User. The username related to the share address. This field is required for share_types (CIFS, HTTPS).
     */
    shareUser?: pulumi.Input<string>;
}
