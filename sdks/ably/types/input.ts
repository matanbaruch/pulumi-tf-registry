// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface RuleAmqpExternalSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleAmqpExternalTarget {
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * The RabbitMQ exchange, if needed, supports interpolation; see https://faqs.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule for more info. If you don't use RabbitMQ exchanges, leave this blank.
     */
    exchange: pulumi.Input<string>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleAmqpExternalTargetHeader>[]>;
    /**
     * Reject delivery of the message if the route does not exist, otherwise fail silently.
     */
    mandatoryRoute: pulumi.Input<boolean>;
    /**
     * You can optionally override the default TTL on a queue and specify a TTL in minutes for messages to be persisted. It is unusual to change the default TTL, so if this field is left empty, the default TTL for the queue will be used.
     */
    messageTtl?: pulumi.Input<number>;
    /**
     * Marks the message as persistent, instructing the broker to write it to disk if it is in a durable queue.
     */
    persistentMessages: pulumi.Input<boolean>;
    /**
     * The Kafka partition key. This is used to determine which partition a message should be routed to, where a topic has been partitioned. routingKey should be in the format topic:key where topic is the topic to publish to, and key is the value to use as the message key
     */
    routingKey: pulumi.Input<string>;
    /**
     * The webhook URL that Ably will POST events to
     */
    url: pulumi.Input<string>;
}

export interface RuleAmqpExternalTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleAmqpSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleAmqpTarget {
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleAmqpTargetHeader>[]>;
    /**
     * The ID of your Ably queue
     */
    queueId: pulumi.Input<string>;
}

export interface RuleAmqpTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleAzureFunctionSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleAzureFunctionTarget {
    /**
     * The Microsoft Azure Application ID. You can find your Microsoft Azure Application ID
     */
    azureAppId: pulumi.Input<string>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * The name of your Microsoft Azure Function
     */
    functionName: pulumi.Input<string>;
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleAzureFunctionTargetHeader>[]>;
    /**
     * The signing key ID for use in batch mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the [webhook security docs](https://ably.com/docs/general/webhooks#security) for more information
     */
    signingKeyId?: pulumi.Input<string>;
}

export interface RuleAzureFunctionTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleCloudflareWorkerSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleCloudflareWorkerTarget {
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleCloudflareWorkerTargetHeader>[]>;
    /**
     * The signing key ID for use in batch mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the [webhook security docs](https://ably.com/docs/general/webhooks#security) for more information
     */
    signingKeyId?: pulumi.Input<string>;
    /**
     * The webhook URL that Ably will POST events to
     */
    url: pulumi.Input<string>;
}

export interface RuleCloudflareWorkerTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleGoogleFunctionSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleGoogleFunctionTarget {
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * The name of your Google Cloud Function.
     */
    functionName: pulumi.Input<string>;
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleGoogleFunctionTargetHeader>[]>;
    /**
     * The project ID for your Google Cloud Project that was generated when you created your project.
     */
    projectId: pulumi.Input<string>;
    /**
     * The region in which your Google Cloud Function is hosted. See the Google documentation for more details.
     */
    region: pulumi.Input<string>;
    /**
     * The signing key ID for use in batch mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the [webhook security docs](https://ably.com/docs/general/webhooks#security) for more information
     */
    signingKeyId?: pulumi.Input<string>;
}

export interface RuleGoogleFunctionTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleHttpSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleHttpTarget {
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleHttpTargetHeader>[]>;
    /**
     * The signing key ID for use in batch mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the [webhook security docs](https://ably.com/docs/general/webhooks#security) for more information
     */
    signingKeyId?: pulumi.Input<string>;
    /**
     * The webhook URL that Ably will POST events to
     */
    url: pulumi.Input<string>;
}

export interface RuleHttpTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}

export interface RuleIftttSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleIftttTarget {
    /**
     * The Event name is used to identify the IFTTT applet that will receive the Event, make sure the name matches the name of the IFTTT applet.
     */
    eventName: pulumi.Input<string>;
    /**
     * The key in the Webhook Service Documentation page of your IFTTT account
     */
    webhookKey: pulumi.Input<string>;
}

export interface RuleKafkaSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleKafkaTarget {
    /**
     * The Kafka [authentication mechanism](https://docs.confluent.io/platform/current/kafka/overview-authentication-methods.html)
     */
    auth: pulumi.Input<inputs.RuleKafkaTargetAuth>;
    /**
     * This is a list of brokers that host your Kafka partitions. Each broker is specified using the format `host`, `host:port` or `ip:port`
     */
    brokers: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * The Kafka partition key. This is used to determine which partition a message should be routed to, where a topic has been partitioned. routingKey should be in the format topic:key where topic is the topic to publish to, and key is the value to use as the message key
     */
    routingKey: pulumi.Input<string>;
}

export interface RuleKafkaTargetAuth {
    /**
     * SASL(Simple Authentication Security Layer) / SCRAM (Salted Challenge Response Authentication Mechanism) uses usernames and passwords stored in ZooKeeper. Credentials are created during installation. See documentation on [configuring SCRAM](https://docs.confluent.io/platform/current/kafka/authentication_sasl/authentication_sasl_scram.html#kafka-sasl-auth-scram)
     */
    sasl?: pulumi.Input<inputs.RuleKafkaTargetAuthSasl>;
}

export interface RuleKafkaTargetAuthSasl {
    /**
     * `plain` `scram-sha-256` `scram-sha-512`. The hash type to use. SCRAM supports either SHA-256 or SHA-512 hash functions
     */
    mechanism: pulumi.Input<string>;
    /**
     * Kafka login credential
     */
    password: pulumi.Input<string>;
    /**
     * Kafka login credential
     */
    username: pulumi.Input<string>;
}

export interface RuleKinesisSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleKinesisTarget {
    /**
     * object (rule_source)
     */
    authentication: pulumi.Input<inputs.RuleKinesisTargetAuthentication>;
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    partitionKey?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    streamName?: pulumi.Input<string>;
}

export interface RuleKinesisTargetAuthentication {
    /**
     * The AWS key ID for the AWS IAM user
     */
    accessKeyId?: pulumi.Input<string>;
    /**
     * Authentication method. Use 'credentials' or 'assumeRole'
     */
    mode: pulumi.Input<string>;
    /**
     * If you are using the 'ARN of an assumable role' authentication method, this is your Assume Role ARN
     */
    roleArn?: pulumi.Input<string>;
    /**
     * The AWS secret key for the AWS IAM user
     */
    secretAccessKey?: pulumi.Input<string>;
}

export interface RuleLambdaSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleLambdaTarget {
    /**
     * object (rule_source)
     */
    authentication: pulumi.Input<inputs.RuleLambdaTargetAuthentication>;
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    functionName?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
}

export interface RuleLambdaTargetAuthentication {
    /**
     * The AWS key ID for the AWS IAM user
     */
    accessKeyId?: pulumi.Input<string>;
    /**
     * Authentication method. Use 'credentials' or 'assumeRole'
     */
    mode: pulumi.Input<string>;
    /**
     * If you are using the 'ARN of an assumable role' authentication method, this is your Assume Role ARN
     */
    roleArn?: pulumi.Input<string>;
    /**
     * The AWS secret key for the AWS IAM user
     */
    secretAccessKey?: pulumi.Input<string>;
}

export interface RulePulsarSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RulePulsarTarget {
    /**
     * Pulsar supports authenticating clients using security tokens that are based on JSON Web Tokens.
     */
    authentication: pulumi.Input<inputs.RulePulsarTargetAuthentication>;
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * The optional routing key (partition key) used to publish messages. Supports interpolation as described in the [Ably FAQs](https://faqs.ably.com/what-is-the-format-of-the-routingkey-for-an-amqp-or-kinesis-reactor-rule).
     */
    routingKey: pulumi.Input<string>;
    /**
     * The URL of the Pulsar cluster in the form pulsar://host:port or pulsar+ssl://host:port
     */
    serviceUrl: pulumi.Input<string>;
    /**
     * All connections to a Pulsar endpoint require TLS. The tls_trust_certs option allows you to configure different or additional trust anchors for those TLS connections. This enables server verification. You can specify an optional list of trusted CA certificates to use to verify the TLS certificate presented by the Pulsar cluster. Each certificate should be encoded in PEM format
     */
    tlsTrustCerts?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A Pulsar topic. This is a named channel for transmission of messages between producers and consumers. The topic has the form: {persistent|non-persistent}://tenant/namespace/topic
     */
    topic: pulumi.Input<string>;
}

export interface RulePulsarTargetAuthentication {
    /**
     * Authentication mode, in this case JSON Web Token. Use `jwt`
     */
    mode: pulumi.Input<string>;
    /**
     * The JWT string.`
     */
    token: pulumi.Input<string>;
}

export interface RuleSqsSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleSqsTarget {
    /**
     * object (rule_source)
     */
    authentication: pulumi.Input<inputs.RuleSqsTargetAuthentication>;
    /**
     * Your AWS account ID
     */
    awsAccountId?: pulumi.Input<string>;
    /**
     * Delivered messages are wrapped in an Ably envelope by default that contains metadata about the message and its payload. The form of the envelope depends on whether it is part of a Webhook/Function or a Queue/Firehose rule. For everything besides Webhooks, you can ensure you only get the raw payload by unchecking "Enveloped" when setting up the rule.
     */
    enveloped?: pulumi.Input<boolean>;
    /**
     * JSON provides a text-based encoding, whereas MsgPack provides a more efficient binary encoding
     */
    format?: pulumi.Input<string>;
    /**
     * The AWS SQS queue name
     */
    queueName?: pulumi.Input<string>;
    /**
     * The region is which AWS SQS is hosted
     */
    region?: pulumi.Input<string>;
}

export interface RuleSqsTargetAuthentication {
    /**
     * The AWS key ID for the AWS IAM user
     */
    accessKeyId?: pulumi.Input<string>;
    /**
     * Authentication method. Use 'credentials' or 'assumeRole'
     */
    mode: pulumi.Input<string>;
    /**
     * If you are using the 'ARN of an assumable role' authentication method, this is your Assume Role ARN
     */
    roleArn?: pulumi.Input<string>;
    /**
     * The AWS secret key for the AWS IAM user
     */
    secretAccessKey?: pulumi.Input<string>;
}

export interface RuleZapierSource {
    channelFilter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RuleZapierTarget {
    /**
     * If you have additional information to send, you'll need to include the relevant headers
     */
    headers?: pulumi.Input<pulumi.Input<inputs.RuleZapierTargetHeader>[]>;
    /**
     * The signing key ID for use in batch mode. Ably will optionally sign the payload using an API key ensuring your servers can validate the payload using the private API key. See the [webhook security docs](https://ably.com/docs/general/webhooks#security) for more information
     */
    signingKeyId?: pulumi.Input<string>;
    /**
     * The webhook URL that Ably will POST events to
     */
    url: pulumi.Input<string>;
}

export interface RuleZapierTargetHeader {
    /**
     * The name of the header
     */
    name: pulumi.Input<string>;
    /**
     * The value of the header
     */
    value: pulumi.Input<string>;
}
