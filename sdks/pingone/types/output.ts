// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApplicationAccessControlGroupOptions {
    /**
     * A set that specifies the group IDs for the groups the actor must belong to for access to the application.  Values must be valid PingOne Resource IDs.
     */
    groups: string[];
    /**
     * A string that specifies the group type required to access the application.  Options are `ALL_GROUPS` (the actor must belong to all groups listed in the `groups` property), `ANY_GROUP` (the actor must belong to at least one group listed in the `groups` property).
     */
    type: string;
}

export interface ApplicationExternalLinkOptions {
    /**
     * A string that specifies the custom home page URL for the application.  Both `http://` and `https://` URLs are permitted.
     */
    homePageUrl: string;
}

export interface ApplicationIcon {
    /**
     * A string that specifies the URL for the application icon.  Both `http://` and `https://` are permitted.
     */
    href: string;
    /**
     * A string that specifies the ID for the application icon.  Must be a valid PingOne Resource ID.
     */
    id: string;
}

export interface ApplicationOidcOptions {
    /**
     * A boolean that, when set to `true` (the default), if you attempt to reuse the refresh token, the authorization server immediately revokes the reused refresh token, as well as all descendant tokens. Setting this to null equates to a `false` setting.  Defaults to `true`.
     */
    additionalRefreshTokenReplayProtectionEnabled: boolean;
    /**
     * A boolean to specify whether wildcards are allowed in redirect URIs. For more information, see [Wildcards in Redirect URIs](https://docs.pingidentity.com/csh?context=p1_c_wildcard_redirect_uri).  Defaults to `false`.
     */
    allowWildcardInRedirectUris: boolean;
    /**
     * A single object that specifies Certificate based authentication settings. This parameter block can only be set where the application's `type` parameter is set to `NATIVE_APP`.
     */
    certificateBasedAuthentication?: outputs.ApplicationOidcOptionsCertificateBasedAuthentication;
    /**
     * A string that specifies the application ID used to authenticate to the authorization server.
     */
    clientId: string;
    /**
     * A single object that allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application. If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. `/as/authorize` and `/as/token`).  This is legacy behavior, and it is recommended that applications migrate to include specific CORS settings.
     */
    corsSettings?: outputs.ApplicationOidcOptionsCorsSettings;
    /**
     * A string that specifies an optional custom verification URI that is returned for the `/device_authorization` endpoint.
     */
    deviceCustomVerificationUri?: string;
    /**
     * A string that specifies a unique identifier within an environment for a device authorization grant flow to provide a short identifier to the application. This property is ignored when the `device_custom_verification_uri` property is configured. The string can contain any letters, numbers, and some special characters (regex: `a-zA-Z0-9_-`). It can have a length of no more than `50` characters (min/max=`1`/`50`).
     */
    devicePathId?: string;
    /**
     * An integer that specifies the frequency (in seconds) for the client to poll the `/as/token` endpoint. This property is required only for applications in which the `grant_types` property is set to `DEVICE_CODE`. The default value is `5` seconds. It can have a value of no more than `60` seconds (min/max=`1`/`60`).
     */
    devicePollingInterval: number;
    /**
     * An integer that specifies the length of time (in seconds) that the `userCode` and `deviceCode` returned by the `/device_authorization` endpoint are valid. This property is required only for applications in which the `grant_types` property is set to `DEVICE_CODE`. The default value is `600` seconds. It can have a value of no more than `3600` seconds (min/max=`1`/`3600`).
     */
    deviceTimeout: number;
    /**
     * A list that specifies the grant type for the authorization request.  Options are `AUTHORIZATION_CODE`, `CLIENT_CREDENTIALS`, `DEVICE_CODE`, `IMPLICIT`, `REFRESH_TOKEN`.
     */
    grantTypes: string[];
    /**
     * A string that specifies the custom home page URL for the application.  The provided URL is expected to use the `https://` schema.  The `http` schema is permitted where the host is `localhost` or `127.0.0.1`.
     */
    homePageUrl?: string;
    /**
     * A string that specifies the URI to use for third-parties to begin the sign-on process for the application. If specified, PingOne redirects users to this URI to initiate SSO to PingOne. The application is responsible for implementing the relevant OIDC flow when the initiate login URI is requested. This property is required if you want the application to appear in the PingOne Application Portal. See the OIDC specification section of [Initiating Login from a Third Party](https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin) for more information.  The provided URL is expected to use the `https://` schema.  The `http` schema is permitted where the host is `localhost` or `127.0.0.1`.
     */
    initiateLoginUri?: string;
    /**
     * A string that specifies a JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `token_endpoint_auth_method`. This property is required when `token_endpoint_auth_method` is `PRIVATE_KEY_JWT` and the `jwks_url` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwks_url` property is empty. For more infornmation about signing the `request` property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).  Conflicts with `jwks_url`.
     */
    jwks?: string;
    /**
     * A string that specifies a URL (supports `https://` only) that provides access to a JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `token_endpoint_auth_method`. This property is required when `token_endpoint_auth_method` is `PRIVATE_KEY_JWT` and the `jwks` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwks` property is empty. For more infornmation about signing the `request` property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).  Conflicts with `jwks`.
     */
    jwksUrl?: string;
    /**
     * A single object that specifies Mobile application integration settings for `NATIVE_APP` type applications.
     */
    mobileApp: outputs.ApplicationOidcOptionsMobileApp;
    /**
     * A string that specifies whether pushed authorization requests (PAR) are required.  Options are `OPTIONAL`, `REQUIRED`.  Defaults to `OPTIONAL`.
     */
    parRequirement: string;
    /**
     * An integer that specifies the pushed authorization request (PAR) timeout in seconds.  Valid values are between `1` and `600`.  Defaults to `60`.
     */
    parTimeout: number;
    /**
     * A string that specifies how `PKCE` request parameters are handled on the authorize request.  Options are `OPTIONAL`, `REQUIRED`, `S256_REQUIRED`.  Defaults to `OPTIONAL`.
     */
    pkceEnforcement: string;
    /**
     * A list of strings that specifies the URLs that the browser can be redirected to after logout.  The provided URLs are expected to use the `https://`, `http://` schema, or a custom mobile native schema (e.g., `org.bxretail.app://logout`).
     */
    postLogoutRedirectUris?: string[];
    /**
     * A list of strings that specifies the allowed callback URIs for the authentication response.    The provided URLs are expected to use the `https://` schema, or a custom mobile native schema (e.g., `org.bxretail.app://callback`).  The `http` schema is only permitted where the host is `localhost` or `127.0.0.1`.
     */
    redirectUris?: string[];
    /**
     * An integer that specifies the lifetime in seconds of the refresh token. Valid values are between `60` and `2147483647`. If the `refresh_token_rolling_duration` property is specified for the application, then this property value must be less than or equal to the value of `refresh_token_rolling_duration`. After this property is set, the value cannot be nullified - this will reset the value back to the default. This value is used to generate the value for the exp claim when minting a new refresh token.  Defaults to `2592000`.
     */
    refreshTokenDuration: number;
    /**
     * An integer that specifies the number of seconds a refresh token can be exchanged before re-authentication is required. Valid values are between `60` and `2147483647`. After this property is set, the value cannot be nullified - this will force recreation of the resource. This value is used to generate the value for the exp claim when minting a new refresh token.  Defaults to `15552000`.
     */
    refreshTokenRollingDuration: number;
    /**
     * The number of seconds that a refresh token may be reused after having been exchanged for a new set of tokens. This is useful in the case of network errors on the client. Valid values are between `0` and `86400` seconds. `Null` is treated the same as `0`.
     */
    refreshTokenRollingGracePeriodDuration?: number;
    /**
     * A boolean that indicates that the Java Web Token (JWT) for the [request query](https://openid.net/specs/openid-connect-core-1_0.html#RequestObject) parameter is required to be signed. If `false` or null, a signed request object is not required. Both `support_unsigned_request_object` and this property cannot be set to `true`.  Defaults to `false`.
     */
    requireSignedRequestObject: boolean;
    /**
     * A list that specifies the code or token type returned by an authorization request.  Options are `CODE`, `ID_TOKEN`, `TOKEN`.  Note that `CODE` cannot be used in an authorization request with `TOKEN` or `ID_TOKEN` because PingOne does not currently support OIDC hybrid flows.
     */
    responseTypes?: string[];
    /**
     * A boolean that specifies whether the request query parameter JWT is allowed to be unsigned. If `false` or null, an unsigned request object is not allowed.  Defaults to `false`.
     */
    supportUnsignedRequestObject: boolean;
    /**
     * The URI for the application. If specified, PingOne will redirect application users to this URI after a user is authenticated. In the PingOne admin console, this becomes the value of the `target_link_uri` parameter used for the Initiate Single Sign-On URL field.  Both `http://` and `https://` URLs are permitted as well as custom mobile native schema (e.g., `org.bxretail.app://target`).
     */
    targetLinkUri?: string;
    /**
     * A string that specifies the client authentication methods supported by the token endpoint.  Options are `CLIENT_SECRET_BASIC`, `CLIENT_SECRET_JWT`, `CLIENT_SECRET_POST`, `NONE`, `PRIVATE_KEY_JWT`.  When `PRIVATE_KEY_JWT` is configured, either `jwks` or `jwks_url` must also be configured.
     */
    tokenEndpointAuthMethod: string;
    /**
     * A string that specifies the type associated with the application.  Options are `CUSTOM_APP`, `NATIVE_APP`, `SERVICE`, `SINGLE_PAGE_APP`, `WEB_APP`, `WORKER`.  This field is immutable and will trigger a replace plan if changed.
     */
    type: string;
}

export interface ApplicationOidcOptionsCertificateBasedAuthentication {
    /**
     * A string that represents a PingOne ID for the issuance certificate key.  The key must be of type `ISSUANCE`.  Must be a valid PingOne Resource ID.
     */
    keyId: string;
}

export interface ApplicationOidcOptionsCorsSettings {
    /**
     * A string that specifies the behavior of how Authorization and Authentication APIs interact with CORS requests that reference the application.  Options are `ALLOW_NO_ORIGINS` (rejects all CORS requests), `ALLOW_SPECIFIC_ORIGINS` (rejects all CORS requests except those listed in `origins`).
     */
    behavior: string;
    /**
     * A set of strings that represent the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value must be a `http` or `https` URL without a path.  The host may be a domain name (including `localhost`), or an IPv4 address.  Subdomains may use the wildcard (`*`) to match any string.  Must be non-empty when `behavior` is `ALLOW_SPECIFIC_ORIGINS` and must be omitted or empty when `behavior` is `ALLOW_NO_ORIGINS`.  Limited to 20 values.
     */
    origins?: string[];
}

export interface ApplicationOidcOptionsMobileApp {
    /**
     * A string that specifies the bundle associated with the application, for push notifications in native apps. The value of the `bundle_id` property is unique per environment, and once defined, is immutable.  This field is immutable and will trigger a replace plan if changed.
     */
    bundleId?: string;
    /**
     * The unique identifier for the app on the device and in the Huawei Mobile Service AppGallery. The value of this property is unique per environment, and once defined, is immutable.  Required with `huawei_package_name`.  This field is immutable and will trigger a replace plan if changed.
     */
    huaweiAppId?: string;
    /**
     * The package name associated with the application, for push notifications in native apps. The value of this property is unique per environment, and once defined, is immutable.  Required with `huawei_app_id`.  This field is immutable and will trigger a replace plan if changed.
     */
    huaweiPackageName?: string;
    /**
     * A single object that specifies mobile application integrity detection settings.
     */
    integrityDetection: outputs.ApplicationOidcOptionsMobileAppIntegrityDetection;
    /**
     * A string that specifies the package name associated with the application, for push notifications in native apps. The value of the `package_name` property is unique per environment, and once defined, is immutable.  This field is immutable and will trigger a replace plan if changed.
     */
    packageName?: string;
    /**
     * The amount of time a passcode should be displayed before being replaced with a new passcode - must be between `30` and `60` seconds.  Defaults to `30`.
     */
    passcodeRefreshSeconds: number;
    /**
     * A string that specifies a URI prefix that enables direct triggering of the mobile application when scanning a QR code. The URI prefix can be set to a universal link with a valid value (which can be a URL address that starts with `HTTP://` or `HTTPS://`, such as `https://www.bxretail.org`), or an app schema, which is just a string and requires no special validation.
     */
    universalAppLink?: string;
}

export interface ApplicationOidcOptionsMobileAppIntegrityDetection {
    /**
     * A single object that specifies settings for the caching duration of successful integrity detection calls.  Every attestation request entails a certain time tradeoff. You can choose to cache successful integrity detection calls for a predefined duration, between a minimum of 1 minute and a maximum of 48 hours. If integrity detection is ENABLED, the cache duration must be set.
     */
    cacheDuration?: outputs.ApplicationOidcOptionsMobileAppIntegrityDetectionCacheDuration;
    /**
     * A boolean that specifies whether device integrity detection takes place on mobile devices.  Defaults to `false`.
     */
    enabled: boolean;
    /**
     * You can enable device integrity checking separately for Android and iOS by setting `enabled` to `true` and then using `excluded_platforms` to specify the OS where you do not want to use device integrity checking. The values to use are `GOOGLE` and `IOS` (all upper case). Note that this is implemented as an array even though currently you can only include a single value.  If `GOOGLE` is not included in this list, the `google_play` attribute block must be configured.
     */
    excludedPlatforms?: string[];
    /**
     * A single object that describes Google Play Integrity API credential settings for Android device integrity detection.  Required when `excluded_platforms` is unset or does not include `GOOGLE`.
     */
    googlePlay?: outputs.ApplicationOidcOptionsMobileAppIntegrityDetectionGooglePlay;
}

export interface ApplicationOidcOptionsMobileAppIntegrityDetectionCacheDuration {
    /**
     * An integer that specifies the number of minutes or hours that specify the duration between successful integrity detection calls.
     */
    amount: number;
    /**
     * A string that specifies the time units of the cache `amount` parameter.  Options are `HOURS`, `MINUTES`.  Defaults to `MINUTES`.
     */
    units: string;
}

export interface ApplicationOidcOptionsMobileAppIntegrityDetectionGooglePlay {
    /**
     * Play Integrity verdict decryption key from your Google Play Services account. This parameter must be provided if you have set `verification_type` to `INTERNAL`.  Conflicts with `service_account_credentials_json`.
     */
    decryptionKey?: string;
    /**
     * Contents of the JSON file that represents your Service Account Credentials. This parameter must be provided if you have set `verification_type` to `GOOGLE`.  Conflicts with `decryption_key`, `verification_key`.
     */
    serviceAccountCredentialsJson?: string;
    /**
     * Play Integrity verdict signature verification key from your Google Play Services account. This parameter must be provided if you have set `verification_type` to `INTERNAL`.  Conflicts with `service_account_credentials_json`.
     */
    verificationKey?: string;
    /**
     * The type of verification that should be used.  Options are `GOOGLE`, `INTERNAL`.  Using internal verification will not count against your Google API call quota. The value you select for this attribute determines what other parameters you must provide. When set to `GOOGLE`, you must provide `service_account_credentials_json`. When set to `INTERNAL`, you must provide both `decryption_key` and `verification_key`.
     */
    verificationType: string;
}

export interface ApplicationResourceParent {
    /**
     * A string that specifies the application resource's parent ID.
     */
    id: string;
    /**
     * The application resource's parent type.  Options are `PING_ONE_RESOURCE`.
     */
    type: string;
}

export interface ApplicationResourcePermissionResource {
    /**
     * A string that specifies the ID for the associated application resource.
     */
    id: string;
    /**
     * A string that represents the name of the associated application resource.
     */
    name: string;
}

export interface ApplicationSamlOptions {
    /**
     * A list of string that specifies the Assertion Consumer Service URLs. The first URL in the list is used as default (there must be at least one URL).
     */
    acsUrls: string[];
    /**
     * An integer that specifies the assertion validity duration in seconds.
     */
    assertionDuration: number;
    /**
     * A boolean that specifies whether the SAML assertion itself should be signed.  Defaults to `true`.
     */
    assertionSignedEnabled: boolean;
    /**
     * A single object that allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application. If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. `/as/authorize` and `/as/token`).  This is legacy behavior, and it is recommended that applications migrate to include specific CORS settings.
     */
    corsSettings?: outputs.ApplicationSamlOptionsCorsSettings;
    /**
     * A string that specfies a default URL used as the `RelayState` parameter by the IdP to deep link into the application after authentication. This value can be overridden by the `applicationUrl` query parameter for [GET Identity Provider Initiated SSO](https://apidocs.pingidentity.com/pingone/platform/v1/api/#get-identity-provider-initiated-sso). Although both of these parameters are generally URLs, because they are used as deep links, this is not enforced. If neither `defaultTargetUrl` nor `applicationUrl` is specified during a SAML authentication flow, no `RelayState` value is supplied to the application. The `defaultTargetUrl` (or the `applicationUrl`) value is passed to the SAML application’s ACS URL as a separate `RelayState` key value (not within the SAMLResponse key value).
     */
    defaultTargetUrl?: string;
    /**
     * A boolean that specifies whether `requestedAuthnContext` is taken into account in policy decision-making.
     */
    enableRequestedAuthnContext?: boolean;
    /**
     * A string that specifies the custom home page URL for the application.
     */
    homePageUrl?: string;
    /**
     * SAML application assertion/response signing key settings.  Use with `assertion_signed_enabled` to enable assertion signing and/or `response_is_signed` to enable response signing.  It's highly recommended, and best practice, to define signing key settings for the configured SAML application.  However if this property is omitted, the default signing certificate for the environment is used.  This parameter will become a required field in the next major release of the provider.
     */
    idpSigningKey: outputs.ApplicationSamlOptionsIdpSigningKey;
    /**
     * A string that specifies the format of the Subject NameID attibute in the SAML assertion.
     */
    nameidFormat?: string;
    /**
     * A boolean that specifies whether the SAML assertion response itself should be signed.  Defaults to `false`.
     */
    responseIsSigned: boolean;
    /**
     * A string that specifies the binding protocol to be used for the logout response.  Options are `HTTP_POST`, `HTTP_REDIRECT`.  Existing configurations with no data default to `HTTP_POST`.  Defaults to `HTTP_POST`.
     */
    sloBinding: string;
    /**
     * A string that specifies the logout endpoint URL. This is an optional property. However, if a logout endpoint URL is not defined, logout actions result in an error.
     */
    sloEndpoint?: string;
    /**
     * A string that specifies the endpoint URL to submit the logout response. If a value is not provided, the `slo_endpoint` property value is used to submit SLO response.
     */
    sloResponseEndpoint?: string;
    /**
     * An integer that defines how long (hours) PingOne can exchange logout messages with the application, specifically a logout request from the application, since the initial request.  The minimum value is `0` hour and the maximum is `24` hours.
     */
    sloWindow?: number;
    /**
     * A single object that specifies settings for PingOne to encrypt SAML assertions to be sent to the application. Assertions are not encrypted by default.
     */
    spEncryption?: outputs.ApplicationSamlOptionsSpEncryption;
    /**
     * A string that specifies the service provider entity ID used to lookup the application. This is a required property and is unique within the environment.
     */
    spEntityId: string;
    /**
     * A single object item that specifies SP signature verification settings.
     */
    spVerification?: outputs.ApplicationSamlOptionsSpVerification;
    /**
     * A string that specifies the type associated with the application.  Options are `CUSTOM_APP`, `WEB_APP`.  Defaults to `WEB_APP`.  This field is immutable and will trigger a replace plan if changed.
     */
    type: string;
}

export interface ApplicationSamlOptionsCorsSettings {
    /**
     * A string that specifies the behavior of how Authorization and Authentication APIs interact with CORS requests that reference the application.  Options are `ALLOW_NO_ORIGINS` (rejects all CORS requests), `ALLOW_SPECIFIC_ORIGINS` (rejects all CORS requests except those listed in `origins`).
     */
    behavior: string;
    /**
     * A set of strings that represent the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value must be a `http` or `https` URL without a path.  The host may be a domain name (including `localhost`), or an IPv4 address.  Subdomains may use the wildcard (`*`) to match any string.  Must be non-empty when `behavior` is `ALLOW_SPECIFIC_ORIGINS` and must be omitted or empty when `behavior` is `ALLOW_NO_ORIGINS`.  Limited to 20 values.
     */
    origins?: string[];
}

export interface ApplicationSamlOptionsIdpSigningKey {
    /**
     * Specifies the signature algorithm of the key. For RSA keys, options are `SHA256withRSA`, `SHA384withRSA` and `SHA512withRSA`. For elliptical curve (EC) keys, options are `SHA256withECDSA`, `SHA384withECDSA` and `SHA512withECDSA`.
     */
    algorithm: string;
    /**
     * An ID for the certificate key pair to be used by the identity provider to sign assertions and responses.  Must be a valid PingOne resource ID.
     */
    keyId: string;
}

export interface ApplicationSamlOptionsSpEncryption {
    /**
     * The algorithm to use when encrypting assertions.  Options are `AES_128`, `AES_256`, `TRIPLEDES`.
     */
    algorithm: string;
    /**
     * A single object that specifies the certificate settings used to encrypt SAML assertions.
     */
    certificate: outputs.ApplicationSamlOptionsSpEncryptionCertificate;
}

export interface ApplicationSamlOptionsSpEncryptionCertificate {
    /**
     * A string that specifies the unique identifier of the encryption public certificate that has been uploaded to PingOne.
     */
    id: string;
}

export interface ApplicationSamlOptionsSpVerification {
    /**
     * A boolean that specifies whether the Authn Request signing should be enforced.  Defaults to `false`.
     */
    authnRequestSigned: boolean;
    /**
     * A list that specifies the certificate IDs used to verify the service provider signature.  Values must be valid PingOne resource IDs.
     */
    certificateIds: string[];
}

export interface ApplicationSecretPrevious {
    /**
     * A timestamp that specifies how long this secret is saved (and can be used) before it expires. Supported time range is 1 minute to 30 days.
     */
    expiresAt?: string;
    /**
     * A timestamp that specifies when the previous secret was last used.
     */
    lastUsed: string;
    /**
     * A string that specifies the previous application secret. This property is returned in the response if the previous secret is not expired.
     */
    secret: string;
}

export interface AuthorizeApiServiceAccessControl {
    /**
     * A single object that defines if the operation will use custom policy rather than the "Group" or "Scope" access control requirement.
     */
    custom: outputs.AuthorizeApiServiceAccessControlCustom;
}

export interface AuthorizeApiServiceAccessControlCustom {
    /**
     * A boolean that, if set to `true`, means the custom policy will be used for the endpoint.  Defaults to `false`.  This field is immutable and will trigger a replace plan if changed.
     */
    enabled: boolean;
}

export interface AuthorizeApiServiceAuthorizationServer {
    /**
     * A string that specifies the UUID of the custom PingOne resource. The resource defines the characteristics of the OAuth 2.0 access tokens used to get access to the APIs on the API service such as the audience and scopes. This property must identify a PingOne resource with a `type` property value of `CUSTOM`.
     */
    resourceId?: string;
    /**
     * A string that specifies the type of authorization server that will issue access tokens. Must be the same value as the `directory.type` field. If `EXTERNAL`, the `resource` field must not be provided.  Options are `EXTERNAL`, `PINGONE_SSO`.  Defaults to `PINGONE_SSO`.  This field is immutable and will trigger a replace plan if changed.
     */
    type: string;
}

export interface AuthorizeApiServiceDeploymentAuthorizationVersion {
    /**
     * A string that specifies the UUID of the last deployed policy authorization version. This is present only if custom polcies are enabled and the API service has been deployed at least once.
     */
    id: string;
}

export interface AuthorizeApiServiceDeploymentDecisionEndpoint {
    /**
     * A string that specifies the UUID of the decision endpoint.
     */
    id: string;
}

export interface AuthorizeApiServiceDeploymentPolicy {
    /**
     * A string that specifies the UUID of the root policy.
     */
    id: string;
}

export interface AuthorizeApiServiceDeploymentStatus {
    /**
     * A string that describes the deployment status code. For possible values, see [Deployment status codes](https://apidocs.pingidentity.com/pingone/platform/v1/api/#service-deployment-status-codes).
     */
    code: string;
    /**
     * A single object that describes properties related to an error status of the API service deployment.
     */
    error: outputs.AuthorizeApiServiceDeploymentStatusError;
}

export interface AuthorizeApiServiceDeploymentStatusError {
    /**
     * A string that describes a general fault code that identifies the the type of error. See [Error codes](https://apidocs.pingidentity.com/pingone/platform/v1/api/#error-codes).
     */
    code: string;
    /**
     * A string that specifies the UUID of the root policy.
     */
    id: string;
    /**
     * A string that describes a short, human-readable description of the error.
     */
    message: string;
}

export interface AuthorizeApiServiceDirectory {
    /**
     * A string that specifies the type of directory that will be used to issue access tokens.  Options are `EXTERNAL`, `PINGONE_SSO`.  Defaults to `PINGONE_SSO`.
     */
    type: string;
}

export interface AuthorizeApiServiceOperationAccessControl {
    /**
     * A single object that defines the group membership requirements for the operation.
     */
    group?: outputs.AuthorizeApiServiceOperationAccessControlGroup;
    /**
     * A single object that defines permission requirements for the operation.
     */
    permission?: outputs.AuthorizeApiServiceOperationAccessControlPermission;
    /**
     * A single object that defines scope membership requirements for the operation.
     */
    scope?: outputs.AuthorizeApiServiceOperationAccessControlScope;
}

export interface AuthorizeApiServiceOperationAccessControlGroup {
    /**
     * A set of objects that define the access requirements for the operation. The end user must be a member of one or more of these groups to gain access to the operation. The ID must reference a group that exists at the time the data is persisted. There is no referential integrity between a group and this configuration. If a group is subsequently deleted, the access control configuration will continue to reference that group. The set must not contain more than 25 elements.
     */
    groups: outputs.AuthorizeApiServiceOperationAccessControlGroupGroup[];
}

export interface AuthorizeApiServiceOperationAccessControlGroupGroup {
    /**
     * A string that specifies the UUID that represents the ID of the PingOne group. Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface AuthorizeApiServiceOperationAccessControlPermission {
    /**
     * A string that specifies the application permission ID that defines the access requirements for the operation. The end user must be entitled to the specified application permission to gain access to the operation.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface AuthorizeApiServiceOperationAccessControlScope {
    /**
     * A string that specifies the match type of the scope rule.  Options are `ALL` (the client must be authorized with all scopes configured in the `scopes` array to obtain access), `ANY` (the client must be authorized with one or more of the scopes configured in the `scopes` array to obtain access).
     */
    matchType?: string;
    /**
     * A set of objects that specify the scopes that define the access requirements for the operation. The client must be authorized with `ANY` or `ALL` of the scopes to be granted access, depending on the `match_type` field value.
     */
    scopes: outputs.AuthorizeApiServiceOperationAccessControlScopeScope[];
}

export interface AuthorizeApiServiceOperationAccessControlScopeScope {
    /**
     * A string that specifies the ID of the scope.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface AuthorizeApiServiceOperationPath {
    /**
     * A string that specifies the pattern used to identify the path or paths for the operation. The semantics of the pattern are determined by the type. For any type, the pattern can contain characters that are otherwise invalid in a URL path. Invalid characters are handled by performing matching against a percent-decoded HTTP request target path. This allows an administrator to configure patterns without worrying about percent encoding special characters.
     * When the `type` is `PARAMETER`, the syntax outlined in the table below is enforced. Additionally, the pattern must contain a wildcard, double wildcard or named parameter. When the `type` is `EXACT`, the pattern can be any byte sequence except for ASCII control characters such as line feeds or carriage returns. The length of the pattern cannot exceed 2048 characters. The path pattern must not contain empty path segments such as `/../`, `//`, and `/./`.
     */
    pattern: string;
    /**
     * A string that specifies the type of the pattern.  Options are `EXACT` (the verbatim pattern is compared against the path from the request using a case-sensitive comparison), `PARAMETER` (the pattern is compared against the path from the request using a case-sensitive comparison, using the syntax below to encode wildcards and named parameters).
     */
    type: string;
}

export interface AuthorizeApplicationRolePermissionResource {
    /**
     * A string that describes the ID of the application resource associated with this permission.
     */
    id: string;
    /**
     * A string that describes the name of the application resource associated with this permission.
     */
    name: string;
}

export interface BrandingSettingsLogoImage {
    /**
     * The URL or fully qualified path to the logo file used for branding.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.
     */
    href: string;
    /**
     * The ID of the logo image.  This can be retrieved from the `id` parameter of the `pingone.Image` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface BrandingThemeBackgroundImage {
    /**
     * The URL or fully qualified path to the background image file used for branding.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.
     */
    href: string;
    /**
     * The ID of the background image.  This can be retrieved from the `id` parameter of the `pingone.Image` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface BrandingThemeLogo {
    /**
     * The URL or fully qualified path to the logo file used for branding.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.
     */
    href: string;
    /**
     * The ID of the logo image.  This can be retrieved from the `id` parameter of the `pingone.Image` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface CredentialIssuanceRuleAutomation {
    /**
     * The method the service uses to issue credentials with the credential issuance rule. Can be `PERIODIC` or `ON_DEMAND`.
     */
    issue: string;
    /**
     * The method the service uses to revoke credentials with the credential issuance rule. Can be `PERIODIC` or `ON_DEMAND`.
     */
    revoke: string;
    /**
     * The method the service uses to update credentials with the credential issuance rule. Can be `PERIODIC` or `ON_DEMAND`.
     */
    update: string;
}

export interface CredentialIssuanceRuleFilter {
    /**
     * Array of one or more identifiers (UUIDs) of groups, any of which a user must belong for the credential issuance rule to apply.
     */
    groupIds?: string[];
    /**
     * Array of one or more identifiers (UUIDs) of populations, any of which a user must belong for the credential issuance rule to apply.
     */
    populationIds?: string[];
    /**
     * A SCIM query that selects users to which the credential issuance rule applies.
     */
    scim?: string;
}

export interface CredentialIssuanceRuleNotification {
    /**
     * Array of methods for notifying the user; can be `EMAIL`, `SMS`, or both.
     */
    methods: string[];
    /**
     * Contains template parameters.
     */
    template?: outputs.CredentialIssuanceRuleNotificationTemplate;
}

export interface CredentialIssuanceRuleNotificationTemplate {
    /**
     * A string that specifies the ISO language code used for the notification.  Options are `aa`, `ab`, `ae`, `af`, `af-ZA`, `ak`, `am`, `an`, `ar`, `ar-AE`, `ar-BH`, `ar-DZ`, `ar-EG`, `ar-IQ`, `ar-JO`, `ar-KW`, `ar-LB`, `ar-LY`, `ar-MA`, `ar-OM`, `ar-QA`, `ar-SA`, `ar-SY`, `ar-TN`, `ar-YE`, `as`, `av`, `ay`, `az`, `az-AZ`, `ba`, `be`, `be-BY`, `bg`, `bg-BG`, `bi`, `bm`, `bn`, `bo`, `br`, `bs`, `bs-BA`, `ca`, `ca-ES`, `ce`, `ch`, `cmn-CN`, `cmn-TW`, `co`, `cr`, `cs`, `cs-CZ`, `cu`, `cv`, `cy`, `cy-GB`, `da`, `da-DK`, `de`, `de-AT`, `de-CH`, `de-DE`, `de-LI`, `de-LU`, `dv`, `dv-MV`, `dz`, `ee`, `el`, `el-GR`, `en`, `en-AU`, `en-BZ`, `en-CA`, `en-CB`, `en-GB`, `en-GB-WLS`, `en-IE`, `en-IN`, `en-JM`, `en-NZ`, `en-PH`, `en-TT`, `en-US`, `en-ZA`, `en-ZW`, `eo`, `es`, `es-AR`, `es-BO`, `es-CL`, `es-CO`, `es-CR`, `es-DO`, `es-EC`, `es-ES`, `es-GT`, `es-HN`, `es-MX`, `es-NI`, `es-PA`, `es-PE`, `es-PR`, `es-PY`, `es-SV`, `es-US`, `es-UY`, `es-VE`, `et`, `et-EE`, `eu`, `eu-ES`, `fa`, `fa-IR`, `ff`, `fi`, `fi-FI`, `fj`, `fo`, `fo-FO`, `fr`, `fr-BE`, `fr-CA`, `fr-CH`, `fr-FR`, `fr-LU`, `fr-MC`, `fy`, `ga`, `gd`, `gl`, `gl-ES`, `gn`, `gu`, `gu-IN`, `gv`, `ha`, `he`, `he-IL`, `hi`, `hi-IN`, `ho`, `hr`, `hr-BA`, `hr-HR`, `ht`, `hu`, `hu-HU`, `hy`, `hy-AM`, `hz`, `ia`, `id`, `id-ID`, `ie`, `ig`, `ii`, `ik`, `io`, `is`, `is-IS`, `it`, `it-CH`, `it-IT`, `iu`, `ja`, `ja-JP`, `jv`, `ka`, `ka-GE`, `kg`, `ki`, `kj`, `kk`, `kk-KZ`, `kl`, `km`, `kn`, `kn-IN`, `ko`, `ko-KR`, `kok`, `kok-IN`, `kr`, `ks`, `ku`, `kv`, `kw`, `ky`, `ky-KG`, `la`, `lb`, `lg`, `li`, `ln`, `lo`, `lt`, `lt-LT`, `lu`, `lv`, `lv-LV`, `mg`, `mh`, `mi`, `mi-NZ`, `mk`, `mk-MK`, `ml`, `mn`, `mn-MN`, `mr`, `mr-IN`, `ms`, `ms-BN`, `ms-MY`, `mt`, `mt-MT`, `my`, `na`, `nb`, `nb-NO`, `nd`, `ne`, `ng`, `nl`, `nl-BE`, `nl-NL`, `nn`, `nn-NO`, `no`, `nr`, `ns`, `ns-ZA`, `nv`, `ny`, `oc`, `oj`, `om`, `or`, `os`, `pa`, `pa-IN`, `pi`, `pl`, `pl-PL`, `ps`, `ps-AR`, `pt`, `pt-BR`, `pt-PT`, `qu`, `qu-BO`, `qu-EC`, `qu-PE`, `rm`, `rn`, `ro`, `ro-RO`, `ru`, `ru-RU`, `rw`, `sa`, `sa-IN`, `sc`, `sd`, `se`, `se-FI`, `se-NO`, `se-SE`, `sg`, `si`, `sk`, `sk-SK`, `sl`, `sl-SI`, `sm`, `sn`, `so`, `sq`, `sq-AL`, `sr`, `sr-BA`, `sr-SP`, `ss`, `st`, `su`, `sv`, `sv-FI`, `sv-SE`, `sw`, `sw-KE`, `syr`, `syr-SY`, `ta`, `ta-IN`, `te`, `te-IN`, `tg`, `th`, `th-TH`, `ti`, `tk`, `tl`, `tl-PH`, `tn`, `tn-ZA`, `to`, `tr`, `tr-TR`, `ts`, `tt`, `tt-RU`, `tw`, `ty`, `ug`, `uk`, `uk-UA`, `ur`, `ur-PK`, `uz`, `uz-UZ`, `ve`, `vi`, `vi-VN`, `vo`, `wa`, `wo`, `xh`, `xh-ZA`, `yi`, `yo`, `yue-CN`, `za`, `zh`, `zh-CN`, `zh-HK`, `zh-MO`, `zh-SG`, `zh-TW`, `zu`, `zu-ZA`.
     */
    locale: string;
    /**
     * The unique user-defined name for the content variant that contains the message text used for the notification.
     */
    variant: string;
}

export interface CredentialIssuerProfileTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
}

export interface CredentialTypeMetadata {
    /**
     * The URL or fully qualified path to the image file used for the credential background.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.  Image size must not exceed 50 KB.
     */
    backgroundImage?: string;
    /**
     * A numnber indicating the percent opacity of the background image in the credential. High percentage opacity may make text on the credential difficult to read.
     */
    bgOpacityPercent?: number;
    /**
     * A string containing a 6-digit hexadecimal color code specifying the color of the credential.
     */
    cardColor?: string;
    /**
     * Indicates a number (between 1-3) of columns to display visible fields on the credential.
     */
    columns?: number;
    /**
     * Description of the credential.
     */
    description?: string;
    /**
     * In a credential, the information is stored as key-value pairs where `fields` defines those key-value pairs. Effectively, `fields.title` is the key and its value is `fields.value` or extracted from the PingOne Directory attribute named in `fields.attribute`.
     */
    fields: outputs.CredentialTypeMetadataField[];
    /**
     * The URL or fully qualified path to the image file used for the credential logo.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.  Image size must not exceed 25 KB.
     */
    logoImage?: string;
    /**
     * Name of the credential.
     */
    name?: string;
    /**
     * A string containing a 6-digit hexadecimal color code specifying the color of the credential text.
     */
    textColor?: string;
    /**
     * Number version of this credential.
     */
    version: number;
}

export interface CredentialTypeMetadataField {
    /**
     * Name of the PingOne Directory attribute. Present if `field.type` is `Directory Attribute`.
     */
    attribute?: string;
    /**
     * Specifies how an image is stored in the credential field.  Options are `BASE64_STRING`, `INCLUDE_FILE`, `REFERENCE_FILE`.
     */
    fileSupport?: string;
    /**
     * Identifier of the field formatted as `<fields.type> > <fields.title>`.
     */
    id: string;
    /**
     * Specifies whether the field should be visible to viewers of the credential.
     */
    isVisible?: boolean;
    /**
     * Specifies whether the field is required for the credential.
     */
    required: boolean;
    /**
     * Descriptive text when showing the field.
     */
    title?: string;
    /**
     * Specifies the type of data in the credential field.  Options are `Alphanumeric Text`, `Directory Attribute`, `Issued Timestamp`.
     */
    type: string;
    /**
     * The text to appear on the credential for a `field.type` of `Alphanumeric Text`.
     */
    value?: string;
}

export interface CustomDomainVerifyTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m", as a time to wait for DNS record changes to propagate for validation. Valid time units are "s" (seconds), "m" (minutes), "h" (hours). The default is 60 minutes.
     */
    create?: string;
}

export interface EnvironmentService {
    /**
     * A set of objects that specify custom bookmark links for the service.
     */
    bookmarks?: outputs.EnvironmentServiceBookmark[];
    /**
     * A string that specifies the custom console URL to set.  Generally used with services that are deployed separately to the PingOne SaaS service, such as `PingFederate`, `PingAccess`, `PingDirectory`, `PingAuthorize` and `PingCentral`.
     */
    consoleUrl?: string;
    /**
     * A set of string tags to apply upon environment creation.  Only configurable when the service `type` is `DaVinci`.  Options are `DAVINCI_MINIMAL` (allows for a creation of an environment without example/demo configuration in the DaVinci service).  This field is immutable and will trigger a replace plan if changed.
     */
    tags?: string[];
    /**
     * A string that specifies the service type to enable in the environment.  Options are `APIIntelligence`, `Authorize`, `Credentials`, `DaVinci`, `MFA`, `PingAccess`, `PingAuthorize`, `PingCentral`, `PingDirectory`, `PingFederate`, `PingID`, `Risk`, `SSO`, `Verify`.
     */
    type: string;
}

export interface EnvironmentServiceBookmark {
    /**
     * A string that specifies the bookmark name.
     */
    name: string;
    /**
     * A string that represents the bookmark URL.
     */
    url: string;
}

export interface FormComponents {
    /**
     * A set of objects that specifies the form fields that make up the form.
     */
    fields: outputs.FormComponentsField[];
}

export interface FormComponentsField {
    /**
     * **Required** when the `type` is one of `QR_CODE`, `RECAPTCHA_V2`.  A string that specifies the reCAPTCHA alignment.  Options are `CENTER`, `LEFT`, `RIGHT`.
     */
    alignment?: string;
    /**
     * Optional when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `PASSWORD`, `PASSWORD_VERIFY`, `RADIO`, `TEXT`.  A boolean that specifies whether the linked directory attribute is disabled.
     */
    attributeDisabled: boolean;
    /**
     * Optional when the `type` is one of `SLATE_TEXTBLOB`, `TEXTBLOB`.  A string that specifies the field's content (for example, HTML when the field type is `TEXTBLOB`.)
     */
    content?: string;
    /**
     * **Required** when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `FLOW_BUTTON`, `FLOW_LINK`, `PASSWORD`, `PASSWORD_VERIFY`, `QR_CODE`, `RADIO`, `TEXT`.  A string that specifies an identifier for the field component.
     */
    key?: string;
    /**
     * **Required** when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `FLOW_BUTTON`, `FLOW_LINK`, `PASSWORD`, `PASSWORD_VERIFY`, `RADIO`, `SUBMIT_BUTTON`, `TEXT`.  A string that specifies the field label.
     */
    label?: string;
    /**
     * Optional when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `PASSWORD`, `PASSWORD_VERIFY`, `RADIO`, `TEXT`.  A string that specifies how the field is rendered.  Options are `DEFAULT`, `FLOAT`.
     */
    labelMode?: string;
    /**
     * Optional when the `type` is one of `PASSWORD_VERIFY`.  A string that when a second field for verifies password is used, this property specifies the field label for that verify field.
     */
    labelPasswordVerify?: string;
    /**
     * **Required** when the `type` is one of `CHECKBOX`, `RADIO`, optional when the `type` is one of `COMBOBOX`, `DROPDOWN`, `PASSWORD`, `PASSWORD_VERIFY`, `TEXT`.  A string that specifies layout attributes for radio button and checkbox fields.  Options are `HORIZONTAL`, `VERTICAL`.
     */
    layout?: string;
    /**
     * **Required** when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `RADIO`.  An array of objects that specifies the unique list of options.
     */
    options?: outputs.FormComponentsFieldOption[];
    /**
     * A boolean that specifies whether the directory attribute option is disabled. Set to `true` if it references a PingOne directory attribute.
     */
    otherOptionAttributeDisabled: boolean;
    /**
     * A boolean that specifies whether the end user can type an entry that is not in a predefined list.
     */
    otherOptionEnabled: boolean;
    /**
     * A string that specifies the label for the other option in drop-down controls.
     */
    otherOptionInputLabel: string;
    /**
     * A string that specifies whether the form identifies that the choice is a custom choice not from a predefined list.
     */
    otherOptionKey: string;
    /**
     * A string that specifies the label for a custom or "other" choice in a list.
     */
    otherOptionLabel: string;
    /**
     * A single object that specifies the position of the form field in the form.  The combination of `col` and `row` must be unique between form fields.
     */
    position: outputs.FormComponentsFieldPosition;
    /**
     * **Required** when the `type` is one of `QR_CODE`.  A string that specifies the QR Code type.
     */
    qrCodeType?: string;
    /**
     * Optional when the `type` is one of `CHECKBOX`, `COMBOBOX`, `DROPDOWN`, `PASSWORD`, `PASSWORD_VERIFY`, `RADIO`, `TEXT`.  A boolean that specifies whether the field is required.
     */
    required: boolean;
    /**
     * Optional when the `type` is one of `QR_CODE`.  A boolean that specifies the border visibility.
     */
    showBorder: boolean;
    /**
     * Optional when the `type` is one of `PASSWORD`, `PASSWORD_VERIFY`.  A boolean that specifies whether to display password requirements to the user.
     */
    showPasswordRequirements: boolean;
    /**
     * **Required** when the `type` is one of `RECAPTCHA_V2`.  A string that specifies the reCAPTCHA size.  Options are `COMPACT`, `NORMAL`.
     */
    size?: string;
    /**
     * Optional when the `type` is one of `FLOW_BUTTON`, `FLOW_LINK`, `SUBMIT_BUTTON`.  A single object that describes style settings for the field.
     */
    styles?: outputs.FormComponentsFieldStyles;
    /**
     * **Required** when the `type` is one of `RECAPTCHA_V2`.  A string that specifies the reCAPTCHA theme.  Options are `DARK`, `LIGHT`.
     */
    theme?: string;
    /**
     * A string that specifies the type of form field.  Options are `CHECKBOX`, `COMBOBOX`, `DIVIDER`, `DROPDOWN`, `EMPTY_FIELD`, `ERROR_DISPLAY`, `FLOW_BUTTON`, `FLOW_LINK`, `PASSWORD`, `PASSWORD_VERIFY`, `QR_CODE`, `RADIO`, `RECAPTCHA_V2`, `SLATE_TEXTBLOB`, `SUBMIT_BUTTON`, `TEXT`, `TEXTBLOB`.
     */
    type: string;
    /**
     * **Required** when the `type` is one of `TEXT`, optional when the `type` is one of `PASSWORD`, `PASSWORD_VERIFY`.  An object containing validation data for the field.
     */
    validation?: outputs.FormComponentsFieldValidation;
}

export interface FormComponentsFieldOption {
    /**
     * A string that specifies the option's label in the form field that is shown to the end user.
     */
    label: string;
    /**
     * A string that specifies the option's value in the form field that is posted as form data.
     */
    value: string;
}

export interface FormComponentsFieldPosition {
    /**
     * An integer that specifies the column position of the form field in the form  (min = `0`; max = `3`).
     */
    col: number;
    /**
     * An integer that specifies the row position of the form field in the form (maximum number is `50`).
     */
    row: number;
    /**
     * An integer that specifies the width of the form field in the form (in percentage).
     */
    width?: number;
}

export interface FormComponentsFieldStyles {
    /**
     * A string that specifies the button alignment.  Options are `CENTER`, `LEFT`, `RIGHT`.
     */
    alignment?: string;
    /**
     * A string that specifies the button background color. The value must be a valid hexadecimal color.
     */
    backgroundColor?: string;
    /**
     * A string that specifies the button border color. The value must be a valid hexadecimal color.
     */
    borderColor?: string;
    /**
     * A boolean that specifies whether the button is enabled.
     */
    enabled: boolean;
    /**
     * An integer that specifies a custom height of the field (in pixels) when displayed in the form.
     */
    height?: number;
    /**
     * A single object that specifies custom padding styles for the field.
     */
    padding?: outputs.FormComponentsFieldStylesPadding;
    /**
     * A string that specifies the button text color. The value must be a valid hexadecimal color.
     */
    textColor?: string;
    /**
     * An integer that specifies the button width. Set as a percentage.
     */
    width?: number;
    /**
     * A string that specifies the unit to apply to the `width` parameter.  Options are `PERCENT`, `PIXELS`.
     */
    widthUnit?: string;
}

export interface FormComponentsFieldStylesPadding {
    /**
     * An integer that specifies the bottom padding (in pixels) to apply to the field.
     */
    bottom?: number;
    /**
     * An integer that specifies the left padding (in pixels) to apply to the field.
     */
    left?: number;
    /**
     * An integer that specifies the right padding (in pixels) to apply to the field.
     */
    right?: number;
    /**
     * An integer that specifies the top padding (in pixels) to apply to the field.
     */
    top?: number;
}

export interface FormComponentsFieldValidation {
    /**
     * A string that specifies the error message to be displayed when the field validation fails.  When configuring this parameter, the `regex` parameter is required.
     */
    errorMessage?: string;
    /**
     * A string that specifies a validation regular expression. The expression must be a valid regular expression string. This is a required property when the validation type is `CUSTOM`.
     */
    regex?: string;
    /**
     * A string that specifies the validation type.  Options are `CUSTOM`, `NONE`.
     */
    type: string;
}

export interface GatewayKerberos {
    /**
     * An integer that specifies the number of minutes for which the previous credentials are persisted.
     */
    retainPreviousCredentialsMins?: number;
    /**
     * A string that specifies the password for the Kerberos service account.
     */
    serviceAccountPassword?: string;
    /**
     * A string that specifies the Kerberos service account user principal name (for example, `username@bxretail.org`).
     */
    serviceAccountUpn: string;
}

export interface GatewayRadiusClient {
    /**
     * A string that specifies the IP address of the RADIUS client.
     */
    ip: string;
    /**
     * A string that specifies the shared secret for the RADIUS client. If this value is not provided, the shared secret specified with `radius_default_shared_secret` is used. If you are not providing a shared secret for the client, this parameter is optional.
     */
    sharedSecret?: string;
}

export interface GatewayRadiusNetworkPolicyServer {
    /**
     * A string that specifies the IP address of the Network Policy Server (NPS).
     */
    ip: string;
    /**
     * An integer that specifies the port number of the NPS.
     */
    port: number;
}

export interface GatewayUserTypes {
    /**
     * A boolean that, if set to `false`, the user cannot change the password in the remote LDAP directory. In this case, operations for forgotten passwords or resetting of passwords are not available to a user referencing this gateway.  Defaults to `false`.
     */
    allowPasswordChanges: boolean;
    /**
     * Identifies the user type. This correlates to the `password.external.gateway.userType.id` User property.
     */
    id: string;
    /**
     * A single object that describes the configurations for initially authenticating new users who will be migrated to PingOne. Note: If there are multiple users having the same user name, only the first user processed is provisioned.
     */
    newUserLookup?: outputs.GatewayUserTypesNewUserLookup;
    /**
     * A string that specifies the password authority for the user type.  Options are `LDAP`, `PING_ONE`.  If set to `PING_ONE`, PingOne authenticates with the external directory initially, then PingOne authenticates all subsequent sign-ons.
     */
    passwordAuthority: string;
    /**
     * A string that specifies the LDAP base domain name (DN) for this user type.
     */
    searchBaseDn: string;
    /**
     * A boolean that, if set to `true`, when users sign on through an LDAP Gateway client, user attributes are updated based on responses from the LDAP server.  Defaults to `false`.
     */
    updateUserOnSuccessfulAuthentication: boolean;
    /**
     * A list of strings that represent LDAP attribute names that uniquely identify the user, and link to users in PingOne.
     */
    userLinkAttributes: string[];
}

export interface GatewayUserTypesNewUserLookup {
    /**
     * A set of objects supplying a mapping of PingOne attributes to external LDAP attributes. One of the entries must be a mapping for `username`. This is required for the PingOne user schema.
     */
    attributeMappings: outputs.GatewayUserTypesNewUserLookupAttributeMapping[];
    /**
     * The LDAP user search filter to use to match users against the entered user identifier at login. For example, `(((uid=${identifier})(mail=${identifier}))`. Alternatively, this can be a search against the user directory.
     */
    ldapFilterPattern: string;
    /**
     * A string that specifies the ID of the population to use to create user entries during lookup.  Must be a valid PingOne resource ID.
     */
    populationId: string;
}

export interface GatewayUserTypesNewUserLookupAttributeMapping {
    /**
     * A string that specifies the name of a user attribute in PingOne. See [Users properties](https://apidocs.pingidentity.com/pingone/platform/v1/api/#users) for the complete list of available PingOne user attributes.
     */
    name: string;
    value: string;
}

export interface GetApplicationAccessControlGroupOptions {
    /**
     * A set that specifies the group IDs for the groups the actor must belong to for access to the application.
     */
    groups: string[];
    /**
     * A string that specifies the group type required to access the application.
     */
    type: string;
}

export interface GetApplicationExternalLinkOptions {
    /**
     * The custom home page URL for the application.  Both `http://` and `https://` URLs are permitted.
     */
    homePageUrl: string;
}

export interface GetApplicationIcon {
    /**
     * The HREF for the application icon.
     */
    href: string;
    /**
     * The ID for the application icon.
     */
    id: string;
}

export interface GetApplicationOidcOptions {
    /**
     * A boolean that, when set to `true`, if you attempt to reuse the refresh token, the authorization server immediately revokes the reused refresh token, as well as all descendant tokens.  Defaults to `true`.
     */
    additionalRefreshTokenReplayProtectionEnabled: boolean;
    /**
     * A boolean to specify whether wildcards are allowed in redirect URIs. For more information, see [Wildcards in Redirect URIs](https://docs.pingidentity.com/csh?context=p1_c_wildcard_redirect_uri).
     */
    allowWildcardInRedirectUris: boolean;
    /**
     * Certificate based authentication settings.
     */
    certificateBasedAuthentication: outputs.GetApplicationOidcOptionsCertificateBasedAuthentication;
    /**
     * A string that specifies the application ID used to authenticate to the authorization server.
     */
    clientId: string;
    /**
     * A single object that allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application. If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. `/as/authorize` and `/as/token`).  This is legacy behavior, and it is recommended that applications migrate to include specific CORS settings.
     */
    corsSettings: outputs.GetApplicationOidcOptionsCorsSettings;
    /**
     * A string that specifies an optional custom verification URI that is returned for the `/device_authorization` endpoint.
     */
    deviceCustomVerificationUri: string;
    /**
     * A string that describes a unique identifier within an environment for a device authorization grant flow to provide a short identifier to the application. This property is ignored when the `device_custom_verification_uri` property is configured.
     */
    devicePathId: string;
    /**
     * An integer that specifies the frequency (in seconds) for the client to poll the `/as/token` endpoint.
     */
    devicePollingInterval: number;
    /**
     * An integer that specifies the length of time (in seconds) that the `userCode` and `deviceCode` returned by the `/device_authorization` endpoint are valid.
     */
    deviceTimeout: number;
    /**
     * A list that specifies the grant type for the authorization request.
     */
    grantTypes: string[];
    /**
     * The custom home page URL for the application.  The provided URL is expected to use the `https://` schema.  The `http` schema is permitted where the host is `localhost` or `127.0.0.1`.
     */
    homePageUrl: string;
    /**
     * A string that specifies the URI to use for third-parties to begin the sign-on process for the application.
     */
    initiateLoginUri: string;
    /**
     * A string that specifies a JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `token_endpoint_auth_method`. This property is required when `token_endpoint_auth_method` is `PRIVATE_KEY_JWT` and the `jwks_url` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwks_url` property is empty. For more infornmation about signing the `request` property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).
     */
    jwks: string;
    /**
     * A string that specifies a URL (supports `https://` only) that provides access to a JWKS string that validates the signature of signed JWTs for applications that use the `PRIVATE_KEY_JWT` option for the `token_endpoint_auth_method`. This property is required when `token_endpoint_auth_method` is `PRIVATE_KEY_JWT` and the `jwks` property is empty. For more information, see [Create a private_key_jwt JWKS string](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-private_key_jwt-jwks-string). This property is also required if the optional `request` property JWT on the authorize endpoint is signed using the RS256 (or RS384, RS512) signing algorithm and the `jwks` property is empty. For more infornmation about signing the `request` property JWT, see [Create a request property JWT](https://apidocs.pingidentity.com/pingone/platform/v1/api/#create-a-request-property-jwt).
     */
    jwksUrl: string;
    /**
     * Mobile application integration settings.
     */
    mobileApp: outputs.GetApplicationOidcOptionsMobileApp;
    /**
     * A string that specifies whether pushed authorization requests (PAR) are required.
     */
    parRequirement: string;
    /**
     * An integer that specifies the pushed authorization request (PAR) timeout in seconds.
     */
    parTimeout: number;
    /**
     * A string that specifies how `PKCE` request parameters are handled on the authorize request.
     */
    pkceEnforcement: string;
    /**
     * A list of strings that specifies the URLs that the browser can be redirected to after logout.  The provided URLs are expected to use the `https://`, `http://` schema, or a custom mobile native schema (e.g., `org.bxretail.app://logout`).
     */
    postLogoutRedirectUris: string[];
    /**
     * A list of strings that specifies the allowed callback URIs for the authentication response.
     */
    redirectUris: string[];
    /**
     * An integer that specifies the lifetime in seconds of the refresh token.
     */
    refreshTokenDuration: number;
    /**
     * An integer that specifies the number of seconds a refresh token can be exchanged before re-authentication is required.
     */
    refreshTokenRollingDuration: number;
    /**
     * The number of seconds that a refresh token may be reused after having been exchanged for a new set of tokens.
     */
    refreshTokenRollingGracePeriodDuration: number;
    /**
     * A boolean that indicates that the Java Web Token (JWT) for the [request query](https://openid.net/specs/openid-connect-core-1_0.html#RequestObject) parameter is required to be signed. If `false` or null, a signed request object is not required. Both `support_unsigned_request_object` and this property cannot be set to `true`.  Defaults to `false`.
     */
    requireSignedRequestObject: boolean;
    /**
     * A list that specifies the code or token type returned by an authorization request.
     */
    responseTypes: string[];
    /**
     * A boolean that specifies whether the request query parameter JWT is allowed to be unsigned.
     */
    supportUnsignedRequestObject: boolean;
    /**
     * The URI for the application.
     */
    targetLinkUri: string;
    /**
     * A string that specifies the client authentication methods supported by the token endpoint.
     */
    tokenEndpointAuthMethod: string;
    /**
     * A string that specifies the type associated with the application.
     */
    type: string;
}

export interface GetApplicationOidcOptionsCertificateBasedAuthentication {
    /**
     * A string that represents a PingOne ID for the issuance certificate key.
     */
    keyId: string;
}

export interface GetApplicationOidcOptionsCorsSettings {
    /**
     * A string that represents the behavior of how Authorization and Authentication APIs interact with CORS requests that reference the application.  Options are `ALLOW_NO_ORIGINS` (rejects all CORS requests), `ALLOW_SPECIFIC_ORIGINS` (rejects all CORS requests except those listed in `origins`).
     */
    behavior: string;
    /**
     * A set of strings that represent the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value will be a `http` or `https` URL without a path.  The host may be a domain name (including `localhost`), or an IPv4 address.  Subdomains may use the wildcard (`*`) to match any string.  Is expected to be non-empty when `behavior` is `ALLOW_SPECIFIC_ORIGINS` and is expected to be omitted or empty when `behavior` is `ALLOW_NO_ORIGINS`.  Limited to 20 values.
     */
    origins: string[];
}

export interface GetApplicationOidcOptionsMobileApp {
    /**
     * A string that specifies the bundle associated with the application, for push notifications in native apps.
     */
    bundleId: string;
    /**
     * The unique identifier for the app on the device and in the Huawei Mobile Service AppGallery.
     */
    huaweiAppId: string;
    /**
     * The package name associated with the application, for push notifications in native apps.
     */
    huaweiPackageName: string;
    /**
     * Mobile application integrity detection settings.
     */
    integrityDetection: outputs.GetApplicationOidcOptionsMobileAppIntegrityDetection;
    /**
     * A string that specifies the package name associated with the application, for push notifications in native apps.
     */
    packageName: string;
    /**
     * The amount of time a passcode should be displayed before being replaced with a new passcode.
     */
    passcodeRefreshSeconds: number;
    /**
     * A string that specifies a URI prefix that enables direct triggering of the mobile application when scanning a QR code.
     */
    universalAppLink: string;
}

export interface GetApplicationOidcOptionsMobileAppIntegrityDetection {
    /**
     * Indicates the caching duration of successful integrity detection calls.
     */
    cacheDuration: outputs.GetApplicationOidcOptionsMobileAppIntegrityDetectionCacheDuration;
    /**
     * A boolean that specifies whether device integrity detection takes place on mobile devices.
     */
    enabled: boolean;
    /**
     * Indicates OS excluded from device integrity checking.
     */
    excludedPlatforms: string[];
    /**
     * A single object that describes Google Play Integrity API credential settings for Android device integrity detection.
     */
    googlePlay: outputs.GetApplicationOidcOptionsMobileAppIntegrityDetectionGooglePlay;
}

export interface GetApplicationOidcOptionsMobileAppIntegrityDetectionCacheDuration {
    /**
     * An integer that specifies the number of minutes or hours that specify the duration between successful integrity detection calls.
     */
    amount: number;
    /**
     * A string that specifies the cache duration time units.
     */
    units: string;
}

export interface GetApplicationOidcOptionsMobileAppIntegrityDetectionGooglePlay {
    /**
     * Play Integrity verdict decryption key from your Google Play Services account. This parameter must be provided if you have set `verification_type` to `INTERNAL`.  Cannot be set with `service_account_credentials_json`.
     */
    decryptionKey: string;
    /**
     * Contents of the JSON file that represents your Service Account Credentials.
     */
    serviceAccountCredentialsJson: string;
    /**
     * Play Integrity verdict signature verification key from your Google Play Services account.
     */
    verificationKey: string;
    /**
     * The type of verification.
     */
    verificationType: string;
}

export interface GetApplicationSamlOptions {
    /**
     * A list of string that specifies the Assertion Consumer Service URLs. The first URL in the list is used as default (there must be at least one URL).
     */
    acsUrls: string[];
    /**
     * An integer that specifies the assertion validity duration in seconds.
     */
    assertionDuration: number;
    /**
     * A boolean that specifies whether the SAML assertion itself should be signed.
     */
    assertionSignedEnabled: boolean;
    /**
     * A single object that allows customization of how the Authorization and Authentication APIs interact with CORS requests that reference the application. If omitted, the application allows CORS requests from any origin except for operations that expose sensitive information (e.g. `/as/authorize` and `/as/token`).  This is legacy behavior, and it is recommended that applications migrate to include specific CORS settings.
     */
    corsSettings: outputs.GetApplicationSamlOptionsCorsSettings;
    /**
     * A string that specfies a default URL used as the `RelayState` parameter by the IdP to deep link into the application after authentication. This value can be overridden by the `applicationUrl` query parameter for [GET Identity Provider Initiated SSO](https://apidocs.pingidentity.com/pingone/platform/v1/api/#get-identity-provider-initiated-sso). Although both of these parameters are generally URLs, because they are used as deep links, this is not enforced. If neither `defaultTargetUrl` nor `applicationUrl` is specified during a SAML authentication flow, no `RelayState` value is supplied to the application. The `defaultTargetUrl` (or the `applicationUrl`) value is passed to the SAML application’s ACS URL as a separate `RelayState` key value (not within the SAMLResponse key value).
     */
    defaultTargetUrl: string;
    /**
     * A boolean that specifies whether `requestedAuthnContext` is taken into account in policy decision-making.
     */
    enableRequestedAuthnContext: boolean;
    /**
     * A string that specifies the custom home page URL for the application.
     */
    homePageUrl: string;
    /**
     * SAML application assertion/response signing key settings.
     */
    idpSigningKey: outputs.GetApplicationSamlOptionsIdpSigningKey;
    /**
     * A string that specifies the format of the Subject NameID attibute in the SAML assertion.
     */
    nameidFormat: string;
    /**
     * A boolean that specifies whether the SAML assertion response itself should be signed.
     */
    responseIsSigned: boolean;
    /**
     * A string that specifies the binding protocol to be used for the logout response.
     */
    sloBinding: string;
    /**
     * A string that specifies the logout endpoint URL.
     */
    sloEndpoint: string;
    /**
     * A string that specifies the endpoint URL to submit the logout response.
     */
    sloResponseEndpoint: string;
    /**
     * An integer that defines how long (hours) PingOne can exchange logout messages with the application, specifically a logout request from the application, since the initial request.
     */
    sloWindow: number;
    /**
     * A single object that specifies settings for PingOne to encrypt SAML assertions to be sent to the application. Assertions are not encrypted by default.
     */
    spEncryption: outputs.GetApplicationSamlOptionsSpEncryption;
    /**
     * A string that specifies the service provider entity ID used to lookup the application. This is a required property and is unique within the environment.
     */
    spEntityId: string;
    /**
     * A single object that specifies SP signature verification settings.
     */
    spVerification: outputs.GetApplicationSamlOptionsSpVerification;
    /**
     * A string that specifies the type associated with the application.
     */
    type: string;
}

export interface GetApplicationSamlOptionsCorsSettings {
    /**
     * A string that represents the behavior of how Authorization and Authentication APIs interact with CORS requests that reference the application.  Options are `ALLOW_NO_ORIGINS` (rejects all CORS requests), `ALLOW_SPECIFIC_ORIGINS` (rejects all CORS requests except those listed in `origins`).
     */
    behavior: string;
    /**
     * A set of strings that represent the origins from which CORS requests to the Authorization and Authentication APIs are allowed.  Each value will be a `http` or `https` URL without a path.  The host may be a domain name (including `localhost`), or an IPv4 address.  Subdomains may use the wildcard (`*`) to match any string.  Is expected to be non-empty when `behavior` is `ALLOW_SPECIFIC_ORIGINS` and is expected to be omitted or empty when `behavior` is `ALLOW_NO_ORIGINS`.  Limited to 20 values.
     */
    origins: string[];
}

export interface GetApplicationSamlOptionsIdpSigningKey {
    /**
     * A string that specifies the signature algorithm of the key.
     */
    algorithm: string;
    /**
     * An ID for the certificate key pair to be used by the identity provider to sign assertions and responses.
     */
    keyId: string;
}

export interface GetApplicationSamlOptionsSpEncryption {
    /**
     * The algorithm to use when encrypting assertions.  Options are `AES_128`, `AES_256`, `TRIPLEDES`.
     */
    algorithm: string;
    /**
     * A single object that specifies the certificate settings used to encrypt SAML assertions.
     */
    certificate: outputs.GetApplicationSamlOptionsSpEncryptionCertificate;
}

export interface GetApplicationSamlOptionsSpEncryptionCertificate {
    /**
     * A string that specifies the unique identifier of the encryption public certificate that has been uploaded to PingOne.
     */
    id: string;
}

export interface GetApplicationSamlOptionsSpVerification {
    /**
     * A boolean that specifies whether the Authn Request signing should be enforced.
     */
    authnRequestSigned: boolean;
    /**
     * A list that specifies the certificate IDs used to verify the service provider signature.
     */
    certificateIds: string[];
}

export interface GetApplicationSecretPrevious {
    /**
     * A timestamp that specifies how long this secret is saved (and can be used) before it expires. Supported time range is 1 minute to 30 days.
     */
    expiresAt: string;
    /**
     * A timestamp that specifies when the previous secret was last used.
     */
    lastUsed: string;
    /**
     * A string that specifies the previous application secret. This property is returned in the response if the previous secret is not expired.
     */
    secret: string;
}

export interface GetCredentialIssuanceRuleAutomation {
    /**
     * The method the service uses to issue credentials with the credential issuance rule. Can be PERIODIC or ON_DEMAND.
     */
    issue: string;
    /**
     * The method the service uses to revoke credentials with the credential issuance rule. Can be PERIODIC or ON_DEMAND.
     */
    revoke: string;
    /**
     * The method the service uses to update credentials with the credential issuance rule. Can be PERIODIC or ON_DEMAND.
     */
    update: string;
}

export interface GetCredentialIssuanceRuleFilter {
    /**
     * Array of one or more identifiers (UUIDs) of groups, any of which a user must belong for the credential issuance rule to apply.
     */
    groupIds: string[];
    /**
     * Array of one or more identifiers (UUIDs) of populations, any of which a user must belong for the credential issuance rule to apply.
     */
    populationIds: string[];
    /**
     * A SCIM query that selects users to which the credential issuance rule applies.
     */
    scim: string;
}

export interface GetCredentialIssuanceRuleNotification {
    /**
     * Array of methods for notifying the user; can be EMAIL, SMS, or both.
     */
    methods: string[];
    /**
     * Contains template parameters.
     */
    template: outputs.GetCredentialIssuanceRuleNotificationTemplate;
}

export interface GetCredentialIssuanceRuleNotificationTemplate {
    /**
     * The ISO 2-character language code used for the notification; for example, en.
     */
    locale: string;
    /**
     * The unique user-defined name for the content variant that contains the message text used for the notification.
     */
    variant: string;
}

export interface GetCredentialTypeMetadata {
    /**
     * URL or fully qualified path to the image file used for the credential background.
     */
    backgroundImage: string;
    /**
     * Percent opacity of the background image in the credential.
     */
    bgOpacityPercent: number;
    /**
     * Color to show on the credential.
     */
    cardColor: string;
    /**
     * Number of columns to organize the fields displayed on the credential.
     */
    columns: number;
    /**
     * Description of the credential.
     */
    description: string;
    /**
     * Array of objects representing the credential fields.
     */
    fields: outputs.GetCredentialTypeMetadataField[];
    /**
     * URL or fully qualified path to the image file used for the credential logo.
     */
    logoImage: string;
    /**
     * Name of the credential.
     */
    name: string;
    /**
     * Color of the text to show on the credential.
     */
    textColor: string;
    /**
     * Version of this credential.
     */
    version: number;
}

export interface GetCredentialTypeMetadataField {
    /**
     * Name of the PingOne Directory attribute. Present if field.type is Directory Attribute.
     */
    attribute: string;
    /**
     * Specifies how an image is stored in the credential field.
     */
    fileSupport: string;
    /**
     * Identifier of the field object.
     */
    id: string;
    /**
     * Specifies whether the field should be visible to viewers of the credential.
     */
    isVisible: boolean;
    /**
     * Specifies whether the field is required for the credential.
     */
    required: boolean;
    /**
     * Descriptive text when showing the field.
     */
    title: string;
    /**
     * Type of data in the field.
     */
    type: string;
    /**
     * The text to appear on the credential for a field.type of Alphanumeric Text.
     */
    value: string;
}

export interface GetEnvironmentService {
    /**
     * A set of objects that specify custom bookmark links for the service.
     */
    bookmarks: outputs.GetEnvironmentServiceBookmark[];
    /**
     * A custom console URL set for the service.  Generally used with services that are deployed separately to the PingOne SaaS service, such as `PingFederate`, `PingAccess`, `PingDirectory`, `PingAuthorize` and `PingCentral`.
     */
    consoleUrl: string;
    /**
     * A set of tags applied upon environment creation.  Only configurable when the service `type` is `DaVinci`.  Options are `DAVINCI_MINIMAL`.
     */
    tags: string[];
    /**
     * The service type applied to the environment.  Valid options are `APIIntelligence`, `Authorize`, `Credentials`, `DaVinci`, `MFA`, `PingAccess`, `PingAuthorize`, `PingCentral`, `PingDirectory`, `PingFederate`, `PingID`, `Risk`, `SSO`, `Verify`.
     */
    type: string;
}

export interface GetEnvironmentServiceBookmark {
    /**
     * A string that specifies the bookmark name.
     */
    name: string;
    /**
     * A string that specifies the bookmark URL.
     */
    url: string;
}

export interface GetFlowPoliciesDataFilter {
    /**
     * The attribute name to filter on.  Must be one of the following values: `trigger.type`.
     */
    name: string;
    /**
     * The possible values (case sensitive) of the attribute defined in the `name` parameter to filter.
     */
    values: string[];
}

export interface GetFlowPolicyDavinciApplication {
    /**
     * A string that specifies the ID of the DaVinci application to which the flow policy is assigned.
     */
    id: string;
    /**
     * A string that specifies the name of the DaVinci application to which the flow policy is assigned.
     */
    name: string;
}

export interface GetFlowPolicyTrigger {
    /**
     * A string that specifies the type of the DaVinci flow policy.
     */
    type: string;
}

export interface GetGatewayKerberos {
    /**
     * An integer that specifies the number of minutes for which the previous credentials are persisted.
     */
    retainPreviousCredentialsMins: number;
    /**
     * A string that specifies the password for the Kerberos service account.
     */
    serviceAccountPassword: string;
    /**
     * The Kerberos service account user principal name (for example, `username@bxretail.org`).
     */
    serviceAccountUpn: string;
}

export interface GetGatewayRadiusClient {
    /**
     * The IP of the RADIUS client.
     */
    ip: string;
    /**
     * The shared secret for the RADIUS client. If this value is not provided, the shared secret specified with `default_shared_secret` is used.
     */
    sharedSecret: string;
}

export interface GetGatewayRadiusNetworkPolicyServer {
    /**
     * A string that specifies the IP address of the Network Policy Server (NPS).
     */
    ip: string;
    /**
     * An integer that specifies the port number of the NPS.
     */
    port: number;
}

export interface GetGatewayUserTypes {
    /**
     * A boolean that, if set to `false`, the user cannot change the password in the remote LDAP directory. In this case, operations for forgotten passwords or resetting of passwords are not available to a user referencing this gateway.
     */
    allowPasswordChanges: boolean;
    /**
     * Identifies the user type. This correlates to the `password.external.gateway.user_type.id` User property.
     */
    id: string;
    /**
     * The configurations for initially authenticating new users who will be migrated to PingOne. Note: If there are multiple users having the same user name, only the first user processed is provisioned.
     */
    newUserLookup: outputs.GetGatewayUserTypesNewUserLookup;
    /**
     * This can be either `PING_ONE` or `LDAP`. If set to `PING_ONE`, PingOne authenticates with the external directory initially, then PingOne authenticates all subsequent sign-ons.
     */
    passwordAuthority: string;
    /**
     * The LDAP base domain name (DN) for this user type.
     */
    searchBaseDn: string;
    /**
     * A boolean that, if set to `true`, when users sign on through an LDAP Gateway client, user attributes are updated based on responses from the LDAP server.
     */
    updateUserOnSuccessfulAuthentication: boolean;
    /**
     * Represents LDAP attribute names that uniquely identify the user, and link to users in PingOne.
     */
    userLinkAttributes: string[];
}

export interface GetGatewayUserTypesNewUserLookup {
    /**
     * A collection of properties that define how users should be provisioned in PingOne. The `user_type` block specifies which user properties in PingOne correspond to the user properties in an external LDAP directory. You can use an LDAP browser to view the user properties in the external LDAP directory.
     */
    attributeMappings: outputs.GetGatewayUserTypesNewUserLookupAttributeMapping[];
    /**
     * The LDAP user search filter to use to match users against the entered user identifier at login. For example, `(((uid=${identifier})(mail=${identifier}))`. Alternatively, this can be a search against the user directory.
     */
    ldapFilterPattern: string;
    /**
     * The ID of the population to use to create user entries during lookup.
     */
    populationId: string;
}

export interface GetGatewayUserTypesNewUserLookupAttributeMapping {
    /**
     * The name of a user attribute in PingOne. See [Users properties](https://apidocs.pingidentity.com/pingone/platform/v1/api/#users) for the complete list of available PingOne user attributes.
     */
    name: string;
    value: string;
}

export interface GetGroupsDataFilter {
    /**
     * The attribute name to filter on.  Must be one of the following values: `id`, `name`, `population.id`, `externalId`.
     */
    name: string;
    /**
     * The possible values (case sensitive) of the attribute defined in the `name` parameter to filter.
     */
    values: string[];
}

export interface GetLicenseAdvancedServices {
    /**
     * A single object that describes features related to **PingID** advanced service.
     */
    pingid: outputs.GetLicenseAdvancedServicesPingid;
}

export interface GetLicenseAdvancedServicesPingid {
    /**
     * A boolean that specifies whether the PingID advanced service is enabled in the organization.
     */
    included: boolean;
    /**
     * A string that specifies the type of PingID advanced service.
     */
    type: string;
}

export interface GetLicenseAuthorize {
    /**
     * A boolean that specifies whether to enable the PingOne Authorize API access management feature.
     */
    allowApiAccessManagement: boolean;
    /**
     * A boolean that specifies whether to enable the PingOne Authorize dynamic authorization feature.
     */
    allowDynamicAuthorization: boolean;
}

export interface GetLicenseCredentials {
    /**
     * A boolean that specifies whether to enable the PingOne Credentials feature.
     */
    allowCredentials: boolean;
}

export interface GetLicenseEnvironments {
    /**
     * A boolean that specifies whether the license supports creation of resources in the specified environment.
     */
    allowAddResources: boolean;
    /**
     * A boolean that specifies whether the license supports creation of application connections in the specified environment.
     */
    allowConnections: boolean;
    /**
     * A boolean that specifies whether the license supports creation of a custom domain in the specified environment.
     */
    allowCustomDomain: boolean;
    /**
     * A boolean that specifies whether the license supports using custom schema attributes in the specified environment.
     */
    allowCustomSchema: boolean;
    /**
     * A boolean that specifies whether production environments are allowed.
     */
    allowProduction: boolean;
    /**
     * An integer that specifies the maximum number of environments allowed.
     */
    max: number;
    /**
     * A string that specifies the allowed regions associated with environments.  Options are `AP`, `AU`, `CA`, `EU`, `NA`.
     */
    regions: string[];
}

export interface GetLicenseFraud {
    /**
     * A boolean that specifies whether to enable the account protection features of PingOne Fraud.
     */
    allowAccountProtection: boolean;
    /**
     * A boolean that specifies whether to enable the Malicious device detection features of PingOne Fraud.
     */
    allowBotMaliciousDeviceDetection: boolean;
}

export interface GetLicenseGateways {
    /**
     * A boolean that specifies whether to enable the Kerberos Gateway features of PingOne.
     */
    allowKerberosGateway: boolean;
    /**
     * A boolean that specifies whether to enable the LDAP Gateway features of PingOne.
     */
    allowLdapGateway: boolean;
    /**
     * A boolean that specifies whether to enable the RADIUS Gateway features of PingOne.
     */
    allowRadiusGateway: boolean;
}

export interface GetLicenseIntelligence {
    /**
     * A boolean that specifies whether your license permits you to configure advanced risk features.
     */
    allowAdvancedPredictors: boolean;
    /**
     * A boolean that specifies whether to use the intelligence anonymous network detection feature. For `TRIAL` (unpaid) licenses, the default value is `true`. For `ADMIN`, `GLOBAL`, `RISK`, and `MFARISK`, the default value is `true`.
     */
    allowAnonymousNetworkDetection: boolean;
    /**
     * A boolean that specifies whether the customer has opted in to allow user and event behavior analytics (UEBA) data collection.
     */
    allowDataConsent: boolean;
    /**
     * A boolean that specifies whether to use the intelligence geo-velocity feature. For `TRIAL` (unpaid) licenses, the default value is `true`. For `ADMIN`, `GLOBAL`, `RISK`, and `MFARISK`, the default value is `true`.
     */
    allowGeoVelocity: boolean;
    /**
     * A boolean that specifies whether to use the intelligence IP reputation feature. For `TRIAL` (unpaid) licenses, the default value is `true`. For `ADMIN`, `GLOBAL`, `RISK`, and `MFARISK`, the default value is `true`.
     */
    allowReputation: boolean;
    /**
     * A boolean that specifies whether your license permits you to configure risk features such as sign-on policies that include rules to detect anomalous changes to your locations (such as impossible travel). This capability is supported for `TRIAL`, `RISK`, and `MFARISK` license packages. Note: The sharing of user data to enable our machine-learning engine, which is integral to PingOne Risk, is captured in the license property `intelligence.allow_data_consent`, but it is not set to `true` by default in any license package. This license capability always requires active consent by the customer before it can be enabled, and if consent is given, then it allows the full scope of intelligence features included in PingOne Risk (and PingOne Risk plus MFA).
     */
    allowRisk: boolean;
}

export interface GetLicenseMfa {
    /**
     * A boolean that specifies whether Email OTP devices are allowed.
     */
    allowEmailOtp: boolean;
    /**
     * A boolean that specifies whether FIDO2 devices are allowed. For `TRIAL` (unpaid) licenses, the default value is `true`. For other license package types, adoption of the feature determines the default value.
     */
    allowFido2Devices: boolean;
    /**
     * A boolean that specifies whether the license supports sending notifications outside of the environment's whitelist.
     */
    allowNotificationOutsideWhitelist: boolean;
    /**
     * A boolean that specifies whether push notifications are allowed. For `TRIAL` (unpaid) licenses, the default value is `true`. For other license package types, adoption of the feature determines the default value.
     */
    allowPushNotification: boolean;
    /**
     * A boolean that specifies whether SMS OTP devices are allowed.
     */
    allowSmsOtp: boolean;
    /**
     * A boolean that specifies whether TOTP devices are allowed.
     */
    allowTotp: boolean;
    /**
     * A boolean that specifies whether Voice OTP devices are allowed.
     */
    allowVoiceOtp: boolean;
}

export interface GetLicenseOrchestrate {
    /**
     * A boolean that specifies whether the core orchestration services are allowed.
     */
    allowOrchestration: boolean;
}

export interface GetLicenseUsers {
    /**
     * A boolean that specifies whether the license supports using external identity providers in the specified environment.
     */
    allowIdentityProviders: boolean;
    /**
     * A boolean that specifies whether the license supports using inbound provisioning capabilities in the specified environment.
     */
    allowInboundProvisioning: boolean;
    /**
     * A boolean that specifies whether the license supports using My Account capabilities in the specified environment.
     */
    allowMyAccount: boolean;
    /**
     * A boolean that specifies whether the license supports sending password management notifications.
     */
    allowPasswordManagementNotifications: boolean;
    /**
     * A boolean that specifies whether the license supports using password only login capabilities in the specified environment.
     */
    allowPasswordOnlyAuthentication: boolean;
    /**
     * A boolean that specifies whether the license supports using password policies in the specified environment.
     */
    allowPasswordPolicy: boolean;
    /**
     * A boolean that specifies whether the license supports using provisioning capabilities in the specified environment.
     */
    allowProvisioning: boolean;
    /**
     * A boolean that specifies whether the license supports role assignments in the specified environment.
     */
    allowRoleAssignment: boolean;
    /**
     * A boolean that specifies whether the license supports allowing users to update their own profile.
     */
    allowUpdateSelf: boolean;
    /**
     * A boolean that specifies whether the license supports using verification flows in the specified environment.
     */
    allowVerificationFlow: boolean;
    /**
     * An integer that specifies a soft limit on the number of active identities across all environments on the license per year. This property is not visible if a value is not provided at the time the license is created.
     */
    annualActiveIncluded: number;
    /**
     * A boolean that specifies whether the license allows PingOne support.
     */
    entitledToSupport: boolean;
    /**
     * An integer that specifies the maximum number of users allowed per environment.
     */
    max: number;
    /**
     * An integer that specifies the maximum number of users (hard limit) allowed per environment.
     */
    maxHardLimit: number;
    /**
     * An integer that specifies a soft limit on the number of active identities across all environments on the license per month. This property is not visible if a value is not provided at the time the license is created.
     */
    monthlyActiveIncluded: number;
}

export interface GetLicenseVerify {
    /**
     * A boolean that specifies whether to enable the PingOne Verify document matching feature.
     */
    allowDocumentMatch: boolean;
    /**
     * A boolean that specifies whether to enable the PingOne Verify face matching feature.
     */
    allowFaceMatch: boolean;
    /**
     * A boolean that specifies whether to enable the PingOne Verify manual ID inspection feature.
     */
    allowManualIdInspection: boolean;
    /**
     * A boolean that specifies whether to enable the PingOne Verify push notifications feature.
     */
    allowPushNotifications: boolean;
}

export interface GetLicensesDataFilter {
    /**
     * The attribute name to filter on.  Must be one of the following values: `name`, `package`, `status`.
     */
    name: string;
    /**
     * The possible values (case sensitive) of the attribute defined in the `name` parameter to filter.
     */
    values: string[];
}

export interface GetPasswordPolicyHistory {
    /**
     * An integer that specifies the number of prior passwords to keep for prevention of password re-use. The value must be a positive, non-zero integer.
     */
    count: number;
    /**
     * An integer that specifies the length of time to keep recent passwords for prevention of password re-use. The value must be a positive, non-zero integer.
     */
    retentionDays: number;
}

export interface GetPasswordPolicyLength {
    /**
     * An integer that specifies the maximum number of characters allowed for the password. This property is not enforced when not present.
     */
    max: number;
    /**
     * An integer that specifies the minimum number of characters required for the password. This can be from `8` to `32` (inclusive). This property is not enforced when not present.
     */
    min: number;
}

export interface GetPasswordPolicyLockout {
    /**
     * An integer that specifies the length of time before a password is automatically moved out of the lock out state. The value must be a positive, non-zero integer.
     */
    durationSeconds: number;
    /**
     * An integer that specifies the number of tries before a password is placed in the lockout state. The value must be a positive, non-zero integer.
     */
    failureCount: number;
}

export interface GetPasswordPolicyMinCharacters {
    /**
     * An integer that specifies the count of alphabetical uppercase characters (`abcdefghijklmnopqrstuvwxyz`) that should feature in the user's password.  Fixed value of 1.
     */
    alphabeticalLowercase: number;
    /**
     * An integer that specifies the count of alphabetical uppercase characters (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`) that should feature in the user's password.  Fixed value of 1.
     */
    alphabeticalUppercase: number;
    /**
     * An integer that specifies the count of numeric characters (`0123456789`) that should feature in the user's password.  Fixed value of 1.
     */
    numeric: number;
    /**
     * An integer that specifies the count of special characters (`~!@#$%^&*()-_=+[]{}\|;:,.<>/?`) that should feature in the user's password.  Fixed value of 1.
     */
    specialCharacters: number;
}

export interface GetPopulationsDataFilter {
    /**
     * The attribute name to filter on.  Must be one of the following values: `id`, `name`.
     */
    name: string;
    /**
     * The possible values (case sensitive) of the attribute defined in the `name` parameter to filter.
     */
    values: string[];
}

export interface GetResourceApplicationPermissionsSettings {
    /**
     * A boolean setting to enable application permission claims in the access token.
     */
    claimEnabled: boolean;
}

export interface GetResourceSecretPrevious {
    /**
     * A timestamp that specifies how long this secret is saved (and can be used) before it expires. Supported time range is 1 minute to 30 days.
     */
    expiresAt: string;
    /**
     * A timestamp that specifies when the previous secret was last used.
     */
    lastUsed: string;
    /**
     * A string that specifies the previous resource secret. This property is returned in the response if the previous secret is not expired.
     */
    secret: string;
}

export interface GetRolePermission {
    /**
     * A string that specifies the resource for which the permission is applicable.
     */
    classifier: string;
    /**
     * A string that specifies the description of the permission and what the permission enables.
     */
    description: string;
    /**
     * A string that specifies the ID of the permission.
     */
    id: string;
}

export interface GetTrustedEmailDomainDkimRegion {
    /**
     * A string that specifies the name of the region.
     */
    name: string;
    /**
     * The status of the email domain ownership.  Options are `ACTIVE`, `VERIFICATION_REQUIRED`.
     */
    status: string;
    /**
     * A collection of key and value pairs.
     */
    tokens: outputs.GetTrustedEmailDomainDkimRegionToken[];
}

export interface GetTrustedEmailDomainDkimRegionToken {
    /**
     * Record name.
     */
    key: string;
    /**
     * Record value.
     */
    value: string;
}

export interface GetTrustedEmailDomainOwnershipRegion {
    /**
     * A string that specifies the record name to apply to the DNS provider.
     */
    key: string;
    /**
     * A string that specifies the name of the region.
     */
    name: string;
    /**
     * The status of the email domain ownership.  Options are `ACTIVE`, `VERIFICATION_REQUIRED`.
     */
    status: string;
    /**
     * A string that specifies the record value to apply to the DNS provider.
     */
    value: string;
}

export interface GetUserAccount {
    /**
     * A boolean that specifies whether the user can authenticate. If the value is set to `false`, the account is locked or the user is disabled, and unless specified otherwise in administrative configuration, the user will be unable to authenticate.
     */
    canAuthenticate: boolean;
    /**
     * The time the specified user account was locked. This property might be absent if the account is unlocked or if the account was locked out automatically by failed password attempts.
     */
    lockedAt: string;
    /**
     * A string that specifies the the account locked state.  Options are `LOCKED`, `OK`.
     */
    status: string;
}

export interface GetUserAddress {
    /**
     * A string that specifies the country name component in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) "alpha-2" code format. For example, the country codes for the United States and Sweden are `US` and `SE`, respectively.
     */
    countryCode: string;
    /**
     * A string that specifies the city or locality component of the address.
     */
    locality: string;
    /**
     * A string that specifies the ZIP code or postal code component of the address.
     */
    postalCode: string;
    /**
     * A string that specifies the state, province, or region component of the address.
     */
    region: string;
    /**
     * A string that specifies the full street address component, which may include house number, street name, P.O. box, and multi-line extended street address information.
     */
    streetAddress: string;
}

export interface GetUserIdentityProvider {
    /**
     * A string that identifies the external identity provider used to authenticate the user. If not provided, PingOne is the identity provider. This attribute is required if the identity provider is authoritative for just-in-time user provisioning.
     */
    id: string;
    /**
     * A string that specifies the type of identity provider used to authenticate the user.  Options are `AMAZON`, `APPLE`, `FACEBOOK`, `GITHUB`, `GOOGLE`, `LINKEDIN`, `MICROSOFT`, `OPENID_CONNECT`, `PAYPAL`, `PING_ONE`, `SAML`, `TWITTER`, `YAHOO`.  The default value of `PING_ONE` is set when a value for `id` was not provided when the user was originally created.
     */
    type: string;
}

export interface GetUserName {
    /**
     * A string that specifies the family name of the user, or Last in most Western languages (for example, `Jensen` given the full name `Ms. Barbara J Jensen, III`).
     */
    family: string;
    /**
     * A string that specifies the fully formatted name of the user (for example `Ms. Barbara J Jensen, III`).
     */
    formatted: string;
    /**
     * A string that specifies the given name of the user, or First in most Western languages (for example, `Barbara` given the full name `Ms. Barbara J Jensen, III`).
     */
    given: string;
    /**
     * A string that specifies the honorific prefix(es) of the user, or title in most Western languages (for example, `Ms.` given the full name `Ms. Barbara Jane Jensen, III`).
     */
    honorificPrefix: string;
    /**
     * A string that specifies the honorific suffix(es) of the user, or suffix in most Western languages (for example, `III` given the full name `Ms. Barbara Jane Jensen, III`).
     */
    honorificSuffix: string;
    /**
     * A string that specifies the middle name(s) of the user (for exmple, `Jane` given the full name `Ms. Barbara Jane Jensen, III`).
     */
    middle: string;
}

export interface GetUserPassword {
    /**
     * A single object that maps the information relevant to the user's password, and its association to external directories.
     */
    external: outputs.GetUserPasswordExternal;
}

export interface GetUserPasswordExternal {
    /**
     * A single object that contains the external gateway properties. When this is value is specified, the user's password is managed in an external directory.
     */
    gateway: outputs.GetUserPasswordExternalGateway;
}

export interface GetUserPasswordExternalGateway {
    /**
     * A string map that maps the external LDAP directory attributes to PingOne attributes. PingOne uses these values to read the attributes from the external LDAP directory and map them to the corresponding PingOne attributes.
     */
    correlationAttributes: {[key: string]: string};
    /**
     * A string that specifies the PingOne resource ID of the linked gateway that references the remote directory.
     */
    id: string;
    /**
     * A string that indicates one of the supported gateway types.  Options are `API_GATEWAY_INTEGRATION`, `LDAP`, `PING_FEDERATE`, `PING_INTELLIGENCE`, `RADIUS`.
     */
    type: string;
    /**
     * A string that specifies the PingOne resource ID of a user type in the list of user types for the LDAP gateway.
     */
    userTypeId: string;
}

export interface GetUserPhoto {
    /**
     * The URI that is a uniform resource locator (as defined in [Section 1.1.3 of RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-1.3)) that points to a resource location representing the user's image.
     */
    href: string;
}

export interface GetUserRoleAssignmentsRoleAssignment {
    /**
     * A string that specifies the ID of the role assignment relationship.
     */
    id: string;
    /**
     * A boolean that specifies whether the admin role assignment is read only or can be changed.
     */
    readOnly: boolean;
    /**
     * A string that specifies the ID of the admin role that has been assigned to the user.
     */
    roleId: string;
    /**
     * An object that describes the scope of the role assignment.
     */
    scope: outputs.GetUserRoleAssignmentsRoleAssignmentScope;
}

export interface GetUserRoleAssignmentsRoleAssignmentScope {
    /**
     * A string that specifies the ID of the environment, population or organization that the role is scoped to.
     */
    id: string;
    /**
     * The type of the scope.  Options are `APPLICATION`, `ENVIRONMENT`, `ORGANIZATION`, `POPULATION`.
     */
    type: string;
}

export interface GetUserUserLifecycle {
    /**
     * A string that specifies the status of the account lifecycle.  Options are `ACCOUNT_OK`, `VERIFICATION_REQUIRED`.
     */
    status: string;
}

export interface GetUsersDataFilter {
    /**
     * The attribute name to filter on.  Must be one of the following values: `accountId`, `address.streetAddress`, `address.locality`, `address.region`, `address.postalCode`, `address.countryCode`, `email`, `enabled`, `endDate`, `externalId`, `locale`, `mobilePhone`, `name.formatted`, `name.given`, `name.middle`, `name.family`, `name.honorificPrefix`, `name.honorificSuffix`, `nickname`, `population.id`, `photo.href`, `preferredLanguage`, `primaryPhone`, `startDate`, `timezone`, `title`, `type`, `username`, `memberOfGroups.id`.
     */
    name: string;
    /**
     * The possible values (case sensitive) of the attribute defined in the `name` parameter to filter.
     */
    values: string[];
}

export interface GetVerifyPolicyEmail {
    /**
     * When enabled, PingOne Verify registers the email address with PingOne MFA as a verified MFA device.
     */
    createMfaDevice: boolean;
    /**
     * SMS/Voice/Email one-time password (OTP) configuration.
     */
    otp: outputs.GetVerifyPolicyEmailOtp;
    /**
     * Controls the verification requirements for an Email or Phone verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyEmailOtp {
    /**
     * OTP attempts configuration.
     */
    attempts: outputs.GetVerifyPolicyEmailOtpAttempts;
    /**
     * OTP delivery configuration.
     */
    deliveries: outputs.GetVerifyPolicyEmailOtpDeliveries;
    /**
     * The length of time for which the OTP is valid.
     */
    lifetime: outputs.GetVerifyPolicyEmailOtpLifetime;
    /**
     * OTP notification template configuration.
     */
    notification: outputs.GetVerifyPolicyEmailOtpNotification;
}

export interface GetVerifyPolicyEmailOtpAttempts {
    /**
     * Allowed maximum number of OTP failures.
     */
    count: number;
}

export interface GetVerifyPolicyEmailOtpDeliveries {
    /**
     * Cooldown (waiting period between OTP attempts) configuration.
     */
    cooldown: outputs.GetVerifyPolicyEmailOtpDeliveriesCooldown;
    /**
     * Allowed maximum number of OTP deliveries.
     */
    count: number;
}

export interface GetVerifyPolicyEmailOtpDeliveriesCooldown {
    /**
     * Cooldown duration.
     *     - If `cooldown.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `cooldown.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 SECONDS`.
     */
    duration: number;
    /**
     * Time unit of the cooldown duration configuration.  Options are `MINUTES`, `SECONDS`.  Defaults to `SECONDS`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyEmailOtpLifetime {
    /**
     * Lifetime of the OTP delivered via email.
     *     - If `lifetime.time_unit` is `MINUTES`, the allowed range is `1 - 30`.
     *     - If `lifetime.time_unit` is `SECONDS`, the allowed range is `60 - 1800`.
     *     - Defaults to `10 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of the OTP (Email) duration lifetime.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyEmailOtpNotification {
    /**
     * Name of the template to use to pass a one-time passcode (OTP). The default value of `email_phone_verification` is static. Use the `notification.variant_name` property to define an alternate template.
     */
    templateName: string;
    /**
     * Name of the template variant to use to pass a one-time passcode (OTP).
     */
    variantName: string;
}

export interface GetVerifyPolicyFacialComparison {
    /**
     * Facial Comparison threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    threshold: string;
    /**
     * Controls Facial Comparison verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyGovernmentId {
    /**
     * When enabled, Government ID verification fails if the document is expired.
     */
    failExpiredId: boolean;
    /**
     * Determine whether document authentication is automated, manual, or possibly both.  Options are `AUTOMATIC`, `MANUAL`, `STEP_UP`.
     */
    inspectionType: string;
    /**
     * Provider to use for the automatic verification service.  Options are `MITEK`, `VERIFF`.  Defaults to `MITEK`.
     */
    providerAuto: string;
    /**
     * Provider to use for the manual verification service.  Options are `MITEK`.  Defaults to `MITEK`.
     */
    providerManual: string;
    /**
     * Number of retries permitted when submitting images.  The allowed range is `0 - 3`.
     */
    retryAttempts: number;
    /**
     * Controls Government ID verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyLiveness {
    /**
     * Number of retries permitted when submitting images.  The allowed range is `0 - 3`.
     */
    retryAttempts: number;
    /**
     * Liveness Check threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    threshold: string;
    /**
     * Controls Liveness Check verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyPhone {
    /**
     * When enabled, PingOne Verify registers the mobile phone with PingOne MFA as a verified MFA device.
     */
    createMfaDevice: boolean;
    /**
     * SMS/Voice/Email one-time password (OTP) configuration.
     */
    otp: outputs.GetVerifyPolicyPhoneOtp;
    /**
     * Controls the verification requirements for an Email or Phone verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyPhoneOtp {
    /**
     * OTP attempts configuration.
     */
    attempts: outputs.GetVerifyPolicyPhoneOtpAttempts;
    /**
     * OTP delivery configuration.
     */
    deliveries: outputs.GetVerifyPolicyPhoneOtpDeliveries;
    /**
     * The length of time for which the OTP is valid.
     */
    lifetime: outputs.GetVerifyPolicyPhoneOtpLifetime;
    /**
     * OTP notification template configuration.
     */
    notification: outputs.GetVerifyPolicyPhoneOtpNotification;
}

export interface GetVerifyPolicyPhoneOtpAttempts {
    /**
     * Allowed maximum number of OTP failures.
     */
    count: number;
}

export interface GetVerifyPolicyPhoneOtpDeliveries {
    /**
     * Cooldown (waiting period between OTP attempts) configuration.
     */
    cooldown: outputs.GetVerifyPolicyPhoneOtpDeliveriesCooldown;
    /**
     * Allowed maximum number of OTP deliveries.
     */
    count: number;
}

export interface GetVerifyPolicyPhoneOtpDeliveriesCooldown {
    /**
     * Cooldown duration.
     *     - If `cooldown.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `cooldown.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 SECONDS`.
     */
    duration: number;
    /**
     * Time unit of the cooldown duration configuration.  Options are `MINUTES`, `SECONDS`.  Defaults to `SECONDS`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyPhoneOtpLifetime {
    /**
     * Lifetime of the OTP delivered via phone (SMS).
     *     - If `lifetime.time_unit` is `MINUTES`, the allowed range is `1 - 30`.
     *     - If `lifetime.time_unit` is `SECONDS`, the allowed range is `60 - 1800`.
     *     - Defaults to `5 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of the OTP (SMS) duration lifetime.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyPhoneOtpNotification {
    /**
     * Name of the template to use to pass a one-time passcode (OTP). The default value of `email_phone_verification` is static. Use the `notification.variant_name` property to define an alternate template.
     */
    templateName: string;
    /**
     * Name of the template variant to use to pass a one-time passcode (OTP).
     */
    variantName: string;
}

export interface GetVerifyPolicyTransaction {
    /**
     * Object for data collection timeout definition.
     */
    dataCollection: outputs.GetVerifyPolicyTransactionDataCollection;
    /**
     * When `true`, collects documents specified in the policy without determining their validity; defaults to `false`.
     */
    dataCollectionOnly: boolean;
    /**
     * Object for transaction timeout.
     */
    timeout: outputs.GetVerifyPolicyTransactionTimeout;
}

export interface GetVerifyPolicyTransactionDataCollection {
    /**
     * Object for data collection timeout.
     */
    timeout: outputs.GetVerifyPolicyTransactionDataCollectionTimeout;
}

export interface GetVerifyPolicyTransactionDataCollectionTimeout {
    /**
     * Length of time before the data collection transaction expires.
     *     - If `transaction.data_collection.timeout.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `transaction.data_collection.timeout.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `15 MINUTES`.
     *
     *     > When setting or changing timeouts in the transaction configuration object, `transaction.data_collection.timeout.duration` must be less than or equal to `transaction.timeout.duration`.
     */
    duration: number;
    /**
     * Time unit of data collection timeout.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyTransactionTimeout {
    /**
     * Length of time before the transaction expires.
     *     - If `transaction.timeout.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `transaction.timeout.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of transaction timeout.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface GetVerifyPolicyVoice {
    /**
     * Comparison threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    comparisonThreshold: string;
    /**
     * Controls if the transaction performs voice enrollment (`TRUE`) or voice verification (`FALSE`).
     */
    enrollment: boolean;
    /**
     * Liveness threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    livenessThreshold: string;
    /**
     * Object for configuration of voice recording reference data.
     */
    referenceData: outputs.GetVerifyPolicyVoiceReferenceData;
    /**
     * Object for configuration of text dependent voice verification.
     */
    textDependent: outputs.GetVerifyPolicyVoiceTextDependent;
    /**
     * Controls the verification requirements for a Voice verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface GetVerifyPolicyVoiceReferenceData {
    /**
     * Controls if the service stores the original voice recordings.
     */
    retainOriginalRecordings: boolean;
    /**
     * Controls updates to user's voice reference data (voice recordings) upon user re-enrollment. If `TRUE`, new data adds to existing data. If `FALSE`, new data replaces existing data.
     */
    updateOnReenrollment: boolean;
    /**
     * Controls updates to user's voice reference data (voice recordings) upon user verification. If `TRUE`, new data adds to existing data. If `FALSE`, new voice recordings are not retained as reference data.
     */
    updateOnVerification: boolean;
}

export interface GetVerifyPolicyVoiceTextDependent {
    /**
     * Number of voice samples to collect. The allowed range is `3 - 5`
     */
    samples: number;
    /**
     * Identifier (UUID) of the voice phrase to use.
     */
    voicePhraseId: string;
}

export interface IdentityProviderAmazon {
    /**
     * A string that specifies the application client ID from Amazon.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Amazon.
     */
    clientSecret: string;
}

export interface IdentityProviderApple {
    /**
     * A string that specifies the application ID from Apple. This is the identifier obtained after registering a services ID in the Apple developer portal.
     */
    clientId: string;
    /**
     * A string that specifies the private key that is used to generate a client secret.
     */
    clientSecretSigningKey: string;
    /**
     * A 10-character string that Apple uses to identify an authentication key.
     */
    keyId: string;
    /**
     * A 10-character string that Apple uses to identify teams.
     */
    teamId: string;
}

export interface IdentityProviderFacebook {
    /**
     * A string that specifies the application ID from Facebook.
     */
    appId: string;
    /**
     * A string that specifies the application secret from Facebook.
     */
    appSecret: string;
}

export interface IdentityProviderGithub {
    /**
     * A string that specifies the application client ID from Github.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Github.
     */
    clientSecret: string;
}

export interface IdentityProviderGoogle {
    /**
     * A string that specifies the application client ID from Google.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Google.
     */
    clientSecret: string;
}

export interface IdentityProviderIcon {
    /**
     * The URL or fully qualified path to the identity provider icon to use as the login button.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.
     */
    href: string;
    /**
     * The ID for the identity provider icon to use as the login button.  This can be retrieved from the `id` parameter of the `pingone.Image` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface IdentityProviderLinkedin {
    /**
     * A string that specifies the application client ID from LinkedIn.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from LinkedIn.
     */
    clientSecret: string;
}

export interface IdentityProviderLoginButtonIcon {
    /**
     * The URL or fully qualified path to the identity provider icon to use as the login button.  This can be retrieved from the `uploaded_image.href` parameter of the `pingone.Image` resource.
     */
    href: string;
    /**
     * The ID for the identity provider icon to use as the login button.  This can be retrieved from the `id` parameter of the `pingone.Image` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface IdentityProviderMicrosoft {
    /**
     * A string that specifies the application client ID from Microsoft.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Microsoft.
     */
    clientSecret: string;
}

export interface IdentityProviderOpenidConnect {
    /**
     * A string that specifies the the OIDC identity provider's authorization endpoint. This value must be a URL that uses https.
     */
    authorizationEndpoint: string;
    /**
     * A string that specifies the application client ID from the OIDC identity provider.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from the OIDC identity provider.
     */
    clientSecret: string;
    /**
     * A string that specifies the OIDC identity provider's discovery endpoint. This value must be a URL that uses https.
     */
    discoveryEndpoint?: string;
    /**
     * A string that specifies the issuer to which the authentication is sent for the OIDC identity provider. This value must be a URL that uses https.
     */
    issuer: string;
    /**
     * A string that specifies the OIDC identity provider's jwks endpoint. This value must be a URL that uses https.
     */
    jwksEndpoint: string;
    /**
     * A string that specifies the method for PKCE. This value auto-populates from a discovery endpoint if the OpenID Provider includes `S256` in its `code_challenge_methods_supported` claim. The plain method is not currently supported.  Options are `NONE`, `S256`.  Defaults to `NONE`.
     */
    pkceMethod: string;
    /**
     * An array that specifies the scopes to include in the authentication request to the OIDC identity provider.
     */
    scopes: string[];
    /**
     * A string that specifies the OIDC identity provider's token endpoint. This value must be a URL that uses https.
     */
    tokenEndpoint: string;
    /**
     * A string that specifies the OIDC identity provider's token endpoint authentication method.  Options are `CLIENT_SECRET_BASIC`, `CLIENT_SECRET_POST`, `NONE`.  Defaults to `CLIENT_SECRET_BASIC`.
     */
    tokenEndpointAuthMethod: string;
    /**
     * A string that specifies the OIDC identity provider's userInfo endpoint. This value must be a URL that uses https.
     */
    userinfoEndpoint?: string;
}

export interface IdentityProviderPaypal {
    /**
     * A string that specifies the PayPal environment.  Options are `live`, `sandbox`.
     */
    clientEnvironment: string;
    /**
     * A string that specifies the application ID from Paypal.
     */
    clientId: string;
    /**
     * A string that specifies the application secret from PayPal.
     */
    clientSecret: string;
}

export interface IdentityProviderSaml {
    /**
     * A boolean that specifies whether the SAML authentication request will be signed when sending to the identity provider. Set this to `true` if the external IDP is included in an authentication policy to be used by applications that are accessed using a mix of default URLS and custom Domains URLs.  Defaults to `false`.
     */
    authenticationRequestSigned: boolean;
    /**
     * A string that specifies the entity ID URI that is checked against the `issuerId` tag in the incoming response.
     */
    idpEntityId: string;
    /**
     * A single object that specifies settings for SAML IdP verification, including the list of IdP certificates used to verify the signature on the signed assertion of the identity provider.
     */
    idpVerification: outputs.IdentityProviderSamlIdpVerification;
    /**
     * A string that specifies the binding protocol to be used for the logout response.  Options are `HTTP_POST`, `HTTP_REDIRECT`.  Defaults to `HTTP_POST`.
     */
    sloBinding: string;
    /**
     * A string that specifies the logout endpoint URL. This is an optional property. However, if a logout endpoint URL is not defined, logout actions result in an error.  This value must be a URL that uses http or https.
     */
    sloEndpoint?: string;
    /**
     * A string that specifies the endpoint URL to submit the logout response.  If a value is not provided, the `slo_endpoint` property value is used to submit SLO response.  This value must be a URL that uses http or https.
     */
    sloResponseEndpoint?: string;
    /**
     * An integer that defines how long (hours) PingOne can exchange logout messages with the application, specifically a logout request from the application, since the initial request. The minimum value is `1` hour and the maximum is `24` hours.
     */
    sloWindow?: number;
    /**
     * A string that specifies the service provider's entity ID, used to look up the application.
     */
    spEntityId: string;
    /**
     * A single object that specifies settings for SAML assertion signing, including the key and the signature algorithm.  Required when `authentication_request_signed` is set to `true`.
     */
    spSigning?: outputs.IdentityProviderSamlSpSigning;
    /**
     * A string that specifies the binding for the authentication request.  Options are `HTTP_POST`, `HTTP_REDIRECT`.
     */
    ssoBinding: string;
    /**
     * A string that specifies the SSO endpoint for the authentication request.  This value must be a URL that uses http or https.
     */
    ssoEndpoint: string;
}

export interface IdentityProviderSamlIdpVerification {
    /**
     * An unordered list that specifies the identity provider's certificate IDs used to verify the signature on the signed assertion from the identity provider. Signing is done with a private key and verified with a public key.
     */
    certificates: outputs.IdentityProviderSamlIdpVerificationCertificate[];
}

export interface IdentityProviderSamlIdpVerificationCertificate {
    /**
     * A string that specifies the identity provider's certificate ID used to verify the signature on the signed assertion from the identity provider.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface IdentityProviderSamlSpSigning {
    /**
     * The signing key algorithm used by PingOne. The value will depend on which key algorithm and signature algorithm you chose when creating your signing key.  Options are `SHA256withECDSA`, `SHA256withRSA`, `SHA384withECDSA`, `SHA384withRSA`, `SHA512eithEDCSA`, `SHA512withRSA`.
     */
    algorithm?: string;
    /**
     * A single object that specifies settings for the SAML Sp Signing key.
     */
    key: outputs.IdentityProviderSamlSpSigningKey;
}

export interface IdentityProviderSamlSpSigningKey {
    /**
     * A string that specifies the service provider's signing key ID.  Must be a valid PingOne resource ID.
     */
    id: string;
}

export interface IdentityProviderTwitter {
    /**
     * A string that specifies the application client ID from Twitter.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Twitter.
     */
    clientSecret: string;
}

export interface IdentityProviderYahoo {
    /**
     * A string that specifies the application client ID from Yahoo.
     */
    clientId: string;
    /**
     * A string that specifies the application client secret from Yahoo.
     */
    clientSecret: string;
}

export interface ImageUploadedImage {
    /**
     * The height of the image (in pixels).
     */
    height: number;
    /**
     * A string that specifies the URL or fully qualified path to the image source file.
     */
    href: string;
    /**
     * A string that specifies the type of format used for the image. Options are `jpg`, `png`, and `gif`.
     */
    type: string;
    /**
     * The width of the image (in pixels).
     */
    width: number;
}

export interface MfaApplicationPushCredentialApns {
    /**
     * A string that Apple uses as an identifier to identify an authentication key.
     */
    key: string;
    /**
     * A string that Apple uses as an identifier to identify teams.
     */
    teamId: string;
    /**
     * A string that Apple uses as the authentication token signing key to securely connect to APNS. This is the contents of a pkcs8 file with a private key format.
     */
    tokenSigningKey: string;
}

export interface MfaApplicationPushCredentialFcm {
    /**
     * A string in JSON format that represents the service account credentials of Firebase cloud messaging service.
     */
    googleServiceAccountCredentials: string;
}

export interface MfaApplicationPushCredentialHms {
    /**
     * A string that represents the OAuth 2.0 Client ID from the Huawei Developers API console.
     */
    clientId: string;
    /**
     * A string that represents the client secret associated with the OAuth 2.0 Client ID.
     */
    clientSecret: string;
}

export interface MfaDevicePolicyAuthentication {
    /**
     * A string that defines the device selection method.  Options are `ALWAYS_DISPLAY_DEVICES`, `DEFAULT_TO_FIRST`, `PROMPT_TO_SELECT`.  Defaults to `DEFAULT_TO_FIRST`.
     */
    deviceSelection: string;
}

export interface MfaDevicePolicyEmail {
    /**
     * A boolean that specifies whether the email OTP method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A single object that allows configuration of email OTP settings.
     */
    otp: outputs.MfaDevicePolicyEmailOtp;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the email OTP method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices.  Defaults to `false`.
     */
    pairingDisabled: boolean;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicyEmailOtp {
    /**
     * A single object that allows configuration of email OTP failure settings.
     */
    failure?: outputs.MfaDevicePolicyEmailOtpFailure;
    /**
     * A single object that allows configuration of email OTP lifetime settings.
     */
    lifetime?: outputs.MfaDevicePolicyEmailOtpLifetime;
}

export interface MfaDevicePolicyEmailOtpFailure {
    /**
     * A single object that allows configuration of email OTP failure cool down settings.
     */
    coolDown: outputs.MfaDevicePolicyEmailOtpFailureCoolDown;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked.
     */
    count: number;
}

export interface MfaDevicePolicyEmailOtpFailureCoolDown {
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyEmailOtpLifetime {
    /**
     * An integer that defines the duration (number of time units) that the passcode is valid before it expires.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyFido2 {
    /**
     * A boolean that specifies whether the FIDO2 method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A string that specifies the resource UUID that represents the FIDO2 policy in PingOne. This property can be null / left undefined. When null, the environment's default FIDO2 Policy is used.  Must be a valid PingOne resource ID.
     */
    fido2PolicyId?: string;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the FIDO2 method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices.  Defaults to `false`.
     */
    pairingDisabled: boolean;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicyMobile {
    /**
     * A map of objects that specifies settings for a configured Mobile Application.  The ID of the application should be configured as the map key.
     */
    applications?: {[key: string]: outputs.MfaDevicePolicyMobileApplications};
    /**
     * A boolean that specifies whether the mobile device method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A single object that specifies OTP settings for mobile applications in the policy.
     */
    otp: outputs.MfaDevicePolicyMobileOtp;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicyMobileApplications {
    /**
     * A single object that specifies auto enrollment settings for the application in the policy.
     */
    autoEnrollment?: outputs.MfaDevicePolicyMobileApplicationsAutoEnrollment;
    /**
     * A single object that specifies device authorization settings for the application in the policy.
     */
    deviceAuthorization?: outputs.MfaDevicePolicyMobileApplicationsDeviceAuthorization;
    /**
     * Controls how authentication or registration attempts should proceed if a device integrity check does not receive a response.  Options are `permissive` (if you want to allow the process to continue if a device integrity check does not receive a response), `restrictive` (if you want to block the user if a device integrity check does not receive a response).
     */
    integrityDetection?: string;
    /**
     * A single object that specifies OTP settings for the application in the policy.
     */
    otp?: outputs.MfaDevicePolicyMobileApplicationsOtp;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the relevant application. You can use this option if you want to phase out an existing mobile application but want to allow users to continue using the application for authentication for existing devices.
     */
    pairingDisabled: boolean;
    /**
     * A single object that specifies pairing key lifetime settings for the application in the policy.
     */
    pairingKeyLifetime?: outputs.MfaDevicePolicyMobileApplicationsPairingKeyLifetime;
    /**
     * A single object that specifies push settings for the application in the policy.
     */
    push?: outputs.MfaDevicePolicyMobileApplicationsPush;
    /**
     * A single object that specifies push limit settings for the application in the policy.
     */
    pushLimit: outputs.MfaDevicePolicyMobileApplicationsPushLimit;
    /**
     * A single object that specifies push timeout settings for the application in the policy.
     */
    pushTimeout?: outputs.MfaDevicePolicyMobileApplicationsPushTimeout;
}

export interface MfaDevicePolicyMobileApplicationsAutoEnrollment {
    /**
     * A boolean that, when set to `true` if you want the application to allow Auto Enrollment. Auto Enrollment means that the user can authenticate for the first time from an unpaired device, and the successful authentication will result in the pairing of the device for MFA.
     */
    enabled: boolean;
}

export interface MfaDevicePolicyMobileApplicationsDeviceAuthorization {
    /**
     * Specifies the enabled or disabled state of automatic MFA for native devices paired with the user, for the specified application.
     */
    enabled: boolean;
    /**
     * Specifies the level of further verification when device authorization is enabled. The PingOne platform performs an extra verification check by sending a "silent" push notification to the customer native application, and receives a confirmation in return.  By default, the PingOne platform does not perform the extra verification check.  Options are `permissive` (the PingOne platform performs the extra verification check. Upon timeout or failure to get a response from the native app, the MFA step is treated as successfully completed), `restrictive` (the PingOne platform performs the extra verification check. Upon timeout or failure to get a response from the native app, the MFA step is treated as failed).
     */
    extraVerification?: string;
}

export interface MfaDevicePolicyMobileApplicationsOtp {
    /**
     * A boolean that specifies whether OTP authentication is enabled or disabled for the application in the policy.
     */
    enabled: boolean;
}

export interface MfaDevicePolicyMobileApplicationsPairingKeyLifetime {
    /**
     * An integer that defines the amount of time an issued pairing key can be used until it expires. Minimum is 1 minute and maximum is 48 hours. If this parameter is not provided, the duration is set to 10 minutes.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `HOURS`, `MINUTES`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyMobileApplicationsPush {
    /**
     * A boolean that specifies whether push notification is enabled or disabled for the application in the policy.
     */
    enabled: boolean;
}

export interface MfaDevicePolicyMobileApplicationsPushLimit {
    /**
     * An integer that specifies the number of consecutive push notifications that can be ignored or rejected by a user within a defined period before push notifications are blocked for the application. The minimum value is "1" and the maximum value is "50". If this parameter is not provided, the default value is "5".
     */
    count: number;
    /**
     * A single object that specifies push limit lock duration settings for the application in the policy.
     */
    lockDuration?: outputs.MfaDevicePolicyMobileApplicationsPushLimitLockDuration;
    /**
     * A single object that specifies push limit time period settings for the application in the policy.
     */
    timePeriod?: outputs.MfaDevicePolicyMobileApplicationsPushLimitTimePeriod;
}

export interface MfaDevicePolicyMobileApplicationsPushLimitLockDuration {
    /**
     * An integer that defines the length of time that push notifications should be blocked for the application if the defined limit has been reached. The minimum value is `1` minute and the maximum value is `120` minutes. If this parameter is not provided, the default value is `30` minutes.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyMobileApplicationsPushLimitTimePeriod {
    /**
     * An integer that defines the length of time that push notifications should be blocked for the application if the defined limit has been reached. The minimum value is `1` minute and the maximum value is `120` minutes. If this parameter is not provided, the default value is `30` minutes.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyMobileApplicationsPushTimeout {
    /**
     * An integer that defines the length of time that push notifications should be blocked for the application if the defined limit has been reached. The minimum value is `1` minute and the maximum value is `120` minutes. If this parameter is not provided, the default value is `30` minutes.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`. Currently, the only permitted value is `SECONDS`.  Defaults to `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyMobileOtp {
    /**
     * A single object that specifies OTP failure settings for mobile applications in the policy.
     */
    failure: outputs.MfaDevicePolicyMobileOtpFailure;
}

export interface MfaDevicePolicyMobileOtpFailure {
    /**
     * A single object that specifies OTP failure cool down settings for mobile applications in the policy.
     */
    coolDown: outputs.MfaDevicePolicyMobileOtpFailureCoolDown;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. The minimum value is `1`, maximum is `7`, and the default is `3`.
     */
    count: number;
}

export interface MfaDevicePolicyMobileOtpFailureCoolDown {
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. The minimum value is `2`, maximum is `30`, and the default is `2`. Note that when using the "onetime authentication" feature, the user is not blocked after the maximum number of failures even if you specified a block duration.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicySms {
    /**
     * A boolean that specifies whether the SMS OTP method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A single object that allows configuration of SMS OTP settings.
     */
    otp: outputs.MfaDevicePolicySmsOtp;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the SMS OTP method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices.  Defaults to `false`.
     */
    pairingDisabled: boolean;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicySmsOtp {
    /**
     * A single object that allows configuration of SMS OTP failure settings.
     */
    failure?: outputs.MfaDevicePolicySmsOtpFailure;
    /**
     * A single object that allows configuration of SMS OTP lifetime settings.
     */
    lifetime?: outputs.MfaDevicePolicySmsOtpLifetime;
}

export interface MfaDevicePolicySmsOtpFailure {
    /**
     * A single object that allows configuration of SMS OTP failure cool down settings.
     */
    coolDown: outputs.MfaDevicePolicySmsOtpFailureCoolDown;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked.
     */
    count: number;
}

export interface MfaDevicePolicySmsOtpFailureCoolDown {
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicySmsOtpLifetime {
    /**
     * An integer that defines the duration (number of time units) that the passcode is valid before it expires.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyTotp {
    /**
     * A boolean that specifies whether the TOTP method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A single object that allows configuration of TOTP OTP settings.
     */
    otp: outputs.MfaDevicePolicyTotpOtp;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the TOTP method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices.  Defaults to `false`.
     */
    pairingDisabled: boolean;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicyTotpOtp {
    /**
     * A single object that allows configuration of TOTP OTP failure settings.
     */
    failure?: outputs.MfaDevicePolicyTotpOtpFailure;
}

export interface MfaDevicePolicyTotpOtpFailure {
    /**
     * A single object that allows configuration of TOTP OTP failure cool down settings.
     */
    coolDown?: outputs.MfaDevicePolicyTotpOtpFailureCoolDown;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked.
     */
    count: number;
}

export interface MfaDevicePolicyTotpOtpFailureCoolDown {
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyVoice {
    /**
     * A boolean that specifies whether the voice OTP method is enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * A single object that allows configuration of voice OTP settings.
     */
    otp: outputs.MfaDevicePolicyVoiceOtp;
    /**
     * A boolean that, when set to `true`, prevents users from pairing new devices with the voice OTP method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices.  Defaults to `false`.
     */
    pairingDisabled: boolean;
    /**
     * A boolean that, when set to `true`, prompts users to provide nicknames for devices during pairing.
     */
    promptForNicknameOnPairing?: boolean;
}

export interface MfaDevicePolicyVoiceOtp {
    /**
     * A single object that allows configuration of voice OTP failure settings.
     */
    failure?: outputs.MfaDevicePolicyVoiceOtpFailure;
    /**
     * A single object that allows configuration of voice OTP lifetime settings.
     */
    lifetime?: outputs.MfaDevicePolicyVoiceOtpLifetime;
}

export interface MfaDevicePolicyVoiceOtpFailure {
    /**
     * A single object that allows configuration of voice OTP failure cool down settings.
     */
    coolDown: outputs.MfaDevicePolicyVoiceOtpFailureCoolDown;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked.
     */
    count: number;
}

export interface MfaDevicePolicyVoiceOtpFailureCoolDown {
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaDevicePolicyVoiceOtpLifetime {
    /**
     * An integer that defines the duration (number of time units) that the passcode is valid before it expires.
     */
    duration: number;
    /**
     * A string that specifies the type of time unit for `duration`.  Options are `MINUTES`, `SECONDS`.
     */
    timeUnit: string;
}

export interface MfaFido2PolicyBackupEligibility {
    /**
     * A boolean that specifies whether to allow users to register and authenticate with a device that uses cloud-synced credentials.
     */
    allow: boolean;
    /**
     * A boolean that specifies whether the backup eligibility of the device should be checked again at each authentication attempt.  Set to `true` if you want the backup eligibility of the device to be checked again at each authentication attempt and not just once during registration. Set to `false` to have it checked only at registration.
     */
    enforceDuringAuthentication: boolean;
}

export interface MfaFido2PolicyMdsAuthenticatorsRequirements {
    /**
     * A set of strings that is used if `option` is set to `SPECIFIC`, to specify the mdsIdentitfer IDs of authenticators that are allowed in the policy.
     */
    allowedAuthenticatorIds?: string[];
    /**
     * A boolean that specifies whether devices characteristics related to verification are checked again on each authentication attempt.  Set to `true` if you want the device characteristics related to attestation to be checked again at each authentication attempt and not just once during registration. Set to `false` to have them checked only at registration.
     */
    enforceDuringAuthentication: boolean;
    /**
     * A string that specifies the types of device that are allowed on the basis of the attestation provided.  Options are `AUDIT_ONLY` (attestation is requested and the information is used for logging purposes, but the information is not used for filtering authenticators), `CERTIFIED` (allow only FIDO Certified authenticators), `GLOBAL` (allow use of all FIDO authenticators listed in the Global Authenticators table), `NONE` (do not request attestation, allow all FIDO devices), `SPECIFIC` (allow only the authenticators specified with the `allowed_authenticator_ids` parameter).
     */
    option: string;
}

export interface MfaFido2PolicyUserDisplayNameAttributes {
    /**
     * A list of objects that describe attributes associated with the users's account that can be displayed during registration and authentication.
     *     - The content of the list should reflect the preferred order.
     *     - If the first attribute is empty for the user, PingOne will continue through the list until a non-empty attribute is found.
     *     - You can specify any user attribute (including custom attributes) that meet the following criteria: attribute type must be String, validation cannot be set to enumerated values.
     *     - The array must contain the user attribute `username` to ensure that there is at least one non-empty attribute.
     *     - You can have a maximum of six user attributes in the list.
     */
    attributes: outputs.MfaFido2PolicyUserDisplayNameAttributesAttribute[];
}

export interface MfaFido2PolicyUserDisplayNameAttributesAttribute {
    /**
     * The name of the attribute in PingOne, for example `username` or `email`.  The attribute can be any user attribute, including a custom attribute, that is a string data type and does not have enumerated values configured.  If you want to use the `name` attribute for the user (or any attribute that is a complex data type), you must also specify the `sub_attributes` parameter, which can be either the `given` and `family` user attributes or the `formatted` user attribute.
     */
    name: string;
    /**
     * A lsit of objects that describe the sub attributes to use when `name` is configured to use an attribute that is a complex data type.
     */
    subAttributes?: outputs.MfaFido2PolicyUserDisplayNameAttributesAttributeSubAttribute[];
}

export interface MfaFido2PolicyUserDisplayNameAttributesAttributeSubAttribute {
    /**
     * The name of a complex attribute's sub attribute in PingOne, for example `given` or `formatted` where the parent object has a name value of `name`.
     */
    name: string;
}

export interface MfaFido2PolicyUserVerification {
    /**
     * A boolean that specifies whether device characteristics related to user verification are to be checked again at each authentication attempt. Set to `true` if you want the device characteristics related to user verification to be checked again at each authentication attempt and not just once during registration. Set to `false` to have them checked only at registration.
     */
    enforceDuringAuthentication: boolean;
    /**
     * A string that specifies the type of user verification to perform.  Options are `DISCOURAGED`, `PREFERRED`, `REQUIRED`.  Options are `DISCOURAGED` (user verification is not required, even when supported by the FIDO device. In cases where user verification is required by the FIDO device itself, this setting does not override the device setting), `PREFERRED` (user verification is required if the user's FIDO device supports it, but is not required if the user's device does not support it), `REQUIRED` (only FIDO devices supporting user verification can be used).  For usernameless flows, only FIDO devices supporting user verification can be used, regardless of the value configured in this parameter.
     */
    option: string;
}

export interface MfaPolicyEmail {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. Note that when using the "onetime authentication" feature, the user is not blocked after the maximum number of failures even if you specified a block duration. Defaults to `0`.
     */
    otpFailureCooldownDuration?: number;
    /**
     * The type of time unit for `otp_failure_cooldown_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpFailureCooldownTimeunit?: string;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. Defaults to `3`.
     */
    otpFailureCount?: number;
    /**
     * An integer that defines turation (number of time units) that the passcode is valid before it expires. Defaults to `30`.
     */
    otpLifetimeDuration?: number;
    /**
     * The type of time unit for `otp_lifetime_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpLifetimeTimeunit?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicyFido2 {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * Specifies the UUID that represents the FIDO2 policy in PingOne. This property can be null. When null, the environment's default FIDO2 Policy is used.
     */
    fido2PolicyId?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicyMobile {
    /**
     * Settings for a configured Mobile Application.
     */
    applications?: outputs.MfaPolicyMobileApplication[];
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. Defaults to `2`.
     */
    otpFailureCooldownDuration?: number;
    /**
     * The type of time unit for `otp_failure_cooldown_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpFailureCooldownTimeunit?: string;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. Defaults to `3`.
     */
    otpFailureCount?: number;
}

export interface MfaPolicyMobileApplication {
    /**
     * Set to `true` if you want the application to allow Auto Enrollment. Auto Enrollment means that the user can authenticate for the first time from an unpaired device, and the successful authentication will result in the pairing of the device for MFA.
     */
    autoEnrollmentEnabled?: boolean;
    /**
     * Specifies the enabled or disabled state of automatic MFA for native devices paired with the user, for the specified application.
     */
    deviceAuthorizationEnabled?: boolean;
    /**
     * Specifies the level of further verification when `device_authorization_enabled` is true. The PingOne platform performs an extra verification check by sending a "silent" push notification to the customer native application, and receives a confirmation in return.  Extra verification can be one of the following levels: `permissive`: The PingOne platform performs the extra verification check. Upon timeout or failure to get a response from the native app, the MFA step is treated as successfully completed.  `restrictive`: The PingOne platform performs the extra verification check.The PingOne platform performs the extra verification check. Upon timeout or failure to get a response from the native app, the MFA step is treated as failed.
     */
    deviceAuthorizationExtraVerification?: string;
    /**
     * The mobile application's ID.  Mobile applications are configured with the `pingone.Application` resource, as an OIDC `NATIVE` type.
     */
    id: string;
    /**
     * Controls how authentication or registration attempts should proceed if a device integrity check does not receive a response. Set the value to `permissive` if you want to allow the process to continue. Set the value to `restrictive` if you want to block the user in such situations.
     */
    integrityDetection?: string;
    /**
     * Specifies whether OTP authentication is enabled or disabled for the policy.
     */
    otpEnabled: boolean;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
    /**
     * The amount of time an issued pairing key can be used until it expires. Minimum is 1 minute and maximum is 48 hours. If this parameter is not provided, the duration is set to 10 minutes. Defaults to `10`.
     */
    pairingKeyLifetimeDuration?: number;
    /**
     * The time unit for the `pairing_key_lifetime_duration` parameter.  Options are `HOURS` or `MINUTES`. Defaults to `MINUTES`.
     */
    pairingKeyLifetimeTimeunit?: string;
    /**
     * Specifies whether push notification is enabled or disabled for the policy.
     */
    pushEnabled: boolean;
    /**
     * The number of consecutive push notifications that can be ignored or rejected by a user within a defined period before push notifications are blocked for the application. The minimum value is 1 and the maximum value is 50. If this parameter is not provided, the default value is 5. Defaults to `5`.
     */
    pushLimitCount?: number;
    /**
     * The length of time that push notifications should be blocked for the application if the defined limit has been reached. The minimum value is 1 minute and the maximum value is 120 minutes. If this parameter is not provided, the default value is 30 minutes. Defaults to `30`.
     */
    pushLimitLockDuration?: number;
    /**
     * The time unit for the `push_limit_lock_duration` parameter.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    pushLimitLockDurationTimeunit?: string;
    /**
     * The time period in which the push notifications are counted towards the defined limit. The minimum value is 1 minute and the maximum value is 120 minutes. If this parameter is not provided, the default value is 10 minutes. Defaults to `10`.
     */
    pushLimitTimePeriodDuration?: number;
    /**
     * The time unit for the `push_limit_time_period_duration` parameter.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    pushLimitTimePeriodTimeunit?: string;
    /**
     * An integer that defines the amount of time (in seconds) a user has to respond to a push notification before it expires. Minimum is 40 seconds and maximum is 150 seconds. If this parameter is not provided, the duration is set to 40 seconds. Defaults to `40`.
     */
    pushTimeoutDuration?: number;
    /**
     * The time unit for the `push_timeout_duration` parameter. Currently, the only permitted value is `SECONDS`.
     */
    pushTimeoutTimeunit: string;
}

export interface MfaPolicyPlatform {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * Specifies the FIDO policy ID. This property can be null. When null, the environment's default FIDO Policy is used.
     */
    fidoPolicyId?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicySecurityKey {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * Specifies the FIDO policy ID. This property can be null. When null, the environment's default FIDO Policy is used.
     */
    fidoPolicyId?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicySms {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. Note that when using the "onetime authentication" feature, the user is not blocked after the maximum number of failures even if you specified a block duration. Defaults to `0`.
     */
    otpFailureCooldownDuration?: number;
    /**
     * The type of time unit for `otp_failure_cooldown_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpFailureCooldownTimeunit?: string;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. Defaults to `3`.
     */
    otpFailureCount?: number;
    /**
     * An integer that defines turation (number of time units) that the passcode is valid before it expires. Defaults to `30`.
     */
    otpLifetimeDuration?: number;
    /**
     * The type of time unit for `otp_lifetime_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpLifetimeTimeunit?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicyTotp {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. Defaults to `2`.
     */
    otpFailureCooldownDuration?: number;
    /**
     * The type of time unit for `otp_failure_cooldown_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpFailureCooldownTimeunit?: string;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. Defaults to `3`.
     */
    otpFailureCount?: number;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaPolicyVoice {
    /**
     * Enabled or disabled in the policy.
     */
    enabled: boolean;
    /**
     * An integer that defines the duration (number of time units) the user is blocked after reaching the maximum number of passcode failures. Note that when using the "onetime authentication" feature, the user is not blocked after the maximum number of failures even if you specified a block duration. Defaults to `0`.
     */
    otpFailureCooldownDuration?: number;
    /**
     * The type of time unit for `otp_failure_cooldown_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpFailureCooldownTimeunit?: string;
    /**
     * An integer that defines the maximum number of times that the OTP entry can fail for a user, before they are blocked. Defaults to `3`.
     */
    otpFailureCount?: number;
    /**
     * An integer that defines turation (number of time units) that the passcode is valid before it expires. Defaults to `30`.
     */
    otpLifetimeDuration?: number;
    /**
     * The type of time unit for `otp_lifetime_duration`.  Options are `MINUTES` or `SECONDS`. Defaults to `MINUTES`.
     */
    otpLifetimeTimeunit?: string;
    /**
     * You can set this parameter to `true` to prevent users from pairing new devices with the relevant method, though keeping it active in the policy for existing users. You can use this option if you want to phase out an existing authentication method but want to allow users to continue using the method for authentication for existing devices. Defaults to `false`.
     */
    pairingDisabled?: boolean;
}

export interface MfaSettingsLockout {
    /**
     * An integer that defines the number of seconds to keep the account in a locked state
     */
    durationSeconds?: number;
    /**
     * An integer that defines the maximum number of incorrect authentication attempts before the account is locked.
     */
    failureCount: number;
}

export interface MfaSettingsPairing {
    /**
     * An integer that defines the maximum number of MFA devices each user can have. This can be any number from `1` to `15`. All devices that are Active or Blocked are subject to this limit.  Defaults to `5`.
     */
    maxAllowedDevices: number;
    /**
     * A string that controls the type of pairing key issued.  Options are `ALPHANUMERIC` (16-character alphanumeric key), `NUMERIC` (12-digit key).
     */
    pairingKeyFormat: string;
}

export interface MfaSettingsPhoneExtensions {
    /**
     * A boolean when set to `true` to allow one-time passwords to be delivered via voice to phone numbers that include extensions. Set to `false` to disable support for phone numbers with extensions. By default, support for extensions is disabled.
     */
    enabled: boolean;
}

export interface MfaSettingsUsers {
    /**
     * A boolean that, when set to `true`, will enable MFA by default for new users.
     */
    mfaEnabled: boolean;
}

export interface NotificationPolicyCountryLimit {
    /**
     * The countries where the specified methods should be allowed or denied. Use two-letter country codes from ISO 3166-1.  Required when `type` is not `NONE`.
     */
    countries?: string[];
    /**
     * The delivery methods that the defined limitation should be applied to. Content of the array can be `SMS`, `Voice`, or both. If the parameter is not provided, the default is `SMS` and `Voice`.
     */
    deliveryMethods: string[];
    /**
     * A string that specifies the kind of limitation being defined.  Options are `ALLOWED` (allows notifications only for the countries specified in the `countries` parameter), `DENIED` (denies notifications only for the countries specified in the `countries` parameter), `NONE` (no limitation is defined).
     */
    type: string;
}

export interface NotificationPolicyQuota {
    /**
     * The delivery methods for which the limit is being defined.  This limits defined in this block are configured as two groups, Voice/SMS, or Email.  Email cannot be configured with Voice and/or SMS limits.  Options are `Email` (configuration of Email limits but can not be set alongside `SMS` or `Voice`), `SMS` (configuration of SMS limits and can be set alongside `Voice`, but not `Email`), `Voice` (configuration of Voice limits and can be set alongside `SMS`, but not `Email`).  Defaults to `["SMS", "Voice"]`.
     */
    deliveryMethods: string[];
    /**
     * The maximum number of notifications allowed per day.  Cannot be set with `used` and `unused`.
     */
    total?: number;
    /**
     * A string to specify whether the limit defined is per-user or per environment.  Options are `ENVIRONMENT`, `USER`.
     */
    type: string;
    /**
     * The maximum number of notifications that can be received and not responded to each day. Must be configured with `used` and cannot be configured with `total`.
     */
    unused?: number;
    /**
     * The maximum number of notifications that can be received and responded to each day. Must be configured with `unused` and cannot be configured with `total`.
     */
    used?: number;
}

export interface NotificationSettingsAllowedList {
    /**
     * A string that specifies the user ID to add to the allowed list.  Must be a valid PingOne resource ID.
     */
    userId: string;
}

export interface NotificationSettingsEmailFrom {
    /**
     * A string that specifies the email sender's "from" email address.
     */
    emailAddress: string;
    /**
     * A string that specifies the email sender's "from" name.
     */
    name?: string;
}

export interface NotificationSettingsEmailReplyTo {
    /**
     * A string that specifies the email sender's "reply to" email address.
     */
    emailAddress: string;
    /**
     * A string that specifies the email sender's "reply to" name.
     */
    name?: string;
}

export interface NotificationSettingsFrom {
    /**
     * A string that specifies the email sender's "from" email address.  Defaults to `noreply@pingidentity.com`.
     */
    emailAddress: string;
    /**
     * A string that specifies the email sender's "from" name.  Defaults to `PingOne`.
     */
    name?: string;
}

export interface NotificationSettingsReplyTo {
    /**
     * A string that specifies the email sender's "reply to" email address.
     */
    emailAddress: string;
    /**
     * A string that specifies the email sender's "reply to" name.
     */
    name?: string;
}

export interface NotificationTemplateContentEmail {
    /**
     * A string representing the email body. Email text can contain HTML but cannot be larger than 100 kB.  Use of variables is supported.
     */
    body: string;
    /**
     * A string that specifies the email's character set.  Defaults to `UTF-8`.
     */
    characterSet: string;
    /**
     * A string that specifies the email's content-type.  Defaults to `text/html`.
     */
    contentType: string;
    /**
     * A single object that specifies properties for the email sender.
     */
    from?: outputs.NotificationTemplateContentEmailFrom;
    /**
     * A single object that specifies properties for the email "reply to" address.
     */
    replyTo?: outputs.NotificationTemplateContentEmailReplyTo;
    /**
     * A string representing the email's subject line. Cannot exceed 256 characters. Can include variables.
     */
    subject: string;
}

export interface NotificationTemplateContentEmailFrom {
    /**
     * A string that specifies the sender email address. If the environment uses the Ping Identity email sender, or if the address field is empty, the address `noreply@pingidentity.com` is used.  You can configure other email sender addresses per environment.
     */
    address: string;
    /**
     * A string that specifies the email's sender name.  If the environment uses the Ping Identity email sender, the name `PingOne` is used. You can configure other email sender names per environment.
     */
    name: string;
}

export interface NotificationTemplateContentEmailReplyTo {
    /**
     * A string that specifies the "reply to" email address.  If the environment uses the Ping Identity email sender, or if the address field is empty, the address `noreply@pingidentity.com` is used.  You can configure other email "reply to" addresses per environment.
     */
    address: string;
    /**
     * A string that specifies the email's "reply to" name.  If the environment uses the Ping Identity email sender, the name `PingOne` is used.  You can configure other email "reply to" names per environment.
     */
    name: string;
}

export interface NotificationTemplateContentPush {
    /**
     * A string that specifies the push notification text. This can include variables.
     */
    body: string;
    /**
     * A string that specifies what type of banner should be displayed to the user.  Options are `APPROVE_AND_OPEN_APP` (when the Approve button is clicked, authentication is completed and the user is taken to the relevant application), `BANNER_BUTTONS` (the banner contains both Approve and Deny buttons), `WITHOUT_BANNER_BUTTONS` (when the user clicks the banner, they are taken to an application that contains the necessary approval controls).  Defaults to `BANNER_BUTTONS`.  Note that to use the non-default push banners, you must implement them in your application code, using the PingOne SDK. For details, see the [README for iOS](https://github.com/pingidentity/pingone-mobile-sdk-ios/#171-push-notifications-categories) and the [README for Android](https://github.com/pingidentity/pingone-mobile-sdk-android).
     */
    category: string;
    /**
     * A string that specifies the push notification title. This can include variables.
     */
    title: string;
}

export interface NotificationTemplateContentSms {
    /**
     * A string that specifies the SMS text. UC-2 encoding is used for text that contains non GSM-7 characters. UC-2 encoded text cannot exceed 67 characters. GSM-7 encoded text cannot exceed 153 characters. This can include variables.
     */
    content: string;
    /**
     * A string that specifies the SMS sender ID. This property can contain only alphanumeric characters and spaces, and its length cannot exceed 11 characters. In some countries, it is impossible to send an SMS with an alphanumeric sender ID. For those countries, the sender ID must be empty. For SMS recipients in specific countries, refer to Twilio's documentation on [International support for Alphanumeric Sender ID](https://support.twilio.com/hc/en-us/articles/223133767-International-support-for-Alphanumeric-Sender-ID).
     */
    sender?: string;
}

export interface NotificationTemplateContentVoice {
    /**
     * A string that specifies the voice text to read. This can include variables.
     */
    content: string;
    /**
     * A string that specifies the voice type desired for the message. Out of the box options include `Man`, `Woman`, `Alice` (Twilio only), `Amazon Polly`, or your own user-defined custom string. In the case that the selected voice type is not supported by the provider in the desired locale, another voice type will be automatically selected. Additional charges may be incurred for these selections, as determined by the sender.
     */
    type: string;
}

export interface PasswordPolicyHistory {
    /**
     * An integer that specifies the number of prior passwords to keep for prevention of password re-use. The value must be a positive, non-zero integer.
     */
    count: number;
    /**
     * An integer that specifies the length of time to keep recent passwords for prevention of password re-use. The value must be a positive, non-zero integer.
     */
    retentionDays: number;
}

export interface PasswordPolicyLength {
    /**
     * An integer that specifies the maximum number of characters allowed for the password. This property is not enforced when not present.  Defaults to `255`.  Fixed value of `255`.
     */
    max: number;
    /**
     * An integer that specifies the minimum number of characters required for the password. This can be from `8` to `32` (inclusive). This property is not enforced when not present.
     */
    min: number;
}

export interface PasswordPolicyLockout {
    /**
     * An integer that specifies the length of time before a password is automatically moved out of the lock out state. The value must be a positive, non-zero integer.
     */
    durationSeconds: number;
    /**
     * An integer that specifies the number of tries before a password is placed in the lockout state. The value must be a positive, non-zero integer.
     */
    failureCount: number;
}

export interface PasswordPolicyMinCharacters {
    /**
     * An integer that specifies the count of alphabetical uppercase characters (`abcdefghijklmnopqrstuvwxyz`) that should feature in the user's password.  Defaults to `1`.  Fixed value of `1`.
     */
    alphabeticalLowercase: number;
    /**
     * An integer that specifies the count of alphabetical uppercase characters (`ABCDEFGHIJKLMNOPQRSTUVWXYZ`) that should feature in the user's password.  Defaults to `1`.  Fixed value of `1`.
     */
    alphabeticalUppercase: number;
    /**
     * An integer that specifies the count of numeric characters (`0123456789`) that should feature in the user's password.  Defaults to `1`.  Fixed value of `1`.
     */
    numeric: number;
    /**
     * An integer that specifies the count of special characters (`~!@#$%^&*()-_=+[]{}\|;:,.<>/?`) that should feature in the user's password.  Defaults to `1`.  Fixed value of `1`.
     */
    specialCharacters: number;
}

export interface PhoneDeliverySettingsProviderCustom {
    /**
     * A single object that provides authentication settings for authenticating to the custom service API.
     */
    authentication: outputs.PhoneDeliverySettingsProviderCustomAuthentication;
    /**
     * The string that specifies the name of the custom provider used to identify in the PingOne platform.
     */
    name: string;
    /**
     * One or more objects that describe the numbers to use for phone delivery.
     */
    numbers?: outputs.PhoneDeliverySettingsProviderCustomNumber[];
    /**
     * One or more objects that describe the outbound custom notification requests.
     */
    requests: outputs.PhoneDeliverySettingsProviderCustomRequest[];
}

export interface PhoneDeliverySettingsProviderCustomAuthentication {
    /**
     * A string that specifies the authentication token to use for the custom provider account. Required when `method` is `BEARER`
     */
    authToken?: string;
    /**
     * The custom provider account's authentication method.  Options are `BASIC` (`username` and `password` parameters are required to be set), `BEARER` (`token` parameter is required to be set).
     */
    method: string;
    /**
     * A string that specifies the password for the custom provider account. Required when `method` is `BASIC`
     */
    password?: string;
    /**
     * A string that specifies the username for the custom provider account. Required when `method` is `BASIC`
     */
    username?: string;
}

export interface PhoneDeliverySettingsProviderCustomNumber {
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    available: boolean;
    /**
     * A collection of the types of phone delivery service capabilities.  Options are `SMS`, `VOICE`.
     */
    capabilities: string[];
    /**
     * A string that specifies the phone number, toll-free number or short code.
     */
    number: string;
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    selected: boolean;
    /**
     * Specifies the `number`'s supported countries for notification recipients, depending on the phone number type.  If an SMS template has an alphanumeric `sender` ID and also has short code, the `sender` ID will be used for destination countries that support both alphanumeric senders and short codes. For Unites States and Canada that don't support alphanumeric sender IDs, a short code will be used if both an alphanumeric sender and a short code are specified.
     *     - `SHORT_CODE`: A collection containing a single 2-character ISO country code, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified short code `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `TOLL_FREE`: A collection of valid 2-character country ISO codes, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified toll-free `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `PHONE_NUMBER`: this attribute cannot be specified.
     */
    supportedCountries?: string[];
    /**
     * A string that specifies the type of phone number.  Options are `PHONE_NUMBER`, `SHORT_CODE`, `TOLL_FREE`.
     */
    type: string;
}

export interface PhoneDeliverySettingsProviderCustomRequest {
    /**
     * For voice OTP notifications only.  A string that specifies a closing tag which is commonly used by custom providers for defining a pause between each number in the OTP number string.  Example value: `</Say> <Pause length="1"/>`
     */
    afterTag?: string;
    /**
     * For voice OTP notifications only.  A string that specifies an opening tag which is commonly used by custom providers for defining a pause between each number in the OTP number string.  Possible value: `<Say>`.
     */
    beforeTag?: string;
    /**
     * Optional when the `method` is `POST`.  A string that specifies the notification's request body. The body should include the `${to}` and `${message}` mandatory variables. For some vendors, the optional `${from}` variable may also be required. For example `messageType=ARN&message=${message}&phoneNumber=${to}&sender=${from}`.  In addition, you can use [dynamic variables](https://apidocs.pingidentity.com/pingone/platform/v1/api/#notifications-templates-dynamic-variables) and the following optional variables:
     *     - `${voice}` - the type of voice configured for notifications
     *     - `${locale}` - locale
     *     - `${otp}` - OTP
     *     - `${user.username}` - user's username
     *     - `${user.name.given}` - user's given name
     *     - `${user.name.family}` - user's family name
     */
    body?: string;
    /**
     * A string that specifies the notification's delivery method.  Options are `SMS`, `VOICE`.
     */
    deliveryMethod: string;
    /**
     * A map of strings that specifies the notification's request headers, matching the format of the request body. The header should include only one of the following if the `method` is set to `POST`:
     *     - `content-type` = `application/x-www-form-urlencoded` (where the `body` should be form encoded)
     *     - `content-type` = `application/json` (where the `body` should be JSON encoded)
     */
    headers?: {[key: string]: string};
    /**
     * A string that specifies the type of HTTP request method.  Options are `GET`, `POST`.
     */
    method: string;
    /**
     * A string that specifies the phone number format.  Options are `FULL` (The phone number format with a leading `+` sign, in the E.164 standard format.  For example: `+14155552671`), `NUMBER_ONLY` (The phone number format without a leading `+` sign, in the E.164 standard format.  For example: `14155552671`).  Defaults to `FULL`.
     */
    phoneNumberFormat: string;
    /**
     * The provider's remote gateway or customer gateway URL.  For requests using the `POST` method, use the provider's remote gateway URL.  For requests using the `GET` method, use the provider's remote gateway URL, including the `${to}` and `${message}` mandatory variables, and the optional `${from}` variable, for example: `https://api.transmitsms.com/send-sms.json?to=${to}&from=${from}&message=${message}`
     */
    url: string;
}

export interface PhoneDeliverySettingsProviderCustomSyniverse {
    /**
     * The secret key of the Syniverse account.  This field is immutable and will trigger a replace plan if changed.
     */
    authToken: string;
    /**
     * One or more objects that describe the numbers to use for phone delivery.
     */
    selectedNumbers: outputs.PhoneDeliverySettingsProviderCustomSyniverseSelectedNumber[];
    /**
     * One or more objects that describe the numbers that are defined in the Twilio service.
     */
    serviceNumbers: outputs.PhoneDeliverySettingsProviderCustomSyniverseServiceNumber[];
}

export interface PhoneDeliverySettingsProviderCustomSyniverseSelectedNumber {
    /**
     * A string that specifies the phone number, toll-free number or short code that has been configured in Twilio.
     */
    number: string;
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    selected: boolean;
    /**
     * Specifies the `number`'s supported countries for notification recipients, depending on the phone number type.  If an SMS template has an alphanumeric `sender` ID and also has short code, the `sender` ID will be used for destination countries that support both alphanumeric senders and short codes. For Unites States and Canada that don't support alphanumeric sender IDs, a short code will be used if both an alphanumeric sender and a short code are specified.
     *     - `SHORT_CODE`: A collection containing a single 2-character ISO country code, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified short code `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `TOLL_FREE`: A collection of valid 2-character country ISO codes, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified toll-free `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `PHONE_NUMBER`: this attribute cannot be specified.
     */
    supportedCountries?: string[];
    /**
     * A string that specifies the type of phone number.  Options are `PHONE_NUMBER`, `SHORT_CODE`, `TOLL_FREE`.
     */
    type: string;
}

export interface PhoneDeliverySettingsProviderCustomSyniverseServiceNumber {
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    available: boolean;
    /**
     * A collection of the types of phone delivery service capabilities.  Options are `SMS`, `VOICE`.
     */
    capabilities: string[];
    /**
     * A string that specifies the phone number, toll-free number or short code.
     */
    number: string;
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    selected: boolean;
    /**
     * Specifies the `number`'s supported countries for notification recipients, depending on the phone number type.  If an SMS template has an alphanumeric `sender` ID and also has short code, the `sender` ID will be used for destination countries that support both alphanumeric senders and short codes. For Unites States and Canada that don't support alphanumeric sender IDs, a short code will be used if both an alphanumeric sender and a short code are specified.
     *     - `SHORT_CODE`: A collection containing a single 2-character ISO country code, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified short code `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `TOLL_FREE`: A collection of valid 2-character country ISO codes, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified toll-free `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `PHONE_NUMBER`: this attribute cannot be specified.
     */
    supportedCountries: string[];
    /**
     * A string that specifies the type of phone number.  Options are `PHONE_NUMBER`, `SHORT_CODE`, `TOLL_FREE`.
     */
    type: string;
}

export interface PhoneDeliverySettingsProviderCustomTwilio {
    /**
     * The secret key of the Twilio account.  This field is immutable and will trigger a replace plan if changed.
     */
    authToken: string;
    /**
     * One or more objects that describe the numbers to use for phone delivery.
     */
    selectedNumbers: outputs.PhoneDeliverySettingsProviderCustomTwilioSelectedNumber[];
    /**
     * One or more objects that describe the numbers to use for phone delivery.
     */
    serviceNumbers: outputs.PhoneDeliverySettingsProviderCustomTwilioServiceNumber[];
    /**
     * The public ID of the Twilio account.  This field is immutable and will trigger a replace plan if changed.
     */
    sid: string;
}

export interface PhoneDeliverySettingsProviderCustomTwilioSelectedNumber {
    /**
     * A string that specifies the phone number, toll-free number or short code that has been configured in Twilio.
     */
    number: string;
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    selected: boolean;
    /**
     * Specifies the `number`'s supported countries for notification recipients, depending on the phone number type.  If an SMS template has an alphanumeric `sender` ID and also has short code, the `sender` ID will be used for destination countries that support both alphanumeric senders and short codes. For Unites States and Canada that don't support alphanumeric sender IDs, a short code will be used if both an alphanumeric sender and a short code are specified.
     *     - `SHORT_CODE`: A collection containing a single 2-character ISO country code, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified short code `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `TOLL_FREE`: A collection of valid 2-character country ISO codes, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified toll-free `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `PHONE_NUMBER`: this attribute cannot be specified.
     */
    supportedCountries?: string[];
    /**
     * A string that specifies the type of phone number.  Options are `PHONE_NUMBER`, `SHORT_CODE`, `TOLL_FREE`.
     */
    type: string;
}

export interface PhoneDeliverySettingsProviderCustomTwilioServiceNumber {
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    available: boolean;
    /**
     * A collection of the types of phone delivery service capabilities.  Options are `SMS`, `VOICE`.
     */
    capabilities: string[];
    /**
     * A string that specifies the phone number, toll-free number or short code.
     */
    number: string;
    /**
     * A boolean that specifies whether the number is currently available in the provider account.
     */
    selected: boolean;
    /**
     * Specifies the `number`'s supported countries for notification recipients, depending on the phone number type.  If an SMS template has an alphanumeric `sender` ID and also has short code, the `sender` ID will be used for destination countries that support both alphanumeric senders and short codes. For Unites States and Canada that don't support alphanumeric sender IDs, a short code will be used if both an alphanumeric sender and a short code are specified.
     *     - `SHORT_CODE`: A collection containing a single 2-character ISO country code, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified short code `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `TOLL_FREE`: A collection of valid 2-character country ISO codes, for example, `US`, `GB`, `CA`.
     *     If the custom provider is of `type` `CUSTOM_PROVIDER`, this attribute must not be empty or null.
     *     For other custom provider types, if this attribute is null (empty is not supported), the specified toll-free `number` can only be used to dispatch notifications to United States recipient numbers.
     *     - `PHONE_NUMBER`: this attribute cannot be specified.
     */
    supportedCountries: string[];
    /**
     * A string that specifies the type of phone number.  Options are `PHONE_NUMBER`, `SHORT_CODE`, `TOLL_FREE`.
     */
    type: string;
}

export interface ResourceApplicationPermissionsSettings {
    /**
     * A boolean setting to enable application permission claims in the access token.
     */
    claimEnabled: boolean;
}

export interface ResourceSecretPrevious {
    /**
     * A timestamp that specifies how long this secret is saved (and can be used) before it expires. Supported time range is 1 minute to 30 days.
     */
    expiresAt?: string;
    /**
     * A timestamp that specifies when the previous secret was last used.
     */
    lastUsed: string;
    /**
     * A string that specifies the previous resource secret. This property is returned in the response if the previous secret is not expired.
     */
    secret: string;
}

export interface RiskPolicyDefaultResult {
    /**
     * The default result level.  Options are `LOW`.
     */
    level: string;
    /**
     * The default result type.  Options are `VALUE`.
     */
    type: string;
}

export interface RiskPolicyOverride {
    /**
     * A single object that contains the conditions to evaluate that determine whether the override result will be applied to the risk policy evaluation.
     */
    condition: outputs.RiskPolicyOverrideCondition;
    /**
     * A string that represents the name of the overriding risk policy in the set.
     */
    name: string;
    /**
     * An integer that indicates the order in which the override is applied during risk policy evaluation.  The lower the value, the higher the priority.  The priority is determined by the order in which the overrides are defined in HCL.
     */
    priority: number;
    /**
     * A single object that contains the risk result that should be applied to the policy evaluation result when the override condition is met.
     */
    result: outputs.RiskPolicyOverrideResult;
}

export interface RiskPolicyOverrideCondition {
    /**
     * Required when `equals` is set to `VALUE_COMPARISON`.  A string that specifies the compact name of the predictor to apply to the override condition.
     */
    compactName?: string;
    /**
     * Required when `equals` is set to `VALUE_COMPARISON`.  A string that specifies the value of the `predictor_reference_value` that must be matched for the override result to be applied to the policy evaluation.
     */
    equals?: string;
    /**
     * Required when `equals` is set to `IP_RANGE`.  A set of strings that specifies the CIDR ranges that should be evaluated against the value of the `predictor_reference_contains` attribute, that must be matched for the override result to be applied to the policy evaluation.  Values must be valid IPv4 or IPv6 CIDR ranges.
     */
    ipRanges?: string[];
    /**
     * A string that specifies the attribute reference of the collection to evaluate.
     */
    predictorReferenceContains: string;
    /**
     * A string that specifies the attribute reference of the value to evaluate.
     */
    predictorReferenceValue: string;
    /**
     * A string that specifies the type of the override condition to evaluate.  Options are `IP_RANGE`, `VALUE_COMPARISON`.
     */
    type: string;
}

export interface RiskPolicyOverrideResult {
    /**
     * A string that specifies the risk level that should be applied to the policy evalution result when the override condition is met.  Options are `HIGH`, `LOW`, `MEDIUM`.
     */
    level: string;
    /**
     * A string that specifies the type of the risk result should be applied to the policy evalution result when the override condition is met.  Options are `VALUE`.  Defaults to `VALUE`.
     */
    type: string;
    /**
     * An administrator defined string value that is applied to the policy evaluation result when the override condition is met.
     */
    value?: string;
}

export interface RiskPolicyPolicyScores {
    /**
     * An object that specifies the lower and upper bound threshold values that define the high risk outcome as a result of the policy evaluation.
     */
    policyThresholdHigh: outputs.RiskPolicyPolicyScoresPolicyThresholdHigh;
    /**
     * An object that specifies the lower and upper bound threshold values that define the medium risk outcome as a result of the policy evaluation.
     */
    policyThresholdMedium: outputs.RiskPolicyPolicyScoresPolicyThresholdMedium;
    /**
     * An object that describes a predictor to apply to the risk policy and its associated high risk / true outcome score to apply to the risk calculation.
     */
    predictors: outputs.RiskPolicyPolicyScoresPredictor[];
}

export interface RiskPolicyPolicyScoresPolicyThresholdHigh {
    /**
     * An integer that specifies the maxiumum score to use as the lower bound value of the policy threshold.
     */
    maxScore: number;
    /**
     * An integer that specifies the minimum score to use as the lower bound value of the policy threshold.  Maximum value allowed is `1000`
     */
    minScore: number;
}

export interface RiskPolicyPolicyScoresPolicyThresholdMedium {
    /**
     * An integer that specifies the maxiumum score to use as the lower bound value of the policy threshold.
     */
    maxScore: number;
    /**
     * An integer that specifies the minimum score to use as the lower bound value of the policy threshold.  Maximum value allowed is `1000`
     */
    minScore: number;
}

export interface RiskPolicyPolicyScoresPredictor {
    /**
     * A string that specifies the compact name of the predictor to apply to the risk policy.
     */
    compactName: string;
    /**
     * A string that specifies the attribute reference of the level to evaluate.
     */
    predictorReferenceValue: string;
    /**
     * An integer that specifies the score to apply to the High risk / true outcome of the predictor, to apply to the overall risk calculation.
     */
    score: number;
}

export interface RiskPolicyPolicyWeights {
    /**
     * An object that specifies the lower and upper bound threshold score values that define the high risk outcome as a result of the policy evaluation.
     */
    policyThresholdHigh: outputs.RiskPolicyPolicyWeightsPolicyThresholdHigh;
    /**
     * An object that specifies the lower and upper bound threshold score values that define the medium risk outcome as a result of the policy evaluation.
     */
    policyThresholdMedium: outputs.RiskPolicyPolicyWeightsPolicyThresholdMedium;
    /**
     * An object that describes a predictor to apply to the risk policy and its associated weight value for the overall weighted average risk calculation.
     */
    predictors: outputs.RiskPolicyPolicyWeightsPredictor[];
}

export interface RiskPolicyPolicyWeightsPolicyThresholdHigh {
    /**
     * An integer that specifies the maxiumum score to use as the lower bound value of the policy threshold.
     */
    maxScore: number;
    /**
     * An integer that specifies the minimum score to use as the lower bound value of the policy threshold.  For weights policies, the score values should be 10x the desired risk value in the console. For example, a risk score of `5` in the console should be entered as `50`.  The provided score must be exactly divisible by 10.  Maximum value allowed is `100`
     */
    minScore: number;
}

export interface RiskPolicyPolicyWeightsPolicyThresholdMedium {
    /**
     * An integer that specifies the maxiumum score to use as the lower bound value of the policy threshold.
     */
    maxScore: number;
    /**
     * An integer that specifies the minimum score to use as the lower bound value of the policy threshold.  For weights policies, the score values should be 10x the desired risk value in the console. For example, a risk score of `5` in the console should be entered as `50`.  The provided score must be exactly divisible by 10.  Maximum value allowed is `100`
     */
    minScore: number;
}

export interface RiskPolicyPolicyWeightsPredictor {
    /**
     * A string that specifies the compact name of the predictor to apply to the risk policy.
     */
    compactName: string;
    /**
     * A string that specifies the attribute reference of the level to evaluate.
     */
    predictorReferenceValue: string;
    /**
     * An integer that specifies the weight to apply to the predictor when calculating the overall risk score.
     */
    weight: number;
}

export interface RiskPredictorDefault {
    /**
     * A single nested object that contains the result assigned to the predictor if the predictor could not be calculated during the risk evaluation. If this field is not provided, and the predictor could not be calculated during risk evaluation, the behavior is: 1) If the predictor is used in an override, the override is skipped; 2) In the weighted policy, the predictor will have a `weight` of `0`.
     */
    result: outputs.RiskPredictorDefaultResult;
    /**
     * A number that specifies the default weight for the risk predictor. This value is used when the risk predictor is not explicitly configured in a policy.  Defaults to `5`.
     */
    weight: number;
}

export interface RiskPredictorDefaultResult {
    /**
     * The default result level.  Options are `HIGH`, `LOW`, `MEDIUM`.
     */
    level: string;
    /**
     * The default result type.  Options are `VALUE` (any custom attribute value that's defined).
     */
    type: string;
}

export interface RiskPredictorPredictorAdversaryInTheMiddle {
    /**
     * A set of domains that are ignored for the predictor results.
     */
    allowedDomainLists: string[];
}

export interface RiskPredictorPredictorAnonymousNetwork {
    /**
     * A set of IP addresses (CIDRs) that are ignored for the predictor results. The list can include IPs in IPv4 format and IPs in IPv6 format.
     */
    allowedCidrLists: string[];
}

export interface RiskPredictorPredictorBotDetection {
}

export interface RiskPredictorPredictorComposite {
    /**
     * Contains the composition of risk factors you want to use, and the condition logic that determines when or whether a risk factor is applied.
     */
    composition: outputs.RiskPredictorPredictorCompositeComposition;
}

export interface RiskPredictorPredictorCompositeComposition {
    /**
     * A string that specifies the condition logic for the composite risk predictor as applied to the service.
     */
    condition: string;
    /**
     * A string that specifies the condition logic for the composite risk predictor. The value must be a valid JSON string.
     */
    conditionJson: string;
    /**
     * A string that specifies the risk level for the composite risk predictor.  Options are `HIGH`, `LOW`, `MEDIUM`.
     */
    level: string;
}

export interface RiskPredictorPredictorCustomMap {
    /**
     * A single nested object that describes the upper and lower bounds of ranges of values that apply to the attribute reference in `predictor_custom_map.contains`, that map to high, medium or low risk results.
     */
    betweenRanges?: outputs.RiskPredictorPredictorCustomMapBetweenRanges;
    contains: string;
    /**
     * A single nested object that describes IP CIDR ranges of values that apply to the attribute reference in `predictor_custom_map.contains`, that map to high, medium or low risk results.
     */
    ipRanges?: outputs.RiskPredictorPredictorCustomMapIpRanges;
    /**
     * A single nested object that describes the string values that apply to the attribute reference in `predictor_custom_map.contains`, that map to high, medium or low risk results.
     */
    stringList?: outputs.RiskPredictorPredictorCustomMapStringList;
    /**
     * A string that specifies the type of custom map predictor.
     */
    type: string;
}

export interface RiskPredictorPredictorCustomMapBetweenRanges {
    /**
     * A single nested object that describes the upper and lower bounds of ranges that map to a high risk result.
     */
    high?: outputs.RiskPredictorPredictorCustomMapBetweenRangesHigh;
    /**
     * A single nested object that describes the upper and lower bounds of ranges that map to a low risk result.
     */
    low?: outputs.RiskPredictorPredictorCustomMapBetweenRangesLow;
    /**
     * A single nested object that describes the upper and lower bounds of ranges that map to a medium risk result.
     */
    medium?: outputs.RiskPredictorPredictorCustomMapBetweenRangesMedium;
}

export interface RiskPredictorPredictorCustomMapBetweenRangesHigh {
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    maxValue: number;
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    minValue: number;
}

export interface RiskPredictorPredictorCustomMapBetweenRangesLow {
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    maxValue: number;
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    minValue: number;
}

export interface RiskPredictorPredictorCustomMapBetweenRangesMedium {
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    maxValue: number;
    /**
     * A number that specifies the minimum value of the attribute named in `predictor_custom_map.contains`.  This represents the lower bound of this risk result range.
     */
    minValue: number;
}

export interface RiskPredictorPredictorCustomMapIpRanges {
    /**
     * A single nested object that describes the IP CIDR ranges that map to a high risk result.
     */
    high?: outputs.RiskPredictorPredictorCustomMapIpRangesHigh;
    /**
     * A single nested object that describes the IP CIDR ranges that map to a low risk result.
     */
    low?: outputs.RiskPredictorPredictorCustomMapIpRangesLow;
    /**
     * A single nested object that describes the IP CIDR ranges that map to a medium risk result.
     */
    medium?: outputs.RiskPredictorPredictorCustomMapIpRangesMedium;
}

export interface RiskPredictorPredictorCustomMapIpRangesHigh {
    /**
     * A set of strings, in CIDR format, that describe the CIDR ranges that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorCustomMapIpRangesLow {
    /**
     * A set of strings, in CIDR format, that describe the CIDR ranges that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorCustomMapIpRangesMedium {
    /**
     * A set of strings, in CIDR format, that describe the CIDR ranges that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorCustomMapStringList {
    /**
     * A single nested object that describes the string values that map to a high risk result.
     */
    high?: outputs.RiskPredictorPredictorCustomMapStringListHigh;
    /**
     * A single nested object that describes the string values that map to a low risk result.
     */
    low?: outputs.RiskPredictorPredictorCustomMapStringListLow;
    /**
     * A single nested object that describes the string values that map to a medium risk result.
     */
    medium?: outputs.RiskPredictorPredictorCustomMapStringListMedium;
}

export interface RiskPredictorPredictorCustomMapStringListHigh {
    /**
     * A set of strings that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorCustomMapStringListLow {
    /**
     * A set of strings that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorCustomMapStringListMedium {
    /**
     * A set of strings that should evaluate against the value of the attribute named in `predictor_custom_map.contains` for this risk result.
     */
    values?: string[];
}

export interface RiskPredictorPredictorDevice {
    /**
     * A string that represents a date on which the learning process for the device predictor should be restarted.  Can only be configured where the `detect` parameter is `NEW_DEVICE`. This can be used in conjunction with the fallback setting (`default.result.level`) to force strong authentication when moving the predictor to production. The date should be in an RFC3339 format. Note that activation date uses UTC time.
     */
    activationAt?: string;
    /**
     * A string that represents the type of device detection to use.  Options are `NEW_DEVICE` (to configure a model based on new devices), `SUSPICIOUS_DEVICE` (to configure a model based on detection of suspicious devices).  Defaults to `NEW_DEVICE`.
     */
    detect: string;
}

export interface RiskPredictorPredictorEmailReputation {
}

export interface RiskPredictorPredictorGeovelocity {
    /**
     * A set of IP addresses (CIDRs) that are ignored for the predictor results. The list can include IPs in IPv4 format and IPs in IPv6 format.
     */
    allowedCidrLists: string[];
}

export interface RiskPredictorPredictorIpReputation {
    /**
     * A set of IP addresses (CIDRs) that are ignored for the predictor results. The list can include IPs in IPv4 format and IPs in IPv6 format.
     */
    allowedCidrLists: string[];
}

export interface RiskPredictorPredictorUserLocationAnomaly {
    /**
     * An integer that specifies the number of days to apply to the predictor evaluation.
     */
    days: number;
    /**
     * A single nested object that specifies options for the radius to apply to the predictor evaluation
     */
    radius?: outputs.RiskPredictorPredictorUserLocationAnomalyRadius;
}

export interface RiskPredictorPredictorUserLocationAnomalyRadius {
    /**
     * An integer that specifies the distance to apply to the predictor evaluation.
     */
    distance: number;
    /**
     * A string that specifies the unit of distance to apply to the predictor distance.  Options are `kilometers`, `miles`.  Defaults to `kilometers`.
     */
    unit: string;
}

export interface RiskPredictorPredictorUserRiskBehavior {
    /**
     * A single nested object that specifies options for the prediction model to apply to the predictor evaluation.
     */
    predictionModel: outputs.RiskPredictorPredictorUserRiskBehaviorPredictionModel;
}

export interface RiskPredictorPredictorUserRiskBehaviorPredictionModel {
    /**
     * A string that specifies the name of the prediction model to apply to the predictor evaluation.  Options are `login_anomaly_statistic` (to configure the organisation based risk model), `points` (to configure the user-based risk model).
     */
    name: string;
}

export interface RiskPredictorPredictorVelocity {
    /**
     * A set of string values that specifies the attribute references that denote the subject of the velocity metric.  Options are `${event.ip}` (denotes the velocity metric is calculated by IP address), `${event.user.id}` (denotes the velocity metric is calculated by user ID).
     */
    bies: string[];
    /**
     * A single nested object that specifies options for the granularlity of data sampling.
     */
    every: outputs.RiskPredictorPredictorVelocityEvery;
    /**
     * A single nested object that specifies options for the predictor fallback strategy.
     */
    fallback: outputs.RiskPredictorPredictorVelocityFallback;
    /**
     * A string value that specifies the type of measure to use for the predictor.  Options are `DISTINCT_COUNT`.  Defaults to `DISTINCT_COUNT`.
     */
    measure: string;
    of: string;
    /**
     * A single nested object that specifies options for the distribution of data that is compared against to detect anomaly.
     */
    slidingWindow: outputs.RiskPredictorPredictorVelocitySlidingWindow;
    /**
     * A single nested object that specifies options for the velocity algorithm.
     */
    use: outputs.RiskPredictorPredictorVelocityUse;
}

export interface RiskPredictorPredictorVelocityEvery {
    /**
     * An integer that denotes the minimum sample of data to use for the velocity algorithm.
     */
    minSample: number;
    /**
     * An integer that denotes the quantity of unit intervals to use for the velocity algorithm.
     */
    quantity: number;
    /**
     * A string value that specifies the time unit to use when sampling data.  Options are `DAY`, `HOUR`.
     */
    unit: string;
}

export interface RiskPredictorPredictorVelocityFallback {
    /**
     * A floating point value that specifies a high risk threshold for the fallback strategy.
     */
    high: number;
    /**
     * A floating point value that specifies a medium risk threshold for the fallback strategy.
     */
    medium: number;
    /**
     * A string value that specifies the type of fallback strategy algorithm to use.  Options are `ENVIRONMENT_MAX`.
     */
    strategy: string;
}

export interface RiskPredictorPredictorVelocitySlidingWindow {
    /**
     * An integer that denotes the minimum sample of data to use for the velocity algorithm.
     */
    minSample: number;
    /**
     * An integer that denotes the quantity of unit intervals to use for the velocity algorithm.
     */
    quantity: number;
    /**
     * A string value that specifies the time unit to use when sampling data over time.  Options are `DAY`, `HOUR`.
     */
    unit: string;
}

export interface RiskPredictorPredictorVelocityUse {
    /**
     * A floating point value that specifies a high risk threshold for the velocity algorithm.
     */
    high: number;
    /**
     * A floating point value that specifies a medium risk threshold for the velocity algorithm.
     */
    medium: number;
    /**
     * A string value that specifies the type of velocity algorithm to use.  Options are `POISSON_WITH_MAX`.
     */
    type: string;
}

export interface SchemaAttributeEnumeratedValue {
    /**
     * A boolean that specifies whether the enumerated value is archived. Archived values cannot be added to a user, but existing archived values are preserved. This allows clients that read the schema to know all possible values of an attribute.
     */
    archived: boolean;
    /**
     * A string that specifies the description of the enumerated value.
     */
    description?: string;
    /**
     * A string that specifies the value of the enumerated value item. If provided, it must not be an empty string.
     */
    value: string;
}

export interface SchemaAttributeRegexValidation {
    /**
     * A string that specifies the regular expression to which the attribute must conform.
     */
    pattern: string;
    /**
     * A string that specifies a developer friendly description of the regular expression requirements.
     */
    requirements: string;
    /**
     * A set of one or more strings matching the regular expression.
     */
    valuesPatternShouldMatches?: string[];
    /**
     * A set of one or more strings that do not match the regular expression.
     */
    valuesPatternShouldNotMatches?: string[];
}

export interface SignOnPolicyActionAgreement {
    /**
     * A string that specifies the ID of the agreement to which the user must consent.
     */
    agreementId: string;
    /**
     * When enabled, the `Do Not Accept` button will terminate the Flow and display an error message to the user. Defaults to `true`.
     */
    showDeclineOption?: boolean;
}

export interface SignOnPolicyActionConditions {
    /**
     * A boolean that specifies whether the user should be prompted for re-authentication on this action based on a detected anonymous network.  Applies to policy actions of type `mfa`. Defaults to `false`.
     */
    anonymousNetworkDetected?: boolean;
    /**
     * A list of allowed CIDR when an anonymous network is detected.  Applies to policy actions of type `mfa`.
     */
    anonymousNetworkDetectedAllowedCidrs?: string[];
    /**
     * A boolean that specifies whether the user should be prompted for re-authentication on this action based on a detected geovelocity anomaly.  Applies to policy actions of type `mfa`. Defaults to `false`.
     */
    geovelocityAnomalyDetected?: boolean;
    /**
     * A list of strings that specifies the supported network IP addresses expressed as classless inter-domain routing (CIDR) strings.  Applies to policy actions of type `mfa`.
     */
    ipOutOfRangeCidrs?: string[];
    /**
     * A boolean that specifies whether the user's IP risk should be used when evaluating this policy action.  A value of `HIGH` will prompt the user to authenticate with this action.  Applies to policy actions of type `mfa`. Defaults to `false`.
     */
    ipReputationHighRisk?: boolean;
    /**
     * Set the number of seconds by which the user will not be prompted for this action following the last successful authentication.  Applies to policy actions of type `identifier_first`, `identity_provider`, `login`, `mfa`.
     */
    lastSignOnOlderThanSeconds?: number;
    /**
     * Set the number of seconds by which the user will not be prompted for this action following the last successful authentication of an MFA authenticator device.  Applies to policy actions of type `mfa`.
     */
    lastSignOnOlderThanSecondsMfa?: number;
    /**
     * One or more conditions where an attribute on the user's profile must match the configured value.  Applies to policy actions of type `identifier_first`, `login`, `mfa`, but cannot be set on policy actions where the priority is `1`.
     */
    userAttributeEquals?: outputs.SignOnPolicyActionConditionsUserAttributeEqual[];
    /**
     * Activate this action only for users within the specified list of population IDs.  Applies to policy actions of type `identifier_first`, `login`, `mfa`, but cannot be set on policy actions where the priority is `1`.
     */
    userIsMemberOfAnyPopulationIds?: string[];
}

export interface SignOnPolicyActionConditionsUserAttributeEqual {
    /**
     * Specifies the user attribute used in the condition. Only string core, standard, and custom attributes are supported. For complex attribute types, you must reference the sub-attribute (`$${user.name.firstName}`).  Note values that begin with a dollar sign (`$`) must be prefixed with an additional dollar sign.  E.g. `${name.given}` should be configured as `$${name.given}`.  When configured, one of `value` (for attributes of type `STRING` or `INTEGER`) or `value_boolean` (for attributes of type `BOOLEAN`) must be provided.
     */
    attributeReference: string;
    /**
     * The string or integer (as string) value of the attribute (declared in `attribute_reference`) on the user profile that should be matched.  This value parameter should be used where the data type of the schema attribute in `attribute_reference` is of type `STRING` or `INTEGER`.  Conflicts with `value_boolean`.
     */
    value?: string;
    /**
     * The boolean value of the attribute (declared in `attribute_reference`) on the user profile that should be matched.  This value parameter should be used where the data type of the schema attribute in `attribute_reference` is of type `BOOLEAN` (e.g `$${user.emailVerified}`, `$${user.verified}` and `$${user.mfaEnabled}`).  Conflicts with `value`.
     */
    valueBoolean?: boolean;
}

export interface SignOnPolicyActionIdentifierFirst {
    /**
     * One or more IDP discovery rules invoked when no user is associated with the user identifier. The condition on which this identity provider is used to authenticate the user is expressed using the PingOne policy condition language.
     */
    discoveryRules?: outputs.SignOnPolicyActionIdentifierFirstDiscoveryRule[];
    /**
     * A boolean that specifies whether account recovery features are active on the policy action. Defaults to `true`.
     */
    recoveryEnabled?: boolean;
}

export interface SignOnPolicyActionIdentifierFirstDiscoveryRule {
    /**
     * Text to match on a user's username. Any users that don't match a discovery rule will authenticate against PingOne.  E.g `@pingidentity.com`
     */
    attributeContainsText: string;
    /**
     * The ID that specifies the identity provider that will be used to authenticate the user if the condition is matched.
     */
    identityProviderId: string;
}

export interface SignOnPolicyActionIdentityProvider {
    /**
     * A string that designates the sign-on policies included in the authorization flow request. Options can include the PingOne predefined sign-on policies, Single_Factor and Multi_Factor, or any custom defined sign-on policy names. Sign-on policy names should be listed in order of preference, and they must be assigned to the application. This property can be configured on the identity provider action and is passed to the identity provider if the identity provider is of type `SAML` or `OPENID_CONNECT`.
     */
    acrValues?: string;
    /**
     * A string that specifies the ID of the external identity provider to which the user is redirected for sign-on.
     */
    identityProviderId: string;
    /**
     * A boolean that specifies whether to pass in a login hint to the identity provider on the sign on request. Based on user context, the login hint is set if (1) the user is set on the flow, and (2) the user already has an account link for the identity provider. If both of these conditions are true, then the user is sent to the identity provider with a login hint equal to their externalId for the identity provider (saved on the account link). If these conditions are not true, then the API checks see if there is an OIDC login hint on the flow. If so, that login hint is used. If none of these conditions are true, the login hint parameter is not included on the authorization request to the identity provider.
     */
    passUserContext?: boolean;
}

export interface SignOnPolicyActionLogin {
    /**
     * Enables user entries existing outside of PingOne to be provisioned during login, using an external integration solution (such as a Gateway).
     */
    newUserProvisioning?: outputs.SignOnPolicyActionLoginNewUserProvisioning;
    /**
     * A boolean that specifies whether account recovery features are active on the policy action. Defaults to `true`.
     */
    recoveryEnabled?: boolean;
}

export interface SignOnPolicyActionLoginNewUserProvisioning {
    /**
     * One or more blocks that describe a preconfigured gateway and user type that are specified in the Gateway Management schema to determine how to find and migrate user entries existing in an external directory.
     */
    gateways: outputs.SignOnPolicyActionLoginNewUserProvisioningGateway[];
}

export interface SignOnPolicyActionLoginNewUserProvisioningGateway {
    /**
     * A string that specifies the UUID ID of the gateway instance.  The ID may come from the `id` parameter of the `pingone.Gateway` resource.  Must be a valid PingOne resource ID.
     */
    id: string;
    /**
     * A string that specifies the type of the gateway. Currently, only `LDAP` is supported. Defaults to `LDAP`.
     */
    type?: string;
    /**
     * A string that specifies the UUID ID of the user type within the gateway instance.  The ID may come from the `user_type[*].id` parameter of the `pingone.Gateway` resource.  Must be a valid PingOne resource ID.
     */
    userTypeId: string;
}

export interface SignOnPolicyActionMfa {
    /**
     * The ID of the MFA policy that should be used.
     */
    deviceSignOnPolicyId: string;
    /**
     * A string that specifies the device mode for the MFA flow. Options are `BYPASS` to allow MFA without a specified device, or `BLOCK` to block the MFA flow if no device is specified. To use this configuration option, the authorize request must include a signed `login_hint_token` property. For more information, see Authorize (Browserless and MFA Only Flows). Defaults to `BLOCK`.
     */
    noDeviceMode?: string;
}

export interface SignOnPolicyActionPingid {
}

export interface SignOnPolicyActionPingidWindowsLoginPasswordless {
    /**
     * A boolean that specifies whether to allow users to log in when PingOne and or PingID are not available.
     */
    offlineModeEnabled: boolean;
    /**
     * A string that specifies the schema attribute to match against the provided identifier when searching for a user in the directory. Only unique attributes in the directory schema may be configured.
     */
    uniqueUserAttributeName: string;
}

export interface SignOnPolicyActionProgressiveProfiling {
    /**
     * One or more attribute(s) that the user should be prompted to complete as part of the progressive profiling action.
     */
    attributes: outputs.SignOnPolicyActionProgressiveProfilingAttribute[];
    /**
     * A boolean that specifies whether the progressive profiling action will not be executed if another progressive profiling action has already been executed during the flow. Defaults to `true`.
     */
    preventMultiplePromptsPerFlow?: boolean;
    /**
     * An integer that specifies how often to prompt the user to provide profile data for the configured attributes for which they do not have values. Defaults to `7776000`.
     */
    promptIntervalSeconds?: number;
    /**
     * A string that specifies text to display to the user when prompting for attribute values.
     */
    promptText: string;
}

export interface SignOnPolicyActionProgressiveProfilingAttribute {
    /**
     * A string that specifies the name and path of the user profile attribute as defined in the user schema (for example, email or address.postalCode).
     */
    name: string;
    /**
     * A boolean that specifies whether the user is required to provide a value for the attribute.
     */
    required: boolean;
}

export interface SystemApplicationAccessControlGroupOptions {
    /**
     * A set that specifies the group IDs for the groups the actor must belong to for access to the application.
     */
    groups: string[];
    /**
     * A string that specifies the group type required to access the application.  Options are `ALL_GROUPS` (the actor must belong to all groups listed in the `groups` property), `ANY_GROUP` (the actor must belong to at least one group listed in the `groups` property).
     */
    type: string;
}

export interface UserAccount {
    /**
     * A boolean that specifies whether the user can authenticate. If the value is set to `false`, the account is locked or the user is disabled, and unless specified otherwise in administrative configuration, the user will be unable to authenticate.
     */
    canAuthenticate: boolean;
    /**
     * The time the specified user account was locked. This property might be absent if the account is unlocked or if the account was locked out automatically by failed password attempts.
     */
    lockedAt: string;
    /**
     * A string that specifies the the account locked state.  Options are `LOCKED`, `OK`.
     */
    status: string;
}

export interface UserAddress {
    /**
     * A string that specifies the country name component. When specified, the value must be in [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) "alpha-2" code format. For example, the country codes for the United States and Sweden are `US` and `SE`, respectively. Valid characters consist of two upper-case letters.
     */
    countryCode?: string;
    /**
     * A string that specifies the city or locality component of the address. The string can contain any letters, numbers, combining characters, math and currency symbols, dingbats and drawing characters, and invisible whitespace. It can have a length of no more than 256 characters.
     */
    locality?: string;
    /**
     * A string that specifies the ZIP code or postal code component of the address. The string can contain any letters, numbers, combining characters, math and currency symbols, dingbats and drawing characters, and invisible whitespace. It can have a length of no more than 40 characters.
     */
    postalCode?: string;
    /**
     * A string that specifies the state, province, or region component of the address. The string can contain any letters, numbers, combining characters, math and currency symbols, dingbats and drawing characters, and invisible whitespace. It can have a length of no more than 256 characters.
     */
    region?: string;
    /**
     * A string that specifies the full street address component, which may include house number, street name, P.O. box, and multi-line extended street address information. This attribute may contain newlines. It can have a length of no more than 256 characters.
     */
    streetAddress?: string;
}

export interface UserIdentityProvider {
    /**
     * A string that identifies the external identity provider used to authenticate the user. If not provided, PingOne is the identity provider. This attribute is required if the identity provider is authoritative for just-in-time user provisioning.  This field is immutable and will trigger a replace plan if changed.
     */
    id?: string;
    /**
     * A string that specifies the type of identity provider used to authenticate the user.  Options are `AMAZON`, `APPLE`, `FACEBOOK`, `GITHUB`, `GOOGLE`, `LINKEDIN`, `MICROSOFT`, `OPENID_CONNECT`, `PAYPAL`, `PING_ONE`, `SAML`, `TWITTER`, `YAHOO`.  The default value of `PING_ONE` is set when a value for `id` is not provided in this object.
     */
    type: string;
}

export interface UserName {
    /**
     * A string that specifies the family name of the user, or Last in most Western languages (for example, `Jensen` given the full name `Ms. Barbara J Jensen, III`). This may be explicitly set to null when updating a name to unset it. Valid characters consist of any Unicode letter, mark (for example, accent, umlaut), space, dot, apostrophe, or hyphen. It can have a length of no more than 256 characters.
     */
    family?: string;
    /**
     * A string that specifies the fully formatted name of the user (for example `Ms. Barbara J Jensen, III`). This can be explicitly set to null when updating a name to unset it. Valid characters consist of any Unicode letter, mark (for example, accent, umlaut), space, dot, apostrophe, or hyphen. It can have a length of no more than 256 characters.
     */
    formatted?: string;
    /**
     * A string that specifies the given name of the user, or First in most Western languages (for example, `Barbara` given the full name `Ms. Barbara J Jensen, III`). This may be explicitly set to null when updating a name to unset it. The string can contain any letters, numbers, combining characters, math and currency symbols, dingbats and drawing characters, and invisible whitespace. It can have a length of no more than 256 characters.
     */
    given?: string;
    /**
     * A string that specifies the honorific prefix(es) of the user, or title in most Western languages (for example, `Ms.` given the full name `Ms. Barbara Jane Jensen, III`). This can be explicitly set to null when updating a name to unset it.
     */
    honorificPrefix?: string;
    /**
     * A string that specifies the honorific suffix(es) of the user, or suffix in most Western languages (for example, `III` given the full name `Ms. Barbara Jane Jensen, III`). This can be explicitly set to null when updating a name to unset it.
     */
    honorificSuffix?: string;
    /**
     * A string that specifies the middle name(s) of the user (for exmple, `Jane` given the full name `Ms. Barbara Jane Jensen, III`). This can be explicitly set to null when updating a name to unset it. The string can contain any letters, numbers, combining characters, math and currency symbols, dingbats and drawing characters, and invisible whitespace. It can have a length of no more than 256 characters.
     */
    middle?: string;
}

export interface UserPassword {
    /**
     * A single object that maps the information relevant to the user's password, and its association to external directories.
     */
    external?: outputs.UserPasswordExternal;
    /**
     * A boolean that specifies whether the user is forced to change the password on the next log in.  Defaults to `false`.
     */
    forceChange: boolean;
    initialValue?: string;
}

export interface UserPasswordExternal {
    /**
     * A single object that contains the external gateway properties. When this is value is specified, the user's password is managed in an external directory.
     */
    gateway: outputs.UserPasswordExternalGateway;
}

export interface UserPasswordExternalGateway {
    /**
     * A string map that maps the external LDAP directory attributes to PingOne attributes. PingOne uses these values to read the attributes from the external LDAP directory and map them to the corresponding PingOne attributes.
     */
    correlationAttributes?: {[key: string]: string};
    /**
     * A string that specifies the UUID of the linked gateway that references the remote directory.  Must be a valid PingOne resource ID.
     */
    id?: string;
    /**
     * A string that indicates one of the supported gateway types.  Options are `API_GATEWAY_INTEGRATION`, `LDAP`, `PING_FEDERATE`, `PING_INTELLIGENCE`, `RADIUS`.
     */
    type?: string;
    /**
     * A string that specifies the UUID of a user type in the list of user types for the LDAP gateway.  Must be a valid PingOne resource ID.
     */
    userTypeId?: string;
}

export interface UserPhoto {
    /**
     * The URI that is a uniform resource locator (as defined in [Section 1.1.3 of RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-1.3)) that points to a resource location representing the user's image. This can be removed from a user by setting the photo attribute to null. If provided, the resource must be a file (for example, a GIF, JPEG, or PNG image file) rather than a web page containing an image. It must be a valid URL that starts with the HTTP or HTTPS scheme.
     */
    href: string;
}

export interface UserUserLifecycle {
    /**
     * A string that specifies the status of the account lifecycle.  Options are `ACCOUNT_OK`, `VERIFICATION_REQUIRED`.  This property value is only allowed to be set when importing a user to set the initial account status. If the initial status is set to `VERIFICATION_REQUIRED` and an email address is provided, a verification email is sent.  This field is immutable and will trigger a replace plan if changed.
     */
    status?: string;
    /**
     * A boolean that specifies whether to suppress the verification code when the user is imported and the `status` is set to `VERIFICATION_REQUIRED`. If this property is set to `true`, no verification email is sent to the user. If this property is omitted or set to `false`, a verification email is sent automatically to the user.  This field is immutable and will trigger a replace plan if changed.
     */
    suppressVerificationCode?: boolean;
}

export interface VerifyPolicyEmail {
    /**
     * When enabled, PingOne Verify registers the email address with PingOne MFA as a verified MFA device.
     */
    createMfaDevice: boolean;
    /**
     * SMS/Voice/Email one-time password (OTP) configuration.
     */
    otp?: outputs.VerifyPolicyEmailOtp;
    /**
     * Controls the verification requirements for an Email or Phone verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyEmailOtp {
    /**
     * OTP attempts configuration.
     */
    attempts: outputs.VerifyPolicyEmailOtpAttempts;
    /**
     * OTP delivery configuration.
     */
    deliveries: outputs.VerifyPolicyEmailOtpDeliveries;
    /**
     * The length of time for which the OTP is valid.
     */
    lifetime: outputs.VerifyPolicyEmailOtpLifetime;
    /**
     * OTP notification template configuration.
     */
    notification: outputs.VerifyPolicyEmailOtpNotification;
}

export interface VerifyPolicyEmailOtpAttempts {
    /**
     * Allowed maximum number of OTP failures.
     */
    count: number;
}

export interface VerifyPolicyEmailOtpDeliveries {
    /**
     * Cooldown (waiting period between OTP attempts) configuration.
     */
    cooldown: outputs.VerifyPolicyEmailOtpDeliveriesCooldown;
    /**
     * Allowed maximum number of OTP deliveries.
     */
    count: number;
}

export interface VerifyPolicyEmailOtpDeliveriesCooldown {
    /**
     * Cooldown duration.
     *     - If `cooldown.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `cooldown.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 SECONDS`.
     */
    duration: number;
    /**
     * Time unit of the cooldown duration configuration.  Options are `MINUTES`, `SECONDS`.  Defaults to `SECONDS`.
     */
    timeUnit: string;
}

export interface VerifyPolicyEmailOtpLifetime {
    /**
     * Lifetime of the OTP delivered via email.
     *     - If `lifetime.time_unit` is `MINUTES`, the allowed range is `1 - 30`.
     *     - If `lifetime.time_unit` is `SECONDS`, the allowed range is `60 - 1800`.
     *     - Defaults to `10 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of the OTP (Email) duration lifetime.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface VerifyPolicyEmailOtpNotification {
    /**
     * Name of the template to use to pass a one-time passcode (OTP). The default value of `email_phone_verification` is static. Use the `notification.variant_name` property to define an alternate template.
     */
    templateName: string;
    /**
     * Name of the template variant to use to pass a one-time passcode (OTP).
     */
    variantName?: string;
}

export interface VerifyPolicyFacialComparison {
    /**
     * Facial Comparison threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    threshold: string;
    /**
     * Controls Facial Comparison verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyGovernmentId {
    /**
     * When enabled, Government ID verification fails if the document is expired.
     */
    failExpiredId: boolean;
    /**
     * Determine whether document authentication is automated, manual, or possibly both.  Options are `AUTOMATIC`, `MANUAL`, `STEP_UP`.
     */
    inspectionType: string;
    /**
     * Provider to use for the automatic verification service.  Options are `MITEK`, `VERIFF`.  Defaults to `MITEK`.
     */
    providerAuto: string;
    /**
     * Provider to use for the manual verification service.  Options are `MITEK`.  Defaults to `MITEK`.
     */
    providerManual: string;
    /**
     * Number of retries permitted when submitting images.  The allowed range is `0 - 3`.
     */
    retryAttempts?: number;
    /**
     * Controls Government ID verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyLiveness {
    /**
     * Number of retries permitted when submitting images.  The allowed range is `0 - 3`.
     */
    retryAttempts?: number;
    /**
     * Liveness Check threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    threshold: string;
    /**
     * Controls Liveness Check verification requirements.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyPhone {
    /**
     * When enabled, PingOne Verify registers the mobile phone with PingOne MFA as a verified MFA device.
     */
    createMfaDevice: boolean;
    /**
     * SMS/Voice/Email one-time password (OTP) configuration.
     */
    otp?: outputs.VerifyPolicyPhoneOtp;
    /**
     * Controls the verification requirements for an Email or Phone verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyPhoneOtp {
    /**
     * OTP attempts configuration.
     */
    attempts: outputs.VerifyPolicyPhoneOtpAttempts;
    /**
     * OTP delivery configuration.
     */
    deliveries: outputs.VerifyPolicyPhoneOtpDeliveries;
    /**
     * The length of time for which the OTP is valid.
     */
    lifetime: outputs.VerifyPolicyPhoneOtpLifetime;
    /**
     * OTP notification template configuration.
     */
    notification: outputs.VerifyPolicyPhoneOtpNotification;
}

export interface VerifyPolicyPhoneOtpAttempts {
    /**
     * Allowed maximum number of OTP failures.
     */
    count: number;
}

export interface VerifyPolicyPhoneOtpDeliveries {
    /**
     * Cooldown (waiting period between OTP attempts) configuration.
     */
    cooldown: outputs.VerifyPolicyPhoneOtpDeliveriesCooldown;
    /**
     * Allowed maximum number of OTP deliveries.
     */
    count: number;
}

export interface VerifyPolicyPhoneOtpDeliveriesCooldown {
    /**
     * Cooldown duration.
     *     - If `cooldown.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `cooldown.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 SECONDS`.
     */
    duration: number;
    /**
     * Time unit of the cooldown duration configuration.  Options are `MINUTES`, `SECONDS`.  Defaults to `SECONDS`.
     */
    timeUnit: string;
}

export interface VerifyPolicyPhoneOtpLifetime {
    /**
     * Lifetime of the OTP delivered via phone (SMS).
     *     - If `lifetime.time_unit` is `MINUTES`, the allowed range is `1 - 30`.
     *     - If `lifetime.time_unit` is `SECONDS`, the allowed range is `60 - 1800`.
     *     - Defaults to `5 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of the OTP (SMS) duration lifetime.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface VerifyPolicyPhoneOtpNotification {
    /**
     * Name of the template to use to pass a one-time passcode (OTP). The default value of `email_phone_verification` is static. Use the `notification.variant_name` property to define an alternate template.
     */
    templateName: string;
    /**
     * Name of the template variant to use to pass a one-time passcode (OTP).
     */
    variantName?: string;
}

export interface VerifyPolicyTransaction {
    /**
     * Object for data collection timeout definition.
     */
    dataCollection?: outputs.VerifyPolicyTransactionDataCollection;
    /**
     * When `true`, collects documents specified in the policy without determining their validity; defaults to `false`.
     */
    dataCollectionOnly?: boolean;
    /**
     * Object for transaction timeout.
     */
    timeout?: outputs.VerifyPolicyTransactionTimeout;
}

export interface VerifyPolicyTransactionDataCollection {
    /**
     * Object for data collection timeout.
     */
    timeout: outputs.VerifyPolicyTransactionDataCollectionTimeout;
}

export interface VerifyPolicyTransactionDataCollectionTimeout {
    /**
     * Length of time before the data collection transaction expires.
     *     - If `transaction.data_collection.timeout.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `transaction.data_collection.timeout.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `15 MINUTES`.
     *
     *     > When setting or changing timeouts in the transaction configuration object, `transaction.data_collection.timeout.duration` must be less than or equal to `transaction.timeout.duration`.
     */
    duration: number;
    /**
     * Time unit of data collection timeout.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface VerifyPolicyTransactionTimeout {
    /**
     * Length of time before the transaction expires.
     *     - If `transaction.timeout.time_unit` is `MINUTES`, the allowed range is `0 - 30`.
     *     - If `transaction.timeout.time_unit` is `SECONDS`, the allowed range is `0 - 1800`.
     *     - Defaults to `30 MINUTES`.
     */
    duration: number;
    /**
     * Time unit of transaction timeout.  Options are `MINUTES`, `SECONDS`.  Defaults to `MINUTES`.
     */
    timeUnit: string;
}

export interface VerifyPolicyVoice {
    /**
     * Comparison threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    comparisonThreshold: string;
    /**
     * Controls if the transaction performs voice enrollment (`TRUE`) or voice verification (`FALSE`).
     */
    enrollment: boolean;
    /**
     * Liveness threshold requirements.  Options are `HIGH`, `LOW`, `MEDIUM`.  Defaults to `MEDIUM`.
     */
    livenessThreshold: string;
    /**
     * Object for configuration of voice recording reference data.
     */
    referenceData: outputs.VerifyPolicyVoiceReferenceData;
    /**
     * Object for configuration of text dependent voice verification.
     */
    textDependent: outputs.VerifyPolicyVoiceTextDependent;
    /**
     * Controls the verification requirements for a Voice verification.  Options are `DISABLED`, `OPTIONAL`, `REQUIRED`.  Defaults to `DISABLED`.
     */
    verify: string;
}

export interface VerifyPolicyVoiceReferenceData {
    /**
     * Controls if the service stores the original voice recordings.
     */
    retainOriginalRecordings: boolean;
    /**
     * Controls updates to user's voice reference data (voice recordings) upon user re-enrollment. If `TRUE`, new data adds to existing data. If `FALSE`, new data replaces existing data.
     */
    updateOnReenrollment: boolean;
    /**
     * Controls updates to user's voice reference data (voice recordings) upon user verification. If `TRUE`, new data adds to existing data. If `FALSE`, new voice recordings are not retained as reference data.
     */
    updateOnVerification: boolean;
}

export interface VerifyPolicyVoiceTextDependent {
    /**
     * Number of voice samples to collect. The allowed range is `3 - 5`.
     */
    samples: number;
    /**
     * The identifier (UUID) of a defined `voice_phrase` to associate with the policy.
     */
    voicePhraseId: string;
}

export interface WebhookFilterOptions {
    /**
     * A non-empty list that specifies the list of action types that should be matched for the webhook.
     *
     * Refer to the [PingOne API Reference - Subscription Action Types](https://apidocs.pingidentity.com/pingone/platform/v1/api/#subscription-action-types) documentation for a full list of configurable action types.
     */
    includedActionTypes: string[];
    /**
     * An array that specifies the list of applications (by ID) whose events are monitored by the webhook (maximum of 10 IDs in the array). If a list of applications is not provided, events are monitored for all applications in the environment.  Values must be valid PingOne resource IDs.
     */
    includedApplicationIds?: string[];
    /**
     * An array that specifies the list of populations (by ID) whose events are monitored by the webhook (maximum of 10 IDs in the array). This property matches events for users in the specified populations, as opposed to events generated in which the user in one of the populations is the actor.  Values must be valid PingOne resource IDs.
     */
    includedPopulationIds?: string[];
    /**
     * An array of tags that events must have to be monitored by the webhook. If tags are not specified, all events are monitored.  Options are `adminIdentityEvent` (Identifies the event as the action of an administrator on other administrators).
     */
    includedTags?: string[];
    /**
     * A boolean that specifies whether the IP address of an actor should be present in the source section of the event.  Defaults to `false`.
     */
    ipAddressExposed: boolean;
    /**
     * A boolean that specifies whether the User-Agent HTTP header of an event should be present in the source section of the event.  Defaults to `false`.
     */
    useragentExposed: boolean;
}

export namespace config {
    export interface GlobalOptions {
        /**
         * A single block containing configuration items to override population resource settings in PingOne.
         */
        populations?: outputs.config.GlobalOptionsPopulation[];
    }

    export interface GlobalOptionsPopulation {
        containsUsersForceDelete?: boolean;
    }

    export interface ServiceEndpoints {
        /**
         * Hostname for the PingOne management service API.  Default value can be set with the `PINGONE_API_SERVICE_HOSTNAME` environment variable.
         */
        apiHostname: string;
        /**
         * Hostname for the PingOne authentication service API.  Default value can be set with the `PINGONE_AUTH_SERVICE_HOSTNAME` environment variable.
         */
        authHostname: string;
    }

}
