// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class DestinationSnowflake extends pulumi.CustomResource {
    /**
     * Get an existing DestinationSnowflake resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DestinationSnowflakeState, opts?: pulumi.CustomResourceOptions): DestinationSnowflake {
        return new DestinationSnowflake(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'streamkap:index/destinationSnowflake:DestinationSnowflake';

    /**
     * Returns true if the given object is an instance of DestinationSnowflake.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DestinationSnowflake {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DestinationSnowflake.__pulumiType;
    }

    /**
     * Specifies whether the connector should create Dyanmic Tables & Cleanup Task (applies to `append` only)
     */
    public readonly applyDynamicTableScript!: pulumi.Output<boolean>;
    /**
     * Schedule for cleanup task in minutes (applies to `append` only)
     */
    public readonly cleanupTaskSchedule!: pulumi.Output<number>;
    public /*out*/ readonly connector!: pulumi.Output<string>;
    /**
     * Mapping between the tables that store append-only data and the deduplicated tables, e.g.
     * rawTable1:[dedupeSchema.]dedupeTable1,rawTable2:[dedupeSchema.]dedupeTable2,etc. The dedupeTable in mapping will be used
     * for QA scripts. If dedupeSchema is not specified, the deduplicated table will be created in the same schema as the raw
     * table.
     */
    public readonly dedupeTableMapping!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * Target lag for dynamic tables in minutes (applies to `append` only)
     */
    public readonly dynamicTableTargetLag!: pulumi.Output<number>;
    /**
     * Specifies whether the connector processes DELETE or tombstone events and removes the corresponding row from the database
     * (applies to `upsert` only)
     */
    public readonly hardDelete!: pulumi.Output<boolean>;
    /**
     * `upsert` or `append` modes are available
     */
    public readonly ingestionMode!: pulumi.Output<string>;
    /**
     * Destination name
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * The name of the Snowflake warehouse.
     */
    public readonly sfwarehouse!: pulumi.Output<string>;
    /**
     * The name of the database that contains the table to insert rows into.
     */
    public readonly snowflakeDatabaseName!: pulumi.Output<string>;
    /**
     * The private key to authenticate the user. Include only the key, not the header or footer. If the key is split across
     * multiple lines, remove the line breaks.
     */
    public readonly snowflakePrivateKey!: pulumi.Output<string>;
    /**
     * If the value is not empty, this phrase is used to try to decrypt the private key.
     */
    public readonly snowflakePrivateKeyPassphrase!: pulumi.Output<string>;
    /**
     * The name of an existing role with necessary privileges (for Streamkap) assigned to the Username.
     */
    public readonly snowflakeRoleName!: pulumi.Output<string>;
    /**
     * The name of the schema that contains the table to insert rows into.
     */
    public readonly snowflakeSchemaName!: pulumi.Output<string>;
    /**
     * The URL for accessing your Snowflake account. This URL must include your account identifier. Note that the protocol
     * (https://) and port number are optional.
     */
    public readonly snowflakeUrlName!: pulumi.Output<string>;
    /**
     * User login name for the Snowflake account.
     */
    public readonly snowflakeUserName!: pulumi.Output<string>;
    /**
     * Specifies whether the connector should create Hybrid Tables (applies to `upsert` only)
     */
    public readonly useHybridTables!: pulumi.Output<boolean>;

    /**
     * Create a DestinationSnowflake resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DestinationSnowflakeArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DestinationSnowflakeArgs | DestinationSnowflakeState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DestinationSnowflakeState | undefined;
            resourceInputs["applyDynamicTableScript"] = state ? state.applyDynamicTableScript : undefined;
            resourceInputs["cleanupTaskSchedule"] = state ? state.cleanupTaskSchedule : undefined;
            resourceInputs["connector"] = state ? state.connector : undefined;
            resourceInputs["dedupeTableMapping"] = state ? state.dedupeTableMapping : undefined;
            resourceInputs["dynamicTableTargetLag"] = state ? state.dynamicTableTargetLag : undefined;
            resourceInputs["hardDelete"] = state ? state.hardDelete : undefined;
            resourceInputs["ingestionMode"] = state ? state.ingestionMode : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["sfwarehouse"] = state ? state.sfwarehouse : undefined;
            resourceInputs["snowflakeDatabaseName"] = state ? state.snowflakeDatabaseName : undefined;
            resourceInputs["snowflakePrivateKey"] = state ? state.snowflakePrivateKey : undefined;
            resourceInputs["snowflakePrivateKeyPassphrase"] = state ? state.snowflakePrivateKeyPassphrase : undefined;
            resourceInputs["snowflakeRoleName"] = state ? state.snowflakeRoleName : undefined;
            resourceInputs["snowflakeSchemaName"] = state ? state.snowflakeSchemaName : undefined;
            resourceInputs["snowflakeUrlName"] = state ? state.snowflakeUrlName : undefined;
            resourceInputs["snowflakeUserName"] = state ? state.snowflakeUserName : undefined;
            resourceInputs["useHybridTables"] = state ? state.useHybridTables : undefined;
        } else {
            const args = argsOrState as DestinationSnowflakeArgs | undefined;
            if ((!args || args.snowflakeDatabaseName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakeDatabaseName'");
            }
            if ((!args || args.snowflakePrivateKey === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakePrivateKey'");
            }
            if ((!args || args.snowflakePrivateKeyPassphrase === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakePrivateKeyPassphrase'");
            }
            if ((!args || args.snowflakeSchemaName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakeSchemaName'");
            }
            if ((!args || args.snowflakeUrlName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakeUrlName'");
            }
            if ((!args || args.snowflakeUserName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'snowflakeUserName'");
            }
            resourceInputs["applyDynamicTableScript"] = args ? args.applyDynamicTableScript : undefined;
            resourceInputs["cleanupTaskSchedule"] = args ? args.cleanupTaskSchedule : undefined;
            resourceInputs["dedupeTableMapping"] = args ? args.dedupeTableMapping : undefined;
            resourceInputs["dynamicTableTargetLag"] = args ? args.dynamicTableTargetLag : undefined;
            resourceInputs["hardDelete"] = args ? args.hardDelete : undefined;
            resourceInputs["ingestionMode"] = args ? args.ingestionMode : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["sfwarehouse"] = args ? args.sfwarehouse : undefined;
            resourceInputs["snowflakeDatabaseName"] = args ? args.snowflakeDatabaseName : undefined;
            resourceInputs["snowflakePrivateKey"] = args?.snowflakePrivateKey ? pulumi.secret(args.snowflakePrivateKey) : undefined;
            resourceInputs["snowflakePrivateKeyPassphrase"] = args?.snowflakePrivateKeyPassphrase ? pulumi.secret(args.snowflakePrivateKeyPassphrase) : undefined;
            resourceInputs["snowflakeRoleName"] = args ? args.snowflakeRoleName : undefined;
            resourceInputs["snowflakeSchemaName"] = args ? args.snowflakeSchemaName : undefined;
            resourceInputs["snowflakeUrlName"] = args ? args.snowflakeUrlName : undefined;
            resourceInputs["snowflakeUserName"] = args ? args.snowflakeUserName : undefined;
            resourceInputs["useHybridTables"] = args ? args.useHybridTables : undefined;
            resourceInputs["connector"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["snowflakePrivateKey", "snowflakePrivateKeyPassphrase"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(DestinationSnowflake.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering DestinationSnowflake resources.
 */
export interface DestinationSnowflakeState {
    /**
     * Specifies whether the connector should create Dyanmic Tables & Cleanup Task (applies to `append` only)
     */
    applyDynamicTableScript?: pulumi.Input<boolean>;
    /**
     * Schedule for cleanup task in minutes (applies to `append` only)
     */
    cleanupTaskSchedule?: pulumi.Input<number>;
    connector?: pulumi.Input<string>;
    /**
     * Mapping between the tables that store append-only data and the deduplicated tables, e.g.
     * rawTable1:[dedupeSchema.]dedupeTable1,rawTable2:[dedupeSchema.]dedupeTable2,etc. The dedupeTable in mapping will be used
     * for QA scripts. If dedupeSchema is not specified, the deduplicated table will be created in the same schema as the raw
     * table.
     */
    dedupeTableMapping?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Target lag for dynamic tables in minutes (applies to `append` only)
     */
    dynamicTableTargetLag?: pulumi.Input<number>;
    /**
     * Specifies whether the connector processes DELETE or tombstone events and removes the corresponding row from the database
     * (applies to `upsert` only)
     */
    hardDelete?: pulumi.Input<boolean>;
    /**
     * `upsert` or `append` modes are available
     */
    ingestionMode?: pulumi.Input<string>;
    /**
     * Destination name
     */
    name?: pulumi.Input<string>;
    /**
     * The name of the Snowflake warehouse.
     */
    sfwarehouse?: pulumi.Input<string>;
    /**
     * The name of the database that contains the table to insert rows into.
     */
    snowflakeDatabaseName?: pulumi.Input<string>;
    /**
     * The private key to authenticate the user. Include only the key, not the header or footer. If the key is split across
     * multiple lines, remove the line breaks.
     */
    snowflakePrivateKey?: pulumi.Input<string>;
    /**
     * If the value is not empty, this phrase is used to try to decrypt the private key.
     */
    snowflakePrivateKeyPassphrase?: pulumi.Input<string>;
    /**
     * The name of an existing role with necessary privileges (for Streamkap) assigned to the Username.
     */
    snowflakeRoleName?: pulumi.Input<string>;
    /**
     * The name of the schema that contains the table to insert rows into.
     */
    snowflakeSchemaName?: pulumi.Input<string>;
    /**
     * The URL for accessing your Snowflake account. This URL must include your account identifier. Note that the protocol
     * (https://) and port number are optional.
     */
    snowflakeUrlName?: pulumi.Input<string>;
    /**
     * User login name for the Snowflake account.
     */
    snowflakeUserName?: pulumi.Input<string>;
    /**
     * Specifies whether the connector should create Hybrid Tables (applies to `upsert` only)
     */
    useHybridTables?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a DestinationSnowflake resource.
 */
export interface DestinationSnowflakeArgs {
    /**
     * Specifies whether the connector should create Dyanmic Tables & Cleanup Task (applies to `append` only)
     */
    applyDynamicTableScript?: pulumi.Input<boolean>;
    /**
     * Schedule for cleanup task in minutes (applies to `append` only)
     */
    cleanupTaskSchedule?: pulumi.Input<number>;
    /**
     * Mapping between the tables that store append-only data and the deduplicated tables, e.g.
     * rawTable1:[dedupeSchema.]dedupeTable1,rawTable2:[dedupeSchema.]dedupeTable2,etc. The dedupeTable in mapping will be used
     * for QA scripts. If dedupeSchema is not specified, the deduplicated table will be created in the same schema as the raw
     * table.
     */
    dedupeTableMapping?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Target lag for dynamic tables in minutes (applies to `append` only)
     */
    dynamicTableTargetLag?: pulumi.Input<number>;
    /**
     * Specifies whether the connector processes DELETE or tombstone events and removes the corresponding row from the database
     * (applies to `upsert` only)
     */
    hardDelete?: pulumi.Input<boolean>;
    /**
     * `upsert` or `append` modes are available
     */
    ingestionMode?: pulumi.Input<string>;
    /**
     * Destination name
     */
    name?: pulumi.Input<string>;
    /**
     * The name of the Snowflake warehouse.
     */
    sfwarehouse?: pulumi.Input<string>;
    /**
     * The name of the database that contains the table to insert rows into.
     */
    snowflakeDatabaseName: pulumi.Input<string>;
    /**
     * The private key to authenticate the user. Include only the key, not the header or footer. If the key is split across
     * multiple lines, remove the line breaks.
     */
    snowflakePrivateKey: pulumi.Input<string>;
    /**
     * If the value is not empty, this phrase is used to try to decrypt the private key.
     */
    snowflakePrivateKeyPassphrase: pulumi.Input<string>;
    /**
     * The name of an existing role with necessary privileges (for Streamkap) assigned to the Username.
     */
    snowflakeRoleName?: pulumi.Input<string>;
    /**
     * The name of the schema that contains the table to insert rows into.
     */
    snowflakeSchemaName: pulumi.Input<string>;
    /**
     * The URL for accessing your Snowflake account. This URL must include your account identifier. Note that the protocol
     * (https://) and port number are optional.
     */
    snowflakeUrlName: pulumi.Input<string>;
    /**
     * User login name for the Snowflake account.
     */
    snowflakeUserName: pulumi.Input<string>;
    /**
     * Specifies whether the connector should create Hybrid Tables (applies to `upsert` only)
     */
    useHybridTables?: pulumi.Input<boolean>;
}
