// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessPackageAssignmentPolicyApprovalSettings {
    /**
     * Whether an approval is required
     */
    approvalRequired?: boolean;
    /**
     * Whether an approval is required to grant extension. Same approval settings used to approve initial access will apply
     */
    approvalRequiredForExtension?: boolean;
    /**
     * The process to obtain an approval
     */
    approvalStages?: outputs.AccessPackageAssignmentPolicyApprovalSettingsApprovalStage[];
    /**
     * Whether requestor are required to provide a justification to request an access package. Justification is visible to other approvers and the requestor
     */
    requestorJustificationRequired?: boolean;
}

export interface AccessPackageAssignmentPolicyApprovalSettingsApprovalStage {
    /**
     * If no action taken, forward to alternate approvers?
     */
    alternativeApprovalEnabled?: boolean;
    /**
     * If escalation is enabled and the primary approvers do not respond before the escalation time, the escalationApprovers are the users who will be asked to approve requests. This can be a collection of singleUser, groupMembers, requestorManager, internalSponsors and externalSponsors. When creating or updating a policy, if there are no escalation approvers, or escalation approvers are not required for the stage, the value of this property should be an empty collection
     */
    alternativeApprovers?: outputs.AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApprover[];
    /**
     * Decision must be made in how many days? If a request is not approved within this time period after it is made, it will be automatically rejected
     */
    approvalTimeoutInDays: number;
    /**
     * Whether an approver must provide a justification for their decision. Justification is visible to other approvers and the requestor
     */
    approverJustificationRequired?: boolean;
    /**
     * Forward to alternate approver(s) after how many days?
     */
    enableAlternativeApprovalInDays?: number;
    /**
     * The users who will be asked to approve requests. A collection of singleUser, groupMembers, requestorManager, internalSponsors and externalSponsors. When creating or updating a policy, include at least one userSet in this collection
     */
    primaryApprovers?: outputs.AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApprover[];
}

export interface AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApprover {
    /**
     * For a user in an approval stage, this property indicates whether the user is a backup fallback approver
     */
    backup?: boolean;
    /**
     * The object ID of the subject
     */
    objectId?: string;
    /**
     * Type of users
     */
    subjectType: string;
}

export interface AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApprover {
    /**
     * For a user in an approval stage, this property indicates whether the user is a backup fallback approver
     */
    backup?: boolean;
    /**
     * The object ID of the subject
     */
    objectId?: string;
    /**
     * Type of users
     */
    subjectType: string;
}

export interface AccessPackageAssignmentPolicyAssignmentReviewSettings {
    /**
     * Whether to show Show reviewer decision helpers. If enabled, system recommendations based on users' access information will be shown to the reviewers. The reviewer will be recommended to approve the review if the user has signed-in at least once during the last 30 days. The reviewer will be recommended to deny the review if the user has not signed-in during the last 30 days
     */
    accessRecommendationEnabled?: boolean;
    /**
     * What actions the system takes if reviewers don't respond in time
     */
    accessReviewTimeoutBehavior?: string;
    /**
     * Whether a reviewer need provide a justification for their decision. Justification is visible to other reviewers and the requestor
     */
    approverJustificationRequired?: boolean;
    /**
     * How many days each occurrence of the access review series will run
     */
    durationInDays?: number;
    /**
     * Whether to enable assignment review
     */
    enabled?: boolean;
    /**
     * This will determine how often the access review campaign runs
     */
    reviewFrequency?: string;
    /**
     * Self review or specific reviewers
     */
    reviewType?: string;
    /**
     * If the reviewerType is Reviewers, this collection specifies the users who will be reviewers, either by ID or as members of a group, using a collection of singleUser and groupMembers
     */
    reviewers?: outputs.AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewer[];
    /**
     * This is the date the access review campaign will start on, formatted as an RFC3339 date string in UTC(e.g. 2018-01-01T01:02:03Z), default is now. Once an access review has been created, you cannot update its start date
     */
    startingOn?: string;
}

export interface AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewer {
    /**
     * For a user in an approval stage, this property indicates whether the user is a backup fallback approver
     */
    backup?: boolean;
    /**
     * The object ID of the subject
     */
    objectId?: string;
    /**
     * Type of users
     */
    subjectType: string;
}

export interface AccessPackageAssignmentPolicyQuestion {
    /**
     * Configuration of a choice to the question
     */
    choices?: outputs.AccessPackageAssignmentPolicyQuestionChoice[];
    /**
     * Whether this question is required
     */
    required?: boolean;
    /**
     * The sequence number of this question
     */
    sequence?: number;
    /**
     * The content of this question
     */
    text: outputs.AccessPackageAssignmentPolicyQuestionText;
}

export interface AccessPackageAssignmentPolicyQuestionChoice {
    /**
     * The actual value of this choice
     */
    actualValue: string;
    /**
     * The display text of this choice
     */
    displayValue: outputs.AccessPackageAssignmentPolicyQuestionChoiceDisplayValue;
}

export interface AccessPackageAssignmentPolicyQuestionChoiceDisplayValue {
    /**
     * The default text of this question
     */
    defaultText: string;
    /**
     * The localized text of this question
     */
    localizedTexts?: outputs.AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedText[];
}

export interface AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedText {
    /**
     * The localized content of this question
     */
    content: string;
    /**
     * The language code of this question content
     */
    languageCode: string;
}

export interface AccessPackageAssignmentPolicyQuestionText {
    /**
     * The default text of this question
     */
    defaultText: string;
    /**
     * The localized text of this question
     */
    localizedTexts?: outputs.AccessPackageAssignmentPolicyQuestionTextLocalizedText[];
}

export interface AccessPackageAssignmentPolicyQuestionTextLocalizedText {
    /**
     * The localized content of this question
     */
    content: string;
    /**
     * The language code of this question content
     */
    languageCode: string;
}

export interface AccessPackageAssignmentPolicyRequestorSettings {
    /**
     * The users who are allowed to request on this policy, which can be singleUser, groupMembers, and connectedOrganizationMembers
     */
    requestors?: outputs.AccessPackageAssignmentPolicyRequestorSettingsRequestor[];
    /**
     * Whether to accept requests now, when disabled, no new requests can be made using this policy
     */
    requestsAccepted?: boolean;
    /**
     * Specify the scopes of the requestors
     */
    scopeType?: string;
}

export interface AccessPackageAssignmentPolicyRequestorSettingsRequestor {
    /**
     * For a user in an approval stage, this property indicates whether the user is a backup fallback approver
     */
    backup?: boolean;
    /**
     * The object ID of the subject
     */
    objectId?: string;
    /**
     * Type of users
     */
    subjectType: string;
}

export interface AccessPackageAssignmentPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AccessPackageCatalogRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AccessPackageCatalogTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AccessPackageResourceCatalogAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AccessPackageResourcePackageAssociationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AccessPackageTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AdministrativeUnitMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AdministrativeUnitRoleMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface AdministrativeUnitTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AppRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApplicationApi {
    /**
     * Used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app
     */
    knownClientApplications?: string[];
    /**
     * Allows an application to use claims mapping without specifying a custom signing key
     */
    mappedClaimsEnabled?: boolean;
    /**
     * One or more `oauth2_permission_scope` blocks to describe delegated permissions exposed by the web API represented by this application
     */
    oauth2PermissionScopes?: outputs.ApplicationApiOauth2PermissionScope[];
    /**
     * The access token version expected by this resource
     */
    requestedAccessTokenVersion?: number;
}

export interface ApplicationApiAccessTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationApiOauth2PermissionScope {
    /**
     * Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users
     */
    adminConsentDescription?: string;
    /**
     * Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users
     */
    adminConsentDisplayName?: string;
    /**
     * Determines if the permission scope is enabled
     */
    enabled?: boolean;
    /**
     * The unique identifier of the delegated permission
     */
    id: string;
    /**
     * Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions
     */
    type?: string;
    /**
     * Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf
     */
    userConsentDescription?: string;
    /**
     * Display name for the delegated permission that appears in the end user consent experience
     */
    userConsentDisplayName?: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens
     */
    value?: string;
}

export interface ApplicationAppRole {
    /**
     * Specifies whether this app role definition can be assigned to users and groups by setting to `User`, or to other applications (that are accessing this application in a standalone scenario) by setting to `Application`, or to both
     */
    allowedMemberTypes: string[];
    /**
     * Description of the app role that appears when the role is being assigned and, if the role functions as an application permissions, during the consent experiences
     */
    description: string;
    /**
     * Display name for the app role that appears during app role assignment and in consent experiences
     */
    displayName: string;
    /**
     * Determines if the app role is enabled
     */
    enabled?: boolean;
    /**
     * The unique identifier of the app role
     */
    id: string;
    /**
     * The value that is used for the `roles` claim in ID tokens and OAuth 2.0 access tokens that are authenticating an assigned service or user principal
     */
    value?: string;
}

export interface ApplicationAppRoleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationFallbackPublicClientTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApplicationFeatureTag {
    /**
     * Whether this application represents a custom SAML application for linked service principals
     */
    customSingleSignOn?: boolean;
    /**
     * Whether this application represents an Enterprise Application for linked service principals
     */
    enterprise?: boolean;
    /**
     * Whether this application represents a gallery application for linked service principals
     */
    gallery?: boolean;
    /**
     * Whether this application is invisible to users in My Apps and Office 365 Launcher
     */
    hide?: boolean;
}

export interface ApplicationFederatedIdentityCredentialTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationFromTemplateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationIdentifierUriTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApplicationKnownClientsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationOptionalClaims {
    accessTokens?: outputs.ApplicationOptionalClaimsAccessToken[];
    idTokens?: outputs.ApplicationOptionalClaimsIdToken[];
    saml2Tokens?: outputs.ApplicationOptionalClaimsSaml2Token[];
}

export interface ApplicationOptionalClaimsAccessToken {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience
     */
    essential?: boolean;
    /**
     * The name of the optional claim
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object
     */
    source?: string;
}

export interface ApplicationOptionalClaimsIdToken {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience
     */
    essential?: boolean;
    /**
     * The name of the optional claim
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object
     */
    source?: string;
}

export interface ApplicationOptionalClaimsSaml2Token {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience
     */
    essential?: boolean;
    /**
     * The name of the optional claim
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object
     */
    source?: string;
}

export interface ApplicationOptionalClaimsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationOwnerTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ApplicationPassword {
    /**
     * A display name for the password
     */
    displayName: string;
    /**
     * The end date until which the password is valid, formatted as an RFC3339 date string (e.g. `2018-01-01T01:02:03Z`)
     */
    endDate: string;
    /**
     * A UUID used to uniquely identify this password credential
     */
    keyId: string;
    /**
     * The start date from which the password is valid, formatted as an RFC3339 date string (e.g. `2018-01-01T01:02:03Z`). If this isn't specified, the current date is used
     */
    startDate: string;
    /**
     * The password for this application, which is generated by Azure Active Directory
     */
    value: string;
}

export interface ApplicationPasswordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationPermissionScopeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationPreAuthorizedTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationPublicClient {
    /**
     * The URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent
     */
    redirectUris?: string[];
}

export interface ApplicationRedirectUrisTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationRegistrationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationRequiredResourceAccess {
    resourceAccesses: outputs.ApplicationRequiredResourceAccessResourceAccess[];
    resourceAppId: string;
}

export interface ApplicationRequiredResourceAccessResourceAccess {
    id: string;
    type: string;
}

export interface ApplicationSinglePageApplication {
    /**
     * The URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent
     */
    redirectUris?: string[];
}

export interface ApplicationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ApplicationWeb {
    /**
     * Home page or landing page of the application
     */
    homepageUrl?: string;
    implicitGrant?: outputs.ApplicationWebImplicitGrant;
    /**
     * The URL that will be used by Microsoft's authorization service to sign out a user using front-channel, back-channel or SAML logout protocols
     */
    logoutUrl?: string;
    /**
     * The URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent
     */
    redirectUris?: string[];
}

export interface ApplicationWebImplicitGrant {
    /**
     * Whether this web application can request an access token using OAuth 2.0 implicit flow
     */
    accessTokenIssuanceEnabled?: boolean;
    /**
     * Whether this web application can request an ID token using OAuth 2.0 implicit flow
     */
    idTokenIssuanceEnabled?: boolean;
}

export interface AuthenticationStrengthPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ClaimsMappingPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ConditionalAccessPolicyConditions {
    applications: outputs.ConditionalAccessPolicyConditionsApplications;
    clientAppTypes: string[];
    clientApplications?: outputs.ConditionalAccessPolicyConditionsClientApplications;
    devices?: outputs.ConditionalAccessPolicyConditionsDevices;
    locations?: outputs.ConditionalAccessPolicyConditionsLocations;
    platforms?: outputs.ConditionalAccessPolicyConditionsPlatforms;
    servicePrincipalRiskLevels?: string[];
    signInRiskLevels?: string[];
    userRiskLevels?: string[];
    users: outputs.ConditionalAccessPolicyConditionsUsers;
}

export interface ConditionalAccessPolicyConditionsApplications {
    excludedApplications?: string[];
    includedApplications?: string[];
    includedUserActions?: string[];
}

export interface ConditionalAccessPolicyConditionsClientApplications {
    excludedServicePrincipals?: string[];
    includedServicePrincipals?: string[];
}

export interface ConditionalAccessPolicyConditionsDevices {
    filter?: outputs.ConditionalAccessPolicyConditionsDevicesFilter;
}

export interface ConditionalAccessPolicyConditionsDevicesFilter {
    mode: string;
    rule: string;
}

export interface ConditionalAccessPolicyConditionsLocations {
    excludedLocations?: string[];
    includedLocations: string[];
}

export interface ConditionalAccessPolicyConditionsPlatforms {
    excludedPlatforms?: string[];
    includedPlatforms: string[];
}

export interface ConditionalAccessPolicyConditionsUsers {
    excludedGroups?: string[];
    excludedGuestsOrExternalUsers?: outputs.ConditionalAccessPolicyConditionsUsersExcludedGuestsOrExternalUser[];
    excludedRoles?: string[];
    excludedUsers?: string[];
    includedGroups?: string[];
    includedGuestsOrExternalUsers?: outputs.ConditionalAccessPolicyConditionsUsersIncludedGuestsOrExternalUser[];
    includedRoles?: string[];
    includedUsers?: string[];
}

export interface ConditionalAccessPolicyConditionsUsersExcludedGuestsOrExternalUser {
    externalTenants?: outputs.ConditionalAccessPolicyConditionsUsersExcludedGuestsOrExternalUserExternalTenant[];
    guestOrExternalUserTypes: string[];
}

export interface ConditionalAccessPolicyConditionsUsersExcludedGuestsOrExternalUserExternalTenant {
    members?: string[];
    membershipKind: string;
}

export interface ConditionalAccessPolicyConditionsUsersIncludedGuestsOrExternalUser {
    externalTenants?: outputs.ConditionalAccessPolicyConditionsUsersIncludedGuestsOrExternalUserExternalTenant[];
    guestOrExternalUserTypes: string[];
}

export interface ConditionalAccessPolicyConditionsUsersIncludedGuestsOrExternalUserExternalTenant {
    members?: string[];
    membershipKind: string;
}

export interface ConditionalAccessPolicyGrantControls {
    authenticationStrengthPolicyId?: string;
    builtInControls?: string[];
    customAuthenticationFactors?: string[];
    operator: string;
    termsOfUses?: string[];
}

export interface ConditionalAccessPolicySessionControls {
    applicationEnforcedRestrictionsEnabled?: boolean;
    cloudAppSecurityPolicy?: string;
    disableResilienceDefaults?: boolean;
    persistentBrowserMode?: string;
    signInFrequency?: number;
    signInFrequencyAuthenticationType: string;
    signInFrequencyInterval: string;
    signInFrequencyPeriod?: string;
}

export interface ConditionalAccessPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CustomDirectoryRolePermission {
    /**
     * Set of tasks that can be performed on a resource
     */
    allowedResourceActions: string[];
}

export interface CustomDirectoryRoleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DirectoryRoleAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DirectoryRoleEligibilityScheduleRequestTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DirectoryRoleMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface DirectoryRoleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface GetAccessPackageCatalogRoleTimeouts {
    read?: string;
}

export interface GetAccessPackageCatalogTimeouts {
    read?: string;
}

export interface GetAccessPackageTimeouts {
    read?: string;
}

export interface GetAdministrativeUnitTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GetApplicationApi {
    knownClientApplications: string[];
    mappedClaimsEnabled: boolean;
    oauth2PermissionScopes: outputs.GetApplicationApiOauth2PermissionScope[];
    requestedAccessTokenVersion: number;
}

export interface GetApplicationApiOauth2PermissionScope {
    adminConsentDescription: string;
    adminConsentDisplayName: string;
    enabled: boolean;
    id: string;
    type: string;
    userConsentDescription: string;
    userConsentDisplayName: string;
    value: string;
}

export interface GetApplicationAppRole {
    allowedMemberTypes: string[];
    description: string;
    displayName: string;
    enabled: boolean;
    id: string;
    value: string;
}

export interface GetApplicationFeatureTag {
    customSingleSignOn: boolean;
    enterprise: boolean;
    gallery: boolean;
    hide: boolean;
}

export interface GetApplicationOptionalClaim {
    accessTokens: outputs.GetApplicationOptionalClaimAccessToken[];
    idTokens: outputs.GetApplicationOptionalClaimIdToken[];
    saml2Tokens: outputs.GetApplicationOptionalClaimSaml2Token[];
}

export interface GetApplicationOptionalClaimAccessToken {
    additionalProperties: string[];
    essential: boolean;
    name: string;
    source: string;
}

export interface GetApplicationOptionalClaimIdToken {
    additionalProperties: string[];
    essential: boolean;
    name: string;
    source: string;
}

export interface GetApplicationOptionalClaimSaml2Token {
    additionalProperties: string[];
    essential: boolean;
    name: string;
    source: string;
}

export interface GetApplicationPublicClient {
    redirectUris: string[];
}

export interface GetApplicationPublishedAppIdsTimeouts {
    read?: string;
}

export interface GetApplicationRequiredResourceAccess {
    resourceAccesses: outputs.GetApplicationRequiredResourceAccessResourceAccess[];
    resourceAppId: string;
}

export interface GetApplicationRequiredResourceAccessResourceAccess {
    id: string;
    type: string;
}

export interface GetApplicationSinglePageApplication {
    redirectUris: string[];
}

export interface GetApplicationTemplateTimeouts {
    read?: string;
}

export interface GetApplicationTimeouts {
    read?: string;
}

export interface GetApplicationWeb {
    homepageUrl: string;
    implicitGrants: outputs.GetApplicationWebImplicitGrant[];
    logoutUrl: string;
    redirectUris: string[];
}

export interface GetApplicationWebImplicitGrant {
    accessTokenIssuanceEnabled: boolean;
    idTokenIssuanceEnabled: boolean;
}

export interface GetClientConfigTimeouts {
    read?: string;
}

export interface GetDirectoryObjectTimeouts {
    read?: string;
}

export interface GetDirectoryRoleTemplatesRoleTemplate {
    description: string;
    displayName: string;
    objectId: string;
}

export interface GetDirectoryRoleTemplatesTimeouts {
    read?: string;
}

export interface GetDirectoryRolesRole {
    description: string;
    displayName: string;
    objectId: string;
    templateId: string;
}

export interface GetDirectoryRolesTimeouts {
    read?: string;
}

export interface GetDomainsDomain {
    adminManaged: boolean;
    authenticationType: string;
    default: boolean;
    domainName: string;
    initial: boolean;
    root: boolean;
    supportedServices: string[];
    verified: boolean;
}

export interface GetDomainsTimeouts {
    read?: string;
}

export interface GetGroupDynamicMembership {
    enabled: boolean;
    rule: string;
}

export interface GetGroupRoleManagementPolicyTimeouts {
    read?: string;
}

export interface GetGroupTimeouts {
    read?: string;
}

export interface GetGroupsTimeouts {
    read?: string;
}

export interface GetNamedLocationCountry {
    countriesAndRegions: string[];
    includeUnknownCountriesAndRegions: boolean;
}

export interface GetNamedLocationIp {
    ipRanges: string[];
    trusted: boolean;
}

export interface GetNamedLocationTimeouts {
    read?: string;
}

export interface GetServicePrincipalAppRole {
    allowedMemberTypes: string[];
    description: string;
    displayName: string;
    enabled: boolean;
    id: string;
    value: string;
}

export interface GetServicePrincipalFeature {
    customSingleSignOnApp: boolean;
    enterpriseApplication: boolean;
    galleryApplication: boolean;
    visibleToUsers: boolean;
}

export interface GetServicePrincipalFeatureTag {
    customSingleSignOn: boolean;
    enterprise: boolean;
    gallery: boolean;
    hide: boolean;
}

export interface GetServicePrincipalOauth2PermissionScope {
    adminConsentDescription: string;
    adminConsentDisplayName: string;
    enabled: boolean;
    id: string;
    type: string;
    userConsentDescription: string;
    userConsentDisplayName: string;
    value: string;
}

export interface GetServicePrincipalSamlSingleSignOn {
    relayState: string;
}

export interface GetServicePrincipalTimeouts {
    read?: string;
}

export interface GetServicePrincipalsServicePrincipal {
    accountEnabled: boolean;
    appRoleAssignmentRequired: boolean;
    applicationId: string;
    applicationTenantId: string;
    clientId: string;
    displayName: string;
    objectId: string;
    preferredSingleSignOnMode: string;
    samlMetadataUrl: string;
    servicePrincipalNames: string[];
    signInAudience: string;
    tags: string[];
    type: string;
}

export interface GetServicePrincipalsTimeouts {
    read?: string;
}

export interface GetUserTimeouts {
    read?: string;
}

export interface GetUsersTimeouts {
    read?: string;
}

export interface GetUsersUser {
    accountEnabled: boolean;
    displayName: string;
    employeeId: string;
    mail: string;
    mailNickname: string;
    objectId: string;
    onpremisesImmutableId: string;
    onpremisesSamAccountName: string;
    onpremisesUserPrincipalName: string;
    usageLocation: string;
    userPrincipalName: string;
}

export interface GroupDynamicMembership {
    enabled: boolean;
    /**
     * Rule to determine members for a dynamic group. Required when `group_types` contains 'DynamicMembership'
     */
    rule: string;
}

export interface GroupMemberTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface GroupRoleManagementPolicyActivationRules {
    /**
     * The approval stages for the activation
     */
    approvalStage?: outputs.GroupRoleManagementPolicyActivationRulesApprovalStage;
    /**
     * The time after which the an activation can be valid for
     */
    maximumDuration: string;
    /**
     * Whether an approval is required for activation
     */
    requireApproval: boolean;
    /**
     * Whether a justification is required during activation
     */
    requireJustification: boolean;
    /**
     * Whether multi-factor authentication is required during activation
     */
    requireMultifactorAuthentication: boolean;
    /**
     * Whether ticket information is required during activation
     */
    requireTicketInfo: boolean;
    /**
     * Whether a conditional access context is required during activation
     */
    requiredConditionalAccessAuthenticationContext: string;
}

export interface GroupRoleManagementPolicyActivationRulesApprovalStage {
    /**
     * The IDs of the users or groups who can approve the activation
     */
    primaryApprovers: outputs.GroupRoleManagementPolicyActivationRulesApprovalStagePrimaryApprover[];
}

export interface GroupRoleManagementPolicyActivationRulesApprovalStagePrimaryApprover {
    /**
     * The ID of the object to act as an approver
     */
    objectId: string;
    /**
     * The type of object acting as an approver
     */
    type?: string;
}

export interface GroupRoleManagementPolicyActiveAssignmentRules {
    /**
     * Must the assignment have an expiry date
     */
    expirationRequired: boolean;
    /**
     * The duration after which assignments expire
     */
    expireAfter: string;
    /**
     * Whether a justification is required to make an assignment
     */
    requireJustification: boolean;
    /**
     * Whether multi-factor authentication is required to make an assignment
     */
    requireMultifactorAuthentication: boolean;
    /**
     * Whether ticket information is required to make an assignment
     */
    requireTicketInfo: boolean;
}

export interface GroupRoleManagementPolicyEligibleAssignmentRules {
    /**
     * Must the assignment have an expiry date
     */
    expirationRequired: boolean;
    /**
     * The duration after which assignments expire
     */
    expireAfter: string;
}

export interface GroupRoleManagementPolicyNotificationRules {
    /**
     * Notifications about active assignments
     */
    activeAssignments?: outputs.GroupRoleManagementPolicyNotificationRulesActiveAssignments;
    /**
     * Notifications about activations of eligible assignments
     */
    eligibleActivations?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleActivations;
    /**
     * Notifications about eligible assignments
     */
    eligibleAssignments?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleAssignments;
}

export interface GroupRoleManagementPolicyNotificationRulesActiveAssignments {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesActiveAssignmentsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesActiveAssignmentsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesActiveAssignmentsAssigneeNotifications;
}

export interface GroupRoleManagementPolicyNotificationRulesActiveAssignmentsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesActiveAssignmentsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesActiveAssignmentsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleActivations {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleActivationsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleActivationsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleActivationsAssigneeNotifications;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleActivationsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleActivationsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleActivationsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleAssignments {
    /**
     * Admin notification settings
     */
    adminNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsAdminNotifications;
    /**
     * Approver notification settings
     */
    approverNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsApproverNotifications;
    /**
     * Assignee notification settings
     */
    assigneeNotifications?: outputs.GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsAssigneeNotifications;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsAdminNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsApproverNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyNotificationRulesEligibleAssignmentsAssigneeNotifications {
    /**
     * The additional recipients to notify
     */
    additionalRecipients: string[];
    /**
     * Whether the default recipients are notified
     */
    defaultRecipients: boolean;
    /**
     * What level of notifications are sent
     */
    notificationLevel: string;
}

export interface GroupRoleManagementPolicyTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface InvitationMessage {
    /**
     * Email addresses of additional recipients the invitation message should be sent to
     */
    additionalRecipients?: string[];
    /**
     * Customized message body you want to send if you don't want to send the default message
     */
    body?: string;
    /**
     * The language you want to send the default message in
     */
    language?: string;
}

export interface InvitationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface NamedLocationCountry {
    countriesAndRegions: string[];
    includeUnknownCountriesAndRegions?: boolean;
}

export interface NamedLocationIp {
    ipRanges: string[];
    trusted?: boolean;
}

export interface NamedLocationTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivilegedAccessGroupAssignmentScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface PrivilegedAccessGroupEligibilityScheduleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicePrincipalAppRole {
    allowedMemberTypes: string[];
    description: string;
    displayName: string;
    enabled: boolean;
    id: string;
    value: string;
}

export interface ServicePrincipalCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ServicePrincipalClaimsMappingPolicyAssignmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ServicePrincipalDelegatedPermissionGrantTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicePrincipalFeature {
    /**
     * Whether this service principal represents a custom SAML application
     */
    customSingleSignOnApp?: boolean;
    /**
     * Whether this service principal represents an Enterprise Application
     */
    enterpriseApplication?: boolean;
    /**
     * Whether this service principal represents a gallery application
     */
    galleryApplication?: boolean;
    /**
     * Whether this app is visible to users in My Apps and Office 365 Launcher
     */
    visibleToUsers?: boolean;
}

export interface ServicePrincipalFeatureTag {
    /**
     * Whether this service principal represents a custom SAML application
     */
    customSingleSignOn?: boolean;
    /**
     * Whether this service principal represents an Enterprise Application
     */
    enterprise?: boolean;
    /**
     * Whether this service principal represents a gallery application
     */
    gallery?: boolean;
    /**
     * Whether this app is invisible to users in My Apps and Office 365 Launcher
     */
    hide?: boolean;
}

export interface ServicePrincipalOauth2PermissionScope {
    adminConsentDescription: string;
    adminConsentDisplayName: string;
    enabled: boolean;
    id: string;
    type: string;
    userConsentDescription: string;
    userConsentDisplayName: string;
    value: string;
}

export interface ServicePrincipalPasswordTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ServicePrincipalSamlSingleSignOn {
    /**
     * The relative URI the service provider would redirect to after completion of the single sign-on flow
     */
    relayState?: string;
}

export interface ServicePrincipalTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ServicePrincipalTokenSigningCertificateTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SynchronizationJobProvisionOnDemandParameter {
    /**
     * The identifier of the synchronization rule to be applied. This rule ID is defined in the schema for a given synchronization job or template.
     */
    ruleId: string;
    /**
     * The identifiers of one or more objects to which a synchronizationJob is to be applied.
     */
    subjects: outputs.SynchronizationJobProvisionOnDemandParameterSubject[];
}

export interface SynchronizationJobProvisionOnDemandParameterSubject {
    /**
     * The identifier of an object to which a synchronization job is to be applied. Can be one of the following: (1) An onPremisesDistinguishedName for synchronization from Active Directory to Azure AD. (2) The user ID for synchronization from Azure AD to a third-party. (3) The Worker ID of the Workday worker for synchronization from Workday to either Active Directory or Azure AD.
     */
    objectId: string;
    /**
     * The type of the object to which a synchronization job is to be applied. Can be one of the following: `user` for synchronizing between Active Directory and Azure AD, `User` for synchronizing a user between Azure AD and a third-party application, `Worker` for synchronization a user between Workday and either Active Directory or Azure AD, `Group` for synchronizing a group between Azure AD and a third-party application.
     */
    objectTypeName: string;
}

export interface SynchronizationJobProvisionOnDemandTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SynchronizationJobSchedule {
    expiration: string;
    interval: string;
    state: string;
}

export interface SynchronizationJobTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SynchronizationSecretCredential {
    /**
     * Name for this key-value pair.
     */
    key: string;
    /**
     * Value for this key-value pair.
     */
    value: string;
}

export interface SynchronizationSecretTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface UserFlowAttributeTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface UserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

