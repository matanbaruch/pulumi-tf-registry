// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BinaryManagerReposIndexedRepo {
    /**
     * Name of the repository
     */
    name: string;
    packageType: string;
    /**
     * Repository type. Valid value: local, remote, federated
     */
    type: string;
}

export interface BinaryManagerReposNonIndexedRepo {
    name: string;
    packageType: string;
    type: string;
}

export interface CustomIssueCfe {
    /**
     * CVE ID
     */
    cve?: string;
    /**
     * CVSS v2 score
     */
    cvssV2?: string;
    /**
     * CVSS v3 score
     */
    cvssV3?: string;
}

export interface CustomIssueComponent {
    /**
     * List of fixed versions
     */
    fixedVersions?: string[];
    /**
     * ID of the component
     */
    id: string;
    /**
     * List of the vulnerable ranges
     */
    vulnerableRanges?: outputs.CustomIssueComponentVulnerableRange[];
    /**
     * List of vulnerable versions
     */
    vulnerableVersions?: string[];
}

export interface CustomIssueComponentVulnerableRange {
    /**
     * List of fixed versions
     */
    fixedVersions?: string[];
    /**
     * List of vulnerable versions
     */
    vulnerableVersions?: string[];
}

export interface CustomIssueSource {
    /**
     * ID of the source, e.g. CVE
     */
    id: string;
    /**
     * Name of the source
     */
    name?: string;
    /**
     * URL of the source
     */
    url?: string;
}

export interface GetArtifactsScanResult {
    created: string;
    deployedBy: string;
    exposuresIssues: outputs.GetArtifactsScanResultExposuresIssues;
    maliciousPackages: string[];
    name: string;
    packageId: string;
    repoFullPath: string;
    repoPath: string;
    secIssues: outputs.GetArtifactsScanResultSecIssues;
    size: string;
    version: string;
    violations: number;
}

export interface GetArtifactsScanResultExposuresIssues {
    categories: outputs.GetArtifactsScanResultExposuresIssuesCategories;
    lastScanned: string;
}

export interface GetArtifactsScanResultExposuresIssuesCategories {
    applications: outputs.GetArtifactsScanResultExposuresIssuesCategoriesApplications;
    iac: outputs.GetArtifactsScanResultExposuresIssuesCategoriesIac;
    secrets: outputs.GetArtifactsScanResultExposuresIssuesCategoriesSecrets;
    services: outputs.GetArtifactsScanResultExposuresIssuesCategoriesServices;
}

export interface GetArtifactsScanResultExposuresIssuesCategoriesApplications {
    critical: number;
    high: number;
    information: number;
    low: number;
    medium: number;
    total: number;
    unknown: number;
}

export interface GetArtifactsScanResultExposuresIssuesCategoriesIac {
    critical: number;
    high: number;
    information: number;
    low: number;
    medium: number;
    total: number;
    unknown: number;
}

export interface GetArtifactsScanResultExposuresIssuesCategoriesSecrets {
    critical: number;
    high: number;
    information: number;
    low: number;
    medium: number;
    total: number;
    unknown: number;
}

export interface GetArtifactsScanResultExposuresIssuesCategoriesServices {
    critical: number;
    high: number;
    information: number;
    low: number;
    medium: number;
    total: number;
    unknown: number;
}

export interface GetArtifactsScanResultSecIssues {
    critical: number;
    high: number;
    information: number;
    low: number;
    medium: number;
    total: number;
    unknown: number;
}

export interface IgnoreRuleArtifact {
    /**
     * Name of the artifact. Wildcards are not supported.
     */
    name: string;
    /**
     * Path of the artifact. Must end with a '/'
     */
    path?: string;
    /**
     * Version of the artifact
     */
    version?: string;
}

export interface IgnoreRuleBuild {
    /**
     * Name of the build
     */
    name: string;
    /**
     * Version of the build
     */
    version?: string;
}

export interface IgnoreRuleComponent {
    /**
     * Name of the component
     */
    name: string;
    /**
     * Version of the component
     */
    version?: string;
}

export interface IgnoreRuleReleaseBundle {
    /**
     * Name of the release bundle
     */
    name: string;
    /**
     * Version of the release bundle
     */
    version?: string;
}

export interface LicensePolicyRule {
    /**
     * Specifies the actions to take once a security policy violation has been triggered.
     */
    actions: outputs.LicensePolicyRuleActions;
    /**
     * The set of security conditions to examine when an scanned artifact is scanned.
     */
    criteria: outputs.LicensePolicyRuleCriteria;
    /**
     * Name of the rule
     */
    name: string;
    /**
     * Integer describing the rule priority. Must be at least 1
     */
    priority: number;
}

export interface LicensePolicyRuleActions {
    /**
     * Block download of artifacts that meet the Artifact Filter and Severity Filter specifications for this watch
     */
    blockDownload: outputs.LicensePolicyRuleActionsBlockDownload;
    /**
     * Blocks Release Bundle distribution to Edge nodes if a violation is found. Default value is `false`.
     */
    blockReleaseBundleDistribution?: boolean;
    /**
     * Blocks Release Bundle promotion if a violation is found. Default value is `false`.
     */
    blockReleaseBundlePromotion?: boolean;
    /**
     * Allow grace period for certain number of days. All violations will be ignored during this time. To be used only if `fail_build` is enabled.
     */
    buildFailureGracePeriodInDays?: number;
    /**
     * Create Jira Ticket for this Policy Violation. Requires configured Jira integration. Default value is `false`.
     */
    createTicketEnabled?: boolean;
    /**
     * The severity of violation to be triggered if the `criteria` are met.
     */
    customSeverity?: string;
    /**
     * Whether or not the related CI build should be marked as failed if a violation is triggered. This option is only available when the policy is applied to an `xray.Watch` resource with a `type` of `builds`. Default value is `false`.
     */
    failBuild?: boolean;
    /**
     * A list of email addressed that will get emailed when a violation is triggered.
     */
    mails?: string[];
    /**
     * Sends an email message to component deployer with details about the generated Violations. Default value is `false`.
     */
    notifyDeployer?: boolean;
    /**
     * Sends an email message to all configured recipients inside a specific watch with details about the generated Violations. Default value is `false`.
     */
    notifyWatchRecipients?: boolean;
    /**
     * A list of Xray-configured webhook URLs to be invoked if a violation is triggered.
     */
    webhooks?: string[];
}

export interface LicensePolicyRuleActionsBlockDownload {
    /**
     * Whether or not to block download of artifacts that meet the artifact and severity `filters` for the associated `xray.Watch` resource. Default value is `false`.
     */
    active?: boolean;
    /**
     * Whether or not to block download of artifacts that meet the artifact `filters` for the associated `xray.Watch` resource but have not been scanned yet. Can not be set to `true` if attribute `active` is `false`. Default value is `false`.
     */
    unscanned?: boolean;
}

export interface LicensePolicyRuleCriteria {
    /**
     * A violation will be generated for artifacts with unknown licenses (`true` or `false`).
     */
    allowUnknown?: boolean;
    /**
     * A list of OSS license names that may be attached to a component. Supports custom licenses added by the user, but there is no verification if the license exists on the Xray side. If the added license doesn't exist, the policy won't trigger the violation.
     */
    allowedLicenses?: string[];
    /**
     * A list of OSS license names that may not be attached to a component. Supports custom licenses added by the user, but there is no verification if the license exists on the Xray side. If the added license doesn't exist, the policy won't trigger the violation.
     */
    bannedLicenses?: string[];
    /**
     * Do not generate a violation if at least one license is valid in cases whereby multiple licenses were detected on the component
     */
    multiLicensePermissive?: boolean;
}

export interface LicensesReportFilter {
    /**
     * Artifact name.
     */
    artifact?: string;
    /**
     * Artifact's component.
     */
    component?: string;
    /**
     * Filter licenses by names. Only one of 'license_names' or 'license_patterns' can be set.
     */
    licenseNames?: string[];
    /**
     * Filter licenses by patterns. Only one of 'license_names' or 'license_patterns' can be set.
     */
    licensePatterns?: string[];
    scanDate?: outputs.LicensesReportFilterScanDate;
    /**
     * Unknown displays the components that Xray could not discover any licenses for.
     */
    unknown?: boolean;
    /**
     * Unrecognized displays the components that Xray found licenses for, but these licenses are not Xray recognized licenses.
     */
    unrecognized?: boolean;
}

export interface LicensesReportFilterScanDate {
    /**
     * Scan end date.
     */
    end?: string;
    /**
     * Scan start date.
     */
    start?: string;
}

export interface LicensesReportResources {
    /**
     * The builds to include into the report. Only one type of resource can be set per report.
     */
    builds?: outputs.LicensesReportResourcesBuilds;
    /**
     * The projects to include into the report. Only one type of resource can be set per report.
     */
    projects?: outputs.LicensesReportResourcesProjects;
    /**
     * The release bundles to include into the report. Only one type of resource can be set per report.
     */
    releaseBundles?: outputs.LicensesReportResourcesReleaseBundles;
    /**
     * The list of repositories for the report. Only one type of resource can be set per report.
     */
    repositories?: outputs.LicensesReportResourcesRepository[];
}

export interface LicensesReportResourcesBuilds {
    /**
     * The list of exclude patterns. Only one of 'names' or '*_patterns' can be set.
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns. Only one of 'names' or '*_patterns' can be set.
     */
    includePatterns?: string[];
    /**
     * The list of build names. Only one of 'names' or '*_patterns' can be set.
     */
    names?: string[];
    /**
     * The number of latest build versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface LicensesReportResourcesProjects {
    /**
     * The list of include patterns.
     */
    includeKeyPatterns?: string[];
    /**
     * The list of project names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface LicensesReportResourcesReleaseBundles {
    /**
     * The list of exclude patterns
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns
     */
    includePatterns?: string[];
    /**
     * The list of release bundles names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface LicensesReportResourcesRepository {
    /**
     * Exclude path patterns.
     */
    excludePathPatterns?: string[];
    /**
     * Include path patterns.
     */
    includePathPatterns?: string[];
    /**
     * Repository name.
     */
    name: string;
}

export interface OperationalRiskPolicyRule {
    /**
     * Specifies the actions to take once a security policy violation has been triggered.
     */
    actions: outputs.OperationalRiskPolicyRuleActions;
    /**
     * The set of security conditions to examine when an scanned artifact is scanned.
     */
    criteria: outputs.OperationalRiskPolicyRuleCriteria;
    /**
     * Name of the rule
     */
    name: string;
    /**
     * Integer describing the rule priority. Must be at least 1
     */
    priority: number;
}

export interface OperationalRiskPolicyRuleActions {
    /**
     * Block download of artifacts that meet the Artifact Filter and Severity Filter specifications for this watch
     */
    blockDownload: outputs.OperationalRiskPolicyRuleActionsBlockDownload;
    /**
     * Blocks Release Bundle distribution to Edge nodes if a violation is found. Default value is `false`.
     */
    blockReleaseBundleDistribution?: boolean;
    /**
     * Blocks Release Bundle promotion if a violation is found. Default value is `false`.
     */
    blockReleaseBundlePromotion?: boolean;
    /**
     * Allow grace period for certain number of days. All violations will be ignored during this time. To be used only if `fail_build` is enabled.
     */
    buildFailureGracePeriodInDays?: number;
    /**
     * Create Jira Ticket for this Policy Violation. Requires configured Jira integration. Default value is `false`.
     */
    createTicketEnabled?: boolean;
    /**
     * Whether or not the related CI build should be marked as failed if a violation is triggered. This option is only available when the policy is applied to an `xray.Watch` resource with a `type` of `builds`. Default value is `false`.
     */
    failBuild?: boolean;
    /**
     * A list of email addressed that will get emailed when a violation is triggered.
     */
    mails?: string[];
    /**
     * Sends an email message to component deployer with details about the generated Violations. Default value is `false`.
     */
    notifyDeployer?: boolean;
    /**
     * Sends an email message to all configured recipients inside a specific watch with details about the generated Violations. Default value is `false`.
     */
    notifyWatchRecipients?: boolean;
    /**
     * A list of Xray-configured webhook URLs to be invoked if a violation is triggered.
     */
    webhooks?: string[];
}

export interface OperationalRiskPolicyRuleActionsBlockDownload {
    /**
     * Whether or not to block download of artifacts that meet the artifact and severity `filters` for the associated `xray.Watch` resource. Default value is `false`.
     */
    active?: boolean;
    /**
     * Whether or not to block download of artifacts that meet the artifact `filters` for the associated `xray.Watch` resource but have not been scanned yet. Can not be set to `true` if attribute `active` is `false`. Default value is `false`.
     */
    unscanned?: boolean;
}

export interface OperationalRiskPolicyRuleCriteria {
    /**
     * Custom Condition
     */
    opRiskCustom?: outputs.OperationalRiskPolicyRuleCriteriaOpRiskCustom;
    /**
     * The minimum operational risk that will be impacted by the policy: High, Medium, Low
     */
    opRiskMinRisk?: string;
}

export interface OperationalRiskPolicyRuleCriteriaOpRiskCustom {
    /**
     * Number of commits less than per year: 10, 25, 50, or 100
     */
    commitsLessThan?: number;
    /**
     * Number of committers less than per year: 1, 2, 3, 4, or 5
     */
    committersLessThan?: number;
    /**
     * Is End-of-Life?
     */
    isEol?: boolean;
    /**
     * Number of releases since greater than: 1, 2, 3, 4, or 5
     */
    newerVersionsGreaterThan?: number;
    /**
     * Release cadence less than per year: 1, 2, 3, 4, or 5
     */
    releaseCadencePerYearLessThan?: number;
    /**
     * Release age greater than (in months): 6, 12, 18, 24, 30, or 36
     */
    releaseDateGreaterThanMonths?: number;
    /**
     * Risk severity: low, medium, high
     */
    risk?: string;
    /**
     * Use 'AND' between conditions (true) or 'OR' condition (false)
     */
    useAndCondition: boolean;
}

export interface OperationalRisksReportFilter {
    /**
     * Artifact name.
     */
    artifact?: string;
    /**
     * Artifact's component.
     */
    component?: string;
    /**
     * Operational risk level. Allowed values: 'None', 'Low', 'Medium', 'High'.
     */
    risks?: string[];
    scanDate?: outputs.OperationalRisksReportFilterScanDate;
}

export interface OperationalRisksReportFilterScanDate {
    /**
     * Scan end date.
     */
    end?: string;
    /**
     * Scan start date.
     */
    start?: string;
}

export interface OperationalRisksReportResources {
    /**
     * The builds to include into the report. Only one type of resource can be set per report.
     */
    builds?: outputs.OperationalRisksReportResourcesBuilds;
    /**
     * The projects to include into the report. Only one type of resource can be set per report.
     */
    projects?: outputs.OperationalRisksReportResourcesProjects;
    /**
     * The release bundles to include into the report. Only one type of resource can be set per report.
     */
    releaseBundles?: outputs.OperationalRisksReportResourcesReleaseBundles;
    /**
     * The list of repositories for the report. Only one type of resource can be set per report.
     */
    repositories?: outputs.OperationalRisksReportResourcesRepository[];
}

export interface OperationalRisksReportResourcesBuilds {
    /**
     * The list of exclude patterns. Only one of 'names' or '*_patterns' can be set.
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns. Only one of 'names' or '*_patterns' can be set.
     */
    includePatterns?: string[];
    /**
     * The list of build names. Only one of 'names' or '*_patterns' can be set.
     */
    names?: string[];
    /**
     * The number of latest build versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface OperationalRisksReportResourcesProjects {
    /**
     * The list of include patterns.
     */
    includeKeyPatterns?: string[];
    /**
     * The list of project names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface OperationalRisksReportResourcesReleaseBundles {
    /**
     * The list of exclude patterns
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns
     */
    includePatterns?: string[];
    /**
     * The list of release bundles names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface OperationalRisksReportResourcesRepository {
    /**
     * Exclude path patterns.
     */
    excludePathPatterns?: string[];
    /**
     * Include path patterns.
     */
    includePathPatterns?: string[];
    /**
     * Repository name.
     */
    name: string;
}

export interface RepositoryConfigConfig {
    exposures?: outputs.RepositoryConfigConfigExposure[];
    /**
     * The artifact will be retained for the number of days you set here, after the artifact is scanned. This will apply to all artifacts in the repository. Can be omitted when `paths_config` is set.
     */
    retentionInDays?: number;
    /**
     * Enables or disables vulnerability contextual analysis. Only for SaaS instances, will be available after Xray 3.59. Must be set for Docker, OCI, and Maven package types.
     */
    vulnContextualAnalysis?: boolean;
}

export interface RepositoryConfigConfigExposure {
    /**
     * Exposures' scanners categories configurations.
     */
    scannersCategories?: outputs.RepositoryConfigConfigExposureScannersCategory[];
}

export interface RepositoryConfigConfigExposureScannersCategory {
    /**
     * Detect whether common OSS libraries and services are used securely by the application.
     */
    applications?: boolean;
    iac?: boolean;
    /**
     * Detect any secret left exposed in any containers stored in Artifactory to stop any accidental leak of internal tokens or credentials.
     */
    secrets?: boolean;
    /**
     * Detect whether common OSS libraries and services are configured securely, so application can be easily hardened by default.
     */
    services?: boolean;
}

export interface RepositoryConfigPathsConfig {
    /**
     * If you select by pattern, you must define a retention period for all other artifacts in the repository in the All Other Artifacts setting.
     */
    allOtherArtifacts?: outputs.RepositoryConfigPathsConfigAllOtherArtifact[];
    /**
     * Pattern, applied to the repositories.
     */
    patterns?: outputs.RepositoryConfigPathsConfigPattern[];
}

export interface RepositoryConfigPathsConfigAllOtherArtifact {
    /**
     * If checked, Xray will scan newly added artifacts in the path. Note that existing artifacts will not be scanned. If the folder contains existing artifacts that have been scanned, and you do not want to index new artifacts in that folder, you can choose not to index that folder.
     */
    indexNewArtifacts: boolean;
    /**
     * The artifact will be retained for the number of days you set here, after the artifact is scanned. This will apply to all artifacts in the repository.
     */
    retentionInDays: number;
}

export interface RepositoryConfigPathsConfigPattern {
    /**
     * Paths pattern to exclude from the set specific configuration.
     */
    exclude?: string;
    /**
     * Paths pattern to include in the set specific configuration.
     */
    include: string;
    /**
     * If checked, Xray will scan newly added artifacts in the path. Note that existing artifacts will not be scanned. If the folder contains existing artifacts that have been scanned, and you do not want to index new artifacts in that folder, you can choose not to index that folder.
     */
    indexNewArtifacts: boolean;
    /**
     * The artifact will be retained for the number of days you set here, after the artifact is scanned. This will apply to all artifacts in the repository.
     */
    retentionInDays: number;
}

export interface SecurityPolicyRule {
    /**
     * Specifies the actions to take once a security policy violation has been triggered.
     */
    actions: outputs.SecurityPolicyRuleActions;
    /**
     * The set of security conditions to examine when an scanned artifact is scanned.
     */
    criteria: outputs.SecurityPolicyRuleCriteria;
    /**
     * Name of the rule
     */
    name: string;
    /**
     * Integer describing the rule priority. Must be at least 1
     */
    priority: number;
}

export interface SecurityPolicyRuleActions {
    /**
     * Block download of artifacts that meet the Artifact Filter and Severity Filter specifications for this watch
     */
    blockDownload: outputs.SecurityPolicyRuleActionsBlockDownload;
    /**
     * Blocks Release Bundle distribution to Edge nodes if a violation is found. Default value is `false`.
     */
    blockReleaseBundleDistribution?: boolean;
    /**
     * Blocks Release Bundle promotion if a violation is found. Default value is `false`.
     */
    blockReleaseBundlePromotion?: boolean;
    /**
     * Allow grace period for certain number of days. All violations will be ignored during this time. To be used only if `fail_build` is enabled.
     */
    buildFailureGracePeriodInDays?: number;
    /**
     * Create Jira Ticket for this Policy Violation. Requires configured Jira integration. Default value is `false`.
     */
    createTicketEnabled?: boolean;
    /**
     * Whether or not the related CI build should be marked as failed if a violation is triggered. This option is only available when the policy is applied to an `xray.Watch` resource with a `type` of `builds`. Default value is `false`.
     */
    failBuild?: boolean;
    /**
     * A list of email addressed that will get emailed when a violation is triggered.
     */
    mails?: string[];
    /**
     * Sends an email message to component deployer with details about the generated Violations. Default value is `false`.
     */
    notifyDeployer?: boolean;
    /**
     * Sends an email message to all configured recipients inside a specific watch with details about the generated Violations. Default value is `false`.
     */
    notifyWatchRecipients?: boolean;
    /**
     * A list of Xray-configured webhook URLs to be invoked if a violation is triggered.
     */
    webhooks?: string[];
}

export interface SecurityPolicyRuleActionsBlockDownload {
    /**
     * Whether or not to block download of artifacts that meet the artifact and severity `filters` for the associated `xray.Watch` resource. Default value is `false`.
     */
    active?: boolean;
    /**
     * Whether or not to block download of artifacts that meet the artifact `filters` for the associated `xray.Watch` resource but have not been scanned yet. Can not be set to `true` if attribute `active` is `false`. Default value is `false`.
     */
    unscanned?: boolean;
}

export interface SecurityPolicyRuleCriteria {
    /**
     * Default value is `false`. Mark to skip CVEs that are not applicable in the context of the artifact. The contextual analysis operation might be long and affect build time if the `fail_build` action is set.
     *
     * ~>Only supported by JFrog Advanced Security
     */
    applicableCvesOnly?: boolean;
    /**
     * The CVSS score range to apply to the rule. This is used for a fine-grained control, rather than using the predefined severities. The score range is based on CVSS v3 scoring, and CVSS v2 score is CVSS v3 score is not available.
     */
    cvssRange?: outputs.SecurityPolicyRuleCriteriaCvssRange;
    /**
     * Creates policy rules for specific exposures.
     *
     * ~>Only supported by JFrog Advanced Security
     */
    exposures?: outputs.SecurityPolicyRuleCriteriaExposures;
    /**
     * Default value is `false`. Issues that do not have a fixed version are not generated until a fixed version is available. Must be `false` with `malicious_package` enabled.
     */
    fixVersionDependant?: boolean;
    /**
     * Default value is `false`. Generating a violation on a malicious package.
     */
    maliciousPackage?: boolean;
    /**
     * The minimum security vulnerability severity that will be impacted by the policy. Valid values: `All Severities`, `Critical`, `High`, `Medium`, `Low`
     */
    minSeverity?: string;
    /**
     * The package name to create a rule for
     */
    packageName?: string;
    /**
     * The package type to create a rule for
     */
    packageType?: string;
    /**
     * package versions to apply the rule on can be (,) for any version or an open range (1,4) or closed [1,4] or one version [1]
     */
    packageVersions?: string[];
    /**
     * Creates policy rules for specific vulnerability IDs that you input. You can add multiple vulnerabilities IDs up to 100. CVEs and Xray IDs are supported. Example - CVE-2015-20107, XRAY-2344
     */
    vulnerabilityIds?: string[];
}

export interface SecurityPolicyRuleCriteriaCvssRange {
    /**
     * The beginning of the range of CVS scores (from 1-10, float) to flag.
     */
    from: number;
    /**
     * The end of the range of CVS scores (from 1-10, float) to flag.
     */
    to: number;
}

export interface SecurityPolicyRuleCriteriaExposures {
    /**
     * Applications exposures.
     */
    applications?: boolean;
    /**
     * Iac exposures.
     */
    iac?: boolean;
    /**
     * The minimum security vulnerability severity that will be impacted by the policy. Valid values: `All Severities`, `Critical`, `High`, `Medium`, `Low`
     */
    minSeverity?: string;
    /**
     * Secrets exposures.
     */
    secrets?: boolean;
    /**
     * Services exposures.
     */
    services?: boolean;
}

export interface ViolationsReportFilter {
    /**
     * Filter by artifact name, you can use (*) at the beginning or end of a substring as a wildcard.
     */
    artifact?: string;
    /**
     * Filter by component name, you can use (*) at the beginning or end of a substring as a wildcard.
     */
    component?: string;
    /**
     * Licenses Filters.
     */
    licenseFilters?: outputs.ViolationsReportFilterLicenseFilters;
    /**
     * Select Xray policies by name.
     */
    policyNames?: string[];
    /**
     * Security Filters.
     */
    securityFilters?: outputs.ViolationsReportFilterSecurityFilters;
    /**
     * Risk/severity levels. Allowed values: 'None', 'Low', 'Medium', 'High'.
     */
    severities?: string[];
    /**
     * Violation type.
     */
    type?: string;
    updated?: outputs.ViolationsReportFilterUpdated;
    /**
     * Select Xray watch by names. Only one attribute - 'watch_names' or 'watch_patterns' can be set.
     */
    watchNames?: string[];
    /**
     * Select Xray watch name by patterns. Only one attribute - 'watch_names' or 'watch_patterns' can be set.
     */
    watchPatterns?: string[];
}

export interface ViolationsReportFilterLicenseFilters {
    /**
     * Filter licenses by names.
     */
    licenseNames?: string[];
    /**
     * Filter licenses by patterns.
     */
    licensePatterns?: string[];
    /**
     * Unknown displays the components that Xray could not discover any licenses for.
     */
    unknown?: boolean;
    /**
     * Unrecognized displays the components that Xray found licenses for, but these licenses are not Xray recognized licenses.
     */
    unrecognized?: boolean;
}

export interface ViolationsReportFilterSecurityFilters {
    /**
     * CVE.
     */
    cve?: string;
    /**
     * CVSS score.
     */
    cvssScore?: outputs.ViolationsReportFilterSecurityFiltersCvssScore;
    /**
     * Whether the issue has a fix or not.
     */
    hasRemediation?: boolean;
    /**
     * Issue ID.
     */
    issueId?: string;
    /**
     * Vulnerability Summary.
     */
    summaryContains?: string;
}

export interface ViolationsReportFilterSecurityFiltersCvssScore {
    /**
     * Maximum CVSS score.
     */
    maxScore?: number;
    /**
     * Minimum CVSS score.
     */
    minScore?: number;
}

export interface ViolationsReportFilterUpdated {
    /**
     * Created to date.
     */
    end?: string;
    /**
     * Created from date.
     */
    start?: string;
}

export interface ViolationsReportResources {
    /**
     * The builds to include into the report. Only one type of resource can be set per report.
     */
    builds?: outputs.ViolationsReportResourcesBuilds;
    /**
     * The projects to include into the report. Only one type of resource can be set per report.
     */
    projects?: outputs.ViolationsReportResourcesProjects;
    /**
     * The release bundles to include into the report. Only one type of resource can be set per report.
     */
    releaseBundles?: outputs.ViolationsReportResourcesReleaseBundles;
    /**
     * The list of repositories for the report. Only one type of resource can be set per report.
     */
    repositories?: outputs.ViolationsReportResourcesRepository[];
}

export interface ViolationsReportResourcesBuilds {
    /**
     * The list of exclude patterns. Only one of 'names' or '*_patterns' can be set.
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns. Only one of 'names' or '*_patterns' can be set.
     */
    includePatterns?: string[];
    /**
     * The list of build names. Only one of 'names' or '*_patterns' can be set.
     */
    names?: string[];
    /**
     * The number of latest build versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface ViolationsReportResourcesProjects {
    /**
     * The list of include patterns.
     */
    includeKeyPatterns?: string[];
    /**
     * The list of project names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface ViolationsReportResourcesReleaseBundles {
    /**
     * The list of exclude patterns
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns
     */
    includePatterns?: string[];
    /**
     * The list of release bundles names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface ViolationsReportResourcesRepository {
    /**
     * Exclude path patterns.
     */
    excludePathPatterns?: string[];
    /**
     * Include path patterns.
     */
    includePathPatterns?: string[];
    /**
     * Repository name.
     */
    name: string;
}

export interface VulnerabilitiesReportFilter {
    /**
     * CVE.
     */
    cve?: string;
    /**
     * CVSS score.
     */
    cvssScore?: outputs.VulnerabilitiesReportFilterCvssScore;
    /**
     * Whether the issue has a fix or not.
     */
    hasRemediation?: boolean;
    /**
     * Filter by artifact name, you can use (*) at the eginning or end of a substring as a wildcard.
     */
    impactedArtifact?: string;
    /**
     * Issue ID.
     */
    issueId?: string;
    published?: outputs.VulnerabilitiesReportFilterPublished;
    scanDate?: outputs.VulnerabilitiesReportFilterScanDate;
    /**
     * Severity levels. Allowed values: 'Low', 'Medium', 'High', 'Critical'
     */
    severities?: string[];
    /**
     * Filter by component name, you can use (*) at the beginning or end of a substring as a wildcard.
     */
    vulnerableComponent?: string;
}

export interface VulnerabilitiesReportFilterCvssScore {
    /**
     * Maximum CVSS score.
     */
    maxScore?: number;
    /**
     * Minimum CVSS score.
     */
    minScore?: number;
}

export interface VulnerabilitiesReportFilterPublished {
    /**
     * Published to date.
     */
    end?: string;
    /**
     * Published from date.
     */
    start?: string;
}

export interface VulnerabilitiesReportFilterScanDate {
    /**
     * Scanned to date.
     */
    end?: string;
    /**
     * Scanned from date.
     */
    start?: string;
}

export interface VulnerabilitiesReportResources {
    /**
     * The builds to include into the report. Only one type of resource can be set per report.
     */
    builds?: outputs.VulnerabilitiesReportResourcesBuilds;
    /**
     * The projects to include into the report. Only one type of resource can be set per report.
     */
    projects?: outputs.VulnerabilitiesReportResourcesProjects;
    /**
     * The release bundles to include into the report. Only one type of resource can be set per report.
     */
    releaseBundles?: outputs.VulnerabilitiesReportResourcesReleaseBundles;
    /**
     * The list of repositories for the report. Only one type of resource can be set per report.
     */
    repositories?: outputs.VulnerabilitiesReportResourcesRepository[];
}

export interface VulnerabilitiesReportResourcesBuilds {
    /**
     * The list of exclude patterns. Only one of 'names' or '*_patterns' can be set.
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns. Only one of 'names' or '*_patterns' can be set.
     */
    includePatterns?: string[];
    /**
     * The list of build names. Only one of 'names' or '*_patterns' can be set.
     */
    names?: string[];
    /**
     * The number of latest build versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface VulnerabilitiesReportResourcesProjects {
    /**
     * The list of include patterns.
     */
    includeKeyPatterns?: string[];
    /**
     * The list of project names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface VulnerabilitiesReportResourcesReleaseBundles {
    /**
     * The list of exclude patterns
     */
    excludePatterns?: string[];
    /**
     * The list of include patterns
     */
    includePatterns?: string[];
    /**
     * The list of release bundles names.
     */
    names?: string[];
    /**
     * The number of latest release bundle versions to include to the report.
     */
    numberOfLatestVersions?: number;
}

export interface VulnerabilitiesReportResourcesRepository {
    /**
     * Exclude path patterns.
     */
    excludePathPatterns?: string[];
    /**
     * Include path patterns.
     */
    includePathPatterns?: string[];
    /**
     * Repository name.
     */
    name: string;
}

export interface WatchAssignedPolicy {
    /**
     * The name of the policy that will be applied
     */
    name: string;
    /**
     * The type of the policy - security, license or operational risk
     */
    type: string;
}

export interface WatchWatchResource {
    /**
     * `ant-patterns` filter for `all-builds` and `all-projects` watch_resource.type
     */
    antFilters?: outputs.WatchWatchResourceAntFilter[];
    /**
     * The ID number of a binary manager resource. Default value is `default`. To check the list of available binary managers, use the API call `${JFROG_URL}/xray/api/v1/binMgr` as an admin user, use `binMgrId` value. More info [here](https://www.jfrog.com/confluence/display/JFROG/Xray+REST+API#XrayRESTAPI-GetBinaryManager)
     */
    binMgrId: string;
    /**
     * Filter for `regex`, `package-type` and `mime-type` type. Works for `repository` and `all-repos` watch_resource.type
     */
    filters?: outputs.WatchWatchResourceFilter[];
    /**
     * Filter for `property` type. Works for `repository` and `all-repos` watch_resource.type.
     */
    kvFilters?: outputs.WatchWatchResourceKvFilter[];
    /**
     * The name of the build, repository, project, or release bundle. Xray indexing must be enabled on the repository, build, or release bundle.
     */
    name?: string;
    /**
     * `path-ant-patterns` filter for `repository` and `all-repos` watch_resource.type
     */
    pathAntFilters?: outputs.WatchWatchResourcePathAntFilter[];
    /**
     * Type of repository. Only applicable when `type` is `repository`. Options: `local` or `remote`.
     */
    repoType?: string;
    /**
     * Type of resource to be watched. Options: repository, all-repos, build, all-builds, project, all-projects, releaseBundle, all-releaseBundles, releaseBundleV2, all-releaseBundlesV2.
     */
    type: string;
}

export interface WatchWatchResourceAntFilter {
    /**
     * Use Ant-style wildcard patterns to specify build names (i.e. artifact paths) in the build info repository (without a leading slash) that will be excluded in this watch. Projects are supported too. Ant-style path expressions are supported (*, **, ?). For example, an 'apache/**' pattern will exclude the 'apache' build info in the watch.
     */
    excludePatterns?: string[];
    /**
     * Use Ant-style wildcard patterns to specify build names (i.e. artifact paths) in the build info repository (without a leading slash) that will be included in this watch. Projects are supported too. Ant-style path expressions are supported (*, **, ?). For example, an 'apache/**' pattern will include the 'apache' build info in the watch.
     */
    includePatterns?: string[];
}

export interface WatchWatchResourceFilter {
    /**
     * The type of filter, such as `regex`, `path-regex`, `package-type`, or `mime-type`
     */
    type: string;
    /**
     * The value of the filter, such as the text of the regex, name of the package type, or mime type.
     */
    value: string;
}

export interface WatchWatchResourceKvFilter {
    /**
     * The value of the filter, such as the property name of the artifact.
     */
    key: string;
    /**
     * The type of filter. Currently only support `property`
     */
    type: string;
    /**
     * The value of the filter, such as the property value of the artifact.
     */
    value: string;
}

export interface WatchWatchResourcePathAntFilter {
    /**
     * The pattern will apply to the selected repositories. Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, **, ?). For example: 'org/apache/**'
     */
    excludePatterns?: string[];
    /**
     * The pattern will apply to the selected repositories. Simple comma separated wildcard patterns for repository artifact paths (with no leading slash). Ant-style path expressions are supported (*, **, ?). For example: 'org/apache/**'
     */
    includePatterns?: string[];
}

export interface WorkersCountAnalysis {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountImpactAnalysis {
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountIndex {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountMigrationSbom {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountNotification {
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountPanoramic {
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountPersist {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountPolicyEnforcer {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountSbom {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountSbomImpactAnalysis {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

export interface WorkersCountUserCatalog {
    /**
     * Number of workers for existing content
     */
    existingContent: number;
    /**
     * Number of workers for new content
     */
    newContent: number;
}

