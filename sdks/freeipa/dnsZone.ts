// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class DnsZone extends pulumi.CustomResource {
    /**
     * Get an existing DnsZone resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DnsZoneState, opts?: pulumi.CustomResourceOptions): DnsZone {
        return new DnsZone(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'freeipa:index/dnsZone:DnsZone';

    /**
     * Returns true if the given object is an instance of DnsZone.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is DnsZone {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === DnsZone.__pulumiType;
    }

    /**
     * Administrator e-mail address
     */
    public readonly adminEmailAddress!: pulumi.Output<string | undefined>;
    /**
     * Allow inline DNSSEC signing of records in the zone
     */
    public readonly allowInlineDnssecSigning!: pulumi.Output<boolean | undefined>;
    /**
     * Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
     */
    public readonly allowPrtSync!: pulumi.Output<boolean | undefined>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to issue queries
     */
    public readonly allowQuery!: pulumi.Output<string | undefined>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
     */
    public readonly allowTransfer!: pulumi.Output<string | undefined>;
    /**
     * Authoritative nameserver domain name
     */
    public readonly authoritativeNameserver!: pulumi.Output<string | undefined>;
    /**
     * BIND update policy
     */
    public readonly bindUpdatePolicy!: pulumi.Output<string | undefined>;
    /**
     * Time to live for records without explicit TTL definition
     */
    public readonly defaultTtl!: pulumi.Output<number | undefined>;
    /**
     * Allow disabled the zone
     */
    public readonly disableZone!: pulumi.Output<boolean | undefined>;
    /**
     * Allow dynamic updates
     */
    public readonly dynamicUpdates!: pulumi.Output<boolean | undefined>;
    /**
     * Allow create the reverse zone
     */
    public readonly isReverseZone!: pulumi.Output<boolean | undefined>;
    /**
     * NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
     */
    public readonly nsec3paramRecord!: pulumi.Output<string | undefined>;
    /**
     * Force DNS zone creation even if nameserver is not resolvable
     */
    public readonly skipNameserverCheck!: pulumi.Output<boolean | undefined>;
    /**
     * Force DNS zone creation even if it will overlap with an existing zone
     */
    public readonly skipOverlapCheck!: pulumi.Output<boolean | undefined>;
    /**
     * SOA record expire time
     */
    public readonly soaExpire!: pulumi.Output<number | undefined>;
    /**
     * How long should negative responses be cached
     */
    public readonly soaMinimum!: pulumi.Output<number | undefined>;
    /**
     * SOA record refresh time
     */
    public readonly soaRefresh!: pulumi.Output<number | undefined>;
    /**
     * SOA record retry time
     */
    public readonly soaRetry!: pulumi.Output<number | undefined>;
    /**
     * SOA record serial number
     */
    public readonly soaSerialNumber!: pulumi.Output<number | undefined>;
    /**
     * Time to live for records at zone apex
     */
    public readonly ttl!: pulumi.Output<number | undefined>;
    /**
     * Per-zone forwarders. A custom port can be specified for each forwarder using a standard format IP_ADDRESS port PORT
     */
    public readonly zoneForwarders!: pulumi.Output<string[] | undefined>;
    /**
     * Zone name (FQDN)
     */
    public readonly zoneName!: pulumi.Output<string>;

    /**
     * Create a DnsZone resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DnsZoneArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DnsZoneArgs | DnsZoneState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DnsZoneState | undefined;
            resourceInputs["adminEmailAddress"] = state ? state.adminEmailAddress : undefined;
            resourceInputs["allowInlineDnssecSigning"] = state ? state.allowInlineDnssecSigning : undefined;
            resourceInputs["allowPrtSync"] = state ? state.allowPrtSync : undefined;
            resourceInputs["allowQuery"] = state ? state.allowQuery : undefined;
            resourceInputs["allowTransfer"] = state ? state.allowTransfer : undefined;
            resourceInputs["authoritativeNameserver"] = state ? state.authoritativeNameserver : undefined;
            resourceInputs["bindUpdatePolicy"] = state ? state.bindUpdatePolicy : undefined;
            resourceInputs["defaultTtl"] = state ? state.defaultTtl : undefined;
            resourceInputs["disableZone"] = state ? state.disableZone : undefined;
            resourceInputs["dynamicUpdates"] = state ? state.dynamicUpdates : undefined;
            resourceInputs["isReverseZone"] = state ? state.isReverseZone : undefined;
            resourceInputs["nsec3paramRecord"] = state ? state.nsec3paramRecord : undefined;
            resourceInputs["skipNameserverCheck"] = state ? state.skipNameserverCheck : undefined;
            resourceInputs["skipOverlapCheck"] = state ? state.skipOverlapCheck : undefined;
            resourceInputs["soaExpire"] = state ? state.soaExpire : undefined;
            resourceInputs["soaMinimum"] = state ? state.soaMinimum : undefined;
            resourceInputs["soaRefresh"] = state ? state.soaRefresh : undefined;
            resourceInputs["soaRetry"] = state ? state.soaRetry : undefined;
            resourceInputs["soaSerialNumber"] = state ? state.soaSerialNumber : undefined;
            resourceInputs["ttl"] = state ? state.ttl : undefined;
            resourceInputs["zoneForwarders"] = state ? state.zoneForwarders : undefined;
            resourceInputs["zoneName"] = state ? state.zoneName : undefined;
        } else {
            const args = argsOrState as DnsZoneArgs | undefined;
            if ((!args || args.zoneName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'zoneName'");
            }
            resourceInputs["adminEmailAddress"] = args ? args.adminEmailAddress : undefined;
            resourceInputs["allowInlineDnssecSigning"] = args ? args.allowInlineDnssecSigning : undefined;
            resourceInputs["allowPrtSync"] = args ? args.allowPrtSync : undefined;
            resourceInputs["allowQuery"] = args ? args.allowQuery : undefined;
            resourceInputs["allowTransfer"] = args ? args.allowTransfer : undefined;
            resourceInputs["authoritativeNameserver"] = args ? args.authoritativeNameserver : undefined;
            resourceInputs["bindUpdatePolicy"] = args ? args.bindUpdatePolicy : undefined;
            resourceInputs["defaultTtl"] = args ? args.defaultTtl : undefined;
            resourceInputs["disableZone"] = args ? args.disableZone : undefined;
            resourceInputs["dynamicUpdates"] = args ? args.dynamicUpdates : undefined;
            resourceInputs["isReverseZone"] = args ? args.isReverseZone : undefined;
            resourceInputs["nsec3paramRecord"] = args ? args.nsec3paramRecord : undefined;
            resourceInputs["skipNameserverCheck"] = args ? args.skipNameserverCheck : undefined;
            resourceInputs["skipOverlapCheck"] = args ? args.skipOverlapCheck : undefined;
            resourceInputs["soaExpire"] = args ? args.soaExpire : undefined;
            resourceInputs["soaMinimum"] = args ? args.soaMinimum : undefined;
            resourceInputs["soaRefresh"] = args ? args.soaRefresh : undefined;
            resourceInputs["soaRetry"] = args ? args.soaRetry : undefined;
            resourceInputs["soaSerialNumber"] = args ? args.soaSerialNumber : undefined;
            resourceInputs["ttl"] = args ? args.ttl : undefined;
            resourceInputs["zoneForwarders"] = args ? args.zoneForwarders : undefined;
            resourceInputs["zoneName"] = args ? args.zoneName : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(DnsZone.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering DnsZone resources.
 */
export interface DnsZoneState {
    /**
     * Administrator e-mail address
     */
    adminEmailAddress?: pulumi.Input<string>;
    /**
     * Allow inline DNSSEC signing of records in the zone
     */
    allowInlineDnssecSigning?: pulumi.Input<boolean>;
    /**
     * Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
     */
    allowPrtSync?: pulumi.Input<boolean>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to issue queries
     */
    allowQuery?: pulumi.Input<string>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
     */
    allowTransfer?: pulumi.Input<string>;
    /**
     * Authoritative nameserver domain name
     */
    authoritativeNameserver?: pulumi.Input<string>;
    /**
     * BIND update policy
     */
    bindUpdatePolicy?: pulumi.Input<string>;
    /**
     * Time to live for records without explicit TTL definition
     */
    defaultTtl?: pulumi.Input<number>;
    /**
     * Allow disabled the zone
     */
    disableZone?: pulumi.Input<boolean>;
    /**
     * Allow dynamic updates
     */
    dynamicUpdates?: pulumi.Input<boolean>;
    /**
     * Allow create the reverse zone
     */
    isReverseZone?: pulumi.Input<boolean>;
    /**
     * NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
     */
    nsec3paramRecord?: pulumi.Input<string>;
    /**
     * Force DNS zone creation even if nameserver is not resolvable
     */
    skipNameserverCheck?: pulumi.Input<boolean>;
    /**
     * Force DNS zone creation even if it will overlap with an existing zone
     */
    skipOverlapCheck?: pulumi.Input<boolean>;
    /**
     * SOA record expire time
     */
    soaExpire?: pulumi.Input<number>;
    /**
     * How long should negative responses be cached
     */
    soaMinimum?: pulumi.Input<number>;
    /**
     * SOA record refresh time
     */
    soaRefresh?: pulumi.Input<number>;
    /**
     * SOA record retry time
     */
    soaRetry?: pulumi.Input<number>;
    /**
     * SOA record serial number
     */
    soaSerialNumber?: pulumi.Input<number>;
    /**
     * Time to live for records at zone apex
     */
    ttl?: pulumi.Input<number>;
    /**
     * Per-zone forwarders. A custom port can be specified for each forwarder using a standard format IP_ADDRESS port PORT
     */
    zoneForwarders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Zone name (FQDN)
     */
    zoneName?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a DnsZone resource.
 */
export interface DnsZoneArgs {
    /**
     * Administrator e-mail address
     */
    adminEmailAddress?: pulumi.Input<string>;
    /**
     * Allow inline DNSSEC signing of records in the zone
     */
    allowInlineDnssecSigning?: pulumi.Input<boolean>;
    /**
     * Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
     */
    allowPrtSync?: pulumi.Input<boolean>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to issue queries
     */
    allowQuery?: pulumi.Input<string>;
    /**
     * Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
     */
    allowTransfer?: pulumi.Input<string>;
    /**
     * Authoritative nameserver domain name
     */
    authoritativeNameserver?: pulumi.Input<string>;
    /**
     * BIND update policy
     */
    bindUpdatePolicy?: pulumi.Input<string>;
    /**
     * Time to live for records without explicit TTL definition
     */
    defaultTtl?: pulumi.Input<number>;
    /**
     * Allow disabled the zone
     */
    disableZone?: pulumi.Input<boolean>;
    /**
     * Allow dynamic updates
     */
    dynamicUpdates?: pulumi.Input<boolean>;
    /**
     * Allow create the reverse zone
     */
    isReverseZone?: pulumi.Input<boolean>;
    /**
     * NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
     */
    nsec3paramRecord?: pulumi.Input<string>;
    /**
     * Force DNS zone creation even if nameserver is not resolvable
     */
    skipNameserverCheck?: pulumi.Input<boolean>;
    /**
     * Force DNS zone creation even if it will overlap with an existing zone
     */
    skipOverlapCheck?: pulumi.Input<boolean>;
    /**
     * SOA record expire time
     */
    soaExpire?: pulumi.Input<number>;
    /**
     * How long should negative responses be cached
     */
    soaMinimum?: pulumi.Input<number>;
    /**
     * SOA record refresh time
     */
    soaRefresh?: pulumi.Input<number>;
    /**
     * SOA record retry time
     */
    soaRetry?: pulumi.Input<number>;
    /**
     * SOA record serial number
     */
    soaSerialNumber?: pulumi.Input<number>;
    /**
     * Time to live for records at zone apex
     */
    ttl?: pulumi.Input<number>;
    /**
     * Per-zone forwarders. A custom port can be specified for each forwarder using a standard format IP_ADDRESS port PORT
     */
    zoneForwarders?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Zone name (FQDN)
     */
    zoneName: pulumi.Input<string>;
}
