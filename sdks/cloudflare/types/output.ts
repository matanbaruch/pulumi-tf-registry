// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: boolean;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: boolean;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: boolean;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: boolean;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: string[];
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: string[];
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: string[];
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: number;
}

export interface AccessApplicationFooterLink {
    /**
     * The name of the footer link.
     */
    name?: string;
    /**
     * The URL of the footer link.
     */
    url?: string;
}

export interface AccessApplicationLandingPageDesign {
    /**
     * The button color of the landing page.
     */
    buttonColor?: string;
    /**
     * The button text color of the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image to be displayed in the landing page.
     */
    imageUrl?: string;
    /**
     * The message of the landing page.
     */
    message?: string;
    /**
     * The title of the landing page.
     */
    title?: string;
}

export interface AccessApplicationSaasApp {
    /**
     * The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime?: string;
    /**
     * Allow PKCE flow without a client secret.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users.
     */
    appLauncherUrl?: string;
    /**
     * **Modifying this attribute will force creation of a new resource.**
     */
    authType?: string;
    /**
     * The application client id.
     */
    clientId: string;
    /**
     * The application client secret, only returned on initial apply.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    /**
     * Custom attribute mapped from IDPs.
     */
    customAttributes?: outputs.AccessApplicationSaasAppCustomAttribute[];
    /**
     * Custom claim mapped from IDPs.
     */
    customClaims?: outputs.AccessApplicationSaasAppCustomClaim[];
    /**
     * The relay state used if not provided by the identity provider.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application.
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
     */
    groupFilterRegex?: string;
    /**
     * Hybrid and Implicit Flow options.
     */
    hybridAndImplicitOptions?: outputs.AccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for the SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The public certificate that will be used to verify identities.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
     */
    redirectUris?: string[];
    /**
     * Refresh token grant options.
     */
    refreshTokenOptions?: outputs.AccessApplicationSaasAppRefreshTokenOption[];
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml_attributes or oidc_fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access.
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where the SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface AccessApplicationSaasAppCustomAttribute {
    /**
     * A friendly name for the attribute as provided to the SaaS app.
     */
    friendlyName?: string;
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    source: outputs.AccessApplicationSaasAppCustomAttributeSource;
}

export interface AccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface AccessApplicationSaasAppCustomClaim {
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     */
    scope?: string;
    source: outputs.AccessApplicationSaasAppCustomClaimSource;
}

export interface AccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface AccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If true, the authorization endpoint will return an access token.
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If true, the authorization endpoint will return an id token.
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface AccessApplicationSaasAppRefreshTokenOption {
    /**
     * How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface AccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
     */
    authentication?: outputs.AccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings?: outputs.AccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface AccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientSecret?: string;
    /**
     * Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    user?: string;
}

export interface AccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations?: outputs.AccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface AccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface AccessGroupExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessGroupExcludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessGroupExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupExcludeOkta[];
    samls?: outputs.AccessGroupExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessGroupIncludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessGroupIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupIncludeOkta[];
    samls?: outputs.AccessGroupIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessGroupRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessGroupRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessGroupRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessGroupRequireExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessGroupRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessGroupRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessGroupRequireOkta[];
    samls?: outputs.AccessGroupRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessGroupRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessGroupRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessGroupRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessGroupRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessGroupRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessGroupRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessGroupRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessIdentityProviderConfig {
    apiToken?: string;
    appsDomain?: string;
    attributes: string[];
    authUrl?: string;
    authorizationServerId?: string;
    centrifyAccount?: string;
    centrifyAppId?: string;
    certsUrl?: string;
    claims: string[];
    clientId?: string;
    clientSecret?: string;
    conditionalAccessEnabled?: boolean;
    directoryId?: string;
    emailAttributeName?: string;
    emailClaimName?: string;
    idpPublicCert?: string;
    issuerUrl?: string;
    oktaAccount?: string;
    oneloginAccount?: string;
    pingEnvId?: string;
    pkceEnabled?: boolean;
    redirectUrl: string;
    scopes: string[];
    signRequest?: boolean;
    ssoTargetUrl?: string;
    supportGroups?: boolean;
    tokenUrl?: string;
}

export interface AccessIdentityProviderScimConfig {
    enabled?: boolean;
    groupMemberDeprovision?: boolean;
    seatDeprovision?: boolean;
    secret: string;
    userDeprovision?: boolean;
}

export interface AccessMutualTlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork?: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding?: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface AccessOrganizationCustomPage {
    /**
     * The id of the forbidden page.
     */
    forbidden?: string;
    /**
     * The id of the identity denied page.
     */
    identityDenied?: string;
}

export interface AccessOrganizationLoginDesign {
    /**
     * The background color on the login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of the login page.
     */
    footerText?: string;
    /**
     * The text at the top of the login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on the login page.
     */
    logoPath?: string;
    /**
     * The text color on the login page.
     */
    textColor?: string;
}

export interface AccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: number;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: string[];
    emailListUuid?: string;
}

export interface AccessPolicyExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessPolicyExcludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessPolicyExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyExcludeOkta[];
    samls?: outputs.AccessPolicyExcludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessPolicyIncludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessPolicyIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyIncludeOkta[];
    samls?: outputs.AccessPolicyIncludeSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessPolicyRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.AccessPolicyRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.AccessPolicyRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.AccessPolicyRequireExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.AccessPolicyRequireGithub[];
    groups?: string[];
    gsuites?: outputs.AccessPolicyRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.AccessPolicyRequireOkta[];
    samls?: outputs.AccessPolicyRequireSaml[];
    serviceTokens?: string[];
}

export interface AccessPolicyRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface AccessPolicyRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface AccessPolicyRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface AccessPolicyRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface AccessPolicyRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface AccessPolicyRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface AccessPolicyRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface AccessRuleConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip6`, `ip_range`, `asn`, `country`. **Modifying this attribute will force creation of a new resource.**
     */
    target: string;
    /**
     * The value to target. Depends on target's type. **Modifying this attribute will force creation of a new resource.**
     */
    value: string;
}

export interface AddressMapIp {
    /**
     * An IPv4 or IPv6 address.
     */
    ip: string;
}

export interface AddressMapMembership {
    /**
     * Controls whether the membership can be deleted via the API or not.
     */
    canDelete: boolean;
    /**
     * Identifier of the account or zone.
     */
    identifier: string;
    /**
     * The type of the membership.
     */
    kind: string;
}

export interface ApiShieldAuthIdCharacteristic {
    /**
     * The name of the characteristic.
     */
    name?: string;
    /**
     * The type of characteristic. Available values: `header`, `cookie`.
     */
    type?: string;
}

export interface ApiTokenCondition {
    /**
     * Request IP related conditions.
     */
    requestIp?: outputs.ApiTokenConditionRequestIp;
}

export interface ApiTokenConditionRequestIp {
    /**
     * List of IP addresses or CIDR notation where the token may be used from. If not specified, the token will be valid for all IP addresses.
     */
    ins?: string[];
    /**
     * List of IP addresses or CIDR notation where the token should not be used from.
     */
    notIns?: string[];
}

export interface ApiTokenPolicy {
    /**
     * Effect of the policy. Available values: `allow`, `deny`. Defaults to `allow`.
     */
    effect?: string;
    /**
     * List of permissions groups IDs. See [documentation](https://developers.cloudflare.com/api/tokens/create/permissions) for more information.
     */
    permissionGroups: string[];
    /**
     * Describes what operations against which resources are allowed or denied.
     */
    resources: {[key: string]: string};
}

export interface AuthenticatedOriginPullsCertificateTimeouts {
    create?: string;
}

export interface CertificatePackValidationError {
    message: string;
}

export interface CertificatePackValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomHostnameSsl {
    /**
     * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: string;
    certificateAuthority: string;
    /**
     * If a custom uploaded certificate is used.
     */
    customCertificate?: string;
    /**
     * The key for a custom uploaded certificate.
     */
    customKey?: string;
    /**
     * Domain control validation (DCV) method used for this hostname. Available values: `http`, `txt`, `email`.
     */
    method?: string;
    /**
     * SSL/TLS settings for the certificate.
     */
    settings?: outputs.CustomHostnameSslSetting[];
    status: string;
    /**
     * Level of validation to be used for this hostname. Available values: `dv`. Defaults to `dv`.
     */
    type?: string;
    validationErrors: outputs.CustomHostnameSslValidationError[];
    validationRecords: outputs.CustomHostnameSslValidationRecord[];
    /**
     * Indicates whether the certificate covers a wildcard.
     */
    wildcard?: boolean;
}

export interface CustomHostnameSslSetting {
    /**
     * List of SSL/TLS ciphers to associate with this certificate.
     */
    ciphers?: string[];
    /**
     * Whether early hints should be supported. Available values: `on`, `off`.
     */
    earlyHints?: string;
    /**
     * Whether HTTP2 should be supported. Available values: `on`, `off`.
     */
    http2?: string;
    /**
     * Lowest version of TLS this certificate should support. Available values: `1.0`, `1.1`, `1.2`, `1.3`.
     */
    minTlsVersion?: string;
    /**
     * Whether TLSv1.3 should be supported. Available values: `on`, `off`.
     */
    tls13?: string;
}

export interface CustomHostnameSslValidationError {
    message: string;
}

export interface CustomHostnameSslValidationRecord {
    cnameName: string;
    cnameTarget: string;
    emails: string[];
    httpBody: string;
    httpUrl: string;
    txtName: string;
    txtValue: string;
}

export interface CustomSslCustomSslOptions {
    /**
     * Method of building intermediate certificate chain. A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it. Available values: `ubiquitous`, `optimal`, `force`.
     */
    bundleMethod?: string;
    /**
     * Certificate certificate and the intermediate(s).
     */
    certificate?: string;
    /**
     * Specifies the region where your private key can be held locally. Available values: `us`, `eu`, `highest_security`.
     */
    geoRestrictions?: string;
    /**
     * Certificate's private key.
     */
    privateKey?: string;
    /**
     * Whether to enable support for legacy clients which do not include SNI in the TLS handshake. Available values: `legacy_custom`, `sni_custom`.
     */
    type?: string;
}

export interface CustomSslCustomSslPriority {
    id?: string;
    priority?: number;
}

export interface DeviceDexTestData {
    /**
     * The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
     */
    host: string;
    /**
     * The type of Device Dex Test. Available values: `http`, `traceroute`.
     */
    kind: string;
    /**
     * The http request method. Available values: `GET`.
     */
    method?: string;
}

export interface DeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface DevicePostureIntegrationConfig {
    /**
     * The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
     */
    accessClientId?: string;
    /**
     * The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
     */
    accessClientSecret?: string;
    /**
     * The third-party API's URL.
     */
    apiUrl?: string;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: string;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: string;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: string;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: string;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: string;
}

export interface DevicePostureRuleInput {
    /**
     * The number of active threats from SentinelOne.
     */
    activeThreats?: number;
    /**
     * The UUID of a Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * Specific volume(s) to check for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device.
     */
    checkPrivateKey?: boolean;
    /**
     * The common name for a certificate.
     */
    cn?: string;
    /**
     * The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
     */
    complianceStatus?: string;
    /**
     * The workspace one or intune connection id.
     */
    connectionId?: string;
    /**
     * The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    countOperator?: string;
    /**
     * The domain that the client must join.
     */
    domain?: string;
    /**
     * The datetime a device last seen in RFC 3339 format from Tanium.
     */
    eidLastSeen?: string;
    /**
     * True if the firewall must be enabled.
     */
    enabled: boolean;
    /**
     * Checks if the file should exist.
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
     */
    extendedKeyUsages?: string[];
    /**
     * The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
     */
    id?: string;
    /**
     * True if SentinelOne device is infected.
     */
    infected: boolean;
    /**
     * True if SentinelOne device is active.
     */
    isActive: boolean;
    /**
     * The number of issues for kolide.
     */
    issueCount?: string;
    /**
     * The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
     */
    lastSeen?: string;
    /**
     * List of locations to check for client certificate.
     */
    locations?: outputs.DevicePostureRuleInputLocation[];
    /**
     * The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
     */
    networkStatus?: string;
    /**
     * The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    operator?: string;
    /**
     * OS signal score from Crowdstrike. Value must be between 1 and 100.
     */
    os?: string;
    /**
     * The operating system excluding version information.
     */
    osDistroName?: string;
    /**
     * The operating system version excluding OS name information or release name.
     */
    osDistroRevision?: string;
    /**
     * Extra version value following the operating system semantic version.
     */
    osVersionExtra?: string;
    /**
     * Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
     */
    overall?: string;
    /**
     * The path to the file.
     */
    path?: string;
    /**
     * True if all drives must be encrypted.
     */
    requireAll: boolean;
    /**
     * The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
     */
    riskLevel?: string;
    /**
     * Checks if the application should be running.
     */
    running: boolean;
    /**
     * Sensor signal score from Crowdstrike. Value must be between 1 and 100.
     */
    sensorConfig?: string;
    /**
     * The sha256 hash of the file.
     */
    sha256?: string;
    /**
     * The host’s current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
     */
    state?: string;
    /**
     * The thumbprint of the file certificate.
     */
    thumbprint?: string;
    /**
     * The total score from Tanium.
     */
    totalScore?: number;
    /**
     * The operating system semantic version.
     */
    version?: string;
    /**
     * The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    versionOperator?: string;
}

export interface DevicePostureRuleInputLocation {
    /**
     * List of paths to check for client certificate rule.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate rule. Available values: `system`, `user`.
     */
    trustStores?: string[];
}

export interface DevicePostureRuleMatch {
    /**
     * The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
     */
    platform?: string;
}

export interface DlpProfileContextAwareness {
    /**
     * Scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.DlpProfileContextAwarenessSkip;
}

export interface DlpProfileContextAwarenessSkip {
    /**
     * Return all matches, regardless of context analysis result, if the data is a file.
     */
    files: boolean;
}

export interface DlpProfileEntry {
    /**
     * Whether the entry is active. Defaults to `false`.
     */
    enabled?: boolean;
    /**
     * Unique entry identifier.
     */
    id: string;
    /**
     * Name of the entry to deploy.
     */
    name: string;
    pattern?: outputs.DlpProfileEntryPattern;
}

export interface DlpProfileEntryPattern {
    /**
     * The regex that defines the pattern.
     */
    regex: string;
    /**
     * The validation algorithm to apply with this pattern.
     */
    validation?: string;
}

export interface EmailRoutingCatchAllAction {
    /**
     * Type of supported action. Available values: `drop`, `forward`, `worker`.
     */
    type: string;
    /**
     * A list with items in the following form.
     */
    values: string[];
}

export interface EmailRoutingCatchAllMatcher {
    /**
     * Type of matcher. Available values: `all`.
     */
    type: string;
}

export interface EmailRoutingRuleAction {
    /**
     * Type of action. Available values: `forward`, `worker`, `drop`
     */
    type: string;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    values?: string[];
}

export interface EmailRoutingRuleMatcher {
    /**
     * Field to match on. Required for `type` of `literal`.
     */
    field?: string;
    /**
     * Type of matcher. Available values: `literal`, `all`
     */
    type: string;
    /**
     * Value to match on. Required for `type` of `literal`.
     */
    value?: string;
}

export interface FallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix?: string;
}

export interface GetAccountRolesRole {
    description: string;
    id: string;
    name: string;
}

export interface GetAccountsAccount {
    enforceTwofactor: boolean;
    id: string;
    name: string;
    type: string;
}

export interface GetDevicePostureRulesRule {
    description: string;
    expiration: string;
    id: string;
    name: string;
    schedule: string;
    type: string;
}

export interface GetDevicesDevice {
    created: string;
    deleted: boolean;
    deviceType: string;
    id: string;
    ip: string;
    key: string;
    lastSeen: string;
    macAddress: string;
    manufacturer: string;
    model: string;
    name: string;
    osDistroName: string;
    osDistroRevision: string;
    osVersion: string;
    osVersionExtra: string;
    revokedAt: string;
    serialNumber: string;
    updated: string;
    userEmail: string;
    userId: string;
    userName: string;
    version: string;
}

export interface GetDlpDatasetsDataset {
    description: string;
    id: string;
    name: string;
    secret: boolean;
    status: string;
}

export interface GetGatewayAppTypesAppType {
    /**
     * The identifier for the application type of this app.
     */
    applicationTypeId: number;
    /**
     * A short summary of the app type.
     */
    description: string;
    /**
     * The identifier for this app type. There is only one app type per ID.
     */
    id: number;
    /**
     * The name of the app type.
     */
    name: string;
}

export interface GetGatewayCategoriesCategory {
    /**
     * True if the category is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Which account types are allowed to create policies based on this category.
     */
    class: string;
    /**
     * A short summary of domains in the category.
     */
    description: string;
    /**
     * The identifier for this category. There is only one category per ID.
     */
    id: number;
    /**
     * The name of the category.
     */
    name: string;
    /**
     * A list of subcategories.
     */
    subcategories: outputs.GetGatewayCategoriesCategorySubcategory[];
}

export interface GetGatewayCategoriesCategorySubcategory {
    /**
     * True if the subcategory is in beta and subject to change.
     */
    beta: boolean;
    /**
     * Which account types are allowed to create policies based on this subcategory.
     */
    class: string;
    /**
     * A short summary of domains in the subcategory.
     */
    description: string;
    /**
     * The identifier for this subcategory. There is only one subcategory per ID.
     */
    id: number;
    /**
     * The name of the subcategory.
     */
    name: string;
}

export interface GetListsList {
    description: string;
    id: string;
    kind: string;
    name: string;
    numitems: number;
}

export interface GetLoadBalancerPoolsFilter {
    /**
     * A regular expression matching the name of the Load Balancer pool to lookup.
     */
    name?: string;
}

export interface GetLoadBalancerPoolsPool {
    /**
     * List of regions (specified by region code) from which to run health checks. Empty means every Cloudflare data center (the default), but requires an Enterprise plan. Region codes can be found [here](https://support.cloudflare.com/hc/en-us/articles/115000540888-Load-Balancing-Geographic-Regions).
     */
    checkRegions: string[];
    /**
     * The RFC3339 timestamp of when the load balancer was created.
     */
    createdOn: string;
    /**
     * Brief description of the Load Balancer Pool intention.
     */
    description: string;
    /**
     * Whether this pool is enabled. Disabled pools will not receive traffic and are excluded from health checks.
     */
    enabled: boolean;
    /**
     * ID for this load balancer pool.
     */
    id: string;
    /**
     * Latitude this pool is physically located at; used for proximity steering.
     */
    latitude: number;
    /**
     * Setting for controlling load shedding for this pool.
     */
    loadSheddings: outputs.GetLoadBalancerPoolsPoolLoadShedding[];
    /**
     * Longitude this pool is physically located at; used for proximity steering.
     */
    longitude: number;
    /**
     * Minimum number of origins that must be healthy for this pool to serve traffic.
     */
    minimumOrigins: number;
    /**
     * The RFC3339 timestamp of when the load balancer was last modified.
     */
    modifiedOn: string;
    /**
     * ID of the Monitor to use for health checking origins within this pool.
     */
    monitor: string;
    /**
     * Short name (tag) for the pool.
     */
    name: string;
    /**
     * Email address to send health status notifications to. Multiple emails are set as a comma delimited list.
     */
    notificationEmail: string;
    /**
     * The list of origins within this pool.
     */
    origins: outputs.GetLoadBalancerPoolsPoolOrigin[];
}

export interface GetLoadBalancerPoolsPoolLoadShedding {
    defaultPercent: number;
    defaultPolicy: string;
    sessionPercent: number;
    sessionPolicy: string;
}

export interface GetLoadBalancerPoolsPoolOrigin {
    address: string;
    enabled: boolean;
    headers: outputs.GetLoadBalancerPoolsPoolOriginHeader[];
    name: string;
    virtualNetworkId: string;
    weight: number;
}

export interface GetLoadBalancerPoolsPoolOriginHeader {
    header: string;
    values: string[];
}

export interface GetRulesetsFilter {
    /**
     * The ID of the Ruleset to target.
     */
    id?: string;
    /**
     * Type of Ruleset to create. Available values: `custom`, `managed`, `root`, `zone`.
     */
    kind?: string;
    /**
     * Name of the ruleset.
     */
    name?: string;
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
     */
    phase?: string;
    /**
     * Version of the ruleset to filter on.
     */
    version?: string;
}

export interface GetRulesetsRuleset {
    description: string;
    id: string;
    kind: string;
    name: string;
    phase: string;
    rules: outputs.GetRulesetsRulesetRule[];
    version: string;
}

export interface GetRulesetsRulesetRule {
    action: string;
    actionParameters: outputs.GetRulesetsRulesetRuleActionParameter[];
    description: string;
    enabled: boolean;
    exposedCredentialChecks: outputs.GetRulesetsRulesetRuleExposedCredentialCheck[];
    expression: string;
    id: string;
    lastUpdated: string;
    loggings: outputs.GetRulesetsRulesetRuleLogging[];
    ratelimits: outputs.GetRulesetsRulesetRuleRatelimit[];
    ref: string;
    version: string;
}

export interface GetRulesetsRulesetRuleActionParameter {
    additionalCacheablePorts: number[];
    automaticHttpsRewrites: boolean;
    autominifies: outputs.GetRulesetsRulesetRuleActionParameterAutominify[];
    bic: boolean;
    browserTtls: outputs.GetRulesetsRulesetRuleActionParameterBrowserTtl[];
    cache: boolean;
    cacheKeys: outputs.GetRulesetsRulesetRuleActionParameterCacheKey[];
    content: string;
    contentType: string;
    cookieFields: string[];
    disableApps: boolean;
    disableRailgun: boolean;
    disableZaraz: boolean;
    edgeTtls: outputs.GetRulesetsRulesetRuleActionParameterEdgeTtl[];
    emailObfuscation: boolean;
    fromLists: outputs.GetRulesetsRulesetRuleActionParameterFromList[];
    fromValues: outputs.GetRulesetsRulesetRuleActionParameterFromValue[];
    headers: outputs.GetRulesetsRulesetRuleActionParameterHeader[];
    hostHeader: string;
    hotlinkProtection: boolean;
    id: string;
    increment: number;
    matchedDatas: outputs.GetRulesetsRulesetRuleActionParameterMatchedData[];
    mirage: boolean;
    opportunisticEncryption: boolean;
    originCacheControl: boolean;
    originErrorPagePassthru: boolean;
    origins: outputs.GetRulesetsRulesetRuleActionParameterOrigin[];
    overrides: outputs.GetRulesetsRulesetRuleActionParameterOverride[];
    phases: string[];
    polish: string;
    products: string[];
    readTimeout: number;
    requestFields: string[];
    respectStrongEtags: boolean;
    responseFields: string[];
    responses: outputs.GetRulesetsRulesetRuleActionParameterResponse[];
    rocketLoader: boolean;
    rules: {[key: string]: string};
    ruleset: string;
    rulesets: string[];
    securityLevel: string;
    serveStales: outputs.GetRulesetsRulesetRuleActionParameterServeStale[];
    serverSideExcludes: boolean;
    snis: outputs.GetRulesetsRulesetRuleActionParameterSni[];
    ssl: string;
    statusCode: number;
    sxg: boolean;
    uris: outputs.GetRulesetsRulesetRuleActionParameterUri[];
    version: string;
}

export interface GetRulesetsRulesetRuleActionParameterAutominify {
    css: boolean;
    html: boolean;
    js: boolean;
}

export interface GetRulesetsRulesetRuleActionParameterBrowserTtl {
    default: number;
    mode: string;
}

export interface GetRulesetsRulesetRuleActionParameterCacheKey {
    cacheByDeviceType: boolean;
    cacheDeceptionArmor: boolean;
    customKeys: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKey[];
    ignoreQueryStringsOrder: boolean;
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKey {
    cookies: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyCookie[];
    headers: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyHeader[];
    hosts: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyHost[];
    queryStrings: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyQueryString[];
    users: outputs.GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyUser[];
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyCookie {
    checkPresences: string[];
    includes: string[];
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyHeader {
    checkPresences: string[];
    excludeOrigin: boolean;
    includes: string[];
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyHost {
    resolved: boolean;
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyQueryString {
    excludes: string[];
    includes: string[];
}

export interface GetRulesetsRulesetRuleActionParameterCacheKeyCustomKeyUser {
    deviceType: boolean;
    geo: boolean;
    lang: boolean;
}

export interface GetRulesetsRulesetRuleActionParameterEdgeTtl {
    default: number;
    mode: string;
    statusCodeTtls: outputs.GetRulesetsRulesetRuleActionParameterEdgeTtlStatusCodeTtl[];
}

export interface GetRulesetsRulesetRuleActionParameterEdgeTtlStatusCodeTtl {
    statusCode: number;
    statusCodeRanges: outputs.GetRulesetsRulesetRuleActionParameterEdgeTtlStatusCodeTtlStatusCodeRange[];
    value: number;
}

export interface GetRulesetsRulesetRuleActionParameterEdgeTtlStatusCodeTtlStatusCodeRange {
    from: number;
    to: number;
}

export interface GetRulesetsRulesetRuleActionParameterFromList {
    key: string;
    name: string;
}

export interface GetRulesetsRulesetRuleActionParameterFromValue {
    preserveQueryString: boolean;
    statusCode: number;
    targetUrls: outputs.GetRulesetsRulesetRuleActionParameterFromValueTargetUrl[];
}

export interface GetRulesetsRulesetRuleActionParameterFromValueTargetUrl {
    expression: string;
    value: string;
}

export interface GetRulesetsRulesetRuleActionParameterHeader {
    expression: string;
    name: string;
    operation: string;
    value: string;
}

export interface GetRulesetsRulesetRuleActionParameterMatchedData {
    publicKey: string;
}

export interface GetRulesetsRulesetRuleActionParameterOrigin {
    host: string;
    port: number;
}

export interface GetRulesetsRulesetRuleActionParameterOverride {
    action: string;
    categories: outputs.GetRulesetsRulesetRuleActionParameterOverrideCategory[];
    enabled: boolean;
    rules: outputs.GetRulesetsRulesetRuleActionParameterOverrideRule[];
    sensitivityLevel: string;
    status: string;
}

export interface GetRulesetsRulesetRuleActionParameterOverrideCategory {
    action: string;
    category: string;
    enabled: boolean;
    status: string;
}

export interface GetRulesetsRulesetRuleActionParameterOverrideRule {
    action: string;
    enabled: boolean;
    id: string;
    scoreThreshold: number;
    sensitivityLevel: string;
    status: string;
}

export interface GetRulesetsRulesetRuleActionParameterResponse {
    content: string;
    contentType: string;
    statusCode: number;
}

export interface GetRulesetsRulesetRuleActionParameterServeStale {
    disableStaleWhileUpdating: boolean;
}

export interface GetRulesetsRulesetRuleActionParameterSni {
    value: string;
}

export interface GetRulesetsRulesetRuleActionParameterUri {
    origin: boolean;
    paths: outputs.GetRulesetsRulesetRuleActionParameterUriPath[];
    queries: outputs.GetRulesetsRulesetRuleActionParameterUriQuery[];
}

export interface GetRulesetsRulesetRuleActionParameterUriPath {
    expression: string;
    value: string;
}

export interface GetRulesetsRulesetRuleActionParameterUriQuery {
    expression: string;
    value: string;
}

export interface GetRulesetsRulesetRuleExposedCredentialCheck {
    passwordExpression: string;
    usernameExpression: string;
}

export interface GetRulesetsRulesetRuleLogging {
    enabled: boolean;
    status: string;
}

export interface GetRulesetsRulesetRuleRatelimit {
    characteristics: string[];
    countingExpression: string;
    mitigationTimeout: number;
    period: number;
    requestsPerPeriod: number;
    requestsToOrigin: boolean;
    scorePerPeriod: number;
    scoreResponseHeaderName: string;
}

export interface GetZonesFilter {
    /**
     * The account identifier to target for the resource.
     */
    accountId?: string;
    /**
     * The type of search to perform for the `name` value when querying the zone API. Available values: `contains`, `exact`. Defaults to `exact`.
     */
    lookupType?: string;
    /**
     * A RE2 compatible regular expression to filter the	results. This is performed client side whereas the `name` and `lookup_type`	are performed on the Cloudflare server side.
     */
    match?: string;
    /**
     * A string value to search for.
     */
    name?: string;
    /**
     * Paused status of the zone to lookup. Defaults to `false`.
     */
    paused?: boolean;
    /**
     * Status of the zone to lookup.
     */
    status?: string;
}

export interface GetZonesZone {
    id: string;
    name: string;
}

export interface HealthcheckHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of string values for the header.
     */
    values: string[];
}

export interface HealthcheckTimeouts {
    create?: string;
}

export interface HyperdriveConfigCaching {
    /**
     * Disable caching for this Hyperdrive configuration.
     */
    disabled: boolean;
    /**
     * Configure the `max_age` value of this Hyperdrive configuration.
     */
    maxAge?: number;
    /**
     * Disable caching for this Hyperdrive configuration.
     */
    staleWhileRevalidate?: number;
}

export interface HyperdriveConfigOrigin {
    /**
     * Client ID associated with the Cloudflare Access Service Token used to connect via Access.
     */
    accessClientId?: string;
    /**
     * Client Secret associated with the Cloudflare Access Service Token used to connect via Access.
     */
    accessClientSecret?: string;
    /**
     * The name of your origin database.
     */
    database: string;
    /**
     * The host (hostname or IP) of your origin database.
     */
    host: string;
    /**
     * The password of the Hyperdrive configuration.
     */
    password: string;
    /**
     * The port (default: 5432 for Postgres) of your origin database.
     */
    port?: number;
    /**
     * Specifies the URL scheme used to connect to your origin database.
     */
    scheme: string;
    /**
     * The user of your origin database.
     */
    user: string;
}

export interface ListItem {
    /**
     * An optional comment for the item.
     */
    comment?: string;
    value: outputs.ListItemValue;
}

export interface ListItemHostname {
    /**
     * The FQDN to match on.
     */
    urlHostname: string;
}

export interface ListItemRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url.
     */
    includeSubdomains?: boolean;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preservePathSuffix?: boolean;
    /**
     * Whether the redirect target url should keep the query string of the request's url.
     */
    preserveQueryString?: boolean;
    /**
     * The source url of the redirect.
     */
    sourceUrl: string;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: number;
    /**
     * Whether the redirect also matches subpaths of the source url.
     */
    subpathMatching?: boolean;
    /**
     * The target url of the redirect.
     */
    targetUrl: string;
}

export interface ListItemValue {
    asn?: number;
    hostnames?: outputs.ListItemValueHostname[];
    ip?: string;
    redirects?: outputs.ListItemValueRedirect[];
}

export interface ListItemValueHostname {
    /**
     * The FQDN to match on. Wildcard sub-domain matching is allowed. Eg. *.abc.com.
     */
    urlHostname: string;
}

export interface ListItemValueRedirect {
    /**
     * Whether the redirect also matches subdomains of the source url. Available values: `disabled`, `enabled`.
     */
    includeSubdomains?: string;
    /**
     * Whether to preserve the path suffix when doing subpath matching. Available values: `disabled`, `enabled`.
     */
    preservePathSuffix?: string;
    /**
     * Whether the redirect target url should keep the query string of the request's url. Available values: `disabled`, `enabled`.
     */
    preserveQueryString?: string;
    /**
     * The source url of the redirect.
     */
    sourceUrl: string;
    /**
     * The status code to be used when redirecting a request.
     */
    statusCode?: number;
    /**
     * Whether the redirect also matches subpaths of the source url. Available values: `disabled`, `enabled`.
     */
    subpathMatching?: string;
    /**
     * The target url of the redirect.
     */
    targetUrl: string;
}

export interface LoadBalancerAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool. Defaults to `false`.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`. Defaults to `pop`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`. Defaults to `proximity`.
     */
    preferEcs?: string;
}

export interface LoadBalancerMonitorHeader {
    /**
     * The header name.
     */
    header: string;
    /**
     * A list of values for the header.
     */
    values: string[];
}

export interface LoadBalancerPoolLoadShedding {
    /**
     * Percent of traffic to shed 0 - 100. Defaults to `0`.
     */
    defaultPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`, `random`. Defaults to `""`.
     */
    defaultPolicy?: string;
    /**
     * Percent of session traffic to shed 0 - 100. Defaults to `0`.
     */
    sessionPercent?: number;
    /**
     * Method of shedding traffic. Available values: `""`, `hash`. Defaults to `""`.
     */
    sessionPolicy?: string;
}

export interface LoadBalancerPoolOrigin {
    /**
     * The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname.
     */
    address: string;
    /**
     * Whether this origin is enabled. Disabled origins will not receive traffic and are excluded from health checks. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * HTTP request headers.
     */
    headers?: outputs.LoadBalancerPoolOriginHeader[];
    /**
     * A human-identifiable name for the origin.
     */
    name: string;
    /**
     * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
     */
    virtualNetworkId?: string;
    /**
     * The weight (0.01 - 1.00) of this origin, relative to other origins in the pool. Equal values mean equal weighting. A weight of 0 means traffic will not be sent to this origin, but health is still checked. When `origin_steering.policy="least_outstanding_requests"`, weight is used to scale the origin's outstanding requests. When `origin_steering.policy="least_connections"`, weight is used to scale the origin's open connections. Defaults to `1`.
     */
    weight?: number;
}

export interface LoadBalancerPoolOriginHeader {
    /**
     * HTTP Header name.
     */
    header: string;
    /**
     * Values for the HTTP headers.
     */
    values: string[];
}

export interface LoadBalancerPoolOriginSteering {
    /**
     * Origin steering policy to be used. Value `random` selects an origin randomly. Value `hash` selects an origin by computing a hash over the CF-Connecting-IP address. Value `least_outstanding_requests` selects an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Available values: `""`, `hash`, `random`, `least_outstanding_requests`, `least_connections`. Defaults to `random`.
     */
    policy?: string;
}

export interface LoadBalancerPopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRule {
    /**
     * The statement to evaluate to determine if this rule's effects should be applied. An empty condition is always true. See [load balancing rules](https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules).
     */
    condition?: string;
    /**
     * A disabled rule will not be executed.
     */
    disabled?: boolean;
    /**
     * Settings for a HTTP response to return directly to the eyeball if the condition is true. Note: `overrides` or `fixed_response` must be set.
     */
    fixedResponse?: outputs.LoadBalancerRuleFixedResponse;
    /**
     * Human readable name for this rule.
     */
    name: string;
    /**
     * The load balancer settings to alter if this rule's `condition` is true. Note: `overrides` or `fixed_response` must be set.
     */
    overrides?: outputs.LoadBalancerRuleOverride[];
    /**
     * Priority used when determining the order of rule execution. Lower values are executed first. If not provided, the list order will be used.
     */
    priority: number;
    /**
     * Terminates indicates that if this rule is true no further rules should be executed. Note: setting a `fixed_response` forces this field to `true`.
     */
    terminates: boolean;
}

export interface LoadBalancerRuleFixedResponse {
    /**
     * The value of the HTTP context-type header for this fixed response.
     */
    contentType?: string;
    /**
     * The value of the HTTP location header for this fixed response.
     */
    location?: string;
    /**
     * The text used as the html body for this fixed response.
     */
    messageBody?: string;
    /**
     * The HTTP status code used for this fixed response.
     */
    statusCode?: number;
}

export interface LoadBalancerRuleOverride {
    /**
     * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests.
     */
    adaptiveRoutings?: outputs.LoadBalancerRuleOverrideAdaptiveRouting[];
    /**
     * A set containing mappings of country codes to a list of pool IDs (ordered by their failover priority) for the given country.
     */
    countryPools?: outputs.LoadBalancerRuleOverrideCountryPool[];
    /**
     * A list of pool IDs ordered by their failover priority. Used whenever `pop_pools`/`country_pools`/`region_pools` are not defined.
     */
    defaultPools?: string[];
    /**
     * The pool ID to use when all other pools are detected as unhealthy.
     */
    fallbackPool?: string;
    /**
     * Controls location-based steering for non-proxied requests.
     */
    locationStrategies?: outputs.LoadBalancerRuleOverrideLocationStrategy[];
    /**
     * A set containing mappings of Cloudflare Point-of-Presence (PoP) identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). This feature is only available to enterprise customers.
     */
    popPools?: outputs.LoadBalancerRuleOverridePopPool[];
    /**
     * Configures pool weights. When `steering_policy="random"`, a random pool is selected with probability proportional to pool weights. When `steering_policy="least_outstanding_requests"`, pool weights are used to scale each pool's outstanding requests. When `steering_policy="least_connections"`, pool weights are used to scale each pool's open connections.
     */
    randomSteerings?: outputs.LoadBalancerRuleOverrideRandomSteering[];
    /**
     * A set containing mappings of region codes to a list of pool IDs (ordered by their failover priority) for the given region.
     */
    regionPools?: outputs.LoadBalancerRuleOverrideRegionPool[];
    /**
     * Configure attributes for session affinity.
     */
    sessionAffinity?: string;
    /**
     * Configure attributes for session affinity. Note that the property `drain_duration` is not currently supported as a rule override.
     */
    sessionAffinityAttributes?: outputs.LoadBalancerRuleOverrideSessionAffinityAttribute[];
    /**
     * Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of `82800` (23 hours) will be used unless `session_affinity_ttl` is explicitly set. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. Valid values are between `1800` and `604800`.
     */
    sessionAffinityTtl?: number;
    /**
     * The method the load balancer uses to determine the route to your origin. Value `off` uses `default_pool_ids`. Value `geo` uses `pop_pools`/`country_pools`/`region_pools`. For non-proxied requests, the `country` for `country_pools` is determined by `location_strategy`. Value `random` selects a pool randomly. Value `dynamic_latency` uses round trip time to select the closest pool in `default_pool_ids` (requires pool health checks). Value `proximity` uses the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests. Value `least_outstanding_requests` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others. Value `least_connections` selects a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections. Value `""` maps to `geo` if you use `pop_pools`/`country_pools`/`region_pools` otherwise `off`. Available values: `off`, `geo`, `dynamic_latency`, `random`, `proximity`, `least_outstanding_requests`, `least_connections`, `""` Defaults to `""`.
     */
    steeringPolicy?: string;
    /**
     * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This cannot be set for proxied load balancers. Defaults to `30`.
     */
    ttl?: number;
}

export interface LoadBalancerRuleOverrideAdaptiveRouting {
    /**
     * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set `false`, zero-downtime failover will only occur between origins within the same pool.
     */
    failoverAcrossPools?: boolean;
}

export interface LoadBalancerRuleOverrideCountryPool {
    /**
     * A country code which can be determined with the Load Balancing Regions API described [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/). Multiple entries should not be specified with the same country.
     */
    country: string;
    /**
     * A list of pool IDs in failover priority to use in the given country.
     */
    poolIds: string[];
}

export interface LoadBalancerRuleOverrideLocationStrategy {
    /**
     * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful. Value `pop` will use the Cloudflare PoP location. Value `resolver_ip` will use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, it will use the Cloudflare PoP location. Available values: `pop`, `resolver_ip`.
     */
    mode?: string;
    /**
     * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location. Value `always` will always prefer ECS, `never` will never prefer ECS, `proximity` will prefer ECS only when `steering_policy="proximity"`, and `geo` will prefer ECS only when `steering_policy="geo"`. Available values: `always`, `never`, `proximity`, `geo`.
     */
    preferEcs?: string;
}

export interface LoadBalancerRuleOverridePopPool {
    /**
     * A list of pool IDs in failover priority to use for traffic reaching the given PoP.
     */
    poolIds: string[];
    /**
     * A 3-letter code for the Point-of-Presence. Allowed values can be found in the list of datacenters on the [status page](https://www.cloudflarestatus.com/). Multiple entries should not be specified with the same PoP.
     */
    pop: string;
}

export interface LoadBalancerRuleOverrideRandomSteering {
    /**
     * The default weight for pools in the load balancer that are not specified in the `pool_weights` map.
     */
    defaultWeight?: number;
    /**
     * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
     */
    poolWeights?: {[key: string]: number};
}

export interface LoadBalancerRuleOverrideRegionPool {
    /**
     * A list of pool IDs in failover priority to use in the given region.
     */
    poolIds: string[];
    /**
     * A region code which must be in the list defined [here](https://developers.cloudflare.com/load-balancing/reference/region-mapping-api/#list-of-load-balancer-regions). Multiple entries should not be specified with the same region.
     */
    region: string;
}

export interface LoadBalancerRuleOverrideSessionAffinityAttribute {
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: string[];
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`.
     */
    zeroDowntimeFailover?: string;
}

export interface LoadBalancerSessionAffinityAttribute {
    /**
     * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer. Defaults to `0`.
     */
    drainDuration?: number;
    /**
     * Configures the HTTP header names to use when header session affinity is enabled.
     */
    headers?: string[];
    /**
     * Configures how headers are used when header session affinity is enabled. Set to true to require all headers to be present on requests in order for sessions to be created or false to require at least one header to be present. Defaults to `false`.
     */
    requireAllHeaders?: boolean;
    /**
     * Configures the SameSite attribute on session affinity cookie. Value `Auto` will be translated to `Lax` or `None` depending if Always Use HTTPS is enabled. Note: when using value `None`, then you can not set `secure="Never"`. Available values: `Auto`, `Lax`, `None`, `Strict`. Defaults to `Auto`.
     */
    samesite?: string;
    /**
     * Configures the Secure attribute on session affinity cookie. Value `Always` indicates the Secure attribute will be set in the Set-Cookie header, `Never` indicates the Secure attribute will not be set, and `Auto` will set the Secure attribute depending if Always Use HTTPS is enabled. Available values: `Auto`, `Always`, `Never`. Defaults to `Auto`.
     */
    secure?: string;
    /**
     * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value `none` means no failover takes place for sessions pinned to the origin. Value `temporary` means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value `sticky` means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. Available values: `none`, `temporary`, `sticky`. Defaults to `none`.
     */
    zeroDowntimeFailover?: string;
}

export interface LogpushJobOutputOptions {
    /**
     * String to be prepended before each batch.
     */
    batchPrefix?: string;
    /**
     * String to be appended after each batch.
     */
    batchSuffix?: string;
    /**
     * Mitigation for CVE-2021-44228. If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{. Defaults to `false`.
     */
    cve20214428?: boolean;
    /**
     * String to join fields. This field be ignored when record_template is set. Defaults to `,`.
     */
    fieldDelimiter?: string;
    /**
     * List of field names to be included in the Logpush output.
     */
    fieldNames?: string[];
    /**
     * Specifies the output type. Available values: `ndjson`, `csv`. Defaults to `ndjson`.
     */
    outputType?: string;
    /**
     * String to be inserted in-between the records as separator.
     */
    recordDelimiter?: string;
    /**
     * String to be prepended before each record. Defaults to `{`.
     */
    recordPrefix?: string;
    /**
     * String to be appended after each record. Defaults to `}
     * `.
     */
    recordSuffix?: string;
    /**
     * String to use as template for each record instead of the default comma-separated list.
     */
    recordTemplate?: string;
    /**
     * Specifies the sampling rate. Defaults to `1`.
     */
    sampleRate?: number;
    /**
     * Specifies the format for timestamps. Available values: `unixnano`, `unix`, `rfc3339`. Defaults to `unixnano`.
     */
    timestampFormat?: string;
}

export interface ManagedHeadersManagedRequestHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface ManagedHeadersManagedResponseHeader {
    /**
     * Whether the headers rule is active.
     */
    enabled: boolean;
    /**
     * Unique headers rule identifier.
     */
    id: string;
}

export interface NotificationPolicyEmailIntegration {
    id: string;
    name?: string;
}

export interface NotificationPolicyFilters {
    /**
     * Targeted actions for alert.
     */
    actions?: string[];
    /**
     * Affected components for alert. Available values: `API`, `API Shield`, `Access`, `Always Online`, `Analytics`, `Apps Marketplace`, `Argo Smart Routing`, `Audit Logs`, `Authoritative DNS`, `Billing`, `Bot Management`, `Bring Your Own IP (BYOIP)`, `Browser Isolation`, `CDN Cache Purge`, `CDN/Cache`, `Cache Reserve`, `Challenge Platform`, `Cloud Access Security Broker (CASB)`, `Community Site`, `DNS Root Servers`, `DNS Updates`, `Dashboard`, `Data Loss Prevention (DLP)`, `Developer's Site`, `Digital Experience Monitoring (DEX)`, `Distributed Web Gateway`, `Durable Objects`, `Email Routing`, `Ethereum Gateway`, `Firewall`, `Gateway`, `Geo-Key Manager`, `Image Resizing`, `Images`, `Infrastructure`, `Lists`, `Load Balancing and Monitoring`, `Logs`, `Magic Firewall`, `Magic Transit`, `Magic WAN`, `Magic WAN Connector`, `Marketing Site`, `Mirage`, `Network`, `Notifications`, `Observatory`, `Page Shield`, `Pages`, `R2`, `Radar`, `Randomness Beacon`, `Recursive DNS`, `Registrar`, `Registration Data Access Protocol (RDAP)`, `SSL Certificate Provisioning`, `SSL for SaaS Provisioning`, `Security Center`, `Snippets`, `Spectrum`, `Speed Optimizations`, `Stream`, `Support Site`, `Time Services`, `Trace`, `Tunnel`, `Turnstile`, `WARP`, `Waiting Room`, `Web Analytics`, `Workers`, `Workers KV`, `Workers Preview`, `Zaraz`, `Zero Trust`, `Zero Trust Dashboard`, `Zone Versioning`.
     */
    affectedComponents?: string[];
    /**
     * Filter on Points of Presence.
     */
    airportCodes?: string[];
    /**
     * Alert trigger preferences. Example: `slo`.
     */
    alertTriggerPreferences?: string[];
    /**
     * State of the pool to alert on.
     */
    enableds?: string[];
    /**
     * Environment of pages. Available values: `ENVIRONMENT_PREVIEW`, `ENVIRONMENT_PRODUCTION`.
     */
    environments?: string[];
    /**
     * Source configuration to alert on for pool or origin.
     */
    eventSources?: string[];
    /**
     * Stream event type to alert on.
     */
    eventTypes?: string[];
    /**
     * Pages event to alert. Available values: `EVENT_DEPLOYMENT_STARTED`, `EVENT_DEPLOYMENT_FAILED`, `EVENT_DEPLOYMENT_SUCCESS`.
     */
    events?: string[];
    /**
     * Alert grouping.
     */
    groupBies?: string[];
    /**
     * Identifier health check. Required when using `filters.0.status`.
     */
    healthCheckIds?: string[];
    /**
     * The incident impact level that will trigger the dispatch of a notification. Available values: `INCIDENT_IMPACT_NONE`, `INCIDENT_IMPACT_MINOR`, `INCIDENT_IMPACT_MAJOR`, `INCIDENT_IMPACT_CRITICAL`.
     */
    incidentImpacts?: string[];
    /**
     * Stream input id to alert on.
     */
    inputIds?: string[];
    /**
     * A numerical limit. Example: `100`.
     */
    limits?: string[];
    /**
     * Megabits per second threshold for dos alert.
     */
    megabitsPerSeconds?: string[];
    /**
     * Health status to alert on for pool or origin.
     */
    newHealths?: string[];
    /**
     * Tunnel health status to alert on.
     */
    newStatuses?: string[];
    /**
     * Packets per second threshold for dos alert.
     */
    packetsPerSeconds?: string[];
    /**
     * Load balancer pool identifier.
     */
    poolIds?: string[];
    /**
     * Product name. Available values: `worker_requests`, `worker_durable_objects_requests`, `worker_durable_objects_duration`, `worker_durable_objects_data_transfer`, `worker_durable_objects_stored_data`, `worker_durable_objects_storage_deletes`, `worker_durable_objects_storage_writes`, `worker_durable_objects_storage_reads`.
     */
    products?: string[];
    /**
     * Identifier of pages project.
     */
    projectIds?: string[];
    /**
     * Protocol to alert on for dos.
     */
    protocols?: string[];
    /**
     * Requests per second threshold for dos alert.
     */
    requestsPerSeconds?: string[];
    /**
     * Selectors for alert. Valid options depend on the alert type.
     */
    selectors?: string[];
    services?: string[];
    /**
     * A numerical limit. Example: `99.9`.
     */
    slos?: string[];
    /**
     * Status to alert on.
     */
    statuses?: string[];
    /**
     * Target host to alert on for dos.
     */
    targetHostnames?: string[];
    /**
     * Target ip to alert on for dos in CIDR notation.
     */
    targetIps?: string[];
    /**
     * Target domain to alert on.
     */
    targetZoneNames?: string[];
    /**
     * Tunnel IDs to alert on.
     */
    tunnelIds?: string[];
    /**
     * Tunnel Names to alert on.
     */
    tunnelNames?: string[];
    /**
     * Filter for alert.
     */
    wheres?: string[];
    /**
     * A list of zone identifiers.
     */
    zones?: string[];
}

export interface NotificationPolicyPagerdutyIntegration {
    id: string;
    name?: string;
}

export interface NotificationPolicyWebhooksIntegration {
    id: string;
    name?: string;
}

export interface ObservatoryScheduledTestTimeouts {
    create?: string;
}

export interface PageRuleActions {
    /**
     * Defaults to `false`.
     */
    alwaysUseHttps?: boolean;
    automaticHttpsRewrites?: string;
    browserCacheTtl?: string;
    browserCheck?: string;
    bypassCacheOnCookie?: string;
    cacheByDeviceType?: string;
    cacheDeceptionArmor?: string;
    cacheKeyFields?: outputs.PageRuleActionsCacheKeyFields;
    cacheLevel?: string;
    cacheOnCookie?: string;
    cacheTtlByStatuses?: outputs.PageRuleActionsCacheTtlByStatus[];
    /**
     * Defaults to `false`.
     */
    disableApps?: boolean;
    /**
     * Defaults to `false`.
     */
    disablePerformance?: boolean;
    /**
     * Defaults to `false`.
     */
    disableRailgun?: boolean;
    /**
     * Defaults to `false`.
     */
    disableSecurity?: boolean;
    /**
     * Defaults to `false`.
     */
    disableZaraz?: boolean;
    edgeCacheTtl?: number;
    emailObfuscation?: string;
    explicitCacheControl?: string;
    forwardingUrl?: outputs.PageRuleActionsForwardingUrl;
    hostHeaderOverride?: string;
    ipGeolocation?: string;
    minifies?: outputs.PageRuleActionsMinify[];
    mirage?: string;
    opportunisticEncryption?: string;
    originErrorPagePassThru?: string;
    polish?: string;
    resolveOverride?: string;
    respectStrongEtag?: string;
    responseBuffering?: string;
    rocketLoader?: string;
    securityLevel?: string;
    serverSideExclude?: string;
    sortQueryStringForCache?: string;
    ssl?: string;
    trueClientIpHeader?: string;
    waf?: string;
}

export interface PageRuleActionsCacheKeyFields {
    cookie?: outputs.PageRuleActionsCacheKeyFieldsCookie;
    header?: outputs.PageRuleActionsCacheKeyFieldsHeader;
    host: outputs.PageRuleActionsCacheKeyFieldsHost;
    queryString: outputs.PageRuleActionsCacheKeyFieldsQueryString;
    user: outputs.PageRuleActionsCacheKeyFieldsUser;
}

export interface PageRuleActionsCacheKeyFieldsCookie {
    checkPresences: string[];
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHeader {
    checkPresences: string[];
    excludes: string[];
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsHost {
    /**
     * Defaults to `false`.
     */
    resolved?: boolean;
}

export interface PageRuleActionsCacheKeyFieldsQueryString {
    excludes: string[];
    ignore: boolean;
    includes: string[];
}

export interface PageRuleActionsCacheKeyFieldsUser {
    deviceType: boolean;
    geo: boolean;
    lang: boolean;
}

export interface PageRuleActionsCacheTtlByStatus {
    codes: string;
    ttl: number;
}

export interface PageRuleActionsForwardingUrl {
    statusCode: number;
    url: string;
}

export interface PageRuleActionsMinify {
    css: string;
    html: string;
    js: string;
}

export interface PagesProjectBuildConfig {
    /**
     * Enable build caching for the project.
     */
    buildCaching?: boolean;
    /**
     * Command used to build project.
     */
    buildCommand?: string;
    /**
     * Output directory of the build.
     */
    destinationDir?: string;
    /**
     * Your project's root directory, where Cloudflare runs the build command. If your site is not in a subdirectory, leave this path value empty.
     */
    rootDir?: string;
    /**
     * The classifying tag for analytics.
     */
    webAnalyticsTag?: string;
    /**
     * The auth token for analytics.
     */
    webAnalyticsToken?: string;
}

export interface PagesProjectDeploymentConfigs {
    /**
     * Configuration for preview deploys.
     */
    preview?: outputs.PagesProjectDeploymentConfigsPreview;
    /**
     * Configuration for production deploys.
     */
    production?: outputs.PagesProjectDeploymentConfigsProduction;
}

export interface PagesProjectDeploymentConfigsPreview {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: boolean;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: {[key: string]: string};
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: {[key: string]: string};
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: {[key: string]: string};
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: boolean;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: {[key: string]: string};
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement?: outputs.PagesProjectDeploymentConfigsPreviewPlacement;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: {[key: string]: string};
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: {[key: string]: string};
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: outputs.PagesProjectDeploymentConfigsPreviewServiceBinding[];
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsPreviewPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode: string;
}

export interface PagesProjectDeploymentConfigsPreviewServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface PagesProjectDeploymentConfigsProduction {
    /**
     * Use latest compatibility date for Pages Functions. Defaults to `false`.
     */
    alwaysUseLatestCompatibilityDate?: boolean;
    /**
     * Compatibility date used for Pages Functions.
     */
    compatibilityDate: string;
    /**
     * Compatibility flags used for Pages Functions.
     */
    compatibilityFlags: string[];
    /**
     * D1 Databases used for Pages Functions. Defaults to `map[]`.
     */
    d1Databases?: {[key: string]: string};
    /**
     * Durable Object namespaces used for Pages Functions. Defaults to `map[]`.
     */
    durableObjectNamespaces?: {[key: string]: string};
    /**
     * Environment variables for Pages Functions. Defaults to `map[]`.
     */
    environmentVariables?: {[key: string]: string};
    /**
     * Fail open used for Pages Functions. Defaults to `false`.
     */
    failOpen?: boolean;
    /**
     * KV namespaces used for Pages Functions. Defaults to `map[]`.
     */
    kvNamespaces?: {[key: string]: string};
    /**
     * Configuration for placement in the Cloudflare Pages project.
     */
    placement?: outputs.PagesProjectDeploymentConfigsProductionPlacement;
    /**
     * R2 Buckets used for Pages Functions. Defaults to `map[]`.
     */
    r2Buckets?: {[key: string]: string};
    /**
     * Encrypted environment variables for Pages Functions. Defaults to `map[]`.
     */
    secrets?: {[key: string]: string};
    /**
     * Services used for Pages Functions.
     */
    serviceBindings?: outputs.PagesProjectDeploymentConfigsProductionServiceBinding[];
    /**
     * Usage model used for Pages Functions. Available values: `unbound`, `bundled`, `standard`. Defaults to `bundled`.
     */
    usageModel?: string;
}

export interface PagesProjectDeploymentConfigsProductionPlacement {
    /**
     * Placement Mode for the Pages Function.
     */
    mode: string;
}

export interface PagesProjectDeploymentConfigsProductionServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface PagesProjectSource {
    /**
     * Configuration for the source of the Cloudflare Pages project.
     */
    config?: outputs.PagesProjectSourceConfig;
    /**
     * Project host type.
     */
    type?: string;
}

export interface PagesProjectSourceConfig {
    /**
     * Toggle deployments on this repo. Defaults to `true`.
     */
    deploymentsEnabled?: boolean;
    /**
     * Project owner username. **Modifying this attribute will force creation of a new resource.**
     */
    owner?: string;
    /**
     * Enable Pages to comment on Pull Requests. Defaults to `true`.
     */
    prCommentsEnabled?: boolean;
    /**
     * Branches will be excluded from automatic deployment.
     */
    previewBranchExcludes: string[];
    /**
     * Branches will be included for automatic deployment.
     */
    previewBranchIncludes: string[];
    /**
     * Preview Deployment Setting. Available values: `custom`, `all`, `none`. Defaults to `all`.
     */
    previewDeploymentSetting?: string;
    /**
     * Project production branch name.
     */
    productionBranch: string;
    /**
     * Enable production deployments. Defaults to `true`.
     */
    productionDeploymentEnabled?: boolean;
    /**
     * Project repository name. **Modifying this attribute will force creation of a new resource.**
     */
    repoName?: string;
}

export interface RateLimitAction {
    /**
     * The type of action to perform. Available values: `simulate`, `ban`, `challenge`, `js_challenge`, `managed_challenge`.
     */
    mode: string;
    /**
     * Custom content-type and body to return, this overrides the custom error for the zone. This field is not required. Omission will result in default HTML error page.
     */
    response?: outputs.RateLimitActionResponse;
    /**
     * The time in seconds as an integer to perform the mitigation action. This field is required if the `mode` is either `simulate` or `ban`. Must be the same or greater than the period.
     */
    timeout?: number;
}

export interface RateLimitActionResponse {
    /**
     * The body to return, the content here should conform to the `content_type`.
     */
    body: string;
    /**
     * The content-type of the body. Available values: `text/plain`, `text/xml`, `application/json`.
     */
    contentType: string;
}

export interface RateLimitCorrelate {
    /**
     * If set to 'nat', NAT support will be enabled for rate limiting. Available values: `nat`.
     */
    by?: string;
}

export interface RateLimitMatch {
    /**
     * Matches HTTP requests (from the client to Cloudflare).
     */
    request?: outputs.RateLimitMatchRequest;
    /**
     * Matches HTTP responses before they are returned to the client from Cloudflare. If this is defined, then the entire counting of traffic occurs at this stage.
     */
    response?: outputs.RateLimitMatchResponse;
}

export interface RateLimitMatchRequest {
    /**
     * HTTP Methods to match traffic on. Available values: `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `_ALL_`.
     */
    methods: string[];
    /**
     * HTTP schemes to match traffic on. Available values: `HTTP`, `HTTPS`, `_ALL_`.
     */
    schemes: string[];
    /**
     * The URL pattern to match comprised of the host and path, i.e. example.org/path. Wildcard are expanded to match applicable traffic, query strings are not matched. Use _ for all traffic to your zone.
     */
    urlPattern: string;
}

export interface RateLimitMatchResponse {
    /**
     * List of HTTP headers maps to match the origin response on.
     */
    headers?: {[key: string]: string}[];
    /**
     * Only count traffic that has come from your origin servers. If true, cached items that Cloudflare serve will not count towards rate limiting.
     */
    originTraffic: boolean;
    /**
     * HTTP Status codes, can be one, many or indicate all by not providing this value.
     */
    statuses: number[];
}

export interface RecordData {
    algorithm?: number;
    altitude?: number;
    certificate?: string;
    content?: string;
    digest?: string;
    digestType?: number;
    fingerprint?: string;
    flags?: string;
    keyTag?: number;
    latDegrees?: number;
    latDirection?: string;
    latMinutes?: number;
    latSeconds?: number;
    longDegrees?: number;
    longDirection?: string;
    longMinutes?: number;
    longSeconds?: number;
    matchingType?: number;
    name?: string;
    order?: number;
    port?: number;
    precisionHorz?: number;
    precisionVert?: number;
    preference?: number;
    priority?: number;
    proto?: string;
    protocol?: number;
    publicKey?: string;
    regex?: string;
    replacement?: string;
    selector?: number;
    service?: string;
    size?: number;
    tag?: string;
    target?: string;
    type?: number;
    usage?: number;
    value?: string;
    weight?: number;
}

export interface RecordTimeouts {
    create?: string;
    update?: string;
}

export interface RegionalHostnameTimeouts {
    create?: string;
    update?: string;
}

export interface RiskBehaviorBehavior {
    /**
     * Whether this risk behavior type is enabled.
     */
    enabled: boolean;
    /**
     * Name of this risk behavior type
     */
    name: string;
    /**
     * Risk level. Available values: `low`, `medium`, `high`
     */
    riskLevel: string;
}

export interface RulesetRule {
    /**
     * Action to perform in the ruleset rule. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
     */
    action?: string;
    /**
     * List of parameters that configure the behavior of the ruleset rule action.
     */
    actionParameters?: outputs.RulesetRuleActionParameter[];
    /**
     * Brief summary of the ruleset rule and its intended use.
     */
    description: string;
    /**
     * Whether the rule is active.
     */
    enabled: boolean;
    /**
     * List of parameters that configure exposed credential checks.
     */
    exposedCredentialChecks?: outputs.RulesetRuleExposedCredentialCheck[];
    /**
     * Criteria for an HTTP request to trigger the ruleset rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * The most recent update to this rule.
     */
    lastUpdated: string;
    /**
     * List parameters to configure how the rule generates logs. Only valid for skip action.
     */
    loggings?: outputs.RulesetRuleLogging[];
    /**
     * List of parameters that configure HTTP rate limiting behaviour.
     */
    ratelimits?: outputs.RulesetRuleRatelimit[];
    /**
     * Rule reference.
     */
    ref: string;
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParameter {
    /**
     * Specifies uncommon ports to allow cacheable assets to be served from.
     */
    additionalCacheablePorts?: number[];
    /**
     * Compression algorithms to use in order of preference.
     */
    algorithms?: outputs.RulesetRuleActionParameterAlgorithm[];
    /**
     * Turn on or off Cloudflare Automatic HTTPS rewrites.
     */
    automaticHttpsRewrites?: boolean;
    /**
     * Indicate which file extensions to minify automatically.
     */
    autominifies?: outputs.RulesetRuleActionParameterAutominify[];
    /**
     * Inspect the visitor's browser for headers commonly associated with spammers and certain bots.
     */
    bic?: boolean;
    /**
     * List of browser TTL parameters to apply to the request.
     */
    browserTtls?: outputs.RulesetRuleActionParameterBrowserTtl[];
    /**
     * Whether to cache if expression matches.
     */
    cache?: boolean;
    /**
     * List of cache key parameters to apply to the request.
     */
    cacheKeys?: outputs.RulesetRuleActionParameterCacheKey[];
    /**
     * Content of the custom error response.
     */
    content?: string;
    /**
     * Content-Type of the custom error response.
     */
    contentType?: string;
    /**
     * List of cookie values to include as part of custom fields logging.
     */
    cookieFields?: string[];
    /**
     * Turn off all active Cloudflare Apps.
     */
    disableApps?: boolean;
    /**
     * Turn off railgun feature of the Cloudflare Speed app.
     */
    disableRailgun?: boolean;
    /**
     * Turn off RUM feature.
     */
    disableRum?: boolean;
    /**
     * Turn off zaraz feature.
     */
    disableZaraz?: boolean;
    /**
     * List of edge TTL parameters to apply to the request.
     */
    edgeTtls?: outputs.RulesetRuleActionParameterEdgeTtl[];
    /**
     * Turn on or off the Cloudflare Email Obfuscation feature of the Cloudflare Scrape Shield app.
     */
    emailObfuscation?: boolean;
    /**
     * Toggle fonts.
     */
    fonts?: boolean;
    /**
     * Use a list to lookup information for the action.
     */
    fromLists?: outputs.RulesetRuleActionParameterFromList[];
    /**
     * Use a value to lookup information for the action.
     */
    fromValues?: outputs.RulesetRuleActionParameterFromValue[];
    /**
     * List of HTTP header modifications to perform in the ruleset rule. Note: Headers are order dependent and must be provided sorted alphabetically ascending based on the `name` value.
     */
    headers?: outputs.RulesetRuleActionParameterHeader[];
    /**
     * Host Header that request origin receives.
     */
    hostHeader?: string;
    /**
     * Turn on or off the hotlink protection feature.
     */
    hotlinkProtection?: boolean;
    /**
     * Identifier of the action parameter to modify.
     */
    id?: string;
    increment?: number;
    /**
     * List of properties to configure WAF payload logging.
     */
    matchedDatas?: outputs.RulesetRuleActionParameterMatchedData[];
    /**
     * Turn on or off Cloudflare Mirage of the Cloudflare Speed app.
     */
    mirage?: boolean;
    /**
     * Turn on or off the Cloudflare Opportunistic Encryption feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    opportunisticEncryption?: boolean;
    /**
     * Enable or disable the use of a more compliant Cache Control parsing mechanism, enabled by default for most zones.
     */
    originCacheControl?: boolean;
    /**
     * Pass-through error page for origin.
     */
    originErrorPagePassthru?: boolean;
    /**
     * List of properties to change request origin.
     */
    origins?: outputs.RulesetRuleActionParameterOrigin[];
    /**
     * List of override configurations to apply to the ruleset.
     */
    overrides?: outputs.RulesetRuleActionParameterOverride[];
    /**
     * Point in the request/response lifecycle where the ruleset will be created. Available values: `ddos_l4`, `ddos_l7`, `http_config_settings`, `http_custom_errors`, `http_log_custom_fields`, `http_ratelimit`, `http_request_cache_settings`, `http_request_dynamic_redirect`, `http_request_firewall_custom`, `http_request_firewall_managed`, `http_request_late_transform`, `http_request_origin`, `http_request_redirect`, `http_request_sanitize`, `http_request_sbfm`, `http_request_transform`, `http_response_compression`, `http_response_firewall_managed`, `http_response_headers_transform`, `magic_transit`.
     */
    phases?: string[];
    /**
     * Apply options from the Polish feature of the Cloudflare Speed app.
     */
    polish?: string;
    /**
     * Products to target with the actions. Available values: `bic`, `hot`, `ratelimit`, `securityLevel`, `uablock`, `waf`, `zonelockdown`.
     */
    products?: string[];
    /**
     * Specifies a maximum timeout for reading content from an origin server.
     */
    readTimeout?: number;
    /**
     * List of request headers to include as part of custom fields logging, in lowercase.
     */
    requestFields?: string[];
    /**
     * Respect strong ETags.
     */
    respectStrongEtags?: boolean;
    /**
     * List of response headers to include as part of custom fields logging, in lowercase.
     */
    responseFields?: string[];
    /**
     * List of parameters that configure the response given to end users.
     */
    responses?: outputs.RulesetRuleActionParameterResponse[];
    /**
     * Turn on or off Cloudflare Rocket Loader in the Cloudflare Speed app.
     */
    rocketLoader?: boolean;
    /**
     * Map of managed WAF rule ID to comma-delimited string of ruleset rule IDs. Example: `rules = { "efb7b8c949ac4650a09736fc376e9aee" = "5de7edfa648c4d6891dc3e7f84534ffa,e3a567afc347477d9702d9047e97d760" }`.
     */
    rules?: {[key: string]: string};
    /**
     * Which ruleset ID to target.
     */
    ruleset?: string;
    /**
     * List of managed WAF rule IDs to target. Only valid when the `"action"` is set to skip.
     */
    rulesets?: string[];
    /**
     * Control options for the Security Level feature from the Security app.
     */
    securityLevel?: string;
    /**
     * List of serve stale parameters to apply to the request.
     */
    serveStales?: outputs.RulesetRuleActionParameterServeStale[];
    /**
     * Turn on or off the Server Side Excludes feature of the Cloudflare Scrape Shield app.
     */
    serverSideExcludes?: boolean;
    /**
     * List of properties to manange Server Name Indication.
     */
    snis?: outputs.RulesetRuleActionParameterSni[];
    /**
     * Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
     */
    ssl?: string;
    /**
     * HTTP status code of the custom error response.
     */
    statusCode?: number;
    /**
     * Turn on or off the SXG feature.
     */
    sxg?: boolean;
    /**
     * List of URI properties to configure for the ruleset rule when performing URL rewrite transformations.
     */
    uris?: outputs.RulesetRuleActionParameterUri[];
    /**
     * Version of the ruleset to deploy.
     */
    version: string;
}

export interface RulesetRuleActionParameterAlgorithm {
    /**
     * Name of the compression algorithm to use. Available values: `gzip`, `brotli`, `auto`, `default`, `none`
     */
    name: string;
}

export interface RulesetRuleActionParameterAutominify {
    /**
     * CSS minification.
     */
    css?: boolean;
    /**
     * HTML minification.
     */
    html?: boolean;
    /**
     * JS minification.
     */
    js?: boolean;
}

export interface RulesetRuleActionParameterBrowserTtl {
    /**
     * Default browser TTL. This value is required when override_origin is set
     */
    default?: number;
    /**
     * Mode of the browser TTL. Available values: `override_origin`, `respect_origin`, `bypass`
     */
    mode: string;
}

export interface RulesetRuleActionParameterCacheKey {
    /**
     * Cache by device type.
     */
    cacheByDeviceType?: boolean;
    /**
     * Cache deception armor.
     */
    cacheDeceptionArmor?: boolean;
    /**
     * Custom key parameters for the request.
     */
    customKeys?: outputs.RulesetRuleActionParameterCacheKeyCustomKey[];
    /**
     * Ignore query strings order.
     */
    ignoreQueryStringsOrder?: boolean;
}

export interface RulesetRuleActionParameterCacheKeyCustomKey {
    /**
     * Cookie parameters for the custom key.
     */
    cookies?: outputs.RulesetRuleActionParameterCacheKeyCustomKeyCookie[];
    /**
     * Header parameters for the custom key.
     */
    headers?: outputs.RulesetRuleActionParameterCacheKeyCustomKeyHeader[];
    /**
     * Host parameters for the custom key.
     */
    hosts?: outputs.RulesetRuleActionParameterCacheKeyCustomKeyHost[];
    /**
     * Query string parameters for the custom key.
     */
    queryStrings?: outputs.RulesetRuleActionParameterCacheKeyCustomKeyQueryString[];
    /**
     * User parameters for the custom key.
     */
    users?: outputs.RulesetRuleActionParameterCacheKeyCustomKeyUser[];
}

export interface RulesetRuleActionParameterCacheKeyCustomKeyCookie {
    /**
     * List of cookies to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * List of cookies to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParameterCacheKeyCustomKeyHeader {
    /**
     * List of headers to check for presence in the custom key.
     */
    checkPresences?: string[];
    /**
     * Exclude the origin header from the custom key.
     */
    excludeOrigin: boolean;
    /**
     * List of headers to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParameterCacheKeyCustomKeyHost {
    /**
     * Resolve hostname to IP address.
     */
    resolved?: boolean;
}

export interface RulesetRuleActionParameterCacheKeyCustomKeyQueryString {
    /**
     * List of query string parameters to exclude from the custom key.
     */
    excludes?: string[];
    /**
     * List of query string parameters to include in the custom key.
     */
    includes?: string[];
}

export interface RulesetRuleActionParameterCacheKeyCustomKeyUser {
    /**
     * Add device type to the custom key.
     */
    deviceType?: boolean;
    /**
     * Add geo data to the custom key.
     */
    geo?: boolean;
    /**
     * Add language data to the custom key.
     */
    lang?: boolean;
}

export interface RulesetRuleActionParameterEdgeTtl {
    /**
     * Default edge TTL.
     */
    default?: number;
    /**
     * Mode of the edge TTL. Available values: `override_origin`, `respect_origin`, `bypass_by_default`
     */
    mode: string;
    /**
     * Edge TTL for the status codes.
     */
    statusCodeTtls?: outputs.RulesetRuleActionParameterEdgeTtlStatusCodeTtl[];
}

export interface RulesetRuleActionParameterEdgeTtlStatusCodeTtl {
    /**
     * Status code for which the edge TTL is applied.
     */
    statusCode?: number;
    /**
     * Status code range for which the edge TTL is applied.
     */
    statusCodeRanges?: outputs.RulesetRuleActionParameterEdgeTtlStatusCodeTtlStatusCodeRange[];
    /**
     * Status code edge TTL value.
     */
    value?: number;
}

export interface RulesetRuleActionParameterEdgeTtlStatusCodeTtlStatusCodeRange {
    /**
     * From status code.
     */
    from?: number;
    /**
     * To status code.
     */
    to?: number;
}

export interface RulesetRuleActionParameterFromList {
    /**
     * Expression to use for the list lookup.
     */
    key?: string;
    /**
     * Name of the list.
     */
    name?: string;
}

export interface RulesetRuleActionParameterFromValue {
    /**
     * Preserve query string for redirect URL.
     */
    preserveQueryString?: boolean;
    /**
     * Status code for redirect.
     */
    statusCode?: number;
    /**
     * Target URL for redirect.
     */
    targetUrls?: outputs.RulesetRuleActionParameterFromValueTargetUrl[];
}

export interface RulesetRuleActionParameterFromValueTargetUrl {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static value to provide as the HTTP request header value.
     */
    value?: string;
}

export interface RulesetRuleActionParameterHeader {
    /**
     * Use a value dynamically determined by the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Name of the HTTP request header to target.
     */
    name?: string;
    /**
     * Action to perform on the HTTP request header. Available values: `remove`, `set`, `add`.
     */
    operation?: string;
    /**
     * Static value to provide as the HTTP request header value.
     */
    value?: string;
}

export interface RulesetRuleActionParameterMatchedData {
    /**
     * Public key to use within WAF Ruleset payload logging to view the HTTP request parameters. You can generate a public key [using the `matched-data-cli` command-line tool](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/command-line/generate-key-pair) or [in the Cloudflare dashboard](https://developers.cloudflare.com/waf/managed-rulesets/payload-logging/configure).
     */
    publicKey?: string;
}

export interface RulesetRuleActionParameterOrigin {
    /**
     * Origin Hostname where request is sent.
     */
    host?: string;
    /**
     * Origin Port where request is sent.
     */
    port?: number;
}

export interface RulesetRuleActionParameterOverride {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
     */
    action?: string;
    /**
     * List of tag-based overrides.
     */
    categories?: outputs.RulesetRuleActionParameterOverrideCategory[];
    /**
     * Defines if the current ruleset-level override enables or disables the ruleset.
     */
    enabled?: boolean;
    /**
     * List of rule-based overrides.
     */
    rules?: outputs.RulesetRuleActionParameterOverrideRule[];
    /**
     * Sensitivity level to override for all ruleset rules. Available values: `default`, `medium`, `low`, `eoff`.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParameterOverrideCategory {
    /**
     * Action to perform in the tag-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
     */
    action?: string;
    /**
     * Tag name to apply the ruleset rule override to.
     */
    category?: string;
    /**
     * Defines if the current tag-level override enables or disables the ruleset rules with the specified tag.
     */
    enabled?: boolean;
}

export interface RulesetRuleActionParameterOverrideRule {
    /**
     * Action to perform in the rule-level override. Available values: `block`, `challenge`, `compress_response`, `ddos_dynamic`, `ddos_mitigation`, `execute`, `force_connection_close`, `js_challenge`, `log`, `log_custom_field`, `managed_challenge`, `redirect`, `rewrite`, `route`, `score`, `serve_error`, `set_cache_settings`, `set_config`, `skip`.
     */
    action?: string;
    /**
     * Defines if the current rule-level override enables or disables the rule.
     */
    enabled?: boolean;
    /**
     * Rule ID to apply the override to.
     */
    id?: string;
    /**
     * Anomaly score threshold to apply in the ruleset rule override. Only applicable to modsecurity-based rulesets.
     */
    scoreThreshold?: number;
    /**
     * Sensitivity level for a ruleset rule override.
     */
    sensitivityLevel?: string;
}

export interface RulesetRuleActionParameterResponse {
    /**
     * Body content to include in the response.
     */
    content?: string;
    /**
     * HTTP content type to send in the response.
     */
    contentType?: string;
    /**
     * HTTP status code to send in the response.
     */
    statusCode?: number;
}

export interface RulesetRuleActionParameterServeStale {
    /**
     * Disable stale while updating.
     */
    disableStaleWhileUpdating?: boolean;
}

export interface RulesetRuleActionParameterSni {
    /**
     * Value to define for SNI.
     */
    value?: string;
}

export interface RulesetRuleActionParameterUri {
    origin?: boolean;
    /**
     * URI path configuration when performing a URL rewrite.
     */
    paths?: outputs.RulesetRuleActionParameterUriPath[];
    /**
     * Query string configuration when performing a URL rewrite.
     */
    queries?: outputs.RulesetRuleActionParameterUriQuery[];
}

export interface RulesetRuleActionParameterUriPath {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface RulesetRuleActionParameterUriQuery {
    /**
     * Expression that defines the updated (dynamic) value of the URI path or query string component. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    expression?: string;
    /**
     * Static string value of the updated URI path or query string component.
     */
    value?: string;
}

export interface RulesetRuleExposedCredentialCheck {
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "password" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    passwordExpression?: string;
    /**
     * Firewall Rules expression language based on Wireshark display filters for where to check for the "username" value. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language).
     */
    usernameExpression?: string;
}

export interface RulesetRuleLogging {
    /**
     * Override the default logging behavior when a rule is matched.
     */
    enabled?: boolean;
}

export interface RulesetRuleRatelimit {
    /**
     * List of parameters that define how Cloudflare tracks the request rate for this rule.
     */
    characteristics?: string[];
    /**
     * Criteria for counting HTTP requests to trigger the Rate Limiting action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Firewall Rules language](https://developers.cloudflare.com/firewall/cf-firewall-language) documentation for all available fields, operators, and functions.
     */
    countingExpression?: string;
    /**
     * Once the request rate is reached, the Rate Limiting rule blocks further requests for the period of time defined in this field.
     */
    mitigationTimeout?: number;
    /**
     * The period of time to consider (in seconds) when evaluating the request rate.
     */
    period?: number;
    /**
     * The number of requests over the period of time that will trigger the Rate Limiting rule.
     */
    requestsPerPeriod?: number;
    /**
     * Whether to include requests to origin within the Rate Limiting count.
     */
    requestsToOrigin: boolean;
    /**
     * The maximum aggregate score over the period of time that will trigger Rate Limiting rule.
     */
    scorePerPeriod?: number;
    /**
     * Name of HTTP header in the response, set by the origin server, with the score for the current request.
     */
    scoreResponseHeaderName?: string;
}

export interface SpectrumApplicationDns {
    /**
     * The name of the DNS record associated with the application.
     */
    name: string;
    /**
     * The type of DNS record associated with the application.
     */
    type: string;
}

export interface SpectrumApplicationEdgeIps {
    /**
     * The IP versions supported for inbound connections on Spectrum anycast IPs. Required when `type` is not `static`. Available values: `all`, `ipv4`, `ipv6`.
     */
    connectivity?: string;
    /**
     * The collection of customer owned IPs to broadcast via anycast for this hostname and application. Requires [Bring Your Own IP](https://developers.cloudflare.com/spectrum/getting-started/byoip/) provisioned.
     */
    ips?: string[];
    /**
     * The type of edge IP configuration specified. Available values: `dynamic`, `static`.
     */
    type: string;
}

export interface SpectrumApplicationOriginDns {
    /**
     * Fully qualified domain name of the origin.
     */
    name: string;
}

export interface SpectrumApplicationOriginPortRange {
    /**
     * Upper bound of the origin port range.
     */
    end: number;
    /**
     * Lower bound of the origin port range.
     */
    start: number;
}

export interface SplitTunnelTunnel {
    /**
     * The address for the tunnel.
     */
    address?: string;
    /**
     * A description for the tunnel.
     */
    description?: string;
    /**
     * The domain name for the tunnel.
     */
    host?: string;
}

export interface TeamsAccountAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: boolean;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
    /**
     * Set notifications for antivirus.
     */
    notificationSettings?: outputs.TeamsAccountAntivirusNotificationSettings;
}

export interface TeamsAccountAntivirusNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface TeamsAccountBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: string;
    /**
     * Indicator of enablement.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * URL of block page logo.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Name of block page configuration.
     */
    name?: string;
}

export interface TeamsAccountBodyScanning {
    /**
     * Body scanning inspection mode. Available values: `deep`, `shallow`.
     */
    inspectionMode: string;
}

export interface TeamsAccountCustomCertificate {
    /**
     * Whether TLS encryption should use a custom certificate.
     */
    enabled: boolean;
    /**
     * ID of custom certificate.
     */
    id: string;
    updatedAt: string;
}

export interface TeamsAccountExtendedEmailMatching {
    /**
     * Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
     */
    enabled: boolean;
}

export interface TeamsAccountFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: boolean;
}

export interface TeamsAccountLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: boolean;
    /**
     * Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: outputs.TeamsAccountLoggingSettingsByRuleType;
}

export interface TeamsAccountLoggingSettingsByRuleType {
    /**
     * Logging configuration for DNS requests.
     */
    dns: outputs.TeamsAccountLoggingSettingsByRuleTypeDns;
    /**
     * Logging configuration for HTTP requests.
     */
    http: outputs.TeamsAccountLoggingSettingsByRuleTypeHttp;
    /**
     * Logging configuration for layer 4 requests.
     */
    l4: outputs.TeamsAccountLoggingSettingsByRuleTypeL4;
}

export interface TeamsAccountLoggingSettingsByRuleTypeDns {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeHttp {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountLoggingSettingsByRuleTypeL4 {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface TeamsAccountPayloadLog {
    /**
     * Public key used to encrypt matched payloads.
     */
    publicKey: string;
}

export interface TeamsAccountProxy {
    /**
     * Whether root ca is enabled account wide for ZT clients.
     */
    rootCa: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for TCP traffic.
     */
    tcp: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for UDP traffic.
     */
    udp: boolean;
    /**
     * Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
     */
    virtualIp: boolean;
}

export interface TeamsAccountSshSessionLog {
    /**
     * Public key used to encrypt ssh session.
     */
    publicKey: string;
}

export interface TeamsListItemsWithDescription {
    description: string;
    value: string;
}

export interface TeamsLocationNetwork {
    id: string;
    /**
     * CIDR notation representation of the network IP.
     */
    network: string;
}

export interface TeamsRuleRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: {[key: string]: string};
    /**
     * Allow parent MSP accounts to enable bypass their children's rules.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for auditing SSH usage.
     */
    auditSsh?: outputs.TeamsRuleRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls?: outputs.TeamsRuleRuleSettingsBisoAdminControls;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: boolean;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: string;
    /**
     * Allow child MSP accounts to bypass their parent's rule.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession?: outputs.TeamsRuleRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve_dns_through_cloudflare is set. DNS queries will route to the address closest to their origin.
     */
    dnsResolvers?: outputs.TeamsRuleRuleSettingsDnsResolvers;
    /**
     * Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
     */
    egress?: outputs.TeamsRuleRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response.
     */
    ignoreCnameCategoryMatches?: boolean;
    /**
     * Disable DNSSEC validation (must be Allow rule).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Turns on IP category based filter on dns if the rule contains dns category checks.
     */
    ipCategories?: boolean;
    /**
     * Settings to forward layer 4 traffic.
     */
    l4override?: outputs.TeamsRuleRuleSettingsL4override;
    /**
     * Notification settings on a block rule.
     */
    notificationSettings?: outputs.TeamsRuleRuleSettingsNotificationSettings;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: string;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: string[];
    /**
     * Configure DLP Payload Logging settings for this rule.
     */
    payloadLog?: outputs.TeamsRuleRuleSettingsPayloadLog;
    /**
     * Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
     */
    resolveDnsThroughCloudflare?: boolean;
    /**
     * Configure untrusted certificate settings for this rule.
     */
    untrustedCert?: outputs.TeamsRuleRuleSettingsUntrustedCert;
}

export interface TeamsRuleRuleSettingsAuditSsh {
    /**
     * Log all SSH commands.
     */
    commandLogging: boolean;
}

export interface TeamsRuleRuleSettingsBisoAdminControls {
    /**
     * Disable clipboard redirection.
     */
    disableClipboardRedirection?: boolean;
    /**
     * Disable copy-paste.
     */
    disableCopyPaste?: boolean;
    /**
     * Disable download.
     */
    disableDownload?: boolean;
    /**
     * Disable keyboard usage.
     */
    disableKeyboard?: boolean;
    /**
     * Disable printing.
     */
    disablePrinting?: boolean;
    /**
     * Disable upload.
     */
    disableUpload?: boolean;
}

export interface TeamsRuleRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Enable session enforcement for this rule.
     */
    enforce: boolean;
}

export interface TeamsRuleRuleSettingsDnsResolvers {
    /**
     * IPv4 resolvers.
     */
    ipv4s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv4[];
    /**
     * IPv6 resolvers.
     */
    ipv6s?: outputs.TeamsRuleRuleSettingsDnsResolversIpv6[];
}

export interface TeamsRuleRuleSettingsDnsResolversIpv4 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsDnsResolversIpv6 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface TeamsRuleRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: string;
    /**
     * The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
     */
    ipv4Fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: string;
}

export interface TeamsRuleRuleSettingsL4override {
    /**
     * Override IP to forward traffic to.
     */
    ip: string;
    /**
     * Override Port to forward traffic to.
     */
    port: number;
}

export interface TeamsRuleRuleSettingsNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface TeamsRuleRuleSettingsPayloadLog {
    /**
     * Enable or disable DLP Payload Logging for this rule.
     */
    enabled: boolean;
}

export interface TeamsRuleRuleSettingsUntrustedCert {
    /**
     * Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
     */
    action?: string;
}

export interface TunnelConfigConfig {
    /**
     * Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
     */
    ingressRules: outputs.TunnelConfigConfigIngressRule[];
    originRequest?: outputs.TunnelConfigConfigOriginRequest;
    /**
     * If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
     */
    warpRouting?: outputs.TunnelConfigConfigWarpRouting;
}

export interface TunnelConfigConfigIngressRule {
    /**
     * Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
     */
    hostname?: string;
    originRequest?: outputs.TunnelConfigConfigIngressRuleOriginRequest;
    /**
     * Path of the incoming request. If the path matches, the request will be sent to the local service.
     */
    path?: string;
    /**
     * Name of the service to which the request will be sent.
     */
    service: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.TunnelConfigConfigIngressRuleOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.TunnelConfigConfigIngressRuleOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface TunnelConfigConfigIngressRuleOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface TunnelConfigConfigOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.TunnelConfigConfigOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.TunnelConfigConfigOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface TunnelConfigConfigOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface TunnelConfigConfigOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface TunnelConfigConfigWarpRouting {
    /**
     * Whether WARP routing is enabled.
     */
    enabled?: boolean;
}

export interface UserAgentBlockingRuleConfiguration {
    /**
     * The configuration target for this rule. You must set the target to ua for User Agent Blocking rules.
     */
    target: string;
    /**
     * The exact user agent string to match. This value will be compared to the received User-Agent HTTP header value.
     */
    value: string;
}

export interface WaitingRoomAdditionalRoute {
    /**
     * The additional host name for which the waiting room to be applied on (no wildcards).
     */
    host: string;
    /**
     * The path within the additional host to enable the waiting room on. Defaults to `/`.
     */
    path?: string;
}

export interface WaitingRoomRulesRule {
    /**
     * Action to perform in the ruleset rule. Available values: `bypass_waiting_room`.
     */
    action: string;
    /**
     * Brief summary of the waiting room rule and its intended use.
     */
    description?: string;
    /**
     * Criteria for an HTTP request to trigger the waiting room rule action. Uses the Firewall Rules expression language based on Wireshark display filters. Refer to the [Waiting Room Rules Docs](https://developers.cloudflare.com/waiting-room/additional-options/waiting-room-rules/bypass-rules/).
     */
    expression: string;
    /**
     * Unique rule identifier.
     */
    id: string;
    /**
     * Whether the rule is enabled or disabled. Available values: `enabled`, `disabled`.
     */
    status?: string;
    /**
     * Version of the waiting room rule.
     */
    version: string;
}

export interface WaitingRoomTimeouts {
    create?: string;
    update?: string;
}

export interface WebAnalyticsRuleTimeouts {
    create?: string;
}

export interface WebAnalyticsSiteTimeouts {
    create?: string;
}

export interface WorkerScriptAnalyticsEngineBinding {
    /**
     * The name of the Analytics Engine dataset to write to.
     */
    dataset: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptD1DatabaseBinding {
    /**
     * Database ID of D1 database to use.
     */
    databaseId: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: string;
}

export interface WorkerScriptPlacement {
    /**
     * The placement mode for the Worker. Available values: `smart`.
     */
    mode: string;
}

export interface WorkerScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The plain text you want to store.
     */
    text: string;
}

export interface WorkerScriptQueueBinding {
    /**
     * The name of the global variable for the binding in your Worker code.
     */
    binding: string;
    /**
     * Name of the queue you want to use.
     */
    queue: string;
}

export interface WorkerScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkerScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The secret text you want to store.
     */
    text: string;
}

export interface WorkerScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface WorkerScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkersScriptAnalyticsEngineBinding {
    /**
     * The name of the Analytics Engine dataset to write to.
     */
    dataset: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkersScriptD1DatabaseBinding {
    /**
     * Database ID of D1 database to use.
     */
    databaseId: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkersScriptKvNamespaceBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * ID of the KV namespace you want to use.
     */
    namespaceId: string;
}

export interface WorkersScriptPlacement {
    /**
     * The placement mode for the Worker. Available values: `smart`.
     */
    mode: string;
}

export interface WorkersScriptPlainTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The plain text you want to store.
     */
    text: string;
}

export interface WorkersScriptQueueBinding {
    /**
     * The name of the global variable for the binding in your Worker code.
     */
    binding: string;
    /**
     * Name of the queue you want to use.
     */
    queue: string;
}

export interface WorkersScriptR2BucketBinding {
    /**
     * The name of the Bucket to bind to.
     */
    bucketName: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface WorkersScriptSecretTextBinding {
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The secret text you want to store.
     */
    text: string;
}

export interface WorkersScriptServiceBinding {
    /**
     * The name of the Worker environment to bind to.
     */
    environment?: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
    /**
     * The name of the Worker to bind to.
     */
    service: string;
}

export interface WorkersScriptWebassemblyBinding {
    /**
     * The base64 encoded wasm module you want to store.
     */
    module: string;
    /**
     * The global variable for the binding in your Worker code.
     */
    name: string;
}

export interface ZeroTrustAccessApplicationCorsHeader {
    /**
     * Value to determine whether all HTTP headers are exposed.
     */
    allowAllHeaders?: boolean;
    /**
     * Value to determine whether all methods are exposed.
     */
    allowAllMethods?: boolean;
    /**
     * Value to determine whether all origins are permitted to make CORS requests.
     */
    allowAllOrigins?: boolean;
    /**
     * Value to determine if credentials (cookies, authorization headers, or TLS client certificates) are included with requests.
     */
    allowCredentials?: boolean;
    /**
     * List of HTTP headers to expose via CORS.
     */
    allowedHeaders?: string[];
    /**
     * List of methods to expose via CORS.
     */
    allowedMethods?: string[];
    /**
     * List of origins permitted to make CORS requests.
     */
    allowedOrigins?: string[];
    /**
     * The maximum time a preflight request will be cached.
     */
    maxAge?: number;
}

export interface ZeroTrustAccessApplicationFooterLink {
    /**
     * The name of the footer link.
     */
    name?: string;
    /**
     * The URL of the footer link.
     */
    url?: string;
}

export interface ZeroTrustAccessApplicationLandingPageDesign {
    /**
     * The button color of the landing page.
     */
    buttonColor?: string;
    /**
     * The button text color of the landing page.
     */
    buttonTextColor?: string;
    /**
     * The URL of the image to be displayed in the landing page.
     */
    imageUrl?: string;
    /**
     * The message of the landing page.
     */
    message?: string;
    /**
     * The title of the landing page.
     */
    title?: string;
}

export interface ZeroTrustAccessApplicationSaasApp {
    /**
     * The lifetime of the Access Token after creation. Valid units are `m` and `h`. Must be greater than or equal to 1m and less than or equal to 24h.
     */
    accessTokenLifetime?: string;
    /**
     * Allow PKCE flow without a client secret.
     */
    allowPkceWithoutClientSecret?: boolean;
    /**
     * The URL where this applications tile redirects users.
     */
    appLauncherUrl?: string;
    /**
     * **Modifying this attribute will force creation of a new resource.**
     */
    authType?: string;
    /**
     * The application client id.
     */
    clientId: string;
    /**
     * The application client secret, only returned on initial apply.
     */
    clientSecret: string;
    /**
     * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
     */
    consumerServiceUrl?: string;
    /**
     * Custom attribute mapped from IDPs.
     */
    customAttributes?: outputs.ZeroTrustAccessApplicationSaasAppCustomAttribute[];
    /**
     * Custom claim mapped from IDPs.
     */
    customClaims?: outputs.ZeroTrustAccessApplicationSaasAppCustomClaim[];
    /**
     * The relay state used if not provided by the identity provider.
     */
    defaultRelayState?: string;
    /**
     * The OIDC flows supported by this application.
     */
    grantTypes: string[];
    /**
     * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
     */
    groupFilterRegex?: string;
    /**
     * Hybrid and Implicit Flow options.
     */
    hybridAndImplicitOptions?: outputs.ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions;
    /**
     * The unique identifier for the SaaS application.
     */
    idpEntityId: string;
    /**
     * The format of the name identifier sent to the SaaS application.
     */
    nameIdFormat?: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
     */
    nameIdTransformJsonata?: string;
    /**
     * The public certificate that will be used to verify identities.
     */
    publicKey: string;
    /**
     * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens.
     */
    redirectUris?: string[];
    /**
     * Refresh token grant options.
     */
    refreshTokenOptions?: outputs.ZeroTrustAccessApplicationSaasAppRefreshTokenOption[];
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml_attributes or oidc_fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
     */
    samlAttributeTransformJsonata?: string;
    /**
     * Define the user information shared with access.
     */
    scopes: string[];
    /**
     * A globally unique name for an identity or service provider.
     */
    spEntityId?: string;
    /**
     * The endpoint where the SaaS application will send login requests.
     */
    ssoEndpoint: string;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttribute {
    /**
     * A friendly name for the attribute as provided to the SaaS app.
     */
    friendlyName?: string;
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     */
    nameFormat?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    source: outputs.ZeroTrustAccessApplicationSaasAppCustomAttributeSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomAttributeSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaim {
    /**
     * The name of the attribute as provided to the SaaS app.
     */
    name?: string;
    /**
     * True if the attribute must be always present.
     */
    required?: boolean;
    /**
     * The scope of the claim.
     */
    scope?: string;
    source: outputs.ZeroTrustAccessApplicationSaasAppCustomClaimSource;
}

export interface ZeroTrustAccessApplicationSaasAppCustomClaimSource {
    /**
     * The name of the attribute as provided by the IDP.
     */
    name: string;
    /**
     * A mapping from IdP ID to claim name.
     */
    nameByIdp?: {[key: string]: string};
}

export interface ZeroTrustAccessApplicationSaasAppHybridAndImplicitOptions {
    /**
     * If true, the authorization endpoint will return an access token.
     */
    returnAccessTokenFromAuthorizationEndpoint?: boolean;
    /**
     * If true, the authorization endpoint will return an id token.
     */
    returnIdTokenFromAuthorizationEndpoint?: boolean;
}

export interface ZeroTrustAccessApplicationSaasAppRefreshTokenOption {
    /**
     * How long a refresh token will be valid for after creation. Valid units are `m`, `h` and `d`. Must be longer than 1m.
     */
    lifetime?: string;
}

export interface ZeroTrustAccessApplicationScimConfig {
    /**
     * Attributes for configuring HTTP Basic, OAuth Bearer token, or OAuth 2 authentication schemes for SCIM provisioning to an application.
     */
    authentication?: outputs.ZeroTrustAccessApplicationScimConfigAuthentication;
    /**
     * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
     */
    deactivateOnDelete?: boolean;
    /**
     * Whether SCIM provisioning is turned on for this application.
     */
    enabled?: boolean;
    /**
     * The UID of the IdP to use as the source for SCIM resources to provision to this application.
     */
    idpUid: string;
    /**
     * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
     */
    mappings?: outputs.ZeroTrustAccessApplicationScimConfigMapping[];
    /**
     * The base URI for the application's SCIM-compatible API.
     */
    remoteUri: string;
}

export interface ZeroTrustAccessApplicationScimConfigAuthentication {
    /**
     * URL used to generate the auth code used during token generation. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    authorizationUrl?: string;
    /**
     * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientId?: string;
    /**
     * Secret used to authenticate when generating a token for authenticating with the remove SCIM service. Required when using `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    clientSecret?: string;
    /**
     * Required when using `scim_config.0.authentication.0.user`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    password?: string;
    /**
     * The authentication scheme to use when making SCIM requests to this application.
     */
    scheme: string;
    /**
     * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    scopes?: string[];
    /**
     * Token used to authenticate with the remote SCIM service. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    token?: string;
    /**
     * URL used to generate the token used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.client_id`. Conflicts with `scim_config.0.authentication.0.user`, `scim_config.0.authentication.0.password`, `scim_config.0.authentication.0.token`.
     */
    tokenUrl?: string;
    /**
     * User name used to authenticate with the remote SCIM service. Required when using `scim_config.0.authentication.0.password`. Conflicts with `scim_config.0.authentication.0.token`, `scim_config.0.authentication.0.client_id`, `scim_config.0.authentication.0.client_secret`, `scim_config.0.authentication.0.authorization_url`, `scim_config.0.authentication.0.token_url`, `scim_config.0.authentication.0.scopes`.
     */
    user?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMapping {
    /**
     * Whether or not this mapping is enabled.
     */
    enabled?: boolean;
    /**
     * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
     */
    filter?: string;
    /**
     * Whether or not this mapping applies to creates, updates, or deletes.
     */
    operations?: outputs.ZeroTrustAccessApplicationScimConfigMappingOperations;
    /**
     * Which SCIM resource type this mapping applies to.
     */
    schema: string;
    /**
     * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
     */
    transformJsonata?: string;
}

export interface ZeroTrustAccessApplicationScimConfigMappingOperations {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    delete?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
}

export interface ZeroTrustAccessGroupExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessGroupExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessGroupExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessGroupExcludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessGroupExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessGroupExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessGroupExcludeOkta[];
    samls?: outputs.ZeroTrustAccessGroupExcludeSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessGroupExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessGroupExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessGroupExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessGroupExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessGroupExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessGroupExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustAccessGroupInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessGroupIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessGroupIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessGroupIncludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessGroupIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessGroupIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessGroupIncludeOkta[];
    samls?: outputs.ZeroTrustAccessGroupIncludeSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessGroupIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessGroupIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessGroupIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessGroupIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessGroupIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessGroupIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustAccessGroupRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessGroupRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessGroupRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessGroupRequireExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessGroupRequireGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessGroupRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessGroupRequireOkta[];
    samls?: outputs.ZeroTrustAccessGroupRequireSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessGroupRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessGroupRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessGroupRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessGroupRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessGroupRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessGroupRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessGroupRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustAccessIdentityProviderConfig {
    apiToken?: string;
    appsDomain?: string;
    attributes: string[];
    authUrl?: string;
    authorizationServerId?: string;
    centrifyAccount?: string;
    centrifyAppId?: string;
    certsUrl?: string;
    claims: string[];
    clientId?: string;
    clientSecret?: string;
    conditionalAccessEnabled?: boolean;
    directoryId?: string;
    emailAttributeName?: string;
    emailClaimName?: string;
    idpPublicCert?: string;
    issuerUrl?: string;
    oktaAccount?: string;
    oneloginAccount?: string;
    pingEnvId?: string;
    pkceEnabled?: boolean;
    redirectUrl: string;
    scopes: string[];
    signRequest?: boolean;
    ssoTargetUrl?: string;
    supportGroups?: boolean;
    tokenUrl?: string;
}

export interface ZeroTrustAccessIdentityProviderScimConfig {
    enabled?: boolean;
    groupMemberDeprovision?: boolean;
    seatDeprovision?: boolean;
    secret: string;
    userDeprovision?: boolean;
}

export interface ZeroTrustAccessMtlsHostnameSettingsSetting {
    /**
     * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
     */
    chinaNetwork?: boolean;
    /**
     * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
     */
    clientCertificateForwarding?: boolean;
    /**
     * The hostname that these settings apply to.
     */
    hostname: string;
}

export interface ZeroTrustAccessOrganizationCustomPage {
    /**
     * The id of the forbidden page.
     */
    forbidden?: string;
    /**
     * The id of the identity denied page.
     */
    identityDenied?: string;
}

export interface ZeroTrustAccessOrganizationLoginDesign {
    /**
     * The background color on the login page.
     */
    backgroundColor?: string;
    /**
     * The text at the bottom of the login page.
     */
    footerText?: string;
    /**
     * The text at the top of the login page.
     */
    headerText?: string;
    /**
     * The URL of the logo on the login page.
     */
    logoPath?: string;
    /**
     * The text color on the login page.
     */
    textColor?: string;
}

export interface ZeroTrustAccessPolicyApprovalGroup {
    /**
     * Number of approvals needed.
     */
    approvalsNeeded: number;
    /**
     * List of emails to request approval from.
     */
    emailAddresses?: string[];
    emailListUuid?: string;
}

export interface ZeroTrustAccessPolicyExclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessPolicyExcludeAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessPolicyExcludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessPolicyExcludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessPolicyExcludeGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessPolicyExcludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessPolicyExcludeOkta[];
    samls?: outputs.ZeroTrustAccessPolicyExcludeSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessPolicyExcludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyExcludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessPolicyExcludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessPolicyExcludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessPolicyExcludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessPolicyExcludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessPolicyExcludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustAccessPolicyInclude {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessPolicyIncludeAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessPolicyIncludeAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessPolicyIncludeExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessPolicyIncludeGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessPolicyIncludeGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessPolicyIncludeOkta[];
    samls?: outputs.ZeroTrustAccessPolicyIncludeSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessPolicyIncludeAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyIncludeAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessPolicyIncludeExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessPolicyIncludeGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessPolicyIncludeGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessPolicyIncludeOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessPolicyIncludeSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustAccessPolicyRequire {
    anyValidServiceToken?: boolean;
    authContexts?: outputs.ZeroTrustAccessPolicyRequireAuthContext[];
    authMethod?: string;
    azures?: outputs.ZeroTrustAccessPolicyRequireAzure[];
    certificate?: boolean;
    commonName?: string;
    /**
     * Overflow field if you need to have multiple common_name rules in a single policy.  Use in place of the singular common_name field.
     */
    commonNames?: string[];
    devicePostures?: string[];
    emailDomains?: string[];
    emailLists?: string[];
    emails?: string[];
    everyone?: boolean;
    externalEvaluations?: outputs.ZeroTrustAccessPolicyRequireExternalEvaluation[];
    geos?: string[];
    githubs?: outputs.ZeroTrustAccessPolicyRequireGithub[];
    groups?: string[];
    gsuites?: outputs.ZeroTrustAccessPolicyRequireGsuite[];
    /**
     * The ID of an existing IP list to reference.
     */
    ipLists?: string[];
    /**
     * An IPv4 or IPv6 CIDR block.
     */
    ips?: string[];
    loginMethods?: string[];
    oktas?: outputs.ZeroTrustAccessPolicyRequireOkta[];
    samls?: outputs.ZeroTrustAccessPolicyRequireSaml[];
    serviceTokens?: string[];
}

export interface ZeroTrustAccessPolicyRequireAuthContext {
    /**
     * The ACID of the Authentication Context.
     */
    acId: string;
    /**
     * The ID of the Authentication Context.
     */
    id: string;
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId: string;
}

export interface ZeroTrustAccessPolicyRequireAzure {
    /**
     * The ID of the Azure Identity provider.
     */
    identityProviderId?: string;
    /**
     * The ID of the Azure group or user.
     */
    ids?: string[];
}

export interface ZeroTrustAccessPolicyRequireExternalEvaluation {
    evaluateUrl?: string;
    keysUrl?: string;
}

export interface ZeroTrustAccessPolicyRequireGithub {
    identityProviderId?: string;
    name?: string;
    teams?: string[];
}

export interface ZeroTrustAccessPolicyRequireGsuite {
    emails?: string[];
    identityProviderId?: string;
}

export interface ZeroTrustAccessPolicyRequireOkta {
    identityProviderId?: string;
    names?: string[];
}

export interface ZeroTrustAccessPolicyRequireSaml {
    attributeName?: string;
    attributeValue?: string;
    identityProviderId?: string;
}

export interface ZeroTrustDeviceManagedNetworksConfig {
    /**
     * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
     */
    sha256: string;
    /**
     * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
     */
    tlsSockaddr: string;
}

export interface ZeroTrustDevicePostureIntegrationConfig {
    /**
     * The Access client ID to be used as the `Cf-Access-Client-ID` header when making a request to the `api_url`.
     */
    accessClientId?: string;
    /**
     * The Access client secret to be used as the `Cf-Access-Client-Secret` header when making a request to the `api_url`.
     */
    accessClientSecret?: string;
    /**
     * The third-party API's URL.
     */
    apiUrl?: string;
    /**
     * The third-party authorization API URL.
     */
    authUrl?: string;
    /**
     * The client identifier for authenticating API calls.
     */
    clientId?: string;
    /**
     * The client key for authenticating API calls.
     */
    clientKey?: string;
    /**
     * The client secret for authenticating API calls.
     */
    clientSecret?: string;
    /**
     * The customer identifier for authenticating API calls.
     */
    customerId?: string;
}

export interface ZeroTrustDevicePostureRuleInput {
    /**
     * The number of active threats from SentinelOne.
     */
    activeThreats?: number;
    /**
     * The UUID of a Cloudflare managed certificate.
     */
    certificateId?: string;
    /**
     * Specific volume(s) to check for encryption.
     */
    checkDisks?: string[];
    /**
     * Confirm the certificate was not imported from another device.
     */
    checkPrivateKey?: boolean;
    /**
     * The common name for a certificate.
     */
    cn?: string;
    /**
     * The workspace one or intune device compliance status. `compliant` and `noncompliant` are values supported by both providers. `unknown`, `conflict`, `error`, `ingraceperiod` values are only supported by intune. Available values: `compliant`, `noncompliant`, `unknown`, `conflict`, `error`, `ingraceperiod`.
     */
    complianceStatus?: string;
    /**
     * The workspace one or intune connection id.
     */
    connectionId?: string;
    /**
     * The count comparison operator for kolide. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    countOperator?: string;
    /**
     * The domain that the client must join.
     */
    domain?: string;
    /**
     * The datetime a device last seen in RFC 3339 format from Tanium.
     */
    eidLastSeen?: string;
    /**
     * True if the firewall must be enabled.
     */
    enabled: boolean;
    /**
     * Checks if the file should exist.
     */
    exists: boolean;
    /**
     * List of values indicating purposes for which the certificate public key can be used. Available values: `clientAuth`, `emailProtection`.
     */
    extendedKeyUsages?: string[];
    /**
     * The Teams List id. Required for `serial_number` and `unique_client_id` rule types.
     */
    id?: string;
    /**
     * True if SentinelOne device is infected.
     */
    infected: boolean;
    /**
     * True if SentinelOne device is active.
     */
    isActive: boolean;
    /**
     * The number of issues for kolide.
     */
    issueCount?: string;
    /**
     * The duration of time that the host was last seen from Crowdstrike. Must be in the format `1h` or `30m`. Valid units are `d`, `h` and `m`.
     */
    lastSeen?: string;
    /**
     * List of locations to check for client certificate.
     */
    locations?: outputs.ZeroTrustDevicePostureRuleInputLocation[];
    /**
     * The network status from SentinelOne. Available values: `connected`, `disconnected`, `disconnecting`, `connecting`.
     */
    networkStatus?: string;
    /**
     * The version comparison operator. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    operator?: string;
    /**
     * OS signal score from Crowdstrike. Value must be between 1 and 100.
     */
    os?: string;
    /**
     * The operating system excluding version information.
     */
    osDistroName?: string;
    /**
     * The operating system version excluding OS name information or release name.
     */
    osDistroRevision?: string;
    /**
     * Extra version value following the operating system semantic version.
     */
    osVersionExtra?: string;
    /**
     * Overall ZTA score from Crowdstrike. Value must be between 1 and 100.
     */
    overall?: string;
    /**
     * The path to the file.
     */
    path?: string;
    /**
     * True if all drives must be encrypted.
     */
    requireAll: boolean;
    /**
     * The risk level from Tanium. Available values: `low`, `medium`, `high`, `critical`.
     */
    riskLevel?: string;
    /**
     * Checks if the application should be running.
     */
    running: boolean;
    /**
     * Sensor signal score from Crowdstrike. Value must be between 1 and 100.
     */
    sensorConfig?: string;
    /**
     * The sha256 hash of the file.
     */
    sha256?: string;
    /**
     * The host’s current online status from Crowdstrike. Available values: `online`, `offline`, `unknown`.
     */
    state?: string;
    /**
     * The thumbprint of the file certificate.
     */
    thumbprint?: string;
    /**
     * The total score from Tanium.
     */
    totalScore?: number;
    /**
     * The operating system semantic version.
     */
    version?: string;
    /**
     * The version comparison operator for crowdstrike. Available values: `>`, `>=`, `<`, `<=`, `==`.
     */
    versionOperator?: string;
}

export interface ZeroTrustDevicePostureRuleInputLocation {
    /**
     * List of paths to check for client certificate rule.
     */
    paths?: string[];
    /**
     * List of trust stores to check for client certificate rule. Available values: `system`, `user`.
     */
    trustStores?: string[];
}

export interface ZeroTrustDevicePostureRuleMatch {
    /**
     * The platform of the device. Available values: `windows`, `mac`, `linux`, `android`, `ios`, `chromeos`.
     */
    platform?: string;
}

export interface ZeroTrustDexTestData {
    /**
     * The host URL for `http` test `kind`. For `traceroute`, it must be a valid hostname or IP address.
     */
    host: string;
    /**
     * The type of Device Dex Test. Available values: `http`, `traceroute`.
     */
    kind: string;
    /**
     * The http request method. Available values: `GET`.
     */
    method?: string;
}

export interface ZeroTrustDlpProfileContextAwareness {
    /**
     * Scan the context of predefined entries to only return matches surrounded by keywords.
     */
    enabled: boolean;
    /**
     * Content types to exclude from context analysis and return all matches.
     */
    skip: outputs.ZeroTrustDlpProfileContextAwarenessSkip;
}

export interface ZeroTrustDlpProfileContextAwarenessSkip {
    /**
     * Return all matches, regardless of context analysis result, if the data is a file.
     */
    files: boolean;
}

export interface ZeroTrustDlpProfileEntry {
    /**
     * Whether the entry is active. Defaults to `false`.
     */
    enabled?: boolean;
    /**
     * Unique entry identifier.
     */
    id: string;
    /**
     * Name of the entry to deploy.
     */
    name: string;
    pattern?: outputs.ZeroTrustDlpProfileEntryPattern;
}

export interface ZeroTrustDlpProfileEntryPattern {
    /**
     * The regex that defines the pattern.
     */
    regex: string;
    /**
     * The validation algorithm to apply with this pattern.
     */
    validation?: string;
}

export interface ZeroTrustDnsLocationNetwork {
    id: string;
    /**
     * CIDR notation representation of the network IP.
     */
    network: string;
}

export interface ZeroTrustGatewayPolicyRuleSettings {
    /**
     * Add custom headers to allowed requests in the form of key-value pairs.
     */
    addHeaders?: {[key: string]: string};
    /**
     * Allow parent MSP accounts to enable bypass their children's rules.
     */
    allowChildBypass?: boolean;
    /**
     * Settings for auditing SSH usage.
     */
    auditSsh?: outputs.ZeroTrustGatewayPolicyRuleSettingsAuditSsh;
    /**
     * Configure how browser isolation behaves.
     */
    bisoAdminControls?: outputs.ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls;
    /**
     * Indicator of block page enablement.
     */
    blockPageEnabled?: boolean;
    /**
     * The displayed reason for a user being blocked.
     */
    blockPageReason?: string;
    /**
     * Allow child MSP accounts to bypass their parent's rule.
     */
    bypassParentRule?: boolean;
    /**
     * Configure how session check behaves.
     */
    checkSession?: outputs.ZeroTrustGatewayPolicyRuleSettingsCheckSession;
    /**
     * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when resolve_dns_through_cloudflare is set. DNS queries will route to the address closest to their origin.
     */
    dnsResolvers?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolvers;
    /**
     * Configure how Proxy traffic egresses. Can be set for rules with Egress action and Egress filter. Can be omitted to indicate local egress via Warp IPs.
     */
    egress?: outputs.ZeroTrustGatewayPolicyRuleSettingsEgress;
    /**
     * Set to true, to ignore the category matches at CNAME domains in a response.
     */
    ignoreCnameCategoryMatches?: boolean;
    /**
     * Disable DNSSEC validation (must be Allow rule).
     */
    insecureDisableDnssecValidation?: boolean;
    /**
     * Turns on IP category based filter on dns if the rule contains dns category checks.
     */
    ipCategories?: boolean;
    /**
     * Settings to forward layer 4 traffic.
     */
    l4override?: outputs.ZeroTrustGatewayPolicyRuleSettingsL4override;
    /**
     * Notification settings on a block rule.
     */
    notificationSettings?: outputs.ZeroTrustGatewayPolicyRuleSettingsNotificationSettings;
    /**
     * The host to override matching DNS queries with.
     */
    overrideHost?: string;
    /**
     * The IPs to override matching DNS queries with.
     */
    overrideIps?: string[];
    /**
     * Configure DLP Payload Logging settings for this rule.
     */
    payloadLog?: outputs.ZeroTrustGatewayPolicyRuleSettingsPayloadLog;
    /**
     * Enable sending queries that match the resolver policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when `dns_resolvers` are specified.
     */
    resolveDnsThroughCloudflare?: boolean;
    /**
     * Configure untrusted certificate settings for this rule.
     */
    untrustedCert?: outputs.ZeroTrustGatewayPolicyRuleSettingsUntrustedCert;
}

export interface ZeroTrustGatewayPolicyRuleSettingsAuditSsh {
    /**
     * Log all SSH commands.
     */
    commandLogging: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsBisoAdminControls {
    /**
     * Disable clipboard redirection.
     */
    disableClipboardRedirection?: boolean;
    /**
     * Disable copy-paste.
     */
    disableCopyPaste?: boolean;
    /**
     * Disable download.
     */
    disableDownload?: boolean;
    /**
     * Disable keyboard usage.
     */
    disableKeyboard?: boolean;
    /**
     * Disable printing.
     */
    disablePrinting?: boolean;
    /**
     * Disable upload.
     */
    disableUpload?: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsCheckSession {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     */
    duration: string;
    /**
     * Enable session enforcement for this rule.
     */
    enforce: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolvers {
    /**
     * IPv4 resolvers.
     */
    ipv4s?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4[];
    /**
     * IPv6 resolvers.
     */
    ipv6s?: outputs.ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6[];
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv4 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsDnsResolversIpv6 {
    /**
     * The IPv4 or IPv6 address of the upstream resolver.
     */
    ip: string;
    /**
     * A port number to use for the upstream resolver. Defaults to `53`.
     */
    port?: number;
    /**
     * Whether to connect to this resolver over a private network. Must be set when `vnet_id` is set.
     */
    routeThroughPrivateNetwork?: boolean;
    /**
     * specify a virtual network for this resolver. Uses default virtual network id if omitted.
     */
    vnetId?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsEgress {
    /**
     * The IPv4 address to be used for egress.
     */
    ipv4: string;
    /**
     * The IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egreass via Warp IPs.
     */
    ipv4Fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     */
    ipv6: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsL4override {
    /**
     * Override IP to forward traffic to.
     */
    ip: string;
    /**
     * Override Port to forward traffic to.
     */
    port: number;
}

export interface ZeroTrustGatewayPolicyRuleSettingsNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewayPolicyRuleSettingsPayloadLog {
    /**
     * Enable or disable DLP Payload Logging for this rule.
     */
    enabled: boolean;
}

export interface ZeroTrustGatewayPolicyRuleSettingsUntrustedCert {
    /**
     * Action to be taken when the SSL certificate of upstream is invalid. Available values: `pass_through`, `block`, `error`.
     */
    action?: string;
}

export interface ZeroTrustGatewaySettingsAntivirus {
    /**
     * Scan on file download.
     */
    enabledDownloadPhase: boolean;
    /**
     * Scan on file upload.
     */
    enabledUploadPhase: boolean;
    /**
     * Block requests for files that cannot be scanned.
     */
    failClosed: boolean;
    /**
     * Set notifications for antivirus.
     */
    notificationSettings?: outputs.ZeroTrustGatewaySettingsAntivirusNotificationSettings;
}

export interface ZeroTrustGatewaySettingsAntivirusNotificationSettings {
    /**
     * Enable notification settings.
     */
    enabled?: boolean;
    /**
     * Notification content.
     */
    message?: string;
    /**
     * Support URL to show in the notification.
     */
    supportUrl?: string;
}

export interface ZeroTrustGatewaySettingsBlockPage {
    /**
     * Hex code of block page background color.
     */
    backgroundColor?: string;
    /**
     * Indicator of enablement.
     */
    enabled?: boolean;
    /**
     * Block page footer text.
     */
    footerText?: string;
    /**
     * Block page header text.
     */
    headerText?: string;
    /**
     * URL of block page logo.
     */
    logoPath?: string;
    /**
     * Admin email for users to contact.
     */
    mailtoAddress?: string;
    /**
     * Subject line for emails created from block page.
     */
    mailtoSubject?: string;
    /**
     * Name of block page configuration.
     */
    name?: string;
}

export interface ZeroTrustGatewaySettingsBodyScanning {
    /**
     * Body scanning inspection mode. Available values: `deep`, `shallow`.
     */
    inspectionMode: string;
}

export interface ZeroTrustGatewaySettingsCustomCertificate {
    /**
     * Whether TLS encryption should use a custom certificate.
     */
    enabled: boolean;
    /**
     * ID of custom certificate.
     */
    id: string;
    updatedAt: string;
}

export interface ZeroTrustGatewaySettingsExtendedEmailMatching {
    /**
     * Whether e-mails should be matched on all variants of user emails (with + or . modifiers) in Firewall policies.
     */
    enabled: boolean;
}

export interface ZeroTrustGatewaySettingsFips {
    /**
     * Only allow FIPS-compliant TLS configuration.
     */
    tls?: boolean;
}

export interface ZeroTrustGatewaySettingsLogging {
    /**
     * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
     */
    redactPii: boolean;
    /**
     * Represents whether all requests are logged or only the blocked requests are slogged in DNS, HTTP and L4 filters.
     */
    settingsByRuleType: outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleType;
}

export interface ZeroTrustGatewaySettingsLoggingSettingsByRuleType {
    /**
     * Logging configuration for DNS requests.
     */
    dns: outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns;
    /**
     * Logging configuration for HTTP requests.
     */
    http: outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp;
    /**
     * Logging configuration for layer 4 requests.
     */
    l4: outputs.ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4;
}

export interface ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeDns {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeHttp {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface ZeroTrustGatewaySettingsLoggingSettingsByRuleTypeL4 {
    /**
     * Whether to log all activity.
     */
    logAll: boolean;
    logBlocks: boolean;
}

export interface ZeroTrustGatewaySettingsPayloadLog {
    /**
     * Public key used to encrypt matched payloads.
     */
    publicKey: string;
}

export interface ZeroTrustGatewaySettingsProxy {
    /**
     * Whether root ca is enabled account wide for ZT clients.
     */
    rootCa: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for TCP traffic.
     */
    tcp: boolean;
    /**
     * Whether gateway proxy is enabled on gateway devices for UDP traffic.
     */
    udp: boolean;
    /**
     * Whether virtual IP (CGNAT) is enabled account wide and will override existing local interface IP for ZT clients.
     */
    virtualIp: boolean;
}

export interface ZeroTrustGatewaySettingsSshSessionLog {
    /**
     * Public key used to encrypt ssh session.
     */
    publicKey: string;
}

export interface ZeroTrustListItemsWithDescription {
    description: string;
    value: string;
}

export interface ZeroTrustLocalFallbackDomainDomain {
    /**
     * A description of the fallback domain, displayed in the client UI.
     */
    description?: string;
    /**
     * A list of IP addresses to handle domain resolution.
     */
    dnsServers?: string[];
    /**
     * The domain suffix to match when resolving locally.
     */
    suffix?: string;
}

export interface ZeroTrustRiskBehaviorBehavior {
    /**
     * Whether this risk behavior type is enabled.
     */
    enabled: boolean;
    /**
     * Name of this risk behavior type
     */
    name: string;
    /**
     * Risk level. Available values: `low`, `medium`, `high`
     */
    riskLevel: string;
}

export interface ZeroTrustSplitTunnelTunnel {
    /**
     * The address for the tunnel.
     */
    address?: string;
    /**
     * A description for the tunnel.
     */
    description?: string;
    /**
     * The domain name for the tunnel.
     */
    host?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfig {
    /**
     * Each incoming request received by cloudflared causes cloudflared to send a request to a local service. This section configures the rules that determine which requests are sent to which local services. Last rule must match all requests, e.g `service = "http_status:503"`. [Read more](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/tunnel-guide/local/local-management/ingress/).
     */
    ingressRules: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRule[];
    originRequest?: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequest;
    /**
     * If you're exposing a [private network](https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/private-net/), you need to add the `warp-routing` key and set it to `true`.
     */
    warpRouting?: outputs.ZeroTrustTunnelCloudflaredConfigConfigWarpRouting;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressRule {
    /**
     * Hostname to match the incoming request with. If the hostname matches, the request will be sent to the service.
     */
    hostname?: string;
    originRequest?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest;
    /**
     * Path of the incoming request. If the path matches, the request will be sent to the local service.
     */
    path?: string;
    /**
     * Name of the service to which the request will be sent.
     */
    service: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigIngressRuleOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequest {
    /**
     * Access rules for the ingress service.
     */
    access?: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess;
    /**
     * Runs as jump host.
     */
    bastionMode?: boolean;
    /**
     * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare. Defaults to `""`.
     */
    caPool?: string;
    /**
     * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by `tlsTimeout`. Defaults to `30s`.
     */
    connectTimeout?: string;
    /**
     * Disables chunked transfer encoding. Useful if you are running a Web Server Gateway Interface (WSGI) server. Defaults to `false`.
     */
    disableChunkedEncoding?: boolean;
    /**
     * Enables HTTP/2 support for the origin connection. Defaults to `false`.
     */
    http2Origin?: boolean;
    /**
     * Sets the HTTP Host header on requests sent to the local service. Defaults to `""`.
     */
    httpHostHeader?: string;
    /**
     * IP rules for the proxy service.
     */
    ipRules?: outputs.ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule[];
    /**
     * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections. Defaults to `100`.
     */
    keepAliveConnections?: number;
    /**
     * Timeout after which an idle keepalive connection can be discarded. Defaults to `1m30s`.
     */
    keepAliveTimeout?: string;
    /**
     * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols. Defaults to `false`.
     */
    noHappyEyeballs?: boolean;
    /**
     * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted. Defaults to `false`.
     */
    noTlsVerify?: boolean;
    /**
     * Hostname that cloudflared should expect from your origin server certificate. Defaults to `""`.
     */
    originServerName?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen address for that proxy. Defaults to `127.0.0.1`.
     */
    proxyAddress?: string;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures the listen port for that proxy. If set to zero, an unused port will randomly be chosen. Defaults to `0`.
     */
    proxyPort?: number;
    /**
     * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Available values: `""`, `socks`. Defaults to `""`.
     */
    proxyType?: string;
    /**
     * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server. Defaults to `30s`.
     */
    tcpKeepAlive?: string;
    /**
     * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server. Defaults to `10s`.
     */
    tlsTimeout?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequestAccess {
    /**
     * Audience tags of the access rule.
     */
    audTags?: string[];
    /**
     * Whether the access rule is required.
     */
    required?: boolean;
    /**
     * Name of the team to which the access rule applies.
     */
    teamName?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigOriginRequestIpRule {
    /**
     * Whether to allow the IP prefix.
     */
    allow?: boolean;
    /**
     * Ports to use within the IP rule.
     */
    ports?: number[];
    /**
     * IP rule prefix.
     */
    prefix?: string;
}

export interface ZeroTrustTunnelCloudflaredConfigConfigWarpRouting {
    /**
     * Whether WARP routing is enabled.
     */
    enabled?: boolean;
}

export interface ZoneLockdownConfiguration {
    /**
     * The request property to target. Available values: `ip`, `ip_range`.
     */
    target: string;
    /**
     * The value to target. Depends on target's type. IP addresses should just be standard IPv4/IPv6 notation i.e. `192.0.2.1` or `2001:db8::/32` and IP ranges in CIDR format i.e. `192.0.2.0/24`.
     */
    value: string;
}

export interface ZoneSettingsOverrideInitialSetting {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    fonts: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minifies: outputs.ZoneSettingsOverrideInitialSettingMinify[];
    mirage: string;
    mobileRedirects: outputs.ZoneSettingsOverrideInitialSettingMobileRedirect[];
    nels: outputs.ZoneSettingsOverrideInitialSettingNel[];
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeaders: outputs.ZoneSettingsOverrideInitialSettingSecurityHeader[];
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideInitialSettingMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideInitialSettingMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideInitialSettingNel {
    enabled: boolean;
}

export interface ZoneSettingsOverrideInitialSettingSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

export interface ZoneSettingsOverrideSettings {
    alwaysOnline: string;
    alwaysUseHttps: string;
    automaticHttpsRewrites: string;
    binaryAst: string;
    brotli: string;
    browserCacheTtl: number;
    browserCheck: string;
    cacheLevel: string;
    challengeTtl: number;
    ciphers: string[];
    cnameFlattening: string;
    developmentMode: string;
    earlyHints: string;
    emailObfuscation: string;
    filterLogsToCloudflare: string;
    fonts: string;
    h2Prioritization: string;
    hotlinkProtection: string;
    http2: string;
    http3: string;
    imageResizing: string;
    ipGeolocation: string;
    ipv6: string;
    logToCloudflare: string;
    maxUpload: number;
    minTlsVersion: string;
    minify?: outputs.ZoneSettingsOverrideSettingsMinify;
    mirage: string;
    /**
     * @deprecated Deprecated
     */
    mobileRedirect?: outputs.ZoneSettingsOverrideSettingsMobileRedirect;
    nel?: outputs.ZoneSettingsOverrideSettingsNel;
    opportunisticEncryption: string;
    opportunisticOnion: string;
    orangeToOrange: string;
    originErrorPagePassThru: string;
    originMaxHttpVersion: string;
    polish: string;
    prefetchPreload: string;
    privacyPass: string;
    proxyReadTimeout: string;
    pseudoIpv4: string;
    responseBuffering: string;
    rocketLoader: string;
    securityHeader?: outputs.ZoneSettingsOverrideSettingsSecurityHeader;
    securityLevel: string;
    serverSideExclude: string;
    sortQueryStringForCache: string;
    ssl: string;
    /**
     * @deprecated Deprecated
     */
    tls12Only: string;
    tls13: string;
    tlsClientAuth: string;
    trueClientIpHeader: string;
    universalSsl: string;
    visitorIp: string;
    waf: string;
    webp: string;
    websockets: string;
    zeroRtt: string;
}

export interface ZoneSettingsOverrideSettingsMinify {
    css: string;
    html: string;
    js: string;
}

export interface ZoneSettingsOverrideSettingsMobileRedirect {
    mobileSubdomain: string;
    status: string;
    stripUri: boolean;
}

export interface ZoneSettingsOverrideSettingsNel {
    enabled: boolean;
}

export interface ZoneSettingsOverrideSettingsSecurityHeader {
    enabled: boolean;
    includeSubdomains: boolean;
    maxAge: number;
    nosniff: boolean;
    preload: boolean;
}

