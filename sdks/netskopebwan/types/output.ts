// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GatewayAssignedPolicy {
    id: string;
    name: string;
}

export interface GatewayBgpConfiguration {
    bfdInterval: number;
    bfdMultiplier: number;
    bfdRecvInterval: number;
    isBfdEnabled: boolean;
    localAs: number;
    name: string;
    neighbor: string;
    remoteAs: number;
    routerId: string;
}

export interface GatewayCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface GatewayInterface {
    8021xMab: boolean;
    addresses?: outputs.GatewayInterfaceAddress[];
    allowedVlans: number[];
    bridgeMembers: string[];
    dhcpRelayServerSetting?: outputs.GatewayInterfaceDhcpRelayServerSetting;
    dhcpServerSetting?: outputs.GatewayInterfaceDhcpServerSetting;
    doAdvertise: boolean;
    enableNat: boolean;
    isDisabled: boolean;
    lteProps?: outputs.GatewayInterfaceLteProps;
    macAddr: string;
    mode: string;
    mtu: number;
    mtuDiscovery: string;
    name: string;
    overlaySetting?: outputs.GatewayInterfaceOverlaySetting;
    proxyArpSettings?: outputs.GatewayInterfaceProxyArpSetting[];
    radii?: outputs.GatewayInterfaceRadius[];
    type: string;
    vlan: number;
    vrrp?: outputs.GatewayInterfaceVrrp;
    wifiProps?: outputs.GatewayInterfaceWifiProps;
    zone: string;
}

export interface GatewayInterfaceAddress {
    address: string;
    addressAssignment: string;
    addressFamily: string;
    dnsPrimary: string;
    dnsSecondary: string;
    gateway: string;
    mask: string;
}

export interface GatewayInterfaceDhcpRelayServerSetting {
    relayServerIpLists: string[];
}

export interface GatewayInterfaceDhcpServerSetting {
    addressRanges?: outputs.GatewayInterfaceDhcpServerSettingAddressRange[];
    customOptions?: outputs.GatewayInterfaceDhcpServerSettingCustomOption[];
    dnsPrimary: string;
    dnsSecondary: string;
    leaseDuration: number;
    macAddressToIpv4Bindings?: outputs.GatewayInterfaceDhcpServerSettingMacAddressToIpv4Binding[];
    network: string;
}

export interface GatewayInterfaceDhcpServerSettingAddressRange {
    endIpv4: string;
    startIpv4: string;
}

export interface GatewayInterfaceDhcpServerSettingCustomOption {
    code: number;
    type: string;
    value: string;
}

export interface GatewayInterfaceDhcpServerSettingMacAddressToIpv4Binding {
    ipv4Address: string;
    macAddress: string;
    name: string;
}

export interface GatewayInterfaceLteProps {
    apn: string;
    isPrimary: boolean;
    password: string;
    userName: string;
}

export interface GatewayInterfaceOverlaySetting {
    bwMeasurementMode: string;
    dataUsageLimit?: outputs.GatewayInterfaceOverlaySettingDataUsageLimit;
    doCopyTos: boolean;
    isBackup: boolean;
    isMetered: boolean;
    rxBwKbps: number;
    tag: string;
    txBwKbps: number;
}

export interface GatewayInterfaceOverlaySettingDataUsageLimit {
    dataLimitMb: number;
    dataUsagePeriod: string;
    dataUsagePeriodStartDate: string;
}

export interface GatewayInterfaceProxyArpSetting {
    ipv4Address: string;
    ipv4Gateway: string;
    ipv4Mask: string;
    lanInterfaceName: string;
}

export interface GatewayInterfaceRadius {
    accountingPort: number;
    clientInterfaceName: string;
    clientIpv4: string;
    ipv4: string;
    name: string;
    port: number;
    secret: string;
}

export interface GatewayInterfaceVrrp {
    advertiseInterval: number;
    priority: number;
    state: string;
    virtualIpv4: string;
    virtualRouterId: number;
}

export interface GatewayInterfaceWifiProps {
    bridge: string;
    channel: number;
    countryCode: string;
    encryption?: outputs.GatewayInterfaceWifiPropsEncryption;
    freq: number;
    mode: string;
    ssid: string;
}

export interface GatewayInterfaceWifiPropsEncryption {
    key: string;
    protocol: string;
}

export interface GatewayModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface GatewayMqttConfiguration {
    deviceId: string;
    name: string;
    projectId: string;
    region: string;
    registry: string;
    topics?: outputs.GatewayMqttConfigurationTopic[];
}

export interface GatewayMqttConfigurationTopic {
    name: string;
    uri: string;
}

export interface GatewayOne2OneNatRule {
    biDirectional: boolean;
    lanIp: string;
    lanPort: number;
    name: string;
    publicIp: string;
    publicPort: number;
    upLinkIfName: string;
}

export interface GatewayOverlayConfiguration {
    ip: string;
    mask: string;
    routableAddresses?: outputs.GatewayOverlayConfigurationRoutableAddress[];
}

export interface GatewayOverlayConfigurationRoutableAddress {
    networkAddress: string;
    networkTag: string;
}

export interface GatewayPortForwardingNatRule {
    biDirectional: boolean;
    lanIp: string;
    lanPort: number;
    name: string;
    publicIp: string;
    publicPort: number;
    upLinkIfName: string;
}

export interface GatewayStaticRoute {
    advertise: boolean;
    cost: number;
    destination: string;
    device: string;
    install: boolean;
    nhop: string;
}

export interface GetGatewayAssignedPolicy {
    id: string;
    name: string;
}

export interface GetGatewayBgpConfiguration {
    bfdInterval: number;
    bfdMultiplier: number;
    bfdRecvInterval: number;
    isBfdEnabled: boolean;
    localAs: number;
    name: string;
    neighbor: string;
    remoteAs: number;
    routerId: string;
}

export interface GetGatewayCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetGatewayInterface {
    8021xMab: boolean;
    addresses?: outputs.GetGatewayInterfaceAddress[];
    allowedVlans: number[];
    bridgeMembers: string[];
    dhcpRelayServerSetting?: outputs.GetGatewayInterfaceDhcpRelayServerSetting;
    dhcpServerSetting?: outputs.GetGatewayInterfaceDhcpServerSetting;
    doAdvertise: boolean;
    enableNat: boolean;
    isDisabled: boolean;
    lteProps?: outputs.GetGatewayInterfaceLteProps;
    macAddr: string;
    mode: string;
    mtu: number;
    mtuDiscovery: string;
    name: string;
    overlaySetting?: outputs.GetGatewayInterfaceOverlaySetting;
    proxyArpSettings?: outputs.GetGatewayInterfaceProxyArpSetting[];
    radii?: outputs.GetGatewayInterfaceRadius[];
    type: string;
    vlan: number;
    vrrp?: outputs.GetGatewayInterfaceVrrp;
    wifiProps?: outputs.GetGatewayInterfaceWifiProps;
    zone: string;
}

export interface GetGatewayInterfaceAddress {
    address: string;
    addressAssignment: string;
    addressFamily: string;
    dnsPrimary: string;
    dnsSecondary: string;
    gateway: string;
    mask: string;
}

export interface GetGatewayInterfaceDhcpRelayServerSetting {
    relayServerIpLists: string[];
}

export interface GetGatewayInterfaceDhcpServerSetting {
    addressRanges?: outputs.GetGatewayInterfaceDhcpServerSettingAddressRange[];
    customOptions?: outputs.GetGatewayInterfaceDhcpServerSettingCustomOption[];
    dnsPrimary: string;
    dnsSecondary: string;
    leaseDuration: number;
    macAddressToIpv4Bindings?: outputs.GetGatewayInterfaceDhcpServerSettingMacAddressToIpv4Binding[];
    network: string;
}

export interface GetGatewayInterfaceDhcpServerSettingAddressRange {
    endIpv4: string;
    startIpv4: string;
}

export interface GetGatewayInterfaceDhcpServerSettingCustomOption {
    code: number;
    type: string;
    value: string;
}

export interface GetGatewayInterfaceDhcpServerSettingMacAddressToIpv4Binding {
    ipv4Address: string;
    macAddress: string;
    name: string;
}

export interface GetGatewayInterfaceLteProps {
    apn: string;
    isPrimary: boolean;
    password: string;
    userName: string;
}

export interface GetGatewayInterfaceOverlaySetting {
    bwMeasurementMode: string;
    dataUsageLimit?: outputs.GetGatewayInterfaceOverlaySettingDataUsageLimit;
    doCopyTos: boolean;
    isBackup: boolean;
    isMetered: boolean;
    rxBwKbps: number;
    tag: string;
    txBwKbps: number;
}

export interface GetGatewayInterfaceOverlaySettingDataUsageLimit {
    dataLimitMb: number;
    dataUsagePeriod: string;
    dataUsagePeriodStartDate: string;
}

export interface GetGatewayInterfaceProxyArpSetting {
    ipv4Address: string;
    ipv4Gateway: string;
    ipv4Mask: string;
    lanInterfaceName: string;
}

export interface GetGatewayInterfaceRadius {
    accountingPort: number;
    clientInterfaceName: string;
    clientIpv4: string;
    ipv4: string;
    name: string;
    port: number;
    secret: string;
}

export interface GetGatewayInterfaceVrrp {
    advertiseInterval: number;
    priority: number;
    state: string;
    virtualIpv4: string;
    virtualRouterId: number;
}

export interface GetGatewayInterfaceWifiProps {
    bridge: string;
    channel: number;
    countryCode: string;
    encryption?: outputs.GetGatewayInterfaceWifiPropsEncryption;
    freq: number;
    mode: string;
    ssid: string;
}

export interface GetGatewayInterfaceWifiPropsEncryption {
    key: string;
    protocol: string;
}

export interface GetGatewayModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetGatewayMqttConfiguration {
    deviceId: string;
    name: string;
    projectId: string;
    region: string;
    registry: string;
    topics?: outputs.GetGatewayMqttConfigurationTopic[];
}

export interface GetGatewayMqttConfigurationTopic {
    name: string;
    uri: string;
}

export interface GetGatewayOne2OneNatRule {
    biDirectional: boolean;
    lanIp: string;
    lanPort: number;
    name: string;
    publicIp: string;
    publicPort: number;
    upLinkIfName: string;
}

export interface GetGatewayOverlayConfiguration {
    ip: string;
    mask: string;
    routableAddresses?: outputs.GetGatewayOverlayConfigurationRoutableAddress[];
}

export interface GetGatewayOverlayConfigurationRoutableAddress {
    networkAddress: string;
    networkTag: string;
}

export interface GetGatewayPortForwardingNatRule {
    biDirectional: boolean;
    lanIp: string;
    lanPort: number;
    name: string;
    publicIp: string;
    publicPort: number;
    upLinkIfName: string;
}

export interface GetGatewayStaticRoute {
    advertise: boolean;
    cost: number;
    destination: string;
    device: string;
    install: boolean;
    nhop: string;
}

export interface GetPolicyConfig {
    pcfgCosTables?: outputs.GetPolicyConfigPcfgCosTable[];
    pcfgFirewall?: outputs.GetPolicyConfigPcfgFirewall;
    pcfgGeneralSettings?: outputs.GetPolicyConfigPcfgGeneralSettings;
    pcfgQosPolicies?: outputs.GetPolicyConfigPcfgQosPolicy[];
    pcfgSchemaver: number;
    pcfgSchemaverMinor: number;
    pcfgUrlFilter?: outputs.GetPolicyConfigPcfgUrlFilter;
}

export interface GetPolicyConfigPcfgCosTable {
    cosJitterMs: number;
    cosLastResort: boolean;
    cosLatencyMs: number;
    cosLlq: boolean;
    cosLossPercent: number;
    cosMinGuaranteeBwPercent: number;
    cosPriority: string;
    cosTrafficClass: string;
}

export interface GetPolicyConfigPcfgFirewall {
    pcfgFirewallEnabled: boolean;
    pcfgFwLogging?: outputs.GetPolicyConfigPcfgFirewallPcfgFwLogging;
    pcfgFwPolicies?: outputs.GetPolicyConfigPcfgFirewallPcfgFwPolicy[];
    pcfgFwStatefulEnabled: boolean;
}

export interface GetPolicyConfigPcfgFirewallPcfgFwLogging {
    pcfgFwAllowLogEnabled: boolean;
    pcfgFwDenyLogEnabled: boolean;
    pcfgFwLogEnabled: boolean;
}

export interface GetPolicyConfigPcfgFirewallPcfgFwPolicy {
    fwAction?: outputs.GetPolicyConfigPcfgFirewallPcfgFwPolicyFwAction;
    fwMatch?: outputs.GetPolicyConfigPcfgFirewallPcfgFwPolicyFwMatch;
    fwName: string;
}

export interface GetPolicyConfigPcfgFirewallPcfgFwPolicyFwAction {
    allowOrDeny: string;
    logging: boolean;
}

export interface GetPolicyConfigPcfgFirewallPcfgFwPolicyFwMatch {
    mtchAppIds: number[];
    mtchDestInternet: boolean;
    mtchDestIp: string;
    mtchDestPort: string;
    mtchDestZone: string;
    mtchDstVlan: number;
    mtchL4Protocol: string;
    mtchSrcIp: string;
    mtchSrcMac: string;
    mtchSrcPort: string;
    mtchSrcVlan: number;
    mtchSrcZone: string;
}

export interface GetPolicyConfigPcfgGeneralSettings {
    pcfgNetflow?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgNetflow;
    pcfgSnmpTraps?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgSnmpTrap[];
    pcfgSnmps?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgSnmp[];
    pcfgSyslogEnabled: boolean;
    pcfgSyslogServers?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgSyslogServer[];
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgNetflow {
    pcfgNfEnabled: boolean;
    pcfgNfExporterSettings?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettings;
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettings {
    nfCollectorSettings?: outputs.GetPolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettingsNfCollectorSetting[];
    nfExportInterval: number;
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettingsNfCollectorSetting {
    nfIp: string;
    nfPort: number;
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgSnmp {
    snmpAllowedIp: string;
    snmpCommunity: string;
    snmpVersion: string;
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgSnmpTrap {
    snmptCommunity: string;
    snmptPort: number;
    snmptServer: string;
}

export interface GetPolicyConfigPcfgGeneralSettingsPcfgSyslogServer {
    applications: string[];
    facility: string;
    format: string;
    port: number;
    protocol: string;
    serverIp: string;
    sourceInterface: string;
    tag: string;
}

export interface GetPolicyConfigPcfgQosPolicy {
    qosAction?: outputs.GetPolicyConfigPcfgQosPolicyQosAction;
    qosMatch?: outputs.GetPolicyConfigPcfgQosPolicyQosMatch;
}

export interface GetPolicyConfigPcfgQosPolicyQosAction {
    firewallAction?: outputs.GetPolicyConfigPcfgQosPolicyQosActionFirewallAction;
    linkSteeringAction?: outputs.GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringAction;
    pbrAction?: outputs.GetPolicyConfigPcfgQosPolicyQosActionPbrAction;
    schedAction?: outputs.GetPolicyConfigPcfgQosPolicyQosActionSchedAction;
    trafficAction?: outputs.GetPolicyConfigPcfgQosPolicyQosActionTrafficAction;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionFirewallAction {
    allowOrDeny: string;
    logging: boolean;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringAction {
    lnksAlgo: string;
    lnksInterface: string;
    lnksLinkSteeringMode: string;
    lnksVia?: outputs.GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksVia;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksVia {
    actives?: outputs.GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaActive[];
    backups?: outputs.GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaBackup[];
}

export interface GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaActive {
    lnksWan: string;
    path: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaBackup {
    lnksWan: string;
    path: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionPbrAction {
    pbrNextHop: string;
    pbrNextHopSite: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionSchedAction {
    schDropAlgo: string;
    schQueueLimitBytes: number;
    schRateLimitEnable: boolean;
    schRxRateLimitKbps: number;
    schTxRateLimitKbps: number;
    schTxRateLimitType: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosActionTrafficAction {
    class: string;
    priority: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosMatch {
    cmapMatchCriteria?: outputs.GetPolicyConfigPcfgQosPolicyQosMatchCmapMatchCriteria;
    cmapMatchType: string;
    cmapName: string;
}

export interface GetPolicyConfigPcfgQosPolicyQosMatchCmapMatchCriteria {
    mtchAppIds: number[];
    mtchDestInternet: boolean;
    mtchDestIp: string;
    mtchDestPort: string;
    mtchDestZone: string;
    mtchDstVlan: number;
    mtchL4Protocol: string;
    mtchSrcIp: string;
    mtchSrcMac: string;
    mtchSrcPort: string;
    mtchSrcVlan: number;
    mtchSrcZone: string;
}

export interface GetPolicyConfigPcfgUrlFilter {
    pcfgUfAllowlists: string[];
    pcfgUfBlockedCategories: number[];
    pcfgUfBlocklists: string[];
    pcfgUfEnabled: boolean;
    pcfgUfReputationThreshold: string;
}

export interface GetPolicyCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetPolicyHub {
    id: string;
    name: string;
    overlayIp: string;
}

export interface GetPolicyModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetTenantCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetTenantModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetUserCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface GetUserModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface PolicyConfig {
    pcfgCosTables?: outputs.PolicyConfigPcfgCosTable[];
    pcfgFirewall?: outputs.PolicyConfigPcfgFirewall;
    pcfgGeneralSettings?: outputs.PolicyConfigPcfgGeneralSettings;
    pcfgQosPolicies?: outputs.PolicyConfigPcfgQosPolicy[];
    pcfgSchemaver: number;
    pcfgSchemaverMinor: number;
    pcfgUrlFilter?: outputs.PolicyConfigPcfgUrlFilter;
}

export interface PolicyConfigPcfgCosTable {
    cosJitterMs: number;
    cosLastResort: boolean;
    cosLatencyMs: number;
    cosLlq: boolean;
    cosLossPercent: number;
    cosMinGuaranteeBwPercent: number;
    cosPriority: string;
    cosTrafficClass: string;
}

export interface PolicyConfigPcfgFirewall {
    pcfgFirewallEnabled: boolean;
    pcfgFwLogging?: outputs.PolicyConfigPcfgFirewallPcfgFwLogging;
    pcfgFwPolicies?: outputs.PolicyConfigPcfgFirewallPcfgFwPolicy[];
    pcfgFwStatefulEnabled: boolean;
}

export interface PolicyConfigPcfgFirewallPcfgFwLogging {
    pcfgFwAllowLogEnabled: boolean;
    pcfgFwDenyLogEnabled: boolean;
    pcfgFwLogEnabled: boolean;
}

export interface PolicyConfigPcfgFirewallPcfgFwPolicy {
    fwAction?: outputs.PolicyConfigPcfgFirewallPcfgFwPolicyFwAction;
    fwMatch?: outputs.PolicyConfigPcfgFirewallPcfgFwPolicyFwMatch;
    fwName: string;
}

export interface PolicyConfigPcfgFirewallPcfgFwPolicyFwAction {
    allowOrDeny: string;
    logging: boolean;
}

export interface PolicyConfigPcfgFirewallPcfgFwPolicyFwMatch {
    mtchAppIds: number[];
    mtchDestInternet: boolean;
    mtchDestIp: string;
    mtchDestPort: string;
    mtchDestZone: string;
    mtchDstVlan: number;
    mtchL4Protocol: string;
    mtchSrcIp: string;
    mtchSrcMac: string;
    mtchSrcPort: string;
    mtchSrcVlan: number;
    mtchSrcZone: string;
}

export interface PolicyConfigPcfgGeneralSettings {
    pcfgNetflow?: outputs.PolicyConfigPcfgGeneralSettingsPcfgNetflow;
    pcfgSnmpTraps?: outputs.PolicyConfigPcfgGeneralSettingsPcfgSnmpTrap[];
    pcfgSnmps?: outputs.PolicyConfigPcfgGeneralSettingsPcfgSnmp[];
    pcfgSyslogEnabled: boolean;
    pcfgSyslogServers?: outputs.PolicyConfigPcfgGeneralSettingsPcfgSyslogServer[];
}

export interface PolicyConfigPcfgGeneralSettingsPcfgNetflow {
    pcfgNfEnabled: boolean;
    pcfgNfExporterSettings?: outputs.PolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettings;
}

export interface PolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettings {
    nfCollectorSettings?: outputs.PolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettingsNfCollectorSetting[];
    nfExportInterval: number;
}

export interface PolicyConfigPcfgGeneralSettingsPcfgNetflowPcfgNfExporterSettingsNfCollectorSetting {
    nfIp: string;
    nfPort: number;
}

export interface PolicyConfigPcfgGeneralSettingsPcfgSnmp {
    snmpAllowedIp: string;
    snmpCommunity: string;
    snmpVersion: string;
}

export interface PolicyConfigPcfgGeneralSettingsPcfgSnmpTrap {
    snmptCommunity: string;
    snmptPort: number;
    snmptServer: string;
}

export interface PolicyConfigPcfgGeneralSettingsPcfgSyslogServer {
    applications: string[];
    facility: string;
    format: string;
    port: number;
    protocol: string;
    serverIp: string;
    sourceInterface: string;
    tag: string;
}

export interface PolicyConfigPcfgQosPolicy {
    qosAction?: outputs.PolicyConfigPcfgQosPolicyQosAction;
    qosMatch?: outputs.PolicyConfigPcfgQosPolicyQosMatch;
}

export interface PolicyConfigPcfgQosPolicyQosAction {
    firewallAction?: outputs.PolicyConfigPcfgQosPolicyQosActionFirewallAction;
    linkSteeringAction?: outputs.PolicyConfigPcfgQosPolicyQosActionLinkSteeringAction;
    pbrAction?: outputs.PolicyConfigPcfgQosPolicyQosActionPbrAction;
    schedAction?: outputs.PolicyConfigPcfgQosPolicyQosActionSchedAction;
    trafficAction?: outputs.PolicyConfigPcfgQosPolicyQosActionTrafficAction;
}

export interface PolicyConfigPcfgQosPolicyQosActionFirewallAction {
    allowOrDeny: string;
    logging: boolean;
}

export interface PolicyConfigPcfgQosPolicyQosActionLinkSteeringAction {
    lnksAlgo: string;
    lnksInterface: string;
    lnksLinkSteeringMode: string;
    lnksVia?: outputs.PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksVia;
}

export interface PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksVia {
    actives?: outputs.PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaActive[];
    backups?: outputs.PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaBackup[];
}

export interface PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaActive {
    lnksWan: string;
    path: string;
}

export interface PolicyConfigPcfgQosPolicyQosActionLinkSteeringActionLnksViaBackup {
    lnksWan: string;
    path: string;
}

export interface PolicyConfigPcfgQosPolicyQosActionPbrAction {
    pbrNextHop: string;
    pbrNextHopSite: string;
}

export interface PolicyConfigPcfgQosPolicyQosActionSchedAction {
    schDropAlgo: string;
    schQueueLimitBytes: number;
    schRateLimitEnable: boolean;
    schRxRateLimitKbps: number;
    schTxRateLimitKbps: number;
    schTxRateLimitType: string;
}

export interface PolicyConfigPcfgQosPolicyQosActionTrafficAction {
    class: string;
    priority: string;
}

export interface PolicyConfigPcfgQosPolicyQosMatch {
    cmapMatchCriteria?: outputs.PolicyConfigPcfgQosPolicyQosMatchCmapMatchCriteria;
    cmapMatchType: string;
    cmapName: string;
}

export interface PolicyConfigPcfgQosPolicyQosMatchCmapMatchCriteria {
    mtchAppIds: number[];
    mtchDestInternet: boolean;
    mtchDestIp: string;
    mtchDestPort: string;
    mtchDestZone: string;
    mtchDstVlan: number;
    mtchL4Protocol: string;
    mtchSrcIp: string;
    mtchSrcMac: string;
    mtchSrcPort: string;
    mtchSrcVlan: number;
    mtchSrcZone: string;
}

export interface PolicyConfigPcfgUrlFilter {
    pcfgUfAllowlists: string[];
    pcfgUfBlockedCategories: number[];
    pcfgUfBlocklists: string[];
    pcfgUfEnabled: boolean;
    pcfgUfReputationThreshold: string;
}

export interface PolicyCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface PolicyHub {
    id: string;
    name: string;
    overlayIp: string;
}

export interface PolicyModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface TenantCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface TenantModifiedBy {
    email: string;
    id: string;
    name: string;
}

export interface UserCreatedBy {
    email: string;
    id: string;
    name: string;
}

export interface UserModifiedBy {
    email: string;
    id: string;
    name: string;
}

