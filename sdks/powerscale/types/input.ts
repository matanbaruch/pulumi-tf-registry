// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccesszoneIfsRestricted {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface ClusterEmailSettings {
    /**
     * This setting determines how notifications will be batched together to be sent by email.  'none' means each notification will be sent separately.  'severity' means notifications of the same severity will be sent together.  'category' means notifications of the same category will be sent together.  'all' means all notifications will be batched together and sent in a single email.
     */
    batchMode?: pulumi.Input<string>;
    /**
     * The address of the SMTP server to be used for relaying the notification messages.  An SMTP server is required in order to send notifications.  If this string is empty, no emails will be sent.
     */
    mailRelay?: pulumi.Input<string>;
    /**
     * The full email address that will appear as the sender of notification messages.
     */
    mailSender?: pulumi.Input<string>;
    /**
     * The subject line for notification messages from this cluster.
     */
    mailSubject?: pulumi.Input<string>;
    /**
     * Password to authenticate with if SMTP authentication is being used.
     */
    smtpAuthPasswd?: pulumi.Input<string>;
    /**
     * Indicates if an SMTP authentication password is set.
     */
    smtpAuthPasswdSet?: pulumi.Input<boolean>;
    /**
     * The type of secure communication protocol to use if SMTP is being used.  If 'none', plain text will be used, if 'starttls', the encrypted STARTTLS protocol will be used.
     */
    smtpAuthSecurity?: pulumi.Input<string>;
    /**
     * Username to authenticate with if SMTP authentication is being used.
     */
    smtpAuthUsername?: pulumi.Input<string>;
    /**
     * The port on the SMTP server to be used for relaying the notification messages.
     */
    smtpPort?: pulumi.Input<number>;
    /**
     * If true, this cluster will send SMTP authentication credentials to the SMTP relay server in order to send its notification emails.  If false, the cluster will attempt to send its notification emails without authentication.
     */
    useSmtpAuth?: pulumi.Input<boolean>;
    /**
     * Location of a custom template file that can be used to specify the layout of the notification emails.  If this string is empty, the default template will be used.
     */
    userTemplate?: pulumi.Input<string>;
}

export interface FilepoolPolicyAction {
    /**
     * action_type Acceptable values: set_requested_protection, set_data_access_pattern, enable_coalescer, apply_data_storage_policy, apply_snapshot_storage_policy, set_cloudpool_policy, enable_packing.
     */
    actionType: pulumi.Input<string>;
    /**
     * Action for set_cloudpool_policy type.
     */
    cloudpoolPolicyAction?: pulumi.Input<inputs.FilepoolPolicyActionCloudpoolPolicyAction>;
    /**
     * Action for set_data_access_pattern type. Set data access pattern optimization. Acceptable values: random, concurrency, streaming.
     */
    dataAccessPatternAction?: pulumi.Input<string>;
    /**
     * Action for apply_data_storage_policy.
     */
    dataStoragePolicyAction?: pulumi.Input<inputs.FilepoolPolicyActionDataStoragePolicyAction>;
    /**
     * Action for enable_coalescer type. Set write performance optimization. True to enable SmartCache action.
     */
    enableCoalescerAction?: pulumi.Input<boolean>;
    /**
     * Action for enable_packing type. True to enable enable_packing action.
     */
    enablePackingAction?: pulumi.Input<boolean>;
    /**
     * Action for set_requested_protection type. Acceptable values: default, +1n, +2d:1n, +2n, +3d:1n, +3d:1n1d, +3n, +4d:1n, +4d:2n, +4n, 2x, 3x, 4x, 5x, 6x, 7x, 8x.
     */
    requestedProtectionAction?: pulumi.Input<string>;
    /**
     * Action for apply_snapshot_storage_policy.
     */
    snapshotStoragePolicyAction?: pulumi.Input<inputs.FilepoolPolicyActionSnapshotStoragePolicyAction>;
}

export interface FilepoolPolicyActionCloudpoolPolicyAction {
    /**
     * Specifies if files with snapshots should be archived.
     */
    archiveSnapshotFiles?: pulumi.Input<boolean>;
    /**
     * Specifies default cloudpool cache settings for new filepool policies.
     */
    cache?: pulumi.Input<inputs.FilepoolPolicyActionCloudpoolPolicyActionCache>;
    /**
     * Specifies if files should be compressed.
     */
    compression?: pulumi.Input<boolean>;
    /**
     * Specifies the minimum amount of time archived data will be retained in the cloud after deletion.
     */
    dataRetention?: pulumi.Input<number>;
    /**
     * Specifies if files should be encrypted.
     */
    encryption?: pulumi.Input<boolean>;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a full NDMP backup. (Used with NDMP backups only.  Not applicable to SyncIQ.)
     */
    fullBackupRetention?: pulumi.Input<number>;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a SyncIQ backup or an incremental NDMP backup. (Used with SyncIQ and NDMP backups.)
     */
    incrementalBackupRetention?: pulumi.Input<number>;
    /**
     * Specifies the cloudPool storage target.
     */
    pool: pulumi.Input<string>;
    /**
     * The minimum amount of time to wait before updating cloud data with local changes.
     */
    writebackFrequency?: pulumi.Input<number>;
}

export interface FilepoolPolicyActionCloudpoolPolicyActionCache {
    /**
     * Specifies cache expiration.
     */
    expiration?: pulumi.Input<number>;
    /**
     * Specifies cache read ahead type. Acceptable values: partial, full.
     */
    readAhead?: pulumi.Input<string>;
    /**
     * Specifies cache type. Acceptable values: cached, no-cache.
     */
    type?: pulumi.Input<string>;
}

export interface FilepoolPolicyActionDataStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: pulumi.Input<string>;
    /**
     * Specifies the storage target.
     */
    storagepool: pulumi.Input<string>;
}

export interface FilepoolPolicyActionSnapshotStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: pulumi.Input<string>;
    /**
     * Specifies the snapshot storage target.
     */
    storagepool: pulumi.Input<string>;
}

export interface FilepoolPolicyFileMatchingPattern {
    /**
     * List of or_criteria file matching rules for this policy.
     */
    orCriterias: pulumi.Input<pulumi.Input<inputs.FilepoolPolicyFileMatchingPatternOrCriteria>[]>;
}

export interface FilepoolPolicyFileMatchingPatternOrCriteria {
    /**
     * List of and_criteria file matching rules for this policy.
     */
    andCriterias: pulumi.Input<pulumi.Input<inputs.FilepoolPolicyFileMatchingPatternOrCriteriaAndCriteria>[]>;
}

export interface FilepoolPolicyFileMatchingPatternOrCriteriaAndCriteria {
    /**
     * Indicates whether the existence of an attribute indicates a match (valid only with 'type' = 'custom_attribute').
     */
    attributeExists?: pulumi.Input<boolean>;
    /**
     * True to match the path exactly, False to match any subtree. (valid only with 'type' = 'path').
     */
    beginsWith?: pulumi.Input<boolean>;
    /**
     * True to indicate case sensitivity when comparing file attributes (valid only with 'type' = 'name' or 'type' = 'path').
     */
    caseSensitive?: pulumi.Input<boolean>;
    /**
     * File attribute field name to be compared in a custom comparison (valid only with 'type' = 'custom_attribute').
     */
    field?: pulumi.Input<string>;
    /**
     * The comparison operator to use while comparing an attribute with its value.
     */
    operator?: pulumi.Input<string>;
    /**
     * The file attribute to be compared to a given value.
     */
    type: pulumi.Input<string>;
    /**
     * Size unit value. One of 'B','KB','MB','GB','TB','PB','EB' (valid only with 'type' = 'size').
     */
    units?: pulumi.Input<string>;
    /**
     * Whether time units refer to a calendar date and time (e.g., Jun 3, 2009) or a relative duration (e.g., 2 weeks) (valid only with 'type' in {accessed_time, birth_time, changed_time or metadata_changed_time}.
     */
    useRelativeTime?: pulumi.Input<boolean>;
    /**
     * The value to be compared against a file attribute.
     */
    value?: pulumi.Input<string>;
}

export interface FilesystemGroup {
    /**
     * group identifier
     */
    id?: pulumi.Input<string>;
    /**
     * group name
     */
    name?: pulumi.Input<string>;
    /**
     * group type
     */
    type?: pulumi.Input<string>;
}

export interface FilesystemOwner {
    /**
     * Owner identifier
     */
    id?: pulumi.Input<string>;
    /**
     * Owner name
     */
    name?: pulumi.Input<string>;
    /**
     * Owner type
     */
    type?: pulumi.Input<string>;
}

export interface GetAccesszoneFilter {
    names?: string[];
}

export interface GetAccesszoneFilterArgs {
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetAdsproviderFilter {
    /**
     * Filter ads providers by names.
     */
    names?: string[];
    /**
     * Filter ads providers by scope.
     */
    scope?: string;
}

export interface GetAdsproviderFilterArgs {
    /**
     * Filter ads providers by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Filter ads providers by scope.
     */
    scope?: pulumi.Input<string>;
}

export interface GetFilepoolPolicyFilter {
    names?: string[];
}

export interface GetFilepoolPolicyFilterArgs {
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetFilesystemFileSystemsDetails {
    /**
     * FileSystems Attributes
     */
    fileSystemAttributes?: inputs.GetFilesystemFileSystemsDetailsFileSystemAttribute[];
    /**
     * Filesystem acl. Shows the access control list for the FileSystem(Namespace directory)
     */
    fileSystemNamespaceAcl?: inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAcl;
    /**
     * Filesystem quotas
     */
    fileSystemQuotas?: inputs.GetFilesystemFileSystemsDetailsFileSystemQuota[];
    /**
     * Filesystem snapshots
     */
    fileSystemSnapshots?: inputs.GetFilesystemFileSystemsDetailsFileSystemSnapshot[];
}

export interface GetFilesystemFileSystemsDetailsArgs {
    /**
     * FileSystems Attributes
     */
    fileSystemAttributes?: pulumi.Input<pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemAttributeArgs>[]>;
    /**
     * Filesystem acl. Shows the access control list for the FileSystem(Namespace directory)
     */
    fileSystemNamespaceAcl?: pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclArgs>;
    /**
     * Filesystem quotas
     */
    fileSystemQuotas?: pulumi.Input<pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemQuotaArgs>[]>;
    /**
     * Filesystem snapshots
     */
    fileSystemSnapshots?: pulumi.Input<pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemSnapshotArgs>[]>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemAttribute {
    /**
     * Attribute name
     */
    name?: string;
    /**
     * Attribute namespace
     */
    namespace?: string;
    /**
     * Attribute value
     */
    value?: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemAttributeArgs {
    /**
     * Attribute name
     */
    name?: pulumi.Input<string>;
    /**
     * Attribute namespace
     */
    namespace?: pulumi.Input<string>;
    /**
     * Attribute value
     */
    value?: pulumi.Input<string>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAcl {
    /**
     * Filesystem Access Control List
     */
    acls?: inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAcl[];
    /**
     * Acl action
     */
    action?: string;
    /**
     * Acl authoritative
     */
    authoritative?: string;
    /**
     * ACL group
     */
    group?: inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroup;
    /**
     * Acl mode
     */
    mode?: string;
    /**
     * ACL owner
     */
    owner?: inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwner;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclArgs {
    /**
     * Filesystem Access Control List
     */
    acls?: pulumi.Input<pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclArgs>[]>;
    /**
     * Acl action
     */
    action?: pulumi.Input<string>;
    /**
     * Acl authoritative
     */
    authoritative?: pulumi.Input<string>;
    /**
     * ACL group
     */
    group?: pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroupArgs>;
    /**
     * Acl mode
     */
    mode?: pulumi.Input<string>;
    /**
     * ACL owner
     */
    owner?: pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwnerArgs>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAcl {
    /**
     * Access rights
     */
    accessRights?: string[];
    /**
     * Access type
     */
    accessType?: string;
    /**
     * Inherit flags
     */
    inheritFlags?: string[];
    /**
     * Op
     */
    op?: string;
    /**
     * Trustee
     */
    trustee?: inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrustee;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclArgs {
    /**
     * Access rights
     */
    accessRights?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Access type
     */
    accessType?: pulumi.Input<string>;
    /**
     * Inherit flags
     */
    inheritFlags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Op
     */
    op?: pulumi.Input<string>;
    /**
     * Trustee
     */
    trustee?: pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrusteeArgs>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrustee {
    /**
     * Trustee identifier
     */
    id?: string;
    /**
     * Trustee name
     */
    name?: string;
    /**
     * Trustee type
     */
    type?: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrusteeArgs {
    /**
     * Trustee identifier
     */
    id?: pulumi.Input<string>;
    /**
     * Trustee name
     */
    name?: pulumi.Input<string>;
    /**
     * Trustee type
     */
    type?: pulumi.Input<string>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroup {
    /**
     * Group identifier
     */
    id?: string;
    /**
     * Group name
     */
    name?: string;
    /**
     * Group type
     */
    type?: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroupArgs {
    /**
     * Group identifier
     */
    id?: pulumi.Input<string>;
    /**
     * Group name
     */
    name?: pulumi.Input<string>;
    /**
     * Group type
     */
    type?: pulumi.Input<string>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwner {
    /**
     * Owner identifier
     */
    id?: string;
    /**
     * Owner name
     */
    name?: string;
    /**
     * Owner type
     */
    type?: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwnerArgs {
    /**
     * Owner identifier
     */
    id?: pulumi.Input<string>;
    /**
     * Owner name
     */
    name?: pulumi.Input<string>;
    /**
     * Owner type
     */
    type?: pulumi.Input<string>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuota {
    /**
     * If true, SMB shares using the quota directory see the quota thresholds as share size.
     */
    container?: boolean;
    /**
     * True if the quota provides enforcement, otherwise a accounting quota.
     */
    enforced?: boolean;
    /**
     * Quota Id
     */
    id?: string;
    /**
     * The path of quota.
     */
    path?: string;
    /**
     * The type of quota.
     */
    type?: string;
    /**
     * Usage
     */
    usage?: inputs.GetFilesystemFileSystemsDetailsFileSystemQuotaUsage;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuotaArgs {
    /**
     * If true, SMB shares using the quota directory see the quota thresholds as share size.
     */
    container?: pulumi.Input<boolean>;
    /**
     * True if the quota provides enforcement, otherwise a accounting quota.
     */
    enforced?: pulumi.Input<boolean>;
    /**
     * Quota Id
     */
    id?: pulumi.Input<string>;
    /**
     * The path of quota.
     */
    path?: pulumi.Input<string>;
    /**
     * The type of quota.
     */
    type?: pulumi.Input<string>;
    /**
     * Usage
     */
    usage?: pulumi.Input<inputs.GetFilesystemFileSystemsDetailsFileSystemQuotaUsageArgs>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuotaUsage {
    /**
     * Bytes used by governed data apparent to application
     */
    applogical?: number;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady?: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical?: number;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady?: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fsphysical?: number;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady?: boolean;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes?: number;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady?: boolean;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical?: number;
    /**
     * Number of physical blocks for file data
     */
    physicalData?: number;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady?: boolean;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection?: number;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady?: boolean;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady?: boolean;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs?: number;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady?: boolean;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuotaUsageArgs {
    /**
     * Bytes used by governed data apparent to application
     */
    applogical?: pulumi.Input<number>;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady?: pulumi.Input<boolean>;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical?: pulumi.Input<number>;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady?: pulumi.Input<boolean>;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fsphysical?: pulumi.Input<number>;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady?: pulumi.Input<boolean>;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes?: pulumi.Input<number>;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady?: pulumi.Input<boolean>;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical?: pulumi.Input<number>;
    /**
     * Number of physical blocks for file data
     */
    physicalData?: pulumi.Input<number>;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady?: pulumi.Input<boolean>;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection?: pulumi.Input<number>;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady?: pulumi.Input<boolean>;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady?: pulumi.Input<boolean>;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs?: pulumi.Input<number>;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady?: pulumi.Input<boolean>;
}

export interface GetFilesystemFileSystemsDetailsFileSystemSnapshot {
    /**
     * The name of the alias, none for real snapshots.
     */
    alias?: string;
    /**
     * The Unix Epoch time the snapshot was created.
     */
    created?: number;
    /**
     * The Unix Epoch time the snapshot will expire and be eligible for automatic deletion.
     */
    expires?: number;
    /**
     * True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of locks.
     */
    hasLocks?: boolean;
    /**
     * The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
     */
    id?: number;
    /**
     * The user or system supplied snapshot name. This will be null for snapshots pending delete.
     */
    name?: string;
    /**
     * The /ifs path snapshotted.
     */
    path?: string;
    /**
     * Percentage of /ifs used for storing this snapshot.
     */
    pctFilesystem?: number;
    /**
     * Percentage of configured snapshot reserved used for storing this snapshot.
     */
    pctReserve?: number;
    /**
     * The name of the schedule used to create this snapshot, if applicable.
     */
    schedule?: string;
    /**
     * The amount of shadow bytes referred to by this snapshot.
     */
    shadowBytes?: number;
    /**
     * The amount of storage in bytes used to store this snapshot.
     */
    size?: number;
    /**
     * Snapshot state.
     */
    state?: string;
    /**
     * The ID of the snapshot pointed to if this is an alias. 18446744073709551615 (max uint64) is returned for an alias to the live filesystem.
     */
    targetId?: number;
    /**
     * The name of the snapshot pointed to if this is an alias.
     */
    targetName?: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemSnapshotArgs {
    /**
     * The name of the alias, none for real snapshots.
     */
    alias?: pulumi.Input<string>;
    /**
     * The Unix Epoch time the snapshot was created.
     */
    created?: pulumi.Input<number>;
    /**
     * The Unix Epoch time the snapshot will expire and be eligible for automatic deletion.
     */
    expires?: pulumi.Input<number>;
    /**
     * True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of locks.
     */
    hasLocks?: pulumi.Input<boolean>;
    /**
     * The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
     */
    id?: pulumi.Input<number>;
    /**
     * The user or system supplied snapshot name. This will be null for snapshots pending delete.
     */
    name?: pulumi.Input<string>;
    /**
     * The /ifs path snapshotted.
     */
    path?: pulumi.Input<string>;
    /**
     * Percentage of /ifs used for storing this snapshot.
     */
    pctFilesystem?: pulumi.Input<number>;
    /**
     * Percentage of configured snapshot reserved used for storing this snapshot.
     */
    pctReserve?: pulumi.Input<number>;
    /**
     * The name of the schedule used to create this snapshot, if applicable.
     */
    schedule?: pulumi.Input<string>;
    /**
     * The amount of shadow bytes referred to by this snapshot.
     */
    shadowBytes?: pulumi.Input<number>;
    /**
     * The amount of storage in bytes used to store this snapshot.
     */
    size?: pulumi.Input<number>;
    /**
     * Snapshot state.
     */
    state?: pulumi.Input<string>;
    /**
     * The ID of the snapshot pointed to if this is an alias. 18446744073709551615 (max uint64) is returned for an alias to the live filesystem.
     */
    targetId?: pulumi.Input<number>;
    /**
     * The name of the snapshot pointed to if this is an alias.
     */
    targetName?: pulumi.Input<string>;
}

export interface GetGroupnetFilter {
    names?: string[];
}

export interface GetGroupnetFilterArgs {
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetLdapProviderFilter {
    names?: string[];
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
}

export interface GetLdapProviderFilterArgs {
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
}

export interface GetNamespaceAclFilter {
    /**
     * Indicate the namespace to set/get acl.
     */
    namespace: string;
    /**
     * Indicates that the operation is on the access point instead of the store path.
     */
    nsaccess?: boolean;
}

export interface GetNamespaceAclFilterArgs {
    /**
     * Indicate the namespace to set/get acl.
     */
    namespace: pulumi.Input<string>;
    /**
     * Indicates that the operation is on the access point instead of the store path.
     */
    nsaccess?: pulumi.Input<boolean>;
}

export interface GetNetworkRuleFilter {
    /**
     * If specified, only rules for this groupnet will be returned.
     */
    groupnet?: string;
    /**
     * Filter network rules by names.
     */
    names?: string[];
    /**
     * If specified, only rules for this pool will be returned.
     */
    pool?: string;
    /**
     * If specified, only rules for this subnet will be returned.
     */
    subnet?: string;
}

export interface GetNetworkRuleFilterArgs {
    /**
     * If specified, only rules for this groupnet will be returned.
     */
    groupnet?: pulumi.Input<string>;
    /**
     * Filter network rules by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If specified, only rules for this pool will be returned.
     */
    pool?: pulumi.Input<string>;
    /**
     * If specified, only rules for this subnet will be returned.
     */
    subnet?: pulumi.Input<string>;
}

export interface GetNetworkpoolFilter {
    /**
     * If specified, only pools with this zone name will be returned.
     */
    accessZone?: string;
    /**
     * If specified, only pools with this allocation type will be returned.
     */
    allocMethod?: string;
    /**
     * If specified, only pools for this groupnet will be returned.
     */
    groupnet?: string;
    /**
     * Filter network pools by names.
     */
    names?: string[];
    /**
     * If specified, only pools for this subnet will be returned.
     */
    subnet?: string;
}

export interface GetNetworkpoolFilterArgs {
    /**
     * If specified, only pools with this zone name will be returned.
     */
    accessZone?: pulumi.Input<string>;
    /**
     * If specified, only pools with this allocation type will be returned.
     */
    allocMethod?: pulumi.Input<string>;
    /**
     * If specified, only pools for this groupnet will be returned.
     */
    groupnet?: pulumi.Input<string>;
    /**
     * Filter network pools by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If specified, only pools for this subnet will be returned.
     */
    subnet?: pulumi.Input<string>;
}

export interface GetNfsExportFilter {
    /**
     * Check for conflicts when listing exports.
     */
    check?: boolean;
    /**
     * The direction of the sort.
     */
    dir?: string;
    /**
     * IDs to filter nfs exports.
     */
    ids?: number[];
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: number;
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: number;
    /**
     * If specified, only exports that explicitly reference at least one of the given paths will be returned.
     */
    path?: string;
    /**
     * Paths to filter nfs exports.
     */
    paths?: string[];
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: string;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * The field that will be used for sorting.
     */
    sort?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetNfsExportFilterArgs {
    /**
     * Check for conflicts when listing exports.
     */
    check?: pulumi.Input<boolean>;
    /**
     * The direction of the sort.
     */
    dir?: pulumi.Input<string>;
    /**
     * IDs to filter nfs exports.
     */
    ids?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: pulumi.Input<number>;
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: pulumi.Input<number>;
    /**
     * If specified, only exports that explicitly reference at least one of the given paths will be returned.
     */
    path?: pulumi.Input<string>;
    /**
     * Paths to filter nfs exports.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: pulumi.Input<string>;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
    /**
     * The field that will be used for sorting.
     */
    sort?: pulumi.Input<string>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetNfsExportSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetNfsExportSettingsFilterArgs {
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetNfsZoneSettingsFilter {
    /**
     * Access zone
     */
    zone?: string;
}

export interface GetNfsZoneSettingsFilterArgs {
    /**
     * Access zone
     */
    zone?: pulumi.Input<string>;
}

export interface GetNtpserverFilter {
    /**
     * Filter NTP Servers by names.
     */
    names?: string[];
}

export interface GetNtpserverFilterArgs {
    /**
     * Filter NTP Servers by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetQuotaFilter {
    /**
     * Only list quotas with this enforcement (non-accounting).
     */
    enforced?: boolean;
    /**
     * Set to true to only list quotas which have exceeded one or more of their thresholds.
     */
    exceeded?: boolean;
    /**
     * Only list quotas with this setting for include_snapshots.
     */
    includeSnapshots?: boolean;
    /**
     * Only list quotas matching this path (see also recurse_path_*).
     */
    path?: string;
    /**
     * Only list user or group quotas matching this persona (must be used with the corresponding type argument).
     */
    persona?: string;
    /**
     * If used with the path argument, match all quotas at that path or any descendent sub-directory.
     */
    recursePathChildren?: boolean;
    /**
     * If used with the path argument, match all quotas at that path or any parent directory.
     */
    recursePathParents?: boolean;
    /**
     * Use the named report as a source rather than the live quotas.
     */
    reportId?: string;
    /**
     * Only list quotas matching this type.
     */
    type?: string;
    /**
     * Optional named zone to use for user and group resolution.
     */
    zone?: string;
}

export interface GetQuotaFilterArgs {
    /**
     * Only list quotas with this enforcement (non-accounting).
     */
    enforced?: pulumi.Input<boolean>;
    /**
     * Set to true to only list quotas which have exceeded one or more of their thresholds.
     */
    exceeded?: pulumi.Input<boolean>;
    /**
     * Only list quotas with this setting for include_snapshots.
     */
    includeSnapshots?: pulumi.Input<boolean>;
    /**
     * Only list quotas matching this path (see also recurse_path_*).
     */
    path?: pulumi.Input<string>;
    /**
     * Only list user or group quotas matching this persona (must be used with the corresponding type argument).
     */
    persona?: pulumi.Input<string>;
    /**
     * If used with the path argument, match all quotas at that path or any descendent sub-directory.
     */
    recursePathChildren?: pulumi.Input<boolean>;
    /**
     * If used with the path argument, match all quotas at that path or any parent directory.
     */
    recursePathParents?: pulumi.Input<boolean>;
    /**
     * Use the named report as a source rather than the live quotas.
     */
    reportId?: pulumi.Input<string>;
    /**
     * Only list quotas matching this type.
     */
    type?: pulumi.Input<string>;
    /**
     * Optional named zone to use for user and group resolution.
     */
    zone?: pulumi.Input<string>;
}

export interface GetRoleFilter {
    /**
     * Filter roles by names.
     */
    names?: string[];
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetRoleFilterArgs {
    /**
     * Filter roles by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetRoleprivilegeFilter {
    /**
     * Filter Role Privileges by names.
     */
    names?: string[];
}

export interface GetRoleprivilegeFilterArgs {
    /**
     * Filter Role Privileges by names.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetS3BucketFilter {
    /**
     * Specifies the name of the owner.
     */
    owner?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetS3BucketFilterArgs {
    /**
     * Specifies the name of the owner.
     */
    owner?: pulumi.Input<string>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetSmbServerSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
}

export interface GetSmbServerSettingsFilterArgs {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
}

export interface GetSmbShareFilter {
    /**
     * The direction of the sort.
     */
    dir?: string;
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: number;
    /**
     * Names to filter smb shares.
     */
    names?: string[];
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: number;
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: string;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * The field that will be used for sorting.
     */
    sort?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetSmbShareFilterArgs {
    /**
     * The direction of the sort.
     */
    dir?: pulumi.Input<string>;
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: pulumi.Input<number>;
    /**
     * Names to filter smb shares.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: pulumi.Input<number>;
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: pulumi.Input<string>;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
    /**
     * The field that will be used for sorting.
     */
    sort?: pulumi.Input<string>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetSmbShareSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetSmbShareSettingsFilterArgs {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: pulumi.Input<string>;
    /**
     * Specifies which access zone to use.
     */
    zone?: pulumi.Input<string>;
}

export interface GetSnapshotFilter {
    path?: string;
}

export interface GetSnapshotFilterArgs {
    path?: pulumi.Input<string>;
}

export interface GetSnapshotScheduleFilter {
    /**
     * The direction of the sort.Supported Values:ASC , DESC
     */
    dir?: string;
    /**
     * Return no more than this many results at once.
     */
    limit?: number;
    /**
     * Names to filter snapshot schedules.
     */
    names?: string[];
    /**
     * The field that will be used for sorting. Choices are id, name, path, pattern, schedule, duration, alias, next_run, and next_snapshot. Default is id.
     */
    sort?: string;
}

export interface GetSnapshotScheduleFilterArgs {
    /**
     * The direction of the sort.Supported Values:ASC , DESC
     */
    dir?: pulumi.Input<string>;
    /**
     * Return no more than this many results at once.
     */
    limit?: pulumi.Input<number>;
    /**
     * Names to filter snapshot schedules.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The field that will be used for sorting. Choices are id, name, path, pattern, schedule, duration, alias, next_run, and next_snapshot. Default is id.
     */
    sort?: pulumi.Input<string>;
}

export interface GetSubnetFilter {
    /**
     * Specifies which groupnet to query.
     */
    groupnetName?: string;
    /**
     * List of subnet name.
     */
    names?: string[];
}

export interface GetSubnetFilterArgs {
    /**
     * Specifies which groupnet to query.
     */
    groupnetName?: pulumi.Input<string>;
    /**
     * List of subnet name.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GetUserFilter {
    /**
     * If true, only return cached objects.
     */
    cached?: boolean;
    /**
     * Filter users by domain.
     */
    domain?: string;
    /**
     * Enumerate all users that a group is a member of.
     */
    memberOf?: boolean;
    /**
     * Filter users by name prefix.
     */
    namePrefix?: string;
    /**
     * List of user identity.
     */
    names?: inputs.GetUserFilterName[];
    /**
     * Filter users by provider.
     */
    provider?: string;
    /**
     * Filter users by zone.
     */
    zone?: string;
}

export interface GetUserFilterArgs {
    /**
     * If true, only return cached objects.
     */
    cached?: pulumi.Input<boolean>;
    /**
     * Filter users by domain.
     */
    domain?: pulumi.Input<string>;
    /**
     * Enumerate all users that a group is a member of.
     */
    memberOf?: pulumi.Input<boolean>;
    /**
     * Filter users by name prefix.
     */
    namePrefix?: pulumi.Input<string>;
    /**
     * List of user identity.
     */
    names?: pulumi.Input<pulumi.Input<inputs.GetUserFilterNameArgs>[]>;
    /**
     * Filter users by provider.
     */
    provider?: pulumi.Input<string>;
    /**
     * Filter users by zone.
     */
    zone?: pulumi.Input<string>;
}

export interface GetUserFilterName {
    /**
     * Specifies a user name.
     */
    name?: string;
    /**
     * Specifies a numeric user identifier.
     */
    uid?: number;
}

export interface GetUserFilterNameArgs {
    /**
     * Specifies a user name.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies a numeric user identifier.
     */
    uid?: pulumi.Input<number>;
}

export interface GetUserGroupFilter {
    /**
     * If true, only return cached objects.
     */
    cached?: boolean;
    /**
     * Filter user groups by domain.
     */
    domain?: string;
    /**
     * Filter user groups by name prefix.
     */
    namePrefix?: string;
    /**
     * List of user group identity.
     */
    names?: inputs.GetUserGroupFilterName[];
    /**
     * Filter user groups by provider.
     */
    provider?: string;
    /**
     * Filter user groups by zone.
     */
    zone?: string;
}

export interface GetUserGroupFilterArgs {
    /**
     * If true, only return cached objects.
     */
    cached?: pulumi.Input<boolean>;
    /**
     * Filter user groups by domain.
     */
    domain?: pulumi.Input<string>;
    /**
     * Filter user groups by name prefix.
     */
    namePrefix?: pulumi.Input<string>;
    /**
     * List of user group identity.
     */
    names?: pulumi.Input<pulumi.Input<inputs.GetUserGroupFilterNameArgs>[]>;
    /**
     * Filter user groups by provider.
     */
    provider?: pulumi.Input<string>;
    /**
     * Filter user groups by zone.
     */
    zone?: pulumi.Input<string>;
}

export interface GetUserGroupFilterName {
    /**
     * Specifies a numeric user group identifier.
     */
    gid?: number;
    /**
     * Specifies a user group name.
     */
    name?: string;
}

export interface GetUserGroupFilterNameArgs {
    /**
     * Specifies a numeric user group identifier.
     */
    gid?: pulumi.Input<number>;
    /**
     * Specifies a user group name.
     */
    name?: pulumi.Input<string>;
}

export interface GetUserMappingRulesFilter {
    /**
     * Names filter for source user name or target user name.
     */
    names?: string[];
    /**
     * Operators filter for user mapping rules.
     */
    operators?: string[];
    /**
     * The zone to which the user mapping applies. Defaults to System.
     */
    zone?: string;
}

export interface GetUserMappingRulesFilterArgs {
    /**
     * Names filter for source user name or target user name.
     */
    names?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Operators filter for user mapping rules.
     */
    operators?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The zone to which the user mapping applies. Defaults to System.
     */
    zone?: pulumi.Input<string>;
}

export interface NamespaceAclAcl {
    /**
     * Specifies the access control permissions for a specific user or group.
     */
    accessrights?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Grants or denies access control permissions.
     */
    accesstype?: pulumi.Input<string>;
    /**
     * Grants or denies access control permissions.
     */
    inheritFlags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Operations for updating access control permissions. Unnecessary for access right replacing scenario
     */
    op?: pulumi.Input<string>;
    /**
     * Provides the JSON object for the group persona of the owner.
     */
    trustee?: pulumi.Input<inputs.NamespaceAclAclTrustee>;
}

export interface NamespaceAclAclCustom {
    /**
     * Specifies the access control permissions for a specific user or group. Options: std_delete, std_read_dac, std_write_dac, std_write_owner, std_synchronize, std_required, generic_all, generic_read, generic_write, generic_exec, dir_gen_all, dir_gen_read, dir_gen_write, dir_gen_execute, file_gen_all, file_gen_read, file_gen_write, file_gen_execute, modify, file_read, file_write, append, execute, file_read_attr, file_write_attr, file_read_ext_attr, file_write_ext_attr, delete_child, list, add_file, add_subdir, traverse, dir_read_attr, dir_write_attr, dir_read_ext_attr, dir_write_ext_attr
     */
    accessrights?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Grants or denies access control permissions. Options: allow, deny
     */
    accesstype: pulumi.Input<string>;
    /**
     * Grants or denies access control permissions. Options: object_inherit, container_inherit, inherit_only, no_prop_inherit, inherited_ace
     */
    inheritFlags?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Operations for updating access control permissions. Unnecessary for access right replacing scenario
     */
    op?: pulumi.Input<string>;
    /**
     * Provides the JSON object for the group persona of the owner.
     */
    trustee: pulumi.Input<inputs.NamespaceAclAclCustomTrustee>;
}

export interface NamespaceAclAclCustomTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0' or 'GID:0'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NamespaceAclAclTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0' or 'GID:0'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NamespaceAclGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NamespaceAclOwner {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NetworkpoolIface {
    /**
     * A string that defines an interface name.
     */
    iface?: pulumi.Input<string>;
    /**
     * Logical Node Number (LNN) of a node.
     */
    lnn?: pulumi.Input<number>;
}

export interface NetworkpoolRange {
    /**
     * High IP
     */
    high?: pulumi.Input<string>;
    /**
     * Low IP
     */
    low?: pulumi.Input<string>;
}

export interface NetworkpoolStaticRoute {
    /**
     * Address of the gateway in the format: yyy.yyy.yyy.yyy
     */
    gateway?: pulumi.Input<string>;
    /**
     * Prefix length in the format: nn.
     */
    prefixlen?: pulumi.Input<number>;
    /**
     * Network address in the format: xxx.xxx.xxx.xxx
     */
    subnet?: pulumi.Input<string>;
}

export interface NfsExportMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportMapAllPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportMapAllSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportMapAllUser>;
}

export interface NfsExportMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportMapFailurePrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportMapFailureSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportMapFailureUser>;
}

export interface NfsExportMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportMapNonRootPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportMapNonRootSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportMapNonRootUser>;
}

export interface NfsExportMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportMapRootPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportMapRootSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportMapRootUser>;
}

export interface NfsExportMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportSettingsMapAllPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportSettingsMapAllSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportSettingsMapAllUser>;
}

export interface NfsExportSettingsMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportSettingsMapFailurePrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportSettingsMapFailureSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportSettingsMapFailureUser>;
}

export interface NfsExportSettingsMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportSettingsMapNonRootPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportSettingsMapNonRootSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportSettingsMapNonRootUser>;
}

export interface NfsExportSettingsMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup?: pulumi.Input<inputs.NfsExportSettingsMapRootPrimaryGroup>;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups?: pulumi.Input<pulumi.Input<inputs.NfsExportSettingsMapRootSecondaryGroup>[]>;
    /**
     * Specifies the persona of the file group.
     */
    user?: pulumi.Input<inputs.NfsExportSettingsMapRootUser>;
}

export interface NfsExportSettingsMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface NfsExportSettingsMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface QuotaPersona {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface QuotaThresholds {
    /**
     * Usage bytes at which notifications will be sent but writes will not be denied.
     */
    advisory?: pulumi.Input<number>;
    /**
     * True if the advisory threshold has been hit.
     */
    advisoryExceeded?: pulumi.Input<boolean>;
    /**
     * Time at which advisory threshold was hit.
     */
    advisoryLastExceeded?: pulumi.Input<number>;
    /**
     * Usage bytes at which further writes will be denied.
     */
    hard?: pulumi.Input<number>;
    /**
     * True if the hard threshold has been hit.
     */
    hardExceeded?: pulumi.Input<boolean>;
    /**
     * Time at which hard threshold was hit.
     */
    hardLastExceeded?: pulumi.Input<number>;
    /**
     * Advisory threshold as percent of hard threshold. Usage bytes at which notifications will be sent but writes will not be denied. Must be >= 0.01 <= 99.99, precision 2
     */
    percentAdvisory?: pulumi.Input<number>;
    /**
     * Soft threshold as percent of hard threshold. Usage bytes at which notifications will be sent and soft grace time will be started. Must be >= 0.01 <= 99.99, precision 2
     */
    percentSoft?: pulumi.Input<number>;
    /**
     * Usage bytes at which notifications will be sent and soft grace time will be started.
     */
    soft?: pulumi.Input<number>;
    /**
     * True if the soft threshold has been hit.
     */
    softExceeded?: pulumi.Input<boolean>;
    /**
     * Time in seconds after which the soft threshold has been hit before writes will be denied.
     */
    softGrace?: pulumi.Input<number>;
    /**
     * Time at which soft threshold was hit
     */
    softLastExceeded?: pulumi.Input<number>;
}

export interface QuotaUsage {
    /**
     * Bytes used by governed data apparent to application.
     */
    applogical?: pulumi.Input<number>;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady?: pulumi.Input<boolean>;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical?: pulumi.Input<number>;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady?: pulumi.Input<boolean>;
    /**
     * Physical data usage adjusted to account for shadow store efficiency
     */
    fsphysical?: pulumi.Input<number>;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady?: pulumi.Input<boolean>;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes?: pulumi.Input<number>;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady?: pulumi.Input<boolean>;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical?: pulumi.Input<number>;
    /**
     * Number of physical blocks for file data
     */
    physicalData?: pulumi.Input<number>;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady?: pulumi.Input<boolean>;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection?: pulumi.Input<number>;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady?: pulumi.Input<boolean>;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady?: pulumi.Input<boolean>;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs?: pulumi.Input<number>;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady?: pulumi.Input<boolean>;
}

export interface RoleMember {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0'
     */
    id: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface RolePrivilege {
    /**
     * Specifies the ID of the privilege.
     */
    id: pulumi.Input<string>;
    /**
     * Specifies the name of the privilege.
     */
    name?: pulumi.Input<string>;
    /**
     * permission of the privilege, 'r' = read , 'x' = read-execute, 'w' = read-execute-write, '-' = no permission
     */
    permission?: pulumi.Input<string>;
}

export interface S3BucketAcl {
    /**
     * Specifies the persona of the file group.
     */
    grantee: pulumi.Input<inputs.S3BucketAclGrantee>;
    /**
     * Specifies the S3 rights being allowed.
     */
    permission: pulumi.Input<string>;
}

export interface S3BucketAclGrantee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: pulumi.Input<string>;
}

export interface SmartpoolSettingsSpilloverTarget {
    /**
     * Target pool name if target specified as storagepool, otherwise empty string.
     */
    name?: pulumi.Input<string>;
    /**
     * Type of target pool. Acceptable values: storagepool, anywhere
     */
    type?: pulumi.Input<string>;
}

export interface SmbSharePermission {
    /**
     * Specifies the file system rights that are allowed or denied.
     */
    permission: pulumi.Input<string>;
    /**
     * Determines whether the permission is allowed or denied.
     */
    permissionType: pulumi.Input<string>;
    /**
     * Specifies the persona of the file group.
     */
    trustee: pulumi.Input<inputs.SmbSharePermissionTrustee>;
}

export interface SmbSharePermissionTrustee {
    /**
     * Specifies the serialized form of a persona using security identifier, which can be 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface SmbShareRunAsRoot {
    /**
     * Specifies the serialized form of a persona using security identifier, which can be 'SID:S-1-1'.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: pulumi.Input<string>;
}

export interface SubnetScServiceAddr {
    /**
     * High IP
     */
    high?: pulumi.Input<string>;
    /**
     * Low IP
     */
    low?: pulumi.Input<string>;
}

export interface UserGid {
    id: pulumi.Input<string>;
    name: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface UserMappingRulesMappingUser {
    /**
     * Specifies the system-defined privilege that may be granted to users.
     */
    privileges?: pulumi.Input<pulumi.Input<inputs.UserMappingRulesMappingUserPrivilege>[]>;
    /**
     * Specifies the configuration properties for a user.
     */
    supplementalIdentities?: pulumi.Input<pulumi.Input<inputs.UserMappingRulesMappingUserSupplementalIdentity>[]>;
    /**
     * Specifies the configuration properties for a user.
     */
    user?: pulumi.Input<inputs.UserMappingRulesMappingUserUser>;
    /**
     * Numeric ID of the access zone which contains this user.
     */
    zid?: pulumi.Input<number>;
    /**
     * Name of the access zone which contains this user.
     */
    zone?: pulumi.Input<string>;
}

export interface UserMappingRulesMappingUserPrivilege {
    /**
     * Specifies the ID of the privilege.
     */
    id?: pulumi.Input<string>;
    /**
     * Specifies the name of the privilege.
     */
    name?: pulumi.Input<string>;
    /**
     * True, if the privilege is read-only.
     */
    readOnly?: pulumi.Input<boolean>;
}

export interface UserMappingRulesMappingUserSupplementalIdentity {
    /**
     * Specifies a user or group GID.
     */
    gid?: pulumi.Input<string>;
    /**
     * Specifies a user or group name.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies a user or group SID.
     */
    sid?: pulumi.Input<string>;
}

export interface UserMappingRulesMappingUserUser {
    /**
     * Specifies the user name.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the user identity on disk.
     */
    onDiskUserIdentity?: pulumi.Input<string>;
    /**
     * Specifies the primary group name.
     */
    primaryGroupName?: pulumi.Input<string>;
    /**
     * Specifies the primary group SID.
     */
    primaryGroupSid?: pulumi.Input<string>;
    /**
     * Specifies a user or group SID.
     */
    sid?: pulumi.Input<string>;
    /**
     * Specifies the user UID.
     */
    uid?: pulumi.Input<string>;
}

export interface UserMappingRulesParameters {
    /**
     * Specifies the default UNIX user information that can be applied if the final credentials do not have valid UID and GID information. (Update Supported)
     */
    defaultUnixUser?: pulumi.Input<inputs.UserMappingRulesParametersDefaultUnixUser>;
}

export interface UserMappingRulesParametersDefaultUnixUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain?: pulumi.Input<string>;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: pulumi.Input<string>;
}

export interface UserMappingRulesRule {
    /**
     * Specifies the operator to make rules on specified users or groups. (Update Supported)
     */
    operator: pulumi.Input<string>;
    /**
     * Specifies the mapping options for this user mapping rule. (Update Supported)
     */
    options?: pulumi.Input<inputs.UserMappingRulesRuleOptions>;
    /**
     * Specifies the source user information that the rule can be applied from. (Update Supported)
     */
    sourceUser?: pulumi.Input<inputs.UserMappingRulesRuleSourceUser>;
    /**
     * Specifies the target user information that the rule can be applied to. (Update Supported)
     */
    targetUser: pulumi.Input<inputs.UserMappingRulesRuleTargetUser>;
}

export interface UserMappingRulesRuleOptions {
    /**
     * If true, and the rule was applied successfully, stop processing further. (Update Supported)
     */
    break?: pulumi.Input<boolean>;
    /**
     * Specifies the default user information that can be applied if the final credentials do not have valid UID and GID information. (Update Supported)
     */
    defaultUser?: pulumi.Input<inputs.UserMappingRulesRuleOptionsDefaultUser>;
    /**
     * If true, the primary GID and primary group SID should be copied to the existing credential. (Update Supported)
     */
    group?: pulumi.Input<boolean>;
    /**
     * If true, all additional identifiers should be copied to the existing credential. (Update Supported)
     */
    groups?: pulumi.Input<boolean>;
    /**
     * If true, the primary UID and primary user SID should be copied to the existing credential. (Update Supported)
     */
    user?: pulumi.Input<boolean>;
}

export interface UserMappingRulesRuleOptionsDefaultUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain?: pulumi.Input<string>;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: pulumi.Input<string>;
}

export interface UserMappingRulesRuleSourceUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain?: pulumi.Input<string>;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: pulumi.Input<string>;
}

export interface UserMappingRulesRuleTargetUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain?: pulumi.Input<string>;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: pulumi.Input<string>;
}

export interface UserMappingRulesTestMappingUser {
    /**
     * Specifies a user name. (Update Supported)
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies a numeric user identifier. (Update Supported)
     */
    uid?: pulumi.Input<number>;
}

export interface UserPrimaryGroupSid {
    id: pulumi.Input<string>;
    name: pulumi.Input<string>;
    type: pulumi.Input<string>;
}
