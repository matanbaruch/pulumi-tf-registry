// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccesszoneIfsRestricted {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface ClusterEmailSettings {
    /**
     * This setting determines how notifications will be batched together to be sent by email.  'none' means each notification will be sent separately.  'severity' means notifications of the same severity will be sent together.  'category' means notifications of the same category will be sent together.  'all' means all notifications will be batched together and sent in a single email.
     */
    batchMode: string;
    /**
     * The address of the SMTP server to be used for relaying the notification messages.  An SMTP server is required in order to send notifications.  If this string is empty, no emails will be sent.
     */
    mailRelay: string;
    /**
     * The full email address that will appear as the sender of notification messages.
     */
    mailSender: string;
    /**
     * The subject line for notification messages from this cluster.
     */
    mailSubject: string;
    /**
     * Password to authenticate with if SMTP authentication is being used.
     */
    smtpAuthPasswd: string;
    /**
     * Indicates if an SMTP authentication password is set.
     */
    smtpAuthPasswdSet: boolean;
    /**
     * The type of secure communication protocol to use if SMTP is being used.  If 'none', plain text will be used, if 'starttls', the encrypted STARTTLS protocol will be used.
     */
    smtpAuthSecurity: string;
    /**
     * Username to authenticate with if SMTP authentication is being used.
     */
    smtpAuthUsername: string;
    /**
     * The port on the SMTP server to be used for relaying the notification messages.
     */
    smtpPort: number;
    /**
     * If true, this cluster will send SMTP authentication credentials to the SMTP relay server in order to send its notification emails.  If false, the cluster will attempt to send its notification emails without authentication.
     */
    useSmtpAuth: boolean;
    /**
     * Location of a custom template file that can be used to specify the layout of the notification emails.  If this string is empty, the default template will be used.
     */
    userTemplate: string;
}

export interface FilepoolPolicyAction {
    /**
     * action_type Acceptable values: set_requested_protection, set_data_access_pattern, enable_coalescer, apply_data_storage_policy, apply_snapshot_storage_policy, set_cloudpool_policy, enable_packing.
     */
    actionType: string;
    /**
     * Action for set_cloudpool_policy type.
     */
    cloudpoolPolicyAction?: outputs.FilepoolPolicyActionCloudpoolPolicyAction;
    /**
     * Action for set_data_access_pattern type. Set data access pattern optimization. Acceptable values: random, concurrency, streaming.
     */
    dataAccessPatternAction?: string;
    /**
     * Action for apply_data_storage_policy.
     */
    dataStoragePolicyAction?: outputs.FilepoolPolicyActionDataStoragePolicyAction;
    /**
     * Action for enable_coalescer type. Set write performance optimization. True to enable SmartCache action.
     */
    enableCoalescerAction?: boolean;
    /**
     * Action for enable_packing type. True to enable enable_packing action.
     */
    enablePackingAction?: boolean;
    /**
     * Action for set_requested_protection type. Acceptable values: default, +1n, +2d:1n, +2n, +3d:1n, +3d:1n1d, +3n, +4d:1n, +4d:2n, +4n, 2x, 3x, 4x, 5x, 6x, 7x, 8x.
     */
    requestedProtectionAction?: string;
    /**
     * Action for apply_snapshot_storage_policy.
     */
    snapshotStoragePolicyAction?: outputs.FilepoolPolicyActionSnapshotStoragePolicyAction;
}

export interface FilepoolPolicyActionCloudpoolPolicyAction {
    /**
     * Specifies if files with snapshots should be archived.
     */
    archiveSnapshotFiles: boolean;
    /**
     * Specifies default cloudpool cache settings for new filepool policies.
     */
    cache: outputs.FilepoolPolicyActionCloudpoolPolicyActionCache;
    /**
     * Specifies if files should be compressed.
     */
    compression: boolean;
    /**
     * Specifies the minimum amount of time archived data will be retained in the cloud after deletion.
     */
    dataRetention: number;
    /**
     * Specifies if files should be encrypted.
     */
    encryption: boolean;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a full NDMP backup. (Used with NDMP backups only.  Not applicable to SyncIQ.)
     */
    fullBackupRetention: number;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a SyncIQ backup or an incremental NDMP backup. (Used with SyncIQ and NDMP backups.)
     */
    incrementalBackupRetention: number;
    /**
     * Specifies the cloudPool storage target.
     */
    pool: string;
    /**
     * The minimum amount of time to wait before updating cloud data with local changes.
     */
    writebackFrequency: number;
}

export interface FilepoolPolicyActionCloudpoolPolicyActionCache {
    /**
     * Specifies cache expiration.
     */
    expiration: number;
    /**
     * Specifies cache read ahead type. Acceptable values: partial, full.
     */
    readAhead: string;
    /**
     * Specifies cache type. Acceptable values: cached, no-cache.
     */
    type: string;
}

export interface FilepoolPolicyActionDataStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: string;
    /**
     * Specifies the storage target.
     */
    storagepool: string;
}

export interface FilepoolPolicyActionSnapshotStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: string;
    /**
     * Specifies the snapshot storage target.
     */
    storagepool: string;
}

export interface FilepoolPolicyFileMatchingPattern {
    /**
     * List of or_criteria file matching rules for this policy.
     */
    orCriterias: outputs.FilepoolPolicyFileMatchingPatternOrCriteria[];
}

export interface FilepoolPolicyFileMatchingPatternOrCriteria {
    /**
     * List of and_criteria file matching rules for this policy.
     */
    andCriterias: outputs.FilepoolPolicyFileMatchingPatternOrCriteriaAndCriteria[];
}

export interface FilepoolPolicyFileMatchingPatternOrCriteriaAndCriteria {
    /**
     * Indicates whether the existence of an attribute indicates a match (valid only with 'type' = 'custom_attribute').
     */
    attributeExists?: boolean;
    /**
     * True to match the path exactly, False to match any subtree. (valid only with 'type' = 'path').
     */
    beginsWith?: boolean;
    /**
     * True to indicate case sensitivity when comparing file attributes (valid only with 'type' = 'name' or 'type' = 'path').
     */
    caseSensitive?: boolean;
    /**
     * File attribute field name to be compared in a custom comparison (valid only with 'type' = 'custom_attribute').
     */
    field?: string;
    /**
     * The comparison operator to use while comparing an attribute with its value.
     */
    operator?: string;
    /**
     * The file attribute to be compared to a given value.
     */
    type: string;
    /**
     * Size unit value. One of 'B','KB','MB','GB','TB','PB','EB' (valid only with 'type' = 'size').
     */
    units?: string;
    /**
     * Whether time units refer to a calendar date and time (e.g., Jun 3, 2009) or a relative duration (e.g., 2 weeks) (valid only with 'type' in {accessed_time, birth_time, changed_time or metadata_changed_time}.
     */
    useRelativeTime?: boolean;
    /**
     * The value to be compared against a file attribute.
     */
    value?: string;
}

export interface FilesystemGroup {
    /**
     * group identifier
     */
    id: string;
    /**
     * group name
     */
    name: string;
    /**
     * group type
     */
    type: string;
}

export interface FilesystemOwner {
    /**
     * Owner identifier
     */
    id: string;
    /**
     * Owner name
     */
    name: string;
    /**
     * Owner type
     */
    type: string;
}

export interface GetAccesszoneAccessZonesDetail {
    /**
     * Specifies an alternate system provider.
     */
    alternateSystemProvider: string;
    /**
     * Specifies the list of authentication providers available on this access zone.
     */
    authProviders: string[];
    /**
     * Specifies amount of time in seconds to cache a user/group.
     */
    cacheEntryExpiry: number;
    /**
     * Determines if a path is created when a path does not exist.
     */
    createPath: boolean;
    /**
     * Groupnet identifier
     */
    groupnet: string;
    /**
     * Specifies the permissions set on automatically created user home directories.
     */
    homeDirectoryUmask: number;
    /**
     * Specifies the system-assigned ID for the access zone. This value is returned when an access zone is created through the POST method
     */
    id: string;
    /**
     * Specifies a list of users and groups that have read and write access to /ifs.
     */
    ifsRestricteds: outputs.GetAccesszoneAccessZonesDetailIfsRestricted[];
    /**
     * Maps untrusted domains to this NetBIOS domain during authentication.
     */
    mapUntrusted: string;
    /**
     * Specifies the access zone name.
     */
    name: string;
    /**
     * Specifies number of seconds the negative cache entry is valid.
     */
    negativeCacheEntryExpiry: number;
    /**
     * Specifies the NetBIOS name.
     */
    netbiosName: string;
    /**
     * Specifies the access zone base directory path.
     */
    path: string;
    /**
     * Specifies the skeleton directory that is used for user home directories.
     */
    skeletonDirectory: string;
    /**
     * True if the access zone is built-in.
     */
    system: boolean;
    /**
     * Specifies the system provider for the access zone.
     */
    systemProvider: string;
    /**
     * Specifies the current ID mapping rules.
     */
    userMappingRules: string[];
    /**
     * Specifies the access zone ID on the system.
     */
    zoneId: number;
}

export interface GetAccesszoneAccessZonesDetailIfsRestricted {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetAccesszoneFilter {
    names?: string[];
}

export interface GetAdsproviderAdsProvidersDetail {
    /**
     * Allocates an ID for an unmapped Active Directory (ADS) group. ADS groups without GIDs can be proactively assigned a GID by the ID mapper. If the ID mapper option is disabled, GIDs are not proactively assigned, and when a primary group for a user does not include a GID, the system may allocate one.
     */
    allocateGids: boolean;
    /**
     * Allocates a user ID for an unmapped Active Directory (ADS) user. ADS users without UIDs can be proactively assigned a UID by the ID mapper. IF the ID mapper option is disabled, UIDs are not proactively assigned, and when an identify for a user does not include a UID, the system may allocate one.
     */
    allocateUids: boolean;
    /**
     * Enables lookup of unqualified user names in the primary domain.
     */
    assumeDefaultDomain: boolean;
    /**
     * Enables authentication and identity management through the authentication provider.
     */
    authentication: boolean;
    /**
     * Specifies the time in seconds between provider online checks.
     */
    checkOnlineInterval: number;
    /**
     * Specifies the current time for the domain controllers.
     */
    controllerTime: number;
    /**
     * Automatically creates a home directory on the first login.
     */
    createHomeDirectory: boolean;
    /**
     * Sends an alert if the domain goes offline.
     */
    domainOfflineAlerts: boolean;
    /**
     * Get duplicate SPNs in the provider domain.
     */
    dupSpns: string[];
    /**
     * List of additional SPNs to expect beyond what automatic checking routines might find.
     */
    extraExpectedSpns: string[];
    /**
     * Sets list of groups that can be resolved.
     */
    findableGroups: string[];
    /**
     * Sets list of users that can be resolved.
     */
    findableUsers: string[];
    /**
     * Specifies the Active Directory forest.
     */
    forest: string;
    /**
     * Groupnet identifier.
     */
    groupnet: string;
    /**
     * Specifies the path to the home directory template.
     */
    homeDirectoryTemplate: string;
    /**
     * Specifies the fully qualified hostname stored in the machine account.
     */
    hostname: string;
    /**
     * Specifies the ID of the Active Directory provider instance.
     */
    id: string;
    /**
     * If set to true, ignores all trusted domains.
     */
    ignoreAllTrusts: boolean;
    /**
     * Includes trusted domains when 'ignore_all_trusts' is set to false.
     */
    ignoredTrustedDomains: string[];
    /**
     * Includes trusted domains when 'ignore_all_trusts' is set to true.
     */
    includeTrustedDomains: string[];
    /**
     * Specifies Active Directory provider instance.
     */
    instance: string;
    /**
     * Enables encryption and signing on LDAP requests.
     */
    ldapSignAndSeal: boolean;
    /**
     * Specifies the login shell path.
     */
    loginShell: string;
    /**
     * Limits user and group lookups to the specified domains.
     */
    lookupDomains: string[];
    /**
     * Looks up AD groups in other providers before allocating a group ID.
     */
    lookupGroups: boolean;
    /**
     * Normalizes AD group names to lowercase before look up.
     */
    lookupNormalizeGroups: boolean;
    /**
     * Normalize AD user names to lowercase before look up.
     */
    lookupNormalizeUsers: boolean;
    /**
     * Looks up AD users in other providers before allocating a user ID.
     */
    lookupUsers: boolean;
    /**
     * Specifies the machine account name when creating a SAM account with Active Directory.
     */
    machineAccount: string;
    /**
     * Enables periodic changes of the machine password for security.
     */
    machinePasswordChanges: boolean;
    /**
     * Sets maximum age of a password in seconds.
     */
    machinePasswordLifespan: number;
    /**
     * Specifies the Active Directory provider name.
     */
    name: string;
    /**
     * Specifies the NetBIOS domain name associated with the machine account.
     */
    netbiosDomain: string;
    /**
     * Specifies the domain controller for which the node has affinity.
     */
    nodeDcAffinity: string;
    /**
     * Specifies the timeout for the domain controller for which the local node has affinity.
     */
    nodeDcAffinityTimeout: number;
    /**
     * Enables the Active Directory provider to respond to 'getpwent' and 'getgrent' requests.
     */
    nssEnumeration: boolean;
    /**
     * Specifies the AD domain to which the provider is joined.
     */
    primaryDomain: string;
    /**
     * Check the provider for filtered lists of findable and unfindable users and groups.
     */
    restrictFindable: boolean;
    /**
     * The maximum amount of time (in seconds) an RPC call to Active Directory is allowed to take.
     */
    rpcCallTimeout: number;
    /**
     * The number of retries attempted when a call to Active Directory fails due to network error.
     */
    serverRetryLimit: number;
    /**
     * Specifies whether to support RFC 2307 attributes on ADS domain controllers.
     */
    sfuSupport: string;
    /**
     * Specifies the site for the Active Directory.
     */
    site: string;
    /**
     * Specifies the status of the provider.
     */
    status: string;
    /**
     * Stores SFU mappings permanently in the ID mapper.
     */
    storeSfuMappings: boolean;
    /**
     * If set to true, indicates that this provider instance was created by OneFS and cannot be removed.
     */
    system: boolean;
    /**
     * Specifies groups that cannot be resolved by the provider.
     */
    unfindableGroups: string[];
    /**
     * Specifies users that cannot be resolved by the provider.
     */
    unfindableUsers: string[];
    /**
     * Specifies the name of the access zone in which this provider was created.
     */
    zoneName: string;
}

export interface GetAdsproviderFilter {
    /**
     * Filter ads providers by names.
     */
    names?: string[];
    /**
     * Filter ads providers by scope.
     */
    scope?: string;
}

export interface GetClusterAcs {
    /**
     * list of failed nodes serial number.
     */
    failedNodesSns: string[];
    /**
     * the number of joined nodes.
     */
    joinedNodes: number;
    /**
     * the status of license activation.
     */
    licenseStatus: string;
    /**
     * the status of SRS enablement.
     */
    srsStatus: string;
    /**
     * total nodes number of the cluster.
     */
    totalNodes: number;
    /**
     * list of unresponsive nodes serial number.
     */
    unresponsiveSns: string[];
}

export interface GetClusterConfig {
    /**
     * Customer configurable description.
     */
    description: string;
    /**
     * device
     */
    devices: outputs.GetClusterConfigDevice[];
    /**
     * Cluster GUID.
     */
    guid: string;
    /**
     * Node join mode: 'manual' or 'secure'.
     */
    joinMode: string;
    /**
     * Device ID of the queried node.
     */
    localDevid: number;
    /**
     * Device logical node number of the queried node.
     */
    localLnn: number;
    /**
     * Device serial number of the queried node.
     */
    localSerial: string;
    /**
     * Cluster name.
     */
    name: string;
    /**
     * version
     */
    onefsVersion: outputs.GetClusterConfigOnefsVersion;
    /**
     * version
     */
    timezone: outputs.GetClusterConfigTimezone;
}

export interface GetClusterConfigDevice {
    /**
     * Device ID.
     */
    devid: number;
    /**
     * Device GUID.
     */
    guid: string;
    /**
     * If true, this node is online and communicating with the local node and every other node with the is_up property normally
     */
    isUp: boolean;
    /**
     * Device logical node number.
     */
    lnn: number;
}

export interface GetClusterConfigOnefsVersion {
    /**
     * OneFS build string.
     */
    build: string;
    /**
     * Kernel release number.
     */
    release: string;
    /**
     * OneFS build number.
     */
    revision: string;
    /**
     * Kernel release type.
     */
    type: string;
    /**
     * Kernel full version information.
     */
    version: string;
}

export interface GetClusterConfigTimezone {
    /**
     * Timezone abbreviation.
     */
    abbreviation: string;
    /**
     * Customer timezone information.
     */
    custom: string;
    /**
     * Timezone full name.
     */
    name: string;
    /**
     * Timezone hierarchical name.
     */
    path: string;
}

export interface GetClusterEmailSettings {
    /**
     * This setting determines how notifications will be batched together to be sent by email.  'none' means each notification will be sent separately.  'severity' means notifications of the same severity will be sent together.  'category' means notifications of the same category will be sent together.  'all' means all notifications will be batched together and sent in a single email.
     */
    batchMode: string;
    /**
     * The address of the SMTP server to be used for relaying the notification messages.  An SMTP server is required in order to send notifications.  If this string is empty, no emails will be sent.
     */
    mailRelay: string;
    /**
     * The full email address that will appear as the sender of notification messages.
     */
    mailSender: string;
    /**
     * The subject line for notification messages from this cluster.
     */
    mailSubject: string;
    /**
     * Indicates if an SMTP authentication password is set.
     */
    smtpAuthPasswdSet: boolean;
    /**
     * The type of secure communication protocol to use if SMTP is being used.  If 'none', plain text will be used, if 'starttls', the encrypted STARTTLS protocol will be used.
     */
    smtpAuthSecurity: string;
    /**
     * Username to authenticate with if SMTP authentication is being used.
     */
    smtpAuthUsername: string;
    /**
     * The port on the SMTP server to be used for relaying the notification messages.
     */
    smtpPort: number;
    /**
     * If true, this cluster will send SMTP authentication credentials to the SMTP relay server in order to send its notification emails.  If false, the cluster will attempt to send its notification emails without authentication.
     */
    useSmtpAuth: boolean;
    /**
     * Location of a custom template file that can be used to specify the layout of the notification emails.
     */
    userTemplate: string;
}

export interface GetClusterIdentity {
    /**
     * A description of the cluster.
     */
    description: string;
    /**
     * //
     */
    logon: outputs.GetClusterIdentityLogon;
    /**
     * The name of the cluster.
     */
    name: string;
}

export interface GetClusterIdentityLogon {
    /**
     * The message of the day.
     */
    motd: string;
    /**
     * The header to the message of the day.
     */
    motdHeader: string;
}

export interface GetClusterInternalNetworks {
    /**
     * Array of IP address ranges to be used to configure the internal failover network of the OneFS cluster.
     */
    failoverIpAddresses: outputs.GetClusterInternalNetworksFailoverIpAddress[];
    /**
     * Status of failover network.
     */
    failoverStatus: string;
    /**
     * Network fabric used for the primary network int-a.
     */
    intAFabric: string;
    /**
     * Array of IP address ranges to be used to configure the internal int-a network of the OneFS cluster.
     */
    intAIpAddresses: outputs.GetClusterInternalNetworksIntAIpAddress[];
    /**
     * Maximum Transfer Unit (MTU) of the primary network int-a.
     */
    intAMtu: number;
    /**
     * Prefixlen specifies the length of network bits used in an IP address. This field is the right-hand part of the CIDR notation representing the subnet mask.
     */
    intAPrefixLength: number;
    /**
     * Status of the primary network int-a.
     */
    intAStatus: string;
    /**
     * Network fabric used for the failover network.
     */
    intBFabric: string;
    /**
     * Array of IP address ranges to be used to configure the internal int-b network of the OneFS cluster.
     */
    intBIpAddresses: outputs.GetClusterInternalNetworksIntBIpAddress[];
    /**
     * Maximum Transfer Unit (MTU) of the failover network int-b.
     */
    intBMtu: number;
    /**
     * Prefixlen specifies the length of network bits used in an IP address. This field is the right-hand part of the CIDR notation representing the subnet mask.
     */
    intBPrefixLength: number;
}

export interface GetClusterInternalNetworksFailoverIpAddress {
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    high: string;
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    low: string;
}

export interface GetClusterInternalNetworksIntAIpAddress {
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    high: string;
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    low: string;
}

export interface GetClusterInternalNetworksIntBIpAddress {
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    high: string;
    /**
     * IPv4 address in the format: xxx.xxx.xxx.xxx
     */
    low: string;
}

export interface GetClusterNodes {
    /**
     * A list of errors encountered by the individual nodes involved in this request, or an empty list if there were no errors.
     */
    errors: outputs.GetClusterNodesError[];
    /**
     * The responses from the individual nodes involved in this request.
     */
    nodes: outputs.GetClusterNodesNode[];
    /**
     * The total number of nodes responding.
     */
    total: number;
}

export interface GetClusterNodesError {
    /**
     * The error code.
     */
    code: string;
    /**
     * The field with the error if applicable.
     */
    field: string;
    /**
     * Node ID (Device Number) of a node.
     */
    id: number;
    /**
     * Logical Node Number (LNN) of a node.
     */
    lnn: number;
    /**
     * The error message.
     */
    message: string;
    /**
     * HTTP Status code returned by this node.
     */
    status: number;
}

export interface GetClusterNodesNode {
    /**
     * List of the drives in this node.
     */
    drives: outputs.GetClusterNodesNodeDrife[];
    /**
     * Error message, if the HTTP status returned from this node was not 200.
     */
    error: string;
    /**
     * //
     */
    hardware: outputs.GetClusterNodesNodeHardware;
    /**
     * Node ID (Device Number) of a node.
     */
    id: number;
    /**
     * Logical Node Number (LNN) of a node.
     */
    lnn: number;
    /**
     * //
     */
    partitions: outputs.GetClusterNodesNodePartitions;
    /**
     * //
     */
    sensors: outputs.GetClusterNodesNodeSensors;
    /**
     * //
     */
    state: outputs.GetClusterNodesNodeState;
    /**
     * //
     */
    status: outputs.GetClusterNodesNodeStatus;
}

export interface GetClusterNodesNodeDrife {
    /**
     * Numerical representation of this drive's bay.
     */
    baynum: number;
    /**
     * Number of blocks on this drive.
     */
    blocks: number;
    /**
     * The chassis number which contains this drive.
     */
    chassis: number;
    /**
     * This drive's device name.
     */
    devname: string;
    /**
     * Drive firmware information
     */
    firmware: outputs.GetClusterNodesNodeDrifeFirmware;
    /**
     * Drive_d's handle representation for this driveIf we fail to retrieve the handle for this drive from drive_d: -1
     */
    handle: number;
    /**
     * String representation of this drive's interface type.
     */
    interfaceType: string;
    /**
     * This drive's logical drive number in IFS.
     */
    lnum: number;
    /**
     * String representation of this drive's physical location.
     */
    locnstr: string;
    /**
     * Size of a logical block on this drive.
     */
    logicalBlockLength: number;
    /**
     * String representation of this drive's media type.
     */
    mediaType: string;
    /**
     * This drive's manufacturer and model.
     */
    model: string;
    /**
     * Size of a physical block on this drive.
     */
    physicalBlockLength: number;
    /**
     * Indicates whether this drive is physically present in the node.
     */
    present: boolean;
    /**
     * This drive's purpose in the DRV state machine.
     */
    purpose: string;
    /**
     * Description of this drive's purpose.
     */
    purposeDescription: string;
    /**
     * Serial number for this drive.
     */
    serial: string;
    /**
     * This drive's state as presented to the UI.
     */
    uiState: string;
    /**
     * The drive's 'worldwide name' from its NAA identifiers.
     */
    wwn: string;
    /**
     * This drive's x-axis grid location.
     */
    xLoc: number;
    /**
     * This drive's y-axis grid location.
     */
    yLoc: number;
}

export interface GetClusterNodesNodeDrifeFirmware {
    /**
     * This drive's current firmware revision
     */
    currentFirmware: string;
    /**
     * This drive's desired firmware revision.
     */
    desiredFirmware: string;
}

export interface GetClusterNodesNodeHardware {
    /**
     * Name of this node's chassis.
     */
    chassis: string;
    /**
     * Chassis code of this node (1U, 2U, etc.).
     */
    chassisCode: string;
    /**
     * Number of chassis making up this node.
     */
    chassisCount: string;
    /**
     * Class of this node (storage, accelerator, etc.).
     */
    class: string;
    /**
     * Node configuration ID.
     */
    configurationId: string;
    /**
     * Manufacturer and model of this node's CPU.
     */
    cpu: string;
    /**
     * Manufacturer and model of this node's disk controller.
     */
    diskController: string;
    /**
     * Manufacturer and model of this node's disk expander.
     */
    diskExpander: string;
    /**
     * Family code of this node (X, S, NL, etc.).
     */
    familyCode: string;
    /**
     * Manufacturer, model, and device id of this node's flash drive.
     */
    flashDrive: string;
    /**
     * Generation code of this node.
     */
    generationCode: string;
    /**
     * PowerScale hardware generation name.
     */
    hwgen: string;
    /**
     * Version of this node's PowerScale Management Board.
     */
    imbVersion: string;
    /**
     * Infiniband card type.
     */
    infiniband: string;
    /**
     * Version of the LCD panel.
     */
    lcdVersion: string;
    /**
     * Manufacturer and model of this node's motherboard.
     */
    motherboard: string;
    /**
     * Description of all this node's network interfaces.
     */
    netInterfaces: string;
    /**
     * Manufacturer and model of this node's NVRAM board.
     */
    nvram: string;
    /**
     * Description strings for each power supply on this node.
     */
    powersupplies: string[];
    /**
     * Number of processors and cores on this node.
     */
    processor: string;
    /**
     * PowerScale product name.
     */
    product: string;
    /**
     * Size of RAM in bytes.
     */
    ram: number;
    /**
     * Serial number of this node.
     */
    serialNumber: string;
    /**
     * Series of this node (X, I, NL, etc.).
     */
    series: string;
    /**
     * Storage class of this node (storage or diskless).
     */
    storageClass: string;
}

export interface GetClusterNodesNodePartitions {
    /**
     * Count of how many partitions are included.
     */
    count: number;
    /**
     * Partition information.
     */
    partitions: outputs.GetClusterNodesNodePartitionsPartition[];
}

export interface GetClusterNodesNodePartitionsPartition {
    /**
     * The block size used for the reported partition information.
     */
    blockSize: number;
    /**
     * Total blocks on this file system partition.
     */
    capacity: number;
    /**
     * Comma separated list of devices used for this file system partition.
     */
    componentDevices: string;
    /**
     * Directory on which this partition is mounted.
     */
    mountPoint: string;
    /**
     * Used blocks on this file system partition, expressed as a percentage.
     */
    percentUsed: string;
    /**
     * //
     */
    statfs: outputs.GetClusterNodesNodePartitionsPartitionStatfs;
    /**
     * Used blocks on this file system partition.
     */
    used: number;
}

export interface GetClusterNodesNodePartitionsPartitionStatfs {
    /**
     * Free blocks available to non-superuser on this partition.
     */
    fBavail: number;
    /**
     * Free blocks on this partition.
     */
    fBfree: number;
    /**
     * Total data blocks on this partition.
     */
    fBlocks: number;
    /**
     * Filesystem fragment size; block size in OneFS.
     */
    fBsize: number;
    /**
     * Free file nodes avail to non-superuser.
     */
    fFfree: number;
    /**
     * Total file nodes in filesystem.
     */
    fFiles: number;
    /**
     * Mount exported flags.
     */
    fFlags: number;
    /**
     * File system type name.
     */
    fFstypename: string;
    /**
     * Optimal transfer block size.
     */
    fIosize: number;
    /**
     * Names of devices this partition is mounted from.
     */
    fMntfromname: string;
    /**
     * Directory this partition is mounted to.
     */
    fMntonname: string;
    /**
     * Maximum filename length.
     */
    fNamemax: number;
    /**
     * UID of user that mounted the filesystem.
     */
    fOwner: number;
    /**
     * Type of filesystem.
     */
    fType: number;
    /**
     * statfs() structure version number.
     */
    fVersion: number;
}

export interface GetClusterNodesNodeSensors {
    /**
     * This node's sensor information.
     */
    sensors: outputs.GetClusterNodesNodeSensorsSensor[];
}

export interface GetClusterNodesNodeSensorsSensor {
    /**
     * The count of values in this sensor group.
     */
    count: number;
    /**
     * The name of this sensor group.
     */
    name: string;
    /**
     * The list of specific sensor value info in this sensor group.
     */
    values: outputs.GetClusterNodesNodeSensorsSensorValue[];
}

export interface GetClusterNodesNodeSensorsSensorValue {
    /**
     * The descriptive name of this sensor.
     */
    desc: string;
    /**
     * The identifier name of this sensor.
     */
    name: string;
    /**
     * The units of this sensor.
     */
    units: string;
    /**
     * The value of this sensor.
     */
    value: string;
}

export interface GetClusterNodesNodeState {
    /**
     * //
     */
    readonly: outputs.GetClusterNodesNodeStateReadonly;
    /**
     * //
     */
    servicelight: outputs.GetClusterNodesNodeStateServicelight;
    /**
     * //
     */
    smartfail: outputs.GetClusterNodesNodeStateSmartfail;
}

export interface GetClusterNodesNodeStateReadonly {
    /**
     * The current read-only mode allowed status for the node.
     */
    allowed: boolean;
    /**
     * The current read-only user mode status for the node. NOTE: If read-only mode is currently disallowed for this node, it will remain read/write until read-only mode is allowed again. This value only sets or clears any user-specified requests for read-only mode. If the node has been placed into read-only mode by the system, it will remain in read-only mode until the system conditions which triggered read-only mode have cleared.
     */
    enabled: boolean;
    /**
     * The current read-only mode status for the node.
     */
    mode: boolean;
    /**
     * The current read-only mode status description for the node.
     */
    status: string;
    /**
     * The read-only state values are valid (False = Error).
     */
    valid: boolean;
    /**
     * The current read-only value (enumerated bitfield) for the node.
     */
    value: number;
}

export interface GetClusterNodesNodeStateServicelight {
    /**
     * The node service light state (True = on).
     */
    enabled: boolean;
}

export interface GetClusterNodesNodeStateSmartfail {
    /**
     * This node is smartfailed (soft_devs).
     */
    smartfailed: boolean;
}

export interface GetClusterNodesNodeStatus {
    /**
     * //
     */
    batterystatus: outputs.GetClusterNodesNodeStatusBatterystatus;
    /**
     * Storage capacity of this node.
     */
    capacities: outputs.GetClusterNodesNodeStatusCapacity[];
    /**
     * //
     */
    cpu: outputs.GetClusterNodesNodeStatusCpu;
    /**
     * //
     */
    nvram: outputs.GetClusterNodesNodeStatusNvram;
    /**
     * //
     */
    powersupplies: outputs.GetClusterNodesNodeStatusPowersupplies;
    /**
     * OneFS release.
     */
    release: string;
    /**
     * Seconds this node has been online.
     */
    uptime: number;
    /**
     * OneFS version.
     */
    version: string;
}

export interface GetClusterNodesNodeStatusBatterystatus {
    /**
     * The last battery test time for battery 1.
     */
    lastTestTime1: string;
    /**
     * The last battery test time for battery 2.
     */
    lastTestTime2: string;
    /**
     * The next checkup for battery 1.
     */
    nextTestTime1: string;
    /**
     * The next checkup for battery 2.
     */
    nextTestTime2: string;
    /**
     * Node has battery status.
     */
    present: boolean;
    /**
     * The result of the last battery test for battery 1.
     */
    result1: string;
    /**
     * The result of the last battery test for battery 2.
     */
    result2: string;
    /**
     * The status of battery 1.
     */
    status1: string;
    /**
     * The status of battery 2.
     */
    status2: string;
    /**
     * Node supports battery status.
     */
    supported: boolean;
}

export interface GetClusterNodesNodeStatusCapacity {
    /**
     * Total device storage bytes.
     */
    bytes: number;
    /**
     * Total device count.
     */
    count: number;
    /**
     * Device type.
     */
    type: string;
}

export interface GetClusterNodesNodeStatusCpu {
    /**
     * Manufacturer model description of this CPU.
     */
    model: string;
    /**
     * CPU overtemp state.
     */
    overtemp: string;
    /**
     * Type of processor and core of this CPU.
     */
    proc: string;
    /**
     * CPU throttling (expressed as a percentage).
     */
    speedLimit: string;
}

export interface GetClusterNodesNodeStatusNvram {
    /**
     * This node's NVRAM battery status information.
     */
    batteries: outputs.GetClusterNodesNodeStatusNvramBattery[];
    /**
     * This node's NVRAM battery count. On failure: -1, otherwise 1 or 2.
     */
    batteryCount: number;
    /**
     * This node's NVRAM battery charge status, as a color.
     */
    chargeStatus: string;
    /**
     * This node's NVRAM battery charge status, as a number. Error or not supported: -1. BR_BLACK: 0. BR_GREEN: 1. BR_YELLOW: 2. BR_RED: 3.
     */
    chargeStatusNumber: number;
    /**
     * This node's NVRAM device name with path.
     */
    device: string;
    /**
     * This node has NVRAM.
     */
    present: boolean;
    /**
     * This node has NVRAM with flash storage.
     */
    presentFlash: boolean;
    /**
     * The size of the NVRAM, in bytes.
     */
    presentSize: number;
    /**
     * This node's NVRAM type.
     */
    presentType: string;
    /**
     * This node's current ship mode state for NVRAM batteries. If not supported or on failure: -1. Disabled: 0. Enabled: 1.
     */
    shipMode: number;
    /**
     * This node supports NVRAM.
     */
    supported: boolean;
    /**
     * This node supports NVRAM with flash storage.
     */
    supportedFlash: boolean;
    /**
     * The maximum size of the NVRAM, in bytes.
     */
    supportedSize: number;
    /**
     * This node's supported NVRAM type.
     */
    supportedType: string;
}

export interface GetClusterNodesNodeStatusNvramBattery {
    /**
     * The current status color of the NVRAM battery.
     */
    color: string;
    /**
     * Identifying index for the NVRAM battery.
     */
    id: number;
    /**
     * The current status message of the NVRAM battery.
     */
    status: string;
    /**
     * The current voltage of the NVRAM battery.
     */
    voltage: string;
}

export interface GetClusterNodesNodeStatusPowersupplies {
    /**
     * Count of how many power supplies are supported.
     */
    count: number;
    /**
     * Count of how many power supplies have failed.
     */
    failures: number;
    /**
     * Does this node have a CFF power supply.
     */
    hasCff: boolean;
    /**
     * A descriptive status string for this node's power supplies.
     */
    status: string;
    /**
     * List of this node's power supplies.
     */
    supplies: outputs.GetClusterNodesNodeStatusPowersuppliesSupply[];
    /**
     * Does this node support CFF power supplies.
     */
    supportsCff: boolean;
}

export interface GetClusterNodesNodeStatusPowersuppliesSupply {
    /**
     * Which node chassis is this power supply in.
     */
    chassis: number;
    /**
     * The current firmware revision of this power supply.
     */
    firmware: string;
    /**
     * Is this power supply in a failure state.
     */
    good: string;
    /**
     * Identifying index for this power supply.
     */
    id: number;
    /**
     * Complete identifying string for this power supply.
     */
    name: string;
    /**
     * A descriptive status string for this power supply.
     */
    status: string;
    /**
     * The type of this power supply.
     */
    type: string;
}

export interface GetFilepoolPolicyFilePoolPolicy {
    /**
     * A list of actions to be taken for matching files.
     */
    actions: outputs.GetFilepoolPolicyFilePoolPolicyAction[];
    /**
     * The order in which this policy should be applied (relative to other policies).
     */
    applyOrder: number;
    /**
     * The guid assigned to the cluster on which the policy was created.
     */
    birthClusterId: string;
    /**
     * A description for this File Pool Policy.
     */
    description: string;
    /**
     * Specifies the file matching rules for determining which files will be managed by this policy.
     */
    fileMatchingPattern: outputs.GetFilepoolPolicyFilePoolPolicyFileMatchingPattern;
    /**
     * A unique name for this File Pool Policy.
     */
    id: string;
    /**
     * A unique name for this File Pool Policy.
     */
    name: string;
    /**
     * Indicates whether this policy is in a good state ("OK") or disabled ("disabled").
     */
    state: string;
    /**
     * Gives further information to describe the state of this policy.
     */
    stateDetails: string;
}

export interface GetFilepoolPolicyFilePoolPolicyAction {
    /**
     * action_type Acceptable values: set_requested_protection, set_data_access_pattern, enable_coalescer, apply_data_storage_policy, apply_snapshot_storage_policy, set_cloudpool_policy, enable_packing.
     */
    actionType: string;
    /**
     * Action for set_cloudpool_policy type.
     */
    cloudpoolPolicyAction: outputs.GetFilepoolPolicyFilePoolPolicyActionCloudpoolPolicyAction;
    /**
     * Action for set_data_access_pattern type. Set data access pattern optimization. Acceptable values: random, concurrency, streaming.
     */
    dataAccessPatternAction: string;
    /**
     * Action for apply_data_storage_policy.
     */
    dataStoragePolicyAction: outputs.GetFilepoolPolicyFilePoolPolicyActionDataStoragePolicyAction;
    /**
     * Action for enable_coalescer type. Set write performance optimization. True to enable SmartCache action.
     */
    enableCoalescerAction: boolean;
    /**
     * Action for enable_packing type. True to enable enable_packing action.
     */
    enablePackingAction: boolean;
    /**
     * Action for set_requested_protection type. Acceptable values: default, +1n, +2d:1n, +2n, +3d:1n, +3d:1n1d, +3n, +4d:1n, +4d:2n, +4n, 2x, 3x, 4x, 5x, 6x, 7x, 8x.
     */
    requestedProtectionAction: string;
    /**
     * Action for apply_snapshot_storage_policy.
     */
    snapshotStoragePolicyAction: outputs.GetFilepoolPolicyFilePoolPolicyActionSnapshotStoragePolicyAction;
}

export interface GetFilepoolPolicyFilePoolPolicyActionCloudpoolPolicyAction {
    /**
     * Specifies if files with snapshots should be archived.
     */
    archiveSnapshotFiles: boolean;
    /**
     * Specifies default cloudpool cache settings for new filepool policies.
     */
    cache: outputs.GetFilepoolPolicyFilePoolPolicyActionCloudpoolPolicyActionCache;
    /**
     * Specifies if files should be compressed.
     */
    compression: boolean;
    /**
     * Specifies the minimum amount of time archived data will be retained in the cloud after deletion.
     */
    dataRetention: number;
    /**
     * Specifies if files should be encrypted.
     */
    encryption: boolean;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a full NDMP backup. (Used with NDMP backups only.  Not applicable to SyncIQ.)
     */
    fullBackupRetention: number;
    /**
     * The minimum amount of time cloud files will be retained after the creation of a SyncIQ backup or an incremental NDMP backup. (Used with SyncIQ and NDMP backups.)
     */
    incrementalBackupRetention: number;
    /**
     * Specifies the cloudPool storage target.
     */
    pool: string;
    /**
     * The minimum amount of time to wait before updating cloud data with local changes.
     */
    writebackFrequency: number;
}

export interface GetFilepoolPolicyFilePoolPolicyActionCloudpoolPolicyActionCache {
    /**
     * Specifies cache expiration.
     */
    expiration: number;
    /**
     * Specifies cache read ahead type. Acceptable values: partial, full.
     */
    readAhead: string;
    /**
     * Specifies cache type. Acceptable values: cached, no-cache.
     */
    type: string;
}

export interface GetFilepoolPolicyFilePoolPolicyActionDataStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: string;
    /**
     * Specifies the storage target.
     */
    storagepool: string;
}

export interface GetFilepoolPolicyFilePoolPolicyActionSnapshotStoragePolicyAction {
    /**
     * Specifies the SSD strategy. Acceptable values: metadata, metadata-write, data, avoid.
     */
    ssdStrategy: string;
    /**
     * Specifies the snapshot storage target.
     */
    storagepool: string;
}

export interface GetFilepoolPolicyFilePoolPolicyFileMatchingPattern {
    /**
     * List of or_criteria file matching rules for this policy.
     */
    orCriterias: outputs.GetFilepoolPolicyFilePoolPolicyFileMatchingPatternOrCriteria[];
}

export interface GetFilepoolPolicyFilePoolPolicyFileMatchingPatternOrCriteria {
    /**
     * List of and_criteria file matching rules for this policy.
     */
    andCriterias: outputs.GetFilepoolPolicyFilePoolPolicyFileMatchingPatternOrCriteriaAndCriteria[];
}

export interface GetFilepoolPolicyFilePoolPolicyFileMatchingPatternOrCriteriaAndCriteria {
    /**
     * Indicates whether the existence of an attribute indicates a match (valid only with 'type' = 'custom_attribute').
     */
    attributeExists: boolean;
    /**
     * True to match the path exactly, False to match any subtree. (valid only with 'type' = 'path').
     */
    beginsWith: boolean;
    /**
     * True to indicate case sensitivity when comparing file attributes (valid only with 'type' = 'name' or 'type' = 'path').
     */
    caseSensitive: boolean;
    /**
     * File attribute field name to be compared in a custom comparison (valid only with 'type' = 'custom_attribute').
     */
    field: string;
    /**
     * The comparison operator to use while comparing an attribute with its value.
     */
    operator: string;
    /**
     * The file attribute to be compared to a given value.
     */
    type: string;
    /**
     * Size unit value. One of 'B','KB','MB','GB','TB','PB','EB' (valid only with 'type' = 'size').
     */
    units: string;
    /**
     * Whether time units refer to a calendar date and time (e.g., Jun 3, 2009) or a relative duration (e.g., 2 weeks) (valid only with 'type' in {accessed_time, birth_time, changed_time or metadata_changed_time}.
     */
    useRelativeTime: boolean;
    /**
     * The value to be compared against a file attribute.
     */
    value: string;
}

export interface GetFilepoolPolicyFilter {
    names?: string[];
}

export interface GetFilesystemFileSystemsDetails {
    /**
     * FileSystems Attributes
     */
    fileSystemAttributes: outputs.GetFilesystemFileSystemsDetailsFileSystemAttribute[];
    /**
     * Filesystem acl. Shows the access control list for the FileSystem(Namespace directory)
     */
    fileSystemNamespaceAcl: outputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAcl;
    /**
     * Filesystem quotas
     */
    fileSystemQuotas: outputs.GetFilesystemFileSystemsDetailsFileSystemQuota[];
    /**
     * Filesystem snapshots
     */
    fileSystemSnapshots: outputs.GetFilesystemFileSystemsDetailsFileSystemSnapshot[];
}

export interface GetFilesystemFileSystemsDetailsFileSystemAttribute {
    /**
     * Attribute name
     */
    name: string;
    /**
     * Attribute namespace
     */
    namespace: string;
    /**
     * Attribute value
     */
    value: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAcl {
    /**
     * Filesystem Access Control List
     */
    acls: outputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAcl[];
    /**
     * Acl action
     */
    action: string;
    /**
     * Acl authoritative
     */
    authoritative: string;
    /**
     * ACL group
     */
    group: outputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroup;
    /**
     * Acl mode
     */
    mode: string;
    /**
     * ACL owner
     */
    owner: outputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwner;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAcl {
    /**
     * Access rights
     */
    accessRights: string[];
    /**
     * Access type
     */
    accessType: string;
    /**
     * Inherit flags
     */
    inheritFlags: string[];
    /**
     * Op
     */
    op: string;
    /**
     * Trustee
     */
    trustee: outputs.GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrustee;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclAclTrustee {
    /**
     * Trustee identifier
     */
    id: string;
    /**
     * Trustee name
     */
    name: string;
    /**
     * Trustee type
     */
    type: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclGroup {
    /**
     * Group identifier
     */
    id: string;
    /**
     * Group name
     */
    name: string;
    /**
     * Group type
     */
    type: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemNamespaceAclOwner {
    /**
     * Owner identifier
     */
    id: string;
    /**
     * Owner name
     */
    name: string;
    /**
     * Owner type
     */
    type: string;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuota {
    /**
     * If true, SMB shares using the quota directory see the quota thresholds as share size.
     */
    container: boolean;
    /**
     * True if the quota provides enforcement, otherwise a accounting quota.
     */
    enforced: boolean;
    /**
     * Quota Id
     */
    id: string;
    /**
     * The path of quota.
     */
    path: string;
    /**
     * The type of quota.
     */
    type: string;
    /**
     * Usage
     */
    usage: outputs.GetFilesystemFileSystemsDetailsFileSystemQuotaUsage;
}

export interface GetFilesystemFileSystemsDetailsFileSystemQuotaUsage {
    /**
     * Bytes used by governed data apparent to application
     */
    applogical: number;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical: number;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fsphysical: number;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady: boolean;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes: number;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady: boolean;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical: number;
    /**
     * Number of physical blocks for file data
     */
    physicalData: number;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady: boolean;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection: number;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady: boolean;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady: boolean;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs: number;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady: boolean;
}

export interface GetFilesystemFileSystemsDetailsFileSystemSnapshot {
    /**
     * The name of the alias, none for real snapshots.
     */
    alias: string;
    /**
     * The Unix Epoch time the snapshot was created.
     */
    created: number;
    /**
     * The Unix Epoch time the snapshot will expire and be eligible for automatic deletion.
     */
    expires: number;
    /**
     * True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of locks.
     */
    hasLocks: boolean;
    /**
     * The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
     */
    id: number;
    /**
     * The user or system supplied snapshot name. This will be null for snapshots pending delete.
     */
    name: string;
    /**
     * The /ifs path snapshotted.
     */
    path: string;
    /**
     * Percentage of /ifs used for storing this snapshot.
     */
    pctFilesystem: number;
    /**
     * Percentage of configured snapshot reserved used for storing this snapshot.
     */
    pctReserve: number;
    /**
     * The name of the schedule used to create this snapshot, if applicable.
     */
    schedule: string;
    /**
     * The amount of shadow bytes referred to by this snapshot.
     */
    shadowBytes: number;
    /**
     * The amount of storage in bytes used to store this snapshot.
     */
    size: number;
    /**
     * Snapshot state.
     */
    state: string;
    /**
     * The ID of the snapshot pointed to if this is an alias. 18446744073709551615 (max uint64) is returned for an alias to the live filesystem.
     */
    targetId: number;
    /**
     * The name of the snapshot pointed to if this is an alias.
     */
    targetName: string;
}

export interface GetGroupnetFilter {
    names?: string[];
}

export interface GetGroupnetGroupnet {
    /**
     * If enabled, SmartConnect treats subdomains of known dns zones as the known dns zone. This is required for S3 Virtual Host domains.
     */
    allowWildcardSubdomains: boolean;
    /**
     * A description of the groupnet.
     */
    description: string;
    /**
     * DNS caching is enabled or disabled.
     */
    dnsCacheEnabled: boolean;
    /**
     * Enable or disable DNS resolver rotate.
     */
    dnsResolverRotate: boolean;
    /**
     * List of DNS search suffixes.
     */
    dnsSearches: string[];
    /**
     * List of Domain Name Server IP addresses.
     */
    dnsServers: string[];
    /**
     * Unique Interface ID.
     */
    id: string;
    /**
     * The name of the groupnet.
     */
    name: string;
    /**
     * Enable or disable appending nodes DNS search list to client DNS inquiries directed at SmartConnect service IP.
     */
    serverSideDnsSearch: boolean;
    /**
     * Name of the subnets in the groupnet.
     */
    subnets: string[];
}

export interface GetLdapProviderFilter {
    names?: string[];
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
}

export interface GetLdapProviderLdapProvider {
    /**
     * Specifies the attribute name used when searching for alternate security identities.
     */
    alternateSecurityIdentitiesAttribute: string;
    /**
     * If true, enables authentication and identity management through the authentication provider.
     */
    authentication: boolean;
    /**
     * If true, connects the provider to a random server.
     */
    balanceServers: boolean;
    /**
     * Specifies the root of the tree in which to search identities.
     */
    baseDn: string;
    /**
     * Specifies the distinguished name for binding to the LDAP server.
     */
    bindDn: string;
    /**
     * Specifies which bind mechanism to use when connecting to an LDAP server. The only supported option is the 'simple' value.
     */
    bindMechanism: string;
    /**
     * Specifies the timeout in seconds when binding to an LDAP server.
     */
    bindTimeout: number;
    /**
     * Specifies the path to the root certificates file.
     */
    certificateAuthorityFile: string;
    /**
     * Specifies the time in seconds between provider online checks.
     */
    checkOnlineInterval: number;
    /**
     * Specifies the canonical name.
     */
    cnAttribute: string;
    /**
     * Automatically create the home directory on the first login.
     */
    createHomeDirectory: boolean;
    /**
     * Specifies the hashed password value.
     */
    cryptPasswordAttribute: string;
    /**
     * Specifies the LDAP Email attribute.
     */
    emailAttribute: string;
    /**
     * If true, enables the LDAP provider.
     */
    enabled: boolean;
    /**
     * If true, allows the provider to enumerate groups.
     */
    enumerateGroups: boolean;
    /**
     * If true, allows the provider to enumerate users.
     */
    enumerateUsers: boolean;
    /**
     * Specifies the list of groups that can be resolved.
     */
    findableGroups: string[];
    /**
     * Specifies the list of users that can be resolved.
     */
    findableUsers: string[];
    /**
     * Specifies the LDAP GECOS attribute.
     */
    gecosAttribute: string;
    /**
     * Specifies the LDAP GID attribute.
     */
    gidAttribute: string;
    /**
     * Specifies the distinguished name of the entry where LDAP searches for groups are started.
     */
    groupBaseDn: string;
    /**
     * Specifies the domain for this provider through which groups are qualified.
     */
    groupDomain: string;
    /**
     * Specifies the LDAP filter for group objects.
     */
    groupFilter: string;
    /**
     * Specifies the LDAP Group Members attribute.
     */
    groupMembersAttribute: string;
    /**
     * Specifies the depth from the base DN to perform LDAP searches. Acceptable values: "default", "base", "onelevel", "subtree", "children".
     */
    groupSearchScope: string;
    /**
     * Groupnet identifier.
     */
    groupnet: string;
    /**
     * Specifies the path to the home directory template.
     */
    homeDirectoryTemplate: string;
    /**
     * Specifies the LDAP Homedir attribute.
     */
    homedirAttribute: string;
    /**
     * Specifies the ID of the LDAP provider.
     */
    id: string;
    /**
     * If true, continues over secure connections even if identity checks fail.
     */
    ignoreTlsErrors: boolean;
    /**
     * Specifies the groups that can be viewed in the provider.
     */
    listableGroups: string[];
    /**
     * Specifies the users that can be viewed in the provider.
     */
    listableUsers: string[];
    /**
     * Specifies the login shell path.
     */
    loginShell: string;
    /**
     * Sets the method by which group member lookups are performed. Use caution when changing this option directly. Acceptable values: "default", "rfc2307bis".
     */
    memberLookupMethod: string;
    /**
     * Specifies the LDAP Query Member Of attribute, which performs reverse membership queries.
     */
    memberOfAttribute: string;
    /**
     * Specifies the name of the LDAP provider.
     */
    name: string;
    /**
     * Specifies the LDAP UID attribute, which is used as the login name.
     */
    nameAttribute: string;
    /**
     * Specifies the distinguished name of the entry where LDAP searches for netgroups are started.
     */
    netgroupBaseDn: string;
    /**
     * Specifies the LDAP filter for netgroup objects.
     */
    netgroupFilter: string;
    /**
     * Specifies the LDAP Netgroup Members attribute.
     */
    netgroupMembersAttribute: string;
    /**
     * Specifies the depth from the base DN to perform LDAP searches. Acceptable values: "default", "base", "onelevel", "subtree", "children".
     */
    netgroupSearchScope: string;
    /**
     * Specifies the LDAP Netgroup Triple attribute.
     */
    netgroupTripleAttribute: string;
    /**
     * Normalizes group names to lowercase before look up.
     */
    normalizeGroups: boolean;
    /**
     * Normalizes user names to lowercase before look up.
     */
    normalizeUsers: boolean;
    /**
     * Specifies the LDAP NT Password attribute.
     */
    ntPasswordAttribute: string;
    /**
     * Specifies which NTLM versions to support for users with NTLM-compatible credentials. Acceptable values: "all", "v2only", "none".
     */
    ntlmSupport: string;
    /**
     * Specifies the OCSP server URIs. Only available for PowerScale 9.5 and above.
     */
    ocspServerUris: string[];
    /**
     * Specifies the provider domain.
     */
    providerDomain: string;
    /**
     * Determines whether to continue over a non-TLS connection.
     */
    requireSecureConnection: boolean;
    /**
     * If true, checks the provider for filtered lists of findable and unfindable users and groups.
     */
    restrictFindable: boolean;
    /**
     * If true, checks the provider for filtered lists of listable and unlistable users and groups.
     */
    restrictListable: boolean;
    /**
     * Specifies the default depth from the base DN to perform LDAP searches. Acceptable values: "default", "base", "onelevel", "subtree", "children".
     */
    searchScope: string;
    /**
     * Specifies the search timeout period in seconds.
     */
    searchTimeout: number;
    /**
     * Specifies the server URIs.
     */
    serverUris: string[];
    /**
     * Sets the attribute name that indicates the absolute date to expire the account.
     */
    shadowExpireAttribute: string;
    /**
     * Sets the attribute name that indicates the section of the shadow map that is used to store the flag value.
     */
    shadowFlagAttribute: string;
    /**
     * Sets the attribute name that indicates the number of days of inactivity that is allowed for the user.
     */
    shadowInactiveAttribute: string;
    /**
     * Sets the attribute name that indicates the last change of the shadow information.
     */
    shadowLastChangeAttribute: string;
    /**
     * Sets the attribute name that indicates the maximum number of days a password can be valid.
     */
    shadowMaxAttribute: string;
    /**
     * Sets the attribute name that indicates the minimum number of days between shadow changes.
     */
    shadowMinAttribute: string;
    /**
     * Sets LDAP filter for shadow user objects.
     */
    shadowUserFilter: string;
    /**
     * Sets the attribute name that indicates the number of days before the password expires to warn the user.
     */
    shadowWarningAttribute: string;
    /**
     * Specifies the LDAP Shell attribute.
     */
    shellAttribute: string;
    /**
     * Sets the attribute name that indicates the SSH Public Key for the user.
     */
    sshPublicKeyAttribute: string;
    /**
     * Specifies the status of the provider.
     */
    status: string;
    /**
     * If true, indicates that this provider instance was created by OneFS and cannot be removed.
     */
    system: boolean;
    /**
     * Specifies the minimum TLS protocol version.
     */
    tlsProtocolMin: string;
    /**
     * This setting controls the behavior of the certificate revocation checking algorithm when the LDAP provider is presented with a digital certificate by an LDAP server. Acceptable values: "none", "allowNoData", "allowNoSrc", "strict". Only available for PowerScale 9.5 and above.
     */
    tlsRevocationCheckLevel: string;
    /**
     * Specifies the LDAP UID Number attribute.
     */
    uidAttribute: string;
    /**
     * Specifies the groups that cannot be resolved by the provider.
     */
    unfindableGroups: string[];
    /**
     * Specifies users that cannot be resolved by the provider.
     */
    unfindableUsers: string[];
    /**
     * Sets the LDAP Unique Group Members attribute.
     */
    uniqueGroupMembersAttribute: string;
    /**
     * Specifies a group that cannot be listed by the provider.
     */
    unlistableGroups: string[];
    /**
     * Specifies a user that cannot be listed by the provider.
     */
    unlistableUsers: string[];
    /**
     * Specifies the distinguished name of the entry at which to start LDAP searches for users.
     */
    userBaseDn: string;
    /**
     * Specifies the domain for this provider through which users are qualified.
     */
    userDomain: string;
    /**
     * Specifies the LDAP filter for user objects.
     */
    userFilter: string;
    /**
     * Specifies the depth from the base DN to perform LDAP searches. Acceptable values: "default", "base", "onelevel", "subtree", "children".
     */
    userSearchScope: string;
    /**
     * Specifies the name of the access zone in which this provider was created.
     */
    zoneName: string;
}

export interface GetNamespaceAclAcl {
    /**
     * Specifies the access control permissions for a specific user or group.
     */
    accessrights: string[];
    /**
     * Grants or denies access control permissions.
     */
    accesstype: string;
    /**
     * Grants or denies access control permissions.
     */
    inheritFlags: string[];
    /**
     * Operations for updating access control permissions. Unnecessary for access right replacing scenario
     */
    op: string;
    /**
     * Provides the JSON object for the group persona of the owner.
     */
    trustee: outputs.GetNamespaceAclAclTrustee;
}

export interface GetNamespaceAclAclTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0' or 'GID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNamespaceAclFilter {
    /**
     * Indicate the namespace to set/get acl.
     */
    namespace: string;
    /**
     * Indicates that the operation is on the access point instead of the store path.
     */
    nsaccess?: boolean;
}

export interface GetNamespaceAclGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNamespaceAclOwner {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNetworkRuleFilter {
    /**
     * If specified, only rules for this groupnet will be returned.
     */
    groupnet?: string;
    /**
     * Filter network rules by names.
     */
    names?: string[];
    /**
     * If specified, only rules for this pool will be returned.
     */
    pool?: string;
    /**
     * If specified, only rules for this subnet will be returned.
     */
    subnet?: string;
}

export interface GetNetworkRuleNetworkRule {
    /**
     * Description for the provisioning rule.
     */
    description: string;
    /**
     * Name of the groupnet this rule belongs to
     */
    groupnet: string;
    /**
     * Unique rule ID.
     */
    id: string;
    /**
     * Interface name the provisioning rule applies to.
     */
    iface: string;
    /**
     * Name of the provisioning rule.
     */
    name: string;
    /**
     * Node type the provisioning rule applies to.
     */
    nodeType: string;
    /**
     * Name of the pool this rule belongs to.
     */
    pool: string;
    /**
     * Name of the subnet this rule belongs to.
     */
    subnet: string;
}

export interface GetNetworkpoolFilter {
    /**
     * If specified, only pools with this zone name will be returned.
     */
    accessZone?: string;
    /**
     * If specified, only pools with this allocation type will be returned.
     */
    allocMethod?: string;
    /**
     * If specified, only pools for this groupnet will be returned.
     */
    groupnet?: string;
    /**
     * Filter network pools by names.
     */
    names?: string[];
    /**
     * If specified, only pools for this subnet will be returned.
     */
    subnet?: string;
}

export interface GetNetworkpoolNetworkPoolsDetail {
    /**
     * Name of a valid access zone to map IP address pool to the zone.
     */
    accessZone: string;
    /**
     * IP address format.
     */
    addrFamily: string;
    /**
     * OneFS supports the following NIC aggregation modes.
     */
    aggregationMode: string;
    /**
     * Specifies how IP address allocation is done among pool members.
     */
    allocMethod: string;
    /**
     * A description of the pool.
     */
    description: string;
    /**
     * Name of the groupnet this pool belongs to.
     */
    groupnet: string;
    /**
     * Unique Pool ID.
     */
    id: string;
    /**
     * List of interface members in this pool.
     */
    ifaces: outputs.GetNetworkpoolNetworkPoolsDetailIface[];
    /**
     * The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.
     */
    name: string;
    /**
     * Indicates that pool contains only RDMA RRoCE capable interfaces.
     */
    nfsv3RroceOnly: boolean;
    /**
     * List of IP address ranges in this pool.
     */
    ranges: outputs.GetNetworkpoolNetworkPoolsDetailRange[];
    /**
     * Rebalance policy..
     */
    rebalancePolicy: string;
    /**
     * Names of the rules in this pool.
     */
    rules: string[];
    /**
     * Time delay in seconds before a node which has been automatically unsuspended becomes usable in SmartConnect responses for pool zones.
     */
    scAutoUnsuspendDelay: number;
    /**
     * SmartConnect client connection balancing policy.
     */
    scConnectPolicy: string;
    /**
     * SmartConnect zone name for the pool.
     */
    scDnsZone: string;
    /**
     * List of SmartConnect zone aliases (DNS names) to the pool.
     */
    scDnsZoneAliases: string[];
    /**
     * SmartConnect IP failover policy.
     */
    scFailoverPolicy: string;
    /**
     * Name of SmartConnect service subnet for this pool.
     */
    scSubnet: string;
    /**
     * List of LNNs showing currently suspended nodes in SmartConnect.
     */
    scSuspendedNodes: number[];
    /**
     * Time to live value for SmartConnect DNS query responses in seconds.
     */
    scTtl: number;
    /**
     * List of interface members in this pool.
     */
    staticRoutes: outputs.GetNetworkpoolNetworkPoolsDetailStaticRoute[];
    /**
     * The name of the subnet.
     */
    subnet: string;
}

export interface GetNetworkpoolNetworkPoolsDetailIface {
    /**
     * A string that defines an interface name.
     */
    iface: string;
    /**
     * Logical Node Number (LNN) of a node.
     */
    lnn: number;
}

export interface GetNetworkpoolNetworkPoolsDetailRange {
    /**
     * High IP
     */
    high: string;
    /**
     * Low IP
     */
    low: string;
}

export interface GetNetworkpoolNetworkPoolsDetailStaticRoute {
    /**
     * Address of the gateway in the format: yyy.yyy.yyy.yyy
     */
    gateway: string;
    /**
     * Prefix length in the format: nn.
     */
    prefixlen: number;
    /**
     * Network address in the format: xxx.xxx.xxx.xxx
     */
    subnet: string;
}

export interface GetNfsExportFilter {
    /**
     * Check for conflicts when listing exports.
     */
    check?: boolean;
    /**
     * The direction of the sort.
     */
    dir?: string;
    /**
     * IDs to filter nfs exports.
     */
    ids?: number[];
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: number;
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: number;
    /**
     * If specified, only exports that explicitly reference at least one of the given paths will be returned.
     */
    path?: string;
    /**
     * Paths to filter nfs exports.
     */
    paths?: string[];
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: string;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * The field that will be used for sorting.
     */
    sort?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetNfsExportNfsExport {
    /**
     * True if all directories under the specified paths are mountable.
     */
    allDirs: boolean;
    /**
     * Specifies the block size returned by the NFS statfs procedure.
     */
    blockSize: number;
    /**
     * True if the client can set file times through the NFS set attribute request. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    canSetTime: boolean;
    /**
     * True if the case is ignored for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    caseInsensitive: boolean;
    /**
     * True if the case is preserved for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    casePreserving: boolean;
    /**
     * True if the superuser can change file ownership. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    chownRestricted: boolean;
    /**
     * Specifies the clients with root access to the export.
     */
    clients: string[];
    /**
     * True if NFS  commit  requests execute asynchronously.
     */
    commitAsynchronous: boolean;
    /**
     * Reports the paths that conflict with another export.
     */
    conflictingPaths: string[];
    /**
     * Specifies the user-defined string that is used to identify the export.
     */
    description: string;
    /**
     * Specifies the preferred size for directory read operations. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    directoryTransferSize: number;
    /**
     * Specifies the default character set encoding of the clients connecting to the export, unless otherwise specified.
     */
    encoding: string;
    /**
     * Specifies the system-assigned ID for the export. This ID is returned when an export is created through the POST method.
     */
    id: number;
    /**
     * Specifies the reported maximum number of links to a file. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    linkMax: number;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapAll: outputs.GetNfsExportNfsExportMapAll;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapFailure: outputs.GetNfsExportNfsExportMapFailure;
    /**
     * True if user mappings query the OneFS user database. When set to false, user mappings only query local authentication.
     */
    mapFull: boolean;
    /**
     * True if incoming user IDs (UIDs) are mapped to users in the OneFS user database. When set to false, incoming UIDs are applied directly to file operations.
     */
    mapLookupUid: boolean;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapNonRoot: outputs.GetNfsExportNfsExportMapNonRoot;
    /**
     * Determines whether searches for users specified in 'map_all', 'map_root' or 'map_nonroot' are retried if the search fails.
     */
    mapRetry: boolean;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapRoot: outputs.GetNfsExportNfsExportMapRoot;
    /**
     * Specifies the maximum file size for any file accessed from the export. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    maxFileSize: number;
    /**
     * Specifies the reported maximum length of a file name. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    nameMaxSize: number;
    /**
     * True if long file names result in an error. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    noTruncate: boolean;
    /**
     * Specifies the paths under /ifs that are exported.
     */
    paths: string[];
    /**
     * True if the export is set to read-only.
     */
    readOnly: boolean;
    /**
     * Specifies the clients with read-only access to the export.
     */
    readOnlyClients: string[];
    /**
     * Specifies the maximum buffer size that clients should use on NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferMaxSize: number;
    /**
     * Specifies the preferred multiple size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferMultiple: number;
    /**
     * Specifies the preferred size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferSize: number;
    /**
     * Specifies the clients with both read and write access to the export, even when the export is set to read-only.
     */
    readWriteClients: string[];
    /**
     * True if 'readdirplus' requests are enabled. Enabling this property might improve network performance and is only available for NFSv3.
     */
    readdirplus: boolean;
    /**
     * Sets the number of directory entries that are prefetched when a 'readdirplus' request is processed. (Deprecated.)
     */
    readdirplusPrefetch: number;
    /**
     * Limits the size of file identifiers returned by NFSv3+ to 32-bit values (may require remount).
     */
    return32bitFileIds: boolean;
    /**
     * Clients that have root access to the export.
     */
    rootClients: string[];
    /**
     * Specifies the authentication types that are supported for this export.
     */
    securityFlavors: string[];
    /**
     * True if set attribute operations execute asynchronously.
     */
    setattrAsynchronous: boolean;
    /**
     * Specifies the snapshot for all mounts.
     */
    snapshot: string;
    /**
     * True if symlinks are supported. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    symlinks: boolean;
    /**
     * Specifies the resolution of all time values that are returned to the clients
     */
    timeDelta: number;
    /**
     * Reports clients that cannot be resolved.
     */
    unresolvedClients: string[];
    /**
     * Specifies the action to be taken when an NFSv3+ datasync write is requested.
     */
    writeDatasyncAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ datasync write is processed.
     */
    writeDatasyncReply: string;
    /**
     * Specifies the action to be taken when an NFSv3+ filesync write is requested.
     */
    writeFilesyncAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ filesync write is processed.
     */
    writeFilesyncReply: string;
    /**
     * Specifies the maximum buffer size that clients should use on NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferMaxSize: number;
    /**
     * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferMultiple: number;
    /**
     * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferSize: number;
    /**
     * Specifies the action to be taken when an NFSv3+ unstable write is requested.
     */
    writeUnstableAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ unstable write is processed.
     */
    writeUnstableReply: string;
    /**
     * Specifies the zone in which the export is valid.
     */
    zone: string;
}

export interface GetNfsExportNfsExportMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportNfsExportMapAllPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportNfsExportMapAllSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportNfsExportMapAllUser;
}

export interface GetNfsExportNfsExportMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportNfsExportMapFailurePrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportNfsExportMapFailureSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportNfsExportMapFailureUser;
}

export interface GetNfsExportNfsExportMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportNfsExportMapNonRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportNfsExportMapNonRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportNfsExportMapNonRootUser;
}

export interface GetNfsExportNfsExportMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportNfsExportMapRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportNfsExportMapRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportNfsExportMapRootUser;
}

export interface GetNfsExportNfsExportMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportNfsExportMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetNfsExportSettingsNfsExportSettings {
    /**
     * True if all directories under the specified paths are mountable.
     */
    allDirs: boolean;
    /**
     * Specifies the block size returned by the NFS statfs procedure.
     */
    blockSize: number;
    /**
     * True if the client can set file times through the NFS set attribute request. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    canSetTime: boolean;
    /**
     * True if the case is ignored for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    caseInsensitive: boolean;
    /**
     * True if the case is preserved for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    casePreserving: boolean;
    /**
     * True if the superuser can change file ownership. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    chownRestricted: boolean;
    /**
     * True if NFS  commit  requests execute asynchronously.
     */
    commitAsynchronous: boolean;
    /**
     * Specifies the preferred size for directory read operations. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    directoryTransferSize: number;
    /**
     * Specifies the default character set encoding of the clients connecting to the export, unless otherwise specified.
     */
    encoding: string;
    /**
     * Specifies the reported maximum number of links to a file. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    linkMax: number;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapAll: outputs.GetNfsExportSettingsNfsExportSettingsMapAll;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapFailure: outputs.GetNfsExportSettingsNfsExportSettingsMapFailure;
    /**
     * True if user mappings query the OneFS user database. When set to false, user mappings only query local authentication.
     */
    mapFull: boolean;
    /**
     * True if incoming user IDs (UIDs) are mapped to users in the OneFS user database. When set to false, incoming UIDs are applied directly to file operations.
     */
    mapLookupUid: boolean;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapNonRoot: outputs.GetNfsExportSettingsNfsExportSettingsMapNonRoot;
    /**
     * Determines whether searches for users specified in 'map_all', 'map_root' or 'map_nonroot' are retried if the search fails.
     */
    mapRetry: boolean;
    /**
     * Specifies the users and groups to which non-root and root clients are mapped.
     */
    mapRoot: outputs.GetNfsExportSettingsNfsExportSettingsMapRoot;
    /**
     * Specifies the maximum file size for any file accessed from the export. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    maxFileSize: number;
    /**
     * Specifies the reported maximum length of a file name. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    nameMaxSize: number;
    /**
     * True if long file names result in an error. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
     */
    noTruncate: boolean;
    /**
     * True if the export is set to read-only.
     */
    readOnly: boolean;
    /**
     * Specifies the maximum buffer size that clients should use on NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferMaxSize: number;
    /**
     * Specifies the preferred multiple size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferMultiple: number;
    /**
     * Specifies the preferred size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    readTransferSize: number;
    /**
     * True if 'readdirplus' requests are enabled. Enabling this property might improve network performance and is only available for NFSv3.
     */
    readdirplus: boolean;
    /**
     * Sets the number of directory entries that are prefetched when a 'readdirplus' request is processed. (Deprecated.)
     */
    readdirplusPrefetch: number;
    /**
     * Limits the size of file identifiers returned by NFSv3+ to 32-bit values (may require remount).
     */
    return32bitFileIds: boolean;
    /**
     * Specifies the authentication types that are supported for this export.
     */
    securityFlavors: string[];
    /**
     * True if set attribute operations execute asynchronously.
     */
    setattrAsynchronous: boolean;
    /**
     * Specifies the snapshot for all mounts.
     */
    snapshot: string;
    /**
     * True if symlinks are supported. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    symlinks: boolean;
    /**
     * Specifies the resolution of all time values that are returned to the clients
     */
    timeDelta: number;
    /**
     * Specifies the action to be taken when an NFSv3+ datasync write is requested.
     */
    writeDatasyncAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ datasync write is processed.
     */
    writeDatasyncReply: string;
    /**
     * Specifies the action to be taken when an NFSv3+ filesync write is requested.
     */
    writeFilesyncAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ filesync write is processed.
     */
    writeFilesyncReply: string;
    /**
     * Specifies the maximum buffer size that clients should use on NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferMaxSize: number;
    /**
     * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferMultiple: number;
    /**
     * Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
     */
    writeTransferSize: number;
    /**
     * Specifies the action to be taken when an NFSv3+ unstable write is requested.
     */
    writeUnstableAction: string;
    /**
     * Specifies the stability disposition returned when an NFSv3+ unstable write is processed.
     */
    writeUnstableReply: string;
    /**
     * Specifies the zone in which the export is valid.
     */
    zone: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportSettingsNfsExportSettingsMapAllPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportSettingsNfsExportSettingsMapAllSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportSettingsNfsExportSettingsMapAllUser;
}

export interface GetNfsExportSettingsNfsExportSettingsMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportSettingsNfsExportSettingsMapFailurePrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportSettingsNfsExportSettingsMapFailureSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportSettingsNfsExportSettingsMapFailureUser;
}

export interface GetNfsExportSettingsNfsExportSettingsMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportSettingsNfsExportSettingsMapNonRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportSettingsNfsExportSettingsMapNonRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportSettingsNfsExportSettingsMapNonRootUser;
}

export interface GetNfsExportSettingsNfsExportSettingsMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.GetNfsExportSettingsNfsExportSettingsMapRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.GetNfsExportSettingsNfsExportSettingsMapRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.GetNfsExportSettingsNfsExportSettingsMapRootUser;
}

export interface GetNfsExportSettingsNfsExportSettingsMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsExportSettingsNfsExportSettingsMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetNfsZoneSettingsFilter {
    /**
     * Access zone
     */
    zone?: string;
}

export interface GetNfsZoneSettingsNfsZoneSettings {
    /**
     * If true, sends owners and groups as UIDs and GIDs when look up fails or if the 'nfsv4_no_name' property is set to 1.
     */
    nfsv4AllowNumericIds: boolean;
    /**
     * Specifies the domain or realm through which users and groups are associated.
     */
    nfsv4Domain: string;
    /**
     * If true, sends owners and groups without a domain name.
     */
    nfsv4NoDomain: boolean;
    /**
     * If true, sends UIDs and GIDs without a domain name.
     */
    nfsv4NoDomainUids: boolean;
    /**
     * If true, sends owners and groups as UIDs and GIDs.
     */
    nfsv4NoNames: boolean;
    /**
     * If true, replaces the owner or group domain with an NFS domain name.
     */
    nfsv4ReplaceDomain: boolean;
    /**
     * Specifies the access zones in which these settings apply.
     */
    zone: string;
}

export interface GetNtpserverFilter {
    /**
     * Filter NTP Servers by names.
     */
    names?: string[];
}

export interface GetNtpserverNtpServersDetail {
    /**
     * Field ID.
     */
    id: string;
    /**
     * Key value from key_file that maps to this server.
     */
    key: string;
    /**
     * NTP server name.
     */
    name: string;
}

export interface GetQuotaFilter {
    /**
     * Only list quotas with this enforcement (non-accounting).
     */
    enforced?: boolean;
    /**
     * Set to true to only list quotas which have exceeded one or more of their thresholds.
     */
    exceeded?: boolean;
    /**
     * Only list quotas with this setting for include_snapshots.
     */
    includeSnapshots?: boolean;
    /**
     * Only list quotas matching this path (see also recurse_path_*).
     */
    path?: string;
    /**
     * Only list user or group quotas matching this persona (must be used with the corresponding type argument).
     */
    persona?: string;
    /**
     * If used with the path argument, match all quotas at that path or any descendent sub-directory.
     */
    recursePathChildren?: boolean;
    /**
     * If used with the path argument, match all quotas at that path or any parent directory.
     */
    recursePathParents?: boolean;
    /**
     * Use the named report as a source rather than the live quotas.
     */
    reportId?: string;
    /**
     * Only list quotas matching this type.
     */
    type?: string;
    /**
     * Optional named zone to use for user and group resolution.
     */
    zone?: string;
}

export interface GetQuotaQuota {
    /**
     * If true, SMB shares using the quota directory see the quota thresholds as share size.
     */
    container: boolean;
    /**
     * Represents the ratio of logical space provided to physical space used. This accounts for protection overhead, metadata, and compression ratios for the data.
     */
    efficiencyRatio: number;
    /**
     * True if the quota provides enforcement, otherwise an accounting quota.
     */
    enforced: boolean;
    /**
     * The system ID given to the quota.
     */
    id: string;
    /**
     * If true, quota governs snapshot data as well as head data.
     */
    includeSnapshots: boolean;
    /**
     * For user, group and directory quotas, true if the quota is linked and controlled by a parent default-* quota. Linked quotas cannot be modified until they are unlinked.
     */
    linked: boolean;
    /**
     * Summary of notifications: 'custom' indicates one or more notification rules available from the notifications sub-resource; 'default' indicates system default rules are used; 'disabled' indicates that no notifications will be used for this quota.; 'badmap' indicates that notification rule has problem in rule map.
     */
    notifications: string;
    /**
     * The ifs path governed.
     */
    path: string;
    /**
     * Specifies the persona of the file group.
     */
    persona: outputs.GetQuotaQuotaPersona;
    /**
     * True if the default resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    ready: boolean;
    /**
     * Represents the ratio of logical space provided to physical data space used. This accounts for compression and data deduplication effects.
     */
    reductionRatio: number;
    /**
     * The thresholds of quota
     */
    thresholds: outputs.GetQuotaQuotaThresholds;
    /**
     * Thresholds apply on quota accounting metric.
     */
    thresholdsOn: string;
    /**
     * The type of quota.
     */
    type: string;
    /**
     * The usage of quota
     */
    usage: outputs.GetQuotaQuotaUsage;
}

export interface GetQuotaQuotaPersona {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetQuotaQuotaThresholds {
    /**
     * Usage bytes at which notifications will be sent but writes will not be denied.
     */
    advisory: number;
    /**
     * True if the advisory threshold has been hit.
     */
    advisoryExceeded: boolean;
    /**
     * Time at which advisory threshold was hit.
     */
    advisoryLastExceeded: number;
    /**
     * Usage bytes at which further writes will be denied.
     */
    hard: number;
    /**
     * True if the hard threshold has been hit.
     */
    hardExceeded: boolean;
    /**
     * Time at which hard threshold was hit.
     */
    hardLastExceeded: number;
    /**
     * Advisory threshold as percent of hard threshold. Usage bytes at which notifications will be sent but writes will not be denied.
     */
    percentAdvisory: number;
    /**
     * Soft threshold as percent of hard threshold. Usage bytes at which notifications will be sent and soft grace time will be started.
     */
    percentSoft: number;
    /**
     * Usage bytes at which notifications will be sent and soft grace time will be started.
     */
    soft: number;
    /**
     * True if the soft threshold has been hit.
     */
    softExceeded: boolean;
    /**
     * Time in seconds after which the soft threshold has been hit before writes will be denied.
     */
    softGrace: number;
    /**
     * Time at which soft threshold was hit
     */
    softLastExceeded: number;
}

export interface GetQuotaQuotaUsage {
    /**
     * Bytes used by governed data apparent to application.
     */
    applogical: number;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical: number;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady: boolean;
    /**
     * Physical data usage adjusted to account for shadow store efficiency
     */
    fsphysical: number;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady: boolean;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes: number;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady: boolean;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical: number;
    /**
     * Number of physical blocks for file data
     */
    physicalData: number;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady: boolean;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection: number;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady: boolean;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady: boolean;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs: number;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady: boolean;
}

export interface GetRoleFilter {
    /**
     * Filter roles by names.
     */
    names?: string[];
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetRoleRolesDetail {
    /**
     * Specifies the description of the role.
     */
    description: string;
    /**
     * Specifies the ID of the role.
     */
    id: string;
    /**
     * Specifies the users or groups that have this role.
     */
    members: outputs.GetRoleRolesDetailMember[];
    /**
     * Specifies the name of the role.
     */
    name: string;
    /**
     * Specifies the privileges granted by this role.
     */
    privileges: outputs.GetRoleRolesDetailPrivilege[];
}

export interface GetRoleRolesDetailMember {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetRoleRolesDetailPrivilege {
    /**
     * Specifies the ID of the privilege.
     */
    id: string;
    /**
     * Specifies the name of the privilege.
     */
    name: string;
    /**
     * permission of the privilege, 'r' = read , 'x' = read-execute, 'w' = read-execute-write, '-' = no permission
     */
    permission: string;
}

export interface GetRoleprivilegeFilter {
    /**
     * Filter Role Privileges by names.
     */
    names?: string[];
}

export interface GetRoleprivilegeRolePrivilegesDetail {
    /**
     * Specifies the general categorization of the privilege.
     */
    category: string;
    /**
     * Specifies a short description of the privilege.
     */
    description: string;
    /**
     * Specifies the ID of the privilege.
     */
    id: string;
    /**
     * Specifies the name of the privilege.
     */
    name: string;
    /**
     * Specifies the parent ID of the privilege.
     */
    parentId: string;
    /**
     * Permissions the privilege has r=read , x=read-execute, w=read-execute-write.
     */
    permission: string;
    /**
     * Specifies the level of the privilege.
     */
    privilegelevel: string;
    /**
     * Specifies the associated uri for the privilege.
     */
    uri: string;
}

export interface GetS3BucketFilter {
    /**
     * Specifies the name of the owner.
     */
    owner?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetS3BucketS3Bucket {
    /**
     * Specifies properties for an S3 Access Control Entry.
     */
    acls: outputs.GetS3BucketS3BucketAcl[];
    /**
     * Description for this S3 bucket.
     */
    description: string;
    /**
     * Bucket ID.
     */
    id: string;
    /**
     * Bucket name.
     */
    name: string;
    /**
     * Set behavior of modifying object acls
     */
    objectAclPolicy: string;
    /**
     * Specifies the name of the owner.
     */
    owner: string;
    /**
     * Path of bucket within /ifs.
     */
    path: string;
    /**
     * Zone ID
     */
    zid: number;
}

export interface GetS3BucketS3BucketAcl {
    /**
     * Specifies the persona of the file group.
     */
    grantee: outputs.GetS3BucketS3BucketAclGrantee;
    /**
     * Specifies the S3 rights being allowed.
     */
    permission: string;
}

export interface GetS3BucketS3BucketAclGrantee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetSmartpoolSettingsSpilloverTarget {
    /**
     * Target pool ID if target specified, otherwise null.
     */
    id: number;
    /**
     * Target pool name if target specified, otherwise null.
     */
    name: string;
    /**
     * Type of target pool.
     */
    type: string;
}

export interface GetSmbServerSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
}

export interface GetSmbServerSettingsSmbServerSettings {
    /**
     * Only enumerate files and folders the requesting user has access to.
     */
    accessBasedShareEnum: boolean;
    /**
     * Specify level of file share audit events to log.
     */
    auditFileshare: string;
    /**
     * Specify the level of logon audit events to log.
     */
    auditLogon: string;
    /**
     * Allow access to .snapshot directories in share subdirectories.
     */
    dotSnapAccessibleChild: boolean;
    /**
     * Allow access to the .snapshot directory in the root of the share.
     */
    dotSnapAccessibleRoot: boolean;
    /**
     * Show .snapshot directories in share subdirectories.
     */
    dotSnapVisibleChild: boolean;
    /**
     * Show the .snapshot directory in the root of a share.
     */
    dotSnapVisibleRoot: boolean;
    /**
     * Indicates whether the server supports signed SMB packets.
     */
    enableSecuritySignatures: boolean;
    /**
     * Specifies the fully-qualified user to use for guest access.
     */
    guestUser: string;
    /**
     * Specify whether to ignore EAs on files.
     */
    ignoreEas: boolean;
    /**
     * Specify the number of OneFS driver worker threads per CPU.
     */
    onefsCpuMultiplier: number;
    /**
     * Set the maximum number of OneFS driver worker threads.
     */
    onefsNumWorkers: number;
    /**
     * If SMB3 encryption is enabled, reject unencrypted access from clients.
     */
    rejectUnencryptedAccess: boolean;
    /**
     * Indicates whether the server requires signed SMB packets.
     */
    requireSecuritySignatures: boolean;
    /**
     * Enable Server Side Copy.
     */
    serverSideCopy: boolean;
    /**
     * Provides a description of the server.
     */
    serverString: string;
    /**
     * Specify whether service is enabled.
     */
    service: boolean;
    /**
     * Specify the number of SRV service worker threads per CPU.
     */
    srvCpuMultiplier: number;
    /**
     * Set the maximum number of SRV service worker threads.
     */
    srvNumWorkers: number;
    /**
     * Support multichannel.
     */
    supportMultichannel: boolean;
    /**
     * Support NetBIOS.
     */
    supportNetbios: boolean;
    /**
     * Support the SMB2 protocol on the server.
     */
    supportSmb2: boolean;
    /**
     * Support the SMB3 encryption on the server.
     */
    supportSmb3Encryption: boolean;
}

export interface GetSmbShareFilter {
    /**
     * The direction of the sort.
     */
    dir?: string;
    /**
     * Return no more than this many results at once (see resume).
     */
    limit?: number;
    /**
     * Names to filter smb shares.
     */
    names?: string[];
    /**
     * The position of the first item returned for a paginated query within the full result set.
     */
    offset?: number;
    /**
     * Continue returning results from previous call using this token (token should come from the previous call, resume cannot be used with other options).
     */
    resume?: string;
    /**
     * If specified as "effective" or not specified, all fields are returned. If specified as "user", only fields with non-default values are shown. If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * The field that will be used for sorting.
     */
    sort?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetSmbShareSettingsFilter {
    /**
     * If specified as "effective" or not specified, all fields are returned.  If specified as "user", only fields with non-default values are shown.  If specified as "default", the original values are returned.
     */
    scope?: string;
    /**
     * Specifies which access zone to use.
     */
    zone?: string;
}

export interface GetSmbShareSettingsSmbShareSettings {
    /**
     * Only enumerate files and folders the requesting user has access to.
     */
    accessBasedEnumeration: boolean;
    /**
     * Access-based enumeration on only the root directory of the share.
     */
    accessBasedEnumerationRootOnly: boolean;
    /**
     * Allow deletion of read-only files in the share.
     */
    allowDeleteReadonly: boolean;
    /**
     * Allows users to execute files they have read rights for.
     */
    allowExecuteAlways: boolean;
    /**
     * Persistent open timeout for the share.
     */
    caTimeout: number;
    /**
     * Specify the level of write-integrity on continuously available shares. Acceptable values: none, write-read-coherent, full
     */
    caWriteIntegrity: string;
    /**
     * Specify level of change notification alerts on the share. Acceptable values: all, norecurse, none
     */
    changeNotify: string;
    /**
     * Specify if persistent opens are allowed on the share.
     */
    continuouslyAvailable: boolean;
    /**
     * Set the create permissions for new files and directories in share. Acceptable values: default acl, inherit mode bits, use create mask and mode
     */
    createPermissions: string;
    /**
     * Client-side caching policy for the shares. Acceptable values: manual, documents, programs, none
     */
    cscPolicy: string;
    /**
     * Unix umask or mode bits.
     */
    directoryCreateMask: number;
    /**
     * Unix umask or mode bits.
     */
    directoryCreateMode: number;
    /**
     * Unix umask or mode bits.
     */
    fileCreateMask: number;
    /**
     * Unix umask or mode bits.
     */
    fileCreateMode: number;
    /**
     * Specifies the list of file extensions.
     */
    fileFilterExtensions: string[];
    /**
     * Specifies if filter list is for deny or allow. Default is deny.
     */
    fileFilterType: string;
    /**
     * Enables file filtering on the share.
     */
    fileFilteringEnabled: boolean;
    /**
     * Hide files and directories that begin with a period '.'.
     */
    hideDotFiles: boolean;
    /**
     * An ACL expressing which hosts are allowed access. A deny clause must be the final entry.
     */
    hostAcls: string[];
    /**
     * Specify the condition in which user access is done as the guest account. Acceptable values: always, bad user, never
     */
    impersonateGuest: string;
    /**
     * User account to be used as guest account.
     */
    impersonateUser: string;
    /**
     * Specifies the wchar_t starting point for automatic byte mangling.
     */
    mangleByteStart: number;
    /**
     * Character mangle map.
     */
    mangleMaps: string[];
    /**
     * Support NTFS ACLs on files and directories.
     */
    ntfsAclSupport: boolean;
    /**
     * Allow oplock requests.
     */
    oplocks: boolean;
    /**
     * Enables SMB3 encryption for the share.
     */
    smb3EncryptionEnabled: boolean;
    /**
     * Enables sparse file.
     */
    sparseFile: boolean;
    /**
     * Specifies if persistent opens would do strict lockout on the share.
     */
    strictCaLockout: boolean;
    /**
     * Handle SMB flush operations.
     */
    strictFlush: boolean;
    /**
     * Specifies whether byte range locks contend against SMB I/O.
     */
    strictLocking: boolean;
    /**
     * Name of the access zone in which to update settings
     */
    zone: string;
}

export interface GetSmbShareSmbShare {
    /**
     * Only enumerate files and folders the requesting user has access to.
     */
    accessBasedEnumeration: boolean;
    /**
     * Access-based enumeration on only the root directory of the share.
     */
    accessBasedEnumerationRootOnly: boolean;
    /**
     * Allow deletion of read-only files in the share.
     */
    allowDeleteReadonly: boolean;
    /**
     * Allows users to execute files they have read rights for.
     */
    allowExecuteAlways: boolean;
    /**
     * Allow automatic expansion of variables for home directories.
     */
    allowVariableExpansion: boolean;
    /**
     * Automatically create home directories.
     */
    autoCreateDirectory: boolean;
    /**
     * Share is visible in net view and the browse list.
     */
    browsable: boolean;
    /**
     * Persistent open timeout for the share.
     */
    caTimeout: number;
    /**
     * Specify the level of write-integrity on continuously available shares.
     */
    caWriteIntegrity: string;
    /**
     * Level of change notification alerts on the share.
     */
    changeNotify: string;
    /**
     * Specify if persistent opens are allowed on the share.
     */
    continuouslyAvailable: boolean;
    /**
     * Create permissions for new files and directories in share.
     */
    createPermissions: string;
    /**
     * Client-side caching policy for the shares.
     */
    cscPolicy: string;
    /**
     * Description for this SMB share.
     */
    description: string;
    /**
     * Directory create mask bits.
     */
    directoryCreateMask: number;
    /**
     * Directory create mode bits.
     */
    directoryCreateMode: number;
    /**
     * File create mask bits.
     */
    fileCreateMask: number;
    /**
     * File create mode bits.
     */
    fileCreateMode: number;
    /**
     * Specifies the list of file extensions.
     */
    fileFilterExtensions: string[];
    /**
     * Specifies if filter list is for deny or allow. Default is deny.
     */
    fileFilterType: string;
    /**
     * Enables file filtering on this zone.
     */
    fileFilteringEnabled: boolean;
    /**
     * Hide files and directories that begin with a period '.'.
     */
    hideDotFiles: boolean;
    /**
     * An ACL expressing which hosts are allowed access. A deny clause must be the final entry.
     */
    hostAcls: string[];
    /**
     * Share ID.
     */
    id: string;
    /**
     * Specify the condition in which user access is done as the guest account.
     */
    impersonateGuest: string;
    /**
     * User account to be used as guest account.
     */
    impersonateUser: string;
    /**
     * Set the inheritable ACL on the share path.
     */
    inheritablePathAcl: boolean;
    /**
     * Specifies the wchar_t starting point for automatic byte mangling.
     */
    mangleByteStart: number;
    /**
     * Character mangle map.
     */
    mangleMaps: string[];
    /**
     * Share name.
     */
    name: string;
    /**
     * Support NTFS ACLs on files and directories.
     */
    ntfsAclSupport: boolean;
    /**
     * Support oplocks.
     */
    oplocks: boolean;
    /**
     * Path of share within /ifs.
     */
    path: string;
    /**
     * Specifies an ordered list of permission modifications.
     */
    permissions: outputs.GetSmbShareSmbSharePermission[];
    /**
     * Allow account to run as root.
     */
    runAsRoots: outputs.GetSmbShareSmbShareRunAsRoot[];
    /**
     * Enables SMB3 encryption for the share.
     */
    smb3EncryptionEnabled: boolean;
    /**
     * Enables sparse file.
     */
    sparseFile: boolean;
    /**
     * Specifies if persistent opens would do strict lockout on the share.
     */
    strictCaLockout: boolean;
    /**
     * Handle SMB flush operations.
     */
    strictFlush: boolean;
    /**
     * Specifies whether byte range locks contend against SMB I/O.
     */
    strictLocking: boolean;
    /**
     * Numeric ID of the access zone which contains this SMB share
     */
    zid: number;
}

export interface GetSmbShareSmbSharePermission {
    /**
     * Specifies the file system rights that are allowed or denied.
     */
    permission: string;
    /**
     * Determines whether the permission is allowed or denied.
     */
    permissionType: string;
    /**
     * Specifies the persona of the file group.
     */
    trustee: outputs.GetSmbShareSmbSharePermissionTrustee;
}

export interface GetSmbShareSmbSharePermissionTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetSmbShareSmbShareRunAsRoot {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface GetSnapshotFilter {
    path?: string;
}

export interface GetSnapshotScheduleFilter {
    /**
     * The direction of the sort.Supported Values:ASC , DESC
     */
    dir?: string;
    /**
     * Return no more than this many results at once.
     */
    limit?: number;
    /**
     * Names to filter snapshot schedules.
     */
    names?: string[];
    /**
     * The field that will be used for sorting. Choices are id, name, path, pattern, schedule, duration, alias, next_run, and next_snapshot. Default is id.
     */
    sort?: string;
}

export interface GetSnapshotScheduleSchedule {
    /**
     * Alias name to create for each snapshot.
     */
    alias: string;
    /**
     * Time in seconds added to creation time to construction expiration time.
     */
    duration: number;
    /**
     * The system ID given to the schedule.
     */
    id: number;
    /**
     * The schedule name.
     */
    name: string;
    /**
     * Unix Epoch time of next snapshot to be created.
     */
    nextRun: number;
    /**
     * Formatted name (see pattern) of next snapshot to be created
     */
    nextSnapshot: string;
    /**
     * The /ifs path snapshotted.
     */
    path: string;
    /**
     * Pattern expanded with strftime to create snapshot names.
     */
    pattern: string;
    /**
     * The isidate compatible natural language description of the schedule.
     */
    schedule: string;
}

export interface GetSnapshotSnapshotsDetail {
    /**
     * The name of the alias, none for real snapshots.
     */
    alias: string;
    /**
     * The Unix Epoch time the snapshot was created.
     */
    created: number;
    /**
     * The Unix Epoch time the snapshot will expire and be eligible for automatic deletion.
     */
    expires: number;
    /**
     * True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of lock.
     */
    hasLocks: boolean;
    /**
     * The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
     */
    id: string;
    /**
     * The user or system supplied snapshot name. This will be null for snapshots pending delete.
     */
    name: string;
    /**
     * The /ifs path snapshotted.
     */
    path: string;
    /**
     * Percentage of /ifs used for storing this snapshot.
     */
    pctFilesystem: number;
    /**
     * Percentage of configured snapshot reserved used for storing this snapshot.
     */
    pctReserve: number;
    /**
     * The name of the schedule used to create this snapshot, if applicable.
     */
    schedule: string;
    /**
     * The amount of time from creation before the snapshot will expire and be eligible for automatic deletion.
     */
    setExpires: string;
    /**
     * The amount of shadow bytes referred to by this snapshot.
     */
    shadowBytes: number;
    /**
     * The amount of storage in bytes used to store this snapshot.
     */
    size: number;
    /**
     * Snapshot state.
     */
    state: string;
    /**
     * The ID of the snapshot pointed to if this is an alias. 18446744073709551615 (max uint64) is returned for an alias to the live filesystem.
     */
    targetId: number;
    /**
     * The name of the snapshot pointed to if this is an alias.
     */
    targetName: string;
}

export interface GetSubnetFilter {
    /**
     * Specifies which groupnet to query.
     */
    groupnetName?: string;
    /**
     * List of subnet name.
     */
    names?: string[];
}

export interface GetSubnetSubnet {
    /**
     * IP address format.
     */
    addrFamily: string;
    /**
     * The base IP address.
     */
    baseAddr: string;
    /**
     * A description of the subnet.
     */
    description: string;
    /**
     * List of Direct Server Return addresses.
     */
    dsrAddrs: string[];
    /**
     * Gateway IP address.
     */
    gateway: string;
    /**
     * Gateway priority.
     */
    gatewayPriority: number;
    /**
     * Name of the groupnet this subnet belongs to.
     */
    groupnet: string;
    /**
     * Unique Subnet ID.
     */
    id: string;
    /**
     * MTU of the subnet.
     */
    mtu: number;
    /**
     * The name of the subnet.
     */
    name: string;
    /**
     * Name of the pools in the subnet.
     */
    pools: string[];
    /**
     * Subnet Prefix Length.
     */
    prefixlen: number;
    /**
     * List of IP addresses that SmartConnect listens for DNS requests.
     */
    scServiceAddrs: outputs.GetSubnetSubnetScServiceAddr[];
    /**
     * Domain Name corresponding to the SmartConnect Service Address.
     */
    scServiceName: string;
    /**
     * VLAN tagging enabled or disabled.
     */
    vlanEnabled: boolean;
    /**
     * VLAN ID for all interfaces in the subnet.
     */
    vlanId: number;
}

export interface GetSubnetSubnetScServiceAddr {
    /**
     * High IP
     */
    high: string;
    /**
     * Low IP
     */
    low: string;
}

export interface GetUserFilter {
    /**
     * If true, only return cached objects.
     */
    cached?: boolean;
    /**
     * Filter users by domain.
     */
    domain?: string;
    /**
     * Enumerate all users that a group is a member of.
     */
    memberOf?: boolean;
    /**
     * Filter users by name prefix.
     */
    namePrefix?: string;
    /**
     * List of user identity.
     */
    names?: outputs.GetUserFilterName[];
    /**
     * Filter users by provider.
     */
    provider?: string;
    /**
     * Filter users by zone.
     */
    zone?: string;
}

export interface GetUserFilterName {
    /**
     * Specifies a user name.
     */
    name?: string;
    /**
     * Specifies a numeric user identifier.
     */
    uid?: number;
}

export interface GetUserGroupFilter {
    /**
     * If true, only return cached objects.
     */
    cached?: boolean;
    /**
     * Filter user groups by domain.
     */
    domain?: string;
    /**
     * Filter user groups by name prefix.
     */
    namePrefix?: string;
    /**
     * List of user group identity.
     */
    names?: outputs.GetUserGroupFilterName[];
    /**
     * Filter user groups by provider.
     */
    provider?: string;
    /**
     * Filter user groups by zone.
     */
    zone?: string;
}

export interface GetUserGroupFilterName {
    /**
     * Specifies a numeric user group identifier.
     */
    gid?: number;
    /**
     * Specifies a user group name.
     */
    name?: string;
}

export interface GetUserGroupUserGroup {
    /**
     * Specifies the distinguished name for the user group.
     */
    dn: string;
    /**
     * Specifies the DNS domain.
     */
    dnsDomain: string;
    /**
     * Specifies the domain that the object is part of.
     */
    domain: string;
    /**
     * If true, the GID was generated.
     */
    generatedGid: boolean;
    /**
     * Specifies a user group identifier.
     */
    gid: string;
    /**
     * Specifies the user group ID.
     */
    id: string;
    /**
     * List of members of group. Group Member can be user or group.
     */
    members: outputs.GetUserGroupUserGroupMember[];
    /**
     * Specifies a user group name.
     */
    name: string;
    /**
     * Specifies the authentication provider that the object belongs to.
     */
    provider: string;
    /**
     * List of roles.
     */
    roles: string[];
    /**
     * Specifies a user group name.
     */
    samAccountName: string;
    /**
     * Specifies a security identifier.
     */
    sid: string;
    /**
     * Specifies the object type.
     */
    type: string;
}

export interface GetUserGroupUserGroupMember {
    /**
     * Specifies a user or group id.
     */
    id: string;
    /**
     * Specifies a user or group name.
     */
    name: string;
    /**
     * Specifies the object type.
     */
    type: string;
}

export interface GetUserMappingRulesFilter {
    /**
     * Names filter for source user name or target user name.
     */
    names?: string[];
    /**
     * Operators filter for user mapping rules.
     */
    operators?: string[];
    /**
     * The zone to which the user mapping applies. Defaults to System.
     */
    zone?: string;
}

export interface GetUserMappingRulesUserMappingRule {
    /**
     * Specifies the operator to make rules on specified users or groups.
     */
    operator: string;
    /**
     * Specifies the mapping options for this user mapping rule.
     */
    options: outputs.GetUserMappingRulesUserMappingRuleOptions;
    /**
     * Specifies the source user information that the rule can be applied from.
     */
    sourceUser: outputs.GetUserMappingRulesUserMappingRuleSourceUser;
    /**
     * Specifies the target user information that the rule can be applied to.
     */
    targetUser: outputs.GetUserMappingRulesUserMappingRuleTargetUser;
}

export interface GetUserMappingRulesUserMappingRuleOptions {
    /**
     * If true, and the rule was applied successfully, stop processing further.
     */
    break: boolean;
    /**
     * Specifies the default user information that can be applied if the final credentials do not have valid UID and GID information.
     */
    defaultUser: outputs.GetUserMappingRulesUserMappingRuleOptionsDefaultUser;
    /**
     * If true, the primary GID and primary group SID should be copied to the existing credential.
     */
    group: boolean;
    /**
     * If true, all additional identifiers should be copied to the existing credential.
     */
    groups: boolean;
    /**
     * If true, the primary UID and primary user SID should be copied to the existing credential.
     */
    user: boolean;
}

export interface GetUserMappingRulesUserMappingRuleOptionsDefaultUser {
    /**
     * Specifies the domain of the user that is being mapped.
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped.
     */
    user: string;
}

export interface GetUserMappingRulesUserMappingRuleSourceUser {
    /**
     * Specifies the domain of the user that is being mapped.
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped.
     */
    user: string;
}

export interface GetUserMappingRulesUserMappingRuleTargetUser {
    /**
     * Specifies the domain of the user that is being mapped.
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped.
     */
    user: string;
}

export interface GetUserMappingRulesUserMappingRulesParameters {
    /**
     * Specifies the default UNIX user information that can be applied if the final credentials do not have valid UID and GID information.
     */
    defaultUnixUser: outputs.GetUserMappingRulesUserMappingRulesParametersDefaultUnixUser;
}

export interface GetUserMappingRulesUserMappingRulesParametersDefaultUnixUser {
    /**
     * Specifies the domain of the user that is being mapped.
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped.
     */
    user: string;
}

export interface GetUserUser {
    /**
     * Specifies a principal name for the user.
     */
    dn?: string;
    /**
     * Specifies the DNS domain.
     */
    dnsDomain?: string;
    /**
     * Specifies the domain that the object is part of.
     */
    domain?: string;
    /**
     * Specifies an email address.
     */
    email?: string;
    /**
     * If true, the authenticated user is enabled.
     */
    enabled?: boolean;
    /**
     * If true, the authenticated user has expired.
     */
    expired?: boolean;
    /**
     * Specifies the Unix Epoch time at which the authenticated user will expire.
     */
    expiry?: number;
    /**
     * Specifies the GECOS value, which is usually the full name.
     */
    gecos?: string;
    /**
     * If true, the GID was generated.
     */
    generatedGid?: boolean;
    /**
     * If true, the UID was generated.
     */
    generatedUid?: boolean;
    /**
     * If true, the UPN was generated.
     */
    generatedUpn?: boolean;
    /**
     * Specifies a group identifier.
     */
    gid?: string;
    /**
     * Specifies a home directory for the user.
     */
    homeDirectory?: string;
    /**
     * Specifies the user ID.
     */
    id?: string;
    /**
     * If true, indicates that the account is locked.
     */
    locked?: boolean;
    /**
     * Specifies the maximum time in seconds allowed before the password expires.
     */
    maxPasswordAge?: number;
    /**
     * Specifies a user name.
     */
    name?: string;
    /**
     * If true, the password has expired.
     */
    passwordExpired?: boolean;
    /**
     * If true, the password is allowed to expire.
     */
    passwordExpires?: boolean;
    /**
     * Specifies the time in Unix Epoch seconds that the password will expire.
     */
    passwordExpiry?: number;
    /**
     * Specifies the last time the password was set.
     */
    passwordLastSet?: number;
    /**
     * Specifies the persona of the primary group.
     */
    primaryGroupSid?: string;
    /**
     * If true, Prompts the user to change their password at the next login.
     */
    promptPasswordChange?: boolean;
    /**
     * Specifies the authentication provider that the object belongs to.
     */
    provider?: string;
    /**
     * List of roles.
     */
    roles: string[];
    /**
     * Specifies a user name.
     */
    samAccountName?: string;
    /**
     * Specifies a path to the shell for the user.
     */
    shell?: string;
    /**
     * Specifies a security identifier.
     */
    sid?: string;
    /**
     * Specifies the object type.
     */
    type?: string;
    /**
     * Specifies a user identifier.
     */
    uid?: string;
    /**
     * Specifies a principal name for the user.
     */
    upn?: string;
    /**
     * Specifies whether the password for the user can be changed.
     */
    userCanChangePassword?: boolean;
}

export interface NamespaceAclAcl {
    /**
     * Specifies the access control permissions for a specific user or group.
     */
    accessrights: string[];
    /**
     * Grants or denies access control permissions.
     */
    accesstype: string;
    /**
     * Grants or denies access control permissions.
     */
    inheritFlags: string[];
    /**
     * Operations for updating access control permissions. Unnecessary for access right replacing scenario
     */
    op: string;
    /**
     * Provides the JSON object for the group persona of the owner.
     */
    trustee: outputs.NamespaceAclAclTrustee;
}

export interface NamespaceAclAclCustom {
    /**
     * Specifies the access control permissions for a specific user or group. Options: std_delete, std_read_dac, std_write_dac, std_write_owner, std_synchronize, std_required, generic_all, generic_read, generic_write, generic_exec, dir_gen_all, dir_gen_read, dir_gen_write, dir_gen_execute, file_gen_all, file_gen_read, file_gen_write, file_gen_execute, modify, file_read, file_write, append, execute, file_read_attr, file_write_attr, file_read_ext_attr, file_write_ext_attr, delete_child, list, add_file, add_subdir, traverse, dir_read_attr, dir_write_attr, dir_read_ext_attr, dir_write_ext_attr
     */
    accessrights?: string[];
    /**
     * Grants or denies access control permissions. Options: allow, deny
     */
    accesstype: string;
    /**
     * Grants or denies access control permissions. Options: object_inherit, container_inherit, inherit_only, no_prop_inherit, inherited_ace
     */
    inheritFlags?: string[];
    /**
     * Operations for updating access control permissions. Unnecessary for access right replacing scenario
     */
    op?: string;
    /**
     * Provides the JSON object for the group persona of the owner.
     */
    trustee: outputs.NamespaceAclAclCustomTrustee;
}

export interface NamespaceAclAclCustomTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0' or 'GID:0'
     */
    id?: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: string;
}

export interface NamespaceAclAclTrustee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0' or 'GID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NamespaceAclGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NamespaceAclOwner {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NetworkpoolIface {
    /**
     * A string that defines an interface name.
     */
    iface: string;
    /**
     * Logical Node Number (LNN) of a node.
     */
    lnn: number;
}

export interface NetworkpoolRange {
    /**
     * High IP
     */
    high: string;
    /**
     * Low IP
     */
    low: string;
}

export interface NetworkpoolStaticRoute {
    /**
     * Address of the gateway in the format: yyy.yyy.yyy.yyy
     */
    gateway: string;
    /**
     * Prefix length in the format: nn.
     */
    prefixlen: number;
    /**
     * Network address in the format: xxx.xxx.xxx.xxx
     */
    subnet: string;
}

export interface NfsExportMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportMapAllPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportMapAllSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportMapAllUser;
}

export interface NfsExportMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportMapFailurePrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportMapFailureSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportMapFailureUser;
}

export interface NfsExportMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportMapNonRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportMapNonRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportMapNonRootUser;
}

export interface NfsExportMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportMapRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportMapRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportMapRootUser;
}

export interface NfsExportMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapAll {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportSettingsMapAllPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportSettingsMapAllSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportSettingsMapAllUser;
}

export interface NfsExportSettingsMapAllPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapAllSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapAllUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapFailure {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportSettingsMapFailurePrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportSettingsMapFailureSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportSettingsMapFailureUser;
}

export interface NfsExportSettingsMapFailurePrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapFailureSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapFailureUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapNonRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportSettingsMapNonRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportSettingsMapNonRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportSettingsMapNonRootUser;
}

export interface NfsExportSettingsMapNonRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapNonRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapNonRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapRoot {
    /**
     * True if the user mapping is applied.
     */
    enabled: boolean;
    /**
     * Specifies the persona of the file group.
     */
    primaryGroup: outputs.NfsExportSettingsMapRootPrimaryGroup;
    /**
     * Specifies persona properties for the secondary user group. A persona consists of either a type and name, or an ID.
     */
    secondaryGroups: outputs.NfsExportSettingsMapRootSecondaryGroup[];
    /**
     * Specifies the persona of the file group.
     */
    user: outputs.NfsExportSettingsMapRootUser;
}

export interface NfsExportSettingsMapRootPrimaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapRootSecondaryGroup {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface NfsExportSettingsMapRootUser {
    /**
     * Specifies the serialized form of a persona, which can be 'GID:0', 'GROUP:wheel'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface QuotaPersona {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name?: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type?: string;
}

export interface QuotaThresholds {
    /**
     * Usage bytes at which notifications will be sent but writes will not be denied.
     */
    advisory: number;
    /**
     * True if the advisory threshold has been hit.
     */
    advisoryExceeded: boolean;
    /**
     * Time at which advisory threshold was hit.
     */
    advisoryLastExceeded: number;
    /**
     * Usage bytes at which further writes will be denied.
     */
    hard: number;
    /**
     * True if the hard threshold has been hit.
     */
    hardExceeded: boolean;
    /**
     * Time at which hard threshold was hit.
     */
    hardLastExceeded: number;
    /**
     * Advisory threshold as percent of hard threshold. Usage bytes at which notifications will be sent but writes will not be denied. Must be >= 0.01 <= 99.99, precision 2
     */
    percentAdvisory: number;
    /**
     * Soft threshold as percent of hard threshold. Usage bytes at which notifications will be sent and soft grace time will be started. Must be >= 0.01 <= 99.99, precision 2
     */
    percentSoft: number;
    /**
     * Usage bytes at which notifications will be sent and soft grace time will be started.
     */
    soft: number;
    /**
     * True if the soft threshold has been hit.
     */
    softExceeded: boolean;
    /**
     * Time in seconds after which the soft threshold has been hit before writes will be denied.
     */
    softGrace: number;
    /**
     * Time at which soft threshold was hit
     */
    softLastExceeded: number;
}

export interface QuotaUsage {
    /**
     * Bytes used by governed data apparent to application.
     */
    applogical: number;
    /**
     * True if applogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    applogicalReady: boolean;
    /**
     * Bytes used by governed data apparent to filesystem.
     */
    fslogical: number;
    /**
     * True if fslogical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fslogicalReady: boolean;
    /**
     * Physical data usage adjusted to account for shadow store efficiency
     */
    fsphysical: number;
    /**
     * True if fsphysical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    fsphysicalReady: boolean;
    /**
     * Number of inodes (filesystem entities) used by governed data.
     */
    inodes: number;
    /**
     * True if inodes resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    inodesReady: boolean;
    /**
     * Bytes used for governed data and filesystem overhead.
     */
    physical: number;
    /**
     * Number of physical blocks for file data
     */
    physicalData: number;
    /**
     * True if physical_data resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalDataReady: boolean;
    /**
     * Number of physical blocks for file protection
     */
    physicalProtection: number;
    /**
     * True if physical_protection resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalProtectionReady: boolean;
    /**
     * True if physical resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    physicalReady: boolean;
    /**
     * Number of shadow references (cloned, deduplicated or packed filesystem blocks) used by governed data.
     */
    shadowRefs: number;
    /**
     * True if shadow_refs resource accounting is accurate on the quota. If false, this quota is waiting on completion of a QuotaScan job.
     */
    shadowRefsReady: boolean;
}

export interface RoleMember {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0'
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface RolePrivilege {
    /**
     * Specifies the ID of the privilege.
     */
    id: string;
    /**
     * Specifies the name of the privilege.
     */
    name: string;
    /**
     * permission of the privilege, 'r' = read , 'x' = read-execute, 'w' = read-execute-write, '-' = no permission
     */
    permission: string;
}

export interface S3BucketAcl {
    /**
     * Specifies the persona of the file group.
     */
    grantee: outputs.S3BucketAclGrantee;
    /**
     * Specifies the S3 rights being allowed.
     */
    permission: string;
}

export interface S3BucketAclGrantee {
    /**
     * Specifies the serialized form of a persona, which can be 'UID:0', 'USER:name', 'GID:0', 'GROUP:wheel', or 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface SmartpoolSettingsSpilloverTarget {
    /**
     * Target pool name if target specified as storagepool, otherwise empty string.
     */
    name: string;
    /**
     * Type of target pool. Acceptable values: storagepool, anywhere
     */
    type: string;
}

export interface SmbSharePermission {
    /**
     * Specifies the file system rights that are allowed or denied.
     */
    permission: string;
    /**
     * Determines whether the permission is allowed or denied.
     */
    permissionType: string;
    /**
     * Specifies the persona of the file group.
     */
    trustee: outputs.SmbSharePermissionTrustee;
}

export interface SmbSharePermissionTrustee {
    /**
     * Specifies the serialized form of a persona using security identifier, which can be 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface SmbShareRunAsRoot {
    /**
     * Specifies the serialized form of a persona using security identifier, which can be 'SID:S-1-1'.
     */
    id: string;
    /**
     * Specifies the persona name, which must be combined with a type.
     */
    name: string;
    /**
     * Specifies the type of persona, which must be combined with a name.
     */
    type: string;
}

export interface SubnetScServiceAddr {
    /**
     * High IP
     */
    high: string;
    /**
     * Low IP
     */
    low: string;
}

export interface UserGid {
    id: string;
    name: string;
    type: string;
}

export interface UserMappingRulesMappingUser {
    /**
     * Specifies the system-defined privilege that may be granted to users.
     */
    privileges: outputs.UserMappingRulesMappingUserPrivilege[];
    /**
     * Specifies the configuration properties for a user.
     */
    supplementalIdentities: outputs.UserMappingRulesMappingUserSupplementalIdentity[];
    /**
     * Specifies the configuration properties for a user.
     */
    user: outputs.UserMappingRulesMappingUserUser;
    /**
     * Numeric ID of the access zone which contains this user.
     */
    zid: number;
    /**
     * Name of the access zone which contains this user.
     */
    zone: string;
}

export interface UserMappingRulesMappingUserPrivilege {
    /**
     * Specifies the ID of the privilege.
     */
    id: string;
    /**
     * Specifies the name of the privilege.
     */
    name: string;
    /**
     * True, if the privilege is read-only.
     */
    readOnly: boolean;
}

export interface UserMappingRulesMappingUserSupplementalIdentity {
    /**
     * Specifies a user or group GID.
     */
    gid: string;
    /**
     * Specifies a user or group name.
     */
    name: string;
    /**
     * Specifies a user or group SID.
     */
    sid: string;
}

export interface UserMappingRulesMappingUserUser {
    /**
     * Specifies the user name.
     */
    name: string;
    /**
     * Specifies the user identity on disk.
     */
    onDiskUserIdentity: string;
    /**
     * Specifies the primary group name.
     */
    primaryGroupName: string;
    /**
     * Specifies the primary group SID.
     */
    primaryGroupSid: string;
    /**
     * Specifies a user or group SID.
     */
    sid: string;
    /**
     * Specifies the user UID.
     */
    uid: string;
}

export interface UserMappingRulesParameters {
    /**
     * Specifies the default UNIX user information that can be applied if the final credentials do not have valid UID and GID information. (Update Supported)
     */
    defaultUnixUser: outputs.UserMappingRulesParametersDefaultUnixUser;
}

export interface UserMappingRulesParametersDefaultUnixUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: string;
}

export interface UserMappingRulesRule {
    /**
     * Specifies the operator to make rules on specified users or groups. (Update Supported)
     */
    operator: string;
    /**
     * Specifies the mapping options for this user mapping rule. (Update Supported)
     */
    options: outputs.UserMappingRulesRuleOptions;
    /**
     * Specifies the source user information that the rule can be applied from. (Update Supported)
     */
    sourceUser?: outputs.UserMappingRulesRuleSourceUser;
    /**
     * Specifies the target user information that the rule can be applied to. (Update Supported)
     */
    targetUser: outputs.UserMappingRulesRuleTargetUser;
}

export interface UserMappingRulesRuleOptions {
    /**
     * If true, and the rule was applied successfully, stop processing further. (Update Supported)
     */
    break: boolean;
    /**
     * Specifies the default user information that can be applied if the final credentials do not have valid UID and GID information. (Update Supported)
     */
    defaultUser: outputs.UserMappingRulesRuleOptionsDefaultUser;
    /**
     * If true, the primary GID and primary group SID should be copied to the existing credential. (Update Supported)
     */
    group: boolean;
    /**
     * If true, all additional identifiers should be copied to the existing credential. (Update Supported)
     */
    groups: boolean;
    /**
     * If true, the primary UID and primary user SID should be copied to the existing credential. (Update Supported)
     */
    user: boolean;
}

export interface UserMappingRulesRuleOptionsDefaultUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: string;
}

export interface UserMappingRulesRuleSourceUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: string;
}

export interface UserMappingRulesRuleTargetUser {
    /**
     * Specifies the domain of the user that is being mapped. (Update Supported)
     */
    domain: string;
    /**
     * Specifies the name of the user that is being mapped. (Update Supported)
     */
    user: string;
}

export interface UserMappingRulesTestMappingUser {
    /**
     * Specifies a user name. (Update Supported)
     */
    name?: string;
    /**
     * Specifies a numeric user identifier. (Update Supported)
     */
    uid?: number;
}

export interface UserPrimaryGroupSid {
    id: string;
    name: string;
    type: string;
}

