// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AdvancedClusterAdvancedConfiguration {
    /**
     * @deprecated Deprecated
     */
    defaultReadConcern: string;
    defaultWriteConcern: string;
    /**
     * @deprecated Deprecated
     */
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours?: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface AdvancedClusterBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface AdvancedClusterConnectionString {
    private: string;
    privateEndpoints: outputs.AdvancedClusterConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface AdvancedClusterConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface AdvancedClusterConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface AdvancedClusterLabel {
    key?: string;
    value?: string;
}

export interface AdvancedClusterReplicationSpec {
    containerId: {[key: string]: string};
    externalId: string;
    /**
     * @deprecated Deprecated
     */
    id: string;
    /**
     * @deprecated Deprecated
     */
    numShards?: number;
    regionConfigs: outputs.AdvancedClusterReplicationSpecRegionConfig[];
    zoneId: string;
    zoneName?: string;
}

export interface AdvancedClusterReplicationSpecRegionConfig {
    analyticsAutoScaling?: outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling;
    analyticsSpecs?: outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs;
    autoScaling?: outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling;
    backingProviderName?: string;
    electableSpecs?: outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs;
    priority: number;
    providerName: string;
    readOnlySpecs?: outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs;
    regionName: string;
}

export interface AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount?: number;
}

export interface AdvancedClusterReplicationSpecRegionConfigAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface AdvancedClusterReplicationSpecRegionConfigElectableSpecs {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount?: number;
}

export interface AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount?: number;
}

export interface AdvancedClusterTag {
    key: string;
    value: string;
}

export interface AdvancedClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlertConfigurationMatcher {
    fieldName: string;
    operator: string;
    value: string;
}

export interface AlertConfigurationMetricThresholdConfig {
    metricName: string;
    mode?: string;
    operator?: string;
    threshold: number;
    units?: string;
}

export interface AlertConfigurationNotification {
    apiToken?: string;
    channelName?: string;
    datadogApiKey?: string;
    datadogRegion?: string;
    delayMin: number;
    emailAddress?: string;
    emailEnabled: boolean;
    integrationId?: string;
    intervalMin: number;
    microsoftTeamsWebhookUrl?: string;
    mobileNumber?: string;
    notifierId: string;
    opsGenieApiKey?: string;
    opsGenieRegion?: string;
    roles?: string[];
    serviceKey?: string;
    smsEnabled: boolean;
    teamId?: string;
    teamName: string;
    typeName: string;
    username?: string;
    victorOpsApiKey?: string;
    victorOpsRoutingKey?: string;
    webhookSecret?: string;
    webhookUrl?: string;
}

export interface AlertConfigurationThresholdConfig {
    operator?: string;
    threshold: number;
    units?: string;
}

export interface BackupCompliancePolicyOnDemandPolicyItem {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface BackupCompliancePolicyPolicyItemDaily {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface BackupCompliancePolicyPolicyItemHourly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface BackupCompliancePolicyPolicyItemMonthly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface BackupCompliancePolicyPolicyItemWeekly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface BackupCompliancePolicyPolicyItemYearly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupScheduleCopySetting {
    cloudProvider: string;
    frequencies: string[];
    regionName: string;
    /**
     * @deprecated Deprecated
     */
    replicationSpecId: string;
    shouldCopyOplogs: boolean;
    zoneId: string;
}

export interface CloudBackupScheduleExport {
    exportBucketId: string;
    frequencyType: string;
}

export interface CloudBackupSchedulePolicyItemDaily {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupSchedulePolicyItemHourly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupSchedulePolicyItemMonthly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupSchedulePolicyItemWeekly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupSchedulePolicyItemYearly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface CloudBackupSnapshotExportJobComponent {
    exportId: string;
    replicaSetName: string;
}

export interface CloudBackupSnapshotExportJobCustomData {
    key: string;
    value: string;
}

export interface CloudBackupSnapshotMember {
    cloudProvider: string;
    id: string;
    replicaSetName: string;
}

export interface CloudBackupSnapshotRestoreJobDeliveryTypeConfig {
    automated?: boolean;
    download?: boolean;
    oplogInc?: number;
    oplogTs?: number;
    pointInTime?: boolean;
    pointInTimeUtcSeconds?: number;
    targetClusterName?: string;
    targetProjectId?: string;
}

export interface CloudProviderAccessAuthorizationAws {
    iamAssumedRoleArn: string;
}

export interface CloudProviderAccessAuthorizationAzure {
    atlasAzureAppId: string;
    servicePrincipalId: string;
    tenantId: string;
}

export interface CloudProviderAccessAuthorizationFeatureUsage {
    featureId: {[key: string]: string};
    featureType: string;
}

export interface CloudProviderAccessSetupAwsConfig {
    atlasAssumedRoleExternalId: string;
    atlasAwsAccountArn: string;
}

export interface CloudProviderAccessSetupAzureConfig {
    atlasAzureAppId: string;
    servicePrincipalId: string;
    tenantId: string;
}

export interface ClusterAdvancedConfiguration {
    /**
     * @deprecated Deprecated
     */
    defaultReadConcern: string;
    defaultWriteConcern: string;
    /**
     * @deprecated Deprecated
     */
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours?: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface ClusterBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface ClusterConnectionString {
    private: string;
    privateEndpoints: outputs.ClusterConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface ClusterConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.ClusterConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface ClusterConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface ClusterLabel {
    key?: string;
    value?: string;
}

export interface ClusterOutageSimulationOutageFilter {
    cloudProvider: string;
    regionName: string;
    type: string;
}

export interface ClusterOutageSimulationTimeouts {
    delete?: string;
}

export interface ClusterReplicationSpec {
    id: string;
    numShards: number;
    regionsConfigs?: outputs.ClusterReplicationSpecRegionsConfig[];
    zoneName?: string;
}

export interface ClusterReplicationSpecRegionsConfig {
    analyticsNodes?: number;
    electableNodes: number;
    priority: number;
    readOnlyNodes?: number;
    regionName: string;
}

export interface ClusterSnapshotBackupPolicy {
    clusterId: string;
    clusterName: string;
    nextSnapshot: string;
    policies: outputs.ClusterSnapshotBackupPolicyPolicy[];
    referenceHourOfDay: number;
    referenceMinuteOfHour: number;
    restoreWindowDays: number;
    updateSnapshots: boolean;
}

export interface ClusterSnapshotBackupPolicyPolicy {
    id: string;
    policyItems: outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem[];
}

export interface ClusterSnapshotBackupPolicyPolicyPolicyItem {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface ClusterTag {
    key: string;
    value: string;
}

export interface ClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CustomDbRoleAction {
    action: string;
    resources: outputs.CustomDbRoleActionResource[];
}

export interface CustomDbRoleActionResource {
    cluster?: boolean;
    collectionName?: string;
    databaseName?: string;
}

export interface CustomDbRoleInheritedRole {
    databaseName: string;
    roleName: string;
}

export interface DataLakePipelineIngestionSchedule {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface DataLakePipelineSink {
    partitionFields?: outputs.DataLakePipelineSinkPartitionField[];
    provider: string;
    region: string;
    type?: string;
}

export interface DataLakePipelineSinkPartitionField {
    fieldName: string;
    order: number;
}

export interface DataLakePipelineSnapshot {
    copyRegion: string;
    createdAt: string;
    expiresAt: string;
    frequencyYype: string;
    id: string;
    masterKey: string;
    mongodVersion: string;
    policies: string[];
    provider: string;
    replicaSetName: string;
    size: number;
    snapshotType: string;
    status: string;
    type: string;
}

export interface DataLakePipelineSource {
    clusterName?: string;
    collectionName?: string;
    databaseName?: string;
    policyItemId?: string;
    projectId: string;
    type?: string;
}

export interface DataLakePipelineTransformation {
    field?: string;
    type?: string;
}

export interface DatabaseUserLabel {
    key: string;
    value: string;
}

export interface DatabaseUserRole {
    collectionName?: string;
    databaseName: string;
    roleName: string;
}

export interface DatabaseUserScope {
    name?: string;
    type?: string;
}

export interface EncryptionAtRestAwsKmsConfig {
    accessKeyId?: string;
    customerMasterKeyId?: string;
    enabled: boolean;
    region?: string;
    roleId?: string;
    secretAccessKey?: string;
}

export interface EncryptionAtRestAzureKeyVaultConfig {
    azureEnvironment?: string;
    clientId?: string;
    enabled: boolean;
    keyIdentifier?: string;
    keyVaultName?: string;
    resourceGroupName?: string;
    secret?: string;
    subscriptionId?: string;
    tenantId?: string;
}

export interface EncryptionAtRestGoogleCloudKmsConfig {
    enabled: boolean;
    keyVersionResourceId?: string;
    serviceAccountKey?: string;
}

export interface EventTriggerEventProcessors {
    awsEventbridge?: outputs.EventTriggerEventProcessorsAwsEventbridge;
}

export interface EventTriggerEventProcessorsAwsEventbridge {
    configAccountId?: string;
    configRegion?: string;
}

export interface FederatedDatabaseInstanceCloudProviderConfig {
    aws: outputs.FederatedDatabaseInstanceCloudProviderConfigAws;
}

export interface FederatedDatabaseInstanceCloudProviderConfigAws {
    externalId: string;
    iamAssumedRoleArn: string;
    iamUserArn: string;
    roleId: string;
    testS3Bucket: string;
}

export interface FederatedDatabaseInstanceDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface FederatedDatabaseInstanceStorageDatabase {
    collections?: outputs.FederatedDatabaseInstanceStorageDatabaseCollection[];
    maxWildcardCollections: number;
    name: string;
    views?: outputs.FederatedDatabaseInstanceStorageDatabaseView[];
}

export interface FederatedDatabaseInstanceStorageDatabaseCollection {
    dataSources?: outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource[];
    name: string;
}

export interface FederatedDatabaseInstanceStorageDatabaseCollectionDataSource {
    allowInsecure: boolean;
    collection: string;
    collectionRegex: string;
    database: string;
    databaseRegex: string;
    datasetName: string;
    defaultFormat: string;
    path: string;
    provenanceFieldName: string;
    storeName: string;
    urls: string[];
}

export interface FederatedDatabaseInstanceStorageDatabaseView {
    name: string;
    pipeline: string;
    source: string;
}

export interface FederatedDatabaseInstanceStorageStore {
    additionalStorageClasses: string[];
    allowInsecure: boolean;
    bucket: string;
    /**
     * @deprecated Deprecated
     */
    clusterId: string;
    clusterName: string;
    defaultFormat: string;
    delimiter: string;
    includeTags: boolean;
    name: string;
    prefix: string;
    projectId: string;
    provider: string;
    public: string;
    readPreference?: outputs.FederatedDatabaseInstanceStorageStoreReadPreference;
    region: string;
    urls: string[];
}

export interface FederatedDatabaseInstanceStorageStoreReadPreference {
    maxStalenessSeconds: number;
    mode: string;
    tagSets?: outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet[];
}

export interface FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet {
    tags: outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag[];
}

export interface FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag {
    name: string;
    value: string;
}

export interface FederatedSettingsOrgConfigUserConflict {
    emailAddress: string;
    federationSettingsId: string;
    firstName: string;
    lastName: string;
    userId: string;
}

export interface FederatedSettingsOrgRoleMappingRoleAssignment {
    groupId?: string;
    orgId?: string;
    roles?: string[];
}

export interface GetAccessListApiKeysResult {
    accessCount: number;
    cidrBlock: string;
    created: string;
    ipAddress: string;
    lastUsed: string;
    lastUsedAddress: string;
}

export interface GetAdvancedClusterAdvancedConfiguration {
    defaultReadConcern: string;
    defaultWriteConcern: string;
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface GetAdvancedClusterBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface GetAdvancedClusterConnectionString {
    private: string;
    privateEndpoints: outputs.GetAdvancedClusterConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface GetAdvancedClusterConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface GetAdvancedClusterConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface GetAdvancedClusterLabel {
    key: string;
    value: string;
}

export interface GetAdvancedClusterReplicationSpec {
    containerId: {[key: string]: string};
    externalId: string;
    id: string;
    numShards: number;
    regionConfigs: outputs.GetAdvancedClusterReplicationSpecRegionConfig[];
    zoneId: string;
    zoneName: string;
}

export interface GetAdvancedClusterReplicationSpecRegionConfig {
    analyticsAutoScalings: outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling[];
    analyticsSpecs: outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpec[];
    autoScalings: outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScaling[];
    backingProviderName: string;
    electableSpecs: outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpec[];
    priority: number;
    providerName: string;
    readOnlySpecs: outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpec[];
    regionName: string;
}

export interface GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClusterReplicationSpecRegionConfigAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface GetAdvancedClusterReplicationSpecRegionConfigElectableSpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClusterTag {
    key: string;
    value: string;
}

export interface GetAdvancedClustersResult {
    advancedConfigurations: outputs.GetAdvancedClustersResultAdvancedConfiguration[];
    backupEnabled: boolean;
    biConnectorConfigs: outputs.GetAdvancedClustersResultBiConnectorConfig[];
    clusterType: string;
    connectionStrings: outputs.GetAdvancedClustersResultConnectionString[];
    createDate: string;
    diskSizeGb: number;
    encryptionAtRestProvider: string;
    globalClusterSelfManagedSharding: boolean;
    labels: outputs.GetAdvancedClustersResultLabel[];
    mongoDbMajorVersion: string;
    mongoDbVersion: string;
    name: string;
    paused: boolean;
    pitEnabled: boolean;
    replicationSpecs: outputs.GetAdvancedClustersResultReplicationSpec[];
    rootCertType: string;
    stateName: string;
    tags: outputs.GetAdvancedClustersResultTag[];
    terminationProtectionEnabled: boolean;
    versionReleaseSystem: string;
}

export interface GetAdvancedClustersResultAdvancedConfiguration {
    defaultReadConcern: string;
    defaultWriteConcern: string;
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface GetAdvancedClustersResultBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface GetAdvancedClustersResultConnectionString {
    private: string;
    privateEndpoints: outputs.GetAdvancedClustersResultConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface GetAdvancedClustersResultConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface GetAdvancedClustersResultConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface GetAdvancedClustersResultLabel {
    key: string;
    value: string;
}

export interface GetAdvancedClustersResultReplicationSpec {
    containerId: {[key: string]: string};
    externalId: string;
    id: string;
    numShards: number;
    regionConfigs: outputs.GetAdvancedClustersResultReplicationSpecRegionConfig[];
    zoneId: string;
    zoneName: string;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfig {
    analyticsAutoScalings: outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling[];
    analyticsSpecs: outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpec[];
    autoScalings: outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScaling[];
    backingProviderName: string;
    electableSpecs: outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpec[];
    priority: number;
    providerName: string;
    readOnlySpecs: outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpec[];
    regionName: string;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfigAutoScaling {
    computeEnabled: boolean;
    computeMaxInstanceSize: string;
    computeMinInstanceSize: string;
    computeScaleDownEnabled: boolean;
    diskGbEnabled: boolean;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpec {
    diskIops: number;
    diskSizeGb: number;
    ebsVolumeType: string;
    instanceSize: string;
    nodeCount: number;
}

export interface GetAdvancedClustersResultTag {
    key: string;
    value: string;
}

export interface GetAlertConfigurationMatcher {
    fieldName: string;
    operator: string;
    value: string;
}

export interface GetAlertConfigurationMetricThresholdConfig {
    metricName: string;
    mode: string;
    operator: string;
    threshold: number;
    units: string;
}

export interface GetAlertConfigurationNotification {
    apiToken: string;
    channelName: string;
    datadogApiKey: string;
    datadogRegion: string;
    delayMin: number;
    emailAddress: string;
    emailEnabled: boolean;
    integrationId: string;
    intervalMin: number;
    microsoftTeamsWebhookUrl: string;
    mobileNumber: string;
    notifierId: string;
    opsGenieApiKey: string;
    opsGenieRegion: string;
    roles: string[];
    serviceKey: string;
    smsEnabled: boolean;
    teamId: string;
    teamName: string;
    typeName: string;
    username: string;
    victorOpsApiKey: string;
    victorOpsRoutingKey: string;
    webhookSecret: string;
    webhookUrl: string;
}

export interface GetAlertConfigurationOutput {
    label?: string;
    type: string;
    value: string;
}

export interface GetAlertConfigurationThresholdConfig {
    operator: string;
    threshold: number;
    units: string;
}

export interface GetAlertConfigurationsListOption {
    includeCount?: boolean;
    itemsPerPage?: number;
    pageNum?: number;
}

export interface GetAlertConfigurationsResult {
    alertConfigurationId: string;
    created: string;
    enabled: boolean;
    eventType: string;
    id: string;
    matchers: outputs.GetAlertConfigurationsResultMatcher[];
    metricThresholdConfigs: outputs.GetAlertConfigurationsResultMetricThresholdConfig[];
    notifications: outputs.GetAlertConfigurationsResultNotification[];
    outputs: outputs.GetAlertConfigurationsResultOutput[];
    projectId: string;
    thresholdConfigs: outputs.GetAlertConfigurationsResultThresholdConfig[];
    updated: string;
}

export interface GetAlertConfigurationsResultMatcher {
    fieldName: string;
    operator: string;
    value: string;
}

export interface GetAlertConfigurationsResultMetricThresholdConfig {
    metricName: string;
    mode: string;
    operator: string;
    threshold: number;
    units: string;
}

export interface GetAlertConfigurationsResultNotification {
    apiToken: string;
    channelName: string;
    datadogApiKey: string;
    datadogRegion: string;
    delayMin: number;
    emailAddress: string;
    emailEnabled: boolean;
    integrationId: string;
    intervalMin: number;
    microsoftTeamsWebhookUrl: string;
    mobileNumber: string;
    notifierId: string;
    opsGenieApiKey: string;
    opsGenieRegion: string;
    roles: string[];
    serviceKey: string;
    smsEnabled: boolean;
    teamId: string;
    teamName: string;
    typeName: string;
    username: string;
    victorOpsApiKey: string;
    victorOpsRoutingKey: string;
    webhookSecret: string;
    webhookUrl: string;
}

export interface GetAlertConfigurationsResultOutput {
    label: string;
    type: string;
    value: string;
}

export interface GetAlertConfigurationsResultThresholdConfig {
    operator: string;
    threshold: number;
    units: string;
}

export interface GetApiKeysResult {
    apiKeyId: string;
    description: string;
    publicKey: string;
    roleNames: string[];
}

export interface GetAtlasUserLink {
    href: string;
    rel: string;
}

export interface GetAtlasUserRole {
    groupId: string;
    orgId: string;
    roleName: string;
}

export interface GetAtlasUsersResult {
    country: string;
    createdAt: string;
    emailAddress: string;
    firstName: string;
    id: string;
    lastAuth: string;
    lastName: string;
    links: outputs.GetAtlasUsersResultLink[];
    mobileNumber: string;
    roles: outputs.GetAtlasUsersResultRole[];
    teamIds: string[];
    userId: string;
    username: string;
}

export interface GetAtlasUsersResultLink {
    href: string;
    rel: string;
}

export interface GetAtlasUsersResultRole {
    groupId: string;
    orgId: string;
    roleName: string;
}

export interface GetBackupCompliancePolicyOnDemandPolicyItem {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetBackupCompliancePolicyPolicyItemDaily {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetBackupCompliancePolicyPolicyItemHourly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetBackupCompliancePolicyPolicyItemMonthly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetBackupCompliancePolicyPolicyItemWeekly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetBackupCompliancePolicyPolicyItemYearly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupScheduleCopySetting {
    cloudProvider: string;
    frequencies: string[];
    regionName: string;
    replicationSpecId: string;
    shouldCopyOplogs: boolean;
    zoneId: string;
}

export interface GetCloudBackupScheduleExport {
    exportBucketId: string;
    frequencyType: string;
}

export interface GetCloudBackupSchedulePolicyItemDaily {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupSchedulePolicyItemHourly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupSchedulePolicyItemMonthly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupSchedulePolicyItemWeekly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupSchedulePolicyItemYearly {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetCloudBackupSnapshotExportBucketsResult {
    bucketName: string;
    cloudProvider: string;
    exportBucketId: string;
    iamRoleId: string;
    roleId: string;
    serviceUrl: string;
    tenantId: string;
}

export interface GetCloudBackupSnapshotExportJobComponent {
    exportId: string;
    replicaSetName: string;
}

export interface GetCloudBackupSnapshotExportJobCustomData {
    key: string;
    value: string;
}

export interface GetCloudBackupSnapshotExportJobsResult {
    components: outputs.GetCloudBackupSnapshotExportJobsResultComponent[];
    createdAt: string;
    customDatas: outputs.GetCloudBackupSnapshotExportJobsResultCustomData[];
    errMsg: string;
    exportBucketId: string;
    exportJobId: string;
    exportStatusExportedCollections: number;
    exportStatusTotalCollections: number;
    finishedAt: string;
    prefix: string;
    snapshotId: string;
    state: string;
}

export interface GetCloudBackupSnapshotExportJobsResultComponent {
    exportId: string;
    replicaSetName: string;
}

export interface GetCloudBackupSnapshotExportJobsResultCustomData {
    key: string;
    value: string;
}

export interface GetCloudBackupSnapshotMember {
    cloudProvider: string;
    id: string;
    replicaSetName: string;
}

export interface GetCloudBackupSnapshotRestoreJobsResult {
    cancelled: boolean;
    deliveryType: string;
    deliveryUrls: string[];
    expired: boolean;
    expiresAt: string;
    finishedAt: string;
    id: string;
    oplogInc: number;
    oplogTs: number;
    pointInTimeUtcSeconds: number;
    snapshotId: string;
    targetClusterName: string;
    targetProjectId: string;
    timestamp: string;
}

export interface GetCloudBackupSnapshotsResult {
    cloudProvider: string;
    createdAt: string;
    description: string;
    expiresAt: string;
    id: string;
    masterKeyUuid: string;
    members: outputs.GetCloudBackupSnapshotsResultMember[];
    mongodVersion: string;
    replicaSetName: string;
    snapshotIds: string[];
    snapshotType: string;
    status: string;
    storageSizeBytes: number;
    type: string;
}

export interface GetCloudBackupSnapshotsResultMember {
    cloudProvider: string;
    id: string;
    replicaSetName: string;
}

export interface GetCloudProviderAccessSetupAwsConfig {
    atlasAssumedRoleExternalId: string;
    atlasAwsAccountArn: string;
}

export interface GetCloudProviderAccessSetupAzureConfig {
    atlasAzureAppId: string;
    servicePrincipalId: string;
    tenantId: string;
}

export interface GetClusterAdvancedConfiguration {
    defaultReadConcern: string;
    defaultWriteConcern: string;
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface GetClusterBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface GetClusterConnectionString {
    awsPrivateLink: {[key: string]: string};
    awsPrivateLinkSrv: {[key: string]: string};
    private: string;
    privateEndpoints: outputs.GetClusterConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface GetClusterConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.GetClusterConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface GetClusterConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface GetClusterLabel {
    key: string;
    value: string;
}

export interface GetClusterOutageSimulationOutageFilter {
    cloudProvider: string;
    regionName: string;
    type: string;
}

export interface GetClusterReplicationSpec {
    id: string;
    numShards: number;
    regionsConfigs: outputs.GetClusterReplicationSpecRegionsConfig[];
    zoneName: string;
}

export interface GetClusterReplicationSpecRegionsConfig {
    analyticsNodes: number;
    electableNodes: number;
    priority: number;
    readOnlyNodes: number;
    regionName: string;
}

export interface GetClusterSnapshotBackupPolicy {
    clusterId: string;
    clusterName: string;
    nextSnapshot: string;
    policies: outputs.GetClusterSnapshotBackupPolicyPolicy[];
    referenceHourOfDay: number;
    referenceMinuteOfHour: number;
    restoreWindowDays: number;
    updateSnapshots: boolean;
}

export interface GetClusterSnapshotBackupPolicyPolicy {
    id: string;
    policyItems: outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItem[];
}

export interface GetClusterSnapshotBackupPolicyPolicyPolicyItem {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetClusterTag {
    key: string;
    value: string;
}

export interface GetClustersResult {
    advancedConfigurations: outputs.GetClustersResultAdvancedConfiguration[];
    autoScalingComputeEnabled: boolean;
    autoScalingComputeScaleDownEnabled: boolean;
    autoScalingDiskGbEnabled: boolean;
    backingProviderName: string;
    backupEnabled: boolean;
    biConnectorConfigs: outputs.GetClustersResultBiConnectorConfig[];
    clusterType: string;
    connectionStrings: outputs.GetClustersResultConnectionString[];
    containerId: string;
    diskSizeGb: number;
    encryptionAtRestProvider: string;
    labels: outputs.GetClustersResultLabel[];
    mongoDbMajorVersion: string;
    mongoDbVersion: string;
    mongoUri: string;
    mongoUriUpdated: string;
    mongoUriWithOptions: string;
    name: string;
    numShards: number;
    paused: boolean;
    pitEnabled: boolean;
    providerAutoScalingComputeMaxInstanceSize: string;
    providerAutoScalingComputeMinInstanceSize: string;
    providerBackupEnabled: boolean;
    providerDiskIops: number;
    providerDiskTypeName: string;
    providerEncryptEbsVolume: boolean;
    providerInstanceSizeName: string;
    providerName: string;
    providerRegionName: string;
    providerVolumeType: string;
    replicationFactor: number;
    replicationSpecs: outputs.GetClustersResultReplicationSpec[];
    snapshotBackupPolicies: outputs.GetClustersResultSnapshotBackupPolicy[];
    srvAddress: string;
    stateName: string;
    tags: outputs.GetClustersResultTag[];
    terminationProtectionEnabled: boolean;
    versionReleaseSystem: string;
}

export interface GetClustersResultAdvancedConfiguration {
    defaultReadConcern: string;
    defaultWriteConcern: string;
    failIndexKeyTooLong: boolean;
    javascriptEnabled: boolean;
    minimumEnabledTlsProtocol: string;
    noTableScan: boolean;
    oplogMinRetentionHours: number;
    oplogSizeMb: number;
    sampleRefreshIntervalBiConnector: number;
    sampleSizeBiConnector: number;
    transactionLifetimeLimitSeconds: number;
}

export interface GetClustersResultBiConnectorConfig {
    enabled: boolean;
    readPreference: string;
}

export interface GetClustersResultConnectionString {
    awsPrivateLink: {[key: string]: string};
    awsPrivateLinkSrv: {[key: string]: string};
    private: string;
    privateEndpoints: outputs.GetClustersResultConnectionStringPrivateEndpoint[];
    privateSrv: string;
    standard: string;
    standardSrv: string;
}

export interface GetClustersResultConnectionStringPrivateEndpoint {
    connectionString: string;
    endpoints: outputs.GetClustersResultConnectionStringPrivateEndpointEndpoint[];
    srvConnectionString: string;
    srvShardOptimizedConnectionString: string;
    type: string;
}

export interface GetClustersResultConnectionStringPrivateEndpointEndpoint {
    endpointId: string;
    providerName: string;
    region: string;
}

export interface GetClustersResultLabel {
    key: string;
    value: string;
}

export interface GetClustersResultReplicationSpec {
    id: string;
    numShards: number;
    regionsConfigs: outputs.GetClustersResultReplicationSpecRegionsConfig[];
    zoneName: string;
}

export interface GetClustersResultReplicationSpecRegionsConfig {
    analyticsNodes: number;
    electableNodes: number;
    priority: number;
    readOnlyNodes: number;
    regionName: string;
}

export interface GetClustersResultSnapshotBackupPolicy {
    clusterId: string;
    clusterName: string;
    nextSnapshot: string;
    policies: outputs.GetClustersResultSnapshotBackupPolicyPolicy[];
    referenceHourOfDay: number;
    referenceMinuteOfHour: number;
    restoreWindowDays: number;
    updateSnapshots: boolean;
}

export interface GetClustersResultSnapshotBackupPolicyPolicy {
    id: string;
    policyItems: outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItem[];
}

export interface GetClustersResultSnapshotBackupPolicyPolicyPolicyItem {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetClustersResultTag {
    key: string;
    value: string;
}

export interface GetControlPlaneIpAddressesInbound {
    /**
     * Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
     */
    aws: {[key: string]: string[]};
    /**
     * Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
     */
    azure: {[key: string]: string[]};
    /**
     * Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
     */
    gcp: {[key: string]: string[]};
}

export interface GetControlPlaneIpAddressesOutbound {
    /**
     * Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
     */
    aws: {[key: string]: string[]};
    /**
     * Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
     */
    azure: {[key: string]: string[]};
    /**
     * Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
     */
    gcp: {[key: string]: string[]};
}

export interface GetCustomDbRoleAction {
    action: string;
    resources: outputs.GetCustomDbRoleActionResource[];
}

export interface GetCustomDbRoleActionResource {
    cluster: boolean;
    collectionName: string;
    databaseName: string;
}

export interface GetCustomDbRoleInheritedRole {
    databaseName: string;
    roleName: string;
}

export interface GetCustomDbRolesResult {
    actions: outputs.GetCustomDbRolesResultAction[];
    inheritedRoles: outputs.GetCustomDbRolesResultInheritedRole[];
    roleName: string;
}

export interface GetCustomDbRolesResultAction {
    action: string;
    resources: outputs.GetCustomDbRolesResultActionResource[];
}

export interface GetCustomDbRolesResultActionResource {
    cluster: boolean;
    collectionName: string;
    databaseName: string;
}

export interface GetCustomDbRolesResultInheritedRole {
    databaseName: string;
    roleName: string;
}

export interface GetDataLakePipelineIngestionSchedule {
    frequencyInterval: number;
    frequencyType: string;
    id: string;
    retentionUnit: string;
    retentionValue: number;
}

export interface GetDataLakePipelineRunStat {
    bytesExported: number;
    numDocs: number;
}

export interface GetDataLakePipelineRunsResult {
    backupFrequencyType: string;
    createdDate: string;
    id: string;
    lastUpdatedDate: string;
    phase: string;
    pipelineId: string;
    pipelineRunId: string;
    snapshotId: string;
    state: string;
    stats: outputs.GetDataLakePipelineRunsResultStat[];
}

export interface GetDataLakePipelineRunsResultStat {
    bytesExported: number;
    numDocs: number;
}

export interface GetDataLakePipelineSink {
    partitionFields: outputs.GetDataLakePipelineSinkPartitionField[];
    provider: string;
    region: string;
    type: string;
}

export interface GetDataLakePipelineSinkPartitionField {
    fieldName: string;
    order: number;
}

export interface GetDataLakePipelineSnapshot {
    copyRegion: string;
    createdAt: string;
    expiresAt: string;
    frequencyYype: string;
    id: string;
    masterKey: string;
    mongodVersion: string;
    policies: string[];
    provider: string;
    replicaSetName: string;
    size: number;
    status: string;
    type: string;
}

export interface GetDataLakePipelineSource {
    clusterName: string;
    collectionName: string;
    databaseName: string;
    projectId: string;
    type: string;
}

export interface GetDataLakePipelineTransformation {
    field: string;
    type: string;
}

export interface GetDataLakePipelinesResult {
    createdDate: string;
    id: string;
    lastUpdatedDate: string;
    name: string;
    projectId: string;
    sinks: outputs.GetDataLakePipelinesResultSink[];
    sources: outputs.GetDataLakePipelinesResultSource[];
    state: string;
    transformations: outputs.GetDataLakePipelinesResultTransformation[];
}

export interface GetDataLakePipelinesResultSink {
    partitionFields: outputs.GetDataLakePipelinesResultSinkPartitionField[];
    provider: string;
    region: string;
    type: string;
}

export interface GetDataLakePipelinesResultSinkPartitionField {
    fieldName: string;
    order: number;
}

export interface GetDataLakePipelinesResultSource {
    clusterName: string;
    collectionName: string;
    databaseName: string;
    projectId: string;
    type: string;
}

export interface GetDataLakePipelinesResultTransformation {
    field: string;
    type: string;
}

export interface GetDatabaseUserLabel {
    key: string;
    value: string;
}

export interface GetDatabaseUserRole {
    collectionName: string;
    databaseName: string;
    roleName: string;
}

export interface GetDatabaseUserScope {
    name: string;
    type: string;
}

export interface GetDatabaseUsersResult {
    authDatabaseName: string;
    awsIamType: string;
    id: string;
    labels: outputs.GetDatabaseUsersResultLabel[];
    ldapAuthType: string;
    oidcAuthType: string;
    projectId: string;
    roles: outputs.GetDatabaseUsersResultRole[];
    scopes: outputs.GetDatabaseUsersResultScope[];
    username: string;
    x509Type: string;
}

export interface GetDatabaseUsersResultLabel {
    key: string;
    value: string;
}

export interface GetDatabaseUsersResultRole {
    collectionName: string;
    databaseName: string;
    roleName: string;
}

export interface GetDatabaseUsersResultScope {
    name: string;
    type: string;
}

export interface GetEventTriggerEventProcessor {
    awsEventbridges: outputs.GetEventTriggerEventProcessorAwsEventbridge[];
}

export interface GetEventTriggerEventProcessorAwsEventbridge {
    configAccountId: string;
    configRegion: string;
}

export interface GetEventTriggersResult {
    configCollection: string;
    configDatabase: string;
    configFullDocument: boolean;
    configFullDocumentBefore: boolean;
    configMatch: string;
    configOperationType: string;
    configOperationTypes: string[];
    configProject: string;
    configProviders: string[];
    configSchedule: string;
    configScheduleType: string;
    configServiceId: string;
    disabled: boolean;
    eventProcessors: outputs.GetEventTriggersResultEventProcessor[];
    functionId: string;
    functionName: string;
    name: string;
    triggerId: string;
    type: string;
    unordered: boolean;
}

export interface GetEventTriggersResultEventProcessor {
    awsEventbridges: outputs.GetEventTriggersResultEventProcessorAwsEventbridge[];
}

export interface GetEventTriggersResultEventProcessorAwsEventbridge {
    configAccountId: string;
    configRegion: string;
}

export interface GetFederatedDatabaseInstanceCloudProviderConfig {
    aws?: outputs.GetFederatedDatabaseInstanceCloudProviderConfigAws;
}

export interface GetFederatedDatabaseInstanceCloudProviderConfigAws {
    externalId: string;
    iamAssumedRoleArn: string;
    iamUserArn: string;
    roleId: string;
    testS3Bucket: string;
}

export interface GetFederatedDatabaseInstanceDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetFederatedDatabaseInstanceStorageDatabase {
    collections: outputs.GetFederatedDatabaseInstanceStorageDatabaseCollection[];
    maxWildcardCollections: number;
    name: string;
    views: outputs.GetFederatedDatabaseInstanceStorageDatabaseView[];
}

export interface GetFederatedDatabaseInstanceStorageDatabaseCollection {
    dataSources: outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSource[];
    name: string;
}

export interface GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSource {
    allowInsecure: boolean;
    collection: string;
    collectionRegex: string;
    database: string;
    databaseRegex: string;
    datasetName: string;
    defaultFormat: string;
    path: string;
    provenanceFieldName: string;
    storeName: string;
    urls: string[];
}

export interface GetFederatedDatabaseInstanceStorageDatabaseView {
    name: string;
    pipeline: string;
    source: string;
}

export interface GetFederatedDatabaseInstanceStorageStore {
    additionalStorageClasses: string[];
    allowInsecure: boolean;
    bucket: string;
    clusterId: string;
    clusterName: string;
    defaultFormat: string;
    delimiter: string;
    includeTags: boolean;
    name: string;
    prefix: string;
    projectId: string;
    provider: string;
    public: string;
    readPreferences: outputs.GetFederatedDatabaseInstanceStorageStoreReadPreference[];
    region: string;
    urls: string[];
}

export interface GetFederatedDatabaseInstanceStorageStoreReadPreference {
    maxStalenessSeconds: number;
    mode: string;
    tagSets: outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet[];
}

export interface GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet {
    tags: outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag[];
}

export interface GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag {
    name: string;
    value: string;
}

export interface GetFederatedDatabaseInstancesResult {
    cloudProviderConfigs: outputs.GetFederatedDatabaseInstancesResultCloudProviderConfig[];
    dataProcessRegions: outputs.GetFederatedDatabaseInstancesResultDataProcessRegion[];
    hostnames: string[];
    name: string;
    projectId: string;
    state: string;
    storageDatabases: outputs.GetFederatedDatabaseInstancesResultStorageDatabase[];
    storageStores: outputs.GetFederatedDatabaseInstancesResultStorageStore[];
}

export interface GetFederatedDatabaseInstancesResultCloudProviderConfig {
    aws: outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAw[];
}

export interface GetFederatedDatabaseInstancesResultCloudProviderConfigAw {
    externalId: string;
    iamAssumedRoleArn: string;
    iamUserArn: string;
    roleId: string;
    testS3Bucket: string;
}

export interface GetFederatedDatabaseInstancesResultDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetFederatedDatabaseInstancesResultStorageDatabase {
    collections: outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollection[];
    maxWildcardCollections: number;
    name: string;
    views: outputs.GetFederatedDatabaseInstancesResultStorageDatabaseView[];
}

export interface GetFederatedDatabaseInstancesResultStorageDatabaseCollection {
    dataSources: outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource[];
    name: string;
}

export interface GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource {
    allowInsecure: boolean;
    collection: string;
    collectionRegex: string;
    database: string;
    databaseRegex: string;
    datasetName: string;
    defaultFormat: string;
    path: string;
    provenanceFieldName: string;
    storeName: string;
    urls: string[];
}

export interface GetFederatedDatabaseInstancesResultStorageDatabaseView {
    name: string;
    pipeline: string;
    source: string;
}

export interface GetFederatedDatabaseInstancesResultStorageStore {
    additionalStorageClasses: string[];
    allowInsecure: boolean;
    bucket: string;
    clusterId: string;
    clusterName: string;
    defaultFormat: string;
    delimiter: string;
    includeTags: boolean;
    name: string;
    prefix: string;
    projectId: string;
    provider: string;
    public: string;
    readPreferences: outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreference[];
    region: string;
    urls: string[];
}

export interface GetFederatedDatabaseInstancesResultStorageStoreReadPreference {
    maxStalenessSeconds: number;
    mode: string;
    tagSets: outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet[];
}

export interface GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet {
    tags: outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag[];
}

export interface GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag {
    name: string;
    value: string;
}

export interface GetFederatedQueryLimitsResult {
    currentUsage: number;
    defaultLimit: number;
    lastModifiedDate: string;
    limitName: string;
    maximumLimit: number;
    overrunPolicy: string;
    projectId: string;
    tenantName: string;
    value: number;
}

export interface GetFederatedSettingsIdentityProviderAssociatedOrg {
    domainAllowLists: string[];
    domainRestrictionEnabled: boolean;
    identityProviderId: string;
    orgId: string;
    postAuthRoleGrants: string[];
    roleMappings: outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMapping[];
    userConflicts: outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflict[];
}

export interface GetFederatedSettingsIdentityProviderAssociatedOrgRoleMapping {
    externalGroupName: string;
    id: string;
    roleAssignments: outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment[];
}

export interface GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetFederatedSettingsIdentityProviderAssociatedOrgUserConflict {
    emailAddress: string;
    federationSettingsId: string;
    firstName: string;
    lastName: string;
    userId: string;
}

export interface GetFederatedSettingsIdentityProviderPemFileInfo {
    certificates: outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificate[];
    fileName: string;
}

export interface GetFederatedSettingsIdentityProviderPemFileInfoCertificate {
    notAfter: string;
    notBefore: string;
}

export interface GetFederatedSettingsIdentityProvidersResult {
    acsUrl: string;
    associatedDomains: string[];
    associatedOrgs: outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrg[];
    audience: string;
    audienceUri: string;
    authorizationType: string;
    clientId: string;
    description: string;
    displayName: string;
    groupsClaim: string;
    idpId: string;
    idpType: string;
    issuerUri: string;
    oktaIdpId: string;
    pemFileInfos: outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfo[];
    protocol: string;
    requestBinding: string;
    requestedScopes: string[];
    responseSignatureAlgorithm: string;
    ssoDebugEnabled: boolean;
    ssoUrl: string;
    status: string;
    userClaim: string;
}

export interface GetFederatedSettingsIdentityProvidersResultAssociatedOrg {
    domainAllowLists: string[];
    domainRestrictionEnabled: boolean;
    identityProviderId: string;
    orgId: string;
    postAuthRoleGrants: string[];
    roleMappings: outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping[];
    userConflicts: outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict[];
}

export interface GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping {
    externalGroupName: string;
    id: string;
    roleAssignments: outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment[];
}

export interface GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict {
    emailAddress: string;
    federationSettingsId: string;
    firstName: string;
    lastName: string;
    userId: string;
}

export interface GetFederatedSettingsIdentityProvidersResultPemFileInfo {
    certificates: outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificate[];
    fileName: string;
}

export interface GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificate {
    notAfter: string;
    notBefore: string;
}

export interface GetFederatedSettingsOrgConfigRoleMapping {
    externalGroupName: string;
    id: string;
    roleAssignments: outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignment[];
}

export interface GetFederatedSettingsOrgConfigRoleMappingRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetFederatedSettingsOrgConfigUserConflict {
    emailAddress: string;
    federationSettingsId: string;
    firstName: string;
    lastName: string;
    userId: string;
}

export interface GetFederatedSettingsOrgConfigsResult {
    dataAccessIdentityProviderIds: string[];
    domainAllowLists: string[];
    domainRestrictionEnabled: boolean;
    identityProviderId: string;
    orgId: string;
    postAuthRoleGrants: string[];
    roleMappings: outputs.GetFederatedSettingsOrgConfigsResultRoleMapping[];
    userConflicts: outputs.GetFederatedSettingsOrgConfigsResultUserConflict[];
}

export interface GetFederatedSettingsOrgConfigsResultRoleMapping {
    externalGroupName: string;
    id: string;
    roleAssignments: outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment[];
}

export interface GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetFederatedSettingsOrgConfigsResultUserConflict {
    emailAddress: string;
    federationSettingsId: string;
    firstName: string;
    lastName: string;
    userId: string;
}

export interface GetFederatedSettingsOrgRoleMappingRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetFederatedSettingsOrgRoleMappingsResult {
    externalGroupName: string;
    id: string;
    roleAssignments: outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignment[];
}

export interface GetFederatedSettingsOrgRoleMappingsResultRoleAssignment {
    groupId: string;
    orgId: string;
    role: string;
}

export interface GetGlobalClusterConfigManagedNamespace {
    collection: string;
    customShardKey: string;
    db: string;
    isCustomShardKeyHashed: boolean;
    isShardKeyUnique: boolean;
}

export interface GetLdapConfigurationUserToDnMapping {
    ldapQuery: string;
    match: string;
    substitution: string;
}

export interface GetLdapVerifyLink {
    href: string;
    rel: string;
}

export interface GetLdapVerifyValidation {
    status: string;
    validationType: string;
}

export interface GetNetworkContainersResult {
    atlasCidrBlock: string;
    azureSubscriptionId: string;
    gcpProjectId: string;
    id: string;
    networkName: string;
    providerName: string;
    provisioned: boolean;
    region: string;
    regionName: string;
    regions: string[];
    vnetName: string;
    vpcId: string;
}

export interface GetNetworkPeeringsResult {
    accepterRegionName: string;
    atlasCidrBlock: string;
    awsAccountId: string;
    azureDirectoryId: string;
    azureSubscriptionId: string;
    connectionId: string;
    containerId: string;
    errorMessage: string;
    errorState: string;
    errorStateName: string;
    gcpProjectId: string;
    networkName: string;
    peeringId: string;
    providerName: string;
    resourceGroupName: string;
    routeTableCidrBlock: string;
    status: string;
    statusName: string;
    vnetName: string;
    vpcId: string;
}

export interface GetOnlineArchiveCriteria {
    dateField: string;
    dateFormat: string;
    expireAfterDays: number;
    query: string;
    type: string;
}

export interface GetOnlineArchiveDataExpirationRule {
    expireAfterDays: number;
}

export interface GetOnlineArchiveDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetOnlineArchivePartitionField {
    fieldName: string;
    fieldType: string;
    order: number;
}

export interface GetOnlineArchiveSchedule {
    dayOfMonth: number;
    dayOfWeek: number;
    endHour: number;
    endMinute: number;
    startHour: number;
    startMinute: number;
    type: string;
}

export interface GetOnlineArchivesResult {
    archiveId: string;
    clusterName: string;
    collName: string;
    collectionType: string;
    criterias: outputs.GetOnlineArchivesResultCriteria[];
    dataExpirationRules: outputs.GetOnlineArchivesResultDataExpirationRule[];
    dataProcessRegions: outputs.GetOnlineArchivesResultDataProcessRegion[];
    dbName: string;
    partitionFields: outputs.GetOnlineArchivesResultPartitionField[];
    paused: boolean;
    projectId: string;
    schedules: outputs.GetOnlineArchivesResultSchedule[];
    state: string;
}

export interface GetOnlineArchivesResultCriteria {
    dateField: string;
    dateFormat: string;
    expireAfterDays: number;
    query: string;
    type: string;
}

export interface GetOnlineArchivesResultDataExpirationRule {
    expireAfterDays: number;
}

export interface GetOnlineArchivesResultDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetOnlineArchivesResultPartitionField {
    fieldName: string;
    fieldType: string;
    order: number;
}

export interface GetOnlineArchivesResultSchedule {
    dayOfMonth: number;
    dayOfWeek: number;
    endHour: number;
    endMinute: number;
    startHour: number;
    startMinute: number;
    type: string;
}

export interface GetOrganizationLink {
    href: string;
    rel: string;
}

export interface GetOrganizationsResult {
    apiAccessListRequired: boolean;
    id: string;
    isDeleted: boolean;
    links: outputs.GetOrganizationsResultLink[];
    multiFactorAuthRequired: boolean;
    name: string;
    restrictEmployeeAccess: boolean;
}

export interface GetOrganizationsResultLink {
    href: string;
    rel: string;
}

export interface GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResult {
    comment: string;
    customerEndpointDnsName: string;
    endpointId: string;
    providerName: string;
    region: string;
    type: string;
}

export interface GetPrivatelinkEndpointServiceEndpoint {
    endpointName: string;
    ipAddress: string;
    status: string;
}

export interface GetPrivatelinkEndpointsServiceServerlessResult {
    cloudProviderEndpointId: string;
    comment: string;
    endpointId: string;
    endpointServiceName: string;
    errorMessage: string;
    privateEndpointIpAddress: string;
    privateLinkServiceResourceId: string;
    status: string;
}

export interface GetProjectApiKeyProjectAssignment {
    projectId: string;
    roleNames: string[];
}

export interface GetProjectApiKeysResult {
    apiKeyId: string;
    description: string;
    privateKey: string;
    projectAssignments: outputs.GetProjectApiKeysResultProjectAssignment[];
    publicKey: string;
}

export interface GetProjectApiKeysResultProjectAssignment {
    projectId: string;
    roleNames: string[];
}

export interface GetProjectIpAddresses {
    services: outputs.GetProjectIpAddressesServices;
}

export interface GetProjectIpAddressesServices {
    clusters: outputs.GetProjectIpAddressesServicesCluster[];
}

export interface GetProjectIpAddressesServicesCluster {
    clusterName: string;
    inbounds: string[];
    outbounds: string[];
}

export interface GetProjectLimit {
    currentUsage: number;
    defaultLimit: number;
    maximumLimit: number;
    name: string;
    value: number;
}

export interface GetProjectTeam {
    roleNames: string[];
    teamId: string;
}

export interface GetProjectsResult {
    clusterCount: number;
    created: string;
    id: string;
    ipAddresses: outputs.GetProjectsResultIpAddresses;
    isCollectDatabaseSpecificsStatisticsEnabled: boolean;
    isDataExplorerEnabled: boolean;
    isExtendedStorageSizesEnabled: boolean;
    isPerformanceAdvisorEnabled: boolean;
    isRealtimePerformancePanelEnabled: boolean;
    isSchemaAdvisorEnabled: boolean;
    limits: outputs.GetProjectsResultLimit[];
    name: string;
    orgId: string;
    projectId: string;
    regionUsageRestrictions: string;
    tags: {[key: string]: string};
    teams: outputs.GetProjectsResultTeam[];
}

export interface GetProjectsResultIpAddresses {
    services: outputs.GetProjectsResultIpAddressesServices;
}

export interface GetProjectsResultIpAddressesServices {
    clusters: outputs.GetProjectsResultIpAddressesServicesCluster[];
}

export interface GetProjectsResultIpAddressesServicesCluster {
    clusterName: string;
    inbounds: string[];
    outbounds: string[];
}

export interface GetProjectsResultLimit {
    currentUsage: number;
    defaultLimit: number;
    maximumLimit: number;
    name: string;
    value: number;
}

export interface GetProjectsResultTeam {
    roleNames: string[];
    teamId: string;
}

export interface GetSearchDeploymentSpec {
    /**
     * Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
     */
    instanceSize: string;
    /**
     * Number of search nodes in the cluster.
     */
    nodeCount: number;
}

export interface GetSearchIndexSynonym {
    analyzer: string;
    name: string;
    sourceCollection: string;
}

export interface GetSearchIndexesResult {
    analyzer: string;
    analyzers: string;
    clusterName: string;
    collectionName: string;
    database: string;
    fields: string;
    indexId: string;
    mappingsDynamic: boolean;
    mappingsFields: string;
    name: string;
    projectId: string;
    searchAnalyzer: string;
    status: string;
    storedSource: string;
    synonyms: outputs.GetSearchIndexesResultSynonym[];
    type: string;
}

export interface GetSearchIndexesResultSynonym {
    analyzer: string;
    name: string;
    sourceCollection: string;
}

export interface GetServerlessInstanceLink {
    href: string;
    rel: string;
}

export interface GetServerlessInstanceTag {
    key: string;
    value: string;
}

export interface GetServerlessInstancesResult {
    autoIndexing: boolean;
    connectionStringsPrivateEndpointSrvs: string[];
    connectionStringsStandardSrv: string;
    continuousBackupEnabled: boolean;
    createDate: string;
    id: string;
    links: outputs.GetServerlessInstancesResultLink[];
    mongoDbVersion: string;
    name: string;
    projectId: string;
    providerSettingsBackingProviderName: string;
    providerSettingsProviderName: string;
    providerSettingsRegionName: string;
    stateName: string;
    tags: outputs.GetServerlessInstancesResultTag[];
    terminationProtectionEnabled: boolean;
}

export interface GetServerlessInstancesResultLink {
    href: string;
    rel: string;
}

export interface GetServerlessInstancesResultTag {
    key: string;
    value: string;
}

export interface GetSharedTierRestoreJobsResult {
    deliveryType: string;
    expirationDate: string;
    jobId: string;
    restoreFinishedDate: string;
    restoreScheduledDate: string;
    snapshotFinishedDate: string;
    snapshotId: string;
    snapshotUrl: string;
    status: string;
    targetDeploymentItemName: string;
    targetProjectId: string;
}

export interface GetSharedTierSnapshotsResult {
    expiration: string;
    finishTime: string;
    mongoDbVersion: string;
    scheduledTime: string;
    snapshotId: string;
    startTime: string;
    status: string;
}

export interface GetStreamConnectionAuthentication {
    mechanism: string;
    password: string;
    username: string;
}

export interface GetStreamConnectionDbRoleToExecute {
    role: string;
    type: string;
}

export interface GetStreamConnectionSecurity {
    brokerPublicCertificate: string;
    protocol: string;
}

export interface GetStreamConnectionsResult {
    authentication: outputs.GetStreamConnectionsResultAuthentication;
    bootstrapServers: string;
    clusterName: string;
    config: {[key: string]: string};
    connectionName: string;
    dbRoleToExecute: outputs.GetStreamConnectionsResultDbRoleToExecute;
    id: string;
    instanceName: string;
    projectId: string;
    security: outputs.GetStreamConnectionsResultSecurity;
    type: string;
}

export interface GetStreamConnectionsResultAuthentication {
    mechanism: string;
    password: string;
    username: string;
}

export interface GetStreamConnectionsResultDbRoleToExecute {
    role: string;
    type: string;
}

export interface GetStreamConnectionsResultSecurity {
    brokerPublicCertificate: string;
    protocol: string;
}

export interface GetStreamInstanceDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetStreamInstanceStreamConfig {
    tier: string;
}

export interface GetStreamInstancesResult {
    dataProcessRegion: outputs.GetStreamInstancesResultDataProcessRegion;
    hostnames: string[];
    id: string;
    instanceName: string;
    projectId: string;
    streamConfig: outputs.GetStreamInstancesResultStreamConfig;
}

export interface GetStreamInstancesResultDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface GetStreamInstancesResultStreamConfig {
    tier: string;
}

export interface GetThirdPartyIntegrationsResult {
    accountId: string;
    apiKey: string;
    channelName: string;
    enabled: boolean;
    id: string;
    microsoftTeamsWebhookUrl: string;
    projectId: string;
    region: string;
    routingKey: string;
    secret: string;
    serviceDiscovery: string;
    serviceKey: string;
    teamName: string;
    type: string;
    url: string;
    userName: string;
}

export interface GetX509AuthenticationDatabaseUserCertificate {
    createdAt: string;
    groupId: string;
    id: number;
    notAfter: string;
    subject: string;
}

export interface GlobalClusterConfigCustomZoneMapping {
    location: string;
    zone: string;
}

export interface GlobalClusterConfigManagedNamespace {
    collection: string;
    customShardKey: string;
    db: string;
    isCustomShardKeyHashed: boolean;
    isShardKeyUnique: boolean;
}

export interface LdapConfigurationUserToDnMapping {
    ldapQuery: string;
    match: string;
    substitution: string;
}

export interface LdapVerifyLink {
    href: string;
    rel: string;
}

export interface LdapVerifyValidation {
    status: string;
    validationType: string;
}

export interface OnlineArchiveCriteria {
    dateField?: string;
    dateFormat: string;
    expireAfterDays?: number;
    query?: string;
    type: string;
}

export interface OnlineArchiveDataExpirationRule {
    expireAfterDays: number;
}

export interface OnlineArchiveDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface OnlineArchivePartitionField {
    fieldName: string;
    fieldType: string;
    order: number;
}

export interface OnlineArchiveSchedule {
    dayOfMonth?: number;
    dayOfWeek?: number;
    endHour?: number;
    endMinute?: number;
    startHour?: number;
    startMinute?: number;
    type: string;
}

export interface PrivateEndpointRegionalModeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkEndpointServerlessTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivatelinkEndpointServiceDataFederationOnlineArchiveTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivatelinkEndpointServiceEndpoint {
    endpointName?: string;
    ipAddress?: string;
    status: string;
}

export interface PrivatelinkEndpointServiceServerlessTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivatelinkEndpointServiceTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivatelinkEndpointTimeouts {
    create?: string;
    delete?: string;
}

export interface ProjectApiKeyProjectAssignment {
    projectId: string;
    roleNames: string[];
}

export interface ProjectIpAccessListTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
}

export interface ProjectIpAddresses {
    services: outputs.ProjectIpAddressesServices;
}

export interface ProjectIpAddressesServices {
    clusters: outputs.ProjectIpAddressesServicesCluster[];
}

export interface ProjectIpAddressesServicesCluster {
    clusterName: string;
    inbounds: string[];
    outbounds: string[];
}

export interface ProjectLimit {
    currentUsage: number;
    defaultLimit: number;
    maximumLimit: number;
    name: string;
    value: number;
}

export interface ProjectTeam {
    roleNames: string[];
    teamId: string;
}

export interface PushBasedLogExportTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface SearchDeploymentSpec {
    /**
     * Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
     */
    instanceSize: string;
    /**
     * Number of search nodes in the cluster.
     */
    nodeCount: number;
}

export interface SearchDeploymentTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface SearchIndexSynonym {
    analyzer: string;
    name: string;
    sourceCollection: string;
}

export interface SearchIndexTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServerlessInstanceLink {
    href: string;
    rel: string;
}

export interface ServerlessInstanceTag {
    key: string;
    value: string;
}

export interface StreamConnectionAuthentication {
    mechanism?: string;
    password?: string;
    username?: string;
}

export interface StreamConnectionDbRoleToExecute {
    role: string;
    type: string;
}

export interface StreamConnectionSecurity {
    brokerPublicCertificate?: string;
    protocol?: string;
}

export interface StreamInstanceDataProcessRegion {
    cloudProvider: string;
    region: string;
}

export interface StreamInstanceStreamConfig {
    tier: string;
}

export interface X509AuthenticationDatabaseUserCertificate {
    createdAt: string;
    groupId: string;
    id: number;
    notAfter: string;
    subject: string;
}

export namespace config {
    export interface AssumeRoles {
        /**
         * The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or µs), ms, s, h, or m.
         */
        duration?: string;
        /**
         * A unique identifier that might be required when you assume a role in another account.
         */
        externalId?: string;
        /**
         * IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.
         */
        policy?: string;
        /**
         * Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.
         */
        policyArns?: string[];
        /**
         * Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.
         */
        roleArn?: string;
        /**
         * An identifier for the assumed role session.
         */
        sessionName?: string;
        /**
         * Source identity specified by the principal assuming the role.
         */
        sourceIdentity?: string;
        /**
         * Assume role session tags.
         */
        tags?: {[key: string]: string};
        /**
         * Assume role session tag keys to pass to any subsequent sessions.
         */
        transitiveTagKeys?: string[];
    }

}
