// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ApigatewayCustomDomain {
    /**
     * The certificate ID for the domain.
     */
    certificateId: string;
    /**
     * The domain name.
     */
    name: string;
}

export interface ApigatewayRouteTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ApigatewayRouteUpstream {
    /**
     * The host of the upstream.
     */
    host: string;
    /**
     * The load balancer algorithm.
     */
    loadbalancer?: string;
    /**
     * The port of the upstream.
     */
    port?: number;
    /**
     * The target URL of the upstream.
     */
    scheme?: string;
    /**
     * Weight with which to split traffic to the upstream.
     */
    weight?: number;
}

export interface ApigatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ApplicationLoadbalancerFlowlog {
    /**
     * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
     */
    action: string;
    /**
     * The S3 bucket name of an existing IONOS Cloud S3 bucket. Immutable, forces re-recreation of the nic resource.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * The resource name.
     */
    name: string;
}

export interface ApplicationLoadbalancerForwardingruleHttpRule {
    /**
     * An array of items in the collection.The action is only performed if each and every condition is met; if no conditions are set, the rule will always be performed.
     */
    conditions?: outputs.ApplicationLoadbalancerForwardingruleHttpRuleCondition[];
    /**
     * Valid only for STATIC actions.
     */
    contentType: string;
    /**
     * Default is false; valid only for REDIRECT actions.
     */
    dropQuery?: boolean;
    /**
     * The location for redirecting; mandatory and valid only for REDIRECT actions.
     */
    location?: string;
    /**
     * The unique name of the Application Load Balancer HTTP rule.
     */
    name: string;
    /**
     * The response message of the request; mandatory for STATIC actions.
     */
    responseMessage?: string;
    /**
     * Valid only for REDIRECT and STATIC actions. For REDIRECT actions, default is 301 and possible values are 301, 302, 303, 307, and 308. For STATIC actions, default is 503 and valid range is 200 to 599.
     */
    statusCode: number;
    /**
     * The ID of the target group; mandatory and only valid for FORWARD actions.
     */
    targetGroup?: string;
    /**
     * Type of the HTTP rule.
     */
    type: string;
}

export interface ApplicationLoadbalancerForwardingruleHttpRuleCondition {
    /**
     * Matching rule for the HTTP rule condition attribute; mandatory for HEADER, PATH, QUERY, METHOD, HOST, and COOKIE types; must be null when type is SOURCE_IP.
     */
    condition?: string;
    /**
     * Must be null when type is PATH, METHOD, HOST, or SOURCE_IP. Key can only be set when type is COOKIES, HEADER, or QUERY.
     */
    key?: string;
    /**
     * Specifies whether the condition is negated or not; the default is False.
     */
    negate?: boolean;
    /**
     * Type of the HTTP rule condition.
     */
    type: string;
    /**
     * Mandatory for conditions CONTAINS, EQUALS, MATCHES, STARTS_WITH, ENDS_WITH; must be null when condition is EXISTS; should be a valid CIDR if provided and if type is SOURCE_IP.
     */
    value?: string;
}

export interface ApplicationLoadbalancerForwardingruleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ApplicationLoadbalancerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface AutoCertificateProviderExternalAccountBinding {
    /**
     * The key ID of the external account binding
     */
    keyId: string;
    /**
     * The secret of the external account binding
     */
    keySecret: string;
}

export interface AutoCertificateProviderTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface AutoCertificateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface AutoscalingGroupPolicy {
    /**
     * The Metric that should trigger the scaling actions. Metric values are checked at fixed intervals.
     */
    metric: string;
    /**
     * Specifies the time range for which the samples are to be aggregated. Must be >= 2 minutes.
     */
    range?: string;
    /**
     * Defines the action to be taken when the 'scaleInThreshold' is exceeded. Here, scaling is always about removing VMs associated with this VM Auto Scaling Group. By default, the termination policy is 'OLDEST_SERVER_FIRST' is effective.
     */
    scaleInAction: outputs.AutoscalingGroupPolicyScaleInAction;
    /**
     * The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scale_out_action' property. The value must have a lower minimum delta to the 'scale_in_threshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
     */
    scaleInThreshold: number;
    /**
     * Defines the action to be performed when the 'scaleOutThreshold' is exceeded. Here, scaling is always about adding new VMs to this VM Auto Scaling Group.
     */
    scaleOutAction: outputs.AutoscalingGroupPolicyScaleOutAction;
    /**
     * The upper threshold for the value of the 'metric'. Used with the 'greater than' (>) operator. A scale-out action is triggered when this value is exceeded, specified by the 'scaleOutAction' property. The value must have a lower minimum delta to the 'scaleInThreshold', depending on the metric, to avoid competing for actions simultaneously. If 'properties.policy.unit=TOTAL', a value >= 40 must be chosen.
     */
    scaleOutThreshold: number;
    /**
     * Units of the applied Metric. Possible values are: PER_HOUR, PER_MINUTE, PER_SECOND, TOTAL.
     */
    unit: string;
}

export interface AutoscalingGroupPolicyScaleInAction {
    /**
     * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are removed. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always removed. Note that for 'SCALE_IN' operations, volumes are not deleted after the server is deleted.
     */
    amount: number;
    /**
     * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
     */
    amountType: string;
    /**
     * The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
     */
    cooldownPeriod: string;
    /**
     * If set to 'true', when deleting an replica during scale in, any attached volume will also be deleted. When set to 'false', all volumes remain in the datacenter and must be deleted manually. Note that every scale-out creates new volumes. When they are not deleted, they will eventually use all of your contracts resource limits. At this point, scaling out would not be possible anymore.
     */
    deleteVolumes: boolean;
    /**
     * The type of termination policy for the VM Auto Scaling Group to follow a specific pattern for scaling-in replicas. The default termination policy is 'OLDEST_SERVER_FIRST'.
     */
    terminationPolicyType: string;
}

export interface AutoscalingGroupPolicyScaleOutAction {
    /**
     * When 'amountType=ABSOLUTE' specifies the absolute number of VMs that are added. The value must be between 1 to 10. 'amountType=PERCENTAGE' specifies the percentage value that is applied to the current number of replicas of the VM Auto Scaling Group. The value must be between 1 to 200. At least one VM is always added or removed.
     */
    amount: number;
    /**
     * The type for the given amount. Possible values are: [ABSOLUTE, PERCENTAGE].
     */
    amountType: string;
    /**
     * The minimum time that elapses after the start of this scaling action until the following scaling action is started. While a scaling action is in progress, no second action is initiated for the same VM Auto Scaling Group. Instead, the metric is re-evaluated after the current scaling action completes (either successfully or with errors). This is currently validated with a minimum value of 2 minutes and a maximum of 24 hours. The default value is 5 minutes if not specified.
     */
    cooldownPeriod: string;
}

export interface AutoscalingGroupReplicaConfiguration {
    /**
     * The zone where the VMs are created using this configuration.
     */
    availabilityZone: string;
    /**
     * The total number of cores for the VMs.
     */
    cores: number;
    /**
     * The zone where the VMs are created using this configuration.
     */
    cpuFamily?: string;
    /**
     * Set of NICs associated with this Replica.
     */
    nics?: outputs.AutoscalingGroupReplicaConfigurationNic[];
    /**
     * The amount of memory for the VMs in MB, e.g. 2048. Size must be specified in multiples of 256 MB with a minimum of 256 MB; however, if you set ramHotPlug to TRUE then you must use a minimum of 1024 MB. If you set the RAM size more than 240GB, then ramHotPlug will be set to FALSE and can not be set to TRUE unless RAM size not set to less than 240GB.
     */
    ram: number;
    /**
     * List of volumes associated with this Replica.
     */
    volumes?: outputs.AutoscalingGroupReplicaConfigurationVolume[];
}

export interface AutoscalingGroupReplicaConfigurationNic {
    /**
     * Dhcp flag for this replica Nic. This is an optional attribute with default value of 'true' if not given in the request payload or given as null.
     */
    dhcp?: boolean;
    /**
     * Activate or deactivate the firewall. By default, an active firewall without any defined rules will block all incoming network traffic except for the firewall rules that explicitly allows certain protocols, IP addresses and ports.
     */
    firewallActive?: boolean;
    /**
     * List of all firewall rules for the specified NIC.
     */
    firewallRules?: outputs.AutoscalingGroupReplicaConfigurationNicFirewallRule[];
    /**
     * The type of firewall rules that will be allowed on the NIC. If not specified, the default INGRESS value is used.
     */
    firewallType?: string;
    /**
     * List of all flow logs for the specified NIC.
     */
    flowLogs?: outputs.AutoscalingGroupReplicaConfigurationNicFlowLog[];
    /**
     * Lan ID for this replica Nic.
     */
    lan: number;
    /**
     * Name for this replica NIC.
     */
    name: string;
    /**
     * In order to link VM to ALB, target group must be provided.
     */
    targetGroup?: outputs.AutoscalingGroupReplicaConfigurationNicTargetGroup;
}

export interface AutoscalingGroupReplicaConfigurationNicFirewallRule {
    /**
     * Sets the allowed code (from 0 to 254) when ICMP protocol is selected. The value 'null' allows all codes.
     */
    icmpCode?: number;
    /**
     * Sets the allowed type (from 0 to 254) if the protocol ICMP is selected. The value 'null' allows all types.
     */
    icmpType?: number;
    /**
     * The name of the firewall rule.
     */
    name?: string;
    /**
     * Sets the end range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
     */
    portRangeEnd?: number;
    /**
     * Sets the initial range of the allowed port (from 1 to 65535) if the protocol TCP or UDP is selected. The value 'null' for 'port_range_start' and 'port_range_end' allows all ports.
     */
    portRangeStart?: number;
    /**
     * The protocol for the rule. The property cannot be modified after its creation (not allowed in update requests).
     */
    protocol: string;
    /**
     * Only traffic originating from the respective IPv4 address is permitted. The value 'null' allows traffic from any IP address.
     */
    sourceIp?: string;
    /**
     * Only traffic originating from the respective MAC address is permitted. Valid format: 'aa:bb:cc:dd:ee:ff'. The value 'null' allows traffic from any MAC address.
     */
    sourceMac?: string;
    /**
     * If the target NIC has multiple IP addresses, only the traffic directed to the respective IP address of the NIC is allowed. The value 'null' allows traffic to any target IP address.
     */
    targetIp?: string;
    /**
     * The firewall rule type. If not specified, the default value 'INGRESS' is used.
     */
    type: string;
}

export interface AutoscalingGroupReplicaConfigurationNicFlowLog {
    /**
     * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
     */
    action: string;
    /**
     * The S3 bucket name of an existing IONOS Cloud S3 bucket. Immutable, forces re-recreation of the nic resource.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * The resource name.
     */
    name: string;
}

export interface AutoscalingGroupReplicaConfigurationNicTargetGroup {
    /**
     * The port for the target group.
     */
    port: number;
    /**
     * The ID of the target group.
     */
    targetGroupId: string;
    /**
     * The weight for the target group.
     */
    weight: number;
}

export interface AutoscalingGroupReplicaConfigurationVolume {
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId: string;
    /**
     * Determines whether the volume will be used as a boot volume. Set to NONE, the volume will not be used as boot volume. 
     * Set to PRIMARY, the volume will be used as boot volume and set to AUTO will delegate the decision to the provisioning engine to decide whether to use the volume as boot volume.
     * Notice that exactly one volume can be set to PRIMARY or all of them set to AUTO.
     */
    bootOrder: string;
    /**
     * The bus type of the volume. Default setting is 'VIRTIO'. The bus type 'IDE' is also supported.
     */
    bus?: string;
    /**
     * The image installed on the disk. Currently, only the UUID of the image is supported. Note that either 'image' or 'imageAlias' must be specified, but not both.
     */
    image?: string;
    /**
     * The image installed on the volume. Must be an 'imageAlias' as specified via the images API. Note that one of 'image' or 'imageAlias' must be set, but not both.
     */
    imageAlias?: string;
    /**
     * Image password for this replica volume.
     */
    imagePassword?: string;
    /**
     * Name for this replica volume.
     */
    name: string;
    /**
     * User-defined size for this replica volume in GB.
     */
    size: number;
    sshKeys?: string[];
    /**
     * Storage Type for this replica volume. Possible values: SSD, HDD, SSD_STANDARD or SSD_PREMIUM
     */
    type: string;
    /**
     * User-data (Cloud Init) for this replica volume.
     */
    userData: string;
}

export interface AutoscalingGroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface BackupUnitTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface CdnDistributionRoutingRule {
    /**
     * The prefix of the routing rule.
     */
    prefix: string;
    /**
     * The scheme of the routing rule.
     */
    scheme: string;
    upstream: outputs.CdnDistributionRoutingRuleUpstream;
}

export interface CdnDistributionRoutingRuleUpstream {
    /**
     * Enable or disable caching. If enabled, the CDN will cache the responses from the upstream host. Subsequent requests for the same resource will be served from the cache.
     */
    caching: boolean;
    geoRestrictions?: outputs.CdnDistributionRoutingRuleUpstreamGeoRestrictions;
    /**
     * The upstream host that handles the requests if not already cached. This host will be protected by the WAF if the option is enabled.
     */
    host: string;
    /**
     * Rate limit class that will be applied to limit the number of incoming requests per IP.
     */
    rateLimitClass: string;
    /**
     * Enable or disable WAF to protect the upstream host.
     */
    waf: boolean;
}

export interface CdnDistributionRoutingRuleUpstreamGeoRestrictions {
    allowLists?: string[];
    blockLists?: string[];
}

export interface CdnDistributionTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface CertificateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryFeatures {
    /**
     * Enables vulnerability scanning for images in the container registry. Note: this feature can incur additional charges
     */
    vulnerabilityScanning: boolean;
}

export interface ContainerRegistryGarbageCollectionSchedule {
    days: string[];
    /**
     * UTC time of day e.g. 01:00:00 - as defined by partial-time - RFC3339
     */
    time: string;
}

export interface ContainerRegistryStorageUsage {
    bytes: number;
    updatedAt: string;
}

export interface ContainerRegistryTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryTokenCredential {
    password: string;
    username: string;
}

export interface ContainerRegistryTokenScope {
    /**
     * Example: ["pull", "push", "delete"]
     */
    actions: string[];
    name: string;
    type: string;
}

export interface ContainerRegistryTokenTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface CubeServerNic {
    deviceNumber: number;
    dhcp?: boolean;
    /**
     * Indicates whether this NIC receives an IPv6 address through DHCP.
     */
    dhcpv6?: boolean;
    firewall?: outputs.CubeServerNicFirewall;
    firewallActive?: boolean;
    firewallType: string;
    ips: string[];
    /**
     * IPv6 CIDR block assigned to the NIC.
     */
    ipv6CidrBlock: string;
    /**
     * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
     */
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name?: string;
    pciSlot: number;
}

export interface CubeServerNicFirewall {
    icmpCode?: string;
    icmpType?: string;
    name?: string;
    portRangeEnd?: number;
    portRangeStart?: number;
    protocol: string;
    sourceIp?: string;
    sourceMac?: string;
    targetIp?: string;
    type: string;
}

export interface CubeServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface CubeServerVolume {
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    diskType: string;
    /**
     * @deprecated Deprecated
     */
    imagePassword?: string;
    licenceType: string;
    name?: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    /**
     * @deprecated Deprecated
     */
    sshKeyPaths: string[];
    /**
     * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
     */
    userData: string;
}

export interface DatacenterCpuArchitecture {
    cpuFamily: string;
    maxCores: number;
    maxRam: number;
    vendor: string;
}

export interface DatacenterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface DataplatformClusterLan {
    /**
     * Indicates if the Kubernetes node pool LAN will reserve an IP using DHCP. The default value is 'true'
     */
    dhcp?: boolean;
    /**
     * The LAN ID of an existing LAN at the related data center
     */
    lanId: string;
    /**
     * An array of additional LANs attached to worker nodes
     */
    routes?: outputs.DataplatformClusterLanRoute[];
}

export interface DataplatformClusterLanRoute {
    /**
     * IPv4 or IPv6 gateway IP for the route
     */
    gateway: string;
    /**
     * IPv4 or IPv6 CIDR to be routed via the interface
     */
    network: string;
}

export interface DataplatformClusterMaintenanceWindow {
    dayOfTheWeek: string;
    /**
     * Time at which the maintenance should start.
     */
    time: string;
}

export interface DataplatformClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface DataplatformNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    /**
     * Time at which the maintenance should start.
     */
    time: string;
}

export interface DataplatformNodePoolTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface DnsRecordTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface DnsZoneTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface FirewallTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetApigatewayCustomDomain {
    certificateId: string;
    name: string;
}

export interface GetApigatewayRouteUpstream {
    host: string;
    loadbalancer: string;
    port: number;
    scheme: string;
    weight: number;
}

export interface GetApplicationLoadbalancerFlowlog {
    action: string;
    bucket: string;
    direction: string;
    id: string;
    name: string;
}

export interface GetApplicationLoadbalancerForwardingruleHttpRule {
    conditions: outputs.GetApplicationLoadbalancerForwardingruleHttpRuleCondition[];
    contentType: string;
    dropQuery: boolean;
    location: string;
    name: string;
    responseMessage: string;
    statusCode: number;
    targetGroup: string;
    type: string;
}

export interface GetApplicationLoadbalancerForwardingruleHttpRuleCondition {
    condition: string;
    key: string;
    negate: boolean;
    type: string;
    value: string;
}

export interface GetApplicationLoadbalancerForwardingruleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetApplicationLoadbalancerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetAutoCertificateProviderExternalAccountBinding {
    keyId: string;
}

export interface GetAutoCertificateProviderTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetAutoCertificateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetAutoscalingGroupPolicy {
    metric: string;
    range: string;
    scaleInActions: outputs.GetAutoscalingGroupPolicyScaleInAction[];
    scaleInThreshold: number;
    scaleOutActions: outputs.GetAutoscalingGroupPolicyScaleOutAction[];
    scaleOutThreshold: number;
    unit: string;
}

export interface GetAutoscalingGroupPolicyScaleInAction {
    amount: number;
    amountType: string;
    cooldownPeriod: string;
    deleteVolumes: boolean;
    terminationPolicyType: string;
}

export interface GetAutoscalingGroupPolicyScaleOutAction {
    amount: number;
    amountType: string;
    cooldownPeriod: string;
}

export interface GetAutoscalingGroupReplicaConfiguration {
    availabilityZone: string;
    cores: number;
    cpuFamily: string;
    nics: outputs.GetAutoscalingGroupReplicaConfigurationNic[];
    ram: number;
    volumes: outputs.GetAutoscalingGroupReplicaConfigurationVolume[];
}

export interface GetAutoscalingGroupReplicaConfigurationNic {
    dhcp: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetAutoscalingGroupReplicaConfigurationNicFirewallRule[];
    firewallType: string;
    flowLogs: outputs.GetAutoscalingGroupReplicaConfigurationNicFlowLog[];
    lan: number;
    name: string;
    targetGroups: outputs.GetAutoscalingGroupReplicaConfigurationNicTargetGroup[];
}

export interface GetAutoscalingGroupReplicaConfigurationNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetAutoscalingGroupReplicaConfigurationNicFlowLog {
    action: string;
    bucket: string;
    direction: string;
    id: string;
    name: string;
}

export interface GetAutoscalingGroupReplicaConfigurationNicTargetGroup {
    port: number;
    targetGroupId: string;
    weight: number;
}

export interface GetAutoscalingGroupReplicaConfigurationVolume {
    backupUnitId: string;
    bootOrder: string;
    bus: string;
    image: string;
    imageAlias: string;
    name: string;
    size: number;
    sshKeys: string[];
    type: string;
}

export interface GetAutoscalingGroupServersServer {
    id: string;
}

export interface GetAutoscalingGroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetBackupUnitTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetCdnDistributionRoutingRule {
    prefix: string;
    scheme: string;
    upstreams: outputs.GetCdnDistributionRoutingRuleUpstream[];
}

export interface GetCdnDistributionRoutingRuleUpstream {
    caching: boolean;
    geoRestrictions: outputs.GetCdnDistributionRoutingRuleUpstreamGeoRestriction[];
    host: string;
    rateLimitClass: string;
    waf: boolean;
}

export interface GetCdnDistributionRoutingRuleUpstreamGeoRestriction {
    allowLists: string[];
    blockLists: string[];
}

export interface GetCdnDistributionTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetCertificateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetContainerRegistryFeature {
    vulnerabilityScanning: boolean;
}

export interface GetContainerRegistryGarbageCollectionSchedule {
    days: string[];
    time: string;
}

export interface GetContainerRegistryLocationsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetContainerRegistryMaintenanceWindow {
    days: string[];
    time: string;
}

export interface GetContainerRegistryStorageUsage {
    bytes: number;
    updatedAt: string;
}

export interface GetContainerRegistryTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetContainerRegistryTokenCredential {
    username: string;
}

export interface GetContainerRegistryTokenScope {
    actions: string[];
    name: string;
    type: string;
}

export interface GetContainerRegistryTokenTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetCubeServerCdrom {
    cloudInit: string;
    cpuHotPlug: boolean;
    cpuHotUnplug: boolean;
    description: string;
    discScsiHotPlug: boolean;
    discScsiHotUnplug: boolean;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageAliases: string[];
    imageType: string;
    licenceType: string;
    location: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    public: boolean;
    ramHotPlug: boolean;
    ramHotUnplug: boolean;
    size: number;
}

export interface GetCubeServerNic {
    deviceNumber: number;
    dhcp: boolean;
    dhcpv6: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetCubeServerNicFirewallRule[];
    firewallType: string;
    id: string;
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name: string;
    pciSlot: number;
}

export interface GetCubeServerNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetCubeServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetCubeServerVolume {
    availabilityZone: string;
    backupUnitId: string;
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageName: string;
    imagePassword: string;
    licenceType: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    sshKeys: string[];
    type: string;
    userData: string;
}

export interface GetDatacenterCpuArchitecture {
    cpuFamily: string;
    maxCores: number;
    maxRam: number;
    vendor: string;
}

export interface GetDatacenterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetDataplatformClusterConfig {
    apiVersion: string;
    clusters: outputs.GetDataplatformClusterConfigCluster[];
    contexts: outputs.GetDataplatformClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetDataplatformClusterConfigUser[];
}

export interface GetDataplatformClusterConfigCluster {
    cluster: {[key: string]: string};
    name: string;
}

export interface GetDataplatformClusterConfigContext {
    context: {[key: string]: string};
    name: string;
}

export interface GetDataplatformClusterConfigUser {
    name: string;
    user: {[key: string]: string};
}

export interface GetDataplatformClusterLan {
    dhcp: boolean;
    lanId: string;
    routes: outputs.GetDataplatformClusterLanRoute[];
}

export interface GetDataplatformClusterLanRoute {
    gateway: string;
    network: string;
}

export interface GetDataplatformClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetDataplatformClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetDataplatformNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetDataplatformNodePoolTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetDataplatformNodePoolsNodePool {
    annotations: {[key: string]: string};
    availabilityZone: string;
    coresCount: number;
    cpuFamily: string;
    datacenterId: string;
    id: string;
    labels: {[key: string]: string};
    maintenanceWindows: outputs.GetDataplatformNodePoolsNodePoolMaintenanceWindow[];
    name: string;
    nodeCount: number;
    ramSize: number;
    storageSize: number;
    storageType: string;
    version: string;
}

export interface GetDataplatformNodePoolsNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetDataplatformNodePoolsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetDataplatformVersionsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetDnsRecordTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetFirewallTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetGroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetGroupUser {
    administrator: boolean;
    email: string;
    firstName: string;
    forceSecAuth: boolean;
    id: string;
    lastName: string;
}

export interface GetImageTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetInmemorydbReplicasetConnection {
    cidr: string;
    datacenterId: string;
    lanId: string;
}

export interface GetInmemorydbReplicasetCredential {
    username: string;
}

export interface GetInmemorydbReplicasetMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetInmemorydbReplicasetResource {
    cores: number;
    ram: number;
    storage: number;
}

export interface GetInmemorydbReplicasetTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetInmemorydbSnapshotMetadata {
    createdDate: string;
    datacenterId: string;
    lastModifiedDate: string;
    replicaSetId: string;
    snapshotTime: string;
}

export interface GetInmemorydbSnapshotTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetIpblockIpConsumer {
    datacenterId: string;
    datacenterName: string;
    ip: string;
    k8sClusterUuid: string;
    k8sNodepoolUuid: string;
    mac: string;
    nicId: string;
    serverId: string;
    serverName: string;
}

export interface GetIpblockTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetIpfailoverTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetK8sClusterConfig {
    apiVersion: string;
    clusters: outputs.GetK8sClusterConfigCluster[];
    contexts: outputs.GetK8sClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetK8sClusterConfigUser[];
}

export interface GetK8sClusterConfigCluster {
    cluster: {[key: string]: string};
    name: string;
}

export interface GetK8sClusterConfigContext {
    context: {[key: string]: string};
    name: string;
}

export interface GetK8sClusterConfigUser {
    name: string;
    user: {[key: string]: string};
}

export interface GetK8sClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetK8sClusterS3Bucket {
    name: string;
}

export interface GetK8sClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetK8sClustersCluster {
    apiSubnetAllowLists: string[];
    availableUpgradeVersions: string[];
    caCrt: string;
    configs: outputs.GetK8sClustersClusterConfig[];
    id: string;
    k8sVersion: string;
    kubeConfig: string;
    location: string;
    maintenanceWindows: outputs.GetK8sClustersClusterMaintenanceWindow[];
    name: string;
    natGatewayIp: string;
    nodePools: string[];
    nodeSubnet: string;
    public: boolean;
    s3Buckets: outputs.GetK8sClustersClusterS3Bucket[];
    server: string;
    state: string;
    userTokens: {[key: string]: string};
    viableNodePoolVersions: string[];
}

export interface GetK8sClustersClusterConfig {
    apiVersion: string;
    clusters: outputs.GetK8sClustersClusterConfigCluster[];
    contexts: outputs.GetK8sClustersClusterConfigContext[];
    currentContext: string;
    kind: string;
    users: outputs.GetK8sClustersClusterConfigUser[];
}

export interface GetK8sClustersClusterConfigCluster {
    cluster: {[key: string]: string};
    name: string;
}

export interface GetK8sClustersClusterConfigContext {
    context: {[key: string]: string};
    name: string;
}

export interface GetK8sClustersClusterConfigUser {
    name: string;
    user: {[key: string]: string};
}

export interface GetK8sClustersClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetK8sClustersClusterS3Bucket {
    name: string;
}

export interface GetK8sClustersFilter {
    name: string;
    value: string;
}

export interface GetK8sClustersTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetK8sNodePoolAutoScaling {
    maxNodeCount: number;
    minNodeCount: number;
}

export interface GetK8sNodePoolLan {
    dhcp: boolean;
    id: number;
    routes: outputs.GetK8sNodePoolLanRoute[];
}

export interface GetK8sNodePoolLanRoute {
    gatewayIp: string;
    network: string;
}

export interface GetK8sNodePoolMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetK8sNodePoolNodesNode {
    id: string;
    k8sVersion: string;
    name: string;
    privateIp: string;
    publicIp: string;
}

export interface GetK8sNodePoolNodesTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetK8sNodePoolTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetKafkaClusterConnection {
    brokerAddresses: string[];
    datacenterId: string;
    lanId: string;
}

export interface GetLanIpFailover {
    ip: string;
    nicUuid: string;
}

export interface GetLanTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetLocationCpuArchitecture {
    cpuFamily: string;
    maxCores: number;
    maxRam: number;
    vendor: string;
}

export interface GetLocationTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetLoggingPipelineLog {
    destinations: outputs.GetLoggingPipelineLogDestination[];
    protocol: string;
    public: boolean;
    source: string;
    tag: string;
}

export interface GetLoggingPipelineLogDestination {
    retentionInDays: number;
    type: string;
}

export interface GetMariadbBackupsBackup {
    baseBackups: outputs.GetMariadbBackupsBackupBaseBackup[];
    clusterId: string;
    earliestRecoveryTargetTime: string;
    size: number;
}

export interface GetMariadbBackupsBackupBaseBackup {
    created: string;
    size: number;
}

export interface GetMariadbBackupsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetMariadbClusterConnection {
    cidr: string;
    datacenterId: string;
    lanId: string;
}

export interface GetMariadbClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetMongoClusterBackup {
    location: string;
}

export interface GetMongoClusterBiConnector {
    enabled: boolean;
    host: string;
    port: string;
}

export interface GetMongoClusterConnection {
    cidrLists: string[];
    datacenterId: string;
    lanId: string;
}

export interface GetMongoClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetMongoClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetMongoTemplateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetMongoUserRole {
    database: string;
    /**
     * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
     */
    role: string;
}

export interface GetMongoUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetNatgatewayLan {
    gatewayIps: string[];
    id: number;
}

export interface GetNatgatewayRuleTargetPortRange {
    end: number;
    start: number;
}

export interface GetNatgatewayRuleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetNatgatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetNetworkloadbalancerFlowlog {
    action: string;
    bucket: string;
    direction: string;
    id: string;
    name: string;
}

export interface GetNetworkloadbalancerForwardingruleHealthCheck {
    clientTimeout: number;
    connectTimeout: number;
    retries: number;
    targetTimeout: number;
}

export interface GetNetworkloadbalancerForwardingruleTarget {
    healthChecks: outputs.GetNetworkloadbalancerForwardingruleTargetHealthCheck[];
    ip: string;
    port: number;
    proxyProtocol: string;
    weight: number;
}

export interface GetNetworkloadbalancerForwardingruleTargetHealthCheck {
    check: boolean;
    checkInterval: number;
    maintenance: boolean;
}

export interface GetNetworkloadbalancerForwardingruleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetNetworkloadbalancerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetNfsClusterConnection {
    datacenterId: string;
    ipAddress: string;
    lan: string;
}

export interface GetNfsClusterNf {
    minVersion: string;
}

export interface GetNfsShareClientGroup {
    /**
     * Optional description for the clients groups.
     */
    description: string;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts: string[];
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks: string[];
    nfs?: outputs.GetNfsShareClientGroupNf[];
}

export interface GetNfsShareClientGroupNf {
    /**
     * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
     */
    squash: string;
}

export interface GetNicFlowlog {
    action: string;
    bucket: string;
    direction: string;
    id: string;
    name: string;
}

export interface GetNicTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgBackupsClusterBackup {
    clusterId: string;
    earliestRecoveryTargetTime: string;
    id: string;
    isActive: boolean;
    location: string;
    metadatas: outputs.GetPgBackupsClusterBackupMetadata[];
    size: number;
    type: string;
    version: string;
}

export interface GetPgBackupsClusterBackupMetadata {
    createdDate: string;
}

export interface GetPgBackupsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgClusterConnection {
    cidr: string;
    datacenterId: string;
    lanId: string;
}

export interface GetPgClusterFromBackup {
    backupId: string;
    recoveryTargetTime: string;
}

export interface GetPgClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface GetPgClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgDatabaseTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgDatabasesDatabase {
    id: string;
    name: string;
    owner: string;
}

export interface GetPgDatabasesTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPgVersionsTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetPrivateCrossconnectConnectableDatacenter {
    id: string;
    location: string;
    name: string;
}

export interface GetPrivateCrossconnectPeer {
    datacenterId: string;
    datacenterName: string;
    lanId: string;
    lanName: string;
    location: string;
}

export interface GetPrivateCrossconnectTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetResourceTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetS3KeyTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetServerCdrom {
    cloudInit: string;
    cpuHotPlug: boolean;
    cpuHotUnplug: boolean;
    description: string;
    discScsiHotPlug: boolean;
    discScsiHotUnplug: boolean;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageAliases: string[];
    imageType: string;
    licenceType: string;
    location: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    public: boolean;
    ramHotPlug: boolean;
    ramHotUnplug: boolean;
    size: number;
}

export interface GetServerLabel {
    id: string;
    key: string;
    value: string;
}

export interface GetServerNic {
    deviceNumber: number;
    dhcp: boolean;
    dhcpv6: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetServerNicFirewallRule[];
    firewallType: string;
    id: string;
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name: string;
    pciSlot: number;
}

export interface GetServerNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetServerVolume {
    availabilityZone: string;
    backupUnitId: string;
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageName: string;
    imagePassword: string;
    licenceType: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    size: number;
    sshKeys: string[];
    type: string;
    userData: string;
}

export interface GetServersFilter {
    name: string;
    value: string;
}

export interface GetServersServer {
    availabilityZone: string;
    bootCdrom: string;
    bootImage: string;
    bootVolume: string;
    cdroms: outputs.GetServersServerCdrom[];
    cores: number;
    cpuFamily: string;
    id: string;
    labels: outputs.GetServersServerLabel[];
    name: string;
    nics: outputs.GetServersServerNic[];
    ram: number;
    templateUuid: string;
    token: string;
    type: string;
    vmState: string;
    volumes: outputs.GetServersServerVolume[];
}

export interface GetServersServerCdrom {
    cloudInit: string;
    cpuHotPlug: boolean;
    cpuHotUnplug: boolean;
    description: string;
    discScsiHotPlug: boolean;
    discScsiHotUnplug: boolean;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageAliases: string[];
    imageType: string;
    licenceType: string;
    location: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    public: boolean;
    ramHotPlug: boolean;
    ramHotUnplug: boolean;
    size: number;
}

export interface GetServersServerLabel {
    id: string;
    key: string;
    value: string;
}

export interface GetServersServerNic {
    deviceNumber: number;
    dhcp: boolean;
    dhcpv6: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetServersServerNicFirewallRule[];
    firewallType: string;
    id: string;
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name: string;
    pciSlot: number;
}

export interface GetServersServerNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetServersServerVolume {
    availabilityZone: string;
    backupUnitId: string;
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    diskType: string;
    id: string;
    imageName: string;
    imagePassword: string;
    licenceType: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    size: number;
    sshKeys: string[];
    userData: string;
}

export interface GetServersTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetShareTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetSnapshotTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetTargetGroupHealthCheck {
    checkInterval: number;
    checkTimeout: number;
    retries: number;
}

export interface GetTargetGroupHttpHealthCheck {
    matchType: string;
    method: string;
    negate: boolean;
    path: string;
    regex: boolean;
    response: string;
}

export interface GetTargetGroupTarget {
    healthCheckEnabled: boolean;
    ip: string;
    maintenanceEnabled: boolean;
    port: number;
    proxyProtocol: string;
    weight: number;
}

export interface GetTargetGroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetTemplateTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetUserGroup {
    id: string;
    name: string;
}

export interface GetUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetVcpuServerCdrom {
    cloudInit: string;
    cpuHotPlug: boolean;
    cpuHotUnplug: boolean;
    description: string;
    discScsiHotPlug: boolean;
    discScsiHotUnplug: boolean;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageAliases: string[];
    imageType: string;
    licenceType: string;
    location: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    public: boolean;
    ramHotPlug: boolean;
    ramHotUnplug: boolean;
    size: number;
}

export interface GetVcpuServerLabel {
    id: string;
    key: string;
    value: string;
}

export interface GetVcpuServerNic {
    deviceNumber: number;
    dhcp: boolean;
    dhcpv6: boolean;
    firewallActive: boolean;
    firewallRules: outputs.GetVcpuServerNicFirewallRule[];
    firewallType: string;
    id: string;
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name: string;
    pciSlot: number;
}

export interface GetVcpuServerNicFirewallRule {
    icmpCode: number;
    icmpType: number;
    id: string;
    name: string;
    portRangeEnd: number;
    portRangeStart: number;
    protocol: string;
    sourceIp: string;
    sourceMac: string;
    targetIp: string;
    type: string;
}

export interface GetVcpuServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetVcpuServerVolume {
    availabilityZone: string;
    backupUnitId: string;
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    id: string;
    imageName: string;
    imagePassword: string;
    licenceType: string;
    name: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    size: number;
    sshKeys: string[];
    type: string;
    userData: string;
}

export interface GetVolumeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GetVpnIpsecGatewayConnection {
    datacenterId: string;
    ipv4Cidr: string;
    ipv6Cidr: string;
    lanId: string;
}

export interface GetVpnIpsecTunnelAuth {
    method: string;
}

export interface GetVpnIpsecTunnelEsp {
    diffieHellmanGroup: string;
    encryptionAlgorithm: string;
    integrityAlgorithm: string;
    lifetime: number;
}

export interface GetVpnIpsecTunnelIke {
    diffieHellmanGroup: string;
    encryptionAlgorithm: string;
    integrityAlgorithm: string;
    lifetime: number;
}

export interface GetVpnWireguardGatewayConnection {
    datacenterId: string;
    ipv4Cidr: string;
    ipv6Cidr: string;
    lanId: string;
}

export interface GetVpnWireguardPeerEndpoint {
    host: string;
    port: number;
}

export interface GroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface GroupUser {
    administrator: boolean;
    email: string;
    firstName: string;
    forceSecAuth: boolean;
    id: string;
    lastName: string;
    password: string;
}

export interface InmemorydbReplicasetConnections {
    /**
     * The IP and subnet for your instance. Note the following unavailable IP ranges: 10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24
     */
    cidr: string;
    /**
     * The datacenter to connect your instance to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID to connect your instance to.
     */
    lanId: string;
}

export interface InmemorydbReplicasetCredentials {
    /**
     * The hashed password for a InMemoryDB user.
     */
    hashedPassword?: outputs.InmemorydbReplicasetCredentialsHashedPassword;
    /**
     * The password for a InMemoryDB user.
     */
    plainTextPassword?: string;
    /**
     * The username for the initial InMemoryDB user. Some system usernames are restricted (e.g. 'admin', 'standby').
     */
    username: string;
}

export interface InmemorydbReplicasetCredentialsHashedPassword {
    algorithm: string;
    hash: string;
}

export interface InmemorydbReplicasetMaintenanceWindow {
    /**
     * The name of the week day.
     */
    dayOfTheWeek: string;
    /**
     * Start of the maintenance window in UTC time.
     */
    time: string;
}

export interface InmemorydbReplicasetResources {
    /**
     * The number of CPU cores per instance.
     */
    cores: number;
    /**
     * The amount of memory per instance in gigabytes (GB).
     */
    ram: number;
    /**
     * The size of the storage in GB. The size is derived from the amount of RAM and the persistence mode and is not configurable.
     */
    storage: number;
}

export interface InmemorydbReplicasetTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface IpblockIpConsumer {
    datacenterId: string;
    datacenterName: string;
    ip: string;
    k8sClusterUuid: string;
    k8sNodepoolUuid: string;
    mac: string;
    nicId: string;
    serverId: string;
    serverName: string;
}

export interface IpblockTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface IpfailoverTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface K8sClusterMaintenanceWindow {
    /**
     * Day of the week when maintenance is allowed
     */
    dayOfTheWeek: string;
    /**
     * A clock time in the day when maintenance is allowed
     */
    time: string;
}

export interface K8sClusterS3Bucket {
    /**
     * Name of the S3 bucket
     */
    name?: string;
}

export interface K8sClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface K8sNodePoolAutoScaling {
    /**
     * The maximum number of worker nodes that the node pool can scale to. Should be greater than min_node_count
     */
    maxNodeCount: number;
    /**
     * The minimum number of worker nodes the node pool can scale down to. Should be less than max_node_count
     */
    minNodeCount: number;
}

export interface K8sNodePoolLan {
    /**
     * Indicates if the Kubernetes Node Pool LAN will reserve an IP using DHCP
     */
    dhcp?: boolean;
    /**
     * The LAN ID of an existing LAN at the related datacenter
     */
    id: number;
    /**
     * An array of additional LANs attached to worker nodes
     */
    routes?: outputs.K8sNodePoolLanRoute[];
}

export interface K8sNodePoolLanRoute {
    /**
     * IPv4 or IPv6 Gateway IP for the route
     */
    gatewayIp: string;
    /**
     * IPv4 or IPv6 CIDR to be routed via the interface
     */
    network: string;
}

export interface K8sNodePoolMaintenanceWindow {
    /**
     * Day of the week when maintenance is allowed
     */
    dayOfTheWeek: string;
    /**
     * A clock time in the day when maintenance is allowed
     */
    time: string;
}

export interface K8sNodePoolTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface KafkaClusterConnections {
    /**
     * The broker addresses of the Kafka Cluster. Can be empty, but must be present.
     */
    brokerAddresses: string[];
    /**
     * The datacenter to connect your Kafka Cluster to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID to connect your Kafka Cluster to.
     */
    lanId: string;
}

export interface KafkaClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface KafkaClusterTopicTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface LanIpFailover {
    ip: string;
    nicUuid: string;
}

export interface LanTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface LoadbalancerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface LoggingPipelineLog {
    /**
     * The internal output stream to send logs to. Possible values are: loki.
     */
    destinations?: outputs.LoggingPipelineLogDestination[];
    /**
     * Protocol to use as intake. Possible values are: http, tcp.
     */
    protocol: string;
    public: boolean;
    /**
     * The source parser to be used
     */
    source: string;
    /**
     * The tag is used to distinguish different pipelines. Must be unique amongst the pipeline's array items.
     */
    tag: string;
}

export interface LoggingPipelineLogDestination {
    /**
     * Defines the number of days a log record should be kept in loki. Works with loki destination type only. Possible values are: 7, 14, 30.
     */
    retentionInDays: number;
    type: string;
}

export interface LoggingPipelineTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface MariadbClusterConnections {
    /**
     * The IP and subnet for your cluster.
     */
    cidr: string;
    /**
     * The datacenter to connect your cluster to.
     */
    datacenterId: string;
    /**
     * The numeric LAN ID to connect your cluster to.
     */
    lanId: string;
}

export interface MariadbClusterCredentials {
    /**
     * The password for a MariaDB user.
     */
    password: string;
    /**
     * The username for the initial MariaDB user. Some system usernames are restricted (e.g 'mariadb', 'admin', 'standby').
     */
    username: string;
}

export interface MariadbClusterMaintenanceWindow {
    /**
     * The name of the week day.
     */
    dayOfTheWeek: string;
    /**
     * Start of the maintenance window in UTC time.
     */
    time: string;
}

export interface MariadbClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface MongoClusterBackup {
    /**
     * The location where the cluster backups will be stored. If not set, the backup is stored in the nearest location of the cluster. Examples: de, eu-sounth-2, eu-central-2
     */
    location?: string;
    /**
     * Number of hours in the past for which a point-in-time snapshot can be created.
     */
    pointInTimeWindowHours?: number;
    /**
     * Number of hours between snapshots.
     */
    snapshotIntervalHours?: number;
}

export interface MongoClusterBiConnector {
    /**
     * Enable or disable the BiConnector.
     */
    enabled?: boolean;
    /**
     * The host where this new BI Connector is installed.
     */
    host: string;
    /**
     * Port number used when connecting to this new BI Connector.
     */
    port: string;
}

export interface MongoClusterConnections {
    /**
     * The list of IPs and subnet for your cluster. Note the following unavailable IP ranges:10.233.64.0/18, 10.233.0.0/18, 10.233.114.0/24. example: [192.168.1.100/24, 192.168.1.101/24]
     */
    cidrLists: string[];
    /**
     * The datacenter to connect your cluster to.
     */
    datacenterId: string;
    /**
     * The LAN to connect your cluster to.
     */
    lanId: string;
}

export interface MongoClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface MongoClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface MongoUserRole {
    database?: string;
    /**
     * A list of mongodb user roles. Examples: read, readWrite, readAnyDatabase
     */
    role?: string;
}

export interface MongoUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NatgatewayLan {
    /**
     * Collection of gateway IP addresses of the NAT gateway. Will be auto-generated if not provided. Should ideally be an IP belonging to the same subnet as the LAN
     */
    gatewayIps: string[];
    /**
     * Id for the LAN connected to the NAT gateway
     */
    id: number;
}

export interface NatgatewayRuleTargetPortRange {
    /**
     * Target port range end associated with the NAT gateway rule.
     */
    end: number;
    /**
     * Target port range start associated with the NAT gateway rule.
     */
    start: number;
}

export interface NatgatewayRuleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NatgatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NetworkloadbalancerFlowlog {
    /**
     * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
     */
    action: string;
    /**
     * The S3 bucket name of an existing IONOS Cloud S3 bucket. Immutable, forces re-recreation of the nic resource.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * The resource name.
     */
    name: string;
}

export interface NetworkloadbalancerForwardingruleHealthCheck {
    /**
     * ClientTimeout is expressed in milliseconds. This inactivity timeout applies when the client is expected to acknowledge or send data. If unset the default of 50 seconds will be used.
     */
    clientTimeout: number;
    /**
     * It specifies the maximum time (in milliseconds) to wait for a connection attempt to a target VM to succeed. If unset, the default of 5 seconds will be used.
     */
    connectTimeout: number;
    /**
     * Retries specifies the number of retries to perform on a target VM after a connection failure. If unset, the default value of 3 will be used.
     */
    retries: number;
    /**
     * TargetTimeout specifies the maximum inactivity time (in milliseconds) on the target VM side. If unset, the default of 50 seconds will be used.
     */
    targetTimeout: number;
}

export interface NetworkloadbalancerForwardingruleTarget {
    /**
     * Health check attributes for Network Load Balancer forwarding rule target
     */
    healthCheck?: outputs.NetworkloadbalancerForwardingruleTargetHealthCheck;
    /**
     * IP of a balanced target VM
     */
    ip: string;
    /**
     * Port of the balanced target service. (range: 1 to 65535)
     */
    port: number;
    /**
     * Proxy protocol version
     */
    proxyProtocol?: string;
    /**
     * Weight parameter is used to adjust the target VM's weight relative to other target VMs
     */
    weight: number;
}

export interface NetworkloadbalancerForwardingruleTargetHealthCheck {
    /**
     * Check specifies whether the target VM's health is checked.
     */
    check: boolean;
    /**
     * CheckInterval determines the duration (in milliseconds) between consecutive health checks. If unspecified a default of 2000 ms is used.
     */
    checkInterval: number;
    /**
     * Maintenance specifies if a target VM should be marked as down, even if it is not.
     */
    maintenance: boolean;
}

export interface NetworkloadbalancerForwardingruleTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NetworkloadbalancerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NfsClusterConnections {
    /**
     * The datacenter to connect your instance to.
     */
    datacenterId: string;
    /**
     * The IP address and subnet for your instance.
     */
    ipAddress: string;
    /**
     * The numeric LAN ID to connect your instance to.
     */
    lan: string;
}

export interface NfsClusterNfs {
    /**
     * The minimum Network File Storage version
     */
    minVersion?: string;
}

export interface NfsClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NfsShareClientGroup {
    /**
     * Optional description for the clients groups.
     */
    description?: string;
    /**
     * A singular host allowed to connect to the share. The host can be specified as IP address and can be either IPv4 or IPv6.
     */
    hosts: string[];
    /**
     * The allowed host or network to which the export is being shared. The IP address can be either IPv4 or IPv6 and has to be given with CIDR notation.
     */
    ipNetworks: string[];
    nfs?: outputs.NfsShareClientGroupNfs;
}

export interface NfsShareClientGroupNfs {
    /**
     * The squash mode for the export. The squash mode can be: none - No squash mode. no mapping, root-anonymous - Map root user to anonymous uid, all-anonymous - Map all users to anonymous uid.
     */
    squash?: string;
}

export interface NfsShareTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface NicFlowlog {
    /**
     * Specifies the traffic direction pattern. Valid values: ACCEPTED, REJECTED, ALL. Immutable, forces re-recreation of the nic resource.
     */
    action: string;
    /**
     * The S3 bucket name of an existing IONOS Cloud S3 bucket. Immutable, forces re-recreation of the nic resource.
     */
    bucket: string;
    /**
     * Specifies the traffic direction pattern. Valid values: INGRESS, EGRESS, BIDIRECTIONAL. Immutable, forces re-recreation of the nic resource.
     */
    direction: string;
    /**
     * The resource's unique identifier.
     */
    id: string;
    /**
     * The resource name.
     */
    name: string;
}

export interface NicTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface PgClusterConnections {
    /**
     * The IP and subnet for the database.
     *           Note the following unavailable IP ranges:
     *           10.233.64.0/18
     *           10.233.0.0/18
     *           10.233.114.0/24
     */
    cidr: string;
    /**
     * The datacenter to connect your cluster to.
     */
    datacenterId: string;
    /**
     * The LAN to connect your cluster to.
     */
    lanId: string;
}

export interface PgClusterCredentials {
    password: string;
    /**
     * the username for the initial postgres user. some system usernames are restricted (e.g. "postgres", "admin", "standby")
     */
    username: string;
}

export interface PgClusterFromBackup {
    /**
     * The unique ID of the backup you want to restore.
     */
    backupId: string;
    /**
     * If this value is supplied as ISO 8601 timestamp, the backup will be replayed up until the given timestamp. If empty, the backup will be applied completely.
     */
    recoveryTargetTime?: string;
}

export interface PgClusterMaintenanceWindow {
    dayOfTheWeek: string;
    time: string;
}

export interface PgClusterTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface PgDatabaseTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface PgUserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface PrivateCrossconnectConnectableDatacenter {
    /**
     * The UUID of the connectable datacenter
     */
    id: string;
    /**
     * The physical location of the connectable datacenter
     */
    location: string;
    /**
     * The name of the connectable datacenter
     */
    name: string;
}

export interface PrivateCrossconnectPeer {
    /**
     * The id of the cross-connected datacenter
     */
    datacenterId: string;
    /**
     * The name of the cross-connected datacenter
     */
    datacenterName: string;
    /**
     * The id of the cross-connected LAN
     */
    lanId: string;
    /**
     * The name of the cross-connected LAN
     */
    lanName: string;
    /**
     * The location of the cross-connected datacenter
     */
    location: string;
}

export interface PrivateCrossconnectTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface S3BucketCorsConfigurationCorsRule {
    /**
     * Specifies which headers are allowed in a preflight OPTIONS request through the Access-Control-Request-Headers header.
     */
    allowedHeaders?: string[];
    /**
     * An HTTP method that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, DELETE.
     */
    allowedMethods: string[];
    /**
     * One or more origins you want customers to be able to access the bucket from.
     */
    allowedOrigins: string[];
    /**
     * One or more headers in the response that you want customers to be able to access from their applications.
     */
    exposeHeaders?: string[];
    /**
     * Container for the Contract Number of the owner.
     */
    id?: number;
    /**
     * The time in seconds that your browser is to cache the preflight response for the specified resource.
     */
    maxAgeSeconds?: number;
}

export interface S3BucketLifecycleConfigurationRule {
    /**
     * Specifies the days since the initiation of an incomplete multipart upload that IONOS S3 Object Storage will wait before permanently removing all parts of the upload.
     */
    abortIncompleteMultipartUpload?: outputs.S3BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload;
    /**
     * A lifecycle rule for when an object expires.
     */
    expiration?: outputs.S3BucketLifecycleConfigurationRuleExpiration;
    /**
     * Unique identifier for the rule.
     */
    id: string;
    /**
     * A lifecycle rule for when non-current object versions expire.
     */
    noncurrentVersionExpiration?: outputs.S3BucketLifecycleConfigurationRuleNoncurrentVersionExpiration;
    /**
     * Object key prefix identifying one or more objects to which the rule applies.
     */
    prefix: string;
    /**
     * Whether the rule is currently being applied. Valid values: Enabled or Disabled.
     */
    status: string;
}

export interface S3BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload {
    /**
     * Specifies the number of days after which IONOS S3 Object Storage aborts an incomplete multipart upload.
     */
    daysAfterInitiation: number;
}

export interface S3BucketLifecycleConfigurationRuleExpiration {
    /**
     * Specifies the date when the object expires. Required if 'days' is not specified.
     */
    date?: string;
    /**
     * Specifies the number of days after object creation when the object expires. Required if 'date' is not specified.
     */
    days?: number;
    /**
     * Indicates whether IONOS S3 Object Storage will remove a delete marker with no noncurrent versions. If set to true, the delete marker will be expired; if set to false the policy takes no operation. This cannot be specified with Days or Date in a Lifecycle Expiration Policy.
     */
    expiredObjectDeleteMarker?: boolean;
}

export interface S3BucketLifecycleConfigurationRuleNoncurrentVersionExpiration {
    /**
     * Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
     */
    noncurrentDays: number;
}

export interface S3BucketObjectLockConfigurationRule {
    defaultRetention?: outputs.S3BucketObjectLockConfigurationRuleDefaultRetention;
}

export interface S3BucketObjectLockConfigurationRuleDefaultRetention {
    days?: number;
    mode?: string;
    years?: number;
}

export interface S3BucketServerSideEncryptionConfigurationRule {
    /**
     * Defines the default encryption settings.
     */
    applyServerSideEncryptionByDefault?: outputs.S3BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault;
}

export interface S3BucketServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault {
    /**
     * Server-side encryption algorithm to use. Valid values are 'AES256'
     */
    sseAlgorithm: string;
}

export interface S3BucketTimeouts {
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    create?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
     */
    delete?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
     */
    read?: string;
    /**
     * A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
     */
    update?: string;
}

export interface S3BucketVersioningVersioningConfiguration {
    /**
     * The MFA delete status of the bucket.
     */
    mfaDelete: string;
    /**
     * The versioning status of the bucket.
     */
    status: string;
}

export interface S3BucketWebsiteConfigurationErrorDocument {
    /**
     * The object key.
     */
    key: string;
}

export interface S3BucketWebsiteConfigurationIndexDocument {
    /**
     * A suffix that is appended to a request that is for a directory on the website endpoint (for example, if the suffix is index.html and you make a request to samplebucket/images/ the data that is returned will be for the object with the key name images/index.html) The suffix must not be empty and must not include a slash character. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
     */
    suffix: string;
}

export interface S3BucketWebsiteConfigurationRedirectAllRequestsTo {
    /**
     * The host name to use in the redirect request.
     */
    hostName?: string;
    /**
     * Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
     */
    protocol?: string;
}

export interface S3BucketWebsiteConfigurationRoutingRule {
    /**
     * A container for describing a condition that must be met for the specified redirect to apply. For example, 1. If request is for pages in the /docs folder, redirect to the /documents folder. 2. If request results in HTTP error 4xx, redirect request to another host where you might process the error.
     */
    condition?: outputs.S3BucketWebsiteConfigurationRoutingRuleCondition;
    /**
     * Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
     */
    redirect?: outputs.S3BucketWebsiteConfigurationRoutingRuleRedirect;
}

export interface S3BucketWebsiteConfigurationRoutingRuleCondition {
    /**
     * The HTTP error code when the redirect is applied. In the event of an error, if the error code equals this value, then the specified redirect is applied. Required when parent element Condition is specified and sibling KeyPrefixEquals is not specified. If both are specified, then both must be true for the redirect to be applied
     */
    httpErrorCodeReturnedEquals?: string;
    /**
     * The object key name prefix when the redirect is applied. For example, to redirect requests for `ExamplePage.html`, the key prefix will be `ExamplePage.html`. To redirect request for all pages with the prefix `docs/`, the key prefix will be `/docs`, which identifies all objects in the `docs/` folder. Required when the parent element `Condition` is specified and sibling `HTTPErrorCodeReturnedEquals` is not specified. If both conditions are specified, both must be true for the redirect to be applied. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
     */
    keyPrefixEquals?: string;
}

export interface S3BucketWebsiteConfigurationRoutingRuleRedirect {
    /**
     * The host name to use in the redirect request.
     */
    hostName?: string;
    /**
     * The HTTP redirect code to use on the response.
     */
    httpRedirectCode?: string;
    /**
     * The protocol to use in the redirect request.
     */
    protocol?: string;
    /**
     * The object key prefix to use in the redirect request. For example, to redirect requests for all pages with prefix `docs/` (objects in the `docs/` folder) to `documents/`, you can set a condition block with `KeyPrefixEquals` set to `docs/` and in the Redirect set `ReplaceKeyPrefixWith` to `/documents`. Not required if one of the siblings is present. Can be present only if `ReplaceKeyWith` is not provided.
     */
    replaceKeyPrefixWith?: string;
    /**
     * The specific object key to use in the redirect request. For example, redirect request to error.html. Not required if one of the siblings is present. Can be present only if ReplaceKeyPrefixWith is not provided. Replacement must be made for object keys containing special characters (such as carriage returns) when using XML requests.
     */
    replaceKeyWith?: string;
}

export interface S3KeyTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ServerBootDeviceSelectionTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ServerLabel {
    key: string;
    value: string;
}

export interface ServerNic {
    deviceNumber: number;
    dhcp?: boolean;
    /**
     * Indicates whether this NIC receives an IPv6 address through DHCP.
     */
    dhcpv6?: boolean;
    firewallActive?: boolean;
    firewallType: string;
    /**
     * Firewall rules created in the server resource. The rules can also be created as separate resources outside the server resource
     */
    firewalls?: outputs.ServerNicFirewall[];
    id: string;
    /**
     * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
     */
    ips: string[];
    /**
     * IPv6 CIDR block assigned to the NIC.
     */
    ipv6CidrBlock: string;
    /**
     * Collection for IPv6 addresses assigned to a nic. Explicitly assigned IPv6 addresses need to come from inside the IPv6 CIDR block assigned to the nic.
     */
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name?: string;
    pciSlot: number;
}

export interface ServerNicFirewall {
    icmpCode?: string;
    icmpType?: string;
    id: string;
    name?: string;
    portRangeEnd?: number;
    portRangeStart?: number;
    protocol: string;
    sourceIp?: string;
    sourceMac?: string;
    targetIp?: string;
    type: string;
}

export interface ServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface ServerVolume {
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    diskType: string;
    /**
     * @deprecated Deprecated
     */
    imagePassword?: string;
    licenceType: string;
    name?: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    /**
     * The size of the volume in GB.
     */
    size: number;
    /**
     * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation.
     *
     * @deprecated Deprecated
     */
    sshKeyPaths?: string[];
    /**
     * Public SSH keys are set on the image as authorized keys for appropriate SSH login to the instance using the corresponding private key. This field may only be set in creation requests. When reading, it always returns null. SSH keys are only supported if a public Linux image is used for the volume creation.
     *
     * @deprecated Deprecated
     */
    sshKeys: string[];
    /**
     * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
     */
    userData: string;
}

export interface ShareTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface SnapshotTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface TargetGroupHealthCheck {
    /**
     * The interval in milliseconds between consecutive health checks; default is 2000.
     */
    checkInterval: number;
    /**
     * The maximum time in milliseconds to wait for a target to respond to a check. For target VMs with 'Check Interval' set, the lesser of the two  values is used once the TCP connection is established.
     */
    checkTimeout: number;
    /**
     * The maximum number of attempts to reconnect to a target after a connection failure. Valid range is 0 to 65535, and default is three reconnection.
     */
    retries: number;
}

export interface TargetGroupHttpHealthCheck {
    matchType: string;
    /**
     * The method for the HTTP health check.
     */
    method: string;
    negate?: boolean;
    /**
     * The path (destination URL) for the HTTP health check request; the default is /.
     */
    path: string;
    regex?: boolean;
    /**
     * The response returned by the request, depending on the match type.
     */
    response: string;
}

export interface TargetGroupTarget {
    /**
     * Makes the target available only if it accepts periodic health check TCP connection attempts; when turned off, the target is considered always available. The health check only consists of a connection attempt to the address and port of the target. Default is True.
     */
    healthCheckEnabled: boolean;
    /**
     * The IP of the balanced target VM.
     */
    ip: string;
    /**
     * Maintenance mode prevents the target from receiving balanced traffic.
     */
    maintenanceEnabled?: boolean;
    /**
     * The port of the balanced target service; valid range is 1 to 65535.
     */
    port: number;
    /**
     * Proxy protocol version
     */
    proxyProtocol?: string;
    /**
     * Traffic is distributed in proportion to target weight, relative to the combined weight of all targets. A target with higher weight receives a greater share of traffic. Valid range is 0 to 256 and default is 1; targets with weight of 0 do not participate in load balancing but still accept persistent connections. It is best use values in the middle of the range to leave room for later adjustments.
     */
    weight: number;
}

export interface TargetGroupTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface UserTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VcpuServerLabel {
    key: string;
    value: string;
}

export interface VcpuServerNic {
    deviceNumber: number;
    dhcp?: boolean;
    dhcpv6?: boolean;
    firewallActive?: boolean;
    firewallType: string;
    /**
     * Firewall rules created in the server resource. The rules can also be created as separate resources outside the server resource
     */
    firewalls?: outputs.VcpuServerNicFirewall[];
    id: string;
    /**
     * Collection of IP addresses assigned to a nic. Explicitly assigned public IPs need to come from reserved IP blocks, Passing value null or empty array will assign an IP address automatically.
     */
    ips: string[];
    ipv6CidrBlock: string;
    ipv6Ips: string[];
    lan: number;
    mac: string;
    name?: string;
    pciSlot: number;
}

export interface VcpuServerNicFirewall {
    icmpCode?: string;
    icmpType?: string;
    id: string;
    name?: string;
    portRangeEnd?: number;
    portRangeStart?: number;
    protocol: string;
    sourceIp?: string;
    sourceMac?: string;
    targetIp?: string;
    type: string;
}

export interface VcpuServerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VcpuServerVolume {
    availabilityZone: string;
    /**
     * The uuid of the Backup Unit that user has access to. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' in conjunction with this property.
     */
    backupUnitId: string;
    /**
     * The UUID of the attached server.
     */
    bootServer: string;
    bus: string;
    cpuHotPlug: boolean;
    deviceNumber: number;
    discVirtioHotPlug: boolean;
    discVirtioHotUnplug: boolean;
    diskType: string;
    licenceType: string;
    name?: string;
    nicHotPlug: boolean;
    nicHotUnplug: boolean;
    pciSlot: number;
    ramHotPlug: boolean;
    /**
     * The size of the volume in GB.
     */
    size: number;
    /**
     * The cloud-init configuration for the volume as base64 encoded string. The property is immutable and is only allowed to be set on a new volume creation. It is mandatory to provide either 'public image' or 'imageAlias' that has cloud-init compatibility in conjunction with this property.
     */
    userData: string;
}

export interface VolumeTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpnIpsecGatewayConnection {
    /**
     * The datacenter to connect your VPN Gateway to.
     */
    datacenterId: string;
    /**
     * Describes the private ipv4 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
     */
    ipv4Cidr: string;
    /**
     * Describes the ipv6 subnet in your LAN that should be accessible by the VPN Gateway. Note: this should be the subnet already assigned to the LAN
     */
    ipv6Cidr?: string;
    /**
     * The numeric LAN ID to connect your VPN Gateway to.
     */
    lanId: string;
}

export interface VpnIpsecGatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpnIpsecTunnelAuth {
    /**
     * The Authentication Method to use for IPSec Authentication.
     */
    method?: string;
    /**
     * The Pre-Shared Key to use for IPSec Authentication. Note: Required if method is PSK.
     */
    pskKey?: string;
}

export interface VpnIpsecTunnelEsp {
    /**
     * The Diffie-Hellman Group to use for IPSec Encryption.
     */
    diffieHellmanGroup?: string;
    /**
     * The encryption algorithm to use for IPSec Encryption.
     */
    encryptionAlgorithm?: string;
    /**
     * The integrity algorithm to use for IPSec Encryption.
     */
    integrityAlgorithm?: string;
    /**
     * The phase lifetime in seconds.
     */
    lifetime?: number;
}

export interface VpnIpsecTunnelIke {
    /**
     * The Diffie-Hellman Group to use for IPSec Encryption.
     */
    diffieHellmanGroup?: string;
    /**
     * The encryption algorithm to use for IPSec Encryption.
     */
    encryptionAlgorithm?: string;
    /**
     * The integrity algorithm to use for IPSec Encryption.
     */
    integrityAlgorithm?: string;
    /**
     * The phase lifetime in seconds.
     */
    lifetime?: number;
}

export interface VpnIpsecTunnelTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpnWireguardGatewayConnection {
    datacenterId: string;
    ipv4Cidr?: string;
    ipv6Cidr?: string;
    lanId: string;
}

export interface VpnWireguardGatewayTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

export interface VpnWireguardPeerEndpoint {
    /**
     * Hostname or IPV4 address that the WireGuard Server will connect to.
     */
    host: string;
    /**
     * Port that the WireGuard Server will connect to.
     */
    port?: number;
}

export interface VpnWireguardPeerTimeouts {
    create?: string;
    default?: string;
    delete?: string;
    update?: string;
}

