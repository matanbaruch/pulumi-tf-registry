// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AksclusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface AksclusterSpec {
    /**
     * Name of the cluster in TMC
     */
    agentName: string;
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * AKS config for the cluster control plane
     */
    config: outputs.AksclusterSpecConfig;
    /**
     * Nodepool definitions for the cluster
     */
    nodepools: outputs.AksclusterSpecNodepool[];
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
    /**
     * Resource ID of the cluster in Azure.
     */
    resourceId: string;
}

export interface AksclusterSpecConfig {
    /**
     * Access config
     */
    accessConfig?: outputs.AksclusterSpecConfigAccessConfig;
    /**
     * Addons Config
     */
    addonConfig?: outputs.AksclusterSpecConfigAddonConfig;
    /**
     * API Server Access Config
     */
    apiServerAccessConfig?: outputs.AksclusterSpecConfigApiServerAccessConfig;
    /**
     * Auto Upgrade Config
     */
    autoUpgradeConfig?: outputs.AksclusterSpecConfigAutoUpgradeConfig;
    /**
     * Resource ID of the disk encryption set to use for enabling
     */
    diskEncryptionSet?: string;
    /**
     * Managed Identity Config
     */
    identityConfig?: outputs.AksclusterSpecConfigIdentityConfig;
    /**
     * Kubernetes version of the cluster
     */
    kubernetesVersion: string;
    /**
     * Linux Config
     */
    linuxConfig?: outputs.AksclusterSpecConfigLinuxConfig;
    /**
     * The geo-location where the resource lives for the cluster.
     */
    location: string;
    /**
     * Network Config
     */
    networkConfig: outputs.AksclusterSpecConfigNetworkConfig;
    /**
     * Name of the resource group containing nodepools.
     */
    nodeResourceGroupName: string;
    /**
     * Azure Kubernetes Service SKU
     */
    sku?: outputs.AksclusterSpecConfigSku;
    /**
     * Storage Config
     */
    storageConfig?: outputs.AksclusterSpecConfigStorageConfig;
    /**
     * Metadata to apply to the cluster to assist with categorization and organization
     */
    tags: {[key: string]: string};
}

export interface AksclusterSpecConfigAccessConfig {
    /**
     * Azure Active Directory config
     */
    aadConfig?: outputs.AksclusterSpecConfigAccessConfigAadConfig;
    /**
     * Disable local accounts
     */
    disableLocalAccounts?: boolean;
    /**
     * Enable kubernetes RBAC
     */
    enableRbac?: boolean;
}

export interface AksclusterSpecConfigAccessConfigAadConfig {
    /**
     * List of AAD group object IDs that will have admin role of the cluster.
     */
    adminGroupIds?: string[];
    /**
     * Enable Azure RBAC for Kubernetes authorization
     */
    enableAzureRbac?: boolean;
    /**
     * Enable Managed RBAC
     */
    managed?: boolean;
    /**
     * AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
     */
    tenantId?: string;
}

export interface AksclusterSpecConfigAddonConfig {
    /**
     * Keyvault secrets provider addon
     */
    azureKeyvaultSecretsProviderAddonConfigs?: outputs.AksclusterSpecConfigAddonConfigAzureKeyvaultSecretsProviderAddonConfig[];
    /**
     * Azure policy addon
     */
    azurePolicyAddonConfigs?: outputs.AksclusterSpecConfigAddonConfigAzurePolicyAddonConfig[];
    /**
     * Monitor addon
     */
    monitorAddonConfigs?: outputs.AksclusterSpecConfigAddonConfigMonitorAddonConfig[];
}

export interface AksclusterSpecConfigAddonConfigAzureKeyvaultSecretsProviderAddonConfig {
    /**
     * Enable Azure Key Vault Secrets Provider
     */
    enable?: boolean;
    /**
     * Enable secrets rotation
     */
    enableSecretRotation?: boolean;
    /**
     * Secret rotation interval
     */
    rotationPollInterval?: string;
}

export interface AksclusterSpecConfigAddonConfigAzurePolicyAddonConfig {
    /**
     * Enable policy addon
     */
    enable?: boolean;
}

export interface AksclusterSpecConfigAddonConfigMonitorAddonConfig {
    /**
     * Enable monitor
     */
    enable?: boolean;
    /**
     * Log analytics workspace ID for the monitoring addon
     */
    logAnalyticsWorkspaceId?: string;
}

export interface AksclusterSpecConfigApiServerAccessConfig {
    /**
     * IP ranges authorized to access the Kubernetes API server
     */
    authorizedIpRanges?: string[];
    /**
     * Enable Private Cluster
     */
    enablePrivateCluster: boolean;
}

export interface AksclusterSpecConfigAutoUpgradeConfig {
    /**
     * Upgrade Channel. Allowed values include: NONE, PATCH, STABLE, RAPID or NODE_IMAGE
     */
    upgradeChannel?: string;
}

export interface AksclusterSpecConfigIdentityConfig {
    /**
     * Type of managed identity used by the cluster (default IDENTITY_TYPE_SYSTEM_ASSIGNED). Allowed values include: IDENTITY_TYPE_SYSTEM_ASSIGNED or IDENTITY_TYPE_USER_ASSIGNED
     */
    type?: string;
    /**
     * User Assigned Managed Identity Config
     */
    userAssigned?: outputs.AksclusterSpecConfigIdentityConfigUserAssigned;
}

export interface AksclusterSpecConfigIdentityConfigUserAssigned {
    /**
     * The ARM resource ID of user assigned identity in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'
     */
    resourceId: string;
}

export interface AksclusterSpecConfigLinuxConfig {
    /**
     * Administrator username to use for Linux VMs
     */
    adminUsername: string;
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers
     */
    sshKeys?: string[];
}

export interface AksclusterSpecConfigNetworkConfig {
    /**
     * DNS prefix of the cluster
     */
    dnsPrefix: string;
    /**
     * IP address assigned to the Kubernetes DNS service. This key can only be set when the network_config.network_plugin key is set to 'azure'.
     */
    dnsServiceIp: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network
     */
    dockerBridgeCidr: string;
    /**
     * Load balancer SKU
     */
    loadBalancerSku: string;
    /**
     * Network plugin. It is used for building Kubernetes network. Allowed values: azure, kubenet. Specify 'azure' for routable pod IPs from VNET, 'kubenet' for non-routable pod IPs with an overlay network, Defaults to 'kubenet'
     */
    networkPlugin: string;
    /**
     * Network plugin mode. Allowed values: overlay. Used to control the mode the network plugin should operate in. For example, 'overlay' used with networkPlugin=azure will use an overlay network (non-VNET IPs) for pods in the cluster.
     */
    networkPluginMode: string;
    /**
     * Network policy
     */
    networkPolicy?: string;
    /**
     * CIDR notation IP ranges from which to assign pod IPs
     */
    podCidrs: string[];
    /**
     * CIDR notation IP ranges from which to assign service cluster IP. This key can only be set when the network_config.network_plugin key is set to 'azure'.
     */
    serviceCidrs: string[];
}

export interface AksclusterSpecConfigSku {
    /**
     * Name of the cluster SKU. Allowed values include: BASIC.
     */
    name: string;
    /**
     * Tier of the cluster SKU. Allowed values include: FREE or PAID.
     */
    tier: string;
}

export interface AksclusterSpecConfigStorageConfig {
    /**
     * Enable the azure disk CSI driver for the storage
     */
    enableDiskCsiDriver: boolean;
    /**
     * Enable the azure file CSI driver for the storage
     */
    enableFileCsiDriver: boolean;
    /**
     * Enable the snapshot controller for the storage
     */
    enableSnapshotController: boolean;
}

export interface AksclusterSpecNodepool {
    /**
     * Name of the nodepool, immutable
     */
    name: string;
    /**
     * Spec for the nodepool
     */
    spec: outputs.AksclusterSpecNodepoolSpec;
}

export interface AksclusterSpecNodepoolSpec {
    /**
     * Auto scaling config.
     */
    autoScalingConfig?: outputs.AksclusterSpecNodepoolSpecAutoScalingConfig;
    /**
     * The list of Availability zones to use for nodepool. This can only be specified if the type of the nodepool is AvailabilitySet.
     */
    availabilityZones: string[];
    /**
     * Count is the number of nodes
     */
    count: number;
    /**
     * Whether each node is allocated its own public IP
     */
    enableNodePublicIp?: boolean;
    /**
     * The maximum number of pods that can run on a node
     */
    maxPods: number;
    /**
     * The mode of the nodepool. Allowed values include: SYSTEM or USER. A cluster must have at least one 'SYSTEM' nodepool at all times.
     */
    mode: string;
    /**
     * The node image version of the nodepool.
     */
    nodeImageVersion: string;
    /**
     * The node labels to be persisted across all nodes in nodepool
     */
    nodeLabels?: {[key: string]: string};
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the nodepool. If you specify 0, it will apply the default osDisk size according to the vmSize specified
     */
    osDiskSizeGb: number;
    /**
     * OS Disk Type. Allowed values include: EPHEMERAL or MANAGED.
     */
    osDiskType: string;
    /**
     * The OS type of the nodepool. Allowed values include: LINUX.
     */
    osType?: string;
    /**
     * The ID of a subnet in an existing VNet into which to assign pods in the cluster. Requires network-plugin to be azure and not compatible with network-plugin-mode overlay
     */
    podSubnetId?: string;
    /**
     * Scale set eviction policy, Allowed values include: DELETE or DEALLOCATE.
     */
    scaleSetEvictionPolicy?: string;
    /**
     * Scale set priority. Allowed values include: REGULAR or SPOT.
     */
    scaleSetPriority: string;
    /**
     * Max spot price
     */
    spotMaxPrice?: number;
    /**
     * AKS specific node tags
     */
    tags?: {[key: string]: string};
    /**
     * The taints added to new nodes during nodepool create and scale
     */
    taints?: outputs.AksclusterSpecNodepoolSpecTaint[];
    /**
     * The Nodepool type. Allowed values include: VIRTUAL_MACHINE_SCALE_SETS or AVAILABILITY_SET.
     */
    type?: string;
    /**
     * upgrade config
     */
    upgradeConfig?: outputs.AksclusterSpecNodepoolSpecUpgradeConfig;
    /**
     * Virtual Machine Size
     */
    vmSize: string;
    /**
     * The ID of a subnet in an existing VNet into which to deploy the cluster. If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes
     */
    vnetSubnetId?: string;
}

export interface AksclusterSpecNodepoolSpecAutoScalingConfig {
    /**
     * Enable auto scaling
     */
    enable?: boolean;
    /**
     * Maximum node count
     */
    maxCount?: number;
    /**
     * Minimum node count
     */
    minCount?: number;
}

export interface AksclusterSpecNodepoolSpecTaint {
    /**
     * Current effect state of the node pool
     */
    effect?: string;
    /**
     * The taint key to be applied to a node
     */
    key?: string;
    /**
     * The taint value corresponding to the taint key
     */
    value?: string;
}

export interface AksclusterSpecNodepoolSpecUpgradeConfig {
    /**
     * Max Surge
     */
    maxSurge?: string;
}

export interface BackupScheduleMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface BackupScheduleScope {
    /**
     * Cluster scope block
     */
    cluster?: outputs.BackupScheduleScopeCluster;
    /**
     * Cluster group scope block
     */
    clusterGroup?: outputs.BackupScheduleScopeClusterGroup;
}

export interface BackupScheduleScopeCluster {
    /**
     * Cluster name
     */
    clusterName: string;
    /**
     * Management cluster name
     */
    managementClusterName: string;
    /**
     * Cluster provisioner name
     */
    provisionerName: string;
}

export interface BackupScheduleScopeClusterGroup {
    /**
     * Cluster group name
     */
    clusterGroupName: string;
}

export interface BackupScheduleSelector {
    /**
     * Specifies the name of excluded clusters.
     */
    excludedNames?: string[];
    /**
     * The label selector to selectively adding individual clusters to the cluster group backup schedule.
     * If not specified, all clusters are included.
     */
    labelSelector?: outputs.BackupScheduleSelectorLabelSelector;
    /**
     * Specifies name of cluster to be selected.
     */
    names?: string[];
}

export interface BackupScheduleSelectorLabelSelector {
    /**
     * (Repeatable Block) A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.BackupScheduleSelectorLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In" and the values array contains only "value".
     * The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface BackupScheduleSelectorLabelSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key: string;
    /**
     * Operator represents a key's relationship to a set of values.
     * Valid operators are "In", "NotIn", "Exists" and "DoesNotExist".
     */
    operator: string;
    /**
     * Values is an array of string values.
     * If the operator is "In" or "NotIn", the values array must be non-empty.
     * If the operator is "Exists" or "DoesNotExist", the values array must be empty.
     * This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface BackupScheduleSpec {
    /**
     * Paused specifies whether the schedule is paused or not. (Default: False)
     */
    paused?: boolean;
    /**
     * Schedule block
     */
    schedule: outputs.BackupScheduleSpecSchedule;
    /**
     * Backup schedule template block, backup definition to be run on the provided schedule
     */
    template?: outputs.BackupScheduleSpecTemplate;
}

export interface BackupScheduleSpecSchedule {
    /**
     * Cron expression of backup schedule rate/interval
     */
    rate: string;
}

export interface BackupScheduleSpecTemplate {
    /**
     * The backup retention period.
     */
    backupTtl?: string;
    /**
     * Specifies the time used to wait for CSI VolumeSnapshot status turns to ReadyToUse during creation, before returning error as timeout.
     * The default value is 10 minute.
     * Format is the time number and time sign, example: "50s" (50 seconds)
     */
    csiSnapshotTimeout?: string;
    /**
     * Specifies whether all pod volumes should be backed up via file system backup by default.
     * (Default: True)
     */
    defaultVolumesToFsBackup?: boolean;
    /**
     * Specifies whether restic should be used to take a backup of all pod volumes by default.
     * (Default: False)
     */
    defaultVolumesToRestic?: boolean;
    /**
     * List of cluster-scoped resource type names to exclude from the backup.
     * If set to "*", all cluster-scoped resource types are excluded.
     */
    excludedClusterScopedResources?: string[];
    /**
     * List of of namespace-scoped resource type names to exclude from the backup.
     * If set to "*", all namespace-scoped resource types are excluded.
     */
    excludedNamespaceScopedResources?: string[];
    /**
     * The namespaces to be excluded in the backup.
     * Can't be used if scope is SET_NAMESPACES.
     */
    excludedNamespaces?: string[];
    /**
     * The name list for the resources to be excluded in backup.
     */
    excludedResources?: string[];
    /**
     * Hooks block represent custom actions that should be executed at different phases of the backup.
     */
    hooks?: outputs.BackupScheduleSpecTemplateHooks;
    /**
     * A flag which specifies whether cluster-scoped resources should be included for consideration in the backup.
     * If set to true, all cluster-scoped resources will be backed up. If set to false, all cluster-scoped resources will be excluded from the backup.
     * If unset, all cluster-scoped resources are included if and only if all namespaces are included and there are no excluded namespaces.
     * Otherwise, only cluster-scoped resources associated with namespace-scoped resources included in the backup spec are backed up.
     * For example, if a PersistentVolumeClaim is included in the backup, its associated PersistentVolume (which is cluster-scoped) would also be backed up.
     * (Default: False)
     */
    includeClusterResources?: boolean;
    /**
     * List of cluster-scoped resource type names to include in the backup.
     * If set to "*", all cluster-scoped resource types are included.
     *   The default value is empty, which means only related cluster-scoped resources are included.
     */
    includedClusterScopedResources?: string[];
    /**
     * List of of namespace-scoped resource type names to include in the backup.
     * The default value is "*".
     */
    includedNamespaceScopedResources?: string[];
    /**
     * The namespace to be included for backup from.
     * If empty, all namespaces are included.
     * Can't be used if scope is FULL_CLUSTER.
     * Required if scope is SET_NAMESPACES.
     */
    includedNamespaces?: string[];
    /**
     * The name list for the resources to be included into backup. If empty, all resources are included.
     */
    includedResources?: string[];
    /**
     * The label selector to selectively adding individual objects to the backup schedule.
     * If not specified, all objects are included.
     * Can't be used if scope is FULL_CLUSTER or SET_NAMESPACES.
     * Required if scope is LABEL_SELECTOR and Or Label Selectors are not defined
     */
    labelSelector?: outputs.BackupScheduleSpecTemplateLabelSelector;
    /**
     * (Repeatable Block) A list of label selectors to filter with when adding individual objects to the backup.
     * If multiple provided they will be joined by the OR operator.
     * LabelSelector as well as OrLabelSelectors cannot co-exist in backup request, only one of them can be used.
     * Can't be used if scope is FULL_CLUSTER or SET_NAMESPACES.
     * Required if scope is LABEL_SELECTOR and Label Selector is not defined
     */
    orLabelSelectors?: outputs.BackupScheduleSpecTemplateOrLabelSelector[];
    /**
     * Specifies the backup order of resources of specific Kind. The map key is the Kind name and value is a list of resource names separated by commas.
     * Each resource name has format "namespace/resourcename".
     * For cluster resources, simply use "resourcename".
     */
    orderedResources?: {[key: string]: string};
    /**
     * Specifies whether snapshot data should be moved to the target location.(Default:False)
     */
    snapshotMoveData?: boolean;
    /**
     * A flag which specifies whether to take cloud snapshots of any PV's referenced in the set of objects included in the Backup.
     * If set to true, snapshots will be taken, otherwise, snapshots will be skipped.
     * If left unset, snapshots will be attempted if volume snapshots are configured for the cluster.
     */
    snapshotVolumes?: boolean;
    /**
     * The name of a BackupStorageLocation where the backup should be stored.
     */
    storageLocation?: string;
    /**
     * System excluded namespaces for state.
     */
    sysExcludedNamespaces: string[];
    /**
     * A list containing names of VolumeSnapshotLocations associated with this backup.
     */
    volumeSnapshotLocations?: string[];
}

export interface BackupScheduleSpecTemplateHooks {
    /**
     * (Repeatable Block) Resources are hooks that should be executed when backing up individual instances of a resource.
     */
    resources?: outputs.BackupScheduleSpecTemplateHooksResource[];
}

export interface BackupScheduleSpecTemplateHooksResource {
    /**
     * Specifies the namespaces to which this hook spec does not apply.
     */
    excludedNamespaces?: string[];
    /**
     * Specifies the namespaces to which this hook spec applies.
     * If empty, it applies to all namespaces.
     */
    includedNamespaces?: string[];
    /**
     * The label selector to selectively adding individual objects to the hook resource.
     * If not specified, all objects are included.
     */
    labelSelector?: outputs.BackupScheduleSpecTemplateHooksResourceLabelSelector;
    /**
     * The name of the hook resource.
     */
    name: string;
    /**
     * (Repeatable Block) A list of backup hooks to execute after storing the item in the backup.
     * These are executed after all "additional items" from item actions are processed.
     */
    postHooks?: outputs.BackupScheduleSpecTemplateHooksResourcePostHook[];
    /**
     * (Repeatable Block) A list of backup hooks to execute after storing the item in the backup.
     * These are executed after all "additional items" from item actions are processed.
     */
    preHooks?: outputs.BackupScheduleSpecTemplateHooksResourcePreHook[];
}

export interface BackupScheduleSpecTemplateHooksResourceLabelSelector {
    /**
     * (Repeatable Block) A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.BackupScheduleSpecTemplateHooksResourceLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In" and the values array contains only "value".
     * The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface BackupScheduleSpecTemplateHooksResourceLabelSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key: string;
    /**
     * Operator represents a key's relationship to a set of values.
     * Valid operators are "In", "NotIn", "Exists" and "DoesNotExist".
     */
    operator: string;
    /**
     * Values is an array of string values.
     * If the operator is "In" or "NotIn", the values array must be non-empty.
     * If the operator is "Exists" or "DoesNotExist", the values array must be empty.
     * This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface BackupScheduleSpecTemplateHooksResourcePostHook {
    /**
     * Exec block defines an exec hook.
     */
    exec: outputs.BackupScheduleSpecTemplateHooksResourcePostHookExec;
}

export interface BackupScheduleSpecTemplateHooksResourcePostHookExec {
    /**
     * The command and arguments to execute.
     */
    commands: string[];
    /**
     * The container in the pod where the command should be executed.
     * If not specified, the pod's first container is used.
     */
    container: string;
    /**
     * Specifies how Velero should behave if it encounters an error executing this hook.
     * Valid values are (FAIL, CONTINUE)
     */
    onError?: string;
    /**
     * Defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
     */
    timeout?: string;
}

export interface BackupScheduleSpecTemplateHooksResourcePreHook {
    /**
     * Exec block defines an exec hook.
     */
    exec: outputs.BackupScheduleSpecTemplateHooksResourcePreHookExec;
}

export interface BackupScheduleSpecTemplateHooksResourcePreHookExec {
    /**
     * The command and arguments to execute.
     */
    commands: string[];
    /**
     * The container in the pod where the command should be executed.
     * If not specified, the pod's first container is used.
     */
    container: string;
    /**
     * Specifies how Velero should behave if it encounters an error executing this hook.
     * Valid values are (FAIL, CONTINUE)
     */
    onError?: string;
    /**
     * Defines the maximum amount of time Velero should wait for the hook to complete before considering the execution a failure.
     */
    timeout?: string;
}

export interface BackupScheduleSpecTemplateLabelSelector {
    /**
     * (Repeatable Block) A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.BackupScheduleSpecTemplateLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In" and the values array contains only "value".
     * The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface BackupScheduleSpecTemplateLabelSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key: string;
    /**
     * Operator represents a key's relationship to a set of values.
     * Valid operators are "In", "NotIn", "Exists" and "DoesNotExist".
     */
    operator: string;
    /**
     * Values is an array of string values.
     * If the operator is "In" or "NotIn", the values array must be non-empty.
     * If the operator is "Exists" or "DoesNotExist", the values array must be empty.
     * This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface BackupScheduleSpecTemplateOrLabelSelector {
    /**
     * (Repeatable Block) A list of label selector requirements. The requirements are ANDed.
     */
    matchExpressions?: outputs.BackupScheduleSpecTemplateOrLabelSelectorMatchExpression[];
    /**
     * A map of {key,value} pairs. A single {key,value} in the map is equivalent to an element of match_expressions, whose key field is "key", the operator is "In" and the values array contains only "value".
     * The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface BackupScheduleSpecTemplateOrLabelSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key: string;
    /**
     * Operator represents a key's relationship to a set of values.
     * Valid operators are "In", "NotIn", "Exists" and "DoesNotExist".
     */
    operator: string;
    /**
     * Values is an array of string values.
     * If the operator is "In" or "NotIn", the values array must be non-empty.
     * If the operator is "Exists" or "DoesNotExist", the values array must be empty.
     * This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface ClusterAttachK8sCluster {
    /**
     * Attach cluster description
     */
    description?: string;
    /**
     * Attach cluster KUBECONFIG path
     */
    kubeconfigFile?: string;
    /**
     * Attach cluster KUBECONFIG
     */
    kubeconfigRaw?: string;
}

export interface ClusterGroupMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface ClusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface ClusterNodePoolMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface ClusterNodePoolSpec {
    /**
     * Cloud labels
     */
    cloudLabels?: {[key: string]: string};
    /**
     * Node labels
     */
    nodeLabels?: {[key: string]: string};
    /**
     * TKGAWSNodepool is the nodepool spec for TKG AWS cluster
     */
    tkgAws?: outputs.ClusterNodePoolSpecTkgAw[];
    /**
     * TKGServiceVsphereNodepool is the nodepool spec for TKG service vsphere cluster
     */
    tkgServiceVspheres?: outputs.ClusterNodePoolSpecTkgServiceVsphere[];
    /**
     * TkgVsphereNodepool is the nodepool config for the TKG vsphere cluster
     */
    tkgVspheres?: outputs.ClusterNodePoolSpecTkgVsphere[];
    /**
     * Count is the number of nodes
     */
    workerNodeCount: string;
}

export interface ClusterNodePoolSpecTkgAw {
    /**
     * Nodepool instance type
     */
    class?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystem of the nodes
     */
    storageClass?: string;
}

export interface ClusterNodePoolSpecTkgServiceVsphere {
    /**
     * Nodepool instance type
     */
    class: string;
    /**
     * Configure the failure domain of node pool. The potential values could be found using cluster:options api. This parameter will be ignored by the backend if the TKG service vsphere cluster doesn't support.
     */
    failureDomain?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystem of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for nodepool nodes
     */
    volumes?: outputs.ClusterNodePoolSpecTkgServiceVsphereVolume[];
}

export interface ClusterNodePoolSpecTkgServiceVsphereVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface ClusterNodePoolSpecTkgVsphere {
    /**
     * VM specific configuration
     */
    vmConfig: outputs.ClusterNodePoolSpecTkgVsphereVmConfig;
}

export interface ClusterNodePoolSpecTkgVsphereVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface ClusterSpec {
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * Optional image registry name is the name of the image registry to be used for the cluster
     */
    imageRegistry?: string;
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
    /**
     * The Tanzu Kubernetes Grid (TKGm) AWS cluster spec
     */
    tkgAws?: outputs.ClusterSpecTkgAws;
    /**
     * The Tanzu Kubernetes Grid Service (TKGs) cluster spec
     */
    tkgServiceVsphere?: outputs.ClusterSpecTkgServiceVsphere;
    /**
     * The Tanzu Kubernetes Grid (TKGm) vSphere cluster spec
     */
    tkgVsphere?: outputs.ClusterSpecTkgVsphere;
}

export interface ClusterSpecTkgAws {
    /**
     * Advanced configuration for TKGm cluster
     */
    advancedConfigs?: outputs.ClusterSpecTkgAwsAdvancedConfig[];
    /**
     * Kubernetes version distribution for the cluster
     */
    distribution: outputs.ClusterSpecTkgAwsDistribution;
    /**
     * AWS related settings for workload cluster
     */
    settings: outputs.ClusterSpecTkgAwsSettings;
    /**
     * Topology configuration of the cluster
     */
    topology: outputs.ClusterSpecTkgAwsTopology;
}

export interface ClusterSpecTkgAwsAdvancedConfig {
    /**
     * The key of the advanced configuration parameters
     */
    key: string;
    /**
     * The value of the advanced configuration parameters
     */
    value: string;
}

export interface ClusterSpecTkgAwsDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Specifies name of the account in which to create the cluster
     */
    provisionerCredentialName?: string;
    /**
     * Specifies region of the cluster
     */
    region: string;
    /**
     * Specifies version of the cluster
     */
    version: string;
}

export interface ClusterSpecTkgAwsSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.ClusterSpecTkgAwsSettingsNetwork;
    /**
     * Security Settings specifies security-related settings for the cluster
     */
    security: outputs.ClusterSpecTkgAwsSettingsSecurity;
}

export interface ClusterSpecTkgAwsSettingsNetwork {
    /**
     * Cluster network specifies kubernetes network information for the cluster
     */
    cluster: outputs.ClusterSpecTkgAwsSettingsNetworkCluster;
    /**
     * Provider Network specifies provider specific network information for the cluster
     */
    providers: outputs.ClusterSpecTkgAwsSettingsNetworkProvider[];
}

export interface ClusterSpecTkgAwsSettingsNetworkCluster {
    /**
     * APIServerPort specifies the port address for the cluster that defaults to 6443.
     */
    apiServerPort?: number;
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.ClusterSpecTkgAwsSettingsNetworkClusterPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.ClusterSpecTkgAwsSettingsNetworkClusterService[];
}

export interface ClusterSpecTkgAwsSettingsNetworkClusterPod {
    /**
     * CIDRBlocks specifies one or more of IP address ranges
     */
    cidrBlocks: string;
}

export interface ClusterSpecTkgAwsSettingsNetworkClusterService {
    /**
     * CIDRBlocks specifies one or more of IP address ranges
     */
    cidrBlocks: string;
}

export interface ClusterSpecTkgAwsSettingsNetworkProvider {
    /**
     * Optional list of subnets used to place the nodes in the cluster
     */
    subnets?: outputs.ClusterSpecTkgAwsSettingsNetworkProviderSubnet[];
    /**
     * AWS VPC configuration for the cluster
     */
    vpc: outputs.ClusterSpecTkgAwsSettingsNetworkProviderVpc;
}

export interface ClusterSpecTkgAwsSettingsNetworkProviderSubnet {
    /**
     * AWS availability zone e.g. us-west-2a
     */
    availabilityZone?: string;
    /**
     * CIDR for AWS subnet which must be in the range of AWS VPC CIDR block
     */
    cidrBlockSubnet?: string;
    /**
     * Describes if it is public subnet or private subnet
     */
    isPublic?: boolean;
    /**
     * This is the subnet ID of AWS. The rest of the fields are ignored if this field is specified
     */
    subnetId?: string;
}

export interface ClusterSpecTkgAwsSettingsNetworkProviderVpc {
    /**
     * CIDR for AWS VPC. A valid example is 10.0.0.0/16
     */
    cidrBlockVpc: string;
    vpcId: string;
}

export interface ClusterSpecTkgAwsSettingsSecurity {
    /**
     * SSH key for provisioning and accessing the cluster VMs
     */
    sshKey: string;
}

export interface ClusterSpecTkgAwsTopology {
    /**
     * AWS specific control plane configuration for workload cluster object
     */
    controlPlane: outputs.ClusterSpecTkgAwsTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.ClusterSpecTkgAwsTopologyNodePool[];
}

export interface ClusterSpecTkgAwsTopologyControlPlane {
    /**
     * List of availability zones for the control plane nodes
     */
    availabilityZones: string[];
    /**
     * Flag which controls if the cluster needs to be highly available. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * Control plane instance type
     */
    instanceType: string;
}

export interface ClusterSpecTkgAwsTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.ClusterSpecTkgAwsTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.ClusterSpecTkgAwsTopologyNodePoolSpec;
}

export interface ClusterSpecTkgAwsTopologyNodePoolInfo {
    /**
     * Description of the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name: string;
}

export interface ClusterSpecTkgAwsTopologyNodePoolSpec {
    /**
     * Nodepool config for tkg aws
     */
    tkgAws?: outputs.ClusterSpecTkgAwsTopologyNodePoolSpecTkgAws;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface ClusterSpecTkgAwsTopologyNodePoolSpecTkgAws {
    /**
     * Availability zone for the nodepool that is to be used when you are creating a nodepool for cluster in TMC hosted AWS solution
     */
    availabilityZone?: string;
    /**
     * Nodepool instance type whose potential values could be found using cluster:options api
     */
    instanceType: string;
    /**
     * List of Availability Zones to place the AWS nodes on. Please use this field to provision a nodepool for workload cluster on an attached TKG AWS management cluster
     */
    nodePlacement: outputs.ClusterSpecTkgAwsTopologyNodePoolSpecTkgAwsNodePlacement;
    /**
     * Subnet ID of the private subnet in which you want the nodes to be created in
     */
    nodepoolSubnetId: string;
    /**
     * Kubernetes version of the node pool
     */
    version: string;
}

export interface ClusterSpecTkgAwsTopologyNodePoolSpecTkgAwsNodePlacement {
    /**
     * The Availability Zone where the AWS nodes are placed
     */
    awsAvailabilityZone: string;
}

export interface ClusterSpecTkgServiceVsphere {
    /**
     * VSphere specific distribution
     */
    distribution: outputs.ClusterSpecTkgServiceVsphereDistribution;
    /**
     * VSphere related settings for workload cluster
     */
    settings: outputs.ClusterSpecTkgServiceVsphereSettings;
    /**
     * Topology specific configuration
     */
    topology: outputs.ClusterSpecTkgServiceVsphereTopology;
}

export interface ClusterSpecTkgServiceVsphereDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Version of the cluster
     */
    version: string;
}

export interface ClusterSpecTkgServiceVsphereSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.ClusterSpecTkgServiceVsphereSettingsNetwork;
    /**
     * StorageSettings specifies storage-related settings for the cluster
     */
    storage?: outputs.ClusterSpecTkgServiceVsphereSettingsStorage;
}

export interface ClusterSpecTkgServiceVsphereSettingsNetwork {
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.ClusterSpecTkgServiceVsphereSettingsNetworkPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.ClusterSpecTkgServiceVsphereSettingsNetworkService[];
}

export interface ClusterSpecTkgServiceVsphereSettingsNetworkPod {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface ClusterSpecTkgServiceVsphereSettingsNetworkService {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface ClusterSpecTkgServiceVsphereSettingsStorage {
    /**
     * Classes is a list of storage classes from the supervisor namespace to expose within a cluster. If omitted, all storage classes from the supervisor namespace will be exposed within the cluster.
     */
    classes?: string[];
    /**
     * DefaultClass is the valid storage class name which is treated as the default storage class within a cluster. If omitted, no default storage class is set.
     */
    defaultClass?: string;
}

export interface ClusterSpecTkgServiceVsphereTopology {
    /**
     * Control plane specific configuration
     */
    controlPlane: outputs.ClusterSpecTkgServiceVsphereTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.ClusterSpecTkgServiceVsphereTopologyNodePool[];
}

export interface ClusterSpecTkgServiceVsphereTopologyControlPlane {
    /**
     * Control plane instance type
     */
    class: string;
    /**
     * High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystems of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for control plane nodes
     */
    volumes?: outputs.ClusterSpecTkgServiceVsphereTopologyControlPlaneVolume[];
}

export interface ClusterSpecTkgServiceVsphereTopologyControlPlaneVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface ClusterSpecTkgServiceVsphereTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.ClusterSpecTkgServiceVsphereTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.ClusterSpecTkgServiceVsphereTopologyNodePoolSpec;
}

export interface ClusterSpecTkgServiceVsphereTopologyNodePoolInfo {
    /**
     * Description for the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name?: string;
}

export interface ClusterSpecTkgServiceVsphereTopologyNodePoolSpec {
    /**
     * Cloud labels
     */
    cloudLabel?: {[key: string]: string};
    /**
     * Node labels
     */
    nodeLabel?: {[key: string]: string};
    /**
     * Nodepool config for tkg service vsphere
     */
    tkgServiceVsphere?: outputs.ClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphere;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface ClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphere {
    /**
     * Control plane instance type
     */
    class: string;
    /**
     * Configure the failure domain of node pool. The potential values could be found using cluster:options api.
     */
    failureDomain?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystems of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for control plane nodes
     */
    volumes?: outputs.ClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphereVolume[];
}

export interface ClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphereVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface ClusterSpecTkgVsphere {
    /**
     * Advanced configuration for TKGm cluster
     */
    advancedConfigs?: outputs.ClusterSpecTkgVsphereAdvancedConfig[];
    /**
     * VSphere specific distribution
     */
    distribution: outputs.ClusterSpecTkgVsphereDistribution;
    /**
     * VSphere related settings for workload cluster
     */
    settings: outputs.ClusterSpecTkgVsphereSettings;
    /**
     * Topology specific configuration
     */
    topology: outputs.ClusterSpecTkgVsphereTopology;
}

export interface ClusterSpecTkgVsphereAdvancedConfig {
    /**
     * The key of the advanced configuration parameters
     */
    key: string;
    /**
     * The value of the advanced configuration parameters
     */
    value: string;
}

export interface ClusterSpecTkgVsphereDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Version specifies the version of the Kubernetes cluster
     */
    version: string;
    /**
     * Workspace defines a workspace configuration for the vSphere cloud provider
     */
    workspace: outputs.ClusterSpecTkgVsphereDistributionWorkspace;
}

export interface ClusterSpecTkgVsphereDistributionWorkspace {
    datacenter: string;
    datastore: string;
    folder: string;
    resourcePool: string;
    workspaceNetwork: string;
}

export interface ClusterSpecTkgVsphereSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.ClusterSpecTkgVsphereSettingsNetwork;
    /**
     * Security Settings specifies security-related settings for the cluster
     */
    security: outputs.ClusterSpecTkgVsphereSettingsSecurity;
}

export interface ClusterSpecTkgVsphereSettingsNetwork {
    /**
     * APIServerPort specifies the port address for the cluster that defaults to 6443.
     */
    apiServerPort?: number;
    /**
     * ControlPlaneEndpoint specifies the control plane virtual IP address. The value should be unique for every create request, else cluster creation shall fail. This field is not needed when AVI enabled while creating a legacy cluster on TKGm.
     */
    controlPlaneEndPoint?: string;
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.ClusterSpecTkgVsphereSettingsNetworkPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.ClusterSpecTkgVsphereSettingsNetworkService[];
}

export interface ClusterSpecTkgVsphereSettingsNetworkPod {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface ClusterSpecTkgVsphereSettingsNetworkService {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface ClusterSpecTkgVsphereSettingsSecurity {
    /**
     * SSH key for provisioning and accessing the cluster VMs
     */
    sshKey: string;
}

export interface ClusterSpecTkgVsphereTopology {
    /**
     * VSphere specific control plane configuration for workload cluster object
     */
    controlPlane: outputs.ClusterSpecTkgVsphereTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.ClusterSpecTkgVsphereTopologyNodePool[];
}

export interface ClusterSpecTkgVsphereTopologyControlPlane {
    /**
     * High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * VM specific configuration
     */
    vmConfig: outputs.ClusterSpecTkgVsphereTopologyControlPlaneVmConfig;
}

export interface ClusterSpecTkgVsphereTopologyControlPlaneVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface ClusterSpecTkgVsphereTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.ClusterSpecTkgVsphereTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.ClusterSpecTkgVsphereTopologyNodePoolSpec;
}

export interface ClusterSpecTkgVsphereTopologyNodePoolInfo {
    /**
     * Description of the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name: string;
}

export interface ClusterSpecTkgVsphereTopologyNodePoolSpec {
    /**
     * Nodepool config for tkgm vsphere
     */
    tkgVsphere?: outputs.ClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphere;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface ClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphere {
    /**
     * VM specific configuration
     */
    vmConfig: outputs.ClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphereVmConfig;
}

export interface ClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphereVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface CredentialMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface CredentialSpec {
    /**
     * The Tanzu capability for which the credential shall be used. Value must be in list [DATA_PROTECTION TANZU_OBSERVABILITY TANZU_SERVICE_MESH PROXY_CONFIG MANAGED_K8S_PROVIDER IMAGE_REGISTRY]
     */
    capability?: string;
    /**
     * Holds credentials sensitive data
     */
    data?: outputs.CredentialSpecData;
    /**
     * The Tanzu provider for which describes credential data type. Value must be in list [PROVIDER_UNSPECIFIED,AWS_EC2,GENERIC_S3,AZURE_AD,AWS_EKS,AZURE_AKS,GENERIC_KEY_VALUE]
     */
    provider?: string;
}

export interface CredentialSpecData {
    /**
     * AWS credential data type
     */
    awsCredential?: outputs.CredentialSpecDataAwsCredential;
    /**
     * Azure credential
     */
    azureCredential?: outputs.CredentialSpecDataAzureCredential;
    /**
     * Generic credential data type used to hold a blob of data represented as string
     */
    genericCredential?: string;
    /**
     * Key Value credential
     */
    keyValue?: outputs.CredentialSpecDataKeyValue;
}

export interface CredentialSpecDataAwsCredential {
    /**
     * Account ID of the AWS credential
     */
    accountId?: string;
    /**
     * Generic credential
     */
    genericCredential?: string;
    /**
     * AWS IAM role ARN and external ID
     */
    iamRole?: outputs.CredentialSpecDataAwsCredentialIamRole;
}

export interface CredentialSpecDataAwsCredentialIamRole {
    /**
     * AWS IAM role ARN
     */
    arn?: string;
    /**
     * An external ID used to assume an AWS IAM role
     */
    extId?: string;
}

export interface CredentialSpecDataAzureCredential {
    /**
     * Azure service principal
     */
    servicePrincipal?: outputs.CredentialSpecDataAzureCredentialServicePrincipal;
    /**
     * Azure service principal
     */
    servicePrincipalWithCertificate?: outputs.CredentialSpecDataAzureCredentialServicePrincipalWithCertificate;
}

export interface CredentialSpecDataAzureCredentialServicePrincipal {
    /**
     * Azure Cloud name
     */
    azureCloudName?: string;
    /**
     * Client ID of the Service Principal
     */
    clientId: string;
    /**
     * Client Secret of the Service Principal
     */
    clientSecret?: string;
    /**
     * Resource Group name
     */
    resourceGroup: string;
    /**
     * Subscription ID of the Azure credential
     */
    subscriptionId: string;
    /**
     * Tenant ID of the Azure credential
     */
    tenantId: string;
}

export interface CredentialSpecDataAzureCredentialServicePrincipalWithCertificate {
    /**
     * Azure Cloud name
     */
    azureCloudName?: string;
    /**
     * Client certificate of the Service Principal
     */
    clientCertificate: string;
    /**
     * Client ID of the Service Principal
     */
    clientId: string;
    /**
     * IDs of the Azure Subscriptions that the Service Principal can manage
     */
    managedSubscriptions?: string[];
    /**
     * Subscription ID of the Azure credential
     */
    subscriptionId: string;
    /**
     * Tenant ID of the Azure credential
     */
    tenantId: string;
}

export interface CredentialSpecDataKeyValue {
    /**
     * Data secret data in the format of key-value pair
     */
    data?: {[key: string]: string};
    /**
     * Type of Secret data, usually mapped to k8s secret type. Supported types: [SECRET_TYPE_UNSPECIFIED,OPAQUE_SECRET_TYPE,DOCKERCONFIGJSON_SECRET_TYPE]
     */
    type?: string;
}

export interface CustomIamRoleMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface CustomIamRoleSpec {
    /**
     * Aggregation rules for the iam role.
     */
    aggregationRule?: outputs.CustomIamRoleSpecAggregationRule;
    /**
     * The allowed scopes for the iam role.
     * Valid values are (ORGANIZATION, MANAGEMENT_CLUSTER, PROVISIONER, CLUSTER_GROUP, CLUSTER, WORKSPACE, NAMESPACE)
     */
    allowedScopes: string[];
    /**
     * Flag representing whether role is deprecated.
     */
    isDeprecated?: boolean;
    /**
     * Kubernetes permissions for the iam role.
     */
    kubernetesPermissions?: outputs.CustomIamRoleSpecKubernetesPermissions;
    /**
     * Tanzu-specific permissions for the role.
     */
    tanzuPermissions?: string[];
}

export interface CustomIamRoleSpecAggregationRule {
    /**
     * Cluster role selector for the iam role.
     */
    clusterRoleSelectors: outputs.CustomIamRoleSpecAggregationRuleClusterRoleSelector[];
}

export interface CustomIamRoleSpecAggregationRuleClusterRoleSelector {
    /**
     * List of label selector requirements.
     * The requirements are ANDed.
     */
    matchExpressions?: outputs.CustomIamRoleSpecAggregationRuleClusterRoleSelectorMatchExpression[];
    /**
     * Map of {key,value} pairs.
     * A single {key,value} in the match_labels map is equivalent to an element of match_expression, whose key field is "key", the operator is "In", and the values array contains only "value". 
     * The requirements are ANDed.
     */
    matchLabels?: {[key: string]: string};
}

export interface CustomIamRoleSpecAggregationRuleClusterRoleSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key: string;
    /**
     * Operator represents a key's relationship to a set of values.
     * Valid operators are "In", "NotIn", "Exists" and "DoesNotExist".
     */
    operator: string;
    /**
     * Values is an array of string values.
     * If the operator is "In" or "NotIn", the values array must be non-empty.
     * If the operator is "Exists" or "DoesNotExist", the values array must be empty.
     * This array is replaced during a strategic merge patch.
     */
    values?: string[];
}

export interface CustomIamRoleSpecKubernetesPermissions {
    /**
     * Kubernetes rules.
     */
    rules: outputs.CustomIamRoleSpecKubernetesPermissionsRule[];
}

export interface CustomIamRoleSpecKubernetesPermissionsRule {
    /**
     * API groups.
     */
    apiGroups?: string[];
    /**
     * Restricts the rule to resources by name.
     */
    resourceNames?: string[];
    /**
     * Resources for the role.
     */
    resources?: string[];
    /**
     * Non-resource urls for the role.
     */
    urlPaths?: string[];
    /**
     * Verbs.
     */
    verbs: string[];
}

export interface CustomPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface CustomPolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.CustomPolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.CustomPolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.CustomPolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.CustomPolicyScopeWorkspace;
}

export interface CustomPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface CustomPolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface CustomPolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface CustomPolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface CustomPolicySpec {
    /**
     * Input for the custom policy, having one of the valid recipes: [tmc_block_nodeport_service tmc_block_resources tmc_block_rolebinding_subjects tmc_external_ips tmc_https_ingress tmc_require_labels custom].
     */
    input: outputs.CustomPolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.CustomPolicySpecNamespaceSelector;
}

export interface CustomPolicySpecInput {
    /**
     * The input schema for custom policy tmc_external_ips recipe version v1
     */
    custom?: outputs.CustomPolicySpecInputCustom;
    /**
     * The input schema for custom policy tmc_block_nodeport_service recipe version v1
     */
    tmcBlockNodeportService?: outputs.CustomPolicySpecInputTmcBlockNodeportService;
    /**
     * The input schema for custom policy tmc_block_resources recipe version v1
     */
    tmcBlockResources?: outputs.CustomPolicySpecInputTmcBlockResources;
    /**
     * The input schema for custom policy tmc_block_rolebinding_subjects recipe version v1
     */
    tmcBlockRolebindingSubjects?: outputs.CustomPolicySpecInputTmcBlockRolebindingSubjects;
    /**
     * The input schema for custom policy tmc_external_ips recipe version v1
     */
    tmcExternalIps?: outputs.CustomPolicySpecInputTmcExternalIps;
    /**
     * The input schema for custom policy tmc_https_ingress recipe version v1
     */
    tmcHttpsIngress?: outputs.CustomPolicySpecInputTmcHttpsIngress;
    /**
     * The input schema for custom policy tmc_require_labels recipe version v1
     */
    tmcRequireLabels?: outputs.CustomPolicySpecInputTmcRequireLabels;
}

export interface CustomPolicySpecInputCustom {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * JSON encoded template parameters.
     */
    parameters?: string;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputCustomTargetKubernetesResource[];
    /**
     * Name of custom template.
     */
    templateName: string;
}

export interface CustomPolicySpecInputCustomTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcBlockNodeportService {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcBlockNodeportServiceTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcBlockNodeportServiceTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcBlockResources {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcBlockResourcesTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcBlockResourcesTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcBlockRolebindingSubjects {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * Parameters.
     */
    parameters: outputs.CustomPolicySpecInputTmcBlockRolebindingSubjectsParameter[];
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcBlockRolebindingSubjectsTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcBlockRolebindingSubjectsParameter {
    /**
     * Disallowed Subjects.
     */
    disallowedSubjects: outputs.CustomPolicySpecInputTmcBlockRolebindingSubjectsParameterDisallowedSubject[];
}

export interface CustomPolicySpecInputTmcBlockRolebindingSubjectsParameterDisallowedSubject {
    /**
     * The kind of subject to disallow, can be User/Group/ServiceAccount.
     */
    kind: string;
    /**
     * The name of the subject to disallow.
     */
    name: string;
}

export interface CustomPolicySpecInputTmcBlockRolebindingSubjectsTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcExternalIps {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * Parameters.
     */
    parameters: outputs.CustomPolicySpecInputTmcExternalIpsParameter[];
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcExternalIpsTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcExternalIpsParameter {
    /**
     * Allowed IPs.
     */
    allowedIps: string[];
}

export interface CustomPolicySpecInputTmcExternalIpsTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcHttpsIngress {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcHttpsIngressTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcHttpsIngressTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecInputTmcRequireLabels {
    /**
     * Audit (dry-run).
     */
    audit?: boolean;
    /**
     * Parameters.
     */
    parameters: outputs.CustomPolicySpecInputTmcRequireLabelsParameter[];
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.CustomPolicySpecInputTmcRequireLabelsTargetKubernetesResource[];
}

export interface CustomPolicySpecInputTmcRequireLabelsParameter {
    /**
     * Labels.
     */
    labels: outputs.CustomPolicySpecInputTmcRequireLabelsParameterLabel[];
}

export interface CustomPolicySpecInputTmcRequireLabelsParameterLabel {
    /**
     * The label key to enforce.
     */
    key: string;
    /**
     * Optional label value to enforce (if left empty, only key will be enforced).
     */
    value?: string;
}

export interface CustomPolicySpecInputTmcRequireLabelsTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface CustomPolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.CustomPolicySpecNamespaceSelectorMatchExpression[];
}

export interface CustomPolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface CustomPolicyTemplateMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface CustomPolicyTemplateSpec {
    /**
     * List of Kubernetes api-resource kinds that need to be synced/replicated in Gatekeeper in order to enforce policy rules on those resources.
     * Note: This is used for OPAGatekeeper based templates, and should be used if the policy enforcement logic in Rego code uses cached data using "data.inventory" fields.
     */
    dataInventories?: outputs.CustomPolicyTemplateSpecDataInventory[];
    /**
     * Flag representing whether the custom policy template is deprecated.
     */
    isDeprecated?: boolean;
    /**
     * The type of Kubernetes resource encoded in Object.
     * Currently, we only support OPAGatekeeper based 'ConstraintTemplate' object.
     */
    objectType?: string;
    /**
     * YAML formatted Kubernetes resource.
     * The Kubernetes object has to be of the type defined in ObjectType ('ConstraintTemplate').
     * The object name must match the name of the wrapping policy template.
     * This will be applied on the cluster after a policy is created using this version of the template.
     * This contains the latest version of the object. For previous versions, check Versions API.
     */
    templateManifest: string;
    /**
     * The type of policy template.
     * Currently, we only support 'OPAGatekeeper' based policy templates.
     */
    templateType?: string;
}

export interface CustomPolicyTemplateSpecDataInventory {
    /**
     * API resource group
     */
    group: string;
    /**
     * API resource kind
     */
    kind: string;
    /**
     * API resource version
     */
    version: string;
}

export interface EksclusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface EksclusterSpec {
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * EKS config for the cluster control plane
     */
    config: outputs.EksclusterSpecConfig;
    /**
     * Nodepool definitions for the cluster
     */
    nodepools: outputs.EksclusterSpecNodepool[];
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
}

export interface EksclusterSpecConfig {
    /**
     * Addons config contains the configuration for all the addons of the cluster, which support customization of addon configuration
     */
    addonsConfig?: outputs.EksclusterSpecConfigAddonsConfig;
    /**
     * Kubernetes Network Config
     */
    kubernetesNetworkConfig?: outputs.EksclusterSpecConfigKubernetesNetworkConfig;
    /**
     * Kubernetes version of the cluster
     */
    kubernetesVersion: string;
    /**
     * EKS logging configuration
     */
    logging?: outputs.EksclusterSpecConfigLogging;
    /**
     * ARN of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations
     */
    roleArn: string;
    /**
     * The metadata to apply to the cluster to assist with categorization and organization
     */
    tags: {[key: string]: string};
    /**
     * VPC config
     */
    vpc: outputs.EksclusterSpecConfigVpc;
}

export interface EksclusterSpecConfigAddonsConfig {
    /**
     * VPC CNI addon config contains the configuration for the VPC CNI addon of the cluster
     */
    vpcCniConfig?: outputs.EksclusterSpecConfigAddonsConfigVpcCniConfig;
}

export interface EksclusterSpecConfigAddonsConfigVpcCniConfig {
    /**
     * ENI config for the VPC CNI addon
     */
    eniConfigs?: outputs.EksclusterSpecConfigAddonsConfigVpcCniConfigEniConfig[];
}

export interface EksclusterSpecConfigAddonsConfigVpcCniConfigEniConfig {
    /**
     * Subnet id for the ENI
     */
    id: string;
    /**
     * Security groups for the ENI
     */
    securityGroups?: string[];
}

export interface EksclusterSpecConfigKubernetesNetworkConfig {
    /**
     * Service CIDR for Kubernetes services
     */
    serviceCidr: string;
}

export interface EksclusterSpecConfigLogging {
    /**
     * Enable API server logs
     */
    apiServer?: boolean;
    /**
     * Enable audit logs
     */
    audit?: boolean;
    /**
     * Enable authenticator logs
     */
    authenticator?: boolean;
    /**
     * Enable controller manager logs
     */
    controllerManager?: boolean;
    /**
     * Enable scheduler logs
     */
    scheduler?: boolean;
}

export interface EksclusterSpecConfigVpc {
    /**
     * Enable Kubernetes API requests within your cluster's VPC (such as node to control plane communication) use the private VPC endpoint (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    enablePrivateAccess?: boolean;
    /**
     * Enable cluster API server access from the internet. You can, optionally, limit the CIDR blocks that can access the public endpoint using public_access_cidrs (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    enablePublicAccess?: boolean;
    /**
     * Specify which addresses from the internet can communicate to the public endpoint, if public endpoint is enabled (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    publicAccessCidrs?: string[];
    /**
     * Security groups for the cluster VMs
     */
    securityGroups?: string[];
    /**
     * Subnet ids used by the cluster (see [Amazon EKS VPC and subnet requirements and considerations](https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html#network-requirements-subnets))
     */
    subnetIds: string[];
}

export interface EksclusterSpecNodepool {
    /**
     * Info for the nodepool
     */
    info: outputs.EksclusterSpecNodepoolInfo;
    /**
     * Spec for the cluster
     */
    spec: outputs.EksclusterSpecNodepoolSpec;
}

export interface EksclusterSpecNodepoolInfo {
    /**
     * Description for the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool, immutable
     */
    name: string;
}

export interface EksclusterSpecNodepoolSpec {
    /**
     * AMI info for the nodepool if AMI type is specified as CUSTOM
     */
    amiInfo?: outputs.EksclusterSpecNodepoolSpecAmiInfo;
    /**
     * AMI type, immutable
     */
    amiType: string;
    /**
     * Capacity Type
     */
    capacityType: string;
    /**
     * Nodepool instance types, immutable
     */
    instanceTypes: string[];
    /**
     * Launch template for the nodepool
     */
    launchTemplate?: outputs.EksclusterSpecNodepoolSpecLaunchTemplate;
    /**
     * Kubernetes node labels
     */
    nodeLabels?: {[key: string]: string};
    /**
     * AMI release version
     */
    releaseVersion: string;
    /**
     * Remote access to worker nodes, immutable
     */
    remoteAccess?: outputs.EksclusterSpecNodepoolSpecRemoteAccess;
    /**
     * ARN of the IAM role that provides permissions for the Kubernetes nodepool to make calls to AWS API operations, immutable
     */
    roleArn: string;
    /**
     * Root disk size in GiB, immutable
     */
    rootDiskSize: number;
    /**
     * Nodepool scaling config
     */
    scalingConfig?: outputs.EksclusterSpecNodepoolSpecScalingConfig;
    /**
     * Subnets required for the nodepool
     */
    subnetIds: string[];
    /**
     * EKS specific tags
     */
    tags?: {[key: string]: string};
    /**
     * If specified, the node's taints
     */
    taints?: outputs.EksclusterSpecNodepoolSpecTaint[];
    /**
     * Update config for the nodepool
     */
    updateConfig?: outputs.EksclusterSpecNodepoolSpecUpdateConfig;
}

export interface EksclusterSpecNodepoolSpecAmiInfo {
    /**
     * ID of the AMI to be used
     */
    amiId?: string;
    /**
     * Override bootstrap command for the custom AMI
     */
    overrideBootstrapCmd?: string;
}

export interface EksclusterSpecNodepoolSpecLaunchTemplate {
    /**
     * The ID of the launch template
     */
    id?: string;
    /**
     * The name of the launch template
     */
    name?: string;
    /**
     * The version of the launch template to use
     */
    version?: string;
}

export interface EksclusterSpecNodepoolSpecRemoteAccess {
    /**
     * Security groups for the VMs
     */
    securityGroups?: string[];
    /**
     * SSH key allows you to connect to your instances and gather diagnostic information if there are issues.
     */
    sshKey?: string;
}

export interface EksclusterSpecNodepoolSpecScalingConfig {
    /**
     * Desired size of nodepool
     */
    desiredSize?: number;
    /**
     * Maximum size of nodepool
     */
    maxSize?: number;
    /**
     * Minimum size of nodepool
     */
    minSize?: number;
}

export interface EksclusterSpecNodepoolSpecTaint {
    /**
     * Current effect state of the node pool
     */
    effect?: string;
    /**
     * The taint key to be applied to a node
     */
    key?: string;
    /**
     * The taint value corresponding to the taint key
     */
    value?: string;
}

export interface EksclusterSpecNodepoolSpecUpdateConfig {
    /**
     * Maximum number of nodes unavailable at once during a version update
     */
    maxUnavailableNodes?: string;
    /**
     * Maximum percentage of nodes unavailable during a version update
     */
    maxUnavailablePercentage?: string;
}

export interface EnableDataProtectionDeletionPolicy {
    /**
     * Destroy backups upon deleting data protection.
     * (default: false)
     */
    deleteBackups?: boolean;
    /**
     * Disable data protection on all clusters in the cluster group even if cluster level schedules present.
     */
    force: boolean;
}

export interface EnableDataProtectionMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface EnableDataProtectionScope {
    /**
     * Cluster scope block
     */
    cluster?: outputs.EnableDataProtectionScopeCluster;
    /**
     * Cluster group scope block
     */
    clusterGroup?: outputs.EnableDataProtectionScopeClusterGroup;
}

export interface EnableDataProtectionScopeCluster {
    /**
     * Cluster name
     */
    clusterName: string;
    /**
     * Management cluster name
     */
    managementClusterName: string;
    /**
     * Cluster provisioner name
     */
    provisionerName: string;
}

export interface EnableDataProtectionScopeClusterGroup {
    /**
     * Cluster group name
     */
    clusterGroupName: string;
}

export interface EnableDataProtectionSpec {
    /**
     * A flag to indicate whether to skip installation of restic server (https://github.com/restic/restic).
     * Otherwise, restic would be enabled by default as part of Data Protection installation.
     * (Default: False)
     */
    disableRestic: boolean;
    /**
     * A flag to indicate whether to backup all the supported API Group versions of a resource on the cluster.
     * (Default: False)
     */
    enableAllApiGroupVersionsBackup: boolean;
    /**
     * A flag to indicate whether to install CSI snapshotting related capabilities.
     * (Default: False)
     */
    enableCsiSnapshots: boolean;
    /**
     * A selector to include/exclude specific clusters in a cluster group (optional)
     */
    selector?: outputs.EnableDataProtectionSpecSelector;
    /**
     * A flag to indicate whether to install the node agent daemonset which is responsible for volume data transfer to the target location.
     */
    useNodeAgent: boolean;
}

export interface EnableDataProtectionSpecSelector {
    excludednames?: string[];
    labelselectors?: outputs.EnableDataProtectionSpecSelectorLabelselector[];
    names?: string[];
}

export interface EnableDataProtectionSpecSelectorLabelselector {
    matchexpressions?: outputs.EnableDataProtectionSpecSelectorLabelselectorMatchexpression[];
}

export interface EnableDataProtectionSpecSelectorLabelselectorMatchexpression {
    key?: string;
    operator?: string;
    values: string[];
}

export interface GetAksclusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetAksclusterSpec {
    /**
     * Name of the cluster in TMC
     */
    agentName: string;
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * AKS config for the cluster control plane
     */
    config: outputs.GetAksclusterSpecConfig;
    /**
     * Nodepool definitions for the cluster
     */
    nodepools: outputs.GetAksclusterSpecNodepool[];
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
    /**
     * Resource ID of the cluster in Azure.
     */
    resourceId: string;
}

export interface GetAksclusterSpecConfig {
    /**
     * Access config
     */
    accessConfig?: outputs.GetAksclusterSpecConfigAccessConfig;
    /**
     * Addons Config
     */
    addonConfig?: outputs.GetAksclusterSpecConfigAddonConfig;
    /**
     * API Server Access Config
     */
    apiServerAccessConfig?: outputs.GetAksclusterSpecConfigApiServerAccessConfig;
    /**
     * Auto Upgrade Config
     */
    autoUpgradeConfig?: outputs.GetAksclusterSpecConfigAutoUpgradeConfig;
    /**
     * Resource ID of the disk encryption set to use for enabling
     */
    diskEncryptionSet?: string;
    /**
     * Managed Identity Config
     */
    identityConfig?: outputs.GetAksclusterSpecConfigIdentityConfig;
    /**
     * Kubernetes version of the cluster
     */
    kubernetesVersion: string;
    /**
     * Linux Config
     */
    linuxConfig?: outputs.GetAksclusterSpecConfigLinuxConfig;
    /**
     * The geo-location where the resource lives for the cluster.
     */
    location: string;
    /**
     * Network Config
     */
    networkConfig: outputs.GetAksclusterSpecConfigNetworkConfig;
    /**
     * Name of the resource group containing nodepools.
     */
    nodeResourceGroupName: string;
    /**
     * Azure Kubernetes Service SKU
     */
    sku?: outputs.GetAksclusterSpecConfigSku;
    /**
     * Storage Config
     */
    storageConfig?: outputs.GetAksclusterSpecConfigStorageConfig;
    /**
     * Metadata to apply to the cluster to assist with categorization and organization
     */
    tags: {[key: string]: string};
}

export interface GetAksclusterSpecConfigAccessConfig {
    /**
     * Azure Active Directory config
     */
    aadConfig?: outputs.GetAksclusterSpecConfigAccessConfigAadConfig;
    /**
     * Disable local accounts
     */
    disableLocalAccounts?: boolean;
    /**
     * Enable kubernetes RBAC
     */
    enableRbac?: boolean;
}

export interface GetAksclusterSpecConfigAccessConfigAadConfig {
    /**
     * List of AAD group object IDs that will have admin role of the cluster.
     */
    adminGroupIds?: string[];
    /**
     * Enable Azure RBAC for Kubernetes authorization
     */
    enableAzureRbac?: boolean;
    /**
     * Enable Managed RBAC
     */
    managed?: boolean;
    /**
     * AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
     */
    tenantId?: string;
}

export interface GetAksclusterSpecConfigAddonConfig {
    /**
     * Keyvault secrets provider addon
     */
    azureKeyvaultSecretsProviderAddonConfigs?: outputs.GetAksclusterSpecConfigAddonConfigAzureKeyvaultSecretsProviderAddonConfig[];
    /**
     * Azure policy addon
     */
    azurePolicyAddonConfigs?: outputs.GetAksclusterSpecConfigAddonConfigAzurePolicyAddonConfig[];
    /**
     * Monitor addon
     */
    monitorAddonConfigs?: outputs.GetAksclusterSpecConfigAddonConfigMonitorAddonConfig[];
}

export interface GetAksclusterSpecConfigAddonConfigAzureKeyvaultSecretsProviderAddonConfig {
    /**
     * Enable Azure Key Vault Secrets Provider
     */
    enable?: boolean;
    /**
     * Enable secrets rotation
     */
    enableSecretRotation?: boolean;
    /**
     * Secret rotation interval
     */
    rotationPollInterval?: string;
}

export interface GetAksclusterSpecConfigAddonConfigAzurePolicyAddonConfig {
    /**
     * Enable policy addon
     */
    enable?: boolean;
}

export interface GetAksclusterSpecConfigAddonConfigMonitorAddonConfig {
    /**
     * Enable monitor
     */
    enable?: boolean;
    /**
     * Log analytics workspace ID for the monitoring addon
     */
    logAnalyticsWorkspaceId?: string;
}

export interface GetAksclusterSpecConfigApiServerAccessConfig {
    /**
     * IP ranges authorized to access the Kubernetes API server
     */
    authorizedIpRanges?: string[];
    /**
     * Enable Private Cluster
     */
    enablePrivateCluster: boolean;
}

export interface GetAksclusterSpecConfigAutoUpgradeConfig {
    /**
     * Upgrade Channel. Allowed values include: NONE, PATCH, STABLE, RAPID or NODE_IMAGE
     */
    upgradeChannel?: string;
}

export interface GetAksclusterSpecConfigIdentityConfig {
    /**
     * Type of managed identity used by the cluster (default IDENTITY_TYPE_SYSTEM_ASSIGNED). Allowed values include: IDENTITY_TYPE_SYSTEM_ASSIGNED or IDENTITY_TYPE_USER_ASSIGNED
     */
    type?: string;
    /**
     * User Assigned Managed Identity Config
     */
    userAssigned?: outputs.GetAksclusterSpecConfigIdentityConfigUserAssigned;
}

export interface GetAksclusterSpecConfigIdentityConfigUserAssigned {
    /**
     * The ARM resource ID of user assigned identity in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'
     */
    resourceId: string;
}

export interface GetAksclusterSpecConfigLinuxConfig {
    /**
     * Administrator username to use for Linux VMs
     */
    adminUsername: string;
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers
     */
    sshKeys?: string[];
}

export interface GetAksclusterSpecConfigNetworkConfig {
    /**
     * DNS prefix of the cluster
     */
    dnsPrefix: string;
    /**
     * IP address assigned to the Kubernetes DNS service. This key can only be set when the network_config.network_plugin key is set to 'azure'.
     */
    dnsServiceIp: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network
     */
    dockerBridgeCidr: string;
    /**
     * Load balancer SKU
     */
    loadBalancerSku: string;
    /**
     * Network plugin. It is used for building Kubernetes network. Allowed values: azure, kubenet. Specify 'azure' for routable pod IPs from VNET, 'kubenet' for non-routable pod IPs with an overlay network, Defaults to 'kubenet'
     */
    networkPlugin: string;
    /**
     * Network plugin mode. Allowed values: overlay. Used to control the mode the network plugin should operate in. For example, 'overlay' used with networkPlugin=azure will use an overlay network (non-VNET IPs) for pods in the cluster.
     */
    networkPluginMode: string;
    /**
     * Network policy
     */
    networkPolicy?: string;
    /**
     * CIDR notation IP ranges from which to assign pod IPs
     */
    podCidrs: string[];
    /**
     * CIDR notation IP ranges from which to assign service cluster IP. This key can only be set when the network_config.network_plugin key is set to 'azure'.
     */
    serviceCidrs: string[];
}

export interface GetAksclusterSpecConfigSku {
    /**
     * Name of the cluster SKU. Allowed values include: BASIC.
     */
    name: string;
    /**
     * Tier of the cluster SKU. Allowed values include: FREE or PAID.
     */
    tier: string;
}

export interface GetAksclusterSpecConfigStorageConfig {
    /**
     * Enable the azure disk CSI driver for the storage
     */
    enableDiskCsiDriver: boolean;
    /**
     * Enable the azure file CSI driver for the storage
     */
    enableFileCsiDriver: boolean;
    /**
     * Enable the snapshot controller for the storage
     */
    enableSnapshotController: boolean;
}

export interface GetAksclusterSpecNodepool {
    /**
     * Name of the nodepool, immutable
     */
    name: string;
    /**
     * Spec for the nodepool
     */
    spec: outputs.GetAksclusterSpecNodepoolSpec;
}

export interface GetAksclusterSpecNodepoolSpec {
    /**
     * Auto scaling config.
     */
    autoScalingConfig?: outputs.GetAksclusterSpecNodepoolSpecAutoScalingConfig;
    /**
     * The list of Availability zones to use for nodepool. This can only be specified if the type of the nodepool is AvailabilitySet.
     */
    availabilityZones: string[];
    /**
     * Count is the number of nodes
     */
    count: number;
    /**
     * Whether each node is allocated its own public IP
     */
    enableNodePublicIp?: boolean;
    /**
     * The maximum number of pods that can run on a node
     */
    maxPods: number;
    /**
     * The mode of the nodepool. Allowed values include: SYSTEM or USER. A cluster must have at least one 'SYSTEM' nodepool at all times.
     */
    mode: string;
    /**
     * The node image version of the nodepool.
     */
    nodeImageVersion: string;
    /**
     * The node labels to be persisted across all nodes in nodepool
     */
    nodeLabels?: {[key: string]: string};
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the nodepool. If you specify 0, it will apply the default osDisk size according to the vmSize specified
     */
    osDiskSizeGb: number;
    /**
     * OS Disk Type. Allowed values include: EPHEMERAL or MANAGED.
     */
    osDiskType: string;
    /**
     * The OS type of the nodepool. Allowed values include: LINUX.
     */
    osType?: string;
    /**
     * The ID of a subnet in an existing VNet into which to assign pods in the cluster. Requires network-plugin to be azure and not compatible with network-plugin-mode overlay
     */
    podSubnetId?: string;
    /**
     * Scale set eviction policy, Allowed values include: DELETE or DEALLOCATE.
     */
    scaleSetEvictionPolicy?: string;
    /**
     * Scale set priority. Allowed values include: REGULAR or SPOT.
     */
    scaleSetPriority: string;
    /**
     * Max spot price
     */
    spotMaxPrice?: number;
    /**
     * AKS specific node tags
     */
    tags?: {[key: string]: string};
    /**
     * The taints added to new nodes during nodepool create and scale
     */
    taints?: outputs.GetAksclusterSpecNodepoolSpecTaint[];
    /**
     * The Nodepool type. Allowed values include: VIRTUAL_MACHINE_SCALE_SETS or AVAILABILITY_SET.
     */
    type?: string;
    /**
     * upgrade config
     */
    upgradeConfig?: outputs.GetAksclusterSpecNodepoolSpecUpgradeConfig;
    /**
     * Virtual Machine Size
     */
    vmSize: string;
    /**
     * The ID of a subnet in an existing VNet into which to deploy the cluster. If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes
     */
    vnetSubnetId?: string;
}

export interface GetAksclusterSpecNodepoolSpecAutoScalingConfig {
    /**
     * Enable auto scaling
     */
    enable?: boolean;
    /**
     * Maximum node count
     */
    maxCount?: number;
    /**
     * Minimum node count
     */
    minCount?: number;
}

export interface GetAksclusterSpecNodepoolSpecTaint {
    /**
     * Current effect state of the node pool
     */
    effect?: string;
    /**
     * The taint key to be applied to a node
     */
    key?: string;
    /**
     * The taint value corresponding to the taint key
     */
    value?: string;
}

export interface GetAksclusterSpecNodepoolSpecUpgradeConfig {
    /**
     * Max Surge
     */
    maxSurge?: string;
}

export interface GetBackupScheduleSchedule {
    backupScope: string;
    metas: outputs.GetBackupScheduleScheduleMeta[];
    name: string;
    scopes: outputs.GetBackupScheduleScheduleScope[];
    selectors: outputs.GetBackupScheduleScheduleSelector[];
    specs: outputs.GetBackupScheduleScheduleSpec[];
}

export interface GetBackupScheduleScheduleMeta {
    annotations: {[key: string]: string};
    description: string;
    labels: {[key: string]: string};
    resourceVersion: string;
    uid: string;
}

export interface GetBackupScheduleScheduleScope {
    clusterGroups: outputs.GetBackupScheduleScheduleScopeClusterGroup[];
    clusters: outputs.GetBackupScheduleScheduleScopeCluster[];
}

export interface GetBackupScheduleScheduleScopeCluster {
    clusterName: string;
    managementClusterName: string;
    provisionerName: string;
}

export interface GetBackupScheduleScheduleScopeClusterGroup {
    clusterGroupName: string;
}

export interface GetBackupScheduleScheduleSelector {
    excludedNames: string[];
    labelSelectors: outputs.GetBackupScheduleScheduleSelectorLabelSelector[];
    names: string[];
}

export interface GetBackupScheduleScheduleSelectorLabelSelector {
    matchExpressions: outputs.GetBackupScheduleScheduleSelectorLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetBackupScheduleScheduleSelectorLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetBackupScheduleScheduleSpec {
    paused: boolean;
    schedules: outputs.GetBackupScheduleScheduleSpecSchedule[];
    templates: outputs.GetBackupScheduleScheduleSpecTemplate[];
}

export interface GetBackupScheduleScheduleSpecSchedule {
    rate: string;
}

export interface GetBackupScheduleScheduleSpecTemplate {
    backupTtl: string;
    csiSnapshotTimeout: string;
    defaultVolumesToFsBackup: boolean;
    defaultVolumesToRestic: boolean;
    excludedClusterScopedResources: string[];
    excludedNamespaceScopedResources: string[];
    excludedNamespaces: string[];
    excludedResources: string[];
    hooks: outputs.GetBackupScheduleScheduleSpecTemplateHook[];
    includeClusterResources: boolean;
    includedClusterScopedResources: string[];
    includedNamespaceScopedResources: string[];
    includedNamespaces: string[];
    includedResources: string[];
    labelSelectors: outputs.GetBackupScheduleScheduleSpecTemplateLabelSelector[];
    orLabelSelectors: outputs.GetBackupScheduleScheduleSpecTemplateOrLabelSelector[];
    orderedResources: {[key: string]: string};
    snapshotMoveData: boolean;
    snapshotVolumes: boolean;
    storageLocation: string;
    sysExcludedNamespaces: string[];
    volumeSnapshotLocations: string[];
}

export interface GetBackupScheduleScheduleSpecTemplateHook {
    resources: outputs.GetBackupScheduleScheduleSpecTemplateHookResource[];
}

export interface GetBackupScheduleScheduleSpecTemplateHookResource {
    excludedNamespaces: string[];
    includedNamespaces: string[];
    labelSelectors: outputs.GetBackupScheduleScheduleSpecTemplateHookResourceLabelSelector[];
    name: string;
    postHooks: outputs.GetBackupScheduleScheduleSpecTemplateHookResourcePostHook[];
    preHooks: outputs.GetBackupScheduleScheduleSpecTemplateHookResourcePreHook[];
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourceLabelSelector {
    matchExpressions: outputs.GetBackupScheduleScheduleSpecTemplateHookResourceLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourceLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourcePostHook {
    execs: outputs.GetBackupScheduleScheduleSpecTemplateHookResourcePostHookExec[];
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourcePostHookExec {
    commands: string[];
    container: string;
    onError: string;
    timeout: string;
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourcePreHook {
    execs: outputs.GetBackupScheduleScheduleSpecTemplateHookResourcePreHookExec[];
}

export interface GetBackupScheduleScheduleSpecTemplateHookResourcePreHookExec {
    commands: string[];
    container: string;
    onError: string;
    timeout: string;
}

export interface GetBackupScheduleScheduleSpecTemplateLabelSelector {
    matchExpressions: outputs.GetBackupScheduleScheduleSpecTemplateLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetBackupScheduleScheduleSpecTemplateLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetBackupScheduleScheduleSpecTemplateOrLabelSelector {
    matchExpressions: outputs.GetBackupScheduleScheduleSpecTemplateOrLabelSelectorMatchExpression[];
    matchLabels: {[key: string]: string};
}

export interface GetBackupScheduleScheduleSpecTemplateOrLabelSelectorMatchExpression {
    key: string;
    operator: string;
    values: string[];
}

export interface GetBackupScheduleScope {
    /**
     * Cluster scope block
     */
    cluster?: outputs.GetBackupScheduleScopeCluster;
    /**
     * Cluster group scope block
     */
    clusterGroup?: outputs.GetBackupScheduleScopeClusterGroup;
}

export interface GetBackupScheduleScopeCluster {
    /**
     * Cluster name
     */
    clusterName: string;
    /**
     * Management cluster name
     */
    managementClusterName?: string;
    /**
     * Cluster provisioner name
     */
    provisionerName?: string;
}

export interface GetBackupScheduleScopeClusterGroup {
    /**
     * Cluster group name
     */
    clusterGroupName: string;
}

export interface GetClusterAttachK8sCluster {
    /**
     * Attach cluster description
     */
    description?: string;
    /**
     * Attach cluster KUBECONFIG path
     */
    kubeconfigFile?: string;
    /**
     * Attach cluster KUBECONFIG
     */
    kubeconfigRaw?: string;
}

export interface GetClusterGroupMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetClusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetClusterNodePoolMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetClusterNodePoolSpec {
    /**
     * Cloud labels
     */
    cloudLabels?: {[key: string]: string};
    /**
     * Node labels
     */
    nodeLabels?: {[key: string]: string};
    /**
     * TKGAWSNodepool is the nodepool spec for TKG AWS cluster
     */
    tkgAws?: outputs.GetClusterNodePoolSpecTkgAw[];
    /**
     * TKGServiceVsphereNodepool is the nodepool spec for TKG service vsphere cluster
     */
    tkgServiceVspheres?: outputs.GetClusterNodePoolSpecTkgServiceVsphere[];
    /**
     * TkgVsphereNodepool is the nodepool config for the TKG vsphere cluster
     */
    tkgVspheres?: outputs.GetClusterNodePoolSpecTkgVsphere[];
    /**
     * Count is the number of nodes
     */
    workerNodeCount: string;
}

export interface GetClusterNodePoolSpecTkgAw {
    /**
     * Nodepool instance type
     */
    class?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystem of the nodes
     */
    storageClass?: string;
}

export interface GetClusterNodePoolSpecTkgServiceVsphere {
    /**
     * Nodepool instance type
     */
    class: string;
    /**
     * Configure the failure domain of node pool. The potential values could be found using cluster:options api. This parameter will be ignored by the backend if the TKG service vsphere cluster doesn't support.
     */
    failureDomain?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystem of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for nodepool nodes
     */
    volumes?: outputs.GetClusterNodePoolSpecTkgServiceVsphereVolume[];
}

export interface GetClusterNodePoolSpecTkgServiceVsphereVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface GetClusterNodePoolSpecTkgVsphere {
    /**
     * VM specific configuration
     */
    vmConfig: outputs.GetClusterNodePoolSpecTkgVsphereVmConfig;
}

export interface GetClusterNodePoolSpecTkgVsphereVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface GetClusterSpec {
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * Optional image registry name is the name of the image registry to be used for the cluster
     */
    imageRegistry?: string;
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
    /**
     * The Tanzu Kubernetes Grid (TKGm) AWS cluster spec
     */
    tkgAws?: outputs.GetClusterSpecTkgAws;
    /**
     * The Tanzu Kubernetes Grid Service (TKGs) cluster spec
     */
    tkgServiceVsphere?: outputs.GetClusterSpecTkgServiceVsphere;
    /**
     * The Tanzu Kubernetes Grid (TKGm) vSphere cluster spec
     */
    tkgVsphere?: outputs.GetClusterSpecTkgVsphere;
}

export interface GetClusterSpecTkgAws {
    /**
     * Advanced configuration for TKGm cluster
     */
    advancedConfigs?: outputs.GetClusterSpecTkgAwsAdvancedConfig[];
    /**
     * Kubernetes version distribution for the cluster
     */
    distribution: outputs.GetClusterSpecTkgAwsDistribution;
    /**
     * AWS related settings for workload cluster
     */
    settings: outputs.GetClusterSpecTkgAwsSettings;
    /**
     * Topology configuration of the cluster
     */
    topology: outputs.GetClusterSpecTkgAwsTopology;
}

export interface GetClusterSpecTkgAwsAdvancedConfig {
    /**
     * The key of the advanced configuration parameters
     */
    key: string;
    /**
     * The value of the advanced configuration parameters
     */
    value: string;
}

export interface GetClusterSpecTkgAwsDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Specifies name of the account in which to create the cluster
     */
    provisionerCredentialName?: string;
    /**
     * Specifies region of the cluster
     */
    region: string;
    /**
     * Specifies version of the cluster
     */
    version: string;
}

export interface GetClusterSpecTkgAwsSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.GetClusterSpecTkgAwsSettingsNetwork;
    /**
     * Security Settings specifies security-related settings for the cluster
     */
    security: outputs.GetClusterSpecTkgAwsSettingsSecurity;
}

export interface GetClusterSpecTkgAwsSettingsNetwork {
    /**
     * Cluster network specifies kubernetes network information for the cluster
     */
    cluster: outputs.GetClusterSpecTkgAwsSettingsNetworkCluster;
    /**
     * Provider Network specifies provider specific network information for the cluster
     */
    providers: outputs.GetClusterSpecTkgAwsSettingsNetworkProvider[];
}

export interface GetClusterSpecTkgAwsSettingsNetworkCluster {
    /**
     * APIServerPort specifies the port address for the cluster that defaults to 6443.
     */
    apiServerPort?: number;
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.GetClusterSpecTkgAwsSettingsNetworkClusterPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.GetClusterSpecTkgAwsSettingsNetworkClusterService[];
}

export interface GetClusterSpecTkgAwsSettingsNetworkClusterPod {
    /**
     * CIDRBlocks specifies one or more of IP address ranges
     */
    cidrBlocks: string;
}

export interface GetClusterSpecTkgAwsSettingsNetworkClusterService {
    /**
     * CIDRBlocks specifies one or more of IP address ranges
     */
    cidrBlocks: string;
}

export interface GetClusterSpecTkgAwsSettingsNetworkProvider {
    /**
     * Optional list of subnets used to place the nodes in the cluster
     */
    subnets?: outputs.GetClusterSpecTkgAwsSettingsNetworkProviderSubnet[];
    /**
     * AWS VPC configuration for the cluster
     */
    vpc: outputs.GetClusterSpecTkgAwsSettingsNetworkProviderVpc;
}

export interface GetClusterSpecTkgAwsSettingsNetworkProviderSubnet {
    /**
     * AWS availability zone e.g. us-west-2a
     */
    availabilityZone?: string;
    /**
     * CIDR for AWS subnet which must be in the range of AWS VPC CIDR block
     */
    cidrBlockSubnet?: string;
    /**
     * Describes if it is public subnet or private subnet
     */
    isPublic?: boolean;
    /**
     * This is the subnet ID of AWS. The rest of the fields are ignored if this field is specified
     */
    subnetId?: string;
}

export interface GetClusterSpecTkgAwsSettingsNetworkProviderVpc {
    /**
     * CIDR for AWS VPC. A valid example is 10.0.0.0/16
     */
    cidrBlockVpc: string;
    vpcId: string;
}

export interface GetClusterSpecTkgAwsSettingsSecurity {
    /**
     * SSH key for provisioning and accessing the cluster VMs
     */
    sshKey: string;
}

export interface GetClusterSpecTkgAwsTopology {
    /**
     * AWS specific control plane configuration for workload cluster object
     */
    controlPlane: outputs.GetClusterSpecTkgAwsTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.GetClusterSpecTkgAwsTopologyNodePool[];
}

export interface GetClusterSpecTkgAwsTopologyControlPlane {
    /**
     * List of availability zones for the control plane nodes
     */
    availabilityZones: string[];
    /**
     * Flag which controls if the cluster needs to be highly available. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * Control plane instance type
     */
    instanceType: string;
}

export interface GetClusterSpecTkgAwsTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.GetClusterSpecTkgAwsTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.GetClusterSpecTkgAwsTopologyNodePoolSpec;
}

export interface GetClusterSpecTkgAwsTopologyNodePoolInfo {
    /**
     * Description of the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name: string;
}

export interface GetClusterSpecTkgAwsTopologyNodePoolSpec {
    /**
     * Nodepool config for tkg aws
     */
    tkgAws?: outputs.GetClusterSpecTkgAwsTopologyNodePoolSpecTkgAws;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface GetClusterSpecTkgAwsTopologyNodePoolSpecTkgAws {
    /**
     * Availability zone for the nodepool that is to be used when you are creating a nodepool for cluster in TMC hosted AWS solution
     */
    availabilityZone?: string;
    /**
     * Nodepool instance type whose potential values could be found using cluster:options api
     */
    instanceType: string;
    /**
     * List of Availability Zones to place the AWS nodes on. Please use this field to provision a nodepool for workload cluster on an attached TKG AWS management cluster
     */
    nodePlacement: outputs.GetClusterSpecTkgAwsTopologyNodePoolSpecTkgAwsNodePlacement;
    /**
     * Subnet ID of the private subnet in which you want the nodes to be created in
     */
    nodepoolSubnetId: string;
    /**
     * Kubernetes version of the node pool
     */
    version: string;
}

export interface GetClusterSpecTkgAwsTopologyNodePoolSpecTkgAwsNodePlacement {
    /**
     * The Availability Zone where the AWS nodes are placed
     */
    awsAvailabilityZone: string;
}

export interface GetClusterSpecTkgServiceVsphere {
    /**
     * VSphere specific distribution
     */
    distribution: outputs.GetClusterSpecTkgServiceVsphereDistribution;
    /**
     * VSphere related settings for workload cluster
     */
    settings: outputs.GetClusterSpecTkgServiceVsphereSettings;
    /**
     * Topology specific configuration
     */
    topology: outputs.GetClusterSpecTkgServiceVsphereTopology;
}

export interface GetClusterSpecTkgServiceVsphereDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Version of the cluster
     */
    version: string;
}

export interface GetClusterSpecTkgServiceVsphereSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.GetClusterSpecTkgServiceVsphereSettingsNetwork;
    /**
     * StorageSettings specifies storage-related settings for the cluster
     */
    storage?: outputs.GetClusterSpecTkgServiceVsphereSettingsStorage;
}

export interface GetClusterSpecTkgServiceVsphereSettingsNetwork {
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.GetClusterSpecTkgServiceVsphereSettingsNetworkPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.GetClusterSpecTkgServiceVsphereSettingsNetworkService[];
}

export interface GetClusterSpecTkgServiceVsphereSettingsNetworkPod {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface GetClusterSpecTkgServiceVsphereSettingsNetworkService {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface GetClusterSpecTkgServiceVsphereSettingsStorage {
    /**
     * Classes is a list of storage classes from the supervisor namespace to expose within a cluster. If omitted, all storage classes from the supervisor namespace will be exposed within the cluster.
     */
    classes?: string[];
    /**
     * DefaultClass is the valid storage class name which is treated as the default storage class within a cluster. If omitted, no default storage class is set.
     */
    defaultClass?: string;
}

export interface GetClusterSpecTkgServiceVsphereTopology {
    /**
     * Control plane specific configuration
     */
    controlPlane: outputs.GetClusterSpecTkgServiceVsphereTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.GetClusterSpecTkgServiceVsphereTopologyNodePool[];
}

export interface GetClusterSpecTkgServiceVsphereTopologyControlPlane {
    /**
     * Control plane instance type
     */
    class: string;
    /**
     * High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystems of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for control plane nodes
     */
    volumes?: outputs.GetClusterSpecTkgServiceVsphereTopologyControlPlaneVolume[];
}

export interface GetClusterSpecTkgServiceVsphereTopologyControlPlaneVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface GetClusterSpecTkgServiceVsphereTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.GetClusterSpecTkgServiceVsphereTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.GetClusterSpecTkgServiceVsphereTopologyNodePoolSpec;
}

export interface GetClusterSpecTkgServiceVsphereTopologyNodePoolInfo {
    /**
     * Description for the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name?: string;
}

export interface GetClusterSpecTkgServiceVsphereTopologyNodePoolSpec {
    /**
     * Cloud labels
     */
    cloudLabel?: {[key: string]: string};
    /**
     * Node labels
     */
    nodeLabel?: {[key: string]: string};
    /**
     * Nodepool config for tkg service vsphere
     */
    tkgServiceVsphere?: outputs.GetClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphere;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface GetClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphere {
    /**
     * Control plane instance type
     */
    class: string;
    /**
     * Configure the failure domain of node pool. The potential values could be found using cluster:options api.
     */
    failureDomain?: string;
    /**
     * Storage Class to be used for storage of the disks which store the root filesystems of the nodes
     */
    storageClass: string;
    /**
     * Configurable volumes for control plane nodes
     */
    volumes?: outputs.GetClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphereVolume[];
}

export interface GetClusterSpecTkgServiceVsphereTopologyNodePoolSpecTkgServiceVsphereVolume {
    /**
     * Volume capacity is in gib
     */
    capacity?: number;
    /**
     * It is the directory where the volume device is to be mounted
     */
    mountPath?: string;
    /**
     * It is the volume name
     */
    name?: string;
    /**
     * This is the storage class for PVC which in case omitted, default storage class will be used for the disks
     */
    pvcStorageClass?: string;
}

export interface GetClusterSpecTkgVsphere {
    /**
     * Advanced configuration for TKGm cluster
     */
    advancedConfigs?: outputs.GetClusterSpecTkgVsphereAdvancedConfig[];
    /**
     * VSphere specific distribution
     */
    distribution: outputs.GetClusterSpecTkgVsphereDistribution;
    /**
     * VSphere related settings for workload cluster
     */
    settings: outputs.GetClusterSpecTkgVsphereSettings;
    /**
     * Topology specific configuration
     */
    topology: outputs.GetClusterSpecTkgVsphereTopology;
}

export interface GetClusterSpecTkgVsphereAdvancedConfig {
    /**
     * The key of the advanced configuration parameters
     */
    key: string;
    /**
     * The value of the advanced configuration parameters
     */
    value: string;
}

export interface GetClusterSpecTkgVsphereDistribution {
    /**
     * Arch of the OS used for the cluster
     */
    osArch: string;
    /**
     * Name of the OS used for the cluster
     */
    osName: string;
    /**
     * Version of the OS used for the cluster
     */
    osVersion: string;
    /**
     * Version specifies the version of the Kubernetes cluster
     */
    version: string;
    /**
     * Workspace defines a workspace configuration for the vSphere cloud provider
     */
    workspace: outputs.GetClusterSpecTkgVsphereDistributionWorkspace;
}

export interface GetClusterSpecTkgVsphereDistributionWorkspace {
    datacenter: string;
    datastore: string;
    folder: string;
    resourcePool: string;
    workspaceNetwork: string;
}

export interface GetClusterSpecTkgVsphereSettings {
    /**
     * Network Settings specifies network-related settings for the cluster
     */
    network: outputs.GetClusterSpecTkgVsphereSettingsNetwork;
    /**
     * Security Settings specifies security-related settings for the cluster
     */
    security: outputs.GetClusterSpecTkgVsphereSettingsSecurity;
}

export interface GetClusterSpecTkgVsphereSettingsNetwork {
    /**
     * APIServerPort specifies the port address for the cluster that defaults to 6443.
     */
    apiServerPort?: number;
    /**
     * ControlPlaneEndpoint specifies the control plane virtual IP address. The value should be unique for every create request, else cluster creation shall fail. This field is not needed when AVI enabled while creating a legacy cluster on TKGm.
     */
    controlPlaneEndPoint?: string;
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16
     */
    pods: outputs.GetClusterSpecTkgVsphereSettingsNetworkPod[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12
     */
    services: outputs.GetClusterSpecTkgVsphereSettingsNetworkService[];
}

export interface GetClusterSpecTkgVsphereSettingsNetworkPod {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface GetClusterSpecTkgVsphereSettingsNetworkService {
    /**
     * CIDRBlocks specifies one or more ranges of IP addresses
     */
    cidrBlocks: string[];
}

export interface GetClusterSpecTkgVsphereSettingsSecurity {
    /**
     * SSH key for provisioning and accessing the cluster VMs
     */
    sshKey: string;
}

export interface GetClusterSpecTkgVsphereTopology {
    /**
     * VSphere specific control plane configuration for workload cluster object
     */
    controlPlane: outputs.GetClusterSpecTkgVsphereTopologyControlPlane;
    /**
     * Nodepool specific configuration
     */
    nodePools?: outputs.GetClusterSpecTkgVsphereTopologyNodePool[];
}

export interface GetClusterSpecTkgVsphereTopologyControlPlane {
    /**
     * High Availability or Non High Availability Cluster. HA cluster creates three controlplane machines, and non HA creates just one
     */
    highAvailability?: boolean;
    /**
     * VM specific configuration
     */
    vmConfig: outputs.GetClusterSpecTkgVsphereTopologyControlPlaneVmConfig;
}

export interface GetClusterSpecTkgVsphereTopologyControlPlaneVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface GetClusterSpecTkgVsphereTopologyNodePool {
    /**
     * Info is the meta information of nodepool for cluster
     */
    info: outputs.GetClusterSpecTkgVsphereTopologyNodePoolInfo;
    /**
     * Spec for the cluster nodepool
     */
    spec?: outputs.GetClusterSpecTkgVsphereTopologyNodePoolSpec;
}

export interface GetClusterSpecTkgVsphereTopologyNodePoolInfo {
    /**
     * Description of the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool
     */
    name: string;
}

export interface GetClusterSpecTkgVsphereTopologyNodePoolSpec {
    /**
     * Nodepool config for tkgm vsphere
     */
    tkgVsphere?: outputs.GetClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphere;
    /**
     * Count is the number of nodes
     */
    workerNodeCount?: string;
}

export interface GetClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphere {
    /**
     * VM specific configuration
     */
    vmConfig: outputs.GetClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphereVmConfig;
}

export interface GetClusterSpecTkgVsphereTopologyNodePoolSpecTkgVsphereVmConfig {
    /**
     * Number of CPUs per node
     */
    cpu?: string;
    /**
     * Root disk size in gigabytes for the VM
     */
    diskSize?: string;
    /**
     * Memory associated with the node in megabytes
     */
    memory?: string;
}

export interface GetCredentialMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetCredentialSpec {
    /**
     * The Tanzu capability for which the credential shall be used. Value must be in list [DATA_PROTECTION TANZU_OBSERVABILITY TANZU_SERVICE_MESH PROXY_CONFIG MANAGED_K8S_PROVIDER IMAGE_REGISTRY]
     */
    capability?: string;
    /**
     * Holds credentials sensitive data
     */
    data?: outputs.GetCredentialSpecData;
    /**
     * The Tanzu provider for which describes credential data type. Value must be in list [PROVIDER_UNSPECIFIED,AWS_EC2,GENERIC_S3,AZURE_AD,AWS_EKS,AZURE_AKS,GENERIC_KEY_VALUE]
     */
    provider?: string;
}

export interface GetCredentialSpecData {
    /**
     * AWS credential data type
     */
    awsCredential?: outputs.GetCredentialSpecDataAwsCredential;
    /**
     * Azure credential
     */
    azureCredential?: outputs.GetCredentialSpecDataAzureCredential;
    /**
     * Generic credential data type used to hold a blob of data represented as string
     */
    genericCredential?: string;
    /**
     * Key Value credential
     */
    keyValue?: outputs.GetCredentialSpecDataKeyValue;
}

export interface GetCredentialSpecDataAwsCredential {
    /**
     * Account ID of the AWS credential
     */
    accountId?: string;
    /**
     * Generic credential
     */
    genericCredential?: string;
    /**
     * AWS IAM role ARN and external ID
     */
    iamRole?: outputs.GetCredentialSpecDataAwsCredentialIamRole;
}

export interface GetCredentialSpecDataAwsCredentialIamRole {
    /**
     * AWS IAM role ARN
     */
    arn?: string;
    /**
     * An external ID used to assume an AWS IAM role
     */
    extId?: string;
}

export interface GetCredentialSpecDataAzureCredential {
    /**
     * Azure service principal
     */
    servicePrincipal?: outputs.GetCredentialSpecDataAzureCredentialServicePrincipal;
    /**
     * Azure service principal
     */
    servicePrincipalWithCertificate?: outputs.GetCredentialSpecDataAzureCredentialServicePrincipalWithCertificate;
}

export interface GetCredentialSpecDataAzureCredentialServicePrincipal {
    /**
     * Azure Cloud name
     */
    azureCloudName?: string;
    /**
     * Client ID of the Service Principal
     */
    clientId: string;
    /**
     * Client Secret of the Service Principal
     */
    clientSecret?: string;
    /**
     * Resource Group name
     */
    resourceGroup: string;
    /**
     * Subscription ID of the Azure credential
     */
    subscriptionId: string;
    /**
     * Tenant ID of the Azure credential
     */
    tenantId: string;
}

export interface GetCredentialSpecDataAzureCredentialServicePrincipalWithCertificate {
    /**
     * Azure Cloud name
     */
    azureCloudName?: string;
    /**
     * Client certificate of the Service Principal
     */
    clientCertificate: string;
    /**
     * Client ID of the Service Principal
     */
    clientId: string;
    /**
     * IDs of the Azure Subscriptions that the Service Principal can manage
     */
    managedSubscriptions?: string[];
    /**
     * Subscription ID of the Azure credential
     */
    subscriptionId: string;
    /**
     * Tenant ID of the Azure credential
     */
    tenantId: string;
}

export interface GetCredentialSpecDataKeyValue {
    /**
     * Data secret data in the format of key-value pair
     */
    data?: {[key: string]: string};
    /**
     * Type of Secret data, usually mapped to k8s secret type. Supported types: [SECRET_TYPE_UNSPECIFIED,OPAQUE_SECRET_TYPE,DOCKERCONFIGJSON_SECRET_TYPE]
     */
    type?: string;
}

export interface GetEksclusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetEksclusterSpec {
    /**
     * Name of the cluster group to which this cluster belongs
     */
    clusterGroup?: string;
    /**
     * EKS config for the cluster control plane
     */
    config: outputs.GetEksclusterSpecConfig;
    /**
     * Nodepool definitions for the cluster
     */
    nodepools: outputs.GetEksclusterSpecNodepool[];
    /**
     * Optional proxy name is the name of the Proxy Config to be used for the cluster
     */
    proxy?: string;
}

export interface GetEksclusterSpecConfig {
    /**
     * Addons config contains the configuration for all the addons of the cluster, which support customization of addon configuration
     */
    addonsConfig?: outputs.GetEksclusterSpecConfigAddonsConfig;
    /**
     * Kubernetes Network Config
     */
    kubernetesNetworkConfig?: outputs.GetEksclusterSpecConfigKubernetesNetworkConfig;
    /**
     * Kubernetes version of the cluster
     */
    kubernetesVersion: string;
    /**
     * EKS logging configuration
     */
    logging?: outputs.GetEksclusterSpecConfigLogging;
    /**
     * ARN of the IAM role that provides permissions for the Kubernetes control plane to make calls to AWS API operations
     */
    roleArn: string;
    /**
     * The metadata to apply to the cluster to assist with categorization and organization
     */
    tags: {[key: string]: string};
    /**
     * VPC config
     */
    vpc: outputs.GetEksclusterSpecConfigVpc;
}

export interface GetEksclusterSpecConfigAddonsConfig {
    /**
     * VPC CNI addon config contains the configuration for the VPC CNI addon of the cluster
     */
    vpcCniConfig?: outputs.GetEksclusterSpecConfigAddonsConfigVpcCniConfig;
}

export interface GetEksclusterSpecConfigAddonsConfigVpcCniConfig {
    /**
     * ENI config for the VPC CNI addon
     */
    eniConfigs?: outputs.GetEksclusterSpecConfigAddonsConfigVpcCniConfigEniConfig[];
}

export interface GetEksclusterSpecConfigAddonsConfigVpcCniConfigEniConfig {
    /**
     * Subnet id for the ENI
     */
    id: string;
    /**
     * Security groups for the ENI
     */
    securityGroups?: string[];
}

export interface GetEksclusterSpecConfigKubernetesNetworkConfig {
    /**
     * Service CIDR for Kubernetes services
     */
    serviceCidr: string;
}

export interface GetEksclusterSpecConfigLogging {
    /**
     * Enable API server logs
     */
    apiServer?: boolean;
    /**
     * Enable audit logs
     */
    audit?: boolean;
    /**
     * Enable authenticator logs
     */
    authenticator?: boolean;
    /**
     * Enable controller manager logs
     */
    controllerManager?: boolean;
    /**
     * Enable scheduler logs
     */
    scheduler?: boolean;
}

export interface GetEksclusterSpecConfigVpc {
    /**
     * Enable Kubernetes API requests within your cluster's VPC (such as node to control plane communication) use the private VPC endpoint (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    enablePrivateAccess?: boolean;
    /**
     * Enable cluster API server access from the internet. You can, optionally, limit the CIDR blocks that can access the public endpoint using public_access_cidrs (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    enablePublicAccess?: boolean;
    /**
     * Specify which addresses from the internet can communicate to the public endpoint, if public endpoint is enabled (see [Amazon EKS cluster endpoint access control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html))
     */
    publicAccessCidrs?: string[];
    /**
     * Security groups for the cluster VMs
     */
    securityGroups?: string[];
    /**
     * Subnet ids used by the cluster (see [Amazon EKS VPC and subnet requirements and considerations](https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html#network-requirements-subnets))
     */
    subnetIds: string[];
}

export interface GetEksclusterSpecNodepool {
    /**
     * Info for the nodepool
     */
    info: outputs.GetEksclusterSpecNodepoolInfo;
    /**
     * Spec for the cluster
     */
    spec: outputs.GetEksclusterSpecNodepoolSpec;
}

export interface GetEksclusterSpecNodepoolInfo {
    /**
     * Description for the nodepool
     */
    description?: string;
    /**
     * Name of the nodepool, immutable
     */
    name: string;
}

export interface GetEksclusterSpecNodepoolSpec {
    /**
     * AMI info for the nodepool if AMI type is specified as CUSTOM
     */
    amiInfo?: outputs.GetEksclusterSpecNodepoolSpecAmiInfo;
    /**
     * AMI type, immutable
     */
    amiType: string;
    /**
     * Capacity Type
     */
    capacityType: string;
    /**
     * Nodepool instance types, immutable
     */
    instanceTypes: string[];
    /**
     * Launch template for the nodepool
     */
    launchTemplate?: outputs.GetEksclusterSpecNodepoolSpecLaunchTemplate;
    /**
     * Kubernetes node labels
     */
    nodeLabels?: {[key: string]: string};
    /**
     * AMI release version
     */
    releaseVersion: string;
    /**
     * Remote access to worker nodes, immutable
     */
    remoteAccess?: outputs.GetEksclusterSpecNodepoolSpecRemoteAccess;
    /**
     * ARN of the IAM role that provides permissions for the Kubernetes nodepool to make calls to AWS API operations, immutable
     */
    roleArn: string;
    /**
     * Root disk size in GiB, immutable
     */
    rootDiskSize: number;
    /**
     * Nodepool scaling config
     */
    scalingConfig?: outputs.GetEksclusterSpecNodepoolSpecScalingConfig;
    /**
     * Subnets required for the nodepool
     */
    subnetIds: string[];
    /**
     * EKS specific tags
     */
    tags?: {[key: string]: string};
    /**
     * If specified, the node's taints
     */
    taints?: outputs.GetEksclusterSpecNodepoolSpecTaint[];
    /**
     * Update config for the nodepool
     */
    updateConfig?: outputs.GetEksclusterSpecNodepoolSpecUpdateConfig;
}

export interface GetEksclusterSpecNodepoolSpecAmiInfo {
    /**
     * ID of the AMI to be used
     */
    amiId?: string;
    /**
     * Override bootstrap command for the custom AMI
     */
    overrideBootstrapCmd?: string;
}

export interface GetEksclusterSpecNodepoolSpecLaunchTemplate {
    /**
     * The ID of the launch template
     */
    id?: string;
    /**
     * The name of the launch template
     */
    name?: string;
    /**
     * The version of the launch template to use
     */
    version?: string;
}

export interface GetEksclusterSpecNodepoolSpecRemoteAccess {
    /**
     * Security groups for the VMs
     */
    securityGroups?: string[];
    /**
     * SSH key allows you to connect to your instances and gather diagnostic information if there are issues.
     */
    sshKey?: string;
}

export interface GetEksclusterSpecNodepoolSpecScalingConfig {
    /**
     * Desired size of nodepool
     */
    desiredSize?: number;
    /**
     * Maximum size of nodepool
     */
    maxSize?: number;
    /**
     * Minimum size of nodepool
     */
    minSize?: number;
}

export interface GetEksclusterSpecNodepoolSpecTaint {
    /**
     * Current effect state of the node pool
     */
    effect?: string;
    /**
     * The taint key to be applied to a node
     */
    key?: string;
    /**
     * The taint value corresponding to the taint key
     */
    value?: string;
}

export interface GetEksclusterSpecNodepoolSpecUpdateConfig {
    /**
     * Maximum number of nodes unavailable at once during a version update
     */
    maxUnavailableNodes?: string;
    /**
     * Maximum percentage of nodes unavailable during a version update
     */
    maxUnavailablePercentage?: string;
}

export interface GetGitRepositoryMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetGitRepositoryScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetGitRepositoryScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.GetGitRepositoryScopeClusterGroup;
}

export interface GetGitRepositoryScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetGitRepositoryScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface GetGitRepositorySpec {
    gitImplementation: string;
    interval: string;
    reves: outputs.GetGitRepositorySpecRef[];
    secretRef: string;
    url: string;
}

export interface GetGitRepositorySpecRef {
    branch: string;
    commit: string;
    semver: string;
    tag: string;
}

export interface GetHelmChartsChart {
    chartMetadataName: string;
    name: string;
    specs: outputs.GetHelmChartsChartSpec[];
}

export interface GetHelmChartsChartSpec {
    apiVersion: string;
    appVersion: string;
    dependencies: outputs.GetHelmChartsChartSpecDependency[];
    deprecated: boolean;
    kubeVersion: string;
    releasedAt: string;
    sources: string[];
    urls: string[];
    valuesConfig: string;
}

export interface GetHelmChartsChartSpecDependency {
    alias: string;
    chartName: string;
    chartVersion: boolean;
    condition: string;
    importValues: string[];
    repositories: string[];
    tags: string[];
}

export interface GetHelmFeatureMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetHelmFeatureScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetHelmFeatureScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.GetHelmFeatureScopeClusterGroup;
}

export interface GetHelmFeatureScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetHelmFeatureScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface GetHelmRepositoryMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetHelmRepositoryScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetHelmRepositoryScopeCluster;
}

export interface GetHelmRepositoryScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetHelmRepositorySpec {
    url: string;
}

export interface GetInspectionsInspection {
    clusterName: string;
    managementClusterName: string;
    name: string;
    provisionerName: string;
    status: {[key: string]: string};
}

export interface GetIntegrationMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetIntegrationSpec {
    /**
     * Integration specific configurations in JSON format
     */
    configurations?: string;
}

export interface GetKubernetesSecretMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetKubernetesSecretScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetKubernetesSecretScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.GetKubernetesSecretScopeClusterGroup;
}

export interface GetKubernetesSecretScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetKubernetesSecretScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface GetKubernetesSecretSpec {
    dockerConfigJsons: outputs.GetKubernetesSecretSpecDockerConfigJson[];
    opaque: {[key: string]: string};
}

export interface GetKubernetesSecretSpecDockerConfigJson {
    imageRegistryUrl: string;
    password: string;
    username: string;
}

export interface GetManagementClusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetManagementClusterRegisterManagementCluster {
    /**
     * Register management cluster description for only TKGm
     */
    tkgmDescription?: string;
    /**
     * Register management cluster KUBECONFIG path for only TKGm
     */
    tkgmKubeconfigFile?: string;
    /**
     * Register management cluster KUBECONFIG for only TKGm
     */
    tkgmKubeconfigRaw?: string;
}

export interface GetManagementClusterSpec {
    /**
     * Cluster group name to be used by default for workload clusters
     */
    clusterGroup: string;
    /**
     * Image registry which is only allowed for TKGm
     */
    imageRegistry?: string;
    /**
     * Kubernetes provider type
     */
    kubernetesProviderType: string;
    /**
     * Managed workload cluster image registry
     */
    managedWorkloadClusterImageRegistry?: string;
    /**
     * Managed workload cluster proxy name
     */
    managedWorkloadClusterProxyName?: string;
    /**
     * Management cluster proxy name
     */
    managementProxyName?: string;
}

export interface GetNamespaceMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetNamespaceSpec {
    attach?: boolean;
    workspaceName?: string;
}

export interface GetPackageInstallMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetPackageInstallScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetPackageInstallScopeCluster;
}

export interface GetPackageInstallScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetPackageInstallSpec {
    inlineValues: {[key: string]: string};
    packageReves: outputs.GetPackageInstallSpecPackageRef[];
    roleBindingScope: string;
}

export interface GetPackageInstallSpecPackageRef {
    packageMetadataName: string;
    versionSelections: outputs.GetPackageInstallSpecPackageRefVersionSelection[];
}

export interface GetPackageInstallSpecPackageRefVersionSelection {
    constraints: string;
}

export interface GetPackageInstallStatus {
    generatedResources: outputs.GetPackageInstallStatusGeneratedResource[];
    managed: boolean;
    packageInstallPhase: string;
    referredBies: string[];
    resolvedVersion: string;
}

export interface GetPackageInstallStatusGeneratedResource {
    clusterRoleName: string;
    roleBindingName: string;
    serviceAccountName: string;
}

export interface GetPackageMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetPackageRepositoryMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetPackageRepositoryScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetPackageRepositoryScopeCluster;
}

export interface GetPackageRepositoryScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetPackageRepositorySpec {
    imgpkgBundles: outputs.GetPackageRepositorySpecImgpkgBundle[];
}

export interface GetPackageRepositorySpecImgpkgBundle {
    image: string;
}

export interface GetPackageRepositoryState {
    disabled: boolean;
    managed: boolean;
    packageRepositoryPhase: string;
    subscribed: boolean;
}

export interface GetPackageScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetPackageScopeCluster;
}

export interface GetPackageScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetPackageSpec {
    capacityRequirementsDescription: string;
    licenses: string[];
    releaseNotes: outputs.GetPackageSpecReleaseNote[];
    releasedAt: string;
    repositoryName: string;
    valuesSchemas: outputs.GetPackageSpecValuesSchema[];
}

export interface GetPackageSpecReleaseNote {
    metadataName: string;
    url: string;
    version: string;
}

export interface GetPackageSpecValuesSchema {
    templates: outputs.GetPackageSpecValuesSchemaTemplate[];
}

export interface GetPackageSpecValuesSchemaTemplate {
    raws: outputs.GetPackageSpecValuesSchemaTemplateRaw[];
}

export interface GetPackageSpecValuesSchemaTemplateRaw {
    examples: outputs.GetPackageSpecValuesSchemaTemplateRawExample[];
    properties: outputs.GetPackageSpecValuesSchemaTemplateRawProperty[];
    title: string;
}

export interface GetPackageSpecValuesSchemaTemplateRawExample {
    namespace: string;
}

export interface GetPackageSpecValuesSchemaTemplateRawProperty {
    namespaces: outputs.GetPackageSpecValuesSchemaTemplateRawPropertyNamespace[];
}

export interface GetPackageSpecValuesSchemaTemplateRawPropertyNamespace {
    default: string;
    description: string;
    type: string;
}

export interface GetPackagesPackage {
    name: string;
    specs: outputs.GetPackagesPackageSpec[];
}

export interface GetPackagesPackageSpec {
    capacityRequirementsDescription: string;
    licenses: string[];
    releaseNotes: outputs.GetPackagesPackageSpecReleaseNote[];
    releasedAt: string;
    repositoryName: string;
    valuesSchemas: outputs.GetPackagesPackageSpecValuesSchema[];
}

export interface GetPackagesPackageSpecReleaseNote {
    metadataName: string;
    url: string;
    version: string;
}

export interface GetPackagesPackageSpecValuesSchema {
    templates: outputs.GetPackagesPackageSpecValuesSchemaTemplate[];
}

export interface GetPackagesPackageSpecValuesSchemaTemplate {
    raws: outputs.GetPackagesPackageSpecValuesSchemaTemplateRaw[];
}

export interface GetPackagesPackageSpecValuesSchemaTemplateRaw {
    examples: outputs.GetPackagesPackageSpecValuesSchemaTemplateRawExample[];
    properties: outputs.GetPackagesPackageSpecValuesSchemaTemplateRawProperty[];
    title: string;
}

export interface GetPackagesPackageSpecValuesSchemaTemplateRawExample {
    namespace: string;
}

export interface GetPackagesPackageSpecValuesSchemaTemplateRawProperty {
    namespaces: outputs.GetPackagesPackageSpecValuesSchemaTemplateRawPropertyNamespace[];
}

export interface GetPackagesPackageSpecValuesSchemaTemplateRawPropertyNamespace {
    default: string;
    description: string;
    type: string;
}

export interface GetPackagesScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetPackagesScopeCluster;
}

export interface GetPackagesScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetProvisionerProvisioner {
    /**
     * Name of the management cluster
     */
    managementCluster: string;
    /**
     * Metadata for the resource
     */
    meta?: outputs.GetProvisionerProvisionerMeta;
    /**
     * Name of the provisioner
     */
    name?: string;
    /**
     * ID of the organization
     */
    orgId?: string;
}

export interface GetProvisionerProvisionerMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetRepositoryCredentialMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GetRepositoryCredentialScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GetRepositoryCredentialScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.GetRepositoryCredentialScopeClusterGroup;
}

export interface GetRepositoryCredentialScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GetRepositoryCredentialScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface GetRepositoryCredentialSpec {
    datas: outputs.GetRepositoryCredentialSpecData[];
}

export interface GetRepositoryCredentialSpecData {
    sshKeys: outputs.GetRepositoryCredentialSpecDataSshKey[];
    usernamePasswords: outputs.GetRepositoryCredentialSpecDataUsernamePassword[];
}

export interface GetRepositoryCredentialSpecDataSshKey {
    identity: string;
    knownHosts: string;
}

export interface GetRepositoryCredentialSpecDataUsernamePassword {
    password: string;
    username: string;
}

export interface GetTargetLocationScope {
    cluster?: outputs.GetTargetLocationScopeCluster;
    provider?: outputs.GetTargetLocationScopeProvider;
}

export interface GetTargetLocationScopeCluster {
    /**
     * Cluster name
     */
    clusterName: string;
    /**
     * Management cluster name
     */
    managementClusterName?: string;
    /**
     * The name of the target location
     */
    name?: string;
    /**
     * Cluster provisioner name
     */
    provisionerName?: string;
}

export interface GetTargetLocationScopeProvider {
    /**
     * A cluster or cluster group assigned for the target location.
     */
    assignedGroupName?: string;
    /**
     * The name of the credentials used for the target location.
     */
    credentialName?: string;
    /**
     * The name of the target location.
     */
    name?: string;
}

export interface GetTargetLocationTargetLocation {
    metas: outputs.GetTargetLocationTargetLocationMeta[];
    name: string;
    specs: outputs.GetTargetLocationTargetLocationSpec[];
}

export interface GetTargetLocationTargetLocationMeta {
    annotations: {[key: string]: string};
    description: string;
    labels: {[key: string]: string};
    resourceVersion: string;
    uid: string;
}

export interface GetTargetLocationTargetLocationSpec {
    assignedGroups: outputs.GetTargetLocationTargetLocationSpecAssignedGroup[];
    bucket: string;
    caCert: string;
    configs: outputs.GetTargetLocationTargetLocationSpecConfig[];
    credential: {[key: string]: string};
    region: string;
    sysBucketKey: string;
    sysRegionKey: string;
    targetProvider: string;
}

export interface GetTargetLocationTargetLocationSpecAssignedGroup {
    clusterGroups: string[];
    clusters: outputs.GetTargetLocationTargetLocationSpecAssignedGroupCluster[];
}

export interface GetTargetLocationTargetLocationSpecAssignedGroupCluster {
    managementClusterName: string;
    name: string;
    provisionerName: string;
}

export interface GetTargetLocationTargetLocationSpecConfig {
    aws: outputs.GetTargetLocationTargetLocationSpecConfigAw[];
    azures: outputs.GetTargetLocationTargetLocationSpecConfigAzure[];
}

export interface GetTargetLocationTargetLocationSpecConfigAw {
    s3BucketUrl: string;
    s3ForcePathStyle: boolean;
    s3PublicUrl: string;
}

export interface GetTargetLocationTargetLocationSpecConfigAzure {
    resourceGroup: string;
    storageAccount: string;
    subscriptionId: string;
}

export interface GetWorkspaceMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GitRepositoryMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface GitRepositoryScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.GitRepositoryScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.GitRepositoryScopeClusterGroup;
}

export interface GitRepositoryScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface GitRepositoryScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface GitRepositorySpec {
    /**
     * GitImplementation specifies which client library implementation to use. go-git is the default git implementation.
     */
    gitImplementation?: string;
    /**
     * Interval at which to check gitrepository for updates. This is the interval at which Tanzu Mission Control will attempt to reconcile changes in the repository to the cluster. A sync interval of 0 would result in no future syncs. If no value is entered, a default interval of 5 minutes will be applied as `5m`.
     */
    interval?: string;
    /**
     * Reference specifies git reference to resolve.
     */
    ref?: outputs.GitRepositorySpecRef;
    /**
     * Reference to the secret. Repository credential.
     */
    secretRef?: string;
    /**
     * URL of the git repository. Repository URL should begin with http, https, or ssh
     */
    url: string;
}

export interface GitRepositorySpecRef {
    /**
     * Branch from git to checkout. When branch is given, then that branch from the git repository will be checked out. If the given branch doesnt exist in the git repository, then adding the git repository will fail. If no branch is given, the `master` branch will be used.
     */
    branch?: string;
    /**
     * Commit SHA to checkout. Takes precedence over all other reference fields. When git_implementation is `GO_GIT`, this can be combined with branch to shallow clone branch in which the commit is expected to exist.
     */
    commit?: string;
    /**
     * SemVer expression to checkout from git tags. Takes precedence over tag. When semver is given, then the latest tag matching that semver will be checked out from the git repository. If no tag in the git repository matches semver, then adding the git repository will fail. If semver is given, tag and branch will be ignored if they are populated.
     */
    semver?: string;
    /**
     * Tag from git to checkout. Takes precedence over branch. When a tag is given, that tag from the git repository will be checked out. If the given tag doesnt exist in the git repository, then adding the git repository will fail. If both tag and branch are given, tag overrides branch and the branch value will be ignored.
     */
    tag?: string;
}

export interface HelmFeatureMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface HelmFeatureScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.HelmFeatureScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.HelmFeatureScopeClusterGroup;
}

export interface HelmFeatureScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface HelmFeatureScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface HelmReleaseMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface HelmReleaseScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.HelmReleaseScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.HelmReleaseScopeClusterGroup;
}

export interface HelmReleaseScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface HelmReleaseScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface HelmReleaseSpec {
    /**
     * Reference to the chart which will be installed.
     */
    chartRef: outputs.HelmReleaseSpecChartRef;
    /**
     * File to read inline values from (in yaml format).User need to specify the file path for inline config
     */
    inlineConfig?: string;
    /**
     * Interval at which to reconcile the Helm release. This is the interval at which Tanzu Mission Control will attempt to reconcile changes in the helm release to the cluster. A sync interval of 0 would result in no future syncs. If no value is entered, a default interval of 5 minutes will be applied as `5m`.
     */
    interval?: string;
    /**
     * TargetNamespace sets or overrides the namespaces of resources yaml while applying on cluster.
     */
    targetNamespace?: string;
}

export interface HelmReleaseSpecChartRef {
    /**
     * Git repository type spec.
     */
    gitRepository?: outputs.HelmReleaseSpecChartRefGitRepository;
    /**
     * Helm repository type Spec.
     */
    helmRepository?: outputs.HelmReleaseSpecChartRefHelmRepository;
}

export interface HelmReleaseSpecChartRefGitRepository {
    /**
     * Path of the chart in the git repository.
     */
    chartPath: string;
    /**
     * Name of the Git repository.
     */
    repositoryName: string;
    /**
     * Namespace Name for the Git repository.
     */
    repositoryNamespace: string;
}

export interface HelmReleaseSpecChartRefHelmRepository {
    /**
     * Name of the chart in the helm repository.
     */
    chartName: string;
    /**
     * Name of the Helm repository.
     */
    repositoryName: string;
    /**
     * Namespace Name for the Helm repository.
     */
    repositoryNamespace: string;
    /**
     * Chart version, applicable for helm repository type.
     */
    version: string;
}

export interface HelmReleaseStatus {
    generatedResources: outputs.HelmReleaseStatusGeneratedResource[];
    phase: string;
}

export interface HelmReleaseStatusGeneratedResource {
    clusterRoleName: string;
    roleBindingName: string;
    serviceAccountName: string;
}

export interface IamPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface IamPolicyRoleBinding {
    /**
     * Role for this rolebinding: max length for a role is 126 characters.
     */
    role: string;
    /**
     * Subject for this rolebinding.
     */
    subjects: outputs.IamPolicyRoleBindingSubject[];
}

export interface IamPolicyRoleBindingSubject {
    /**
     * Subject type, having one of the subject types: USER or GROUP or K8S_SERVICEACCOUNT
     */
    kind: string;
    /**
     * Subject name: allow max characters for email - 320 characters.
     */
    name: string;
}

export interface IamPolicyScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.IamPolicyScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.IamPolicyScopeClusterGroup;
    /**
     * The schema for namespace iam policy full name
     */
    namespace?: outputs.IamPolicyScopeNamespace;
    /**
     * The schema for organization iam policy full name
     */
    organization?: outputs.IamPolicyScopeOrganization;
    /**
     * The schema for workspace iam policy full name
     */
    workspace?: outputs.IamPolicyScopeWorkspace;
}

export interface IamPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface IamPolicyScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface IamPolicyScopeNamespace {
    /**
     * Name of Cluster
     */
    clusterName: string;
    /**
     * Name of ManagementCluster
     */
    managementClusterName?: string;
    /**
     * Name of the Namespace
     */
    name: string;
    /**
     * Name of Provisioner
     */
    provisionerName?: string;
}

export interface IamPolicyScopeOrganization {
    /**
     * ID of the Organization
     */
    orgId: string;
}

export interface IamPolicyScopeWorkspace {
    /**
     * Name of the workspace
     */
    name: string;
}

export interface ImagePolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface ImagePolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.ImagePolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.ImagePolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.ImagePolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.ImagePolicyScopeWorkspace;
}

export interface ImagePolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface ImagePolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface ImagePolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface ImagePolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface ImagePolicySpec {
    /**
     * Input for the image policy, having one of the valid recipes: allowed-name-tag, custom, block-latest-tag or require-digest.
     */
    input: outputs.ImagePolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.ImagePolicySpecNamespaceSelector;
}

export interface ImagePolicySpecInput {
    /**
     * The input schema for image policy allowed-name-tag recipe version v1
     */
    allowedNameTag?: outputs.ImagePolicySpecInputAllowedNameTag;
    /**
     * The input schema for image policy block-latest-tag recipe version v1
     */
    blockLatestTag?: outputs.ImagePolicySpecInputBlockLatestTag;
    /**
     * The input schema for image policy custom recipe version v1
     */
    custom?: outputs.ImagePolicySpecInputCustom;
    /**
     * The input schema for image policy require-digest recipe version v1
     */
    requireDigest?: outputs.ImagePolicySpecInputRequireDigest;
}

export interface ImagePolicySpecInputAllowedNameTag {
    /**
     * Audit (dry-run). Violations will be logged but not denied.
     */
    audit?: boolean;
    /**
     * It specifies a list of rules that defines allowed image patterns.
     */
    rules: outputs.ImagePolicySpecInputAllowedNameTagRule[];
}

export interface ImagePolicySpecInputAllowedNameTagRule {
    /**
     * Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
     */
    imagename?: string;
    /**
     * Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
     */
    tag?: outputs.ImagePolicySpecInputAllowedNameTagRuleTag;
}

export interface ImagePolicySpecInputAllowedNameTagRuleTag {
    /**
     * The negate flag used to exclude certain tag patterns.
     */
    negate?: boolean;
    /**
     * The value (support wildcard) is used to validate against the tag of the image.
     */
    value?: string;
}

export interface ImagePolicySpecInputBlockLatestTag {
    /**
     * Audit (dry-run). Violations will be logged but not denied.
     */
    audit?: boolean;
}

export interface ImagePolicySpecInputCustom {
    /**
     * Audit (dry-run). Violations will be logged but not denied.
     */
    audit?: boolean;
    /**
     * It specifies a list of rules that defines allowed image patterns.
     */
    rules: outputs.ImagePolicySpecInputCustomRule[];
}

export interface ImagePolicySpecInputCustomRule {
    /**
     * Allowed image hostnames, wildcards are supported(for example: *.mycompany.com). Empty field is equivalent to *.
     */
    hostname?: string;
    /**
     * Allowed image names, wildcards are supported(for example: fooservice/*). Empty field is equivalent to *.
     */
    imagename?: string;
    /**
     * Allowed port(if presented) of the image hostname, must associate with valid hostname. Wildcards are supported.
     */
    port?: string;
    /**
     * The flag used to enforce digest to appear in container images.
     */
    requiredigest?: boolean;
    /**
     * Allowed image tag, wildcards are supported (for example: v1.*). No validation is performed on tag if the field is empty.
     */
    tag?: outputs.ImagePolicySpecInputCustomRuleTag;
}

export interface ImagePolicySpecInputCustomRuleTag {
    /**
     * The negate flag used to exclude certain tag patterns.
     */
    negate?: boolean;
    /**
     * The value (support wildcard) is used to validate against the tag of the image.
     */
    value?: string;
}

export interface ImagePolicySpecInputRequireDigest {
    /**
     * Audit (dry-run). Violations will be logged but not denied.
     */
    audit?: boolean;
}

export interface ImagePolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.ImagePolicySpecNamespaceSelectorMatchExpression[];
}

export interface ImagePolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface IntegrationMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface IntegrationSpec {
    /**
     * Integration specific configurations in JSON format
     */
    configurations?: string;
}

export interface KubernetesSecretMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface KubernetesSecretScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.KubernetesSecretScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.KubernetesSecretScopeClusterGroup;
}

export interface KubernetesSecretScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface KubernetesSecretScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface KubernetesSecretSpec {
    /**
     * SecretType definition - SECRET_TYPE_DOCKERCONFIGJSON, Kubernetes secrets type.
     */
    dockerConfigJsons?: outputs.KubernetesSecretSpecDockerConfigJson[];
    /**
     * SecretType definition - SECRET_TYPE_OPAQUE, Kubernetes secrets type.
     */
    opaque?: {[key: string]: string};
}

export interface KubernetesSecretSpecDockerConfigJson {
    /**
     * SecretType definition - Server URL of the registry.
     */
    imageRegistryUrl: string;
    /**
     * SecretType definition - Password of the registry.
     */
    password: string;
    /**
     * SecretType definition - Username of the registry.
     */
    username: string;
}

export interface KustomizationMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface KustomizationScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.KustomizationScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.KustomizationScopeClusterGroup;
}

export interface KustomizationScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface KustomizationScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface KustomizationSpec {
    /**
     * Interval defines the interval at which to reconcile kustomization.
     */
    interval?: string;
    /**
     * Path within the source from which configurations will be applied. The path must exactly match what is in the repository.
     */
    path: string;
    /**
     * If true, the workloads will be deleted when the kustomization CR is deleted. When prune is enabled, removing the kustomization will trigger a removal of all kubernetes objects previously applied on all clusters of this cluster group by this kustomization.
     */
    prune?: boolean;
    /**
     * Reference to the source from which the configurations will be applied. Please select an existing repository.
     */
    source: outputs.KustomizationSpecSource;
    /**
     * TargetNamespace sets or overrides the namespaces of resources/kustomization yaml while applying on cluster. Namespace specified here must exist on cluster. It won't be created as a result of specifying here. Enter the name of the namespace you want the kustomization to be synced to. Entering a target namespace removes the need to specify a namespace in your kustomization. If the namespace does not exist in the cluster, syncing the kustomization will fail.
     */
    targetNamespace?: string;
}

export interface KustomizationSpecSource {
    /**
     * Name of the repository.
     */
    name: string;
    /**
     * Namespace of the repository.
     */
    namespace: string;
}

export interface ManagementClusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface ManagementClusterRegisterManagementCluster {
    /**
     * Register management cluster description for only TKGm
     */
    tkgmDescription?: string;
    /**
     * Register management cluster KUBECONFIG path for only TKGm
     */
    tkgmKubeconfigFile?: string;
    /**
     * Register management cluster KUBECONFIG for only TKGm
     */
    tkgmKubeconfigRaw?: string;
}

export interface ManagementClusterSpec {
    /**
     * Cluster group name to be used by default for workload clusters
     */
    clusterGroup: string;
    /**
     * Image registry which is only allowed for TKGm
     */
    imageRegistry?: string;
    /**
     * Kubernetes provider type
     */
    kubernetesProviderType: string;
    /**
     * Managed workload cluster image registry
     */
    managedWorkloadClusterImageRegistry?: string;
    /**
     * Managed workload cluster proxy name
     */
    managedWorkloadClusterProxyName?: string;
    /**
     * Management cluster proxy name
     */
    managementProxyName?: string;
}

export interface MutationPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface MutationPolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.MutationPolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.MutationPolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.MutationPolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.MutationPolicyScopeWorkspace;
}

export interface MutationPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface MutationPolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface MutationPolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface MutationPolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface MutationPolicySpec {
    /**
     * Input for the mutation policy.
     */
    input: outputs.MutationPolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.MutationPolicySpecNamespaceSelector;
}

export interface MutationPolicySpecInput {
    /**
     * The input schema for custom policy tmc_block_nodeport_service recipe version v1
     */
    annotation?: outputs.MutationPolicySpecInputAnnotation;
    /**
     * The input schema for custom policy tmc_block_nodeport_service recipe version v1
     */
    label?: outputs.MutationPolicySpecInputLabel;
    /**
     * The pod security schema
     */
    podSecurity?: outputs.MutationPolicySpecInputPodSecurity;
}

export interface MutationPolicySpecInputAnnotation {
    annotation?: outputs.MutationPolicySpecInputAnnotationAnnotation;
    /**
     * Scope
     */
    scope?: string;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.MutationPolicySpecInputAnnotationTargetKubernetesResource[];
}

export interface MutationPolicySpecInputAnnotationAnnotation {
    key: string;
    value: string;
}

export interface MutationPolicySpecInputAnnotationTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface MutationPolicySpecInputLabel {
    label?: outputs.MutationPolicySpecInputLabelLabel;
    /**
     * Scope
     */
    scope?: string;
    /**
     * A list of kubernetes api resources on which the policy will be enforced, identified using apiGroups and kinds.
     */
    targetKubernetesResources: outputs.MutationPolicySpecInputLabelTargetKubernetesResource[];
}

export interface MutationPolicySpecInputLabelLabel {
    key: string;
    value: string;
}

export interface MutationPolicySpecInputLabelTargetKubernetesResource {
    /**
     * APIGroup is a group containing the resource type.
     */
    apiGroups: string[];
    /**
     * Kind is the name of the object schema (resource type).
     */
    kinds: string[];
}

export interface MutationPolicySpecInputPodSecurity {
    allowPrivilegeEscalation?: outputs.MutationPolicySpecInputPodSecurityAllowPrivilegeEscalation;
    /**
     * Run as user
     */
    capabilitiesAdd?: outputs.MutationPolicySpecInputPodSecurityCapabilitiesAdd;
    /**
     * Run as user
     */
    capabilitiesDrop?: outputs.MutationPolicySpecInputPodSecurityCapabilitiesDrop;
    fsGroup?: outputs.MutationPolicySpecInputPodSecurityFsGroup;
    privileged?: outputs.MutationPolicySpecInputPodSecurityPrivileged;
    readOnlyRootFilesystem?: outputs.MutationPolicySpecInputPodSecurityReadOnlyRootFilesystem;
    runAsGroup?: outputs.MutationPolicySpecInputPodSecurityRunAsGroup;
    runAsNonRoot?: outputs.MutationPolicySpecInputPodSecurityRunAsNonRoot;
    runAsUser?: outputs.MutationPolicySpecInputPodSecurityRunAsUser;
    /**
     * Allowed selinux options
     */
    seLinuxOptions?: outputs.MutationPolicySpecInputPodSecuritySeLinuxOption[];
    supplementalGroups?: outputs.MutationPolicySpecInputPodSecuritySupplementalGroups;
}

export interface MutationPolicySpecInputPodSecurityAllowPrivilegeEscalation {
    condition: string;
    value: boolean;
}

export interface MutationPolicySpecInputPodSecurityCapabilitiesAdd {
    /**
     * Rule
     */
    operation?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface MutationPolicySpecInputPodSecurityCapabilitiesDrop {
    /**
     * Rule
     */
    operation?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface MutationPolicySpecInputPodSecurityFsGroup {
    condition: string;
    value: number;
}

export interface MutationPolicySpecInputPodSecurityPrivileged {
    condition: string;
    value: boolean;
}

export interface MutationPolicySpecInputPodSecurityReadOnlyRootFilesystem {
    condition: string;
    value: boolean;
}

export interface MutationPolicySpecInputPodSecurityRunAsGroup {
    condition: string;
    value: number;
}

export interface MutationPolicySpecInputPodSecurityRunAsNonRoot {
    condition: string;
    value: boolean;
}

export interface MutationPolicySpecInputPodSecurityRunAsUser {
    condition: string;
    value: number;
}

export interface MutationPolicySpecInputPodSecuritySeLinuxOption {
    /**
     * SELinux condition
     */
    condition?: string;
    /**
     * SELinux level
     */
    level?: string;
    /**
     * SELinux role
     */
    role?: string;
    /**
     * SELinux type
     */
    type?: string;
    /**
     * SELinux user
     */
    user?: string;
}

export interface MutationPolicySpecInputPodSecuritySupplementalGroups {
    condition?: string;
    values: number[];
}

export interface MutationPolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.MutationPolicySpecNamespaceSelectorMatchExpression[];
}

export interface MutationPolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface NamespaceMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface NamespaceQuotaPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface NamespaceQuotaPolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.NamespaceQuotaPolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.NamespaceQuotaPolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.NamespaceQuotaPolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.NamespaceQuotaPolicyScopeWorkspace;
}

export interface NamespaceQuotaPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface NamespaceQuotaPolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface NamespaceQuotaPolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface NamespaceQuotaPolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface NamespaceQuotaPolicySpec {
    /**
     * Input for the namespace quota policy, having one of the valid recipes: small, medium, large or custom.
     */
    input: outputs.NamespaceQuotaPolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.NamespaceQuotaPolicySpecNamespaceSelector;
}

export interface NamespaceQuotaPolicySpecInput {
    /**
     * The input schema for namespace quota policy custom recipe version v1
     */
    custom?: outputs.NamespaceQuotaPolicySpecInputCustom;
    /**
     * The input schema for namespace quota policy large recipe version v1
     */
    large?: outputs.NamespaceQuotaPolicySpecInputLarge;
    /**
     * The input schema for namespace quota policy medium recipe version v1
     */
    medium?: outputs.NamespaceQuotaPolicySpecInputMedium;
    /**
     * The input schema for namespace quota policy small recipe version v1
     */
    small?: outputs.NamespaceQuotaPolicySpecInputSmall;
}

export interface NamespaceQuotaPolicySpecInputCustom {
    /**
     * The sum of CPU limits across all pods in a non-terminal state cannot exceed this value
     */
    limitsCpu?: string;
    /**
     * The sum of memory limits across all pods in a non-terminal state cannot exceed this value
     */
    limitsMemory?: string;
    /**
     * The total number of PersistentVolumeClaims that can exist in a namespace
     */
    persistentVolumeClaims?: number;
    /**
     * Across all persistent volume claims associated with each storage class, the total number of persistent volume claims that can exist in the namespace
     */
    persistentVolumeClaimsPerClass?: {[key: string]: number};
    /**
     * The sum of CPU requests across all pods in a non-terminal state cannot exceed this value
     */
    requestsCpu?: string;
    /**
     * The sum of memory requests across all pods in a non-terminal state cannot exceed this value
     */
    requestsMemory?: string;
    /**
     * The sum of storage requests across all persistent volume claims cannot exceed this value
     */
    requestsStorage?: string;
    /**
     * Across all persistent volume claims associated with each storage class, the sum of storage requests cannot exceed this value
     */
    requestsStoragePerClass?: {[key: string]: string};
    /**
     * The total number of Services of the given type that can exist in a namespace
     */
    resourceCounts?: {[key: string]: number};
}

export interface NamespaceQuotaPolicySpecInputLarge {
}

export interface NamespaceQuotaPolicySpecInputMedium {
}

export interface NamespaceQuotaPolicySpecInputSmall {
}

export interface NamespaceQuotaPolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.NamespaceQuotaPolicySpecNamespaceSelectorMatchExpression[];
}

export interface NamespaceQuotaPolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface NamespaceSpec {
    attach?: boolean;
    workspaceName?: string;
}

export interface NetworkPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface NetworkPolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.NetworkPolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.NetworkPolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.NetworkPolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.NetworkPolicyScopeWorkspace;
}

export interface NetworkPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface NetworkPolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface NetworkPolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface NetworkPolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface NetworkPolicySpec {
    /**
     * Input for the network policy, having one of the valid recipes: allow-all, allow-all-to-pods, allow-all-egress, deny-all, deny-all-to-pods, deny-all-egress, custom-egress or custom-ingress.
     */
    input: outputs.NetworkPolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.NetworkPolicySpecNamespaceSelector;
}

export interface NetworkPolicySpecInput {
    /**
     * The input schema for network policy allow-all recipe version v1
     */
    allowAll?: outputs.NetworkPolicySpecInputAllowAll;
    /**
     * The input schema for network policy allow-all-egress recipe version v1
     */
    allowAllEgress?: outputs.NetworkPolicySpecInputAllowAllEgress;
    /**
     * The input schema for network policy allow-all-to-pods recipe version v1
     */
    allowAllToPods?: outputs.NetworkPolicySpecInputAllowAllToPods;
    /**
     * The input schema for network policy custom egress recipe version v1
     */
    customEgress?: outputs.NetworkPolicySpecInputCustomEgress;
    /**
     * The input schema for network policy custom ingress recipe version v1
     */
    customIngress?: outputs.NetworkPolicySpecInputCustomIngress;
    /**
     * The input schema for network policy deny-all recipe version v1
     */
    denyAll?: outputs.NetworkPolicySpecInputDenyAll;
    /**
     * The input schema for network policy deny-all-egress recipe version v1
     */
    denyAllEgress?: outputs.NetworkPolicySpecInputDenyAllEgress;
    /**
     * The input schema for network policy deny-all-to-pods recipe version v1
     */
    denyAllToPods?: outputs.NetworkPolicySpecInputDenyAllToPods;
}

export interface NetworkPolicySpecInputAllowAll {
    /**
     * Allow traffic only from own namespace. Allow traffic only from pods in the same namespace as the destination pod.
     */
    fromOwnNamespace?: boolean;
}

export interface NetworkPolicySpecInputAllowAllEgress {
}

export interface NetworkPolicySpecInputAllowAllToPods {
    /**
     * Allow traffic only from own namespace. Allow traffic only from pods in the same namespace as the destination pod.
     */
    fromOwnNamespace?: boolean;
    /**
     * Pod Labels on which traffic should be allowed/denied. Use a label selector to identify the pods to which the policy applies.
     */
    toPodLabels?: {[key: string]: string};
}

export interface NetworkPolicySpecInputCustomEgress {
    /**
     * This specifies list of egress rules to be applied to the selected pods.
     */
    rules: outputs.NetworkPolicySpecInputCustomEgressRule[];
    /**
     * Pod Labels on which traffic should be allowed/denied. Use a label selector to identify the pods to which the policy applies.
     */
    toPodLabels?: {[key: string]: string};
}

export interface NetworkPolicySpecInputCustomEgressRule {
    /**
     * List of destination ports for outgoing traffic. Each item in this list is combined using a logical OR. Default is this rule matches all ports (traffic not restricted by port).
     */
    ports: outputs.NetworkPolicySpecInputCustomEgressRulePort[];
    /**
     * List of destinations for outgoing traffic of pods selected for this rule. Default is the rule matches all destinations (traffic not restricted by destinations).
     */
    ruleSpecs: outputs.NetworkPolicySpecInputCustomEgressRuleRuleSpec[];
}

export interface NetworkPolicySpecInputCustomEgressRulePort {
    /**
     * The port on the given protocol. This can either be a numerical or named port on a pod.
     */
    port?: string;
    /**
     * The protocol (TCP or UDP) which traffic must match.
     */
    protocol?: string;
}

export interface NetworkPolicySpecInputCustomEgressRuleRuleSpec {
    /**
     * The rule Spec (destination) for IP Block.
     */
    customIps?: outputs.NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomIp[];
    /**
     * The rule Spec (destination) for Selectors.
     */
    customSelectors?: outputs.NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomSelector[];
}

export interface NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomIp {
    /**
     * IPBlock defines policy on a particular IPBlock. If this field is set then neither of the namespaceSelector and PodSelector can be set.
     */
    ipBlocks?: outputs.NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomIpIpBlock[];
}

export interface NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomIpIpBlock {
    /**
     * CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     */
    cidr: string;
    /**
     * Except is a slice of CIDRs that should not be included within an IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64" Except values will be rejected if they are outside the CIDR range
     */
    excepts?: string[];
}

export interface NetworkPolicySpecInputCustomEgressRuleRuleSpecCustomSelector {
    /**
     * Use a label selector to identify the namespaces to allow as egress destinations.
     */
    namespaceSelector?: {[key: string]: string};
    /**
     * Use a label selector to identify the pods to allow as egress destinations.
     */
    podSelector?: {[key: string]: string};
}

export interface NetworkPolicySpecInputCustomIngress {
    /**
     * This specifies list of ingress rules to be applied to the selected pods.
     */
    rules: outputs.NetworkPolicySpecInputCustomIngressRule[];
    /**
     * Pod Labels on which traffic should be allowed/denied. Use a label selector to identify the pods to which the policy applies.
     */
    toPodLabels?: {[key: string]: string};
}

export interface NetworkPolicySpecInputCustomIngressRule {
    /**
     * List of ports which should be made accessible on the pods selected for this rule. Each item in this list is combined using a logical OR. Default is this rule matches all ports (traffic not restricted by port).
     */
    ports: outputs.NetworkPolicySpecInputCustomIngressRulePort[];
    /**
     * List of sources which should be able to access the pods selected for this rule. Default is the rule matches all sources (traffic not restricted by source). List of items of type V1alpha1CommonPolicySpecNetworkV1CustomIngressRulesRuleSpec0 OR V1alpha1CommonPolicySpecNetworkV1CustomIngressRulesRuleSpec1.
     */
    ruleSpecs: outputs.NetworkPolicySpecInputCustomIngressRuleRuleSpec[];
}

export interface NetworkPolicySpecInputCustomIngressRulePort {
    /**
     * The port on the given protocol. This can either be a numerical or named port on a pod.
     */
    port?: string;
    /**
     * The protocol (TCP or UDP) which traffic must match.
     */
    protocol?: string;
}

export interface NetworkPolicySpecInputCustomIngressRuleRuleSpec {
    /**
     * The rule Spec (source) for IP Block.
     */
    customIps?: outputs.NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomIp[];
    /**
     * The rule Spec (source) for Selectors.
     */
    customSelectors?: outputs.NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomSelector[];
}

export interface NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomIp {
    /**
     * IPBlock defines policy on a particular IPBlock. If this field is set then neither of the namespaceSelector and PodSelector can be set.
     */
    ipBlocks?: outputs.NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomIpIpBlock[];
}

export interface NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomIpIpBlock {
    /**
     * CIDR is a string representing the IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64"
     */
    cidr: string;
    /**
     * Except is a slice of CIDRs that should not be included within an IP Block Valid examples are "192.168.1.1/24" or "2001:db9::/64" Except values will be rejected if they are outside the CIDR range
     */
    excepts?: string[];
}

export interface NetworkPolicySpecInputCustomIngressRuleRuleSpecCustomSelector {
    /**
     * Use a label selector to identify the namespaces to allow as egress destinations.
     */
    namespaceSelector?: {[key: string]: string};
    /**
     * Use a label selector to identify the pods to allow as egress destinations.
     */
    podSelector?: {[key: string]: string};
}

export interface NetworkPolicySpecInputDenyAll {
}

export interface NetworkPolicySpecInputDenyAllEgress {
}

export interface NetworkPolicySpecInputDenyAllToPods {
    /**
     * Pod Labels on which traffic should be allowed/denied. Use a label selector to identify the pods to which the policy applies.
     */
    toPodLabels?: {[key: string]: string};
}

export interface NetworkPolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.NetworkPolicySpecNamespaceSelectorMatchExpression[];
}

export interface NetworkPolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface PackageInstallMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface PackageInstallScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.PackageInstallScopeCluster;
}

export interface PackageInstallScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface PackageInstallSpec {
    /**
     * Inline values to configure the Package Install.
     */
    inlineValues?: {[key: string]: string};
    /**
     * Reference to the Package which will be installed.
     */
    packageRef: outputs.PackageInstallSpecPackageRef;
    /**
     * Role binding scope for service account which will be used by Package Install.
     */
    roleBindingScope: string;
}

export interface PackageInstallSpecPackageRef {
    /**
     * Name of the Package Metadata.
     */
    packageMetadataName: string;
    /**
     * Version Selection of the Package.
     */
    versionSelection: outputs.PackageInstallSpecPackageRefVersionSelection;
}

export interface PackageInstallSpecPackageRefVersionSelection {
    /**
     * Constraints to select Package. Example: constraints: 'v1.2.3', constraints: '<v1.4.0' etc.
     */
    constraints: string;
}

export interface PackageInstallStatus {
    generatedResources: outputs.PackageInstallStatusGeneratedResource[];
    managed: boolean;
    packageInstallPhase: string;
    referredBies: string[];
    resolvedVersion: string;
}

export interface PackageInstallStatusGeneratedResource {
    clusterRoleName: string;
    roleBindingName: string;
    serviceAccountName: string;
}

export interface PackageRepositoryMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface PackageRepositoryScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.PackageRepositoryScopeCluster;
}

export interface PackageRepositoryScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface PackageRepositorySpec {
    /**
     * Docker image url; unqualified, tagged, or digest references supported.
     */
    imgpkgBundle?: outputs.PackageRepositorySpecImgpkgBundle;
}

export interface PackageRepositorySpecImgpkgBundle {
    /**
     * image url string.
     */
    image: string;
}

export interface PackageRepositoryState {
    disabled: boolean;
    managed: boolean;
    packageRepositoryPhase: string;
    subscribed: boolean;
}

export interface ProvisionerMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface RepositoryCredentialMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface RepositoryCredentialScope {
    /**
     * The schema for cluster full name
     */
    cluster?: outputs.RepositoryCredentialScopeCluster;
    /**
     * The schema for cluster group full name
     */
    clusterGroup?: outputs.RepositoryCredentialScopeClusterGroup;
}

export interface RepositoryCredentialScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface RepositoryCredentialScopeClusterGroup {
    /**
     * Name of the cluster group
     */
    name: string;
}

export interface RepositoryCredentialSpec {
    /**
     * The schema for spec credential type.
     */
    data: outputs.RepositoryCredentialSpecData;
}

export interface RepositoryCredentialSpecData {
    /**
     * The schema for SSH credential type spec.
     */
    sshKey?: outputs.RepositoryCredentialSpecDataSshKey;
    /**
     * The schema for Username/Password credential type spec.
     */
    usernamePassword?: outputs.RepositoryCredentialSpecDataUsernamePassword;
}

export interface RepositoryCredentialSpecDataSshKey {
    /**
     * SSH Identity file.
     */
    identity: string;
    /**
     * Known Hosts file path.
     */
    knownHosts: string;
}

export interface RepositoryCredentialSpecDataUsernamePassword {
    /**
     * Password for the basic authorization.
     */
    password: string;
    /**
     * Username for the basic authorization.
     */
    username: string;
}

export interface SecurityPolicyMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface SecurityPolicyScope {
    /**
     * The schema for cluster policy full name
     */
    cluster?: outputs.SecurityPolicyScopeCluster;
    /**
     * The schema for cluster group policy full name
     */
    clusterGroup?: outputs.SecurityPolicyScopeClusterGroup;
    /**
     * The schema for organization policy full name
     */
    organization?: outputs.SecurityPolicyScopeOrganization;
    /**
     * The schema for workspace policy full name
     */
    workspace?: outputs.SecurityPolicyScopeWorkspace;
}

export interface SecurityPolicyScopeCluster {
    /**
     * Name of the management cluster
     */
    managementClusterName?: string;
    /**
     * Name of this cluster
     */
    name: string;
    /**
     * Provisioner of the cluster
     */
    provisionerName?: string;
}

export interface SecurityPolicyScopeClusterGroup {
    /**
     * Name of this cluster group
     */
    clusterGroup: string;
}

export interface SecurityPolicyScopeOrganization {
    /**
     * ID of this organization
     */
    organization: string;
}

export interface SecurityPolicyScopeWorkspace {
    /**
     * Name of this workspace
     */
    workspace: string;
}

export interface SecurityPolicySpec {
    /**
     * Input for the security policy, having one of the valid recipes: baseline, custom or strict.
     */
    input: outputs.SecurityPolicySpecInput;
    /**
     * Label based Namespace Selector for the policy
     */
    namespaceSelector?: outputs.SecurityPolicySpecNamespaceSelector;
}

export interface SecurityPolicySpecInput {
    /**
     * The input schema for security policy baseline recipe version v1
     */
    baseline?: outputs.SecurityPolicySpecInputBaseline;
    /**
     * The input schema for security policy custom recipe version v1
     */
    custom?: outputs.SecurityPolicySpecInputCustom;
    /**
     * The input schema for security policy strict recipe version v1
     */
    strict?: outputs.SecurityPolicySpecInputStrict;
}

export interface SecurityPolicySpecInputBaseline {
    /**
     * Audit (dry-run)
     */
    audit?: boolean;
    /**
     * Disable native pod security policy
     */
    disableNativePsp?: boolean;
}

export interface SecurityPolicySpecInputCustom {
    /**
     * Allow host namespace sharing
     */
    allowHostNamespaceSharing?: boolean;
    /**
     * Allow host network
     */
    allowHostNetwork?: boolean;
    /**
     * Allow privilege escalation
     */
    allowPrivilegeEscalation?: boolean;
    /**
     * Allow privileged containers
     */
    allowPrivilegedContainers?: boolean;
    /**
     * Allowed host paths
     */
    allowedHostPaths?: outputs.SecurityPolicySpecInputCustomAllowedHostPath[];
    /**
     * Allowed host port range
     */
    allowedHostPortRange?: outputs.SecurityPolicySpecInputCustomAllowedHostPortRange;
    /**
     * Allowed selinux options
     */
    allowedSeLinuxOptions?: outputs.SecurityPolicySpecInputCustomAllowedSeLinuxOption[];
    /**
     * Allowed volumes
     */
    allowedVolumes?: string[];
    /**
     * Audit (dry-run)
     */
    audit?: boolean;
    /**
     * Disable native pod security policy
     */
    disableNativePsp?: boolean;
    /**
     * fsGroup
     */
    fsGroup?: outputs.SecurityPolicySpecInputCustomFsGroup;
    /**
     * Linux capabilities
     */
    linuxCapabilities?: outputs.SecurityPolicySpecInputCustomLinuxCapabilities;
    /**
     * Read only root file system
     */
    readOnlyRootFileSystem?: boolean;
    /**
     * Run as group
     */
    runAsGroup?: outputs.SecurityPolicySpecInputCustomRunAsGroup;
    /**
     * Run as user
     */
    runAsUser?: outputs.SecurityPolicySpecInputCustomRunAsUser;
    /**
     * Seccomp
     */
    seccomp?: outputs.SecurityPolicySpecInputCustomSeccomp;
    /**
     * supplemental groups
     */
    supplementalGroups?: outputs.SecurityPolicySpecInputCustomSupplementalGroups;
    /**
     * Sysctls
     */
    sysctls?: outputs.SecurityPolicySpecInputCustomSysctls;
}

export interface SecurityPolicySpecInputCustomAllowedHostPath {
    /**
     * Path prefix
     */
    pathPrefix?: string;
    /**
     * Read only flag
     */
    readOnly?: boolean;
}

export interface SecurityPolicySpecInputCustomAllowedHostPortRange {
    /**
     * Maximum allowed port
     */
    max?: number;
    /**
     * Minimum allowed port
     */
    min?: number;
}

export interface SecurityPolicySpecInputCustomAllowedSeLinuxOption {
    /**
     * SELinux level
     */
    level?: string;
    /**
     * SELinux role
     */
    role?: string;
    /**
     * SELinux type
     */
    type?: string;
    /**
     * SELinux user
     */
    user?: string;
}

export interface SecurityPolicySpecInputCustomFsGroup {
    /**
     * Allowed group id ranges
     */
    ranges?: outputs.SecurityPolicySpecInputCustomFsGroupRange[];
    /**
     * Rule
     */
    rule?: string;
}

export interface SecurityPolicySpecInputCustomFsGroupRange {
    /**
     * Maximum group ID
     */
    max?: number;
    /**
     * Minimum group ID
     */
    min?: number;
}

export interface SecurityPolicySpecInputCustomLinuxCapabilities {
    /**
     * Allowed capabilities
     */
    allowedCapabilities?: string[];
    /**
     * Required drop capabilities
     */
    requiredDropCapabilities?: string[];
}

export interface SecurityPolicySpecInputCustomRunAsGroup {
    /**
     * Allowed group id ranges
     */
    ranges?: outputs.SecurityPolicySpecInputCustomRunAsGroupRange[];
    /**
     * Rule
     */
    rule?: string;
}

export interface SecurityPolicySpecInputCustomRunAsGroupRange {
    /**
     * Maximum group ID
     */
    max?: number;
    /**
     * Minimum group ID
     */
    min?: number;
}

export interface SecurityPolicySpecInputCustomRunAsUser {
    /**
     * Allowed user id ranges
     */
    ranges?: outputs.SecurityPolicySpecInputCustomRunAsUserRange[];
    /**
     * Rule
     */
    rule?: string;
}

export interface SecurityPolicySpecInputCustomRunAsUserRange {
    /**
     * Maximum user ID
     */
    max?: number;
    /**
     * Minimum user ID
     */
    min?: number;
}

export interface SecurityPolicySpecInputCustomSeccomp {
    /**
     * Allowed local host files
     */
    allowedLocalhostFiles?: string[];
    /**
     * Allowed profiles
     */
    allowedProfiles?: string[];
}

export interface SecurityPolicySpecInputCustomSupplementalGroups {
    /**
     * Allowed group id ranges
     */
    ranges?: outputs.SecurityPolicySpecInputCustomSupplementalGroupsRange[];
    /**
     * Rule
     */
    rule?: string;
}

export interface SecurityPolicySpecInputCustomSupplementalGroupsRange {
    /**
     * Maximum group ID
     */
    max?: number;
    /**
     * Minimum group ID
     */
    min?: number;
}

export interface SecurityPolicySpecInputCustomSysctls {
    /**
     * Forbidden sysctls
     */
    forbiddenSysctls?: string[];
}

export interface SecurityPolicySpecInputStrict {
    /**
     * Audit (dry-run)
     */
    audit?: boolean;
    /**
     * Disable native pod security policy
     */
    disableNativePsp?: boolean;
}

export interface SecurityPolicySpecNamespaceSelector {
    /**
     * Match expressions is a list of label selector requirements, the requirements are ANDed
     */
    matchExpressions: outputs.SecurityPolicySpecNamespaceSelectorMatchExpression[];
}

export interface SecurityPolicySpecNamespaceSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values
     */
    operator?: string;
    /**
     * Values is an array of string values
     */
    values: string[];
}

export interface TanzuKubernetesClusterMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface TanzuKubernetesClusterSpec {
    /**
     * Name of the cluster group to which this cluster belongs.
     */
    clusterGroupName?: string;
    /**
     * Name of the image registry configuration to use.
     */
    imageRegistry?: string;
    /**
     * Cluster's kubeconfig.
     */
    kubeconfig: string;
    /**
     * Name of the proxy configuration to use.
     */
    proxyName?: string;
    /**
     * TMC-managed flag indicates if the cluster is managed by tmc.
     * (Default: False)
     */
    tmcManaged: boolean;
    /**
     * The cluster topology.
     */
    topology: outputs.TanzuKubernetesClusterSpecTopology;
}

export interface TanzuKubernetesClusterSpecTopology {
    /**
     * The name of the cluster class for the cluster.
     */
    clusterClass: string;
    /**
     * Variables configuration for the cluster.
     */
    clusterVariables: string;
    /**
     * Control plane specific configuration.
     */
    controlPlane: outputs.TanzuKubernetesClusterSpecTopologyControlPlane;
    /**
     * (Repeatable Block) The core addons.
     */
    coreAddons?: outputs.TanzuKubernetesClusterSpecTopologyCoreAddon[];
    /**
     * Network specific configuration.
     */
    network?: outputs.TanzuKubernetesClusterSpecTopologyNetwork;
    /**
     * (Repeatable Block) Node pool definition for the cluster.
     */
    nodepools: outputs.TanzuKubernetesClusterSpecTopologyNodepool[];
    /**
     * Kubernetes version of the cluster.
     */
    version: string;
}

export interface TanzuKubernetesClusterSpecTopologyControlPlane {
    /**
     * Metadata for the resource
     */
    meta?: outputs.TanzuKubernetesClusterSpecTopologyControlPlaneMeta;
    /**
     * OS image block
     */
    osImage?: outputs.TanzuKubernetesClusterSpecTopologyControlPlaneOsImage;
    /**
     * Number of replicas
     */
    replicas: number;
}

export interface TanzuKubernetesClusterSpecTopologyControlPlaneMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface TanzuKubernetesClusterSpecTopologyControlPlaneOsImage {
    /**
     * The architecture of the OS image.
     */
    arch: string;
    /**
     * The name of the OS image.
     */
    name: string;
    /**
     * The version of the OS image.
     */
    version: string;
}

export interface TanzuKubernetesClusterSpecTopologyCoreAddon {
    /**
     * Provider of core add on
     */
    provider: string;
    /**
     * Type of core add on
     */
    type: string;
}

export interface TanzuKubernetesClusterSpecTopologyNetwork {
    /**
     * Pod CIDR for Kubernetes pods defaults to 192.168.0.0/16.
     */
    podCidrBlocks?: string[];
    /**
     * Service CIDR for kubernetes services defaults to 10.96.0.0/12.
     */
    serviceCidrBlocks?: string[];
    /**
     * Domain name for services.
     */
    serviceDomain?: string;
}

export interface TanzuKubernetesClusterSpecTopologyNodepool {
    /**
     * Description of the node pool.
     */
    description?: string;
    /**
     * Name of the node pool.
     */
    name: string;
    /**
     * Spec for the node pool.
     */
    specs: outputs.TanzuKubernetesClusterSpecTopologyNodepoolSpec[];
}

export interface TanzuKubernetesClusterSpecTopologyNodepoolSpec {
    /**
     * The failure domain the machines will be created in.
     */
    failureDomain?: string;
    /**
     * Metadata for the resource
     */
    meta?: outputs.TanzuKubernetesClusterSpecTopologyNodepoolSpecMeta;
    /**
     * OS image block
     */
    osImage?: outputs.TanzuKubernetesClusterSpecTopologyNodepoolSpecOsImage;
    /**
     * Overrides can be used to override cluster level variables.
     */
    overrides?: string;
    /**
     * Number of replicas
     */
    replicas: number;
    /**
     * The name of the machine deployment class used to create the node pool.
     */
    workerClass: string;
}

export interface TanzuKubernetesClusterSpecTopologyNodepoolSpecMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
}

export interface TanzuKubernetesClusterSpecTopologyNodepoolSpecOsImage {
    /**
     * The architecture of the OS image.
     */
    arch: string;
    /**
     * The name of the OS image.
     */
    name: string;
    /**
     * The version of the OS image.
     */
    version: string;
}

export interface TanzuKubernetesClusterTimeoutPolicy {
    /**
     * Fail on timeout if timeout is reached and cluster is not ready. (Default = true)
     */
    failOnTimeout?: boolean;
    /**
     * Timeout in minutes for tanzu kubernetes creation process. A value of 0 means that no timeout is set. (Default: 60)
     */
    timeout?: number;
    /**
     * Wait for kubeconfig. (Default = true)
     */
    waitForKubeconfig?: boolean;
}

export interface TargetLocationMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export interface TargetLocationSpec {
    /**
     * Assigned groups block for the target location.
     */
    assignedGroups?: outputs.TargetLocationSpecAssignedGroups;
    /**
     * The bucket to use for object storage.
     */
    bucket?: string;
    /**
     * A PEM-encoded certificate bundle to trust while connecting to the storage backend.
     */
    caCert?: string;
    /**
     * Target location config block.
     * Required only when target location is Self Managed and should contain either AWS or Azure blocks but not both.
     */
    config?: outputs.TargetLocationSpecConfig;
    /**
     * Credentials block
     */
    credential: {[key: string]: string};
    /**
     * The region of the bucket origin.
     * Required only when target location is AWS Self Managed.
     */
    region?: string;
    /**
     * System bucket to use for object storage.
     * (Only used for Managed TMC)
     */
    sysBucketKey: string;
    /**
     * System bucket region (Only used for Managed TMC)
     */
    sysRegionKey: string;
    /**
     * The target provider of the backup storage.
     * Valid values are (AWS, AZURE)
     */
    targetProvider: string;
}

export interface TargetLocationSpecAssignedGroups {
    /**
     * Cluster group names
     */
    clusterGroups?: string[];
    /**
     * (Repeatable Block) Cluster block.
     */
    clusters?: outputs.TargetLocationSpecAssignedGroupsCluster[];
}

export interface TargetLocationSpecAssignedGroupsCluster {
    /**
     * Management cluster name
     */
    managementClusterName: string;
    /**
     * Cluster name
     */
    name: string;
    /**
     * Cluster provisioner name
     */
    provisionerName: string;
}

export interface TargetLocationSpecConfig {
    /**
     * AWS S3 and S3-compatible target location config block.
     */
    aws?: outputs.TargetLocationSpecConfigAws;
    /**
     * Azure target location config block.
     */
    azure?: outputs.TargetLocationSpecConfigAzure;
}

export interface TargetLocationSpecConfigAws {
    /**
     * The service endpoint for non-AWS S3 storage solution.
     */
    s3BucketUrl?: string;
    /**
     * A flag for whether to force path style URLs for S3 objects.
     * It is default to false and set it to true when using local storage service like Minio.
     */
    s3ForcePathStyle?: boolean;
    /**
     * The service endpoint used for generating download URLs. This field is primarily for local storage services like Minio.
     */
    s3PublicUrl?: string;
}

export interface TargetLocationSpecConfigAzure {
    /**
     * Name of the resource group containing the storage account for this backup storage location.
     */
    resourceGroup?: string;
    /**
     * Subscription ID under which all the resources are being managed in azure.
     */
    storageAccount?: string;
    /**
     * Name of the storage account for this backup storage location.
     */
    subscriptionId?: string;
}

export interface WorkspaceMeta {
    /**
     * Annotations for the resource
     */
    annotations: {[key: string]: string};
    /**
     * Description of the resource
     */
    description?: string;
    /**
     * Labels for the resource
     */
    labels?: {[key: string]: string};
    /**
     * Resource version of the resource
     */
    resourceVersion: string;
    /**
     * UID of the resource
     */
    uid: string;
}

export namespace config {
    export interface SelfManaged {
        /**
         * URL of the OpenID Connect (OIDC) issuer configured with self-managed Taznu mission control instance
         */
        oidcIssuer?: string;
        /**
         * Password for the above mentioned Username field configured in the OIDC
         */
        password?: string;
        /**
         * Username configured in the OIDC
         */
        username?: string;
    }

}
