// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class ElasticsearchInstance extends pulumi.CustomResource {
    /**
     * Get an existing ElasticsearchInstance resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ElasticsearchInstanceState, opts?: pulumi.CustomResourceOptions): ElasticsearchInstance {
        return new ElasticsearchInstance(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'alicloud:index/elasticsearchInstance:ElasticsearchInstance';

    /**
     * Returns true if the given object is an instance of ElasticsearchInstance.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ElasticsearchInstance {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ElasticsearchInstance.__pulumiType;
    }

    public readonly autoRenewDuration!: pulumi.Output<number | undefined>;
    public readonly clientNodeAmount!: pulumi.Output<number | undefined>;
    public readonly clientNodeSpec!: pulumi.Output<string | undefined>;
    public readonly dataNodeAmount!: pulumi.Output<number>;
    public readonly dataNodeDiskEncrypted!: pulumi.Output<boolean | undefined>;
    public readonly dataNodeDiskPerformanceLevel!: pulumi.Output<string | undefined>;
    public readonly dataNodeDiskSize!: pulumi.Output<number>;
    public readonly dataNodeDiskType!: pulumi.Output<string>;
    public readonly dataNodeSpec!: pulumi.Output<string>;
    public readonly description!: pulumi.Output<string>;
    public /*out*/ readonly domain!: pulumi.Output<string>;
    public readonly enableKibanaPrivateNetwork!: pulumi.Output<boolean | undefined>;
    public readonly enableKibanaPublicNetwork!: pulumi.Output<boolean | undefined>;
    public readonly enablePublic!: pulumi.Output<boolean | undefined>;
    public readonly instanceChargeType!: pulumi.Output<string | undefined>;
    public /*out*/ readonly kibanaDomain!: pulumi.Output<string>;
    public readonly kibanaNodeSpec!: pulumi.Output<string>;
    public /*out*/ readonly kibanaPort!: pulumi.Output<number>;
    public readonly kibanaPrivateSecurityGroupId!: pulumi.Output<string | undefined>;
    public readonly kibanaPrivateWhitelists!: pulumi.Output<string[]>;
    public readonly kibanaWhitelists!: pulumi.Output<string[]>;
    public readonly kmsEncryptedPassword!: pulumi.Output<string | undefined>;
    public readonly kmsEncryptionContext!: pulumi.Output<{[key: string]: string} | undefined>;
    public readonly masterNodeDiskType!: pulumi.Output<string | undefined>;
    public readonly masterNodeSpec!: pulumi.Output<string | undefined>;
    public readonly password!: pulumi.Output<string | undefined>;
    public readonly period!: pulumi.Output<number | undefined>;
    public /*out*/ readonly port!: pulumi.Output<number>;
    public readonly privateWhitelists!: pulumi.Output<string[]>;
    public readonly protocol!: pulumi.Output<string | undefined>;
    public /*out*/ readonly publicDomain!: pulumi.Output<string>;
    public /*out*/ readonly publicPort!: pulumi.Output<number>;
    public readonly publicWhitelists!: pulumi.Output<string[]>;
    public readonly renewStatus!: pulumi.Output<string | undefined>;
    public readonly renewalDurationUnit!: pulumi.Output<string | undefined>;
    public readonly resourceGroupId!: pulumi.Output<string>;
    public readonly settingConfig!: pulumi.Output<{[key: string]: string}>;
    public /*out*/ readonly status!: pulumi.Output<string>;
    public readonly tags!: pulumi.Output<{[key: string]: string} | undefined>;
    public readonly timeouts!: pulumi.Output<outputs.ElasticsearchInstanceTimeouts | undefined>;
    public readonly version!: pulumi.Output<string>;
    public readonly vswitchId!: pulumi.Output<string>;
    public readonly warmNodeAmount!: pulumi.Output<number | undefined>;
    public readonly warmNodeDiskEncrypted!: pulumi.Output<boolean | undefined>;
    public readonly warmNodeDiskSize!: pulumi.Output<number | undefined>;
    public readonly warmNodeDiskType!: pulumi.Output<string | undefined>;
    public readonly warmNodeSpec!: pulumi.Output<string | undefined>;
    public readonly zoneCount!: pulumi.Output<number | undefined>;

    /**
     * Create a ElasticsearchInstance resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ElasticsearchInstanceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ElasticsearchInstanceArgs | ElasticsearchInstanceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ElasticsearchInstanceState | undefined;
            resourceInputs["autoRenewDuration"] = state ? state.autoRenewDuration : undefined;
            resourceInputs["clientNodeAmount"] = state ? state.clientNodeAmount : undefined;
            resourceInputs["clientNodeSpec"] = state ? state.clientNodeSpec : undefined;
            resourceInputs["dataNodeAmount"] = state ? state.dataNodeAmount : undefined;
            resourceInputs["dataNodeDiskEncrypted"] = state ? state.dataNodeDiskEncrypted : undefined;
            resourceInputs["dataNodeDiskPerformanceLevel"] = state ? state.dataNodeDiskPerformanceLevel : undefined;
            resourceInputs["dataNodeDiskSize"] = state ? state.dataNodeDiskSize : undefined;
            resourceInputs["dataNodeDiskType"] = state ? state.dataNodeDiskType : undefined;
            resourceInputs["dataNodeSpec"] = state ? state.dataNodeSpec : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["domain"] = state ? state.domain : undefined;
            resourceInputs["enableKibanaPrivateNetwork"] = state ? state.enableKibanaPrivateNetwork : undefined;
            resourceInputs["enableKibanaPublicNetwork"] = state ? state.enableKibanaPublicNetwork : undefined;
            resourceInputs["enablePublic"] = state ? state.enablePublic : undefined;
            resourceInputs["instanceChargeType"] = state ? state.instanceChargeType : undefined;
            resourceInputs["kibanaDomain"] = state ? state.kibanaDomain : undefined;
            resourceInputs["kibanaNodeSpec"] = state ? state.kibanaNodeSpec : undefined;
            resourceInputs["kibanaPort"] = state ? state.kibanaPort : undefined;
            resourceInputs["kibanaPrivateSecurityGroupId"] = state ? state.kibanaPrivateSecurityGroupId : undefined;
            resourceInputs["kibanaPrivateWhitelists"] = state ? state.kibanaPrivateWhitelists : undefined;
            resourceInputs["kibanaWhitelists"] = state ? state.kibanaWhitelists : undefined;
            resourceInputs["kmsEncryptedPassword"] = state ? state.kmsEncryptedPassword : undefined;
            resourceInputs["kmsEncryptionContext"] = state ? state.kmsEncryptionContext : undefined;
            resourceInputs["masterNodeDiskType"] = state ? state.masterNodeDiskType : undefined;
            resourceInputs["masterNodeSpec"] = state ? state.masterNodeSpec : undefined;
            resourceInputs["password"] = state ? state.password : undefined;
            resourceInputs["period"] = state ? state.period : undefined;
            resourceInputs["port"] = state ? state.port : undefined;
            resourceInputs["privateWhitelists"] = state ? state.privateWhitelists : undefined;
            resourceInputs["protocol"] = state ? state.protocol : undefined;
            resourceInputs["publicDomain"] = state ? state.publicDomain : undefined;
            resourceInputs["publicPort"] = state ? state.publicPort : undefined;
            resourceInputs["publicWhitelists"] = state ? state.publicWhitelists : undefined;
            resourceInputs["renewStatus"] = state ? state.renewStatus : undefined;
            resourceInputs["renewalDurationUnit"] = state ? state.renewalDurationUnit : undefined;
            resourceInputs["resourceGroupId"] = state ? state.resourceGroupId : undefined;
            resourceInputs["settingConfig"] = state ? state.settingConfig : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["tags"] = state ? state.tags : undefined;
            resourceInputs["timeouts"] = state ? state.timeouts : undefined;
            resourceInputs["version"] = state ? state.version : undefined;
            resourceInputs["vswitchId"] = state ? state.vswitchId : undefined;
            resourceInputs["warmNodeAmount"] = state ? state.warmNodeAmount : undefined;
            resourceInputs["warmNodeDiskEncrypted"] = state ? state.warmNodeDiskEncrypted : undefined;
            resourceInputs["warmNodeDiskSize"] = state ? state.warmNodeDiskSize : undefined;
            resourceInputs["warmNodeDiskType"] = state ? state.warmNodeDiskType : undefined;
            resourceInputs["warmNodeSpec"] = state ? state.warmNodeSpec : undefined;
            resourceInputs["zoneCount"] = state ? state.zoneCount : undefined;
        } else {
            const args = argsOrState as ElasticsearchInstanceArgs | undefined;
            if ((!args || args.dataNodeAmount === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dataNodeAmount'");
            }
            if ((!args || args.dataNodeDiskSize === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dataNodeDiskSize'");
            }
            if ((!args || args.dataNodeDiskType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dataNodeDiskType'");
            }
            if ((!args || args.dataNodeSpec === undefined) && !opts.urn) {
                throw new Error("Missing required property 'dataNodeSpec'");
            }
            if ((!args || args.version === undefined) && !opts.urn) {
                throw new Error("Missing required property 'version'");
            }
            if ((!args || args.vswitchId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'vswitchId'");
            }
            resourceInputs["autoRenewDuration"] = args ? args.autoRenewDuration : undefined;
            resourceInputs["clientNodeAmount"] = args ? args.clientNodeAmount : undefined;
            resourceInputs["clientNodeSpec"] = args ? args.clientNodeSpec : undefined;
            resourceInputs["dataNodeAmount"] = args ? args.dataNodeAmount : undefined;
            resourceInputs["dataNodeDiskEncrypted"] = args ? args.dataNodeDiskEncrypted : undefined;
            resourceInputs["dataNodeDiskPerformanceLevel"] = args ? args.dataNodeDiskPerformanceLevel : undefined;
            resourceInputs["dataNodeDiskSize"] = args ? args.dataNodeDiskSize : undefined;
            resourceInputs["dataNodeDiskType"] = args ? args.dataNodeDiskType : undefined;
            resourceInputs["dataNodeSpec"] = args ? args.dataNodeSpec : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["enableKibanaPrivateNetwork"] = args ? args.enableKibanaPrivateNetwork : undefined;
            resourceInputs["enableKibanaPublicNetwork"] = args ? args.enableKibanaPublicNetwork : undefined;
            resourceInputs["enablePublic"] = args ? args.enablePublic : undefined;
            resourceInputs["instanceChargeType"] = args ? args.instanceChargeType : undefined;
            resourceInputs["kibanaNodeSpec"] = args ? args.kibanaNodeSpec : undefined;
            resourceInputs["kibanaPrivateSecurityGroupId"] = args ? args.kibanaPrivateSecurityGroupId : undefined;
            resourceInputs["kibanaPrivateWhitelists"] = args ? args.kibanaPrivateWhitelists : undefined;
            resourceInputs["kibanaWhitelists"] = args ? args.kibanaWhitelists : undefined;
            resourceInputs["kmsEncryptedPassword"] = args ? args.kmsEncryptedPassword : undefined;
            resourceInputs["kmsEncryptionContext"] = args ? args.kmsEncryptionContext : undefined;
            resourceInputs["masterNodeDiskType"] = args ? args.masterNodeDiskType : undefined;
            resourceInputs["masterNodeSpec"] = args ? args.masterNodeSpec : undefined;
            resourceInputs["password"] = args?.password ? pulumi.secret(args.password) : undefined;
            resourceInputs["period"] = args ? args.period : undefined;
            resourceInputs["privateWhitelists"] = args ? args.privateWhitelists : undefined;
            resourceInputs["protocol"] = args ? args.protocol : undefined;
            resourceInputs["publicWhitelists"] = args ? args.publicWhitelists : undefined;
            resourceInputs["renewStatus"] = args ? args.renewStatus : undefined;
            resourceInputs["renewalDurationUnit"] = args ? args.renewalDurationUnit : undefined;
            resourceInputs["resourceGroupId"] = args ? args.resourceGroupId : undefined;
            resourceInputs["settingConfig"] = args ? args.settingConfig : undefined;
            resourceInputs["tags"] = args ? args.tags : undefined;
            resourceInputs["timeouts"] = args ? args.timeouts : undefined;
            resourceInputs["version"] = args ? args.version : undefined;
            resourceInputs["vswitchId"] = args ? args.vswitchId : undefined;
            resourceInputs["warmNodeAmount"] = args ? args.warmNodeAmount : undefined;
            resourceInputs["warmNodeDiskEncrypted"] = args ? args.warmNodeDiskEncrypted : undefined;
            resourceInputs["warmNodeDiskSize"] = args ? args.warmNodeDiskSize : undefined;
            resourceInputs["warmNodeDiskType"] = args ? args.warmNodeDiskType : undefined;
            resourceInputs["warmNodeSpec"] = args ? args.warmNodeSpec : undefined;
            resourceInputs["zoneCount"] = args ? args.zoneCount : undefined;
            resourceInputs["domain"] = undefined /*out*/;
            resourceInputs["kibanaDomain"] = undefined /*out*/;
            resourceInputs["kibanaPort"] = undefined /*out*/;
            resourceInputs["port"] = undefined /*out*/;
            resourceInputs["publicDomain"] = undefined /*out*/;
            resourceInputs["publicPort"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["password"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(ElasticsearchInstance.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering ElasticsearchInstance resources.
 */
export interface ElasticsearchInstanceState {
    autoRenewDuration?: pulumi.Input<number>;
    clientNodeAmount?: pulumi.Input<number>;
    clientNodeSpec?: pulumi.Input<string>;
    dataNodeAmount?: pulumi.Input<number>;
    dataNodeDiskEncrypted?: pulumi.Input<boolean>;
    dataNodeDiskPerformanceLevel?: pulumi.Input<string>;
    dataNodeDiskSize?: pulumi.Input<number>;
    dataNodeDiskType?: pulumi.Input<string>;
    dataNodeSpec?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    domain?: pulumi.Input<string>;
    enableKibanaPrivateNetwork?: pulumi.Input<boolean>;
    enableKibanaPublicNetwork?: pulumi.Input<boolean>;
    enablePublic?: pulumi.Input<boolean>;
    instanceChargeType?: pulumi.Input<string>;
    kibanaDomain?: pulumi.Input<string>;
    kibanaNodeSpec?: pulumi.Input<string>;
    kibanaPort?: pulumi.Input<number>;
    kibanaPrivateSecurityGroupId?: pulumi.Input<string>;
    kibanaPrivateWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    kibanaWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    kmsEncryptedPassword?: pulumi.Input<string>;
    kmsEncryptionContext?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    masterNodeDiskType?: pulumi.Input<string>;
    masterNodeSpec?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    port?: pulumi.Input<number>;
    privateWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    protocol?: pulumi.Input<string>;
    publicDomain?: pulumi.Input<string>;
    publicPort?: pulumi.Input<number>;
    publicWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    renewStatus?: pulumi.Input<string>;
    renewalDurationUnit?: pulumi.Input<string>;
    resourceGroupId?: pulumi.Input<string>;
    settingConfig?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    status?: pulumi.Input<string>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    timeouts?: pulumi.Input<inputs.ElasticsearchInstanceTimeouts>;
    version?: pulumi.Input<string>;
    vswitchId?: pulumi.Input<string>;
    warmNodeAmount?: pulumi.Input<number>;
    warmNodeDiskEncrypted?: pulumi.Input<boolean>;
    warmNodeDiskSize?: pulumi.Input<number>;
    warmNodeDiskType?: pulumi.Input<string>;
    warmNodeSpec?: pulumi.Input<string>;
    zoneCount?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a ElasticsearchInstance resource.
 */
export interface ElasticsearchInstanceArgs {
    autoRenewDuration?: pulumi.Input<number>;
    clientNodeAmount?: pulumi.Input<number>;
    clientNodeSpec?: pulumi.Input<string>;
    dataNodeAmount: pulumi.Input<number>;
    dataNodeDiskEncrypted?: pulumi.Input<boolean>;
    dataNodeDiskPerformanceLevel?: pulumi.Input<string>;
    dataNodeDiskSize: pulumi.Input<number>;
    dataNodeDiskType: pulumi.Input<string>;
    dataNodeSpec: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    enableKibanaPrivateNetwork?: pulumi.Input<boolean>;
    enableKibanaPublicNetwork?: pulumi.Input<boolean>;
    enablePublic?: pulumi.Input<boolean>;
    instanceChargeType?: pulumi.Input<string>;
    kibanaNodeSpec?: pulumi.Input<string>;
    kibanaPrivateSecurityGroupId?: pulumi.Input<string>;
    kibanaPrivateWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    kibanaWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    kmsEncryptedPassword?: pulumi.Input<string>;
    kmsEncryptionContext?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    masterNodeDiskType?: pulumi.Input<string>;
    masterNodeSpec?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    privateWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    protocol?: pulumi.Input<string>;
    publicWhitelists?: pulumi.Input<pulumi.Input<string>[]>;
    renewStatus?: pulumi.Input<string>;
    renewalDurationUnit?: pulumi.Input<string>;
    resourceGroupId?: pulumi.Input<string>;
    settingConfig?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    timeouts?: pulumi.Input<inputs.ElasticsearchInstanceTimeouts>;
    version: pulumi.Input<string>;
    vswitchId: pulumi.Input<string>;
    warmNodeAmount?: pulumi.Input<number>;
    warmNodeDiskEncrypted?: pulumi.Input<boolean>;
    warmNodeDiskSize?: pulumi.Input<number>;
    warmNodeDiskType?: pulumi.Input<string>;
    warmNodeSpec?: pulumi.Input<string>;
    zoneCount?: pulumi.Input<number>;
}
