// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AckOneClusterNetwork {
    securityGroupIds: string[];
    vpcId: string;
    vswitches: string[];
}

export interface AckOneClusterTimeouts {
    create?: string;
    delete?: string;
}

export interface ActiontrailGlobalEventsStorageRegionTimeouts {
    update?: string;
}

export interface ActiontrailHistoryDeliveryJobTimeouts {
    create?: string;
    delete?: string;
}

export interface ActiontrailTimeouts {
    create?: string;
    update?: string;
}

export interface ActiontrailTrailTimeouts {
    create?: string;
    update?: string;
}

export interface AdbClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AdbDbClusterLakeVersionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AdbDbClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AdbLakeAccountAccountPrivilege {
    privilegeObject?: outputs.AdbLakeAccountAccountPrivilegePrivilegeObject;
    privilegeType?: string;
    privileges?: string[];
}

export interface AdbLakeAccountAccountPrivilegePrivilegeObject {
    column: string;
    database: string;
    table: string;
}

export interface AdbLakeAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AdbResourceGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbAclAclEntry {
    description: string;
    entry: string;
    status: string;
}

export interface AlbAclEntryAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlbAclTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbAscriptExtAttribute {
    attributeKey: string;
    attributeValue: string;
}

export interface AlbAscriptTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbHealthCheckTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbListenerAccessLogTracingConfig {
    tracingEnabled?: boolean;
    tracingSample?: number;
    tracingType?: string;
}

export interface AlbListenerAclAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlbListenerAclConfig {
    aclRelations?: outputs.AlbListenerAclConfigAclRelation[];
    aclType: string;
}

export interface AlbListenerAclConfigAclRelation {
    aclId: string;
    status: string;
}

export interface AlbListenerAdditionalCertificateAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlbListenerCertificates {
    certificateId?: string;
}

export interface AlbListenerDefaultAction {
    forwardGroupConfig: outputs.AlbListenerDefaultActionForwardGroupConfig;
    type: string;
}

export interface AlbListenerDefaultActionForwardGroupConfig {
    serverGroupTuples: outputs.AlbListenerDefaultActionForwardGroupConfigServerGroupTuple[];
}

export interface AlbListenerDefaultActionForwardGroupConfigServerGroupTuple {
    serverGroupId: string;
}

export interface AlbListenerQuicConfig {
    quicListenerId?: string;
    quicUpgradeEnabled: boolean;
}

export interface AlbListenerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbListenerXForwardedForConfig {
    xForwardedForClientCertClientVerifyAlias?: string;
    xForwardedForClientCertClientVerifyEnabled: boolean;
    xForwardedForClientCertFingerPrintAlias?: string;
    xForwardedForClientCertFingerPrintEnabled: boolean;
    xForwardedForClientCertIssuerDnAlias?: string;
    xForwardedForClientCertIssuerDnEnabled: boolean;
    xForwardedForClientCertSubjectDnAlias?: string;
    xForwardedForClientCertSubjectDnEnabled: boolean;
    xForwardedForClientSourceIpsEnabled?: boolean;
    xForwardedForClientSourceIpsTrusted?: string;
    xForwardedForClientSrcPortEnabled: boolean;
    xForwardedForEnabled: boolean;
    xForwardedForProtoEnabled: boolean;
    xForwardedForSlbIdEnabled: boolean;
    xForwardedForSlbPortEnabled: boolean;
}

export interface AlbListenerXforwardedForConfig {
    xforwardedforclientcertIssuerdnalias?: string;
    xforwardedforclientcertIssuerdnenabled: boolean;
    xforwardedforclientcertclientverifyalias?: string;
    xforwardedforclientcertclientverifyenabled: boolean;
    xforwardedforclientcertfingerprintalias?: string;
    xforwardedforclientcertfingerprintenabled: boolean;
    xforwardedforclientcertsubjectdnalias?: string;
    xforwardedforclientcertsubjectdnenabled: boolean;
    xforwardedforclientsrcportenabled: boolean;
    xforwardedforenabled: boolean;
    xforwardedforprotoenabled: boolean;
    xforwardedforslbidenabled: boolean;
    xforwardedforslbportenabled: boolean;
}

export interface AlbLoadBalancerAccessLogConfig {
    logProject: string;
    logStore: string;
}

export interface AlbLoadBalancerCommonBandwidthPackageAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlbLoadBalancerLoadBalancerBillingConfig {
    payType: string;
}

export interface AlbLoadBalancerModificationProtectionConfig {
    reason: string;
    status: string;
}

export interface AlbLoadBalancerSecurityGroupAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlbLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbLoadBalancerZoneMapping {
    loadBalancerAddresses: outputs.AlbLoadBalancerZoneMappingLoadBalancerAddress[];
    vswitchId: string;
    zoneId: string;
}

export interface AlbLoadBalancerZoneMappingLoadBalancerAddress {
    address: string;
    allocationId: string;
    eipType: string;
    ipv6Address: string;
}

export interface AlbRuleRuleAction {
    corsConfig?: outputs.AlbRuleRuleActionCorsConfig;
    fixedResponseConfig?: outputs.AlbRuleRuleActionFixedResponseConfig;
    forwardGroupConfig?: outputs.AlbRuleRuleActionForwardGroupConfig;
    insertHeaderConfig?: outputs.AlbRuleRuleActionInsertHeaderConfig;
    order: number;
    redirectConfig?: outputs.AlbRuleRuleActionRedirectConfig;
    removeHeaderConfig?: outputs.AlbRuleRuleActionRemoveHeaderConfig;
    rewriteConfig?: outputs.AlbRuleRuleActionRewriteConfig;
    trafficLimitConfig?: outputs.AlbRuleRuleActionTrafficLimitConfig;
    trafficMirrorConfig?: outputs.AlbRuleRuleActionTrafficMirrorConfig;
    type: string;
}

export interface AlbRuleRuleActionCorsConfig {
    allowCredentials?: string;
    allowHeaders?: string[];
    allowMethods?: string[];
    allowOrigins?: string[];
    exposeHeaders?: string[];
    maxAge?: number;
}

export interface AlbRuleRuleActionFixedResponseConfig {
    content: string;
    contentType?: string;
    httpCode?: string;
}

export interface AlbRuleRuleActionForwardGroupConfig {
    serverGroupStickySession?: outputs.AlbRuleRuleActionForwardGroupConfigServerGroupStickySession;
    serverGroupTuples?: outputs.AlbRuleRuleActionForwardGroupConfigServerGroupTuple[];
}

export interface AlbRuleRuleActionForwardGroupConfigServerGroupStickySession {
    enabled: boolean;
    timeout: number;
}

export interface AlbRuleRuleActionForwardGroupConfigServerGroupTuple {
    serverGroupId: string;
    weight?: number;
}

export interface AlbRuleRuleActionInsertHeaderConfig {
    key?: string;
    value?: string;
    valueType?: string;
}

export interface AlbRuleRuleActionRedirectConfig {
    host?: string;
    httpCode?: string;
    path?: string;
    port?: string;
    protocol?: string;
    query?: string;
}

export interface AlbRuleRuleActionRemoveHeaderConfig {
    key?: string;
}

export interface AlbRuleRuleActionRewriteConfig {
    host?: string;
    path?: string;
    query?: string;
}

export interface AlbRuleRuleActionTrafficLimitConfig {
    perIpQps?: number;
    qps?: number;
}

export interface AlbRuleRuleActionTrafficMirrorConfig {
    mirrorGroupConfig?: outputs.AlbRuleRuleActionTrafficMirrorConfigMirrorGroupConfig;
    targetType?: string;
}

export interface AlbRuleRuleActionTrafficMirrorConfigMirrorGroupConfig {
    serverGroupTuples?: outputs.AlbRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple[];
}

export interface AlbRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple {
    serverGroupId?: string;
}

export interface AlbRuleRuleCondition {
    cookieConfig?: outputs.AlbRuleRuleConditionCookieConfig;
    headerConfig?: outputs.AlbRuleRuleConditionHeaderConfig;
    hostConfig?: outputs.AlbRuleRuleConditionHostConfig;
    methodConfig?: outputs.AlbRuleRuleConditionMethodConfig;
    pathConfig?: outputs.AlbRuleRuleConditionPathConfig;
    queryStringConfig?: outputs.AlbRuleRuleConditionQueryStringConfig;
    responseHeaderConfig?: outputs.AlbRuleRuleConditionResponseHeaderConfig;
    responseStatusCodeConfig?: outputs.AlbRuleRuleConditionResponseStatusCodeConfig;
    sourceIpConfig?: outputs.AlbRuleRuleConditionSourceIpConfig;
    type: string;
}

export interface AlbRuleRuleConditionCookieConfig {
    values?: outputs.AlbRuleRuleConditionCookieConfigValue[];
}

export interface AlbRuleRuleConditionCookieConfigValue {
    key?: string;
    value?: string;
}

export interface AlbRuleRuleConditionHeaderConfig {
    key?: string;
    values?: string[];
}

export interface AlbRuleRuleConditionHostConfig {
    values?: string[];
}

export interface AlbRuleRuleConditionMethodConfig {
    values?: string[];
}

export interface AlbRuleRuleConditionPathConfig {
    values?: string[];
}

export interface AlbRuleRuleConditionQueryStringConfig {
    values?: outputs.AlbRuleRuleConditionQueryStringConfigValue[];
}

export interface AlbRuleRuleConditionQueryStringConfigValue {
    key?: string;
    value?: string;
}

export interface AlbRuleRuleConditionResponseHeaderConfig {
    key?: string;
    values?: string[];
}

export interface AlbRuleRuleConditionResponseStatusCodeConfig {
    values?: string[];
}

export interface AlbRuleRuleConditionSourceIpConfig {
    values?: string[];
}

export interface AlbRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlbSecurityPolicyTimeouts {
    update?: string;
}

export interface AlbServerGroupHealthCheckConfig {
    healthCheckCodes: string[];
    healthCheckConnectPort: number;
    healthCheckEnabled: boolean;
    healthCheckHost: string;
    healthCheckHttpVersion: string;
    healthCheckInterval: number;
    healthCheckMethod: string;
    healthCheckPath: string;
    healthCheckProtocol: string;
    healthCheckTimeout: number;
    healthyThreshold: number;
    unhealthyThreshold: number;
}

export interface AlbServerGroupServer {
    description?: string;
    port?: number;
    remoteIpEnabled: boolean;
    serverId: string;
    serverIp: string;
    serverType: string;
    status: string;
    weight?: number;
}

export interface AlbServerGroupStickySessionConfig {
    cookie: string;
    cookieTimeout: number;
    stickySessionEnabled?: boolean;
    stickySessionType: string;
}

export interface AlbServerGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlidnsAccessStrategyDefaultAddrPool {
    addrPoolId: string;
    lbaWeight?: number;
}

export interface AlidnsAccessStrategyFailoverAddrPool {
    addrPoolId?: string;
    lbaWeight?: number;
}

export interface AlidnsAccessStrategyLine {
    lineCode?: string;
}

export interface AlidnsAddressPoolAddress {
    address: string;
    attributeInfo: string;
    lbaWeight?: number;
    mode: string;
    remark?: string;
}

export interface AlidnsCustomLineIpSegmentList {
    endIp: string;
    startIp: string;
}

export interface AlidnsDomainTimeouts {
    delete?: string;
}

export interface AlidnsGtmInstanceAlertConfig {
    dingtalkNotice?: boolean;
    emailNotice?: boolean;
    noticeType?: string;
    smsNotice?: boolean;
}

export interface AlidnsMonitorConfigIspCityNode {
    cityCode: string;
    ispCode: string;
}

export interface AlidnsRecordTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenAuditCallbackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenBizTypeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenCallbackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenImageLibTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenKeywordLibTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AligreenOssStockTaskTimeouts {
    create?: string;
    delete?: string;
}

export interface AlikafkaInstanceAllowedIpAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface AlikafkaInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlikafkaTopicTimeouts {
    create?: string;
}

export interface AmqpInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayAccessControlListAclEntry {
    aclEntryComment?: string;
    aclEntryIp?: string;
}

export interface ApiGatewayAccessControlListTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayAclEntryAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayApiConstantParameter {
    description?: string;
    in: string;
    name: string;
    value: string;
}

export interface ApiGatewayApiFcServiceConfig {
    arnRole: string;
    functionBaseUrl?: string;
    functionName?: string;
    functionType?: string;
    method: string;
    onlyBusinessPath?: boolean;
    path?: string;
    qualifier?: string;
    region: string;
    serviceName?: string;
    timeout: number;
}

export interface ApiGatewayApiHttpServiceConfig {
    address: string;
    aoneName?: string;
    contentTypeCategory: string;
    contentTypeValue: string;
    method: string;
    path: string;
    timeout: number;
}

export interface ApiGatewayApiHttpVpcServiceConfig {
    aoneName?: string;
    contentTypeCategory: string;
    contentTypeValue: string;
    method: string;
    name: string;
    path: string;
    timeout: number;
    vpcScheme?: string;
}

export interface ApiGatewayApiMockServiceConfig {
    aoneName?: string;
    result: string;
}

export interface ApiGatewayApiRequestConfig {
    bodyFormat?: string;
    method: string;
    mode: string;
    path: string;
    protocol: string;
}

export interface ApiGatewayApiRequestParameter {
    defaultValue?: string;
    description?: string;
    in: string;
    inService: string;
    name: string;
    nameService: string;
    required: string;
    type: string;
}

export interface ApiGatewayApiSystemParameter {
    in: string;
    name: string;
    nameService: string;
}

export interface ApiGatewayInstanceAclAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayInstanceZoneVswitchSecurityGroup {
    cidrBlock: string;
    securityGroup: string;
    vswitchId: string;
    zoneId: string;
}

export interface ApiGatewayLogConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayModelTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ApiGatewayPluginTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsAddonReleaseTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsDispatchRuleGroupRule {
    groupId: number;
    groupInterval: number;
    groupWaitTime: number;
    groupingFields: string[];
    repeatInterval: number;
}

export interface ArmsDispatchRuleLabelMatchExpressionGrid {
    labelMatchExpressionGroups: outputs.ArmsDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
}

export interface ArmsDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
    labelMatchExpressions: outputs.ArmsDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
}

export interface ArmsDispatchRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
    key: string;
    operator: string;
    value: string;
}

export interface ArmsDispatchRuleNotifyRule {
    notifyChannels: string[];
    notifyObjects: outputs.ArmsDispatchRuleNotifyRuleNotifyObject[];
}

export interface ArmsDispatchRuleNotifyRuleNotifyObject {
    name: string;
    notifyObjectId: string;
    notifyType: string;
}

export interface ArmsEnvCustomJobTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsEnvFeatureTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsEnvPodMonitorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsEnvServiceMonitorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsEnvironmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsGrafanaWorkspaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsIntegrationExporterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsPrometheusAlertRuleAnnotation {
    name?: string;
    value?: string;
}

export interface ArmsPrometheusAlertRuleLabel {
    name?: string;
    value?: string;
}

export interface ArmsPrometheusMonitoringTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsPrometheusTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsRemoteWriteTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArmsSyntheticTaskAvailableAssertion {
    expect: string;
    operator: string;
    target?: string;
    type: string;
}

export interface ArmsSyntheticTaskCommonSetting {
    customHost?: outputs.ArmsSyntheticTaskCommonSettingCustomHost;
    ipType?: number;
    isOpenTrace?: boolean;
    monitorSamples?: number;
    traceClientType?: number;
    xtraceRegion?: string;
}

export interface ArmsSyntheticTaskCommonSettingCustomHost {
    hosts: outputs.ArmsSyntheticTaskCommonSettingCustomHostHost[];
    selectType: number;
}

export interface ArmsSyntheticTaskCommonSettingCustomHostHost {
    domain: string;
    ipType: number;
    ips: string[];
}

export interface ArmsSyntheticTaskCustomPeriod {
    endHour?: number;
    startHour?: number;
}

export interface ArmsSyntheticTaskMonitor {
    cityCode: string;
    clientType: number;
    operatorCode: string;
}

export interface ArmsSyntheticTaskMonitorConf {
    apiHttp?: outputs.ArmsSyntheticTaskMonitorConfApiHttp;
    fileDownload?: outputs.ArmsSyntheticTaskMonitorConfFileDownload;
    netDns?: outputs.ArmsSyntheticTaskMonitorConfNetDns;
    netIcmp?: outputs.ArmsSyntheticTaskMonitorConfNetIcmp;
    netTcp?: outputs.ArmsSyntheticTaskMonitorConfNetTcp;
    stream?: outputs.ArmsSyntheticTaskMonitorConfStream;
    website?: outputs.ArmsSyntheticTaskMonitorConfWebsite;
}

export interface ArmsSyntheticTaskMonitorConfApiHttp {
    connectTimeout?: number;
    method?: string;
    requestBody?: outputs.ArmsSyntheticTaskMonitorConfApiHttpRequestBody;
    requestHeaders?: {[key: string]: string};
    targetUrl: string;
    timeout?: number;
}

export interface ArmsSyntheticTaskMonitorConfApiHttpRequestBody {
    content?: string;
    type?: string;
}

export interface ArmsSyntheticTaskMonitorConfFileDownload {
    connectionTimeout?: number;
    customHeaderContent?: {[key: string]: string};
    downloadKernel?: number;
    ignoreCertificateAuthError?: number;
    ignoreCertificateCanceledError?: number;
    ignoreCertificateOutOfDateError?: number;
    ignoreCertificateStatusError?: number;
    ignoreCertificateUntrustworthyError?: number;
    ignoreCertificateUsingError?: number;
    ignoreInvalidHostError?: number;
    monitorTimeout?: number;
    quickProtocol?: number;
    redirection?: number;
    targetUrl: string;
    transmissionSize?: number;
    validateKeywords?: string;
    verifyWay?: number;
    whiteList?: string;
}

export interface ArmsSyntheticTaskMonitorConfNetDns {
    dnsServerIpType?: number;
    nsServer?: string;
    queryMethod?: number;
    targetUrl: string;
    timeout?: number;
}

export interface ArmsSyntheticTaskMonitorConfNetIcmp {
    interval?: number;
    packageNum?: number;
    packageSize?: number;
    splitPackage?: boolean;
    targetUrl: string;
    timeout?: number;
    tracertEnable?: boolean;
    tracertNumMax?: number;
    tracertTimeout?: number;
}

export interface ArmsSyntheticTaskMonitorConfNetTcp {
    connectTimes?: number;
    interval?: number;
    targetUrl: string;
    timeout?: number;
    tracertEnable?: boolean;
    tracertNumMax?: number;
    tracertTimeout?: number;
}

export interface ArmsSyntheticTaskMonitorConfStream {
    customHeaderContent?: {[key: string]: string};
    playerType?: number;
    streamAddressType?: number;
    streamMonitorTimeout?: number;
    streamType?: number;
    targetUrl?: string;
    whiteList?: string;
}

export interface ArmsSyntheticTaskMonitorConfWebsite {
    automaticScrolling?: number;
    customHeader?: number;
    customHeaderContent?: {[key: string]: string};
    disableCache?: number;
    disableCompression?: number;
    dnsHijackWhitelist?: string;
    elementBlacklist?: string;
    filterInvalidIp?: number;
    flowHijackJumpTimes?: number;
    flowHijackLogo?: string;
    ignoreCertificateError?: number;
    monitorTimeout?: number;
    pageTamper?: string;
    redirection?: number;
    slowElementThreshold?: number;
    targetUrl: string;
    verifyStringBlacklist?: string;
    verifyStringWhitelist?: string;
    waitCompletionTime?: number;
}

export interface ArmsSyntheticTaskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AutoProvisioningGroupLaunchTemplateConfig {
    instanceType?: string;
    maxPrice: string;
    priority: string;
    vswitchId: string;
    weightedCapacity: string;
}

export interface BastionhostHostAccountShareKeyAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface BastionhostHostShareKeyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BastionhostInstanceAdAuthServer {
    account: string;
    baseDn: string;
    domain: string;
    emailMapping?: string;
    filter?: string;
    isSsl: boolean;
    mobileMapping?: string;
    nameMapping?: string;
    password: string;
    port: number;
    server: string;
    standbyServer?: string;
}

export interface BastionhostInstanceLdapAuthServer {
    account: string;
    baseDn: string;
    emailMapping?: string;
    filter?: string;
    isSsl?: boolean;
    loginNameMapping?: string;
    mobileMapping?: string;
    nameMapping?: string;
    password: string;
    port: number;
    server: string;
    standbyServer?: string;
}

export interface BastionhostInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BastionhostUserTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BpStudioApplicationInstance {
    id?: string;
    nodeName?: string;
    nodeType?: string;
}

export interface BpStudioApplicationTimeouts {
    create?: string;
    delete?: string;
}

export interface CassandraClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CassandraDataCenterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CddcDedicatedHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CddcDedicatedPropreHostEcsClassList {
    dataDiskPerformanceLevel?: string;
    diskCapacity?: number;
    diskCount?: number;
    diskType?: string;
    instanceType: string;
    sysDiskCapacity: number;
    sysDiskType: string;
    systemDiskPerformanceLevel?: string;
}

export interface CddcDedicatedPropreHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdnDomainAuthConfig {
    authType?: string;
    masterKey: string;
    slaveKey: string;
    timeout?: number;
}

export interface CdnDomainCacheConfig {
    cacheContent: string;
    cacheId: string;
    cacheType: string;
    ttl: number;
    weight?: number;
}

export interface CdnDomainCertificateConfig {
    privateKey?: string;
    serverCertificate?: string;
    serverCertificateStatus?: string;
}

export interface CdnDomainConfigFunctionArg {
    argName: string;
    argValue: string;
}

export interface CdnDomainConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdnDomainHttpHeaderConfig {
    headerId: string;
    headerKey: string;
    headerValue: string;
}

export interface CdnDomainNewCertificateConfig {
    certId: string;
    certName: string;
    certRegion: string;
    certType: string;
    forceSet?: string;
    privateKey?: string;
    serverCertificate: string;
    serverCertificateStatus?: string;
}

export interface CdnDomainNewSource {
    content?: string;
    port?: number;
    priority?: number;
    type?: string;
    weight?: number;
}

export interface CdnDomainNewTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdnDomainPage404Config {
    customPageUrl?: string;
    errorCode: string;
    pageType?: string;
}

export interface CdnDomainParameterFilterConfig {
    enable?: string;
    hashKeyArgs: string[];
}

export interface CdnDomainReferConfig {
    allowEmpty?: string;
    referLists: string[];
    referType?: string;
}

export interface CdnFcTriggerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdnRealTimeLogDeliveryTimeouts {
    create?: string;
}

export interface CenBandwidthLimitTimeouts {
    delete?: string;
    update?: string;
}

export interface CenBandwidthPackageAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CenBandwidthPackageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenChildInstanceRouteEntryToAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CenInstanceAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CenInstanceTimeouts {
    create?: string;
    delete?: string;
}

export interface CenInterRegionTrafficQosPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenInterRegionTrafficQosQueueTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenPrivateZoneTimeouts {
    create?: string;
}

export interface CenRouteMapTimeouts {
    create?: string;
}

export interface CenRouteServiceTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTrafficMarkingPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouteTableAggregationTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterCidrTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterEcrAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterGrantAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterMulticastDomainAssociationTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterMulticastDomainMemberTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterMulticastDomainPeerMemberTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterMulticastDomainSourceTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterMulticastDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterPeerAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterPrefixListAssociationTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterRouteEntryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterRouteTableAssociationTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterRouteTablePropagationTimeouts {
    create?: string;
    delete?: string;
}

export interface CenTransitRouterRouteTableTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterVbrAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterVpcAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterVpcAttachmentZoneMapping {
    vswitchId?: string;
    zoneId?: string;
}

export interface CenTransitRouterVpnAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CenTransitRouterVpnAttachmentZone {
    zoneId: string;
}

export interface CenVbrHealthCheckTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ChatbotPublishTaskTimeouts {
    create?: string;
}

export interface ClickHouseAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClickHouseBackupPolicyTimeouts {
    create?: string;
}

export interface ClickHouseDbClusterDbClusterAccessWhiteList {
    dbClusterIpArrayAttribute?: string;
    dbClusterIpArrayName?: string;
    securityIpList?: string;
}

export interface ClickHouseDbClusterMultiZoneVswitchList {
    vswitchId: string;
    zoneId: string;
}

export interface ClickHouseDbClusterTimeouts {
    create?: string;
    update?: string;
}

export interface CloudFirewallAddressBookEcsTag {
    tagKey?: string;
    tagValue?: string;
}

export interface CloudFirewallInstanceMemberTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudFirewallNatFirewallControlPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudFirewallNatFirewallNatRouteEntryList {
    destinationCidr: string;
    nexthopId: string;
    nexthopType: string;
    routeTableId: string;
}

export interface CloudFirewallNatFirewallTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudFirewallVpcCenTrFirewallTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudFirewallVpcFirewallCenLocalVpc {
    attachmentId: string;
    attachmentName: string;
    defendCidrLists: string[];
    eniLists: outputs.CloudFirewallVpcFirewallCenLocalVpcEniList[];
    manualVswitchId: string;
    networkInstanceId: string;
    networkInstanceName: string;
    networkInstanceType: string;
    ownerId: string;
    regionNo: string;
    routeMode: string;
    supportManualMode: string;
    transitRouterId: string;
    transitRouterType: string;
    vpcCidrTableLists: outputs.CloudFirewallVpcFirewallCenLocalVpcVpcCidrTableList[];
    vpcId: string;
    vpcName: string;
}

export interface CloudFirewallVpcFirewallCenLocalVpcEniList {
    eniId: string;
    eniPrivateIpAddress: string;
}

export interface CloudFirewallVpcFirewallCenLocalVpcVpcCidrTableList {
    routeEntryLists: outputs.CloudFirewallVpcFirewallCenLocalVpcVpcCidrTableListRouteEntryList[];
    routeTableId: string;
}

export interface CloudFirewallVpcFirewallCenLocalVpcVpcCidrTableListRouteEntryList {
    destinationCidr: string;
    nextHopInstanceId: string;
}

export interface CloudFirewallVpcFirewallCenTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudFirewallVpcFirewallControlPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudFirewallVpcFirewallLocalVpc {
    eniId: string;
    eniPrivateIpAddress: string;
    localVpcCidrTableLists: outputs.CloudFirewallVpcFirewallLocalVpcLocalVpcCidrTableList[];
    regionNo: string;
    routerInterfaceId: string;
    vpcId: string;
    vpcName: string;
}

export interface CloudFirewallVpcFirewallLocalVpcLocalVpcCidrTableList {
    localRouteEntryLists: outputs.CloudFirewallVpcFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList[];
    localRouteTableId: string;
}

export interface CloudFirewallVpcFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList {
    localDestinationCidr: string;
    localNextHopInstanceId: string;
}

export interface CloudFirewallVpcFirewallPeerVpc {
    eniId: string;
    eniPrivateIpAddress: string;
    peerVpcCidrTableLists: outputs.CloudFirewallVpcFirewallPeerVpcPeerVpcCidrTableList[];
    regionNo: string;
    routerInterfaceId: string;
    vpcId: string;
    vpcName: string;
}

export interface CloudFirewallVpcFirewallPeerVpcPeerVpcCidrTableList {
    peerRouteEntryLists: outputs.CloudFirewallVpcFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList[];
    peerRouteTableId: string;
}

export interface CloudFirewallVpcFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList {
    peerDestinationCidr: string;
    peerNextHopInstanceId: string;
}

export interface CloudFirewallVpcFirewallTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudMonitorServiceBasicPublicTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudMonitorServiceEnterprisePublicTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudMonitorServiceGroupMonitoringAgentProcessAlertConfig {
    comparisonOperator: string;
    effectiveInterval?: string;
    escalationsLevel: string;
    silenceTime?: number;
    statistics: string;
    targetLists?: outputs.CloudMonitorServiceGroupMonitoringAgentProcessAlertConfigTargetList[];
    threshold: string;
    times: string;
    webhook?: string;
}

export interface CloudMonitorServiceGroupMonitoringAgentProcessAlertConfigTargetList {
    arn?: string;
    jsonParams?: string;
    level?: string;
    targetListId?: string;
}

export interface CloudMonitorServiceGroupMonitoringAgentProcessMatchExpress {
    function: string;
    name: string;
    value: string;
}

export interface CloudMonitorServiceGroupMonitoringAgentProcessTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudMonitorServiceHybridDoubleWriteTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudMonitorServiceMonitoringAgentProcessTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudSsoAccessAssignmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudSsoAccessConfigurationPermissionPolicy {
    permissionPolicyDocument?: string;
    permissionPolicyName: string;
    permissionPolicyType: string;
}

export interface CloudSsoAccessConfigurationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudSsoDirectorySamlIdentityProviderConfiguration {
    encodedMetadataDocument: string;
    ssoStatus: string;
}

export interface CloudStorageGatewayExpressSyncShareAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudStorageGatewayExpressSyncTimeouts {
    delete?: string;
}

export interface CloudStorageGatewayGatewayBlockVolumeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudStorageGatewayGatewayFileShareTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudStorageGatewayGatewaySmbUserTimeouts {
    create?: string;
    delete?: string;
}

export interface CloudStorageGatewayGatewayTimeouts {
    create?: string;
}

export interface CmsAlarmCompositeExpression {
    expressionListJoin?: string;
    expressionLists?: outputs.CmsAlarmCompositeExpressionExpressionList[];
    expressionRaw?: string;
    level?: string;
    times?: number;
}

export interface CmsAlarmCompositeExpressionExpressionList {
    comparisonOperator?: string;
    metricName?: string;
    period?: string;
    statistics?: string;
    threshold?: string;
}

export interface CmsAlarmEscalationsCritical {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsAlarmEscalationsInfo {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsAlarmEscalationsWarn {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsAlarmPrometheus {
    annotations?: {[key: string]: string};
    level: string;
    promQl?: string;
    times: number;
}

export interface CmsAlarmTarget {
    arn?: string;
    jsonParams?: string;
    level?: string;
    targetId?: string;
}

export interface CmsAlarmTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsDynamicTagGroupMatchExpress {
    tagValue: string;
    tagValueMatchFunction: string;
}

export interface CmsEventRuleContactParameter {
    contactGroupName?: string;
    contactParametersId?: string;
    level?: string;
}

export interface CmsEventRuleEventPattern {
    eventTypeLists?: string[];
    levelLists?: string[];
    nameLists?: string[];
    product: string;
    sqlFilter?: string;
}

export interface CmsEventRuleFcParameter {
    arn: string;
    fcParametersId?: string;
    functionName?: string;
    region?: string;
    serviceName?: string;
}

export interface CmsEventRuleMnsParameter {
    arn: string;
    mnsParametersId?: string;
    queue?: string;
    region?: string;
    topic?: string;
}

export interface CmsEventRuleOpenApiParameter {
    action?: string;
    arn: string;
    openApiParametersId?: string;
    product?: string;
    region?: string;
    role?: string;
    version?: string;
}

export interface CmsEventRuleSlsParameter {
    arn: string;
    logStore?: string;
    project?: string;
    region?: string;
    slsParametersId?: string;
}

export interface CmsEventRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsEventRuleWebhookParameter {
    method?: string;
    protocol?: string;
    url?: string;
    webhookParametersId?: string;
}

export interface CmsGroupMetricRuleEscalations {
    critical?: outputs.CmsGroupMetricRuleEscalationsCritical;
    info?: outputs.CmsGroupMetricRuleEscalationsInfo;
    warn?: outputs.CmsGroupMetricRuleEscalationsWarn;
}

export interface CmsGroupMetricRuleEscalationsCritical {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsGroupMetricRuleEscalationsInfo {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsGroupMetricRuleEscalationsWarn {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: number;
}

export interface CmsGroupMetricRuleTarget {
    arn?: string;
    id?: string;
    jsonParams?: string;
    level?: string;
}

export interface CmsGroupMetricRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsHybridMonitorFcTaskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsHybridMonitorSlsTaskAttachLabel {
    name?: string;
    value?: string;
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfig {
    expresses?: outputs.CmsHybridMonitorSlsTaskSlsProcessConfigExpress[];
    filter?: outputs.CmsHybridMonitorSlsTaskSlsProcessConfigFilter;
    groupBies?: outputs.CmsHybridMonitorSlsTaskSlsProcessConfigGroupBy[];
    statistics?: outputs.CmsHybridMonitorSlsTaskSlsProcessConfigStatistic[];
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfigExpress {
    alias?: string;
    express?: string;
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfigFilter {
    filters?: outputs.CmsHybridMonitorSlsTaskSlsProcessConfigFilterFilter[];
    relation?: string;
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfigFilterFilter {
    operator?: string;
    slsKeyName?: string;
    value?: string;
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfigGroupBy {
    alias?: string;
    slsKeyName?: string;
}

export interface CmsHybridMonitorSlsTaskSlsProcessConfigStatistic {
    alias?: string;
    function?: string;
    parameterOne?: string;
    parameterTwo?: string;
    slsKeyName?: string;
}

export interface CmsHybridMonitorSlsTaskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsMetricRuleBlackListMetric {
    metricName: string;
    resource?: string;
}

export interface CmsMetricRuleTemplateAlertTemplate {
    category: string;
    escalations?: outputs.CmsMetricRuleTemplateAlertTemplateEscalations;
    metricName: string;
    namespace: string;
    ruleName: string;
    webhook?: string;
}

export interface CmsMetricRuleTemplateAlertTemplateEscalations {
    critical?: outputs.CmsMetricRuleTemplateAlertTemplateEscalationsCritical;
    info?: outputs.CmsMetricRuleTemplateAlertTemplateEscalationsInfo;
    warn?: outputs.CmsMetricRuleTemplateAlertTemplateEscalationsWarn;
}

export interface CmsMetricRuleTemplateAlertTemplateEscalationsCritical {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: string;
}

export interface CmsMetricRuleTemplateAlertTemplateEscalationsInfo {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: string;
}

export interface CmsMetricRuleTemplateAlertTemplateEscalationsWarn {
    comparisonOperator?: string;
    statistics?: string;
    threshold?: string;
    times?: string;
}

export interface CmsMonitorGroupInstancesInstance {
    category: string;
    instanceId: string;
    instanceName: string;
    regionId: string;
}

export interface CmsNamespaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsSiteMonitorIspCity {
    city: string;
    isp: string;
}

export interface CmsSiteMonitorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CmsSlsGroupSlsGroupConfig {
    slsLogstore: string;
    slsProject: string;
    slsRegion: string;
    slsUserId?: string;
}

export interface CmsSlsGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CommonBandwidthPackageAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CommonBandwidthPackageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ComputeNestServiceInstanceCommodity {
    payPeriod?: number;
    payPeriodUnit?: string;
}

export interface ComputeNestServiceInstanceOperationMetadata {
    operatedServiceInstanceId?: string;
    operationEndTime?: string;
    operationStartTime?: string;
    resources: string;
}

export interface ComputeNestServiceInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigAggregateCompliancePackConfigRule {
    configRuleParameters?: outputs.ConfigAggregateCompliancePackConfigRuleConfigRuleParameter[];
    managedRuleIdentifier: string;
}

export interface ConfigAggregateCompliancePackConfigRuleConfigRuleParameter {
    parameterName?: string;
    parameterValue?: string;
}

export interface ConfigAggregateCompliancePackConfigRuleId {
    configRuleId?: string;
}

export interface ConfigAggregateCompliancePackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigAggregateConfigRuleTimeouts {
    create?: string;
    update?: string;
}

export interface ConfigAggregateDeliveryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigAggregatorAggregatorAccount {
    accountId: string;
    accountName: string;
    accountType: string;
}

export interface ConfigAggregatorTimeouts {
    create?: string;
}

export interface ConfigCompliancePackConfigRule {
    configRuleParameters?: outputs.ConfigCompliancePackConfigRuleConfigRuleParameter[];
    managedRuleIdentifier: string;
}

export interface ConfigCompliancePackConfigRuleConfigRuleParameter {
    parameterName?: string;
    parameterValue?: string;
}

export interface ConfigCompliancePackConfigRuleId {
    configRuleId?: string;
}

export interface ConfigCompliancePackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigConfigurationRecorderTimeouts {
    update?: string;
}

export interface ConfigDeliveryChannelTimeouts {
    create?: string;
    update?: string;
}

export interface ConfigDeliveryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigRemediationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigRuleCompliance {
    complianceType: string;
    count: number;
}

export interface ConfigRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerClusterNode {
    eip: string;
    id: string;
    name: string;
    privateIp: string;
    status: string;
}

export interface CopyImageTimeouts {
    create?: string;
    delete?: string;
}

export interface CrChainChainConfig {
    nodes?: outputs.CrChainChainConfigNode[];
    routers?: outputs.CrChainChainConfigRouter[];
}

export interface CrChainChainConfigNode {
    enable?: boolean;
    nodeConfigs?: outputs.CrChainChainConfigNodeNodeConfig[];
    nodeName?: string;
}

export interface CrChainChainConfigNodeNodeConfig {
    denyPolicies?: outputs.CrChainChainConfigNodeNodeConfigDenyPolicy[];
}

export interface CrChainChainConfigNodeNodeConfigDenyPolicy {
    action?: string;
    issueCount?: string;
    issueLevel?: string;
    logic?: string;
}

export interface CrChainChainConfigRouter {
    froms?: outputs.CrChainChainConfigRouterFrom[];
    tos?: outputs.CrChainChainConfigRouterTo[];
}

export interface CrChainChainConfigRouterFrom {
    nodeName?: string;
}

export interface CrChainChainConfigRouterTo {
    nodeName?: string;
}

export interface CrEeInstanceTimeouts {
    create?: string;
}

export interface CrEndpointAclPolicyTimeouts {
    create?: string;
    delete?: string;
}

export interface CrVpcEndpointLinkedVpcTimeouts {
    create?: string;
    delete?: string;
}

export interface CsApplicationService {
    id: string;
    name: string;
    status: string;
    version: string;
}

export interface CsAutoscalingConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsEdgeKubernetesAddon {
    config?: string;
    disabled?: boolean;
    name?: string;
    version?: string;
}

export interface CsEdgeKubernetesLogConfig {
    project?: string;
    type: string;
}

export interface CsEdgeKubernetesTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsEdgeKubernetesWorkerDataDisk {
    autoSnapshotPolicyId?: string;
    category?: string;
    device?: string;
    encrypted?: string;
    kmsKeyId?: string;
    name?: string;
    performanceLevel?: string;
    size?: string;
    snapshotId?: string;
}

export interface CsEdgeKubernetesWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface CsKubernetesAddon {
    config?: string;
    disabled?: boolean;
    name?: string;
    version?: string;
}

export interface CsKubernetesAddonTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsKubernetesAutoscalerNodepool {
    id?: string;
    labels?: string;
    taints?: string;
}

export interface CsKubernetesAutoscalerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsKubernetesDeleteOption {
    deleteMode?: string;
    resourceType?: string;
}

export interface CsKubernetesLogConfig {
    project?: string;
    type: string;
}

export interface CsKubernetesMasterNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface CsKubernetesNodePoolDataDisk {
    autoFormat?: string;
    autoSnapshotPolicyId?: string;
    burstingEnabled?: boolean;
    category?: string;
    device?: string;
    encrypted?: string;
    fileSystem?: string;
    kmsKeyId?: string;
    mountTarget?: string;
    name: string;
    performanceLevel?: string;
    provisionedIops?: number;
    size?: number;
    snapshotId?: string;
}

export interface CsKubernetesNodePoolKubeletConfiguration {
    allowedUnsafeSysctls?: string[];
    containerLogMaxFiles?: string;
    containerLogMaxSize?: string;
    cpuManagerPolicy?: string;
    eventBurst?: string;
    eventRecordQps?: string;
    evictionHard?: {[key: string]: string};
    evictionSoft?: {[key: string]: string};
    evictionSoftGracePeriod?: {[key: string]: string};
    featureGates?: {[key: string]: boolean};
    kubeApiBurst?: string;
    kubeApiQps?: string;
    kubeReserved?: {[key: string]: string};
    maxPods?: string;
    readOnlyPort?: string;
    registryBurst?: string;
    registryPullQps?: string;
    serializeImagePulls?: string;
    systemReserved?: {[key: string]: string};
}

export interface CsKubernetesNodePoolLabel {
    key: string;
    value?: string;
}

export interface CsKubernetesNodePoolManagement {
    autoRepair: boolean;
    autoRepairPolicy?: outputs.CsKubernetesNodePoolManagementAutoRepairPolicy;
    autoUpgrade: boolean;
    autoUpgradePolicy?: outputs.CsKubernetesNodePoolManagementAutoUpgradePolicy;
    autoVulFix: boolean;
    autoVulFixPolicy?: outputs.CsKubernetesNodePoolManagementAutoVulFixPolicy;
    enable?: boolean;
    maxUnavailable?: number;
    /**
     * @deprecated Deprecated
     */
    surge?: number;
    /**
     * @deprecated Deprecated
     */
    surgePercentage?: number;
}

export interface CsKubernetesNodePoolManagementAutoRepairPolicy {
    restartNode: boolean;
}

export interface CsKubernetesNodePoolManagementAutoUpgradePolicy {
    autoUpgradeKubelet: boolean;
}

export interface CsKubernetesNodePoolManagementAutoVulFixPolicy {
    restartNode: boolean;
    vulLevel: string;
}

export interface CsKubernetesNodePoolPrivatePoolOptions {
    privatePoolOptionsId?: string;
    privatePoolOptionsMatchCriteria?: string;
}

export interface CsKubernetesNodePoolRollingPolicy {
    maxParallelism?: number;
}

export interface CsKubernetesNodePoolRolloutPolicy {
    maxUnavailable?: number;
}

export interface CsKubernetesNodePoolScalingConfig {
    eipBandwidth?: number;
    eipInternetChargeType?: string;
    enable?: boolean;
    isBondEip?: boolean;
    maxSize?: number;
    minSize?: number;
    type?: string;
}

export interface CsKubernetesNodePoolSpotPriceLimit {
    instanceType?: string;
    priceLimit?: string;
}

export interface CsKubernetesNodePoolTaint {
    effect?: string;
    key: string;
    value?: string;
}

export interface CsKubernetesNodePoolTeeConfig {
    teeEnable?: boolean;
}

export interface CsKubernetesNodePoolTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsKubernetesPermissionsPermission {
    cluster: string;
    isCustom?: boolean;
    isRamRole?: boolean;
    namespace?: string;
    roleName: string;
    roleType: string;
}

export interface CsKubernetesPermissionsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsKubernetesTaint {
    effect?: string;
    key?: string;
    value?: string;
}

export interface CsKubernetesTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsKubernetesWorkerDataDisk {
    autoSnapshotPolicyId?: string;
    category?: string;
    device?: string;
    encrypted?: string;
    kmsKeyId?: string;
    name?: string;
    performanceLevel?: string;
    size?: string;
    snapshotId?: string;
}

export interface CsKubernetesWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface CsManagedKubernetesAddon {
    config?: string;
    disabled?: boolean;
    name?: string;
    version?: string;
}

export interface CsManagedKubernetesDeleteOption {
    deleteMode?: string;
    resourceType?: string;
}

export interface CsManagedKubernetesLogConfig {
    project?: string;
    type: string;
}

export interface CsManagedKubernetesMaintenanceWindow {
    duration: string;
    enable: boolean;
    maintenanceTime: string;
    weeklyPeriod: string;
}

export interface CsManagedKubernetesRrsaMetadata {
    enabled: boolean;
    ramOidcProviderArn: string;
    ramOidcProviderName: string;
    rrsaOidcIssuerUrl: string;
}

export interface CsManagedKubernetesTaint {
    effect?: string;
    key?: string;
    value?: string;
}

export interface CsManagedKubernetesTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CsManagedKubernetesWorkerDataDisk {
    autoSnapshotPolicyId?: string;
    category?: string;
    device?: string;
    encrypted?: string;
    kmsKeyId?: string;
    name?: string;
    performanceLevel?: string;
    size?: string;
    snapshotId?: string;
}

export interface CsManagedKubernetesWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface CsServerlessKubernetesAddon {
    config?: string;
    disabled?: boolean;
    name?: string;
    version?: string;
}

export interface CsServerlessKubernetesDeleteOption {
    deleteMode?: string;
    resourceType?: string;
}

export interface CsServerlessKubernetesRrsaMetadata {
    enabled: boolean;
    ramOidcProviderArn: string;
    ramOidcProviderName: string;
    rrsaOidcIssuerUrl: string;
}

export interface CsServerlessKubernetesTimeouts {
    create?: string;
    delete?: string;
}

export interface CsSwarmNode {
    eip: string;
    id: string;
    name: string;
    privateIp: string;
    status: string;
}

export interface DasSwitchDasProTimeouts {
    create?: string;
    delete?: string;
}

export interface DataWorksProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbInstanceBabelfishConfig {
    babelfishEnabled: string;
    masterUserPassword: string;
    masterUsername: string;
    migrationMode: string;
}

export interface DbInstanceParameter {
    name: string;
    value: string;
}

export interface DbInstancePgHbaConf {
    address: string;
    database: string;
    mask?: string;
    method: string;
    option?: string;
    priorityId: number;
    type: string;
    user: string;
}

export interface DbInstanceServerlessConfig {
    autoPause?: boolean;
    maxCapacity: number;
    minCapacity: number;
    switchForce?: boolean;
}

export interface DbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbReadonlyInstanceParameter {
    name: string;
    value: string;
}

export interface DbReadonlyInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbfsAutoSnapShotPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbfsInstanceAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface DbfsInstanceEcsList {
    ecsId?: string;
}

export interface DbfsInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DbfsSnapshotTimeouts {
    create?: string;
    delete?: string;
}

export interface DbsBackupPlanTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnDomainConfigFunctionArg {
    argName: string;
    argValue: string;
}

export interface DcdnDomainSource {
    content?: string;
    port: number;
    priority: string;
    type?: string;
    weight: string;
}

export interface DcdnDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnErEnvConf {
    presetCanaryAnhui?: outputs.DcdnErEnvConfPresetCanaryAnhui;
    presetCanaryBeijing?: outputs.DcdnErEnvConfPresetCanaryBeijing;
    presetCanaryChongqing?: outputs.DcdnErEnvConfPresetCanaryChongqing;
    presetCanaryFujian?: outputs.DcdnErEnvConfPresetCanaryFujian;
    presetCanaryGansu?: outputs.DcdnErEnvConfPresetCanaryGansu;
    presetCanaryGuangdong?: outputs.DcdnErEnvConfPresetCanaryGuangdong;
    presetCanaryGuangxi?: outputs.DcdnErEnvConfPresetCanaryGuangxi;
    presetCanaryGuizhou?: outputs.DcdnErEnvConfPresetCanaryGuizhou;
    presetCanaryHainan?: outputs.DcdnErEnvConfPresetCanaryHainan;
    presetCanaryHebei?: outputs.DcdnErEnvConfPresetCanaryHebei;
    presetCanaryHeilongjiang?: outputs.DcdnErEnvConfPresetCanaryHeilongjiang;
    presetCanaryHenan?: outputs.DcdnErEnvConfPresetCanaryHenan;
    presetCanaryHongKong?: outputs.DcdnErEnvConfPresetCanaryHongKong;
    presetCanaryHubei?: outputs.DcdnErEnvConfPresetCanaryHubei;
    presetCanaryHunan?: outputs.DcdnErEnvConfPresetCanaryHunan;
    presetCanaryJiangsu?: outputs.DcdnErEnvConfPresetCanaryJiangsu;
    presetCanaryJiangxi?: outputs.DcdnErEnvConfPresetCanaryJiangxi;
    presetCanaryJilin?: outputs.DcdnErEnvConfPresetCanaryJilin;
    presetCanaryLiaoning?: outputs.DcdnErEnvConfPresetCanaryLiaoning;
    presetCanaryMacau?: outputs.DcdnErEnvConfPresetCanaryMacau;
    presetCanaryNeimenggu?: outputs.DcdnErEnvConfPresetCanaryNeimenggu;
    presetCanaryNingxia?: outputs.DcdnErEnvConfPresetCanaryNingxia;
    presetCanaryOverseas?: outputs.DcdnErEnvConfPresetCanaryOverseas;
    presetCanaryQinghai?: outputs.DcdnErEnvConfPresetCanaryQinghai;
    presetCanaryShaanxi?: outputs.DcdnErEnvConfPresetCanaryShaanxi;
    presetCanaryShandong?: outputs.DcdnErEnvConfPresetCanaryShandong;
    presetCanaryShanghai?: outputs.DcdnErEnvConfPresetCanaryShanghai;
    presetCanaryShanxi?: outputs.DcdnErEnvConfPresetCanaryShanxi;
    presetCanarySichuan?: outputs.DcdnErEnvConfPresetCanarySichuan;
    presetCanaryTaiwan?: outputs.DcdnErEnvConfPresetCanaryTaiwan;
    presetCanaryTianjin?: outputs.DcdnErEnvConfPresetCanaryTianjin;
    presetCanaryXinjiang?: outputs.DcdnErEnvConfPresetCanaryXinjiang;
    presetCanaryXizang?: outputs.DcdnErEnvConfPresetCanaryXizang;
    presetCanaryYunnan?: outputs.DcdnErEnvConfPresetCanaryYunnan;
    presetCanaryZhejiang?: outputs.DcdnErEnvConfPresetCanaryZhejiang;
    production?: outputs.DcdnErEnvConfProduction;
    staging?: outputs.DcdnErEnvConfStaging;
}

export interface DcdnErEnvConfPresetCanaryAnhui {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryBeijing {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryChongqing {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryFujian {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryGansu {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryGuangdong {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryGuangxi {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryGuizhou {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHainan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHebei {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHeilongjiang {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHenan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHongKong {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHubei {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryHunan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryJiangsu {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryJiangxi {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryJilin {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryLiaoning {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryMacau {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryNeimenggu {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryNingxia {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryOverseas {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryQinghai {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryShaanxi {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryShandong {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryShanghai {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryShanxi {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanarySichuan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryTaiwan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryTianjin {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryXinjiang {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryXizang {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryYunnan {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfPresetCanaryZhejiang {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfProduction {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErEnvConfStaging {
    allowedHosts: string[];
    codeRev?: string;
    specName: string;
}

export interface DcdnErTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnIpaDomainSource {
    content: string;
    port: number;
    priority: string;
    type: string;
    weight: number;
}

export interface DcdnIpaDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnKvNamespaceTimeouts {
    create?: string;
    delete?: string;
}

export interface DcdnKvTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnWafDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnWafPolicyDomainAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface DcdnWafPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DcdnWafRuleCondition {
    key: string;
    opValue: string;
    subKey?: string;
    values?: string;
}

export interface DcdnWafRuleRateLimit {
    interval?: number;
    status?: outputs.DcdnWafRuleRateLimitStatus;
    subKey?: string;
    target?: string;
    threshold?: number;
    ttl?: number;
}

export interface DcdnWafRuleRateLimitStatus {
    code?: string;
    count?: number;
    ratio?: number;
}

export interface DcdnWafRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DdosBasicThresholdTimeouts {
    create?: string;
    update?: string;
}

export interface DdosBgpPolicyContent {
    blackIpListExpireAt?: number;
    enableDefense?: boolean;
    enableDropIcmp?: boolean;
    enableIntelligence: boolean;
    fingerPrintRuleLists?: outputs.DdosBgpPolicyContentFingerPrintRuleList[];
    intelligenceLevel: string;
    layer4RuleLists?: outputs.DdosBgpPolicyContentLayer4RuleList[];
    portRuleLists?: outputs.DdosBgpPolicyContentPortRuleList[];
    reflectBlockUdpPortLists?: number[];
    regionBlockCountryLists?: number[];
    regionBlockProvinceLists?: number[];
    sourceBlockLists?: outputs.DdosBgpPolicyContentSourceBlockList[];
    sourceLimit?: outputs.DdosBgpPolicyContentSourceLimit;
    whitenGfbrNets?: boolean;
}

export interface DdosBgpPolicyContentFingerPrintRuleList {
    dstPortEnd: number;
    dstPortStart: number;
    fingerPrintRuleId?: string;
    matchAction: string;
    maxPktLen: number;
    minPktLen: number;
    offset?: number;
    payloadBytes?: string;
    protocol: string;
    rateValue?: number;
    seqNo: number;
    srcPortEnd: number;
    srcPortStart: number;
}

export interface DdosBgpPolicyContentLayer4RuleList {
    action: string;
    conditionLists: outputs.DdosBgpPolicyContentLayer4RuleListConditionList[];
    limited: number;
    match: string;
    method: string;
    name: string;
    priority: number;
}

export interface DdosBgpPolicyContentLayer4RuleListConditionList {
    arg: string;
    depth: number;
    position: number;
}

export interface DdosBgpPolicyContentPortRuleList {
    dstPortEnd: number;
    dstPortStart: number;
    matchAction: string;
    portRuleId?: string;
    protocol: string;
    seqNo: number;
    srcPortEnd: number;
    srcPortStart: number;
}

export interface DdosBgpPolicyContentSourceBlockList {
    blockExpireSeconds: number;
    everySeconds: number;
    exceedLimitTimes: number;
    type: number;
}

export interface DdosBgpPolicyContentSourceLimit {
    bps?: number;
    pps?: number;
    synBps?: number;
    synPps?: number;
}

export interface DdosBgpPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DdosbgpIpTimeouts {
    create?: string;
    delete?: string;
}

export interface DdoscooDomainResourceProxyType {
    proxyPorts?: number[];
    proxyType?: string;
}

export interface DdoscooInstanceTimeouts {
    create?: string;
    delete?: string;
}

export interface DdoscooSchedulerRuleRule {
    priority?: number;
    regionId?: string;
    status: number;
    type?: string;
    value?: string;
    valueType?: number;
}

export interface DdoscooSchedulerRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DfsAccessGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DfsAccessRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DfsFileSystemTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DfsMountPointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DfsVscMountPointInstance {
    instanceId: string;
    status: string;
    vscs: outputs.DfsVscMountPointInstanceVsc[];
}

export interface DfsVscMountPointInstanceVsc {
    vscId: string;
    vscStatus: string;
    vscType: string;
}

export interface DfsVscMountPointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DiskAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface DiskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DmsEnterpriseAuthorityTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DmsEnterpriseInstanceTimeouts {
    create?: string;
}

export interface DmsEnterpriseProxyTimeouts {
    create?: string;
    delete?: string;
}

export interface DnsDomainTimeouts {
    delete?: string;
}

export interface DrdsInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DrdsPolardbxInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DtsInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DtsMigrationJobTimeouts {
    create?: string;
    update?: string;
}

export interface DtsSubscriptionJobTimeouts {
    update?: string;
}

export interface DtsSynchronizationJobTimeouts {
    update?: string;
}

export interface EaisInstanceTimeouts {
    create?: string;
}

export interface EbsDedicatedBlockStorageClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EbsDiskReplicaGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EbsDiskReplicaPairTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EbsEnterpriseSnapshotPolicyAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface EbsEnterpriseSnapshotPolicyCrossRegionCopyInfo {
    enabled?: boolean;
    regions?: outputs.EbsEnterpriseSnapshotPolicyCrossRegionCopyInfoRegion[];
}

export interface EbsEnterpriseSnapshotPolicyCrossRegionCopyInfoRegion {
    regionId?: string;
    retainDays?: number;
}

export interface EbsEnterpriseSnapshotPolicyRetainRule {
    number?: number;
    timeInterval?: number;
    timeUnit?: string;
}

export interface EbsEnterpriseSnapshotPolicySchedule {
    cronExpression: string;
}

export interface EbsEnterpriseSnapshotPolicySpecialRetainRules {
    enabled?: boolean;
    rules?: outputs.EbsEnterpriseSnapshotPolicySpecialRetainRulesRule[];
}

export interface EbsEnterpriseSnapshotPolicySpecialRetainRulesRule {
    specialPeriodUnit?: string;
    timeInterval?: number;
    timeUnit?: string;
}

export interface EbsEnterpriseSnapshotPolicyStorageRule {
    enableImmediateAccess?: boolean;
}

export interface EbsEnterpriseSnapshotPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EbsReplicaGroupDrillTimeouts {
    create?: string;
    delete?: string;
}

export interface EbsReplicaPairDrillTimeouts {
    create?: string;
    delete?: string;
}

export interface EbsSolutionInstanceParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface EbsSolutionInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcdAdConnectorDirectoryTimeouts {
    create?: string;
    delete?: string;
}

export interface EcdAdConnectorOfficeSiteTimeouts {
    create?: string;
    delete?: string;
}

export interface EcdBundleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcdCustomPropertyPropertyValue {
    propertyValue?: string;
    propertyValueId: string;
}

export interface EcdCustomPropertyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcdDesktopTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcdImageTimeouts {
    create?: string;
    delete?: string;
}

export interface EcdNasFileSystemTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcdPolicyGroupAuthorizeAccessPolicyRule {
    cidrIp?: string;
    description?: string;
}

export interface EcdPolicyGroupAuthorizeSecurityPolicyRule {
    cidrIp?: string;
    description?: string;
    ipProtocol?: string;
    policy?: string;
    portRange?: string;
    priority?: string;
    type?: string;
}

export interface EcdRamDirectoryTimeouts {
    create?: string;
    delete?: string;
}

export interface EcdSnapshotTimeouts {
    create?: string;
    delete?: string;
}

export interface EciContainerGroupAcrRegistryInfo {
    domains?: string[];
    instanceId?: string;
    instanceName?: string;
    regionId?: string;
}

export interface EciContainerGroupContainer {
    args?: string[];
    commands?: string[];
    cpu?: number;
    environmentVars?: outputs.EciContainerGroupContainerEnvironmentVar[];
    gpu?: number;
    image: string;
    imagePullPolicy?: string;
    lifecyclePreStopHandlerExecs?: string[];
    livenessProbes?: outputs.EciContainerGroupContainerLivenessProbe[];
    memory?: number;
    name: string;
    ports?: outputs.EciContainerGroupContainerPort[];
    readinessProbes?: outputs.EciContainerGroupContainerReadinessProbe[];
    ready: boolean;
    restartCount: number;
    securityContexts?: outputs.EciContainerGroupContainerSecurityContext[];
    volumeMounts?: outputs.EciContainerGroupContainerVolumeMount[];
    workingDir?: string;
}

export interface EciContainerGroupContainerEnvironmentVar {
    fieldReves?: outputs.EciContainerGroupContainerEnvironmentVarFieldRef[];
    key?: string;
    value?: string;
}

export interface EciContainerGroupContainerEnvironmentVarFieldRef {
    fieldPath?: string;
}

export interface EciContainerGroupContainerLivenessProbe {
    execs?: outputs.EciContainerGroupContainerLivenessProbeExec[];
    failureThreshold?: number;
    httpGets?: outputs.EciContainerGroupContainerLivenessProbeHttpGet[];
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    tcpSockets?: outputs.EciContainerGroupContainerLivenessProbeTcpSocket[];
    timeoutSeconds?: number;
}

export interface EciContainerGroupContainerLivenessProbeExec {
    commands?: string[];
}

export interface EciContainerGroupContainerLivenessProbeHttpGet {
    path?: string;
    port?: number;
    scheme?: string;
}

export interface EciContainerGroupContainerLivenessProbeTcpSocket {
    port?: number;
}

export interface EciContainerGroupContainerPort {
    port?: number;
    protocol?: string;
}

export interface EciContainerGroupContainerReadinessProbe {
    execs?: outputs.EciContainerGroupContainerReadinessProbeExec[];
    failureThreshold?: number;
    httpGets?: outputs.EciContainerGroupContainerReadinessProbeHttpGet[];
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    tcpSockets?: outputs.EciContainerGroupContainerReadinessProbeTcpSocket[];
    timeoutSeconds?: number;
}

export interface EciContainerGroupContainerReadinessProbeExec {
    commands?: string[];
}

export interface EciContainerGroupContainerReadinessProbeHttpGet {
    path?: string;
    port?: number;
    scheme?: string;
}

export interface EciContainerGroupContainerReadinessProbeTcpSocket {
    port?: number;
}

export interface EciContainerGroupContainerSecurityContext {
    capabilities?: outputs.EciContainerGroupContainerSecurityContextCapability[];
    privileged?: boolean;
    runAsUser?: number;
}

export interface EciContainerGroupContainerSecurityContextCapability {
    adds?: string[];
}

export interface EciContainerGroupContainerVolumeMount {
    mountPath?: string;
    name?: string;
    readOnly?: boolean;
}

export interface EciContainerGroupDnsConfig {
    nameServers?: string[];
    options?: outputs.EciContainerGroupDnsConfigOption[];
    searches?: string[];
}

export interface EciContainerGroupDnsConfigOption {
    name?: string;
    value?: string;
}

export interface EciContainerGroupEciSecurityContext {
    sysctls?: outputs.EciContainerGroupEciSecurityContextSysctl[];
}

export interface EciContainerGroupEciSecurityContextSysctl {
    name?: string;
    value?: string;
}

export interface EciContainerGroupHostAlias {
    hostnames?: string[];
    ip?: string;
}

export interface EciContainerGroupImageRegistryCredential {
    password: string;
    server: string;
    userName: string;
}

export interface EciContainerGroupInitContainer {
    args?: string[];
    commands?: string[];
    cpu?: number;
    environmentVars?: outputs.EciContainerGroupInitContainerEnvironmentVar[];
    gpu?: number;
    image?: string;
    imagePullPolicy?: string;
    memory?: number;
    name?: string;
    ports?: outputs.EciContainerGroupInitContainerPort[];
    ready: boolean;
    restartCount: number;
    securityContexts?: outputs.EciContainerGroupInitContainerSecurityContext[];
    volumeMounts?: outputs.EciContainerGroupInitContainerVolumeMount[];
    workingDir?: string;
}

export interface EciContainerGroupInitContainerEnvironmentVar {
    fieldReves?: outputs.EciContainerGroupInitContainerEnvironmentVarFieldRef[];
    key?: string;
    value?: string;
}

export interface EciContainerGroupInitContainerEnvironmentVarFieldRef {
    fieldPath?: string;
}

export interface EciContainerGroupInitContainerPort {
    port?: number;
    protocol?: string;
}

export interface EciContainerGroupInitContainerSecurityContext {
    capabilities?: outputs.EciContainerGroupInitContainerSecurityContextCapability[];
    runAsUser?: number;
}

export interface EciContainerGroupInitContainerSecurityContextCapability {
    adds?: string[];
}

export interface EciContainerGroupInitContainerVolumeMount {
    mountPath?: string;
    name?: string;
    readOnly?: boolean;
}

export interface EciContainerGroupSecurityContext {
    sysctls?: outputs.EciContainerGroupSecurityContextSysctl[];
}

export interface EciContainerGroupSecurityContextSysctl {
    name?: string;
    value?: string;
}

export interface EciContainerGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EciContainerGroupVolume {
    configFileVolumeConfigFileToPaths?: outputs.EciContainerGroupVolumeConfigFileVolumeConfigFileToPath[];
    diskVolumeDiskId?: string;
    diskVolumeFsType?: string;
    flexVolumeDriver?: string;
    flexVolumeFsType?: string;
    flexVolumeOptions?: string;
    name?: string;
    nfsVolumePath?: string;
    nfsVolumeReadOnly?: boolean;
    nfsVolumeServer?: string;
    type?: string;
}

export interface EciContainerGroupVolumeConfigFileVolumeConfigFileToPath {
    content?: string;
    path?: string;
}

export interface EciImageCacheImageRegistryCredential {
    password?: string;
    server?: string;
    userName?: string;
}

export interface EciImageCacheTimeouts {
    create?: string;
}

export interface EciOpenapiImageCacheImageRegistryCredential {
    password?: string;
    server?: string;
    userName?: string;
}

export interface EciOpenapiImageCacheTimeouts {
    create?: string;
}

export interface EciVirtualNodeTaint {
    effect?: string;
    key?: string;
    value?: string;
}

export interface EciVirtualNodeTimeouts {
    create?: string;
}

export interface EcpInstanceTimeouts {
    create?: string;
    update?: string;
}

export interface EcsActivationTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsAutoSnapshotPolicyTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsCapacityReservationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsDedicatedHostNetworkAttributes {
    slbUdpTimeout?: number;
    udpTimeout?: number;
}

export interface EcsDedicatedHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsDiskAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsDiskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsElasticityAssuranceTimeouts {
    create?: string;
    update?: string;
}

export interface EcsImageComponentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsInstanceSetDataDisk {
    autoSnapshotPolicyId?: string;
    diskCategory: string;
    diskDescription?: string;
    diskName?: string;
    diskSize: number;
    encrypted?: boolean;
    kmsKeyId?: string;
    performanceLevel: string;
    snapshotId?: string;
}

export interface EcsInstanceSetExcludeInstanceFilter {
    key: string;
    values: string[];
}

export interface EcsInstanceSetNetworkInterface {
    description?: string;
    networkInterfaceName?: string;
    primaryIpAddress?: string;
    securityGroupId: string;
    vswitchId?: string;
}

export interface EcsInstanceSetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsInvocationTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsKeyPairTimeouts {
    delete?: string;
}

export interface EcsLaunchTemplateDataDisk {
    category?: string;
    deleteWithInstance?: boolean;
    description?: string;
    encrypted?: boolean;
    name?: string;
    performanceLevel?: string;
    size?: number;
    snapshotId?: string;
}

export interface EcsLaunchTemplateNetworkInterfaces {
    description?: string;
    name?: string;
    primaryIp?: string;
    securityGroupId?: string;
    vswitchId?: string;
}

export interface EcsLaunchTemplateSystemDisk {
    category: string;
    deleteWithInstance?: boolean;
    description: string;
    encrypted?: boolean;
    iops?: string;
    name: string;
    performanceLevel: string;
    size: number;
}

export interface EcsNetworkInterfaceAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsNetworkInterfacePermissionTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsNetworkInterfaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsPrefixListEntry {
    cidr?: string;
    description?: string;
}

export interface EcsSnapshotGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EcsSnapshotTimeouts {
    create?: string;
    delete?: string;
}

export interface EcsStorageCapacityUnitTimeouts {
    create?: string;
}

export interface EdasK8sApplicationTimeouts {
    create?: string;
    delete?: string;
}

export interface EdasK8sClusterTimeouts {
    create?: string;
    delete?: string;
}

export interface EdasK8sSlbAttachmentSlbConfig {
    name: string;
    portMappings: outputs.EdasK8sSlbAttachmentSlbConfigPortMapping[];
    scheduler: string;
    /**
     * if field 'slb_id' is empty, EDAS will purchase a new slb for this config
     */
    slbId: string;
    specification?: string;
    type: string;
}

export interface EdasK8sSlbAttachmentSlbConfigPortMapping {
    certId?: string;
    loadbalancerProtocol: string;
    servicePort: outputs.EdasK8sSlbAttachmentSlbConfigPortMappingServicePort;
}

export interface EdasK8sSlbAttachmentSlbConfigPortMappingServicePort {
    port: number;
    protocol: string;
    targetPort: number;
}

export interface EdasK8sSlbAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EdasNamespaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EfloSubnetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EfloVpdTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EhpcClusterAdditionalVolume {
    jobQueue?: string;
    localDirectory?: string;
    location?: string;
    remoteDirectory?: string;
    roles?: outputs.EhpcClusterAdditionalVolumeRole[];
    volumeId?: string;
    volumeMountOption?: string;
    volumeMountpoint?: string;
    volumeProtocol?: string;
    volumeType?: string;
}

export interface EhpcClusterAdditionalVolumeRole {
    name?: string;
}

export interface EhpcClusterApplication {
    tag?: string;
}

export interface EhpcClusterPostInstallScript {
    args?: string;
    url?: string;
}

export interface EhpcClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipAddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipAssociationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipSegmentAddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipanycastAnycastEipAddressAttachmentPopLocation {
    popLocation?: string;
}

export interface EipanycastAnycastEipAddressAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EipanycastAnycastEipAddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ElasticsearchInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EmrClusterBootstrapAction {
    arg?: string;
    executionFailStrategy?: string;
    executionMoment?: string;
    executionTarget?: string;
    name?: string;
    path?: string;
}

export interface EmrClusterConfig {
    configKey: string;
    configValue: string;
    fileName: string;
    serviceName: string;
}

export interface EmrClusterHostGroup {
    autoRenew?: boolean;
    chargeType?: string;
    decommissionTimeout: number;
    diskCapacity?: string;
    diskCount?: string;
    diskType?: string;
    enableGracefulDecommission: boolean;
    gpuDriver?: string;
    hostGroupName?: string;
    hostGroupType?: string;
    instanceList?: string;
    instanceType?: string;
    nodeCount?: string;
    period: number;
    sysDiskCapacity?: string;
    sysDiskType?: string;
}

export interface EmrClusterMetaStoreConf {
    dbPassword: string;
    dbUrl: string;
    dbUserName: string;
}

export interface EmrClusterModifyClusterServiceConfig {
    comment?: string;
    configParams: string;
    configType?: string;
    customConfigParams?: string;
    gatewayClusterIdLists?: string[];
    groupId?: string;
    hostInstanceId?: string;
    refreshHostConfig?: boolean;
    serviceName: string;
}

export interface EmrClusterTimeouts {
    create?: string;
    delete?: string;
}

export interface Emrv2ClusterApplicationConfig {
    applicationName: string;
    configDescription?: string;
    configFileName: string;
    configItemKey: string;
    configItemValue: string;
    configScope?: string;
    nodeGroupId?: string;
    nodeGroupName?: string;
}

export interface Emrv2ClusterBootstrapScript {
    executionFailStrategy: string;
    executionMoment: string;
    nodeSelector: outputs.Emrv2ClusterBootstrapScriptNodeSelector;
    /**
     * @deprecated Deprecated
     */
    priority?: number;
    scriptArgs: string;
    scriptName: string;
    scriptPath: string;
}

export interface Emrv2ClusterBootstrapScriptNodeSelector {
    /**
     * @deprecated Deprecated
     */
    nodeGroupId?: string;
    nodeGroupIds?: string[];
    /**
     * @deprecated Deprecated
     */
    nodeGroupName?: string;
    nodeGroupNames?: string[];
    nodeGroupTypes?: string[];
    nodeNames?: string[];
    nodeSelectType: string;
}

export interface Emrv2ClusterNodeAttribute {
    dataDiskEncrypted: boolean;
    dataDiskKmsKeyId: string;
    keyPairName: string;
    ramRole: string;
    securityGroupId: string;
    vpcId: string;
    zoneId: string;
}

export interface Emrv2ClusterNodeGroup {
    additionalSecurityGroupIds?: string[];
    autoScalingPolicy?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicy;
    costOptimizedConfig?: outputs.Emrv2ClusterNodeGroupCostOptimizedConfig;
    dataDisks: outputs.Emrv2ClusterNodeGroupDataDisk[];
    deploymentSetStrategy: string;
    gracefulShutdown: boolean;
    instanceTypes: string[];
    nodeCount: number;
    nodeGroupName: string;
    nodeGroupType: string;
    nodeResizeStrategy: string;
    paymentType: string;
    spotBidPrices?: outputs.Emrv2ClusterNodeGroupSpotBidPrice[];
    spotInstanceRemedy: boolean;
    subscriptionConfig?: outputs.Emrv2ClusterNodeGroupSubscriptionConfig;
    systemDisk: outputs.Emrv2ClusterNodeGroupSystemDisk;
    vswitchIds?: string[];
    withPublicIp: boolean;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicy {
    constraints?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyConstraints;
    scalingRules?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRule[];
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyConstraints {
    maxCapacity?: number;
    minCapacity?: number;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRule {
    activityType: string;
    adjustmentType?: string;
    adjustmentValue: number;
    metricsTrigger?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger;
    minAdjustmentValue?: number;
    ruleName: string;
    timeTrigger?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger;
    triggerType: string;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTrigger {
    conditionLogicOperator?: string;
    conditions?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition[];
    coolDownInterval?: number;
    evaluationCount: number;
    timeConstraints?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint[];
    timeWindow: number;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerCondition {
    comparisonOperator: string;
    metricName: string;
    statistics: string;
    tags?: outputs.Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag[];
    threshold: number;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerConditionTag {
    key: string;
    value?: string;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleMetricsTriggerTimeConstraint {
    endTime?: string;
    startTime?: string;
}

export interface Emrv2ClusterNodeGroupAutoScalingPolicyScalingRuleTimeTrigger {
    endTime?: string;
    launchExpirationTime?: number;
    launchTime: string;
    recurrenceType?: string;
    recurrenceValue?: string;
    startTime?: string;
}

export interface Emrv2ClusterNodeGroupCostOptimizedConfig {
    onDemandBaseCapacity: number;
    onDemandPercentageAboveBaseCapacity: number;
    spotInstancePools: number;
}

export interface Emrv2ClusterNodeGroupDataDisk {
    category: string;
    count: number;
    performanceLevel: string;
    size: number;
}

export interface Emrv2ClusterNodeGroupSpotBidPrice {
    bidPrice: number;
    instanceType: string;
}

export interface Emrv2ClusterNodeGroupSubscriptionConfig {
    autoPayOrder?: boolean;
    autoRenew?: boolean;
    autoRenewDuration?: number;
    autoRenewDurationUnit?: string;
    paymentDuration: number;
    paymentDurationUnit: string;
}

export interface Emrv2ClusterNodeGroupSystemDisk {
    category: string;
    count: number;
    performanceLevel: string;
    size: number;
}

export interface Emrv2ClusterSubscriptionConfig {
    autoPayOrder?: boolean;
    autoRenew?: boolean;
    autoRenewDuration?: number;
    autoRenewDurationUnit?: string;
    paymentDuration: number;
    paymentDurationUnit: string;
}

export interface Emrv2ClusterTimeouts {
    create?: string;
    delete?: string;
}

export interface EnsDiskInstanceAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsDiskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsEipInstanceAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface EnsEipTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsImageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsInstanceDataDisk {
    category?: string;
    size?: number;
}

export interface EnsInstanceSecurityGroupAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface EnsInstanceSystemDisk {
    category: string;
    size: number;
}

export interface EnsInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsNatGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsNetworkTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsSecurityGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsSnapshotTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnsVswitchTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EssAlarmExpression {
    comparisonOperator: string;
    metricName: string;
    period: number;
    statistics: string;
    threshold: number;
}

export interface EssEciScalingConfigurationAcrRegistryInfo {
    domains?: string[];
    instanceId?: string;
    instanceName?: string;
    regionId?: string;
}

export interface EssEciScalingConfigurationContainer {
    args?: string[];
    commands?: string[];
    cpu?: number;
    environmentVars?: outputs.EssEciScalingConfigurationContainerEnvironmentVar[];
    gpu?: number;
    image?: string;
    imagePullPolicy?: string;
    lifecyclePreStopHandlerExecs?: string[];
    livenessProbeExecCommands?: string[];
    livenessProbeFailureThreshold?: number;
    livenessProbeHttpGetPath?: string;
    livenessProbeHttpGetPort?: number;
    livenessProbeHttpGetScheme?: string;
    livenessProbeInitialDelaySeconds?: number;
    livenessProbePeriodSeconds?: number;
    livenessProbeSuccessThreshold?: number;
    livenessProbeTcpSocketPort?: number;
    livenessProbeTimeoutSeconds?: number;
    memory?: number;
    name?: string;
    ports?: outputs.EssEciScalingConfigurationContainerPort[];
    readinessProbeExecCommands?: string[];
    readinessProbeFailureThreshold?: number;
    readinessProbeHttpGetPath?: string;
    readinessProbeHttpGetPort?: number;
    readinessProbeHttpGetScheme?: string;
    readinessProbeInitialDelaySeconds?: number;
    readinessProbePeriodSeconds?: number;
    readinessProbeSuccessThreshold?: number;
    readinessProbeTcpSocketPort?: number;
    readinessProbeTimeoutSeconds?: number;
    securityContextCapabilityAdds?: string[];
    securityContextReadOnlyRootFileSystem?: boolean;
    securityContextRunAsUser?: number;
    volumeMounts?: outputs.EssEciScalingConfigurationContainerVolumeMount[];
    workingDir?: string;
}

export interface EssEciScalingConfigurationContainerEnvironmentVar {
    fieldRefFieldPath?: string;
    key?: string;
    value?: string;
}

export interface EssEciScalingConfigurationContainerPort {
    port?: number;
    protocol?: string;
}

export interface EssEciScalingConfigurationContainerVolumeMount {
    mountPath?: string;
    name?: string;
    readOnly?: boolean;
}

export interface EssEciScalingConfigurationHostAlias {
    hostnames?: string[];
    ip?: string;
}

export interface EssEciScalingConfigurationImageRegistryCredential {
    password?: string;
    server?: string;
    username?: string;
}

export interface EssEciScalingConfigurationInitContainer {
    args?: string[];
    commands?: string[];
    cpu?: number;
    environmentVars?: outputs.EssEciScalingConfigurationInitContainerEnvironmentVar[];
    gpu?: number;
    image?: string;
    imagePullPolicy?: string;
    memory?: number;
    name?: string;
    ports?: outputs.EssEciScalingConfigurationInitContainerPort[];
    securityContextCapabilityAdds?: string[];
    securityContextReadOnlyRootFileSystem?: boolean;
    securityContextRunAsUser?: number;
    volumeMounts?: outputs.EssEciScalingConfigurationInitContainerVolumeMount[];
    workingDir?: string;
}

export interface EssEciScalingConfigurationInitContainerEnvironmentVar {
    fieldRefFieldPath?: string;
    key?: string;
    value?: string;
}

export interface EssEciScalingConfigurationInitContainerPort {
    port?: number;
    protocol?: string;
}

export interface EssEciScalingConfigurationInitContainerVolumeMount {
    mountPath?: string;
    name?: string;
    readOnly?: boolean;
}

export interface EssEciScalingConfigurationTimeouts {
    create?: string;
    delete?: string;
}

export interface EssEciScalingConfigurationVolume {
    configFileVolumeConfigFileToPaths?: outputs.EssEciScalingConfigurationVolumeConfigFileVolumeConfigFileToPath[];
    diskVolumeDiskId?: string;
    diskVolumeDiskSize?: number;
    diskVolumeFsType?: string;
    flexVolumeDriver?: string;
    flexVolumeFsType?: string;
    flexVolumeOptions?: string;
    name?: string;
    nfsVolumePath?: string;
    nfsVolumeReadOnly?: boolean;
    nfsVolumeServer?: string;
    type?: string;
}

export interface EssEciScalingConfigurationVolumeConfigFileVolumeConfigFileToPath {
    content?: string;
    path?: string;
}

export interface EssScalingConfigurationDataDisk {
    autoSnapshotPolicyId?: string;
    category?: string;
    deleteWithInstance?: boolean;
    description?: string;
    /**
     * @deprecated Deprecated
     */
    device?: string;
    encrypted?: boolean;
    kmsKeyId?: string;
    name?: string;
    performanceLevel?: string;
    size?: number;
    snapshotId?: string;
}

export interface EssScalingConfigurationInstancePatternInfo {
    architectures?: string[];
    burstablePerformance: string;
    cores?: number;
    excludedInstanceTypes?: string[];
    instanceFamilyLevel?: string;
    maxPrice?: number;
    memory?: number;
}

export interface EssScalingConfigurationInstanceTypeOverride {
    instanceType?: string;
    weightedCapacity?: number;
}

export interface EssScalingConfigurationSpotPriceLimit {
    instanceType?: string;
    priceLimit?: number;
}

export interface EssScalingConfigurationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EssScalingGroupAlbServerGroup {
    albServerGroupId?: string;
    port?: number;
    weight?: number;
}

export interface EssScalingGroupLaunchTemplateOverride {
    instanceType?: string;
    spotPriceLimit?: number;
    weightedCapacity?: number;
}

export interface EssScalingRuleAlarmDimension {
    dimensionKey?: string;
    dimensionValue?: string;
}

export interface EssScalingRuleStepAdjustment {
    metricIntervalLowerBound?: string;
    metricIntervalUpperBound?: string;
    scalingAdjustment?: number;
}

export interface EssScalinggroupVserverGroupsVserverGroup {
    loadbalancerId: string;
    vserverAttributes: outputs.EssScalinggroupVserverGroupsVserverGroupVserverAttribute[];
}

export interface EssScalinggroupVserverGroupsVserverGroupVserverAttribute {
    port: number;
    vserverGroupId: string;
    weight: number;
}

export interface EssSuspendProcessTimeouts {
    create?: string;
    delete?: string;
}

export interface EventBridgeApiDestinationHttpApiParameters {
    endpoint: string;
    method: string;
}

export interface EventBridgeApiDestinationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EventBridgeConnectionAuthParameters {
    apiKeyAuthParameters?: outputs.EventBridgeConnectionAuthParametersApiKeyAuthParameters;
    authorizationType?: string;
    basicAuthParameters?: outputs.EventBridgeConnectionAuthParametersBasicAuthParameters;
    oauthParameters?: outputs.EventBridgeConnectionAuthParametersOauthParameters;
}

export interface EventBridgeConnectionAuthParametersApiKeyAuthParameters {
    apiKeyName?: string;
    apiKeyValue?: string;
}

export interface EventBridgeConnectionAuthParametersBasicAuthParameters {
    password?: string;
    username?: string;
}

export interface EventBridgeConnectionAuthParametersOauthParameters {
    authorizationEndpoint?: string;
    clientParameters?: outputs.EventBridgeConnectionAuthParametersOauthParametersClientParameters;
    httpMethod?: string;
    oauthHttpParameters?: outputs.EventBridgeConnectionAuthParametersOauthParametersOauthHttpParameters;
}

export interface EventBridgeConnectionAuthParametersOauthParametersClientParameters {
    clientId?: string;
    clientSecret?: string;
}

export interface EventBridgeConnectionAuthParametersOauthParametersOauthHttpParameters {
    bodyParameters?: outputs.EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersBodyParameter[];
    headerParameters?: outputs.EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersHeaderParameter[];
    queryStringParameters?: outputs.EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersQueryStringParameter[];
}

export interface EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersBodyParameter {
    isValueSecret?: string;
    key?: string;
    value?: string;
}

export interface EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersHeaderParameter {
    isValueSecret?: string;
    key?: string;
    value?: string;
}

export interface EventBridgeConnectionAuthParametersOauthParametersOauthHttpParametersQueryStringParameter {
    isValueSecret?: string;
    key?: string;
    value?: string;
}

export interface EventBridgeConnectionNetworkParameters {
    networkType: string;
    securityGroupId?: string;
    vpcId?: string;
    vswitcheId?: string;
}

export interface EventBridgeConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EventBridgeRuleTarget {
    deadLetterQueue?: outputs.EventBridgeRuleTargetDeadLetterQueue;
    endpoint: string;
    paramLists: outputs.EventBridgeRuleTargetParamList[];
    pushRetryStrategy: string;
    targetId: string;
    type: string;
}

export interface EventBridgeRuleTargetDeadLetterQueue {
    arn?: string;
}

export interface EventBridgeRuleTargetParamList {
    form: string;
    resourceKey: string;
    template?: string;
    value?: string;
}

export interface EventBridgeRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectEcFailoverTestJobTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectGrantRuleToCenTimeouts {
    create?: string;
    delete?: string;
}

export interface ExpressConnectPhysicalConnectionTimeouts {
    create?: string;
}

export interface ExpressConnectRouterExpressConnectRouterRegion {
    regionId?: string;
    transitMode: string;
}

export interface ExpressConnectRouterExpressConnectRouterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectRouterInterfaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectRouterTrAssociationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectRouterVbrChildInstanceTimeouts {
    create?: string;
    delete?: string;
}

export interface ExpressConnectRouterVpcAssociationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectTrafficQosAssociationTimeouts {
    create?: string;
    delete?: string;
}

export interface ExpressConnectTrafficQosQueueTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectTrafficQosRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectTrafficQosTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ExpressConnectVbrPconnAssociationTimeouts {
    create?: string;
    delete?: string;
}

export interface ExpressConnectVirtualBorderRouterTimeouts {
    update?: string;
}

export interface ExpressConnectVirtualPhysicalConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FcAliasRoutingConfig {
    additionalVersionWeights?: {[key: string]: number};
}

export interface FcCustomDomainCertConfig {
    certName: string;
    certificate: string;
    privateKey: string;
}

export interface FcCustomDomainRouteConfig {
    functionName: string;
    methods?: string[];
    path: string;
    qualifier?: string;
    serviceName: string;
}

export interface FcFunctionAsyncInvokeConfigDestinationConfig {
    onFailure?: outputs.FcFunctionAsyncInvokeConfigDestinationConfigOnFailure;
    onSuccess?: outputs.FcFunctionAsyncInvokeConfigDestinationConfigOnSuccess;
}

export interface FcFunctionAsyncInvokeConfigDestinationConfigOnFailure {
    destination: string;
}

export interface FcFunctionAsyncInvokeConfigDestinationConfigOnSuccess {
    destination: string;
}

export interface FcFunctionCustomContainerConfig {
    args?: string;
    command?: string;
    image: string;
}

export interface FcLayerVersionTimeouts {
    create?: string;
    delete?: string;
}

export interface FcServiceLogConfig {
    enableInstanceMetrics?: boolean;
    enableRequestMetrics?: boolean;
    logstore: string;
    project: string;
}

export interface FcServiceNasConfig {
    groupId: number;
    mountPoints: outputs.FcServiceNasConfigMountPoint[];
    userId: number;
}

export interface FcServiceNasConfigMountPoint {
    mountDir: string;
    serverAddr: string;
}

export interface FcServiceTracingConfig {
    params: {[key: string]: string};
    type: string;
}

export interface FcServiceVpcConfig {
    securityGroupId: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface Fcv2FunctionCode {
    ossBucketName?: string;
    ossObjectName?: string;
    zipFile?: string;
}

export interface Fcv2FunctionCustomContainerConfig {
    accelerationType?: string;
    args?: string;
    command?: string;
    image?: string;
    webServerMode?: boolean;
}

export interface Fcv2FunctionCustomDns {
    dnsOptions?: outputs.Fcv2FunctionCustomDnsDnsOption[];
    nameServers?: string[];
    searches?: string[];
}

export interface Fcv2FunctionCustomDnsDnsOption {
    name?: string;
    value?: string;
}

export interface Fcv2FunctionCustomHealthCheckConfig {
    failureThreshold?: number;
    httpGetUrl?: string;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
}

export interface Fcv2FunctionCustomRuntimeConfig {
    args?: string[];
    commands?: string[];
}

export interface Fcv2FunctionInstanceLifecycleConfig {
    preFreeze?: outputs.Fcv2FunctionInstanceLifecycleConfigPreFreeze;
    preStop?: outputs.Fcv2FunctionInstanceLifecycleConfigPreStop;
}

export interface Fcv2FunctionInstanceLifecycleConfigPreFreeze {
    handler?: string;
    timeout?: number;
}

export interface Fcv2FunctionInstanceLifecycleConfigPreStop {
    handler?: string;
    timeout?: number;
}

export interface Fcv2FunctionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3AliasTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3AsyncInvokeConfigDestinationConfig {
    onFailure?: outputs.Fcv3AsyncInvokeConfigDestinationConfigOnFailure;
    onSuccess?: outputs.Fcv3AsyncInvokeConfigDestinationConfigOnSuccess;
}

export interface Fcv3AsyncInvokeConfigDestinationConfigOnFailure {
    destination?: string;
}

export interface Fcv3AsyncInvokeConfigDestinationConfigOnSuccess {
    destination?: string;
}

export interface Fcv3AsyncInvokeConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3ConcurrencyConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3CustomDomainAuthConfig {
    authInfo?: string;
    authType?: string;
}

export interface Fcv3CustomDomainCertConfig {
    certName?: string;
    certificate?: string;
    privateKey?: string;
}

export interface Fcv3CustomDomainRouteConfig {
    routes?: outputs.Fcv3CustomDomainRouteConfigRoute[];
}

export interface Fcv3CustomDomainRouteConfigRoute {
    functionName?: string;
    methods?: string[];
    path?: string;
    qualifier?: string;
    rewriteConfig?: outputs.Fcv3CustomDomainRouteConfigRouteRewriteConfig;
}

export interface Fcv3CustomDomainRouteConfigRouteRewriteConfig {
    equalRules?: outputs.Fcv3CustomDomainRouteConfigRouteRewriteConfigEqualRule[];
    regexRules?: outputs.Fcv3CustomDomainRouteConfigRouteRewriteConfigRegexRule[];
    wildcardRules?: outputs.Fcv3CustomDomainRouteConfigRouteRewriteConfigWildcardRule[];
}

export interface Fcv3CustomDomainRouteConfigRouteRewriteConfigEqualRule {
    match?: string;
    replacement?: string;
}

export interface Fcv3CustomDomainRouteConfigRouteRewriteConfigRegexRule {
    match?: string;
    replacement?: string;
}

export interface Fcv3CustomDomainRouteConfigRouteRewriteConfigWildcardRule {
    match?: string;
    replacement?: string;
}

export interface Fcv3CustomDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3CustomDomainTlsConfig {
    cipherSuites?: string[];
    maxVersion?: string;
    minVersion?: string;
}

export interface Fcv3CustomDomainWafConfig {
    enableWaf?: boolean;
}

export interface Fcv3FunctionCode {
    checksum?: string;
    ossBucketName?: string;
    ossObjectName?: string;
    zipFile?: string;
}

export interface Fcv3FunctionCustomContainerConfig {
    /**
     * @deprecated Deprecated
     */
    accelerationInfos: outputs.Fcv3FunctionCustomContainerConfigAccelerationInfo[];
    /**
     * @deprecated Deprecated
     */
    accelerationType?: string;
    /**
     * @deprecated Deprecated
     */
    acrInstanceId?: string;
    commands?: string[];
    entrypoints?: string[];
    healthCheckConfig?: outputs.Fcv3FunctionCustomContainerConfigHealthCheckConfig;
    image?: string;
    port?: number;
    resolvedImageUri: string;
}

export interface Fcv3FunctionCustomContainerConfigAccelerationInfo {
    status: string;
}

export interface Fcv3FunctionCustomContainerConfigHealthCheckConfig {
    failureThreshold?: number;
    httpGetUrl?: string;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
}

export interface Fcv3FunctionCustomDns {
    dnsOptions?: outputs.Fcv3FunctionCustomDnsDnsOption[];
    nameServers?: string[];
    searches?: string[];
}

export interface Fcv3FunctionCustomDnsDnsOption {
    name?: string;
    value?: string;
}

export interface Fcv3FunctionCustomRuntimeConfig {
    args?: string[];
    commands?: string[];
    healthCheckConfig?: outputs.Fcv3FunctionCustomRuntimeConfigHealthCheckConfig;
    port: number;
}

export interface Fcv3FunctionCustomRuntimeConfigHealthCheckConfig {
    failureThreshold: number;
    httpGetUrl?: string;
    initialDelaySeconds?: number;
    periodSeconds?: number;
    successThreshold?: number;
    timeoutSeconds?: number;
}

export interface Fcv3FunctionGpuConfig {
    gpuMemorySize?: number;
    gpuType?: string;
}

export interface Fcv3FunctionInstanceLifecycleConfig {
    initializer?: outputs.Fcv3FunctionInstanceLifecycleConfigInitializer;
    preStop?: outputs.Fcv3FunctionInstanceLifecycleConfigPreStop;
}

export interface Fcv3FunctionInstanceLifecycleConfigInitializer {
    handler?: string;
    timeout?: number;
}

export interface Fcv3FunctionInstanceLifecycleConfigPreStop {
    handler?: string;
    timeout?: number;
}

export interface Fcv3FunctionLogConfig {
    enableInstanceMetrics: boolean;
    enableRequestMetrics: boolean;
    logBeginRule: string;
    logstore?: string;
    project?: string;
}

export interface Fcv3FunctionNasConfig {
    groupId: number;
    mountPoints?: outputs.Fcv3FunctionNasConfigMountPoint[];
    userId: number;
}

export interface Fcv3FunctionNasConfigMountPoint {
    enableTls?: boolean;
    mountDir?: string;
    serverAddr?: string;
}

export interface Fcv3FunctionOssMountConfig {
    mountPoints?: outputs.Fcv3FunctionOssMountConfigMountPoint[];
}

export interface Fcv3FunctionOssMountConfigMountPoint {
    bucketName?: string;
    bucketPath?: string;
    endpoint?: string;
    mountDir?: string;
    readOnly?: boolean;
}

export interface Fcv3FunctionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Fcv3FunctionVersionTimeouts {
    create?: string;
    delete?: string;
}

export interface Fcv3FunctionVpcConfig {
    securityGroupId?: string;
    vpcId?: string;
    vswitchIds?: string[];
}

export interface Fcv3TriggerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FnfExecutionTimeouts {
    create?: string;
    update?: string;
}

export interface FnfFlowTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FnfScheduleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ForwardEntryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaAcceleratorSpareIpAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface GaAcceleratorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaAccessLogTimeouts {
    create?: string;
    delete?: string;
}

export interface GaAclAclEntry {
    entry: string;
    entryDescription: string;
}

export interface GaAclAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface GaAclEntryAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface GaAclTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaAdditionalCertificateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBandwidthPackageAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBandwidthPackageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBasicAccelerateIpEndpointRelationTimeouts {
    create?: string;
    delete?: string;
}

export interface GaBasicAccelerateIpTimeouts {
    create?: string;
    delete?: string;
}

export interface GaBasicAcceleratorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBasicEndpointGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBasicEndpointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaBasicIpSetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaCustomRoutingEndpointGroupDestinationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaCustomRoutingEndpointGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaCustomRoutingEndpointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaCustomRoutingEndpointTrafficPolicyPortRange {
    fromPort?: number;
    toPort?: number;
}

export interface GaCustomRoutingEndpointTrafficPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaDomainTimeouts {
    create?: string;
    delete?: string;
}

export interface GaEndpointGroupEndpointConfiguration {
    enableClientipPreservation: boolean;
    enableProxyProtocol?: boolean;
    endpoint: string;
    type: string;
    weight: number;
}

export interface GaEndpointGroupPortOverrides {
    endpointPort?: number;
    listenerPort?: number;
}

export interface GaEndpointGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaForwardingRuleRuleAction {
    forwardGroupConfig?: outputs.GaForwardingRuleRuleActionForwardGroupConfig;
    order: number;
    ruleActionType: string;
    ruleActionValue?: string;
}

export interface GaForwardingRuleRuleActionForwardGroupConfig {
    serverGroupTuples: outputs.GaForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
}

export interface GaForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
    endpointGroupId: string;
}

export interface GaForwardingRuleRuleCondition {
    hostConfigs?: outputs.GaForwardingRuleRuleConditionHostConfig[];
    pathConfig?: outputs.GaForwardingRuleRuleConditionPathConfig;
    ruleConditionType: string;
}

export interface GaForwardingRuleRuleConditionHostConfig {
    values?: string[];
}

export interface GaForwardingRuleRuleConditionPathConfig {
    values?: string[];
}

export interface GaForwardingRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaIpSetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GaListenerCertificate {
    id?: string;
}

export interface GaListenerForwardedForConfig {
    forwardedForGaApEnabled?: boolean;
    forwardedForGaIdEnabled?: boolean;
    forwardedForPortEnabled?: boolean;
    forwardedForProtoEnabled?: boolean;
    realIpEnabled?: boolean;
}

export interface GaListenerPortRange {
    fromPort: number;
    toPort: number;
}

export interface GaListenerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetActiontrailHistoryDeliveryJobsJob {
    createTime: string;
    endTime: string;
    historyDeliveryJobId: string;
    homeRegion: string;
    id: string;
    jobStatuses: outputs.GetActiontrailHistoryDeliveryJobsJobJobStatus[];
    startTime: string;
    status: number;
    trailName: string;
    updatedTime: string;
}

export interface GetActiontrailHistoryDeliveryJobsJobJobStatus {
    region: string;
    status: number;
}

export interface GetActiontrailTrailsActiontrail {
    eventRw: string;
    id: string;
    isOrganizationTrail: boolean;
    ossBucketName: string;
    ossKeyPrefix: string;
    ossWriteRoleArn: string;
    slsProjectArn: string;
    slsWriteRoleArn: string;
    status: string;
    trailName: string;
    trailRegion: string;
}

export interface GetActiontrailTrailsTrail {
    eventRw: string;
    id: string;
    isOrganizationTrail: boolean;
    ossBucketName: string;
    ossKeyPrefix: string;
    ossWriteRoleArn: string;
    slsProjectArn: string;
    slsWriteRoleArn: string;
    status: string;
    trailName: string;
    trailRegion: string;
}

export interface GetActiontrailsActiontrail {
    eventRw: string;
    id: string;
    isOrganizationTrail: boolean;
    ossBucketName: string;
    ossKeyPrefix: string;
    ossWriteRoleArn: string;
    slsProjectArn: string;
    slsWriteRoleArn: string;
    status: string;
    trailName: string;
    trailRegion: string;
}

export interface GetActiontrailsTrail {
    eventRw: string;
    id: string;
    isOrganizationTrail: boolean;
    ossBucketName: string;
    ossKeyPrefix: string;
    ossWriteRoleArn: string;
    slsProjectArn: string;
    slsWriteRoleArn: string;
    status: string;
    trailName: string;
    trailRegion: string;
}

export interface GetAdbClustersCluster {
    autoRenewPeriod: number;
    chargeType: string;
    commodityCode: string;
    computeResource: string;
    connectionString: string;
    createTime: string;
    dbClusterCategory: string;
    dbClusterId: string;
    dbClusterNetworkType: string;
    dbClusterType: string;
    dbClusterVersion: string;
    dbNodeClass: string;
    dbNodeCount: number;
    dbNodeStorage: number;
    description: string;
    diskType: string;
    dtsJobId: string;
    elasticIoResource: number;
    engine: string;
    engineVersion: string;
    executorCount: string;
    expireTime: string;
    expired: string;
    id: string;
    lockMode: string;
    lockReason: string;
    maintainTime: string;
    mode: string;
    networkType: string;
    paymentType: string;
    port: number;
    rdsInstanceId: string;
    regionId: string;
    renewalStatus: string;
    resourceGroupId: string;
    securityIps: string[];
    status: string;
    storageResource: string;
    tags: {[key: string]: string};
    vpcCloudInstanceId: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetAdbDbClusterLakeVersionsVersion {
    commodityCode: string;
    computeResource: string;
    connectionString: string;
    createTime: string;
    dbClusterId: string;
    dbClusterVersion: string;
    engine: string;
    engineVersion: string;
    expireTime: string;
    expired: string;
    id: string;
    lockMode: string;
    lockReason: string;
    paymentType: string;
    port: string;
    resourceGroupId: string;
    status: string;
    storageResource: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetAdbDbClustersCluster {
    autoRenewPeriod: number;
    chargeType: string;
    commodityCode: string;
    computeResource: string;
    connectionString: string;
    createTime: string;
    dbClusterCategory: string;
    dbClusterId: string;
    dbClusterNetworkType: string;
    dbClusterType: string;
    dbClusterVersion: string;
    dbNodeClass: string;
    dbNodeCount: number;
    dbNodeStorage: number;
    description: string;
    diskType: string;
    dtsJobId: string;
    elasticIoResource: number;
    engine: string;
    engineVersion: string;
    executorCount: string;
    expireTime: string;
    expired: string;
    id: string;
    lockMode: string;
    lockReason: string;
    maintainTime: string;
    mode: string;
    networkType: string;
    paymentType: string;
    port: number;
    rdsInstanceId: string;
    regionId: string;
    renewalStatus: string;
    resourceGroupId: string;
    securityIps: string[];
    status: string;
    storageResource: string;
    tags: {[key: string]: string};
    vpcCloudInstanceId: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetAdbResourceGroupsGroup {
    createTime: string;
    dbClusterId: string;
    groupName: string;
    groupType: string;
    id: string;
    nodeNum: number;
    user: string;
}

export interface GetAdbZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetAlbAclsAcl {
    aclEntries: outputs.GetAlbAclsAclAclEntry[];
    aclId: string;
    aclName: string;
    addressIpVersion: string;
    id: string;
    resourceGroupId: string;
    status: string;
}

export interface GetAlbAclsAclAclEntry {
    description: string;
    entry: string;
    status: string;
}

export interface GetAlbAscriptsAscript {
    ascriptId: string;
    ascriptName: string;
    enabled: boolean;
    extAttributeEnabled: boolean;
    extAttributes: outputs.GetAlbAscriptsAscriptExtAttribute[];
    id: string;
    listenerId: string;
    loadBalancerId: string;
    position: string;
    scriptContent: string;
    status: string;
}

export interface GetAlbAscriptsAscriptExtAttribute {
    attributeKey: string;
    attributeValue: string;
}

export interface GetAlbHealthCheckTemplatesTemplate {
    healthCheckCodes: string[];
    healthCheckConnectPort: number;
    healthCheckHost: string;
    healthCheckHttpVersion: string;
    healthCheckInterval: number;
    healthCheckMethod: string;
    healthCheckPath: string;
    healthCheckProtocol: string;
    healthCheckTemplateId: string;
    healthCheckTemplateName: string;
    healthCheckTimeout: number;
    healthyThreshold: number;
    id: string;
    unhealthyThreshold: number;
}

export interface GetAlbListenersListener {
    accessLogRecordCustomizedHeadersEnabled: boolean;
    accessLogTracingConfigs: outputs.GetAlbListenersListenerAccessLogTracingConfig[];
    aclConfigs: outputs.GetAlbListenersListenerAclConfig[];
    certificates: outputs.GetAlbListenersListenerCertificate[];
    defaultActions: outputs.GetAlbListenersListenerDefaultAction[];
    gzipEnabled: boolean;
    http2Enabled: boolean;
    id: string;
    idleTimeout: number;
    listenerDescription: string;
    listenerId: string;
    listenerPort: number;
    listenerProtocol: string;
    loadBalancerId: string;
    maxResults: string;
    nextToken: string;
    quicConfigs: outputs.GetAlbListenersListenerQuicConfig[];
    requestTimeout: number;
    securityPolicyId: string;
    status: string;
    xforwardedForConfigs: outputs.GetAlbListenersListenerXforwardedForConfig[];
}

export interface GetAlbListenersListenerAccessLogTracingConfig {
    tracingEnabled: boolean;
    tracingSample: number;
    tracingType: string;
}

export interface GetAlbListenersListenerAclConfig {
    aclRelations: outputs.GetAlbListenersListenerAclConfigAclRelation[];
    aclType: string;
}

export interface GetAlbListenersListenerAclConfigAclRelation {
    aclId: string;
    status: string;
}

export interface GetAlbListenersListenerCertificate {
    certificateId: string;
}

export interface GetAlbListenersListenerDefaultAction {
    forwardGroupConfigs: outputs.GetAlbListenersListenerDefaultActionForwardGroupConfig[];
    type: string;
}

export interface GetAlbListenersListenerDefaultActionForwardGroupConfig {
    serverGroupTuples: outputs.GetAlbListenersListenerDefaultActionForwardGroupConfigServerGroupTuple[];
}

export interface GetAlbListenersListenerDefaultActionForwardGroupConfigServerGroupTuple {
    serverGroupId: string;
}

export interface GetAlbListenersListenerQuicConfig {
    quicListenerId: string;
    quicUpgradeEnabled: boolean;
}

export interface GetAlbListenersListenerXforwardedForConfig {
    xforwardedforclientcertIssuerdnalias: string;
    xforwardedforclientcertIssuerdnenabled: boolean;
    xforwardedforclientcertclientverifyalias: string;
    xforwardedforclientcertclientverifyenabled: boolean;
    xforwardedforclientcertfingerprintalias: string;
    xforwardedforclientcertfingerprintenabled: boolean;
    xforwardedforclientcertsubjectdnalias: string;
    xforwardedforclientcertsubjectdnenabled: boolean;
    xforwardedforclientsrcportenabled: boolean;
    xforwardedforenabled: boolean;
    xforwardedforprotoenabled: boolean;
    xforwardedforslbidenabled: boolean;
    xforwardedforslbportenabled: boolean;
}

export interface GetAlbLoadBalancersBalancer {
    accessLogConfigs: outputs.GetAlbLoadBalancersBalancerAccessLogConfig[];
    addressAllocatedMode: string;
    addressType: string;
    bandwidthPackageId: string;
    createTime: string;
    deletionProtectionConfigs: outputs.GetAlbLoadBalancersBalancerDeletionProtectionConfig[];
    dnsName: string;
    id: string;
    loadBalancerBillingConfigs: outputs.GetAlbLoadBalancersBalancerLoadBalancerBillingConfig[];
    loadBalancerBusinessStatus: string;
    loadBalancerBussinessStatus: string;
    loadBalancerEdition: string;
    loadBalancerId: string;
    loadBalancerName: string;
    loadBalancerOperationLocks: outputs.GetAlbLoadBalancersBalancerLoadBalancerOperationLock[];
    modificationProtectionConfigs: outputs.GetAlbLoadBalancersBalancerModificationProtectionConfig[];
    resourceGroupId: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    zoneMappings: outputs.GetAlbLoadBalancersBalancerZoneMapping[];
}

export interface GetAlbLoadBalancersBalancerAccessLogConfig {
    logProject: string;
    logStore: string;
}

export interface GetAlbLoadBalancersBalancerDeletionProtectionConfig {
    enabled: boolean;
    enabledTime: string;
}

export interface GetAlbLoadBalancersBalancerLoadBalancerBillingConfig {
    payType: string;
}

export interface GetAlbLoadBalancersBalancerLoadBalancerOperationLock {
    lockReason: string;
    lockType: string;
}

export interface GetAlbLoadBalancersBalancerModificationProtectionConfig {
    reason: string;
    status: string;
}

export interface GetAlbLoadBalancersBalancerZoneMapping {
    loadBalancerAddresses: outputs.GetAlbLoadBalancersBalancerZoneMappingLoadBalancerAddress[];
    vswitchId: string;
    zoneId: string;
}

export interface GetAlbLoadBalancersBalancerZoneMappingLoadBalancerAddress {
    address: string;
}

export interface GetAlbRulesRule {
    id: string;
    listenerId: string;
    loadBalancerId: string;
    priority: number;
    ruleActions: outputs.GetAlbRulesRuleRuleAction[];
    ruleConditions: outputs.GetAlbRulesRuleRuleCondition[];
    ruleId: string;
    ruleName: string;
    status: string;
}

export interface GetAlbRulesRuleRuleAction {
    fixedResponseConfigs: outputs.GetAlbRulesRuleRuleActionFixedResponseConfig[];
    forwardGroupConfigs: outputs.GetAlbRulesRuleRuleActionForwardGroupConfig[];
    insertHeaderConfigs: outputs.GetAlbRulesRuleRuleActionInsertHeaderConfig[];
    order: number;
    redirectConfigs: outputs.GetAlbRulesRuleRuleActionRedirectConfig[];
    rewriteConfigs: outputs.GetAlbRulesRuleRuleActionRewriteConfig[];
    trafficLimitConfigs: outputs.GetAlbRulesRuleRuleActionTrafficLimitConfig[];
    trafficMirrorConfigs: outputs.GetAlbRulesRuleRuleActionTrafficMirrorConfig[];
    type: string;
}

export interface GetAlbRulesRuleRuleActionFixedResponseConfig {
    content: string;
    contentType: string;
    httpCode: string;
}

export interface GetAlbRulesRuleRuleActionForwardGroupConfig {
    serverGroupTuples: outputs.GetAlbRulesRuleRuleActionForwardGroupConfigServerGroupTuple[];
}

export interface GetAlbRulesRuleRuleActionForwardGroupConfigServerGroupTuple {
    serverGroupId: string;
    weight: number;
}

export interface GetAlbRulesRuleRuleActionInsertHeaderConfig {
    key: string;
    value: string;
    valueType: string;
}

export interface GetAlbRulesRuleRuleActionRedirectConfig {
    host: string;
    httpCode: string;
    path: string;
    port: string;
    protocol: string;
    query: string;
}

export interface GetAlbRulesRuleRuleActionRewriteConfig {
    host: string;
    path: string;
    query: string;
}

export interface GetAlbRulesRuleRuleActionTrafficLimitConfig {
    qps: number;
}

export interface GetAlbRulesRuleRuleActionTrafficMirrorConfig {
    mirrorGroupConfigs: outputs.GetAlbRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfig[];
    targetType: string;
}

export interface GetAlbRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfig {
    serverGroupTuples: outputs.GetAlbRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple[];
}

export interface GetAlbRulesRuleRuleActionTrafficMirrorConfigMirrorGroupConfigServerGroupTuple {
    serverGroupId: string;
}

export interface GetAlbRulesRuleRuleCondition {
    cookieConfigs: outputs.GetAlbRulesRuleRuleConditionCookieConfig[];
    headerConfigs: outputs.GetAlbRulesRuleRuleConditionHeaderConfig[];
    hostConfigs: outputs.GetAlbRulesRuleRuleConditionHostConfig[];
    methodConfigs: outputs.GetAlbRulesRuleRuleConditionMethodConfig[];
    pathConfigs: outputs.GetAlbRulesRuleRuleConditionPathConfig[];
    queryStringConfigs: outputs.GetAlbRulesRuleRuleConditionQueryStringConfig[];
    sourceIpConfigs: outputs.GetAlbRulesRuleRuleConditionSourceIpConfig[];
    type: string;
}

export interface GetAlbRulesRuleRuleConditionCookieConfig {
    values: outputs.GetAlbRulesRuleRuleConditionCookieConfigValue[];
}

export interface GetAlbRulesRuleRuleConditionCookieConfigValue {
    key: string;
    value: string;
}

export interface GetAlbRulesRuleRuleConditionHeaderConfig {
    key: string;
    values: string[];
}

export interface GetAlbRulesRuleRuleConditionHostConfig {
    values: string[];
}

export interface GetAlbRulesRuleRuleConditionMethodConfig {
    values: string[];
}

export interface GetAlbRulesRuleRuleConditionPathConfig {
    values: string[];
}

export interface GetAlbRulesRuleRuleConditionQueryStringConfig {
    values: outputs.GetAlbRulesRuleRuleConditionQueryStringConfigValue[];
}

export interface GetAlbRulesRuleRuleConditionQueryStringConfigValue {
    key: string;
    value: string;
}

export interface GetAlbRulesRuleRuleConditionSourceIpConfig {
    values: string[];
}

export interface GetAlbSecurityPoliciesPolicy {
    ciphers: string[];
    id: string;
    resourceGroupId: string;
    securityPolicyId: string;
    securityPolicyName: string;
    status: string;
    tlsVersions: string[];
}

export interface GetAlbServerGroupsGroup {
    healthCheckConfigs: outputs.GetAlbServerGroupsGroupHealthCheckConfig[];
    id: string;
    protocol: string;
    scheduler: string;
    serverGroupId: string;
    serverGroupName: string;
    servers: outputs.GetAlbServerGroupsGroupServer[];
    status: string;
    stickySessionConfigs: outputs.GetAlbServerGroupsGroupStickySessionConfig[];
    tags: {[key: string]: string};
    vpcId: string;
}

export interface GetAlbServerGroupsGroupHealthCheckConfig {
    healthCheckCodes: string[];
    healthCheckConnectPort: number;
    healthCheckEnabled: boolean;
    healthCheckHost: string;
    healthCheckHttpVersion: string;
    healthCheckInterval: number;
    healthCheckMethod: string;
    healthCheckPath: string;
    healthCheckProtocol: string;
    healthCheckTimeout: number;
    healthyThreshold: number;
    unhealthyThreshold: number;
}

export interface GetAlbServerGroupsGroupServer {
    description: string;
    port: number;
    serverId: string;
    serverIp: string;
    serverType: string;
    status: string;
    weight: number;
}

export interface GetAlbServerGroupsGroupStickySessionConfig {
    cookie: string;
    cookieTimeout: number;
    stickySessionEnabled: boolean;
    stickySessionType: string;
}

export interface GetAlbSystemSecurityPoliciesPolicy {
    ciphers: string[];
    id: string;
    securityPolicyId: string;
    tlsVersions: string[];
}

export interface GetAlbZonesZone {
    id: string;
    localName: string;
    zoneId: string;
}

export interface GetAlidnsAccessStrategiesStrategy {
    accessMode: string;
    accessStrategyId: string;
    createTime: string;
    createTimestamp: string;
    defaultAddrPoolType: string;
    defaultAddrPools: outputs.GetAlidnsAccessStrategiesStrategyDefaultAddrPool[];
    defaultAvailableAddrNum: number;
    defaultLatencyOptimization: string;
    defaultLbaStrategy: string;
    defaultMaxReturnAddrNum: number;
    defaultMinAvailableAddrNum: number;
    effectiveAddrPoolGroupType: string;
    failoverAddrPoolType: string;
    failoverAddrPools: outputs.GetAlidnsAccessStrategiesStrategyFailoverAddrPool[];
    failoverAvailableAddrNum: number;
    failoverLatencyOptimization: string;
    failoverLbaStrategy: string;
    failoverMaxReturnAddrNum: number;
    failoverMinAvailableAddrNum: number;
    id: string;
    instanceId: string;
    lines: outputs.GetAlidnsAccessStrategiesStrategyLine[];
    strategyMode: string;
    strategyName: string;
}

export interface GetAlidnsAccessStrategiesStrategyDefaultAddrPool {
    addrCount: number;
    addrPoolId: string;
    lbaWeight: number;
    name: string;
}

export interface GetAlidnsAccessStrategiesStrategyFailoverAddrPool {
    addrCount: number;
    addrPoolId: string;
    lbaWeight: number;
    name: string;
}

export interface GetAlidnsAccessStrategiesStrategyLine {
    groupCode: string;
    groupName: string;
    lineCode: string;
    lineName: string;
}

export interface GetAlidnsAddressPoolsPool {
    addressPoolId: string;
    addressPoolName: string;
    addresses: outputs.GetAlidnsAddressPoolsPoolAddress[];
    createTime: string;
    createTimestamp: string;
    id: string;
    instanceId: string;
    lbaStrategy: string;
    monitorConfigId: string;
    monitorStatus: string;
    type: string;
    updateTime: string;
    updateTimestamp: string;
}

export interface GetAlidnsAddressPoolsPoolAddress {
    address: string;
    attributeInfo: string;
    lbaWeight: number;
    mode: string;
    remark: string;
}

export interface GetAlidnsCustomLinesLine {
    code: string;
    customLineId: string;
    customLineName: string;
    domainName: string;
    id: string;
    ipSegmentLists: outputs.GetAlidnsCustomLinesLineIpSegmentList[];
}

export interface GetAlidnsCustomLinesLineIpSegmentList {
    endIp: string;
    startIp: string;
}

export interface GetAlidnsDomainGroupsGroup {
    domainCount: number;
    groupId: string;
    groupName: string;
    id: string;
}

export interface GetAlidnsDomainsDomain {
    aliDomain: boolean;
    availableTtls: number[];
    dnsServers: string[];
    domainId: string;
    domainName: string;
    groupId: string;
    groupName: string;
    id: string;
    inBlackHole: boolean;
    inClean: boolean;
    instanceId: string;
    lineType: string;
    minTtl: number;
    punyCode: string;
    recordLineTreeJson: string;
    recordLines: outputs.GetAlidnsDomainsDomainRecordLine[];
    regionLines: boolean;
    remark: string;
    resourceGroupId: string;
    slaveDns: boolean;
    tags: {[key: string]: string};
    versionCode: string;
    versionName: string;
}

export interface GetAlidnsDomainsDomainRecordLine {
    fatherCode: string;
    lineCode: string;
    lineDisplayName: string;
    lineName: string;
}

export interface GetAlidnsGtmInstancesInstance {
    alertConfigs: outputs.GetAlidnsGtmInstancesInstanceAlertConfig[];
    alertGroups: string[];
    cnameType: string;
    createTime: string;
    expireTime: string;
    id: string;
    instanceId: string;
    instanceName: string;
    packageEdition: string;
    paymentType: string;
    publicCnameMode: string;
    publicRr: string;
    publicUserDomainName: string;
    publicZoneName: string;
    resourceGroupId: string;
    strategyMode: string;
    ttl: number;
}

export interface GetAlidnsGtmInstancesInstanceAlertConfig {
    dingtalkNotice: boolean;
    emailNotice: boolean;
    noticeType: string;
    smsNotice: boolean;
}

export interface GetAlidnsInstancesInstance {
    dnsSecurity: string;
    domain: string;
    domainNumbers: string;
    id: string;
    instanceId: string;
    paymentType: string;
    versionCode: string;
    versionName: string;
}

export interface GetAlidnsRecordsRecord {
    domainName: string;
    id: string;
    line: string;
    locked: boolean;
    priority: number;
    recordId: string;
    remark: string;
    rr: string;
    status: string;
    ttl: number;
    type: string;
    value: string;
}

export interface GetAlikafkaConsumerGroupsGroup {
    consumerId: string;
    id: string;
    instanceId: string;
    remark: string;
    tags: {[key: string]: string};
}

export interface GetAlikafkaInstancesInstance {
    allowedLists: outputs.GetAlikafkaInstancesInstanceAllowedList[];
    config: string;
    createTime: string;
    deployType: number;
    diskSize: number;
    diskType: number;
    domainEndpoint: string;
    eipMax: number;
    endPoint: string;
    expiredTime: number;
    id: string;
    ioMax: number;
    msgRetain: number;
    name: string;
    paidType: string;
    partitionNum: number;
    saslDomainEndpoint: string;
    securityGroup: string;
    serviceStatus: number;
    serviceVersion: string;
    specType: string;
    sslDomainEndpoint: string;
    sslEndPoint: string;
    tags: {[key: string]: string};
    topicQuota: number;
    upgradeServiceDetailInfos: outputs.GetAlikafkaInstancesInstanceUpgradeServiceDetailInfo[];
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetAlikafkaInstancesInstanceAllowedList {
    deployType: string;
    internetLists: outputs.GetAlikafkaInstancesInstanceAllowedListInternetList[];
    vpcLists: outputs.GetAlikafkaInstancesInstanceAllowedListVpcList[];
}

export interface GetAlikafkaInstancesInstanceAllowedListInternetList {
    allowedIpLists: string[];
    portRange: string;
}

export interface GetAlikafkaInstancesInstanceAllowedListVpcList {
    allowedIpLists: string[];
    portRange: string;
}

export interface GetAlikafkaInstancesInstanceUpgradeServiceDetailInfo {
    current2OpenSourceVersion: string;
}

export interface GetAlikafkaSaslAclsAcl {
    aclOperationType: string;
    aclResourceName: string;
    aclResourcePatternType: string;
    aclResourceType: string;
    host: string;
    username: string;
}

export interface GetAlikafkaSaslUsersUser {
    password: string;
    username: string;
}

export interface GetAlikafkaTopicsTopic {
    compactTopic: boolean;
    createTime: string;
    id: string;
    instanceId: string;
    localTopic: boolean;
    partitionNum: number;
    remark: string;
    status: number;
    statusName: string;
    tags: {[key: string]: string};
    topic: string;
}

export interface GetAmqpBindingsBinding {
    argument: string;
    bindingKey: string;
    bindingType: string;
    destinationName: string;
    id: string;
    instanceId: string;
    sourceExchange: string;
    virtualHostName: string;
}

export interface GetAmqpExchangesExchange {
    attributes: {[key: string]: string};
    autoDeleteState: boolean;
    createTime: string;
    exchangeName: string;
    exchangeType: string;
    id: string;
    instanceId: string;
    virtualHostName: string;
}

export interface GetAmqpInstancesInstance {
    createTime: string;
    expireTime: string;
    id: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    paymentType: string;
    privateEndPoint: string;
    publicEndpoint: string;
    renewalDuration: number;
    renewalDurationUnit: string;
    renewalStatus: string;
    status: string;
    supportEip: boolean;
}

export interface GetAmqpQueuesQueue {
    attributes: {[key: string]: string};
    autoDeleteState: boolean;
    createTime: string;
    exclusiveState: boolean;
    id: string;
    instanceId: string;
    lastConsumeTime: string;
    queueName: string;
    virtualHostName: string;
}

export interface GetAmqpStaticAccountsAccount {
    accessKey: string;
    createTime: string;
    id: string;
    instanceId: string;
    masterUid: string;
    password: string;
    userName: string;
}

export interface GetAmqpVirtualHostsHost {
    id: string;
    instanceId: string;
    virtualHostName: string;
}

export interface GetApiGatewayApisApi {
    apiId: string;
    description: string;
    groupId: string;
    groupName: string;
    id: string;
    name: string;
    regionId: string;
}

export interface GetApiGatewayAppsApp {
    appCode: string;
    createdTime: string;
    description: string;
    id: number;
    modifiedTime: string;
    name: string;
}

export interface GetApiGatewayBackendsBackend {
    backendId: string;
    backendName: string;
    backendType: string;
    createTime: string;
    description: string;
    id: string;
    modifiedTime: string;
}

export interface GetApiGatewayGroupsGroup {
    billingStatus: string;
    createdTime: string;
    description: string;
    id: string;
    illegalStatus: string;
    modifiedTime: string;
    name: string;
    regionId: string;
    subDomain: string;
    trafficLimit: number;
}

export interface GetApiGatewayLogConfigsConfig {
    id: string;
    logType: string;
    regionId: string;
    slsLogStore: string;
    slsProject: string;
}

export interface GetApiGatewayModelsModel {
    createTime: string;
    description: string;
    groupId: string;
    id: string;
    modelId: string;
    modelName: string;
    modelRef: string;
    modifiedTime: string;
    schema: string;
}

export interface GetApiGatewayPluginsPlugin {
    createTime: string;
    description: string;
    id: string;
    modifiedTime: string;
    pluginData: string;
    pluginId: string;
    pluginName: string;
    pluginType: string;
    tags: {[key: string]: string};
}

export interface GetArmsAlertContactGroupsGroup {
    alertContactGroupId: string;
    alertContactGroupName: string;
    contactIds: string[];
    createTime: string;
    id: string;
}

export interface GetArmsAlertContactsContact {
    alertContactId: string;
    alertContactName: string;
    createTime: string;
    dingRobotWebhookUrl: string;
    email: string;
    id: string;
    phoneNum: string;
    systemNoc: boolean;
    webhook: string;
}

export interface GetArmsDispatchRulesRule {
    dispatchRuleId: string;
    dispatchRuleName: string;
    dispatchType: string;
    groupRules: outputs.GetArmsDispatchRulesRuleGroupRule[];
    id: string;
    labelMatchExpressionGrids: outputs.GetArmsDispatchRulesRuleLabelMatchExpressionGrid[];
    notifyRules: outputs.GetArmsDispatchRulesRuleNotifyRule[];
    status: string;
}

export interface GetArmsDispatchRulesRuleGroupRule {
    groupId: number;
    groupInterval: number;
    groupWaitTime: number;
    groupingFields: string[];
    repeatInterval: number;
}

export interface GetArmsDispatchRulesRuleLabelMatchExpressionGrid {
    labelMatchExpressionGroups: outputs.GetArmsDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup[];
}

export interface GetArmsDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroup {
    labelMatchExpressions: outputs.GetArmsDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression[];
}

export interface GetArmsDispatchRulesRuleLabelMatchExpressionGridLabelMatchExpressionGroupLabelMatchExpression {
    key: string;
    operator: string;
    value: string;
}

export interface GetArmsDispatchRulesRuleNotifyRule {
    notifyChannels: string[];
    notifyObjects: outputs.GetArmsDispatchRulesRuleNotifyRuleNotifyObject[];
}

export interface GetArmsDispatchRulesRuleNotifyRuleNotifyObject {
    name: string;
    notifyObjectId: string;
    notifyType: string;
}

export interface GetArmsIntegrationExportersIntegrationExporter {
    clusterId: string;
    exporterType: string;
    id: string;
    instanceId: number;
    instanceName: string;
    integrationType: string;
    param: string;
    target: string;
    version: string;
}

export interface GetArmsPrometheisPromethei {
    authToken: string;
    clusterId: string;
    clusterName: string;
    clusterType: string;
    grafanaInstanceId: string;
    httpApiInterUrl: string;
    httpApiIntraUrl: string;
    id: string;
    pushGateWayInterUrl: string;
    pushGateWayIntraUrl: string;
    remoteReadInterUrl: string;
    remoteReadIntraUrl: string;
    remoteWriteInterUrl: string;
    remoteWriteIntraUrl: string;
    resourceGroupId: string;
    securityGroupId: string;
    subClustersJson: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetArmsPrometheusAlertRulesRule {
    annotations: outputs.GetArmsPrometheusAlertRulesRuleAnnotation[];
    clusterId: string;
    dispatchRuleId: string;
    duration: string;
    expression: string;
    id: string;
    labels: outputs.GetArmsPrometheusAlertRulesRuleLabel[];
    message: string;
    notifyType: string;
    prometheusAlertRuleId: string;
    prometheusAlertRuleName: string;
    status: number;
    type: string;
}

export interface GetArmsPrometheusAlertRulesRuleAnnotation {
    name: string;
    value: string;
}

export interface GetArmsPrometheusAlertRulesRuleLabel {
    name: string;
    value: string;
}

export interface GetArmsPrometheusMonitoringsPrometheusMonitoring {
    clusterId: string;
    configYaml: string;
    id: string;
    monitoringName: string;
    status: string;
    type: string;
}

export interface GetArmsPrometheusPromethei {
    authToken: string;
    clusterId: string;
    clusterName: string;
    clusterType: string;
    grafanaInstanceId: string;
    httpApiInterUrl: string;
    httpApiIntraUrl: string;
    id: string;
    pushGateWayInterUrl: string;
    pushGateWayIntraUrl: string;
    remoteReadInterUrl: string;
    remoteReadIntraUrl: string;
    remoteWriteInterUrl: string;
    remoteWriteIntraUrl: string;
    resourceGroupId: string;
    securityGroupId: string;
    subClustersJson: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetArmsRemoteWritesRemoteWrite {
    clusterId: string;
    id: string;
    remoteWriteName: string;
    remoteWriteYaml: string;
}

export interface GetBastionhostHostAccountsAccount {
    hasPassword: boolean;
    hostAccountId: string;
    hostAccountName: string;
    hostId: string;
    id: string;
    instanceId: string;
    privateKeyFingerprint: string;
    protocolName: string;
}

export interface GetBastionhostHostGroupsGroup {
    comment: string;
    hostGroupId: string;
    hostGroupName: string;
    id: string;
    instanceId: string;
}

export interface GetBastionhostHostShareKeysKey {
    hostShareKeyId: string;
    hostShareKeyName: string;
    id: string;
    instanceId: string;
    privateKeyFingerPrint: string;
}

export interface GetBastionhostHostsHost {
    activeAddressType: string;
    comment: string;
    hostId: string;
    hostName: string;
    hostPrivateAddress: string;
    hostPublicAddress: string;
    id: string;
    instanceId: string;
    osType: string;
    protocols: outputs.GetBastionhostHostsHostProtocol[];
    source: string;
    sourceInstanceId: string;
}

export interface GetBastionhostHostsHostProtocol {
    hostFingerPrint: string;
    port: number;
    protocolName: string;
}

export interface GetBastionhostInstancesInstance {
    description: string;
    id: string;
    instanceStatus: string;
    licenseCode: string;
    privateDomain: string;
    publicDomain: string;
    publicNetworkAccess: boolean;
    securityGroupIds: string[];
    tags: {[key: string]: string};
    userVswitchId: string;
}

export interface GetBastionhostUserGroupsGroup {
    comment: string;
    id: string;
    instanceId: string;
    userGroupId: string;
    userGroupName: string;
}

export interface GetBastionhostUsersUser {
    comment: string;
    displayName: string;
    email: string;
    id: string;
    instanceId: string;
    mobile: string;
    mobileCountryCode: string;
    source: string;
    sourceUserId: string;
    status: string;
    userId: string;
    userName: string;
}

export interface GetBpStudioApplicationsApplication {
    applicationId: string;
    applicationName: string;
    createTime: string;
    id: string;
    imageUrl: string;
    resourceGroupId: string;
    status: string;
    topoUrl: string;
}

export interface GetBrainIndustrialPidLoopsLoop {
    id: string;
    pidLoopConfiguration: string;
    pidLoopDcsType: string;
    pidLoopDesc: string;
    pidLoopId: string;
    pidLoopIsCrucial: boolean;
    pidLoopName: string;
    pidLoopType: string;
    pidProjectId: string;
    status: string;
}

export interface GetBrainIndustrialPidOrganizationsOrganization {
    id: string;
    parentPidOrganizationId: string;
    pidOrganizationId: string;
    pidOrganizationLevel: number;
    pidOrganizationName: string;
}

export interface GetBrainIndustrialPidProjectsProject {
    id: string;
    pidOrganizationId: string;
    pidProjectDesc: string;
    pidProjectId: string;
    pidProjectName: string;
}

export interface GetBssOpenApiPricingModulesModule {
    code: string;
    id: string;
    pricingModuleName: string;
    productCode: string;
    productType: string;
    subscriptionType: string;
    unit: string;
    values: outputs.GetBssOpenApiPricingModulesModuleValue[];
}

export interface GetBssOpenApiPricingModulesModuleValue {
    name: string;
    remark: string;
    type: string;
    value: string;
}

export interface GetBssOpenApiProductsProduct {
    id: string;
    productCode: string;
    productName: string;
    productType: string;
    subscriptionType: string;
}

export interface GetCasCertificatesCertificate {
    buyInAliyun: boolean;
    cert: string;
    certId: string;
    certificateName: string;
    city: string;
    common: string;
    country: string;
    endDate: string;
    expired: boolean;
    fingerprint: string;
    id: string;
    issuer: string;
    key: string;
    name: string;
    orgName: string;
    province: string;
    sans: string;
    startDate: string;
}

export interface GetCassandraBackupPlansPlan {
    active: boolean;
    backupPeriod: string;
    backupTime: string;
    clusterId: string;
    createTime: string;
    dataCenterId: string;
    id: string;
    retentionPeriod: number;
}

export interface GetCassandraClustersCluster {
    clusterId: string;
    clusterName: string;
    createdTime: string;
    dataCenterCount: number;
    expireTime: string;
    id: string;
    lockMode: string;
    majorVersion: string;
    minorVersion: string;
    payType: string;
    status: string;
    tags: {[key: string]: string};
}

export interface GetCassandraDataCentersCenter {
    clusterId: string;
    commodityInstance: string;
    createdTime: string;
    dataCenterId: string;
    dataCenterName: string;
    diskSize: number;
    diskType: string;
    expireTime: string;
    instanceType: string;
    lockMode: string;
    nodeCount: number;
    payType: string;
    status: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetCassandraZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetCddcDedicatedHostAccountsAccount {
    accountName: string;
    dedicatedHostId: string;
    id: string;
}

export interface GetCddcDedicatedHostGroupsGroup {
    allocationPolicy: string;
    bastionInstanceId: string;
    cpuAllocateRation: number;
    cpuAllocatedAmount: number;
    cpuAllocationRatio: number;
    createTime: string;
    dedicatedHostCountGroupByHostTypes: outputs.GetCddcDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType[];
    dedicatedHostGroupDesc: string;
    dedicatedHostGroupId: string;
    deployType: string;
    diskAllocateRation: number;
    diskAllocatedAmount: number;
    diskAllocationRatio: number;
    diskUsedAmount: number;
    diskUtility: number;
    engine: string;
    hostNumber: number;
    hostReplacePolicy: string;
    id: string;
    instanceNumber: number;
    memAllocateRation: number;
    memAllocatedAmount: number;
    memAllocationRatio: number;
    memUsedAmount: number;
    memUtility: number;
    text: string;
    vpcId: string;
    zoneIdLists: outputs.GetCddcDedicatedHostGroupsGroupZoneIdList[];
}

export interface GetCddcDedicatedHostGroupsGroupDedicatedHostCountGroupByHostType {
    placeHolder: string;
}

export interface GetCddcDedicatedHostGroupsGroupZoneIdList {
    zoneIdLists: string[];
}

export interface GetCddcDedicatedHostsHost {
    allocationStatus: string;
    bastionInstanceId: string;
    cpuAllocationRatio: string;
    cpuUsed: string;
    createTime: string;
    dedicatedHostGroupId: string;
    dedicatedHostId: string;
    diskAllocationRatio: string;
    ecsClassCode: string;
    endTime: string;
    engine: string;
    expiredTime: string;
    hostClass: string;
    hostCpu: string;
    hostMem: string;
    hostName: string;
    hostStorage: string;
    hostType: string;
    id: string;
    imageCategory: string;
    ipAddress: string;
    memAllocationRatio: string;
    memoryUsed: string;
    openPermission: string;
    status: string;
    storageUsed: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetCddcHostEcsLevelInfosInfo {
    description: string;
    ecsClass: string;
    ecsClassCode: string;
    resClassCode: string;
}

export interface GetCddcZonesZone {
    id: string;
    regionId: string;
    zoneId: string;
}

export interface GetCdnBlockedRegionsRegion {
    continent: string;
    countriesAndRegions: string;
    countriesAndRegionsName: string;
}

export interface GetCdnRealTimeLogDeliveriesDelivery {
    domain: string;
    id: string;
    logstore: string;
    project: string;
    slsRegion: string;
    status: string;
}

export interface GetCenBandwidthLimitsLimit {
    bandwidthLimit: number;
    instanceId: string;
    localRegionId: string;
    oppositeRegionId: string;
    status: string;
}

export interface GetCenBandwidthPackagesPackage {
    bandwidth: number;
    bandwidthPackageChargeType: string;
    businessStatus: string;
    cenBandwidthPackageId: string;
    cenBandwidthPackageName: string;
    cenIds: string[];
    description: string;
    expiredTime: string;
    geographicRegionAId: string;
    geographicRegionBId: string;
    geographicSpanId: string;
    hasReservationData: string;
    id: string;
    instanceId: string;
    isCrossBorder: boolean;
    name: string;
    paymentType: string;
    reservationActiveTime: string;
    reservationBandwidth: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    status: string;
}

export interface GetCenChildInstanceRouteEntryToAttachmentsAttachment {
    cenId: string;
    childInstanceRouteTableId: string;
    destinationCidrBlock: string;
    id: string;
    serviceType: string;
    status: string;
    transitRouterAttachmentId: string;
}

export interface GetCenFlowlogsFlowlog {
    cenId: string;
    description: string;
    flowLogId: string;
    flowLogName: string;
    id: string;
    logStoreName: string;
    projectName: string;
    status: string;
}

export interface GetCenInstanceAttachmentsAttachment {
    childInstanceAttachTime: string;
    childInstanceId: string;
    childInstanceOwnerId: number;
    childInstanceRegionId: string;
    childInstanceType: string;
    id: string;
    instanceId: string;
    status: string;
}

export interface GetCenInstancesInstance {
    cenBandwidthPackageIds: string[];
    cenId: string;
    cenInstanceName: string;
    createTime: string;
    description: string;
    id: string;
    name: string;
    protectionLevel: string;
    status: string;
    tags: {[key: string]: string};
}

export interface GetCenInterRegionTrafficQosPoliciesPolicy {
    id: string;
    interRegionTrafficQosPolicyDescription: string;
    interRegionTrafficQosPolicyId: string;
    interRegionTrafficQosPolicyName: string;
    status: string;
    transitRouterAttachmentId: string;
    transitRouterId: string;
}

export interface GetCenInterRegionTrafficQosQueuesQueue {
    dscps: string[];
    id: string;
    interRegionTrafficQosQueueDescription: string;
    interRegionTrafficQosQueueId: string;
    interRegionTrafficQosQueueName: string;
    remainBandwidthPercent: number;
    status: string;
    trafficQosPolicyId: string;
}

export interface GetCenPrivateZonesZone {
    accessRegionId: string;
    cenId: string;
    hostRegionId: string;
    hostVpcId: string;
    id: string;
    privateZoneDnsServers: string;
    status: string;
}

export interface GetCenRegionRouteEntriesEntry {
    cidrBlock: string;
    nextHopId: string;
    nextHopRegionId: string;
    nextHopType: string;
    type: string;
}

export interface GetCenRouteEntriesEntry {
    cidrBlock: string;
    conflicts: outputs.GetCenRouteEntriesEntryConflict[];
    nextHopId: string;
    nextHopType: string;
    operationalMode: boolean;
    publishStatus: string;
    routeTableId: string;
    routeType: string;
}

export interface GetCenRouteEntriesEntryConflict {
    cidrBlock: string;
    instanceId: string;
    instanceType: string;
    regionId: string;
    status: string;
}

export interface GetCenRouteMapsMap {
    asPathMatchMode: string;
    cenId: string;
    cenRegionId: string;
    cidrMatchMode: string;
    communityMatchMode: string;
    communityOperateMode: string;
    description: string;
    destinationChildInstanceTypes: string[];
    destinationCidrBlocks: string[];
    destinationInstanceIds: string[];
    destinationInstanceIdsReverseMatch: boolean;
    destinationRouteTableIds: string[];
    id: string;
    mapResult: string;
    matchAsns: string[];
    matchCommunitySets: string[];
    nextPriority: number;
    operateCommunitySets: string[];
    preference: number;
    prependAsPaths: string[];
    priority: number;
    routeMapId: string;
    routeTypes: string[];
    sourceChildInstanceTypes: string[];
    sourceInstanceIds: string[];
    sourceInstanceIdsReverseMatch: boolean;
    sourceRegionIds: string[];
    sourceRouteTableIds: string[];
    status: string;
    transmitDirection: string;
}

export interface GetCenRouteServicesService {
    accessRegionId: string;
    cenId: string;
    cidrs: string[];
    description: string;
    host: string;
    hostRegionId: string;
    hostVpcId: string;
    id: string;
    status: string;
    updateInterval: string;
}

export interface GetCenTrafficMarkingPoliciesPolicy {
    description: string;
    id: string;
    markingDscp: number;
    priority: number;
    status: string;
    trafficMarkingPolicyId: string;
    trafficMarkingPolicyName: string;
    transitRouterId: string;
}

export interface GetCenTransitRouteTableAggregationsTransitRouteTableAggregation {
    id: string;
    routeType: string;
    status: string;
    transitRouteTableAggregationCidr: string;
    transitRouteTableAggregationDescription: string;
    transitRouteTableAggregationName: string;
    transitRouteTableAggregationScope: string;
    transitRouteTableId: string;
}

export interface GetCenTransitRouterAvailableResourcesResource {
    availableZones: string[];
    masterZones: string[];
    slaveZones: string[];
    supportMulticast: boolean;
}

export interface GetCenTransitRouterCidrsCidr {
    cidr: string;
    description: string;
    family: string;
    id: string;
    publishCidrRoute: boolean;
    transitRouterCidrId: string;
    transitRouterCidrName: string;
    transitRouterId: string;
}

export interface GetCenTransitRouterMulticastDomainAssociationsAssociation {
    id: string;
    resourceId: string;
    resourceOwnerId: number;
    resourceType: string;
    status: string;
    transitRouterAttachmentId: string;
    transitRouterMulticastDomainId: string;
    vswitchId: string;
}

export interface GetCenTransitRouterMulticastDomainMembersMember {
    groupIpAddress: string;
    id: string;
    networkInterfaceId: string;
    status: string;
    transitRouterMulticastDomainId: string;
    vpcId: string;
}

export interface GetCenTransitRouterMulticastDomainPeerMembersMember {
    groupIpAddress: string;
    id: string;
    peerTransitRouterMulticastDomainId: string;
    status: string;
    transitRouterMulticastDomainId: string;
}

export interface GetCenTransitRouterMulticastDomainSourcesSource {
    groupIpAddress: string;
    id: string;
    networkInterfaceId: string;
    status: string;
    transitRouterMulticastDomainId: string;
    vpcId: string;
}

export interface GetCenTransitRouterMulticastDomainsDomain {
    id: string;
    status: string;
    transitRouterId: string;
    transitRouterMulticastDomainDescription: string;
    transitRouterMulticastDomainId: string;
    transitRouterMulticastDomainName: string;
}

export interface GetCenTransitRouterPeerAttachmentsAttachment {
    autoPublishRouteEnabled: boolean;
    bandwidth: number;
    cenBandwidthPackageId: string;
    geographicSpanId: string;
    id: string;
    peerTransitRouterId: string;
    peerTransitRouterOwnerId: string;
    peerTransitRouterRegionId: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentDescription: string;
    transitRouterAttachmentId: string;
    transitRouterAttachmentName: string;
    transitRouterId: string;
}

export interface GetCenTransitRouterPrefixListAssociationsAssociation {
    id: string;
    nextHop: string;
    nextHopInstanceId: string;
    nextHopType: string;
    ownerUid: number;
    prefixListId: string;
    status: string;
    transitRouterId: string;
    transitRouterTableId: string;
}

export interface GetCenTransitRouterRouteEntriesEntry {
    id: string;
    status: string;
    transitRouterRouteEntryDescription: string;
    transitRouterRouteEntryDestinationCidrBlock: string;
    transitRouterRouteEntryId: string;
    transitRouterRouteEntryName: string;
    transitRouterRouteEntryNextHopId: string;
    transitRouterRouteEntryNextHopType: string;
    transitRouterRouteEntryType: string;
}

export interface GetCenTransitRouterRouteTableAssociationsAssociation {
    id: string;
    resourceId: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentId: string;
    transitRouterRouteTableId: string;
}

export interface GetCenTransitRouterRouteTablePropagationsPropagation {
    id: string;
    resourceId: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentId: string;
}

export interface GetCenTransitRouterRouteTablesTable {
    id: string;
    status: string;
    transitRouterRouteTableDescription: string;
    transitRouterRouteTableId: string;
    transitRouterRouteTableName: string;
    transitRouterRouteTableType: string;
}

export interface GetCenTransitRouterVbrAttachmentsAttachment {
    autoPublishRouteEnabled: boolean;
    id: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentDescription: string;
    transitRouterAttachmentId: string;
    transitRouterAttachmentName: string;
    vbrId: string;
    vbrOwnerId: string;
}

export interface GetCenTransitRouterVpcAttachmentsAttachment {
    autoPublishRouteEnabled: boolean;
    cenId: string;
    id: string;
    paymentType: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentDescription: string;
    transitRouterAttachmentId: string;
    transitRouterAttachmentName: string;
    transitRouterId: string;
    vpcId: string;
    vpcOwnerId: string;
    zoneMappings: outputs.GetCenTransitRouterVpcAttachmentsAttachmentZoneMapping[];
}

export interface GetCenTransitRouterVpcAttachmentsAttachmentZoneMapping {
    vswitchId: string;
    zoneId: string;
}

export interface GetCenTransitRouterVpnAttachmentsAttachment {
    autoPublishRouteEnabled: boolean;
    createTime: string;
    id: string;
    resourceType: string;
    status: string;
    transitRouterAttachmentDescription: string;
    transitRouterAttachmentId: string;
    transitRouterAttachmentName: string;
    transitRouterId: string;
    vpnId: string;
    vpnOwnerId: string;
    zones: outputs.GetCenTransitRouterVpnAttachmentsAttachmentZone[];
}

export interface GetCenTransitRouterVpnAttachmentsAttachmentZone {
    zoneId: string;
}

export interface GetCenTransitRoutersTransitRouter {
    aliUid: string;
    cenId: string;
    id: string;
    status: string;
    transitRouterDescription: string;
    transitRouterId: string;
    transitRouterName: string;
    type: string;
    xgwVip: string;
}

export interface GetCenVbrHealthChecksCheck {
    cenId: string;
    healthCheckInterval: number;
    healthCheckSourceIp: string;
    healthCheckTargetIp: string;
    healthyThreshold: number;
    id: string;
    vbrInstanceId: string;
    vbrInstanceRegionId: string;
}

export interface GetChatbotAgentsAgent {
    agentId: string;
    agentKey: string;
    agentName: string;
    id: string;
}

export interface GetClickHouseAccountsAccount {
    accountDescription: string;
    accountName: string;
    accountType: string;
    dbClusterId: string;
    id: string;
    status: string;
}

export interface GetClickHouseBackupPoliciesPolicy {
    backupRetentionPeriod: number;
    dbClusterId: string;
    id: string;
    preferredBackupPeriods: string[];
    preferredBackupTime: string;
    status: string;
}

export interface GetClickHouseDbClustersCluster {
    aliUid: string;
    bid: string;
    category: string;
    commodityCode: string;
    connectionString: string;
    controlVersion: string;
    createTime: string;
    dbClusterAccessWhiteLists: outputs.GetClickHouseDbClustersClusterDbClusterAccessWhiteList[];
    dbClusterDescription: string;
    dbClusterId: string;
    dbClusterNetworkType: string;
    dbClusterType: string;
    dbNodeClass: string;
    dbNodeCount: string;
    dbNodeStorage: string;
    encryptionKey: string;
    encryptionType: string;
    engine: string;
    engineVersion: string;
    expireTime: string;
    id: string;
    isExpired: string;
    lockMode: string;
    lockReason: string;
    maintainTime: string;
    paymentType: string;
    port: number;
    publicConnectionString: string;
    publicPort: string;
    scaleOutStatuses: outputs.GetClickHouseDbClustersClusterScaleOutStatus[];
    status: string;
    storageType: string;
    supportBackup: number;
    supportHttpsPort: boolean;
    supportMysqlPort: boolean;
    vpcCloudInstanceId: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetClickHouseDbClustersClusterDbClusterAccessWhiteList {
    dbClusterIpArrayAttribute: string;
    dbClusterIpArrayName: string;
    securityIpList: string;
}

export interface GetClickHouseDbClustersClusterScaleOutStatus {
    progress: string;
    ratio: string;
}

export interface GetClickHouseRegionsRegion {
    regionId: string;
    zoneIds: outputs.GetClickHouseRegionsRegionZoneId[];
}

export interface GetClickHouseRegionsRegionZoneId {
    vpcEnabled: boolean;
    zoneId: string;
}

export interface GetCloudConnectNetworksNetwork {
    cidrBlock: string;
    description: string;
    id: string;
    isDefault: boolean;
    name: string;
}

export interface GetCloudFirewallAddressBooksBook {
    addressLists: string[];
    autoAddTagEcs: number;
    description: string;
    ecsTags: outputs.GetCloudFirewallAddressBooksBookEcsTag[];
    groupName: string;
    groupType: string;
    groupUuid: string;
    id: string;
    tagRelation: string;
}

export interface GetCloudFirewallAddressBooksBookEcsTag {
    tagKey: string;
    tagValue: string;
}

export interface GetCloudFirewallControlPoliciesPolicy {
    aclAction: string;
    aclUuid: string;
    applicationId: string;
    applicationName: string;
    description: string;
    destPort: string;
    destPortGroup: string;
    destPortGroupPorts: string[];
    destPortType: string;
    destination: string;
    destinationGroupCidrs: string[];
    destinationGroupType: string;
    destinationType: string;
    direction: string;
    dnsResult: string;
    dnsResultTime: string;
    hitTimes: string;
    id: string;
    order: number;
    proto: string;
    release: boolean;
    source: string;
    sourceGroupCidrs: string[];
    sourceGroupType: string;
    sourceType: string;
}

export interface GetCloudFirewallInstanceMembersMember {
    createTime: number;
    id: string;
    memberDesc: string;
    memberDisplayName: string;
    memberUid: string;
    modifyTime: number;
    status: string;
}

export interface GetCloudFirewallInstancesInstance {
    createTime: string;
    endTime: string;
    id: string;
    instanceId: string;
    paymentType: string;
    renewalDurationUnit: string;
    renewalStatus: string;
    status: string;
}

export interface GetCloudFirewallVpcFirewallCensCen {
    cenId: string;
    connectType: string;
    id: string;
    localVpcs: outputs.GetCloudFirewallVpcFirewallCensCenLocalVpc[];
    networkInstanceId: string;
    status: string;
    vpcFirewallId: string;
    vpcFirewallName: string;
}

export interface GetCloudFirewallVpcFirewallCensCenLocalVpc {
    attachmentId: string;
    attachmentName: string;
    defendCidrLists: string[];
    eniLists: outputs.GetCloudFirewallVpcFirewallCensCenLocalVpcEniList[];
    manualVswitchId: string;
    networkInstanceId: string;
    networkInstanceName: string;
    networkInstanceType: string;
    ownerId: string;
    regionNo: string;
    routeMode: string;
    supportManualMode: string;
    transitRouterId: string;
    transitRouterType: string;
    vpcCidrTableLists: outputs.GetCloudFirewallVpcFirewallCensCenLocalVpcVpcCidrTableList[];
    vpcId: string;
    vpcName: string;
}

export interface GetCloudFirewallVpcFirewallCensCenLocalVpcEniList {
    eniId: string;
    eniPrivateIpAddress: string;
}

export interface GetCloudFirewallVpcFirewallCensCenLocalVpcVpcCidrTableList {
    routeEntryLists: outputs.GetCloudFirewallVpcFirewallCensCenLocalVpcVpcCidrTableListRouteEntryList[];
    routeTableId: string;
}

export interface GetCloudFirewallVpcFirewallCensCenLocalVpcVpcCidrTableListRouteEntryList {
    destinationCidr: string;
    nextHopInstanceId: string;
}

export interface GetCloudFirewallVpcFirewallControlPoliciesPolicy {
    aclAction: string;
    aclUuid: string;
    applicationId: string;
    applicationName: string;
    description: string;
    destPort: string;
    destPortGroup: string;
    destPortGroupPorts: string[];
    destPortType: string;
    destination: string;
    destinationGroupCidrs: string[];
    destinationGroupType: string;
    destinationType: string;
    hitTimes: number;
    id: string;
    memberUid: string;
    order: number;
    proto: string;
    release: boolean;
    source: string;
    sourceGroupCidrs: string[];
    sourceGroupType: string;
    sourceType: string;
    vpcFirewallId: string;
}

export interface GetCloudFirewallVpcFirewallsFirewall {
    bandwidth: number;
    connectType: string;
    id: string;
    localVpcs: outputs.GetCloudFirewallVpcFirewallsFirewallLocalVpc[];
    peerVpcs: outputs.GetCloudFirewallVpcFirewallsFirewallPeerVpc[];
    regionStatus: string;
    status: string;
    vpcFirewallId: string;
    vpcFirewallName: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallLocalVpc {
    eniId: string;
    eniPrivateIpAddress: string;
    localVpcCidrTableLists: outputs.GetCloudFirewallVpcFirewallsFirewallLocalVpcLocalVpcCidrTableList[];
    regionNo: string;
    routerInterfaceId: string;
    vpcId: string;
    vpcName: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallLocalVpcLocalVpcCidrTableList {
    localRouteEntryLists: outputs.GetCloudFirewallVpcFirewallsFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList[];
    localRouteTableId: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallLocalVpcLocalVpcCidrTableListLocalRouteEntryList {
    localDestinationCidr: string;
    localNextHopInstanceId: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallPeerVpc {
    eniId: string;
    eniPrivateIpAddress: string;
    peerVpcCidrTableLists: outputs.GetCloudFirewallVpcFirewallsFirewallPeerVpcPeerVpcCidrTableList[];
    regionNo: string;
    routerInterfaceId: string;
    vpcId: string;
    vpcName: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallPeerVpcPeerVpcCidrTableList {
    peerRouteEntryLists: outputs.GetCloudFirewallVpcFirewallsFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList[];
    peerRouteTableId: string;
}

export interface GetCloudFirewallVpcFirewallsFirewallPeerVpcPeerVpcCidrTableListPeerRouteEntryList {
    peerDestinationCidr: string;
    peerNextHopInstanceId: string;
}

export interface GetCloudMonitorServiceHybridDoubleWritesHybridDoubleWrite {
    id: string;
    namespace: string;
    sourceNamespace: string;
    sourceUserId: string;
    userId: string;
}

export interface GetCloudSsoAccessAssignmentsAssignment {
    accessConfigurationId: string;
    accessConfigurationName: string;
    directoryId: string;
    id: string;
    principalId: string;
    principalName: string;
    principalType: string;
    targetId: string;
    targetName: string;
    targetPathName: string;
    targetType: string;
}

export interface GetCloudSsoAccessConfigurationsConfiguration {
    accessConfigurationId: string;
    accessConfigurationName: string;
    createTime: string;
    description: string;
    directoryId: string;
    id: string;
    permissionPolicies: outputs.GetCloudSsoAccessConfigurationsConfigurationPermissionPolicy[];
    relayState: string;
    sessionDuration: number;
    statusNotifications: string[];
}

export interface GetCloudSsoAccessConfigurationsConfigurationPermissionPolicy {
    addTime: string;
    permissionPolicyDocument: string;
    permissionPolicyName: string;
    permissionPolicyType: string;
}

export interface GetCloudSsoDirectoriesDirectory {
    createTime: string;
    directoryId: string;
    directoryName: string;
    id: string;
    mfaAuthenticationStatus: string;
    region: string;
    samlIdentityProviderConfigurations: outputs.GetCloudSsoDirectoriesDirectorySamlIdentityProviderConfiguration[];
    scimSynchronizationStatus: string;
    tasks: outputs.GetCloudSsoDirectoriesDirectoryTask[];
}

export interface GetCloudSsoDirectoriesDirectorySamlIdentityProviderConfiguration {
    createTime: string;
    encodedMetadataDocument: string;
    entityId: string;
    loginUrl: string;
    ssoStatus: string;
}

export interface GetCloudSsoDirectoriesDirectoryTask {
    accessConfigurationId: string;
    accessConfigurationName: string;
    endTime: string;
    failureReason: string;
    principalId: string;
    principalName: string;
    principalType: string;
    startTime: string;
    status: string;
    targetId: string;
    targetName: string;
    targetPath: string;
    targetType: string;
    taskId: string;
    taskType: string;
}

export interface GetCloudSsoGroupsGroup {
    createTime: string;
    description: string;
    directoryId: string;
    groupId: string;
    groupName: string;
    id: string;
    provisionType: string;
}

export interface GetCloudSsoScimServerCredentialsCredential {
    createTime: string;
    credentialId: string;
    credentialSecret: string;
    credentialType: string;
    directoryId: string;
    expireTime: string;
    id: string;
    status: string;
}

export interface GetCloudSsoUsersUser {
    createTime: string;
    description: string;
    directoryId: string;
    displayName: string;
    email: string;
    firstName: string;
    id: string;
    lastName: string;
    mfaDevices: outputs.GetCloudSsoUsersUserMfaDevice[];
    provisionType: string;
    status: string;
    userId: string;
    userName: string;
}

export interface GetCloudSsoUsersUserMfaDevice {
    deviceId: string;
    deviceName: string;
    deviceType: string;
    effectiveTime: string;
}

export interface GetCloudStorageGatewayExpressSyncsSync {
    bucketName: string;
    bucketPrefix: string;
    bucketRegion: string;
    description: string;
    expressSyncId: string;
    expressSyncName: string;
    id: string;
    mnsTopic: string;
}

export interface GetCloudStorageGatewayGatewayBlockVolumesVolume {
    address: string;
    cacheMode: string;
    chapEnabled: boolean;
    chapInUser: string;
    chunkSize: number;
    diskId: string;
    diskType: string;
    enabled: boolean;
    gatewayBlockVolumeName: string;
    gatewayId: string;
    id: string;
    indexId: string;
    localPath: string;
    lunId: number;
    ossBucketName: string;
    ossBucketSsl: boolean;
    ossEndpoint: string;
    port: number;
    protocol: string;
    size: number;
    state: string;
    status: number;
    target: string;
    totalDownload: number;
    totalUpload: number;
    volumeState: number;
}

export interface GetCloudStorageGatewayGatewayCacheDisksDisk {
    cacheDiskCategory: string;
    cacheDiskSizeInGb: number;
    cacheId: string;
    expiredTime: number;
    gatewayId: string;
    id: string;
    iops: number;
    isUsed: boolean;
    localFilePath: string;
    renewUrl: string;
    status: number;
}

export interface GetCloudStorageGatewayGatewayFileSharesShare {
    accessBasedEnumeration: boolean;
    address: string;
    backendLimit: number;
    browsable: boolean;
    bucketInfos: string;
    bucketsStub: boolean;
    bypassCacheRead: boolean;
    cacheMode: string;
    clientSideCmk: string;
    clientSideEncryption: boolean;
    directIo: boolean;
    diskId: string;
    diskType: string;
    downloadLimit: number;
    enabled: boolean;
    expressSyncId: string;
    fastReclaim: boolean;
    feLimit: number;
    fileNumLimit: string;
    fsSizeLimit: string;
    gatewayFileShareName: string;
    gatewayId: string;
    id: string;
    ignoreDelete: boolean;
    inPlace: boolean;
    inRate: string;
    indexId: string;
    kmsRotatePeriod: number;
    lagPeriod: string;
    localPath: string;
    mnsHealth: string;
    nfsV4Optimization: boolean;
    obsoleteBuckets: string;
    ossBucketName: string;
    ossBucketSsl: boolean;
    ossEndpoint: string;
    ossHealth: string;
    ossUsed: string;
    outRate: string;
    partialSyncPaths: string;
    pathPrefix: string;
    pollingInterval: number;
    protocol: string;
    remainingMetaSpace: string;
    remoteSync: boolean;
    remoteSyncDownload: boolean;
    roClientList: string;
    roUserList: string;
    rwClientList: string;
    rwUserList: string;
    serverSideCmk: string;
    serverSideEncryption: boolean;
    size: string;
    squash: string;
    state: string;
    supportArchive: boolean;
    syncProgress: number;
    totalDownload: string;
    totalUpload: string;
    transferAcceleration: boolean;
    used: string;
    windowsAcl: boolean;
}

export interface GetCloudStorageGatewayGatewaySmbUsersUser {
    gatewayId: string;
    id: string;
    username: string;
}

export interface GetCloudStorageGatewayGatewaysGateway {
    activatedTime: string;
    buyUrl: string;
    category: string;
    createTime: string;
    description: string;
    ecsInstanceId: string;
    expireStatus: number;
    expiredTime: string;
    gatewayClass: string;
    gatewayId: string;
    gatewayName: string;
    gatewayVersion: string;
    id: string;
    innerIp: string;
    ip: string;
    isReleaseAfterExpiration: boolean;
    location: string;
    paymentType: string;
    publicNetworkBandwidth: number;
    renewUrl: string;
    status: string;
    storageBundleId: string;
    taskId: string;
    type: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetCloudStorageGatewayStocksStock {
    availableGatewayClasses: string[];
    zoneId: string;
}

export interface GetCloudStorageGatewayStorageBundlesBundle {
    createTime: string;
    description: string;
    id: string;
    location: string;
    storageBundleId: string;
    storageBundleName: string;
}

export interface GetCloudauthFaceConfigsConfig {
    bizName: string;
    bizType: string;
    gmtUpdated: string;
}

export interface GetCmsAlarmContactGroupsGroup {
    alarmContactGroupName: string;
    contacts: string[];
    describe: string;
    enableSubscribed: boolean;
    id: string;
}

export interface GetCmsAlarmContactsContact {
    alarmContactName: string;
    channelsAliim: string;
    channelsDingWebHook: string;
    channelsMail: string;
    channelsSms: string;
    channelsStateAliim: string;
    channelsStateDingWebHook: string;
    channelsStateMail: string;
    channelsStatusSms: string;
    contactGroups: string[];
    describe: string;
    id: string;
    lang: string;
}

export interface GetCmsDynamicTagGroupsGroup {
    dynamicTagRuleId: string;
    id: string;
    matchExpressFilterRelation: string;
    matchExpresses: outputs.GetCmsDynamicTagGroupsGroupMatchExpress[];
    status: string;
    tagKey: string;
}

export interface GetCmsDynamicTagGroupsGroupMatchExpress {
    tagValue: string;
    tagValueMatchFunction: string;
}

export interface GetCmsEventRulesRule {
    description: string;
    eventPatterns: outputs.GetCmsEventRulesRuleEventPattern[];
    eventRuleName: string;
    eventType: string;
    groupId: string;
    id: string;
    silenceTime: number;
    status: string;
}

export interface GetCmsEventRulesRuleEventPattern {
    eventTypeLists: string[];
    keywordFilters: outputs.GetCmsEventRulesRuleEventPatternKeywordFilter[];
    levelLists: string[];
    nameLists: string[];
    product: string;
    sqlFilter: string;
}

export interface GetCmsEventRulesRuleEventPatternKeywordFilter {
    keyWords: string[];
    relation: string;
}

export interface GetCmsGroupMetricRulesRule {
    contactGroups: string;
    dimensions: string;
    effectiveInterval: string;
    emailSubject: string;
    enableState: boolean;
    escalations: outputs.GetCmsGroupMetricRulesRuleEscalation[];
    groupId: string;
    groupMetricRuleName: string;
    id: string;
    metricName: string;
    namespace: string;
    noEffectiveInterval: string;
    period: number;
    resources: string;
    ruleId: string;
    silenceTime: number;
    sourceType: string;
    status: string;
    webhook: string;
}

export interface GetCmsGroupMetricRulesRuleEscalation {
    criticals: outputs.GetCmsGroupMetricRulesRuleEscalationCritical[];
    infos: outputs.GetCmsGroupMetricRulesRuleEscalationInfo[];
    warns: outputs.GetCmsGroupMetricRulesRuleEscalationWarn[];
}

export interface GetCmsGroupMetricRulesRuleEscalationCritical {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: number;
}

export interface GetCmsGroupMetricRulesRuleEscalationInfo {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: number;
}

export interface GetCmsGroupMetricRulesRuleEscalationWarn {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: number;
}

export interface GetCmsHybridMonitorDatasData {
    labels: outputs.GetCmsHybridMonitorDatasDataLabel[];
    metricName: string;
    values: outputs.GetCmsHybridMonitorDatasDataValue[];
}

export interface GetCmsHybridMonitorDatasDataLabel {
    key: string;
    value: string;
}

export interface GetCmsHybridMonitorDatasDataValue {
    ts: string;
    value: string;
}

export interface GetCmsHybridMonitorFcTasksTask {
    createTime: string;
    hybridMonitorFcTaskId: string;
    id: string;
    namespace: string;
    targetUserId: string;
    yarmConfig: string;
}

export interface GetCmsHybridMonitorSlsTasksTask {
    attachLabels: outputs.GetCmsHybridMonitorSlsTasksTaskAttachLabel[];
    collectInterval: number;
    collectTargetEndpoint: string;
    collectTargetPath: string;
    collectTargetType: string;
    collectTimout: number;
    createTime: string;
    description: string;
    extraInfo: string;
    groupId: string;
    hybridMonitorSlsTaskId: string;
    id: string;
    instances: string[];
    logFilePath: string;
    logProcess: string;
    logSample: string;
    logSplit: string;
    matchExpressRelation: string;
    matchExpresses: outputs.GetCmsHybridMonitorSlsTasksTaskMatchExpress[];
    namespace: string;
    networkType: string;
    slsProcess: string;
    slsProcessConfigs: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfig[];
    taskName: string;
    taskType: string;
    uploadRegion: string;
    yarmConfig: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskAttachLabel {
    name: string;
    value: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskMatchExpress {
    function: string;
    name: string;
    value: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfig {
    expresses: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigExpress[];
    filters: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigFilter[];
    groupBies: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigGroupBy[];
    statistics: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigStatistic[];
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigExpress {
    alias: string;
    express: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigFilter {
    filters: outputs.GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilter[];
    relation: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigFilterFilter {
    operator: string;
    slsKeyName: string;
    value: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigGroupBy {
    alias: string;
    slsKeyName: string;
}

export interface GetCmsHybridMonitorSlsTasksTaskSlsProcessConfigStatistic {
    alias: string;
    function: string;
    parameterOne: string;
    parameterTwo: string;
    slsKeyName: string;
}

export interface GetCmsMetricRuleBlackListsList {
    category: string;
    createTime: string;
    effectiveTime: string;
    enableEndTime: string;
    enableStartTime: string;
    id: string;
    instances: string[];
    isEnable: boolean;
    metricRuleBlackListId: string;
    metricRuleBlackListName: string;
    metrics: outputs.GetCmsMetricRuleBlackListsListMetric[];
    namespace: string;
    scopeType: string;
    scopeValues: string[];
}

export interface GetCmsMetricRuleBlackListsListMetric {
    metricName: string;
    resource: string;
}

export interface GetCmsMetricRuleTemplatesTemplate {
    alertTemplates: outputs.GetCmsMetricRuleTemplatesTemplateAlertTemplate[];
    description: string;
    groupId: string;
    id: string;
    metricRuleTemplateName: string;
    restVersion: string;
    templateId: string;
}

export interface GetCmsMetricRuleTemplatesTemplateAlertTemplate {
    category: string;
    escalations: outputs.GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalation[];
    metricName: string;
    namespace: string;
    ruleName: string;
    selector: string;
    webhook: string;
}

export interface GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalation {
    criticals: outputs.GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationCritical[];
    infos: outputs.GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationInfo[];
    warns: outputs.GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationWarn[];
}

export interface GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationCritical {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: string;
}

export interface GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationInfo {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: string;
}

export interface GetCmsMetricRuleTemplatesTemplateAlertTemplateEscalationWarn {
    comparisonOperator: string;
    statistics: string;
    threshold: string;
    times: string;
}

export interface GetCmsMonitorGroupInstancesInstance {
    instances: outputs.GetCmsMonitorGroupInstancesInstanceInstance[];
}

export interface GetCmsMonitorGroupInstancesInstanceInstance {
    category: string;
    instanceId: string;
    instanceName: string;
    regionId: string;
}

export interface GetCmsMonitorGroupInstancesesInstance {
    instances: outputs.GetCmsMonitorGroupInstancesesInstanceInstance[];
}

export interface GetCmsMonitorGroupInstancesesInstanceInstance {
    category: string;
    instanceId: string;
    instanceName: string;
    regionId: string;
}

export interface GetCmsMonitorGroupsGroup {
    bindUrl: string;
    contactGroups: string[];
    dynamicTagRuleId: string;
    gmtCreate: number;
    gmtModified: number;
    groupId: string;
    id: string;
    monitorGroupName: string;
    serviceId: string;
    tags: {[key: string]: string};
    templateIds: string[];
    type: string;
}

export interface GetCmsNamespacesNamespace {
    createTime: string;
    description: string;
    id: string;
    modifyTime: string;
    namespace: string;
    namespaceId: string;
    specification: string;
}

export interface GetCmsSiteMonitorsMonitor {
    address: string;
    createTime: string;
    interval: string;
    taskId: string;
    taskName: string;
    taskType: string;
}

export interface GetCmsSlsGroupsGroup {
    createTime: string;
    id: string;
    slsGroupConfigs: outputs.GetCmsSlsGroupsGroupSlsGroupConfig[];
    slsGroupDescription: string;
    slsGroupName: string;
}

export interface GetCmsSlsGroupsGroupSlsGroupConfig {
    slsLogstore: string;
    slsProject: string;
    slsRegion: string;
    slsUserId: string;
}

export interface GetCommonBandwidthPackagesPackage {
    bandwidth: string;
    bandwidthPackageId: string;
    bandwidthPackageName: string;
    businessStatus: string;
    deletionProtection: boolean;
    description: string;
    expiredTime: string;
    hasReservationData: boolean;
    id: string;
    internetChargeType: string;
    isp: string;
    name: string;
    paymentType: string;
    publicIpAddresses: outputs.GetCommonBandwidthPackagesPackagePublicIpAddress[];
    ratio: number;
    reservationActiveTime: string;
    reservationBandwidth: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    resourceGroupId: string;
    serviceManaged: number;
    status: string;
}

export interface GetCommonBandwidthPackagesPackagePublicIpAddress {
    allocationId: string;
    bandwidthPackageIpRelationStatus: string;
    ipAddress: string;
}

export interface GetComputeNestServiceInstancesFilter {
    name?: string;
    values?: string[];
}

export interface GetComputeNestServiceInstancesServiceInstance {
    enableInstanceOps: boolean;
    id: string;
    operatedServiceInstanceId: string;
    operationEndTime: string;
    operationStartTime: string;
    parameters: string;
    resources: string;
    serviceInstanceId: string;
    serviceInstanceName: string;
    services: outputs.GetComputeNestServiceInstancesServiceInstanceService[];
    source: string;
    status: string;
    tags: {[key: string]: string};
    templateName: string;
}

export interface GetComputeNestServiceInstancesServiceInstanceService {
    deployType: string;
    publishTime: string;
    serviceId: string;
    serviceInfos: outputs.GetComputeNestServiceInstancesServiceInstanceServiceServiceInfo[];
    serviceType: string;
    status: string;
    supplierName: string;
    supplierUrl: string;
    version: string;
    versionName: string;
}

export interface GetComputeNestServiceInstancesServiceInstanceServiceServiceInfo {
    image: string;
    locale: string;
    name: string;
    shortDescription: string;
}

export interface GetConfigAggregateCompliancePacksPack {
    accountId: string;
    aggregateCompliancePackName: string;
    aggregatorCompliancePackId: string;
    compliancePackTemplateId: string;
    configRules: outputs.GetConfigAggregateCompliancePacksPackConfigRule[];
    description: string;
    id: string;
    riskLevel: number;
    status: string;
}

export interface GetConfigAggregateCompliancePacksPackConfigRule {
    configRuleId: string;
    configRuleParameters: outputs.GetConfigAggregateCompliancePacksPackConfigRuleConfigRuleParameter[];
    managedRuleIdentifier: string;
}

export interface GetConfigAggregateCompliancePacksPackConfigRuleConfigRuleParameter {
    parameterName: string;
    parameterValue: string;
    required: boolean;
}

export interface GetConfigAggregateConfigRulesRule {
    accountId: string;
    aggregateConfigRuleName: string;
    aggregatorId: string;
    compliancePackId: string;
    compliances: outputs.GetConfigAggregateConfigRulesRuleCompliance[];
    configRuleArn: string;
    configRuleId: string;
    configRuleTriggerTypes: string;
    description: string;
    eventSource: string;
    excludeResourceIdsScope: string;
    id: string;
    inputParameters: {[key: string]: string};
    maximumExecutionFrequency: string;
    modifiedTimestamp: string;
    regionIdsScope: string;
    resourceGroupIdsScope: string;
    resourceTypesScopes: string[];
    riskLevel: number;
    sourceIdentifier: string;
    sourceOwner: string;
    status: string;
    tagKeyScope: string;
    tagValueScope: string;
}

export interface GetConfigAggregateConfigRulesRuleCompliance {
    complianceType: string;
    count: number;
}

export interface GetConfigAggregateDeliveriesDelivery {
    accountId: string;
    aggregatorId: string;
    configurationItemChangeNotification: boolean;
    configurationSnapshot: boolean;
    deliveryChannelAssumeRoleArn: string;
    deliveryChannelCondition: string;
    deliveryChannelId: string;
    deliveryChannelName: string;
    deliveryChannelTargetArn: string;
    deliveryChannelType: string;
    description: string;
    id: string;
    nonCompliantNotification: boolean;
    oversizedDataOssTargetArn: string;
    status: number;
}

export interface GetConfigAggregatorsAggregator {
    accountId: string;
    aggregatorAccounts: outputs.GetConfigAggregatorsAggregatorAggregatorAccount[];
    aggregatorId: string;
    aggregatorName: string;
    aggregatorType: string;
    description: string;
    id: string;
    status: string;
}

export interface GetConfigAggregatorsAggregatorAggregatorAccount {
    accountId: string;
    accountName: string;
    accountType: string;
}

export interface GetConfigCompliancePacksPack {
    accountId: string;
    compliancePackId: string;
    compliancePackName: string;
    compliancePackTemplateId: string;
    configRules: outputs.GetConfigCompliancePacksPackConfigRule[];
    description: string;
    id: string;
    riskLevel: number;
    status: string;
}

export interface GetConfigCompliancePacksPackConfigRule {
    configRuleId: string;
    configRuleParameters: outputs.GetConfigCompliancePacksPackConfigRuleConfigRuleParameter[];
    managedRuleIdentifier: string;
}

export interface GetConfigCompliancePacksPackConfigRuleConfigRuleParameter {
    parameterName: string;
    parameterValue: string;
    required: boolean;
}

export interface GetConfigConfigurationRecordersRecorder {
    accountId: string;
    id: string;
    organizationEnableStatus: string;
    organizationMasterId: number;
    resourceTypes: string[];
    status: string;
}

export interface GetConfigDeliveriesDelivery {
    accountId: string;
    configurationItemChangeNotification: boolean;
    configurationSnapshot: boolean;
    deliveryChannelAssumeRoleArn: string;
    deliveryChannelCondition: string;
    deliveryChannelId: string;
    deliveryChannelName: string;
    deliveryChannelTargetArn: string;
    deliveryChannelType: string;
    description: string;
    id: string;
    nonCompliantNotification: boolean;
    oversizedDataOssTargetArn: string;
    status: number;
}

export interface GetConfigDeliveryChannelsChannel {
    deliveryChannelAssumeRoleArn: string;
    deliveryChannelCondition: string;
    deliveryChannelId: string;
    deliveryChannelName: string;
    deliveryChannelTargetArn: string;
    deliveryChannelType: string;
    description: string;
    id: string;
    status: number;
}

export interface GetConfigRulesRule {
    accountId: string;
    compliancePackId: string;
    compliances: outputs.GetConfigRulesRuleCompliance[];
    configRuleArn: string;
    configRuleId: string;
    configRuleState: string;
    configRuleTriggerTypes: string;
    description: string;
    eventSource: string;
    excludeResourceIdsScope: string;
    id: string;
    inputParameters: {[key: string]: string};
    maximumExecutionFrequency: string;
    modifiedTimestamp: string;
    regionIdsScope: string;
    resourceGroupIdsScope: string;
    resourceTypesScopes: string[];
    riskLevel: number;
    ruleName: string;
    scopeComplianceResourceTypes: string[];
    sourceDetailMessageType: string;
    sourceIdentifier: string;
    sourceMaximumExecutionFrequency: string;
    sourceOwner: string;
    status: string;
    tagKeyScope: string;
    tagValueScope: string;
}

export interface GetConfigRulesRuleCompliance {
    complianceType: string;
    count: number;
}

export interface GetCrChainsChain {
    chainConfigs: outputs.GetCrChainsChainChainConfig[];
    chainId: string;
    chainName: string;
    createTime: string;
    description: string;
    id: string;
    instanceId: string;
    modifiedTime: string;
    scopeId: string;
    scopeType: string;
}

export interface GetCrChainsChainChainConfig {
    nodes: outputs.GetCrChainsChainChainConfigNode[];
    routers: outputs.GetCrChainsChainChainConfigRouter[];
}

export interface GetCrChainsChainChainConfigNode {
    enable: boolean;
    nodeConfigs: outputs.GetCrChainsChainChainConfigNodeNodeConfig[];
    nodeName: string;
}

export interface GetCrChainsChainChainConfigNodeNodeConfig {
    denyPolicies: outputs.GetCrChainsChainChainConfigNodeNodeConfigDenyPolicy[];
}

export interface GetCrChainsChainChainConfigNodeNodeConfigDenyPolicy {
    action: string;
    issueCount: string;
    issueLevel: string;
    logic: string;
}

export interface GetCrChainsChainChainConfigRouter {
    froms: outputs.GetCrChainsChainChainConfigRouterFrom[];
    tos: outputs.GetCrChainsChainChainConfigRouterTo[];
}

export interface GetCrChainsChainChainConfigRouterFrom {
    nodeName: string;
}

export interface GetCrChainsChainChainConfigRouterTo {
    nodeName: string;
}

export interface GetCrChartNamespacesNamespace {
    autoCreateRepo: boolean;
    chartNamespaceId: string;
    defaultRepoType: string;
    id: string;
    instanceId: string;
    namespaceName: string;
}

export interface GetCrChartRepositoriesRepository {
    chartRepositoryId: string;
    createTime: string;
    id: string;
    instanceId: string;
    repoName: string;
    repoNamespaceName: string;
    repoType: string;
    summary: string;
}

export interface GetCrEeInstancesInstance {
    authorizationToken: string;
    id: string;
    name: string;
    namespaceQuota: string;
    namespaceUsage: string;
    publicEndpoints: string[];
    region: string;
    repoQuota: string;
    repoUsage: string;
    specification: string;
    tempUsername: string;
    vpcEndpoints: string[];
}

export interface GetCrEeNamespacesNamespace {
    autoCreate: boolean;
    defaultVisibility: string;
    id: string;
    instanceId: string;
    name: string;
    namespaceId: string;
    namespaceName: string;
}

export interface GetCrEeReposRepo {
    id: string;
    instanceId: string;
    name: string;
    namespace: string;
    repoType: string;
    summary: string;
    tags: outputs.GetCrEeReposRepoTag[];
}

export interface GetCrEeReposRepoTag {
    digest: string;
    imageCreate: string;
    imageId: string;
    imageSize: number;
    imageUpdate: string;
    status: string;
    tag: string;
}

export interface GetCrEeSyncRulesRule {
    id: string;
    instanceId: string;
    name: string;
    namespaceName: string;
    regionId: string;
    repoName: string;
    syncDirection: string;
    syncScope: string;
    syncTrigger: string;
    tagFilter: string;
    targetInstanceId: string;
    targetNamespaceName: string;
    targetRegionId: string;
    targetRepoName: string;
}

export interface GetCrEndpointAclPoliciesPolicy {
    description: string;
    endpointType: string;
    entry: string;
    id: string;
    instanceId: string;
}

export interface GetCrNamespacesNamespace {
    autoCreate: boolean;
    defaultVisibility: string;
    name: string;
}

export interface GetCrReposRepo {
    domainList: {[key: string]: string};
    name: string;
    namespace: string;
    repoType: string;
    summary: string;
    tags: outputs.GetCrReposRepoTag[];
}

export interface GetCrReposRepoTag {
    digest: string;
    imageCreate: number;
    imageId: string;
    imageSize: number;
    imageUpdate: number;
    status: string;
    tag: string;
}

export interface GetCrVpcEndpointLinkedVpcsVpcEndpointLinkedVpc {
    defaultAccess: boolean;
    id: string;
    instanceId: string;
    ip: string;
    moduleName: string;
    status: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetCsEdgeKubernetesClustersCluster {
    availabilityZone: string;
    connections: {[key: string]: string};
    id: string;
    name: string;
    natGatewayId: string;
    securityGroupId: string;
    vpcId: string;
    workerNodes: outputs.GetCsEdgeKubernetesClustersClusterWorkerNode[];
}

export interface GetCsEdgeKubernetesClustersClusterWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface GetCsKubernetesAddonsAddon {
    currentConfig: string;
    currentVersion: string;
    name: string;
    nextVersion: string;
    required: boolean;
}

export interface GetCsKubernetesClustersCluster {
    availabilityZone: string;
    clusterNetworkType: string;
    connections: {[key: string]: string};
    id: string;
    imageId: string;
    keyName: string;
    logConfigs: outputs.GetCsKubernetesClustersClusterLogConfig[];
    masterAutoRenew: boolean;
    masterAutoRenewPeriod: number;
    masterDiskCategory: string;
    masterDiskSize: number;
    masterInstanceChargeType: string;
    masterInstanceTypes: string[];
    masterNodes: outputs.GetCsKubernetesClustersClusterMasterNode[];
    masterPeriod: number;
    masterPeriodUnit: string;
    name: string;
    natGatewayId: string;
    nodeCidrMask: number;
    podCidr: string;
    securityGroupId: string;
    serviceCidr: string;
    slbInternetEnabled: boolean;
    vpcId: string;
    vswitchIds: string[];
    workerAutoRenew: boolean;
    workerAutoRenewPeriod: number;
    workerDataDiskCategory: string;
    workerDataDiskSize: number;
    workerDiskCategory: string;
    workerDiskSize: number;
    workerInstanceChargeType: string;
    workerInstanceTypes: string[];
    workerNodes: outputs.GetCsKubernetesClustersClusterWorkerNode[];
    workerNumbers: number[];
    workerPeriod: number;
    workerPeriodUnit: string;
}

export interface GetCsKubernetesClustersClusterLogConfig {
    project: string;
    type: string;
}

export interface GetCsKubernetesClustersClusterMasterNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface GetCsKubernetesClustersClusterWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface GetCsKubernetesPermissionsPermission {
    isOwner: boolean;
    isRamRole: boolean;
    resourceId: string;
    resourceType: string;
    roleName: string;
    roleType: string;
}

export interface GetCsKubernetesVersionMetadata {
    runtimes: outputs.GetCsKubernetesVersionMetadataRuntime[];
    version: string;
}

export interface GetCsKubernetesVersionMetadataRuntime {
    name: string;
    version: string;
}

export interface GetCsManagedKubernetesClustersCluster {
    availabilityZone: string;
    clusterNetworkType: string;
    connections: {[key: string]: string};
    id: string;
    imageId: string;
    keyName: string;
    logConfigs: outputs.GetCsManagedKubernetesClustersClusterLogConfig[];
    name: string;
    natGatewayId: string;
    podCidr: string;
    securityGroupId: string;
    serviceCidr: string;
    slbInternetEnabled: boolean;
    vpcId: string;
    vswitchIds: string[];
    workerAutoRenew: boolean;
    workerAutoRenewPeriod: number;
    workerDataDiskCategory: string;
    workerDataDiskSize: number;
    workerDiskCategory: string;
    workerDiskSize: number;
    workerInstanceChargeType: string;
    workerInstanceTypes: string[];
    workerNodes: outputs.GetCsManagedKubernetesClustersClusterWorkerNode[];
    workerNumbers: number[];
    workerPeriod: number;
    workerPeriodUnit: string;
}

export interface GetCsManagedKubernetesClustersClusterLogConfig {
    project: string;
    type: string;
}

export interface GetCsManagedKubernetesClustersClusterWorkerNode {
    id: string;
    name: string;
    privateIp: string;
}

export interface GetCsServerlessKubernetesClustersCluster {
    connections: {[key: string]: string};
    deletionProtection: boolean;
    endpointPublicAccessEnabled: boolean;
    id: string;
    name: string;
    natGatewayId: string;
    securityGroupId: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetDataWorksFoldersFolder {
    folderId: string;
    folderPath: string;
    id: string;
    projectId: string;
}

export interface GetDatabaseGatewayGatewaysGateway {
    createTime: string;
    gatewayDesc: string;
    gatewayInstances: outputs.GetDatabaseGatewayGatewaysGatewayGatewayInstance[];
    gatewayName: string;
    hosts: string;
    id: string;
    modifiedTime: string;
    parentId: string;
    status: string;
    userId: string;
}

export interface GetDatabaseGatewayGatewaysGatewayGatewayInstance {
    connectEndpointType: string;
    currentDaemonVersion: string;
    currentVersion: string;
    endPoint: string;
    gatewayInstanceId: string;
    gatewayInstanceStatus: string;
    lastUpdateTime: string;
    localIp: string;
    message: string;
    outputIp: string;
}

export interface GetDbInstanceClassInfosInfo {
    classCode?: string;
    classGroup?: string;
    cpu?: string;
    instructionSetArch?: string;
    maxConnections?: string;
    maxIombps?: string;
    maxIops?: string;
    memoryClass?: string;
    referencePrice?: string;
}

export interface GetDbInstanceClassesInstanceClass {
    instanceClass: string;
    price: string;
    storageRange: {[key: string]: string};
    zoneIds: outputs.GetDbInstanceClassesInstanceClassZoneId[];
}

export interface GetDbInstanceClassesInstanceClassZoneId {
    id: string;
    subZoneIds: string[];
}

export interface GetDbInstanceEnginesInstanceEngine {
    category: string;
    engine: string;
    engineVersion: string;
    zoneIds: outputs.GetDbInstanceEnginesInstanceEngineZoneId[];
}

export interface GetDbInstanceEnginesInstanceEngineZoneId {
    id: string;
    subZoneIds: string[];
}

export interface GetDbInstancesInstance {
    acl: string;
    availabilityZone: string;
    caType: string;
    chargeType: string;
    clientCaCert: string;
    clientCaCertExpireTime: string;
    clientCertRevocationList: string;
    connectionMode: string;
    connectionString: string;
    createTime: string;
    creator: string;
    dbInstanceStorageType: string;
    dbInstanceType: string;
    dbType: string;
    deleteDate: string;
    deletionProtection: boolean;
    description: string;
    encryptionKey: string;
    encryptionKeyStatus: string;
    engine: string;
    engineVersion: string;
    expireTime: string;
    guardInstanceId: string;
    haMode: string;
    hostInstanceInfos: outputs.GetDbInstancesInstanceHostInstanceInfo[];
    id: string;
    instanceStorage: number;
    instanceType: string;
    keyUsage: string;
    lastModifyStatus: string;
    masterInstanceId: string;
    masterZone: string;
    materialExpireTime: string;
    modifyStatusReason: string;
    name: string;
    netType: string;
    origin: string;
    parameters: outputs.GetDbInstancesInstanceParameter[];
    port: string;
    readonlyInstanceIds: string[];
    regionId: string;
    replicationAcl: string;
    requireUpdate: string;
    requireUpdateItem: string;
    requireUpdateReason: string;
    serverCaUrl: string;
    serverCert: string;
    serverKey: string;
    sslCreateTime: string;
    sslEnabled: string;
    sslExpireTime: string;
    status: string;
    syncMode: string;
    tempInstanceId: string;
    vpcId: string;
    vswitchId: string;
    zoneIdSlaveA: string;
    zoneIdSlaveB: string;
}

export interface GetDbInstancesInstanceHostInstanceInfo {
    dataSyncTime: string;
    logSyncTime: string;
    nodeId: string;
    nodeType: string;
    regionId: string;
    syncStatus: string;
    zoneId: string;
}

export interface GetDbInstancesInstanceParameter {
    checkingCode: string;
    forceModify: string;
    forceRestart: string;
    parameterDescription: string;
    parameterName: string;
    parameterValue: string;
}

export interface GetDbZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetDbfsAutoSnapShotPoliciesAutoSnapShotPolicy {
    appliedDbfsNumber: number;
    createTime: string;
    id: string;
    lastModified: string;
    policyId: string;
    policyName: string;
    repeatWeekdays: string[];
    retentionDays: number;
    status: string;
    statusDetail: string;
    timePoints: string[];
}

export interface GetDbfsInstancesInstance {
    attachNodeNumber: number;
    category: string;
    createTime: string;
    dbfsClusterId: string;
    ecsLists: outputs.GetDbfsInstancesInstanceEcsList[];
    enableRaid: boolean;
    encryption: boolean;
    id: string;
    instanceId: string;
    instanceName: string;
    kmsKeyId: string;
    paymentType: string;
    performanceLevel: string;
    raidStripeUnitNumber: string;
    size: number;
    status: string;
    zoneId: string;
}

export interface GetDbfsInstancesInstanceEcsList {
    ecsId: string;
}

export interface GetDbfsSnapshotsSnapshot {
    category: string;
    createTime: string;
    description: string;
    id: string;
    instanceId: string;
    lastModifiedTime: string;
    progress: string;
    remainTime: number;
    retentionDays: number;
    snapshotId: string;
    snapshotName: string;
    snapshotType: string;
    sourceFsSize: number;
    status: string;
}

export interface GetDbsBackupPlansPlan {
    backupGatewayId: string;
    backupMethod: string;
    backupObjects: string;
    backupPeriod: string;
    backupPlanId: string;
    backupPlanName: string;
    backupRetentionPeriod: number;
    backupStartTime: string;
    backupStorageType: string;
    crossAliyunId: string;
    crossRoleName: string;
    databaseType: string;
    duplicationArchivePeriod: number;
    duplicationInfrequentAccessPeriod: number;
    enableBackupLog: boolean;
    id: string;
    instanceClass: string;
    ossBucketName: string;
    paymentType: string;
    resourceGroupId: string;
    sourceEndpointDatabaseName: string;
    sourceEndpointInstanceId: string;
    sourceEndpointInstanceType: string;
    sourceEndpointRegion: string;
    sourceEndpointSid: string;
    sourceEndpointUserName: string;
    status: string;
}

export interface GetDcdnDomainsDomain {
    certName: string;
    cname: string;
    description: string;
    domainName: string;
    gmtModified: string;
    id: string;
    resourceGroupId: string;
    scope: string;
    sources: outputs.GetDcdnDomainsDomainSource[];
    sslProtocol: string;
    sslPub: string;
    status: string;
}

export interface GetDcdnDomainsDomainSource {
    content: string;
    enabled: string;
    port: number;
    priority: string;
    type: string;
    weight: string;
}

export interface GetDcdnIpaDomainsDomain {
    certName: string;
    cname: string;
    createTime: string;
    description: string;
    domainName: string;
    id: string;
    resourceGroupId: string;
    scope: string;
    sources: outputs.GetDcdnIpaDomainsDomainSource[];
    sslProtocol: string;
    sslPub: string;
    status: string;
}

export interface GetDcdnIpaDomainsDomainSource {
    content: string;
    port: number;
    priority: string;
    type: string;
    weight: number;
}

export interface GetDcdnWafDomainsDomain {
    clientIpTag: string;
    defenseScenes: outputs.GetDcdnWafDomainsDomainDefenseScene[];
    domainName: string;
    id: string;
}

export interface GetDcdnWafDomainsDomainDefenseScene {
    defenseScene: string;
    policyId: string;
}

export interface GetDcdnWafPoliciesPolicy {
    dcdnWafPolicyId: string;
    defenseScene: string;
    domainCount: number;
    gmtModified: string;
    id: string;
    policyName: string;
    policyType: string;
    ruleCount: string;
    status: string;
}

export interface GetDcdnWafRulesWafRule {
    action: string;
    ccStatus: string;
    cnRegionList: string;
    conditions: outputs.GetDcdnWafRulesWafRuleCondition[];
    defenseScene: string;
    effect: string;
    gmtModified: string;
    id: string;
    otherRegionList: string;
    policyId: string;
    rateLimits: outputs.GetDcdnWafRulesWafRuleRateLimit[];
    regularRules: string[];
    regularTypes: string[];
    remoteAddrs: string[];
    ruleName: string;
    scenes: string[];
    status: string;
    wafGroupIds: string;
    wafRuleId: string;
}

export interface GetDcdnWafRulesWafRuleCondition {
    key: string;
    opValue: string;
    subKey: string;
    values: string;
}

export interface GetDcdnWafRulesWafRuleRateLimit {
    interval: number;
    statuses: outputs.GetDcdnWafRulesWafRuleRateLimitStatus[];
    subKey: string;
    target: string;
    threshold: number;
    ttl: number;
}

export interface GetDcdnWafRulesWafRuleRateLimitStatus {
    code: string;
    count: number;
    ratio: number;
}

export interface GetDdosbgpInstancesInstance {
    bandwidth: number;
    baseBandwidth: number;
    id: string;
    ipCount: number;
    ipType: string;
    name: string;
    normalBandwidth: number;
    region: string;
    type: string;
}

export interface GetDdosbgpIpsIp {
    id: string;
    instanceId: string;
    ip: string;
    product: string;
    status: string;
}

export interface GetDdoscooDomainResourcesResource {
    blackLists: string[];
    ccEnabled: boolean;
    ccRuleEnabled: boolean;
    ccTemplate: string;
    certName: string;
    domain: string;
    http2Enable: boolean;
    httpsExt: string;
    id: string;
    instanceIds: string[];
    policyMode: string;
    proxyEnabled: boolean;
    proxyTypes: outputs.GetDdoscooDomainResourcesResourceProxyType[];
    realServers: string[];
    rsType: number;
    sslCiphers: string;
    sslProtocols: string;
    whiteLists: string[];
}

export interface GetDdoscooDomainResourcesResourceProxyType {
    proxyPorts: number[];
    proxyType: string;
}

export interface GetDdoscooInstancesInstance {
    bandwidth: number;
    baseBandwidth: number;
    createTime: number;
    debtStatus: number;
    domainCount: number;
    edition: number;
    enabled: number;
    expireTime: number;
    id: string;
    ipMode: string;
    ipVersion: string;
    name: string;
    portCount: number;
    remark: string;
    serviceBandwidth: number;
    status: number;
}

export interface GetDdoscooPortsPort {
    backendPort: string;
    frontendPort: string;
    frontendProtocol: string;
    id: string;
    instanceId: string;
    realServers: string[];
}

export interface GetDfsAccessGroupsGroup {
    accessGroupId: string;
    accessGroupName: string;
    createTime: string;
    description: string;
    id: string;
    mountPointCount: number;
    networkType: string;
    ruleCount: number;
}

export interface GetDfsAccessRulesRule {
    accessGroupId: string;
    accessRuleId: string;
    createTime: string;
    description: string;
    id: string;
    networkSegment: string;
    priority: number;
    rwAccessType: string;
}

export interface GetDfsFileSystemsSystem {
    createTime: string;
    description: string;
    fileSystemId: string;
    fileSystemName: string;
    id: string;
    mountPointCount: number;
    numberOfDirectories: number;
    numberOfFiles: number;
    protocolType: string;
    provisionedThroughputInMiBps: number;
    spaceCapacity: number;
    storagePackageId: string;
    storageType: string;
    throughputMode: string;
    usedSpaceSize: number;
    zoneId: string;
}

export interface GetDfsMountPointsPoint {
    accessGroupId: string;
    createTime: string;
    description: string;
    fileSystemId: string;
    id: string;
    mountPointDomain: string;
    mountPointId: string;
    networkType: string;
    status: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetDfsZonesZone {
    options: outputs.GetDfsZonesZoneOption[];
    zoneId: string;
}

export interface GetDfsZonesZoneOption {
    protocolType: string;
    storageType: string;
}

export interface GetDirectMailDomainsDomain {
    cnameAuthStatus: string;
    cnameConfirmStatus: string;
    cnameRecord: string;
    createTime: string;
    defaultDomain: string;
    dkimAuthStatus: string;
    dkimPublicKey: string;
    dkimRr: string;
    dmarcAuthStatus: string;
    dmarcHostRecord: string;
    dmarcRecord: string;
    dnsDmarc: string;
    dnsMx: string;
    dnsSpf: string;
    dnsTxt: string;
    domainId: string;
    domainName: string;
    domainRecord: string;
    domainType: string;
    hostRecord: string;
    icpStatus: string;
    id: string;
    mxAuthStatus: string;
    mxRecord: string;
    spfAuthStatus: string;
    spfRecord: string;
    status: string;
    tlDomainName: string;
    tracefRecord: string;
}

export interface GetDirectMailMailAddressesAddress {
    accountName: string;
    createTime: string;
    dailyCount: string;
    dailyReqCount: string;
    domainStatus: string;
    id: string;
    mailAddressId: string;
    monthCount: string;
    monthReqCount: string;
    replyAddress: string;
    replyStatus: string;
    sendtype: string;
    status: string;
}

export interface GetDirectMailReceiversesReceiverse {
    createTime: string;
    description: string;
    id: string;
    receiversAlias: string;
    receiversId: string;
    receiversName: string;
    status: number;
}

export interface GetDirectMailTagsTag {
    id: string;
    tagId: string;
    tagName: string;
}

export interface GetDisksDisk {
    attachedTime: string;
    autoSnapshotPolicyId: string;
    availabilityZone: string;
    category: string;
    creationTime: string;
    deleteAutoSnapshot: boolean;
    deleteWithInstance: boolean;
    description: string;
    detachedTime: string;
    device: string;
    diskId: string;
    diskName: string;
    diskType: string;
    enableAutoSnapshot: boolean;
    enableAutomatedSnapshotPolicy: boolean;
    encrypted: string;
    expiredTime: string;
    id: string;
    imageId: string;
    instanceId: string;
    iops: number;
    iopsRead: number;
    iopsWrite: number;
    kmsKeyId: string;
    mountInstanceNum: number;
    mountInstances: outputs.GetDisksDiskMountInstance[];
    name: string;
    operationLocks: outputs.GetDisksDiskOperationLock[];
    paymentType: string;
    performanceLevel: string;
    portable: boolean;
    productCode: string;
    regionId: string;
    resourceGroupId: string;
    size: number;
    snapshotId: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
    zoneId: string;
}

export interface GetDisksDiskMountInstance {
    attachedTime: string;
    device: string;
    instanceId: string;
}

export interface GetDisksDiskOperationLock {
    lockReason: string;
}

export interface GetDisksOperationLock {
    lockReason?: string;
}

export interface GetDmsEnterpriseDatabasesDatabase {
    catalogName: string;
    databaseId: string;
    dbType: string;
    dbaId: string;
    dbaName: string;
    encoding: string;
    envType: string;
    host: string;
    id: string;
    instanceId: string;
    ownerIdLists: string[];
    ownerNameLists: string[];
    port: number;
    schemaName: string;
    searchName: string;
    sid: string;
    state: string;
}

export interface GetDmsEnterpriseInstancesInstance {
    dataLinkName: string;
    databasePassword: string;
    databaseUser: string;
    dbaId: string;
    dbaNickName: string;
    ddlOnline: number;
    ecsInstanceId: string;
    ecsRegion: string;
    envType: string;
    exportTimeout: number;
    host: string;
    id: string;
    instanceAlias: string;
    instanceId: string;
    instanceName: string;
    instanceSource: string;
    instanceType: string;
    port: number;
    queryTimeout: number;
    safeRuleId: string;
    sid: string;
    status: string;
    useDsql: number;
    vpcId: string;
}

export interface GetDmsEnterpriseLogicDatabasesDatabase {
    alias: string;
    databaseIds: string[];
    dbType: string;
    envType: string;
    id: string;
    logic: boolean;
    logicDatabaseId: string;
    ownerIdLists: string[];
    ownerNameLists: string[];
    schemaName: string;
    searchName: string;
}

export interface GetDmsEnterpriseProxiesProxy {
    creatorId: string;
    creatorName: string;
    httpsPort: number;
    id: string;
    instanceId: string;
    privateEnable: boolean;
    privateHost: string;
    protocolPort: number;
    protocolType: string;
    proxyId: string;
    publicEnable: boolean;
    publicHost: string;
}

export interface GetDmsEnterpriseProxyAccessesAccess {
    accessId: string;
    accessSecret: string;
    createTime: string;
    id: string;
    indepAccount: string;
    instanceId: string;
    originInfo: string;
    proxyAccessId: string;
    proxyId: string;
    userId: string;
    userName: string;
    userUid: string;
}

export interface GetDmsEnterpriseUsersUser {
    id: string;
    mobile: string;
    nickName: string;
    parentUid: number;
    roleIds: number[];
    roleNames: string[];
    status: string;
    uid: string;
    userId: string;
    userName: string;
}

export interface GetDmsUserTenantsTenant {
    id: string;
    status: string;
    tenantName: string;
    tid: string;
}

export interface GetDnsDomainGroupsGroup {
    groupId: string;
    groupName: string;
}

export interface GetDnsDomainRecordsRecord {
    domainName: string;
    hostRecord: string;
    line: string;
    locked: boolean;
    priority: number;
    recordId: string;
    status: string;
    ttl: number;
    type: string;
    value: string;
}

export interface GetDnsDomainsDomain {
    aliDomain: boolean;
    availableTtls: number[];
    dnsServers: string[];
    domainId: string;
    domainName: string;
    groupId: string;
    groupName: string;
    id: string;
    inBlackHole: boolean;
    inClean: boolean;
    instanceId: string;
    lineType: string;
    minTtl: number;
    punyCode: string;
    recordLineTreeJson: string;
    recordLines: outputs.GetDnsDomainsDomainRecordLine[];
    regionLines: boolean;
    remark: string;
    resourceGroupId: string;
    slaveDns: boolean;
    tags: {[key: string]: string};
    versionCode: string;
    versionName: string;
}

export interface GetDnsDomainsDomainRecordLine {
    fatherCode: string;
    lineCode: string;
    lineDisplayName: string;
    lineName: string;
}

export interface GetDnsGroupsGroup {
    groupId: string;
    groupName: string;
}

export interface GetDnsInstancesInstance {
    dnsSecurity: string;
    domain: string;
    domainNumbers: string;
    id: string;
    instanceId: string;
    paymentType: string;
    versionCode: string;
    versionName: string;
}

export interface GetDnsRecordsRecord {
    domainName: string;
    hostRecord: string;
    line: string;
    locked: boolean;
    priority: number;
    recordId: string;
    status: string;
    ttl: number;
    type: string;
    value: string;
}

export interface GetDnsResolutionLinesLine {
    lineCode: string;
    lineDisplayName: string;
    lineName: string;
}

export interface GetDrdsInstancesInstance {
    connectionString: string;
    createTime: number;
    description: string;
    id: string;
    networkType: string;
    port: string;
    status: string;
    type: string;
    version: number;
    zoneId: string;
}

export interface GetDtsConsumerChannelsChannel {
    consumerGroupId: string;
    consumerGroupName: string;
    consumerGroupUserName: string;
    consumptionCheckpoint: string;
    id: string;
    messageDelay: number;
    unconsumedData: number;
}

export interface GetDtsInstancesInstance {
    createTime: string;
    destinationEndpointEngineName: string;
    destinationRegion: string;
    dtsInstanceId: string;
    id: string;
    instanceClass: string;
    instanceName: string;
    paymentType: string;
    resourceGroupId: string;
    sourceEndpointEngineName: string;
    sourceRegion: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
}

export interface GetDtsMigrationJobsJob {
    dataInitialization: boolean;
    dataSynchronization: boolean;
    dbList: string;
    destinationEndpointDataBaseName: string;
    destinationEndpointEngineName: string;
    destinationEndpointInstanceId: string;
    destinationEndpointInstanceType: string;
    destinationEndpointIp: string;
    destinationEndpointOracleSid: string;
    destinationEndpointPort: string;
    destinationEndpointRegion: string;
    destinationEndpointUserName: string;
    dtsInstanceId: string;
    dtsJobId: string;
    dtsJobName: string;
    id: string;
    paymentType: string;
    sourceEndpointDatabaseName: string;
    sourceEndpointEngineName: string;
    sourceEndpointInstanceId: string;
    sourceEndpointInstanceType: string;
    sourceEndpointIp: string;
    sourceEndpointOracleSid: string;
    sourceEndpointOwnerId: string;
    sourceEndpointPort: string;
    sourceEndpointRegion: string;
    sourceEndpointRole: string;
    sourceEndpointUserName: string;
    status: string;
    structureInitialization: boolean;
}

export interface GetDtsSubscriptionJobsJob {
    checkpoint: string;
    createTime: string;
    dbList: string;
    dtsInstanceId: string;
    dtsJobId: string;
    dtsJobName: string;
    expireTime: string;
    id: string;
    paymentType: string;
    sourceEndpointDatabaseName: string;
    sourceEndpointEngineName: string;
    sourceEndpointInstanceId: string;
    sourceEndpointInstanceType: string;
    sourceEndpointIp: string;
    sourceEndpointOracleSid: string;
    sourceEndpointOwnerId: string;
    sourceEndpointPort: string;
    sourceEndpointRegion: string;
    sourceEndpointRole: string;
    sourceEndpointUserName: string;
    status: string;
    subscriptionDataTypeDdl: boolean;
    subscriptionDataTypeDml: boolean;
    subscriptionHosts: outputs.GetDtsSubscriptionJobsJobSubscriptionHost[];
    subscriptionInstanceNetworkType: string;
    subscriptionInstanceVpcId: string;
    subscriptionInstanceVswitchId: string;
    tags: {[key: string]: string};
}

export interface GetDtsSubscriptionJobsJobSubscriptionHost {
    privateHost: string;
    publicHost: string;
    vpcHost: string;
}

export interface GetDtsSynchronizationJobsJob {
    checkpoint: string;
    createTime: string;
    dataInitialization: boolean;
    dataSynchronization: boolean;
    dbList: string;
    destinationEndpointDataBaseName: string;
    destinationEndpointEngineName: string;
    destinationEndpointInstanceId: string;
    destinationEndpointInstanceType: string;
    destinationEndpointIp: string;
    destinationEndpointOracleSid: string;
    destinationEndpointPort: string;
    destinationEndpointRegion: string;
    destinationEndpointUserName: string;
    dtsInstanceId: string;
    dtsJobId: string;
    dtsJobName: string;
    expireTime: string;
    id: string;
    sourceEndpointDatabaseName: string;
    sourceEndpointEngineName: string;
    sourceEndpointInstanceId: string;
    sourceEndpointInstanceType: string;
    sourceEndpointIp: string;
    sourceEndpointOracleSid: string;
    sourceEndpointOwnerId: string;
    sourceEndpointPort: string;
    sourceEndpointRegion: string;
    sourceEndpointRole: string;
    sourceEndpointUserName: string;
    status: string;
    structureInitialization: boolean;
    synchronizationDirection: string;
}

export interface GetEaisInstancesInstance {
    clientInstanceId: string;
    clientInstanceName: string;
    clientInstanceType: string;
    id: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    status: string;
    zoneId: string;
}

export interface GetEbsDedicatedBlockStorageClustersCluster {
    availableCapacity: string;
    category: string;
    createTime: string;
    dedicatedBlockStorageClusterId: string;
    dedicatedBlockStorageClusterName: string;
    deliveryCapacity: string;
    description: string;
    expiredTime: string;
    id: string;
    performanceLevel: string;
    resourceGroupId: string;
    status: string;
    supportedCategory: string;
    totalCapacity: string;
    type: string;
    usedCapacity: string;
    zoneId: string;
}

export interface GetEbsDiskReplicaGroupsGroup {
    description: string;
    destinationRegionId: string;
    destinationZoneId: string;
    groupName: string;
    id: string;
    lastRecoverPoint: string;
    primaryRegion: string;
    primaryZone: string;
    replicaGroupId: string;
    rpo: number;
    site: string;
    sourceRegionId: string;
    sourceZoneId: string;
    standbyRegion: string;
    standbyZone: string;
    status: string;
}

export interface GetEbsDiskReplicaPairsPair {
    bandwidth: string;
    description: string;
    destinationDiskId: string;
    destinationRegionId: string;
    destinationZoneId: string;
    diskId: string;
    id: string;
    pairName: string;
    paymentType: string;
    replicaPairId: string;
    resourceGroupId: string;
    rpo: string;
    sourceZoneId: string;
    status: string;
}

export interface GetEbsRegionsRegion {
    regionId: string;
    zones: outputs.GetEbsRegionsRegionZone[];
}

export interface GetEbsRegionsRegionZone {
    zoneId: string;
}

export interface GetEcdAdConnectorDirectoriesDirectory {
    adConnectorDirectoryId: string;
    adConnectors: outputs.GetEcdAdConnectorDirectoriesDirectoryAdConnector[];
    createTime: string;
    customSecurityGroupId: string;
    directoryName: string;
    directoryType: string;
    dnsAddresses: string[];
    dnsUserName: string;
    domainName: string;
    domainUserName: string;
    enableAdminAccess: boolean;
    id: string;
    mfaEnabled: boolean;
    status: string;
    subDnsAddresses: string[];
    subDomainName: string;
    trustPassword: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface GetEcdAdConnectorDirectoriesDirectoryAdConnector {
    adConnectorAddress: string;
    connectorStatus: string;
    networkInterfaceId: string;
    specification: string;
    trustKey: string;
    vswitchId: string;
}

export interface GetEcdAdConnectorOfficeSitesSite {
    adConnectorOfficeSiteName: string;
    adConnectors: outputs.GetEcdAdConnectorOfficeSitesSiteAdConnector[];
    bandwidth: number;
    cenId: string;
    cidrBlock: string;
    createTime: string;
    customSecurityGroupId: string;
    desktopAccessType: string;
    desktopVpcEndpoint: string;
    dnsAddresses: string[];
    dnsUserName: string;
    domainName: string;
    domainUserName: string;
    enableAdminAccess: boolean;
    enableCrossDesktopAccess: boolean;
    enableInternetAccess: boolean;
    fileSystemIds: string[];
    id: string;
    logs: outputs.GetEcdAdConnectorOfficeSitesSiteLog[];
    mfaEnabled: boolean;
    networkPackageId: string;
    officeSiteId: string;
    officeSiteType: string;
    ssoEnabled: boolean;
    status: string;
    subDomainDnsAddresses: string[];
    subDomainName: string;
    trustPassword: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface GetEcdAdConnectorOfficeSitesSiteAdConnector {
    adConnectorAddress: string;
    connectorStatus: string;
    networkInterfaceId: string;
    vswitchId: string;
}

export interface GetEcdAdConnectorOfficeSitesSiteLog {
    level: string;
    message: string;
    step: string;
    timeStamp: string;
}

export interface GetEcdBundlesBundle {
    bundleId: string;
    bundleName: string;
    bundleType: string;
    description: string;
    desktopType: string;
    desktopTypeAttributes: outputs.GetEcdBundlesBundleDesktopTypeAttribute[];
    disks: outputs.GetEcdBundlesBundleDisk[];
    id: string;
    imageId: string;
    osType: string;
}

export interface GetEcdBundlesBundleDesktopTypeAttribute {
    cpuCount: number;
    gpuCount: string;
    gpuSpec: string;
    memorySize: string;
}

export interface GetEcdBundlesBundleDisk {
    diskSize: string;
    diskType: string;
}

export interface GetEcdCommandsCommand {
    commandContent: string;
    commandType: string;
    createTime: string;
    id: string;
    invokeDesktops: outputs.GetEcdCommandsCommandInvokeDesktop[];
    invokeId: string;
    status: string;
}

export interface GetEcdCommandsCommandInvokeDesktop {
    desktopId: string;
    dropped: number;
    errorCode: string;
    errorInfo: string;
    exitCode: string;
    finishTime: string;
    invocationStatus: string;
    output: string;
    repeats: number;
    startTime: string;
    stopTime: string;
}

export interface GetEcdCustomPropertiesProperty {
    customPropertyId: string;
    id: string;
    propertyKey: string;
    propertyValues: outputs.GetEcdCustomPropertiesPropertyPropertyValue[];
}

export interface GetEcdCustomPropertiesPropertyPropertyValue {
    propertyValue: string;
    propertyValueId: string;
}

export interface GetEcdDesktopTypesType {
    cpuCount: string;
    dataDiskSize: string;
    desktopTypeId: string;
    gpuCount: number;
    gpuSpec: string;
    id: string;
    instanceTypeFamily: string;
    memorySize: string;
    status: string;
    systemDiskSize: string;
}

export interface GetEcdDesktopsDesktop {
    cpu: number;
    createTime: string;
    desktopId: string;
    desktopName: string;
    desktopType: string;
    directoryId: string;
    endUserIds: string[];
    expiredTime: string;
    id: string;
    imageId: string;
    memory: string;
    networkInterfaceId: string;
    paymentType: string;
    policyGroupId: string;
    status: string;
    systemDiskSize: number;
}

export interface GetEcdImagesImage {
    createTime: string;
    dataDiskSize: number;
    description: string;
    gpuCategory: boolean;
    id: string;
    imageId: string;
    imageName: string;
    imageType: string;
    osType: string;
    progress: string;
    size: number;
    status: string;
}

export interface GetEcdNasFileSystemsSystem {
    capacity: string;
    createTime: string;
    description: string;
    fileSystemId: string;
    fileSystemType: string;
    id: string;
    meteredSize: string;
    mountTargetDomain: string;
    mountTargetStatus: string;
    nasFileSystemName: string;
    officeSiteId: string;
    officeSiteName: string;
    status: string;
    storageType: string;
    supportAcl: boolean;
    zoneId: string;
}

export interface GetEcdNetworkPackagesPackage {
    bandwidth: number;
    createTime: string;
    eipAddresses: string[];
    expiredTime: string;
    id: string;
    internetChargeType: string;
    networkPackageId: string;
    officeSiteId: string;
    officeSiteName: string;
    status: string;
}

export interface GetEcdPolicyGroupsGroup {
    authorizeAccessPolicyRules: outputs.GetEcdPolicyGroupsGroupAuthorizeAccessPolicyRule[];
    authorizeSecurityPolicyRules: outputs.GetEcdPolicyGroupsGroupAuthorizeSecurityPolicyRule[];
    cameraRedirect: string;
    clipboard: string;
    domainList: string;
    edsCount: number;
    htmlAccess: string;
    htmlFileTransfer: string;
    id: string;
    localDrive: string;
    policyGroupId: string;
    policyGroupName: string;
    policyGroupType: string;
    recording: string;
    recordingEndTime: string;
    recordingFps: number;
    recordingStartTime: string;
    status: string;
    usbRedirect: string;
    visualQuality: string;
    watermark: string;
    watermarkTransparency: string;
    watermarkType: string;
}

export interface GetEcdPolicyGroupsGroupAuthorizeAccessPolicyRule {
    cidrIp: string;
    description: string;
}

export interface GetEcdPolicyGroupsGroupAuthorizeSecurityPolicyRule {
    cidrIp: string;
    description: string;
    ipProtocol: string;
    policy: string;
    portRange: string;
    priority: string;
    type: string;
}

export interface GetEcdRamDirectoriesDirectory {
    adConnectors: outputs.GetEcdRamDirectoriesDirectoryAdConnector[];
    createTime: string;
    customSecurityGroupId: string;
    desktopAccessType: string;
    desktopVpcEndpoint: string;
    directoryType: string;
    dnsAddresses: string[];
    dnsUserName: string;
    domainName: string;
    domainPassword: string;
    domainUserName: string;
    enableAdminAccess: boolean;
    enableCrossDesktopAccess: boolean;
    enableInternetAccess: boolean;
    fileSystemIds: string[];
    id: string;
    logs: outputs.GetEcdRamDirectoriesDirectoryLog[];
    mfaEnabled: boolean;
    ramDirectoryId: string;
    ramDirectoryName: string;
    ssoEnabled: boolean;
    status: string;
    subDnsAddresses: string[];
    subDomainName: string;
    trustPassword: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface GetEcdRamDirectoriesDirectoryAdConnector {
    adConnectorAddress: string;
    connectorStatus: string;
    networkInterfaceId: string;
    vswitchId: string;
}

export interface GetEcdRamDirectoriesDirectoryLog {
    level: string;
    message: string;
    step: string;
    timeStamp: string;
}

export interface GetEcdSimpleOfficeSitesSite {
    bandwidth: number;
    cenId: string;
    cidrBlock: string;
    createTime: string;
    customSecurityGroupId: string;
    desktopAccessType: string;
    desktopVpcEndpoint: string;
    dnsAddresses: string[];
    dnsUserName: string;
    domainName: string;
    domainPassword: string;
    domainUserName: string;
    enableAdminAccess: boolean;
    enableCrossDesktopAccess: boolean;
    enableInternetAccess: boolean;
    fileSystemIds: string[];
    id: string;
    mfaEnabled: boolean;
    networkPackageId: string;
    officeSiteId: string;
    officeSiteType: string;
    simpleOfficeSiteName: string;
    ssoEnabled: boolean;
    ssoStatus: boolean;
    status: string;
    subDnsAddresses: string[];
    subDomainName: string;
    trustPassword: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface GetEcdSnapshotsSnapshot {
    createTime: string;
    description: string;
    desktopId: string;
    id: string;
    progress: string;
    remainTime: number;
    snapshotId: string;
    snapshotName: string;
    snapshotType: string;
    sourceDiskSize: string;
    sourceDiskType: string;
    status: string;
}

export interface GetEcdUsersUser {
    email: string;
    endUserId: string;
    id: string;
    phone: string;
    status: string;
}

export interface GetEcdZonesZone {
    zoneId: string;
}

export interface GetEciContainerGroupsGroup {
    containerGroupId: string;
    containerGroupName: string;
    containers: outputs.GetEciContainerGroupsGroupContainer[];
    cpu: number;
    discount: number;
    dnsConfigs: outputs.GetEciContainerGroupsGroupDnsConfig[];
    eciSecurityContexts: outputs.GetEciContainerGroupsGroupEciSecurityContext[];
    eniInstanceId: string;
    events: outputs.GetEciContainerGroupsGroupEvent[];
    expiredTime: string;
    failedTime: string;
    hostAliases: outputs.GetEciContainerGroupsGroupHostAlias[];
    id: string;
    initContainers: outputs.GetEciContainerGroupsGroupInitContainer[];
    instanceType: string;
    internetIp: string;
    intranetIp: string;
    ipv6Address: string;
    memory: number;
    ramRoleName: string;
    resourceGroupId: string;
    restartPolicy: string;
    securityGroupId: string;
    status: string;
    succeededTime: string;
    tags: {[key: string]: string};
    volumes: outputs.GetEciContainerGroupsGroupVolume[];
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEciContainerGroupsGroupContainer {
    args: string[];
    commands: string[];
    cpu: number;
    environmentVars: outputs.GetEciContainerGroupsGroupContainerEnvironmentVar[];
    gpu: number;
    image: string;
    imagePullPolicy: string;
    memory: number;
    name: string;
    ports: outputs.GetEciContainerGroupsGroupContainerPort[];
    ready: boolean;
    restartCount: number;
    volumeMounts: outputs.GetEciContainerGroupsGroupContainerVolumeMount[];
    workingDir: string;
}

export interface GetEciContainerGroupsGroupContainerEnvironmentVar {
    key: string;
    value: string;
}

export interface GetEciContainerGroupsGroupContainerPort {
    port: number;
    protocol: string;
}

export interface GetEciContainerGroupsGroupContainerVolumeMount {
    mountPath: string;
    name: string;
    readOnly: boolean;
}

export interface GetEciContainerGroupsGroupDnsConfig {
    nameServers: string[];
    options: outputs.GetEciContainerGroupsGroupDnsConfigOption[];
    searches: string[];
}

export interface GetEciContainerGroupsGroupDnsConfigOption {
    name: string;
    value: string;
}

export interface GetEciContainerGroupsGroupEciSecurityContext {
    sysctls: outputs.GetEciContainerGroupsGroupEciSecurityContextSysctl[];
}

export interface GetEciContainerGroupsGroupEciSecurityContextSysctl {
    name: string;
    value: string;
}

export interface GetEciContainerGroupsGroupEvent {
    count: number;
    firstTimestamp: string;
    lastTimestamp: string;
    message: string;
    name: string;
    reason: string;
    type: string;
}

export interface GetEciContainerGroupsGroupHostAlias {
    hostnames: string[];
    ip: string;
}

export interface GetEciContainerGroupsGroupInitContainer {
    args: string[];
    commands: string[];
    cpu: number;
    environmentVars: outputs.GetEciContainerGroupsGroupInitContainerEnvironmentVar[];
    gpu: number;
    image: string;
    imagePullPolicy: string;
    memory: number;
    name: string;
    ports: outputs.GetEciContainerGroupsGroupInitContainerPort[];
    ready: boolean;
    restartCount: number;
    volumeMounts: outputs.GetEciContainerGroupsGroupInitContainerVolumeMount[];
    workingDir: string;
}

export interface GetEciContainerGroupsGroupInitContainerEnvironmentVar {
    key: string;
    value: string;
}

export interface GetEciContainerGroupsGroupInitContainerPort {
    port: number;
    protocol: string;
}

export interface GetEciContainerGroupsGroupInitContainerVolumeMount {
    mountPath: string;
    name: string;
    readOnly: boolean;
}

export interface GetEciContainerGroupsGroupVolume {
    configFileVolumeConfigFileToPaths: outputs.GetEciContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath[];
    diskVolumeDiskId: string;
    diskVolumeFsType: string;
    flexVolumeDriver: string;
    flexVolumeFsType: string;
    flexVolumeOptions: string;
    name: string;
    nfsVolumePath: string;
    nfsVolumeReadOnly: boolean;
    nfsVolumeServer: string;
    type: string;
}

export interface GetEciContainerGroupsGroupVolumeConfigFileVolumeConfigFileToPath {
    content: string;
    path: string;
}

export interface GetEciImageCachesCach {
    containerGroupId: string;
    events: outputs.GetEciImageCachesCachEvent[];
    expireDateTime: string;
    id: string;
    imageCacheId: string;
    imageCacheName: string;
    images: string[];
    progress: string;
    snapshotId: string;
    status: string;
}

export interface GetEciImageCachesCachEvent {
    count: number;
    firstTimestamp: string;
    lastTimestamp: string;
    message: string;
    name: string;
    type: string;
}

export interface GetEciVirtualNodesNode {
    cpu: number;
    createTime: string;
    eniInstanceId: string;
    events: outputs.GetEciVirtualNodesNodeEvent[];
    id: string;
    internetIp: string;
    intranetIp: string;
    memory: number;
    ramRoleName: string;
    resourceGroupId: string;
    securityGroupId: string;
    status: string;
    tags: {[key: string]: string};
    virtualNodeId: string;
    virtualNodeName: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEciVirtualNodesNodeEvent {
    count: number;
    firstTimestamp: string;
    lastTimestamp: string;
    message: string;
    name: string;
    reason: string;
    type: string;
}

export interface GetEciZonesZone {
    regionEndpoint: string;
    zoneIds: string[];
}

export interface GetEcpInstanceTypesInstanceType {
    cpuCoreCount: number;
    defaultResolution: string;
    instanceType: string;
    instanceTypeFamily: string;
    name: string;
    nameEn: string;
}

export interface GetEcpInstancesInstance {
    description: string;
    id: string;
    imageId: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    keyPairName: string;
    paymentType: string;
    resolution: string;
    securityGroupId: string;
    status: string;
    vncUrl: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEcpKeyPairsPair {
    id: string;
    keyPairFingerPrint: string;
    keyPairName: string;
}

export interface GetEcpZonesZone {
    zoneId: string;
}

export interface GetEcsActivationsActivation {
    activationId: string;
    createTime: string;
    deregisteredCount: number;
    description: string;
    disabled: boolean;
    id: string;
    instanceCount: number;
    instanceName: string;
    ipAddressRange: string;
    registeredCount: number;
    timeToLiveInHours: number;
}

export interface GetEcsAutoSnapshotPoliciesPolicy {
    autoSnapshotPolicyId: string;
    copiedSnapshotsRetentionDays: number;
    diskNums: number;
    enableCrossRegionCopy: boolean;
    id: string;
    name: string;
    repeatWeekdays: string[];
    retentionDays: number;
    status: string;
    tags: {[key: string]: string};
    targetCopyRegions: string[];
    timePoints: string[];
    volumeNums: number;
}

export interface GetEcsCapacityReservationsReservation {
    capacityReservationId: string;
    capacityReservationName: string;
    description: string;
    endTime: string;
    endTimeType: string;
    id: string;
    instanceAmount: string;
    instanceType: string;
    matchCriteria: string;
    paymentType: string;
    platform: string;
    resourceGroupId: string;
    startTime: string;
    startTimeType: string;
    status: string;
    tags: {[key: string]: string};
    timeSlot: string;
    zoneIds: string[];
}

export interface GetEcsCommandsCommand {
    commandContent: string;
    commandId: string;
    description: string;
    enableParameter: boolean;
    id: string;
    name: string;
    parameterNames: string[];
    timeout: number;
    type: string;
    workingDir: string;
}

export interface GetEcsDedicatedHostClustersCluster {
    dedicatedHostClusterCapacities: outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity[];
    dedicatedHostClusterId: string;
    dedicatedHostClusterName: string;
    dedicatedHostIds: string[];
    description: string;
    id: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
    zoneId: string;
}

export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacity {
    availableMemory: number;
    availableVcpus: number;
    localStorageCapacities: outputs.GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity[];
    totalMemory: number;
    totalVcpus: number;
}

export interface GetEcsDedicatedHostClustersClusterDedicatedHostClusterCapacityLocalStorageCapacity {
    availableDisk: number;
    dataDiskCategory: string;
    totalDisk: number;
}

export interface GetEcsDedicatedHostsHost {
    actionOnMaintenance: string;
    autoPlacement: string;
    autoReleaseTime: string;
    capacities: outputs.GetEcsDedicatedHostsHostCapacity[];
    cores: number;
    cpuOverCommitRatio: number;
    dedicatedHostId: string;
    dedicatedHostName: string;
    dedicatedHostType: string;
    description: string;
    expiredTime: string;
    gpuSpec: string;
    id: string;
    machineId: string;
    networkAttributes: outputs.GetEcsDedicatedHostsHostNetworkAttribute[];
    operationLocks: outputs.GetEcsDedicatedHostsHostOperationLock[];
    paymentType: string;
    physicalGpus: number;
    resourceGroupId: string;
    saleCycle: string;
    sockets: number;
    status: string;
    supportedCustomInstanceTypeFamilies: string[];
    supportedInstanceTypeFamilies: string[];
    supportedInstanceTypesLists: string[];
    tags: {[key: string]: string};
    zoneId: string;
}

export interface GetEcsDedicatedHostsHostCapacity {
    availableLocalStorage: number;
    availableMemory: number;
    availableVcpus: number;
    availableVgpus: number;
    localStorageCategory: string;
    totalLocalStorage: number;
    totalMemory: number;
    totalVcpus: number;
    totalVgpus: number;
}

export interface GetEcsDedicatedHostsHostNetworkAttribute {
    slbUdpTimeout: number;
    udpTimeout: number;
}

export interface GetEcsDedicatedHostsHostOperationLock {
    lockReason: string;
}

export interface GetEcsDedicatedHostsOperationLock {
    lockReason?: string;
}

export interface GetEcsDeploymentSetsSet {
    createTime: string;
    deploymentSetId: string;
    deploymentSetName: string;
    description: string;
    domain: string;
    granularity: string;
    id: string;
    instanceAmount: number;
    instanceIds: string[];
    strategy: string;
}

export interface GetEcsDisksDisk {
    attachedTime: string;
    autoSnapshotPolicyId: string;
    availabilityZone: string;
    category: string;
    creationTime: string;
    deleteAutoSnapshot: boolean;
    deleteWithInstance: boolean;
    description: string;
    detachedTime: string;
    device: string;
    diskId: string;
    diskName: string;
    diskType: string;
    enableAutoSnapshot: boolean;
    enableAutomatedSnapshotPolicy: boolean;
    encrypted: string;
    expiredTime: string;
    id: string;
    imageId: string;
    instanceId: string;
    iops: number;
    iopsRead: number;
    iopsWrite: number;
    kmsKeyId: string;
    mountInstanceNum: number;
    mountInstances: outputs.GetEcsDisksDiskMountInstance[];
    name: string;
    operationLocks: outputs.GetEcsDisksDiskOperationLock[];
    paymentType: string;
    performanceLevel: string;
    portable: boolean;
    productCode: string;
    regionId: string;
    resourceGroupId: string;
    size: number;
    snapshotId: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
    zoneId: string;
}

export interface GetEcsDisksDiskMountInstance {
    attachedTime: string;
    device: string;
    instanceId: string;
}

export interface GetEcsDisksDiskOperationLock {
    lockReason: string;
}

export interface GetEcsDisksOperationLock {
    lockReason?: string;
}

export interface GetEcsElasticityAssurancesAssurance {
    allocatedResources: outputs.GetEcsElasticityAssurancesAssuranceAllocatedResource[];
    description: string;
    elasticityAssuranceId: string;
    endTime: string;
    id: string;
    instanceChargeType: string;
    privatePoolOptionsId: string;
    privatePoolOptionsMatchCriteria: string;
    privatePoolOptionsName: string;
    resourceGroupId: string;
    startTime: string;
    startTimeType: string;
    status: string;
    tags: {[key: string]: string};
    totalAssuranceTimes: string;
    usedAssuranceTimes: number;
}

export interface GetEcsElasticityAssurancesAssuranceAllocatedResource {
    instanceType: string;
    totalAmount: number;
    usedAmount: number;
    zoneId: string;
}

export interface GetEcsHpcClustersCluster {
    description: string;
    hpcClusterId: string;
    id: string;
    name: string;
}

export interface GetEcsImageComponentsComponent {
    componentType: string;
    content: string;
    createTime: string;
    description: string;
    id: string;
    imageComponentId: string;
    imageComponentName: string;
    owner: string;
    resourceGroupId: string;
    systemType: string;
    tags: {[key: string]: string};
}

export interface GetEcsImagePipelinesPipeline {
    addAccounts: string[];
    baseImage: string;
    baseImageType: string;
    buildContent: string;
    creationTime: string;
    deleteInstanceOnFailure: boolean;
    description: string;
    id: string;
    imageName: string;
    imagePipelineId: string;
    instanceType: string;
    internetMaxBandwidthOut: number;
    name: string;
    resourceGroupId: string;
    systemDiskSize: number;
    tags: {[key: string]: string};
    toRegionIds: string[];
    vswitchId: string;
}

export interface GetEcsInvocationsInvocation {
    commandContent: string;
    commandId: string;
    commandName: string;
    commandType: string;
    createTime: string;
    frequency: string;
    id: string;
    invocationId: string;
    invocationStatus: string;
    invokeInstances: outputs.GetEcsInvocationsInvocationInvokeInstance[];
    invokeStatus: string;
    parameters: string;
    repeatMode: string;
    timed: boolean;
    username: string;
}

export interface GetEcsInvocationsInvocationInvokeInstance {
    creationTime: string;
    dropped: number;
    errorCode: string;
    errorInfo: string;
    exitCode: number;
    finishTime: string;
    instanceId: string;
    instanceInvokeStatus: string;
    invocationStatus: string;
    output: string;
    repeats: number;
    startTime: string;
    stopTime: string;
    timed: boolean;
    updateTime: string;
}

export interface GetEcsKeyPairsKeyPair {
    fingerPrint: string;
    id: string;
    instances: outputs.GetEcsKeyPairsKeyPairInstance[];
    keyName: string;
    keyPairName: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetEcsKeyPairsKeyPairInstance {
    availabilityZone: string;
    description: string;
    imageId: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    keyName: string;
    privateIp: string;
    publicIp: string;
    regionId: string;
    status: string;
    vswitchId: string;
}

export interface GetEcsKeyPairsPair {
    fingerPrint: string;
    id: string;
    instances: outputs.GetEcsKeyPairsPairInstance[];
    keyName: string;
    keyPairName: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetEcsKeyPairsPairInstance {
    availabilityZone: string;
    description: string;
    imageId: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    keyName: string;
    privateIp: string;
    publicIp: string;
    regionId: string;
    status: string;
    vswitchId: string;
}

export interface GetEcsLaunchTemplatesTemplate {
    autoReleaseTime: string;
    createdBy: string;
    dataDisks: outputs.GetEcsLaunchTemplatesTemplateDataDisk[];
    defaultVersionNumber: number;
    deploymentSetId: string;
    description: string;
    enableVmOsConfig: boolean;
    hostName: string;
    id: string;
    imageId: string;
    imageOwnerAlias: string;
    instanceChargeType: string;
    instanceName: string;
    instanceType: string;
    internetChargeType: string;
    internetMaxBandwidthIn: number;
    internetMaxBandwidthOut: number;
    ioOptimized: string;
    keyPairName: string;
    latestVersionNumber: number;
    launchTemplateId: string;
    launchTemplateName: string;
    modifiedTime: string;
    networkInterfaces: outputs.GetEcsLaunchTemplatesTemplateNetworkInterface[];
    networkType: string;
    passwordInherit: boolean;
    period: number;
    privateIpAddress: string;
    ramRoleName: string;
    resourceGroupId: string;
    securityEnhancementStrategy: string;
    securityGroupId: string;
    securityGroupIds: string[];
    spotDuration: string;
    spotPriceLimit: number;
    spotStrategy: string;
    systemDisks: outputs.GetEcsLaunchTemplatesTemplateSystemDisk[];
    templateTags: {[key: string]: string};
    userData: string;
    versionDescription: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEcsLaunchTemplatesTemplateDataDisk {
    category: string;
    deleteWithInstance: boolean;
    description: string;
    encrypted: boolean;
    name: string;
    performanceLevel: string;
    size: number;
    snapshotId: string;
}

export interface GetEcsLaunchTemplatesTemplateNetworkInterface {
    description: string;
    name: string;
    primaryIp: string;
    securityGroupId: string;
    vswitchId: string;
}

export interface GetEcsLaunchTemplatesTemplateSystemDisk {
    category: string;
    deleteWithInstance: boolean;
    description: string;
    iops: string;
    name: string;
    performanceLevel: string;
    size: number;
}

export interface GetEcsNetworkInterfacePermissionsPermission {
    accountId: string;
    id: string;
    networkInterfaceId: string;
    networkInterfacePermissionId: string;
    permission: string;
    serviceName: string;
    status: string;
}

export interface GetEcsNetworkInterfacesInterface {
    associatedPublicIps: outputs.GetEcsNetworkInterfacesInterfaceAssociatedPublicIp[];
    creationTime: string;
    description: string;
    id: string;
    instanceId: string;
    ipv6Sets: string[];
    mac: string;
    name: string;
    networkInterfaceId: string;
    networkInterfaceName: string;
    networkInterfaceTrafficMode: string;
    ownerId: string;
    primaryIpAddress: string;
    privateIp: string;
    privateIpAddresses: string[];
    privateIps: string[];
    queueNumber: number;
    resourceGroupId: string;
    securityGroupIds: string[];
    securityGroups: string[];
    serviceId: number;
    serviceManaged: boolean;
    status: string;
    tags: {[key: string]: string};
    type: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEcsNetworkInterfacesInterfaceAssociatedPublicIp {
    publicIpAddress: string;
}

export interface GetEcsPrefixListsList {
    addressFamily: string;
    associationCount: number;
    createTime: string;
    description: string;
    entries: outputs.GetEcsPrefixListsListEntry[];
    id: string;
    maxEntries: number;
    prefixListId: string;
    prefixListName: string;
}

export interface GetEcsPrefixListsListEntry {
    cidr: string;
    description: string;
}

export interface GetEcsSnapshotGroupsGroup {
    description: string;
    id: string;
    instanceId: string;
    resourceGroupId: string;
    snapshotGroupId: string;
    snapshotGroupName: string;
    status: string;
    tags: {[key: string]: string};
}

export interface GetEcsSnapshotsSnapshot {
    category: string;
    creationTime: string;
    description: string;
    diskId: string;
    encrypted: boolean;
    id: string;
    instantAccess: boolean;
    instantAccessRetentionDays: number;
    name: string;
    productCode: string;
    progress: string;
    remainTime: number;
    resourceGroupId: string;
    retentionDays: number;
    snapshotId: string;
    snapshotName: string;
    snapshotSn: string;
    snapshotType: string;
    sourceDiskId: string;
    sourceDiskSize: string;
    sourceDiskType: string;
    sourceStorageType: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
    usage: string;
}

export interface GetEcsStorageCapacityUnitsUnit {
    allocationStatus: string;
    capacity: number;
    createTime: string;
    description: string;
    expiredTime: string;
    id: string;
    startTime: string;
    status: string;
    storageCapacityUnitId: string;
    storageCapacityUnitName: string;
}

export interface GetEdasApplicationsApplication {
    appId: string;
    appName: string;
    applicationType: string;
    buildPackageId: number;
    clusterId: string;
    clusterType: number;
    regionId: string;
}

export interface GetEdasClustersCluster {
    clusterId: string;
    clusterName: string;
    clusterType: number;
    cpu: number;
    cpuUsed: number;
    createTime: number;
    mem: number;
    memUsed: number;
    networkMode: number;
    nodeNum: number;
    regionId: string;
    updateTime: number;
    vpcId: string;
}

export interface GetEdasDeployGroupsGroup {
    appId: string;
    appVersionId: string;
    clusterId: string;
    createTime: number;
    groupId: string;
    groupName: string;
    groupType: number;
    packageVersionId: string;
    updateTime: number;
}

export interface GetEdasNamespacesNamespace {
    belongRegion: string;
    debugEnable: boolean;
    description: string;
    id: string;
    namespaceId: string;
    namespaceLogicalId: string;
    namespaceName: string;
    userId: string;
}

export interface GetEfloSubnetsSubnet {
    cidr: string;
    createTime: string;
    gmtModified: string;
    id: string;
    message: string;
    resourceGroupId: string;
    status: string;
    subnetId: string;
    subnetName: string;
    type: string;
    vpdId: string;
    zoneId: string;
}

export interface GetEfloVpdsVpd {
    cidr: string;
    createTime: string;
    gmtModified: string;
    id: string;
    resourceGroupId: string;
    status: string;
    vpdId: string;
    vpdName: string;
}

export interface GetEhpcClustersCluster {
    accountType: string;
    applications: outputs.GetEhpcClustersClusterApplication[];
    clientVersion: string;
    clusterId: string;
    clusterName: string;
    computeCount: number;
    computeInstanceType: string;
    createTime: string;
    deployMode: string;
    description: string;
    haEnable: boolean;
    id: string;
    imageId: string;
    imageOwnerAlias: string;
    loginCount: number;
    loginInstanceType: string;
    managerCount: number;
    managerInstanceType: string;
    osTag: string;
    postInstallScripts: outputs.GetEhpcClustersClusterPostInstallScript[];
    remoteDirectory: string;
    sccClusterId: string;
    schedulerType: string;
    securityGroupId: string;
    status: string;
    volumeId: string;
    volumeMountpoint: string;
    volumeProtocol: string;
    volumeType: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEhpcClustersClusterApplication {
    tag: string;
}

export interface GetEhpcClustersClusterPostInstallScript {
    args: string;
    url: string;
}

export interface GetEhpcJobTemplatesTemplate {
    arrayRequest: string;
    clockTime: string;
    commandLine: string;
    gpu: number;
    id: string;
    jobTemplateId: string;
    jobTemplateName: string;
    mem: string;
    node: number;
    packagePath: string;
    priority: number;
    queue: string;
    reRunable: boolean;
    runasUser: string;
    stderrRedirectPath: string;
    stdoutRedirectPath: string;
    task: number;
    thread: number;
    variables: string;
}

export interface GetEipAddressesAddress {
    addressName: string;
    allocationId: string;
    availableRegions: string[];
    bandwidth: string;
    bandwidthPackageBandwidth: string;
    bandwidthPackageId: string;
    bandwidthPackageType: string;
    createTime: string;
    deletionProtection: boolean;
    description: string;
    expiredTime: string;
    hasReservationData: string;
    hdMonitorStatus: string;
    id: string;
    instanceId: string;
    instanceRegionId: string;
    instanceType: string;
    internetChargeType: string;
    ipAddress: string;
    isp: string;
    operationLocks: string[];
    paymentType: string;
    reservationActiveTime: string;
    reservationBandwidth: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    resourceGroupId: string;
    secondLimited: boolean;
    segmentInstanceId: string;
    status: string;
    tags: {[key: string]: string};
}

export interface GetEipAddressesEip {
    bandwidth: string;
    creationTime: string;
    deletionProtection: boolean;
    id: string;
    instanceId: string;
    instanceType: string;
    internetChargeType: string;
    ipAddress: string;
    status: string;
}

export interface GetEipanycastAnycastEipAddressesAddress {
    aliUid: number;
    anycastEipAddressName: string;
    anycastEipBindInfoLists: outputs.GetEipanycastAnycastEipAddressesAddressAnycastEipBindInfoList[];
    anycastId: string;
    bandwidth: number;
    bid: string;
    businessStatus: string;
    description: string;
    id: string;
    internetChargeType: string;
    ipAddress: string;
    paymentType: string;
    serviceLocation: string;
    status: string;
}

export interface GetEipanycastAnycastEipAddressesAddressAnycastEipBindInfoList {
    bindInstanceId: string;
    bindInstanceRegionId: string;
    bindInstanceType: string;
    bindTime: string;
}

export interface GetEipsAddress {
    addressName: string;
    allocationId: string;
    availableRegions: string[];
    bandwidth: string;
    bandwidthPackageBandwidth: string;
    bandwidthPackageId: string;
    bandwidthPackageType: string;
    createTime: string;
    deletionProtection: boolean;
    description: string;
    expiredTime: string;
    hasReservationData: string;
    hdMonitorStatus: string;
    id: string;
    instanceId: string;
    instanceRegionId: string;
    instanceType: string;
    internetChargeType: string;
    ipAddress: string;
    isp: string;
    operationLocks: string[];
    paymentType: string;
    reservationActiveTime: string;
    reservationBandwidth: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    resourceGroupId: string;
    secondLimited: boolean;
    segmentInstanceId: string;
    status: string;
    tags: {[key: string]: string};
}

export interface GetEipsEip {
    bandwidth: string;
    creationTime: string;
    deletionProtection: boolean;
    id: string;
    instanceId: string;
    instanceType: string;
    internetChargeType: string;
    ipAddress: string;
    status: string;
}

export interface GetElasticsearchInstancesInstance {
    createdAt: string;
    dataNodeAmount: number;
    dataNodeDiskSize: number;
    dataNodeDiskType: string;
    dataNodeSpec: string;
    description: string;
    id: string;
    instanceChargeType: string;
    status: string;
    tags: {[key: string]: string};
    updatedAt: string;
    version: string;
    vswitchId: string;
}

export interface GetElasticsearchZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetEmrClustersCluster {
    accessInfos: outputs.GetEmrClustersClusterAccessInfo[];
    autoScalingAllowed: boolean;
    autoScalingByLoadAllowed: boolean;
    autoScalingEnable: boolean;
    autoScalingSpotWithLimitAllowed: boolean;
    bootstrapActionLists: outputs.GetEmrClustersClusterBootstrapActionList[];
    bootstrapFailed: boolean;
    clusterId: string;
    clusterName: string;
    createResource: string;
    createTime: string;
    createType: string;
    depositType: string;
    easEnable: boolean;
    expiredTime: string;
    extraInfo: string;
    hasUncompletedOrder: boolean;
    highAvailabilityEnable: boolean;
    hostGroupLists: outputs.GetEmrClustersClusterHostGroupList[];
    hostPoolInfos: outputs.GetEmrClustersClusterHostPoolInfo[];
    id: string;
    imageId: string;
    localMetaDb: boolean;
    machineType: string;
    metaStoreType: string;
    netType: string;
    paymentType: string;
    period: number;
    relateClusterInfos: outputs.GetEmrClustersClusterRelateClusterInfo[];
    resizeDiskEnable: boolean;
    runningTime: number;
    securityGroupId: string;
    securityGroupName: string;
    softwareInfos: outputs.GetEmrClustersClusterSoftwareInfo[];
    startTime: string;
    status: string;
    stopTime: string;
    tags: {[key: string]: string};
    type: string;
    userDefinedEmrEcsRole: string;
    userId: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetEmrClustersClusterAccessInfo {
    zkLinks: outputs.GetEmrClustersClusterAccessInfoZkLink[];
}

export interface GetEmrClustersClusterAccessInfoZkLink {
    link: string;
    port: string;
}

export interface GetEmrClustersClusterBootstrapActionList {
    arg: string;
    name: string;
    path: string;
}

export interface GetEmrClustersClusterHostGroupList {
    bandWidth: string;
    chargeType: string;
    cpuCore: number;
    diskCapacity: number;
    diskCount: number;
    diskType: string;
    hostGroupChangeType: string;
    hostGroupId: string;
    hostGroupName: string;
    hostGroupType: string;
    instanceType: string;
    memoryCapacity: number;
    nodeCount: number;
    nodes: outputs.GetEmrClustersClusterHostGroupListNode[];
    period: string;
}

export interface GetEmrClustersClusterHostGroupListNode {
    createTime: string;
    diskInfos: outputs.GetEmrClustersClusterHostGroupListNodeDiskInfo[];
    emrExpiredTime: string;
    expiredTime: string;
    innerIp: string;
    instanceId: string;
    pubIp: string;
    status: string;
    supportIpv6: boolean;
    zoneId: string;
}

export interface GetEmrClustersClusterHostGroupListNodeDiskInfo {
    device: string;
    diskId: string;
    diskName: string;
    size: number;
    type: string;
}

export interface GetEmrClustersClusterHostPoolInfo {
    hpBizId: string;
    hpName: string;
}

export interface GetEmrClustersClusterRelateClusterInfo {
    clusterId: string;
    clusterName: string;
    clusterType: string;
    status: string;
}

export interface GetEmrClustersClusterSoftwareInfo {
    clusterType: string;
    emrVer: string;
    softwares: outputs.GetEmrClustersClusterSoftwareInfoSoftware[];
}

export interface GetEmrClustersClusterSoftwareInfoSoftware {
    displayName: string;
    name: string;
    onlyDisplay: boolean;
    startTpe: number;
    version: string;
}

export interface GetEmrDiskTypesType {
    max: number;
    min: number;
    value: string;
}

export interface GetEmrInstanceTypesType {
    id: string;
    localStorageCapacity: number;
    zoneId: string;
}

export interface GetEmrMainVersionsMainVersion {
    clusterTypes: string[];
    emrVersion: string;
    imageId: string;
}

export interface GetEmrv2ClustersCluster {
    clusterId: string;
    clusterName: string;
    clusterState: string;
    clusterType: string;
    createTime: string;
    emrDefaultRole: string;
    endTime: string;
    expireTime: string;
    paymentType: string;
    readyTime: string;
    releaseVersion: string;
    resourceGroupId: string;
    stateChangeReason: {[key: string]: string};
    tags: outputs.GetEmrv2ClustersClusterTag[];
}

export interface GetEmrv2ClustersClusterTag {
    key: string;
    value: string;
}

export interface GetEnhancedNatAvailableZonesZone {
    localName: string;
    zoneId: string;
}

export interface GetEnsKeyPairsPair {
    createTime: string;
    id: string;
    keyPairFingerPrint: string;
    keyPairName: string;
    version: string;
}

export interface GetEssAlarmsAlarm {
    alarmActions: string[];
    cloudMonitorGroupId: number;
    comparisonOperator: string;
    description: string;
    dimensions: {[key: string]: string};
    enable: boolean;
    evaluationCount: number;
    id: string;
    metricName: string;
    metricType: string;
    name: string;
    period: number;
    scalingGroupId: string;
    state: string;
    statistics: string;
    threshold: string;
}

export interface GetEssLifecycleHooksHook {
    defaultResult: string;
    heartbeatTimeout: number;
    id: string;
    lifecycleTransition: string;
    name: string;
    notificationArn: string;
    notificationMetadata: string;
    scalingGroupId: string;
}

export interface GetEssNotificationsNotification {
    id: string;
    notificationArn: string;
    notificationTypes: string[];
    scalingGroupId: string;
}

export interface GetEssScalingConfigurationsConfiguration {
    creationTime: string;
    creditSpecification: string;
    dataDisks: outputs.GetEssScalingConfigurationsConfigurationDataDisk[];
    hostName: string;
    id: string;
    imageId: string;
    instanceName: string;
    instanceType: string;
    internetChargeType: string;
    internetMaxBandwidthIn: number;
    internetMaxBandwidthOut: number;
    lifecycleState: string;
    name: string;
    scalingGroupId: string;
    securityGroupId: string;
    spotPriceLimits: outputs.GetEssScalingConfigurationsConfigurationSpotPriceLimit[];
    spotStrategy: string;
    systemDiskCategory: string;
    systemDiskPerformanceLevel: string;
    systemDiskSize: number;
}

export interface GetEssScalingConfigurationsConfigurationDataDisk {
    category: string;
    deleteWithInstance: boolean;
    device: string;
    performanceLevel: string;
    size: number;
    snapshotId: string;
}

export interface GetEssScalingConfigurationsConfigurationSpotPriceLimit {
    instanceType: string;
    priceLimit: number;
}

export interface GetEssScalingGroupsGroup {
    activeCapacity: number;
    activeScalingConfiguration: string;
    cooldownTime: number;
    creationTime: string;
    dbInstanceIds: string[];
    groupDeletionProtection: boolean;
    healthCheckType: string;
    id: string;
    launchTemplateId: string;
    launchTemplateVersion: string;
    lifecycleState: string;
    loadBalancerIds: string[];
    maxSize: number;
    minSize: number;
    modificationTime: string;
    name: string;
    pendingCapacity: number;
    regionId: string;
    removalPolicies: string[];
    removingCapacity: number;
    suspendedProcesses: string[];
    tags: {[key: string]: string};
    totalCapacity: number;
    totalInstanceCount: number;
    vpcId: string;
    vswitchId: string;
    vswitchIds: string[];
}

export interface GetEssScalingRulesRule {
    adjustmentType: string;
    adjustmentValue: number;
    cooldown: number;
    id: string;
    minAdjustmentMagnitude: number;
    name: string;
    scalingGroupId: string;
    scalingRuleAri: string;
    type: string;
}

export interface GetEssScheduledTasksTask {
    description: string;
    id: string;
    launchExpirationTime: number;
    launchTime: string;
    maxValue: number;
    minValue: number;
    name: string;
    recurrenceEndTime: string;
    recurrenceType: string;
    recurrenceValue: string;
    scheduledAction: string;
    taskEnabled: boolean;
}

export interface GetEventBridgeEventBusesBus {
    createTime: string;
    description: string;
    eventBusName: string;
    id: string;
}

export interface GetEventBridgeEventSourcesSource {
    description: string;
    eventSourceName: string;
    externalSourceConfig: {[key: string]: string};
    externalSourceType: string;
    id: string;
    linkedExternalSource: boolean;
    type: string;
}

export interface GetEventBridgeRulesRule {
    description: string;
    eventBusName: string;
    filterPattern: string;
    id: string;
    ruleName: string;
    status: string;
    targets: outputs.GetEventBridgeRulesRuleTarget[];
}

export interface GetEventBridgeRulesRuleTarget {
    endpoint: string;
    targetId: string;
    type: string;
}

export interface GetExpressConnectAccessPointsPoint {
    accessPointFeatureModels: outputs.GetExpressConnectAccessPointsPointAccessPointFeatureModel[];
    accessPointId: string;
    accessPointName: string;
    attachedRegionNo: string;
    description: string;
    hostOperator: string;
    id: string;
    location: string;
    status: string;
    type: string;
}

export interface GetExpressConnectAccessPointsPointAccessPointFeatureModel {
    featureKey: string;
    featureValue: string;
}

export interface GetExpressConnectGrantRuleToCensCen {
    cenId: string;
    cenOwnerId: number;
    createTime: string;
    id: string;
}

export interface GetExpressConnectPhysicalConnectionsConnection {
    accessPointId: string;
    adLocation: string;
    bandwidth: string;
    businessStatus: string;
    circuitCode: string;
    createTime: string;
    description: string;
    enabledTime: string;
    endTime: string;
    hasReservationData: string;
    id: string;
    lineOperator: string;
    loaStatus: string;
    paymentType: string;
    peerLocation: string;
    physicalConnectionId: string;
    physicalConnectionName: string;
    portNumber: string;
    portType: string;
    redundantPhysicalConnectionId: string;
    reservationActiveTime: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    spec: string;
    status: string;
    type: string;
}

export interface GetExpressConnectRouterInterfacesFilter {
    key?: string;
    values?: string[];
}

export interface GetExpressConnectRouterInterfacesInterface {
    accessPointId: string;
    bandwidth: number;
    businessStatus: string;
    connectedTime: string;
    createTime: string;
    crossBorder: boolean;
    description: string;
    endTime: string;
    hasReservationData: string;
    hcRate: number;
    hcThreshold: string;
    healthCheckSourceIp: string;
    healthCheckTargetIp: string;
    id: string;
    oppositeAccessPointId: string;
    oppositeBandwidth: number;
    oppositeInterfaceBusinessStatus: string;
    oppositeInterfaceId: string;
    oppositeInterfaceOwnerId: string;
    oppositeInterfaceSpec: string;
    oppositeInterfaceStatus: string;
    oppositeRegionId: string;
    oppositeRouterId: string;
    oppositeRouterType: string;
    oppositeVpcInstanceId: string;
    paymentType: string;
    reservationActiveTime: string;
    reservationBandwidth: string;
    reservationInternetChargeType: string;
    reservationOrderType: string;
    role: string;
    routerId: string;
    routerInterfaceId: string;
    routerInterfaceName: string;
    routerType: string;
    spec: string;
    status: string;
    vpcInstanceId: string;
}

export interface GetExpressConnectVbrPconnAssociationsAssociation {
    circuitCode: string;
    enableIpv6: boolean;
    id: string;
    localGatewayIp: string;
    localIpv6GatewayIp: string;
    peerGatewayIp: string;
    peerIpv6GatewayIp: string;
    peeringIpv6SubnetMask: string;
    peeringSubnetMask: string;
    physicalConnectionId: string;
    status: string;
    vbrId: string;
    vlanId: number;
}

export interface GetExpressConnectVirtualBorderRoutersFilter {
    key?: string;
    values?: string[];
}

export interface GetExpressConnectVirtualBorderRoutersRouter {
    accessPointId: string;
    activationTime: string;
    circuitCode: string;
    cloudBoxInstanceId: string;
    createTime: string;
    description: string;
    detectMultiplier: number;
    eccId: string;
    enableIpv6: boolean;
    id: string;
    localGatewayIp: string;
    localIpv6GatewayIp: string;
    minRxInterval: number;
    minTxInterval: number;
    paymentVbrExpireTime: string;
    peerGatewayIp: string;
    peerIpv6GatewayIp: string;
    peeringIpv6SubnetMask: string;
    peeringSubnetMask: string;
    physicalConnectionBusinessStatus: string;
    physicalConnectionId: string;
    physicalConnectionOwnerUid: string;
    physicalConnectionStatus: string;
    recoveryTime: string;
    routeTableId: string;
    status: string;
    terminationTime: string;
    type: string;
    virtualBorderRouterId: string;
    virtualBorderRouterName: string;
    vlanId: number;
    vlanInterfaceId: string;
}

export interface GetExpressConnectVirtualPhysicalConnectionsConnection {
    accessPointId: string;
    adLocation: string;
    bandwidth: string;
    businessStatus: string;
    circuitCode: string;
    createTime: string;
    description: string;
    enabledTime: string;
    endTime: string;
    expectSpec: string;
    id: string;
    lineOperator: string;
    loaStatus: string;
    orderMode: string;
    parentPhysicalConnectionAliUid: string;
    parentPhysicalConnectionId: string;
    peerLocation: string;
    portNumber: string;
    portType: string;
    redundantPhysicalConnectionId: string;
    resourceGroupId: string;
    spec: string;
    status: string;
    virtualPhysicalConnectionId: string;
    virtualPhysicalConnectionName: string;
    virtualPhysicalConnectionStatus: string;
    vlanId: number;
    vpconnAliUid: string;
}

export interface GetFcCustomDomainsDomain {
    accountId: string;
    apiVersion: string;
    certConfigs: outputs.GetFcCustomDomainsDomainCertConfig[];
    createdTime: string;
    domainName: string;
    id: string;
    lastModifiedTime: string;
    protocol: string;
    routeConfigs: outputs.GetFcCustomDomainsDomainRouteConfig[];
}

export interface GetFcCustomDomainsDomainCertConfig {
    certName: string;
    certificate: string;
}

export interface GetFcCustomDomainsDomainRouteConfig {
    functionName: string;
    methods: string[];
    path: string;
    qualifier: string;
    serviceName: string;
}

export interface GetFcFunctionsFunction {
    caPort: number;
    codeChecksum: string;
    codeSize: number;
    creationTime: string;
    customContainerConfigs: outputs.GetFcFunctionsFunctionCustomContainerConfig[];
    description: string;
    environmentVariables: {[key: string]: string};
    handler: string;
    id: string;
    initializationTimeout: number;
    initializer: string;
    instanceConcurrency: number;
    instanceType: string;
    lastModificationTime: string;
    memorySize: number;
    name: string;
    runtime: string;
    timeout: number;
}

export interface GetFcFunctionsFunctionCustomContainerConfig {
    args: string;
    command: string;
    image: string;
}

export interface GetFcServicesService {
    creationTime: string;
    description: string;
    id: string;
    internetAccess: boolean;
    lastModificationTime: string;
    logConfigs: outputs.GetFcServicesServiceLogConfig[];
    name: string;
    nasConfigs: outputs.GetFcServicesServiceNasConfig[];
    role: string;
    vpcConfigs: outputs.GetFcServicesServiceVpcConfig[];
}

export interface GetFcServicesServiceLogConfig {
    logstore: string;
    project: string;
}

export interface GetFcServicesServiceNasConfig {
    groupId: number;
    mountPoints: outputs.GetFcServicesServiceNasConfigMountPoint[];
    userId: number;
}

export interface GetFcServicesServiceNasConfigMountPoint {
    mountDir: string;
    serverAddr: string;
}

export interface GetFcServicesServiceVpcConfig {
    securityGroupId: string;
    vpcId: string;
    vswitchIds: string[];
}

export interface GetFcTriggersTrigger {
    config: string;
    creationTime: string;
    id: string;
    invocationRole: string;
    lastModificationTime: string;
    name: string;
    sourceArn: string;
    type: string;
}

export interface GetFcZonesZone {
    id: string;
}

export interface GetFnfExecutionsExecution {
    executionName: string;
    flowName: string;
    id: string;
    input: string;
    output: string;
    startedTime: string;
    status: string;
    stoppedTime: string;
}

export interface GetFnfFlowsFlow {
    definition: string;
    description: string;
    flowId: string;
    id: string;
    lastModifiedTime: string;
    name: string;
    roleArn: string;
    type: string;
}

export interface GetFnfSchedulesSchedule {
    cronExpression: string;
    description: string;
    enable: boolean;
    id: string;
    lastModifiedTime: string;
    payload: string;
    scheduleId: string;
    scheduleName: string;
}

export interface GetForwardEntriesEntry {
    externalIp: string;
    externalPort: string;
    forwardEntryId: string;
    forwardEntryName: string;
    id: string;
    internalIp: string;
    internalPort: string;
    ipProtocol: string;
    name: string;
    status: string;
}

export interface GetGaAcceleratorSpareIpAttachmentsAttachment {
    acceleratorId: string;
    id: string;
    spareIp: string;
    status: string;
}

export interface GetGaAcceleratorsAccelerator {
    acceleratorId: string;
    acceleratorName: string;
    basicBandwidthPackages: outputs.GetGaAcceleratorsAcceleratorBasicBandwidthPackage[];
    cenId: string;
    crossDomainBandwidthPackages: outputs.GetGaAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
    ddosId: string;
    description: string;
    dnsName: string;
    expiredTime: number;
    id: string;
    paymentType: string;
    secondDnsName: string;
    spec: string;
    status: string;
}

export interface GetGaAcceleratorsAcceleratorBasicBandwidthPackage {
    bandwidth: number;
    bandwidthType: string;
    instanceId: string;
}

export interface GetGaAcceleratorsAcceleratorCrossDomainBandwidthPackage {
    bandwidth: number;
    instanceId: string;
}

export interface GetGaAclsAcl {
    aclEntries: outputs.GetGaAclsAclAclEntry[];
    aclId: string;
    aclName: string;
    addressIpVersion: string;
    id: string;
    status: string;
}

export interface GetGaAclsAclAclEntry {
    entry: string;
    entryDescription: string;
}

export interface GetGaAdditionalCertificatesCertificate {
    acceleratorId: string;
    certificateId: string;
    domain: string;
    id: string;
    listenerId: string;
}

export interface GetGaBandwidthPackagesPackage {
    bandwidth: number;
    bandwidthPackageId: string;
    bandwidthPackageName: string;
    bandwidthType: string;
    cbnGeographicRegionIda: string;
    cbnGeographicRegionIdb: string;
    description: string;
    expiredTime: string;
    id: string;
    paymentType: string;
    status: string;
    type: string;
}

export interface GetGaBasicAccelerateIpEndpointRelationsRelation {
    accelerateIpId: string;
    acceleratorId: string;
    basicEndpointName: string;
    endpointAddress: string;
    endpointId: string;
    endpointSubAddress: string;
    endpointSubAddressType: string;
    endpointType: string;
    endpointZoneId: string;
    id: string;
    ipAddress: string;
    status: string;
}

export interface GetGaBasicAccelerateIpsIp {
    accelerateIpAddress: string;
    accelerateIpId: string;
    acceleratorId: string;
    id: string;
    ipSetId: string;
    status: string;
}

export interface GetGaBasicAcceleratorsAccelerator {
    bandwidthBillingType: string;
    basicAcceleratorId: string;
    basicAcceleratorName: string;
    basicBandwidthPackages: outputs.GetGaBasicAcceleratorsAcceleratorBasicBandwidthPackage[];
    basicEndpointGroupId: string;
    basicIpSetId: string;
    createTime: number;
    crossDomainBandwidthPackages: outputs.GetGaBasicAcceleratorsAcceleratorCrossDomainBandwidthPackage[];
    description: string;
    expiredTime: number;
    id: string;
    instanceChargeType: string;
    regionId: string;
    status: string;
}

export interface GetGaBasicAcceleratorsAcceleratorBasicBandwidthPackage {
    bandwidth: number;
    bandwidthType: string;
    instanceId: string;
}

export interface GetGaBasicAcceleratorsAcceleratorCrossDomainBandwidthPackage {
    bandwidth: number;
    instanceId: string;
}

export interface GetGaBasicEndpointsEndpoint {
    acceleratorId: string;
    basicEndpointName: string;
    endpointAddress: string;
    endpointGroupId: string;
    endpointId: string;
    endpointSubAddress: string;
    endpointSubAddressType: string;
    endpointType: string;
    endpointZoneId: string;
    id: string;
    status: string;
}

export interface GetGaCustomRoutingEndpointGroupDestinationsCustomRoutingEndpointGroupDestination {
    acceleratorId: string;
    customRoutingEndpointGroupDestinationId: string;
    endpointGroupId: string;
    fromPort: number;
    id: string;
    listenerId: string;
    protocols: string[];
    toPort: number;
}

export interface GetGaCustomRoutingEndpointGroupsGroup {
    acceleratorId: string;
    customRoutingEndpointGroupName: string;
    description: string;
    endpointGroupId: string;
    endpointGroupIpLists: string[];
    endpointGroupRegion: string;
    endpointGroupUnconfirmedIpLists: string[];
    id: string;
    listenerId: string;
    status: string;
}

export interface GetGaCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicy {
    acceleratorId: string;
    address: string;
    customRoutingEndpointTrafficPolicyId: string;
    endpointGroupId: string;
    endpointId: string;
    id: string;
    listenerId: string;
    portRanges: outputs.GetGaCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicyPortRange[];
}

export interface GetGaCustomRoutingEndpointTrafficPoliciesCustomRoutingEndpointTrafficPolicyPortRange {
    fromPort: number;
    toPort: number;
}

export interface GetGaCustomRoutingEndpointsCustomRoutingEndpoint {
    acceleratorId: string;
    customRoutingEndpointId: string;
    endpoint: string;
    endpointGroupId: string;
    id: string;
    listenerId: string;
    trafficToEndpointPolicy: string;
    type: string;
}

export interface GetGaCustomRoutingPortMappingsCustomRoutingPortMapping {
    acceleratorId: string;
    acceleratorPort: number;
    destinationSocketAddresses: outputs.GetGaCustomRoutingPortMappingsCustomRoutingPortMappingDestinationSocketAddress[];
    endpointGroupId: string;
    endpointGroupRegion: string;
    endpointId: string;
    listenerId: string;
    protocols: string[];
    status: string;
    vswitch: string;
}

export interface GetGaCustomRoutingPortMappingsCustomRoutingPortMappingDestinationSocketAddress {
    ipAddress: string;
    port: number;
}

export interface GetGaDomainsDomain {
    acceleratorId: string;
    domain: string;
    id: string;
    status: string;
}

export interface GetGaEndpointGroupIpAddressCidrBlocksEndpointGroupIpAddressCidrBlock {
    endpointGroupRegion: string;
    ipAddressCidrBlocks: string[];
    status: string;
}

export interface GetGaEndpointGroupsGroup {
    description: string;
    endpointConfigurations: outputs.GetGaEndpointGroupsGroupEndpointConfiguration[];
    endpointGroupId: string;
    endpointGroupIpLists: string[];
    endpointGroupRegion: string;
    healthCheckIntervalSeconds: number;
    healthCheckPath: string;
    healthCheckPort: number;
    healthCheckProtocol: string;
    id: string;
    listenerId: string;
    name: string;
    portOverrides: outputs.GetGaEndpointGroupsGroupPortOverride[];
    status: string;
    thresholdCount: number;
    trafficPercentage: number;
}

export interface GetGaEndpointGroupsGroupEndpointConfiguration {
    enableClientipPreservation: boolean;
    endpoint: string;
    probePort: number;
    probeProtocol: string;
    type: string;
    weight: number;
}

export interface GetGaEndpointGroupsGroupPortOverride {
    endpointPort: number;
    listenerPort: number;
}

export interface GetGaForwardingRulesForwardingRule {
    forwardingRuleId: string;
    forwardingRuleName: string;
    forwardingRuleStatus: string;
    id: string;
    listenerId: string;
    priority: number;
    ruleActions: outputs.GetGaForwardingRulesForwardingRuleRuleAction[];
    ruleConditions: outputs.GetGaForwardingRulesForwardingRuleRuleCondition[];
}

export interface GetGaForwardingRulesForwardingRuleRuleAction {
    forwardGroupConfigs: outputs.GetGaForwardingRulesForwardingRuleRuleActionForwardGroupConfig[];
    order: number;
    ruleActionType: string;
}

export interface GetGaForwardingRulesForwardingRuleRuleActionForwardGroupConfig {
    serverGroupTuples: outputs.GetGaForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple[];
}

export interface GetGaForwardingRulesForwardingRuleRuleActionForwardGroupConfigServerGroupTuple {
    endpointGroupId: string;
}

export interface GetGaForwardingRulesForwardingRuleRuleCondition {
    hostConfigs: outputs.GetGaForwardingRulesForwardingRuleRuleConditionHostConfig[];
    pathConfigs: outputs.GetGaForwardingRulesForwardingRuleRuleConditionPathConfig[];
    ruleConditionType: string;
}

export interface GetGaForwardingRulesForwardingRuleRuleConditionHostConfig {
    values: string[];
}

export interface GetGaForwardingRulesForwardingRuleRuleConditionPathConfig {
    values: string[];
}

export interface GetGaIpSetsSet {
    accelerateRegionId: string;
    bandwidth: number;
    id: string;
    ipAddressLists: string[];
    ipSetId: string;
    ipVersion: string;
    status: string;
}

export interface GetGaListenersListener {
    certificates: outputs.GetGaListenersListenerCertificate[];
    clientAffinity: string;
    description: string;
    id: string;
    listenerId: string;
    name: string;
    portRanges: outputs.GetGaListenersListenerPortRange[];
    protocol: string;
    status: string;
}

export interface GetGaListenersListenerCertificate {
    id: string;
    type: string;
}

export interface GetGaListenersListenerPortRange {
    fromPort: number;
    toPort: number;
}

export interface GetGovernanceBaselinesBaseline {
    baselineId: string;
    baselineName: string;
    description: string;
}

export interface GetGpdbAccountsAccount {
    accountDescription: string;
    accountName: string;
    dbInstanceId: string;
    id: string;
    status: string;
}

export interface GetGpdbDbInstancePlansPlan {
    dbInstancePlanName: string;
    id: string;
    planConfigs: outputs.GetGpdbDbInstancePlansPlanPlanConfig[];
    planDesc: string;
    planEndDate: string;
    planId: string;
    planScheduleType: string;
    planStartDate: string;
    planType: string;
    status: string;
}

export interface GetGpdbDbInstancePlansPlanPlanConfig {
    pauses: outputs.GetGpdbDbInstancePlansPlanPlanConfigPause[];
    resumes: outputs.GetGpdbDbInstancePlansPlanPlanConfigResume[];
    scaleIns: outputs.GetGpdbDbInstancePlansPlanPlanConfigScaleIn[];
    scaleOuts: outputs.GetGpdbDbInstancePlansPlanPlanConfigScaleOut[];
}

export interface GetGpdbDbInstancePlansPlanPlanConfigPause {
    executeTime: string;
    planCronTime: string;
    planTaskStatus: string;
}

export interface GetGpdbDbInstancePlansPlanPlanConfigResume {
    executeTime: string;
    planCronTime: string;
    planTaskStatus: string;
}

export interface GetGpdbDbInstancePlansPlanPlanConfigScaleIn {
    executeTime: string;
    planCronTime: string;
    planTaskStatus: string;
    segmentNodeNum: string;
}

export interface GetGpdbDbInstancePlansPlanPlanConfigScaleOut {
    executeTime: string;
    planCronTime: string;
    planTaskStatus: string;
    segmentNodeNum: string;
}

export interface GetGpdbInstancesInstance {
    availabilityZone: string;
    chargeType: string;
    connectionString: string;
    cpuCores: string;
    createTime: string;
    creationTime: string;
    dbInstanceCategory: string;
    dbInstanceClass: string;
    dbInstanceId: string;
    dbInstanceMode: string;
    description: string;
    engine: string;
    engineVersion: string;
    id: string;
    instanceNetworkType: string;
    ipWhitelists: outputs.GetGpdbInstancesInstanceIpWhitelist[];
    maintainEndTime: string;
    maintainStartTime: string;
    masterNodeNum: string;
    memorySize: string;
    paymentType: string;
    regionId: string;
    segNodeNum: string;
    status: string;
    storageSize: number;
    storageType: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetGpdbInstancesInstanceIpWhitelist {
    ipGroupAttribute: string;
    ipGroupName: string;
    securityIpList: string;
}

export interface GetGpdbZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetGraphDatabaseDbInstancesInstance {
    connectionString: string;
    createTime: string;
    currentMinorVersion: string;
    dbInstanceCategory: string;
    dbInstanceCpu: string;
    dbInstanceDescription: string;
    dbInstanceId: string;
    dbInstanceIpArrays: outputs.GetGraphDatabaseDbInstancesInstanceDbInstanceIpArray[];
    dbInstanceMemory: string;
    dbInstanceNetworkType: string;
    dbInstanceStorageType: string;
    dbInstanceType: string;
    dbNodeClass: string;
    dbNodeCount: string;
    dbNodeStorage: string;
    dbVersion: string;
    expireTime: string;
    expired: string;
    id: string;
    latestMinorVersion: string;
    lockMode: string;
    lockReason: string;
    maintainTime: string;
    masterDbInstanceId: string;
    paymentType: string;
    port: number;
    publicConnectionString: string;
    publicPort: number;
    readOnlyDbInstanceIds: string[];
    status: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetGraphDatabaseDbInstancesInstanceDbInstanceIpArray {
    dbInstanceIpArrayAttribute: string;
    dbInstanceIpArrayName: string;
    securityIps: string;
}

export interface GetHavipsHavip {
    associatedEipAddresses: string[];
    associatedInstances: string[];
    description: string;
    havipId: string;
    havipName: string;
    id: string;
    ipAddress: string;
    masterInstanceId: string;
    status: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetHbaseInstanceTypesCoreInstanceType {
    category: string;
    cpuSize: number;
    engine: string;
    instanceType: string;
    maxCoreCount: number;
    memSize: number;
    storageType: string;
    version: string;
    zone: string;
}

export interface GetHbaseInstanceTypesMasterInstanceType {
    cpuSize: number;
    instanceType: string;
    memSize: number;
}

export interface GetHbaseInstanceTypesType {
    cpuSize: number;
    memSize: number;
    value: string;
}

export interface GetHbaseInstancesInstance {
    backupStatus: string;
    coreDiskSize: number;
    coreDiskType: string;
    coreInstanceType: string;
    coreNodeCount: number;
    createdTime: string;
    deletionProtection: boolean;
    engine: string;
    engineVersion: string;
    expireTime: string;
    id: string;
    masterInstanceType: string;
    masterNodeCount: number;
    name: string;
    networkType: string;
    payType: string;
    regionId: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetHbaseZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetHbrBackupJobsFilter {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface GetHbrBackupJobsJob {
    actualBytes: string;
    actualItems: string;
    backJobName: string;
    backupJobId: string;
    backupType: string;
    bucket: string;
    bytesDone: string;
    bytesTotal: string;
    completeTime: string;
    createTime: string;
    crossAccountRoleName: string;
    crossAccountType: string;
    crossAccountUserId: number;
    errorMessage: string;
    exclude: string;
    fileSystemId: string;
    id: string;
    include: string;
    instanceId: string;
    itemsDone: string;
    itemsTotal: string;
    nasCreateTime: string;
    otsDetails: outputs.GetHbrBackupJobsJobOtsDetail[];
    paths: string[];
    planId: string;
    prefix: string;
    progress: string;
    sourceType: string;
    startTime: string;
    status: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrBackupJobsJobOtsDetail {
    tableNames: string[];
}

export interface GetHbrEcsBackupClientsClient {
    archType: string;
    backupStatus: string;
    clientType: string;
    clientVersion: string;
    createTime: string;
    dataNetworkType: string;
    dataProxySetting: string;
    ecsBackupClientId: string;
    hostname: string;
    id: string;
    instanceId: string;
    instanceName: string;
    lastHeartBeatTime: string;
    maxClientVersion: string;
    maxCpuCore: string;
    maxWorker: string;
    osType: string;
    privateIpv4: string;
    proxyHost: string;
    proxyPassword: string;
    proxyPort: string;
    proxyUser: string;
    status: string;
    updatedTime: string;
    useHttps: boolean;
    zoneId: string;
}

export interface GetHbrEcsBackupPlansPlan {
    backupType: string;
    createTime: string;
    createdTime: string;
    detail: string;
    disabled: boolean;
    ecsBackupPlanId: string;
    ecsBackupPlanName: string;
    exclude: string;
    id: string;
    include: string;
    instanceId: string;
    options: string;
    paths: string[];
    retention: string;
    schedule: string;
    sourceType: string;
    speedLimit: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrHanaBackupClientsHanaBackupClient {
    alertSetting: string;
    clientId: string;
    clientName: string;
    clientType: string;
    clientVersion: string;
    clusterId: string;
    id: string;
    instanceId: string;
    instanceName: string;
    maxVersion: string;
    networkType: string;
    status: string;
    statusMessage: string;
    useHttps: boolean;
    vaultId: string;
}

export interface GetHbrHanaBackupPlansPlan {
    backupPrefix: string;
    backupType: string;
    clusterId: string;
    databaseName: string;
    id: string;
    pageTotal: string;
    planId: string;
    planName: string;
    schedule: string;
    status: string;
    vaultId: string;
}

export interface GetHbrHanaInstancesInstance {
    alertSetting: string;
    hanaInstanceId: string;
    hanaName: string;
    host: string;
    id: string;
    instanceNumber: number;
    resourceGroupId: string;
    status: string;
    statusMessage: string;
    useSsl: boolean;
    userName: string;
    validateCertificate: boolean;
    vaultId: string;
}

export interface GetHbrNasBackupPlansPlan {
    backupType: string;
    createTime: string;
    createdTime: string;
    disabled: boolean;
    fileSystemId: string;
    id: string;
    nasBackupPlanId: string;
    nasBackupPlanName: string;
    options: string;
    paths: string[];
    retention: string;
    schedule: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrOssBackupPlansPlan {
    backupType: string;
    bucket: string;
    createdTime: string;
    disabled: boolean;
    id: string;
    ossBackupPlanId: string;
    ossBackupPlanName: string;
    prefix: string;
    retention: string;
    schedule: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrOtsBackupPlansPlan {
    backupType: string;
    createdTime: string;
    disabled: boolean;
    id: string;
    otsBackupPlanId: string;
    otsBackupPlanName: string;
    otsDetails: outputs.GetHbrOtsBackupPlansPlanOtsDetail[];
    retention: string;
    schedule: string;
    sourceType: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrOtsBackupPlansPlanOtsDetail {
    tableNames: string[];
}

export interface GetHbrOtsSnapshotsSnapshot {
    actualBytes: string;
    backupType: string;
    bytesTotal: string;
    completeTime: string;
    createTime: string;
    createdTime: string;
    id: string;
    instanceName: string;
    jobId: string;
    parentSnapshotHash: string;
    rangeEnd: string;
    rangeStart: string;
    retention: string;
    snapshotHash: string;
    snapshotId: string;
    sourceType: string;
    startTime: string;
    status: string;
    tableName: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrReplicationVaultRegionsRegion {
    replicationRegionId: string;
}

export interface GetHbrRestoreJobsJob {
    actualBytes: string;
    actualItems: string;
    bytesDone: string;
    bytesTotal: string;
    completeTime: string;
    createTime: string;
    errorFile: string;
    errorMessage: string;
    expireTime: string;
    id: string;
    itemsDone: string;
    itemsTotal: string;
    options: string;
    parentId: string;
    progress: number;
    restoreJobId: string;
    restoreType: string;
    snapshotHash: string;
    snapshotId: string;
    sourceType: string;
    startTime: string;
    status: string;
    targetBucket: string;
    targetClientId: string;
    targetCreateTime: string;
    targetDataSourceId: string;
    targetFileSystemId: string;
    targetInstanceId: string;
    targetPath: string;
    targetPrefix: string;
    updatedTime: string;
    vaultId: string;
}

export interface GetHbrServerBackupPlansFilter {
    key?: string;
    values?: string[];
}

export interface GetHbrServerBackupPlansPlan {
    createTime: string;
    details: outputs.GetHbrServerBackupPlansPlanDetail[];
    disabled: boolean;
    ecsServerBackupPlanId: string;
    ecsServerBackupPlanName: string;
    id: string;
    instanceId: string;
    retention: string;
    schedule: string;
}

export interface GetHbrServerBackupPlansPlanDetail {
    appConsistent: boolean;
    destinationRegionId: string;
    destinationRetention: number;
    diskIdLists: string[];
    doCopy: boolean;
    enableFsFreeze: boolean;
    postScriptPath: string;
    preScriptPath: string;
    snapshotGroup: boolean;
    timeoutInSeconds: number;
}

export interface GetHbrSnapshotsSnapshot {
    actualBytes: string;
    actualItems: string;
    backupType: string;
    bucket: string;
    bytesDone: string;
    bytesTotal: string;
    clientId: string;
    completeTime: string;
    createTime: string;
    createdTime: string;
    errorFile: string;
    fileSystemId: string;
    id: string;
    instanceId: string;
    itemsDone: string;
    itemsTotal: string;
    jobId: string;
    parentSnapshotHash: string;
    path: string;
    prefix: string;
    retention: string;
    snapshotHash: string;
    snapshotId: string;
    sourceType: string;
    startTime: string;
    status: string;
    updatedTime: string;
}

export interface GetHbrVaultsVault {
    bucketName: string;
    bytesDone: string;
    createdTime: string;
    dedup: boolean;
    description: string;
    id: string;
    indexAvailable: boolean;
    indexLevel: string;
    indexUpdateTime: string;
    latestReplicationTime: string;
    paymentType: string;
    replication: boolean;
    replicationSourceRegionId: string;
    replicationSourceVaultId: string;
    retention: string;
    searchEnabled: boolean;
    sourceTypes: string[];
    status: string;
    storageSize: string;
    updatedTime: string;
    vaultId: string;
    vaultName: string;
    vaultStatusMessage: string;
    vaultStorageClass: string;
    vaultType: string;
}

export interface GetImagesImage {
    architecture: string;
    creationTime: string;
    description: string;
    diskDeviceMappings: outputs.GetImagesImageDiskDeviceMapping[];
    id: string;
    imageId: string;
    imageOwnerAlias: string;
    imageVersion: string;
    isCopied: boolean;
    isSelfShared: string;
    isSubscribed: boolean;
    isSupportIoOptimized: boolean;
    name: string;
    osName: string;
    osNameEn: string;
    osType: string;
    platform: string;
    productCode: string;
    progress: string;
    size: number;
    state: string;
    status: string;
    tags: {[key: string]: string};
    usage: string;
}

export interface GetImagesImageDiskDeviceMapping {
    device: string;
    size: string;
    snapshotId: string;
}

export interface GetImmProjectsProject {
    billingType: string;
    computeUnit: number;
    createTime: string;
    endpoint: string;
    id: string;
    modifyTime: string;
    project: string;
    serviceRole: string;
    type: string;
}

export interface GetImpAppTemplatesTemplate {
    appTemplateCreator: string;
    appTemplateId: string;
    appTemplateName: string;
    componentLists: string[];
    configLists: outputs.GetImpAppTemplatesTemplateConfigList[];
    createTime: string;
    id: string;
    integrationMode: string;
    scene: string;
    sdkInfo: string;
    standardRoomInfo: string;
    status: string;
}

export interface GetImpAppTemplatesTemplateConfigList {
    key: string;
    value: string;
}

export interface GetInstanceTypeFamiliesFamily {
    generation: string;
    id: string;
    zoneIds: string[];
}

export interface GetInstanceTypesInstanceType {
    availabilityZones: string[];
    burstableInstance: {[key: string]: string};
    cpuCoreCount: number;
    eniAmount: number;
    family: string;
    gpu: {[key: string]: string};
    id: string;
    localStorage: {[key: string]: string};
    memorySize: number;
    nvmeSupport: string;
    price: string;
}

export interface GetInstancesInstance {
    availabilityZone: string;
    creationTime: string;
    description: string;
    diskDeviceMappings: outputs.GetInstancesInstanceDiskDeviceMapping[];
    eip: string;
    id: string;
    imageId: string;
    instanceChargeType: string;
    instanceType: string;
    internetChargeType: string;
    internetMaxBandwidthOut: number;
    keyName: string;
    name: string;
    privateIp: string;
    publicIp: string;
    ramRoleName: string;
    regionId: string;
    resourceGroupId: string;
    securityGroups: string[];
    spotStrategy: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetInstancesInstanceDiskDeviceMapping {
    category: string;
    device: string;
    diskId: string;
    diskName: string;
    size: number;
    type: string;
}

export interface GetIotDeviceGroupsGroup {
    createTime: string;
    deviceActive: string;
    deviceCount: string;
    deviceOnline: string;
    errorMessage: string;
    groupDesc: string;
    groupId: string;
    groupName: string;
    id: string;
    success: boolean;
}

export interface GetKeyPairsKeyPair {
    fingerPrint: string;
    id: string;
    instances: outputs.GetKeyPairsKeyPairInstance[];
    keyName: string;
    keyPairName: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetKeyPairsKeyPairInstance {
    availabilityZone: string;
    description: string;
    imageId: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    keyName: string;
    privateIp: string;
    publicIp: string;
    regionId: string;
    status: string;
    vswitchId: string;
}

export interface GetKeyPairsPair {
    fingerPrint: string;
    id: string;
    instances: outputs.GetKeyPairsPairInstance[];
    keyName: string;
    keyPairName: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetKeyPairsPairInstance {
    availabilityZone: string;
    description: string;
    imageId: string;
    instanceId: string;
    instanceName: string;
    instanceType: string;
    keyName: string;
    privateIp: string;
    publicIp: string;
    regionId: string;
    status: string;
    vswitchId: string;
}

export interface GetKmsAliasesAlias {
    aliasName: string;
    id: string;
    keyId: string;
}

export interface GetKmsKeyVersionsVersion {
    createTime: string;
    creationDate: string;
    id: string;
    keyId: string;
    keyVersionId: string;
}

export interface GetKmsKeysKey {
    arn: string;
    automaticRotation: string;
    creationDate: string;
    creator: string;
    deleteDate: string;
    description: string;
    id: string;
    keyId: string;
    keySpec: string;
    keyUsage: string;
    lastRotationDate: string;
    materialExpireTime: string;
    nextRotationDate: string;
    origin: string;
    primaryKeyVersion: string;
    protectionLevel: string;
    rotationInterval: string;
    status: string;
}

export interface GetKmsSecretVersionsVersion {
    secretData: string;
    secretDataType: string;
    secretName: string;
    versionId: string;
    versionStages: string[];
}

export interface GetKmsSecretsSecret {
    arn: string;
    description: string;
    encryptionKeyId: string;
    id: string;
    plannedDeleteTime: string;
    secretData: string;
    secretDataType: string;
    secretName: string;
    secretType: string;
    tags: {[key: string]: string};
    versionId: string;
    versionStages: string[];
}

export interface GetKvstoreAccountsAccount {
    accountName: string;
    accountPrivilege: string;
    accountType: string;
    description: string;
    id: string;
    instanceId: string;
    status: string;
}

export interface GetKvstoreConnectionsConnection {
    connectionString: string;
    dbInstanceNetType: string;
    expiredTime: string;
    id: string;
    instanceId: string;
    ipAddress: string;
    port: string;
    upgradeable: string;
    vpcId: string;
    vpcInstanceId: string;
    vswitchId: string;
}

export interface GetKvstoreInstanceClassesClass {
    instanceClass: string;
    price: string;
}

export interface GetKvstoreInstanceEnginesInstanceEngine {
    engine: string;
    engineVersion: string;
    zoneId: string;
}

export interface GetKvstoreInstancesInstance {
    architectureType: string;
    autoRenew: boolean;
    autoRenewPeriod: number;
    availabilityZone: string;
    bandwidth: number;
    capacity: number;
    chargeType: string;
    config: {[key: string]: string};
    connectionDomain: string;
    connectionMode: string;
    connections: number;
    createTime: string;
    dbInstanceId: string;
    dbInstanceName: string;
    destroyTime: string;
    endTime: string;
    engineVersion: string;
    expireTime: string;
    hasRenewChangeOrder: boolean;
    id: string;
    instanceClass: string;
    instanceReleaseProtection: boolean;
    instanceType: string;
    isRds: boolean;
    maintainEndTime: string;
    maintainStartTime: string;
    maxConnections: number;
    name: string;
    networkType: string;
    nodeType: string;
    packageType: string;
    paymentType: string;
    port: number;
    privateIp: string;
    qps: number;
    regionId: string;
    replacateId: string;
    resourceGroupId: string;
    searchKey: string;
    secondaryZoneId: string;
    securityGroupId: string;
    securityIpGroupAttribute: string;
    securityIpGroupName: string;
    securityIps: string[];
    sslEnable: string;
    status: string;
    tags: {[key: string]: string};
    userName: string;
    vpcAuthMode: string;
    vpcCloudInstanceId: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetKvstoreZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetLindormInstancesInstance {
    autoRenew: string;
    coldStorage: number;
    createTime: string;
    deletionProection: boolean;
    diskCategory: string;
    diskUsage: string;
    diskWarningThreshold: string;
    engineType: number;
    expiredTime: string;
    fileEngineNodeCount: number;
    fileEngineSpecification: string;
    id: string;
    instanceId: string;
    instanceName: string;
    instanceStorage: string;
    ipWhiteLists: string[];
    ltsNodeCount: number;
    ltsNodeSpecification: string;
    networkType: string;
    paymentType: string;
    phoenixNodeCount: number;
    phoenixNodeSpecification: string;
    resourceOwnerId: string;
    searchEngineNodeCount: number;
    searchEngineSpecification: string;
    serviceType: string;
    status: string;
    tableEngineNodeCount: number;
    tableEngineSpecification: string;
    timeSeriesEngineNodeCount: number;
    timeSeriresEngineSpecification: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetLogProjectsProject {
    description: string;
    id: string;
    lastModifyTime: string;
    owner: string;
    policy: string;
    projectName: string;
    region: string;
    status: string;
}

export interface GetLogStoresStore {
    id: string;
    storeName: string;
}

export interface GetMarketProductProduct {
    code: string;
    description: string;
    name: string;
    skuses: outputs.GetMarketProductProductSkus[];
}

export interface GetMarketProductProductSkus {
    images: outputs.GetMarketProductProductSkusImage[];
    packageVersions: outputs.GetMarketProductProductSkusPackageVersion[];
    skuCode: string;
    skuName: string;
}

export interface GetMarketProductProductSkusImage {
    imageId: string;
    imageName: string;
    regionId: string;
}

export interface GetMarketProductProductSkusPackageVersion {
    packageName: string;
    packageVersion: string;
}

export interface GetMarketProductsProduct {
    categoryId: number;
    code: string;
    deliveryDate: string;
    deliveryWay: string;
    imageUrl: string;
    name: string;
    operationSystem: string;
    score: string;
    shortDescription: string;
    suggestedPrice: string;
    supplierId: number;
    supplierName: string;
    tags: string;
    targetUrl: string;
    warrantyDate: string;
}

export interface GetMaxcomputeProjectsProject {
    comment: string;
    costStorage: string;
    createTime: string;
    defaultQuota: string;
    ipWhiteLists: outputs.GetMaxcomputeProjectsProjectIpWhiteList[];
    owner: string;
    projectName: string;
    properties: outputs.GetMaxcomputeProjectsProjectProperty[];
    securityProperties: outputs.GetMaxcomputeProjectsProjectSecurityProperty[];
    status: string;
    type: string;
}

export interface GetMaxcomputeProjectsProjectIpWhiteList {
    ipList: string;
    vpcIpList: string;
}

export interface GetMaxcomputeProjectsProjectProperty {
    allowFullScan: boolean;
    enableDecimal2: boolean;
    encryptions: outputs.GetMaxcomputeProjectsProjectPropertyEncryption[];
    retentionDays: number;
    sqlMeteringMax: string;
    tableLifecycles: outputs.GetMaxcomputeProjectsProjectPropertyTableLifecycle[];
    timezone: string;
    typeSystem: string;
}

export interface GetMaxcomputeProjectsProjectPropertyEncryption {
    algorithm: string;
    enable: boolean;
    key: string;
}

export interface GetMaxcomputeProjectsProjectPropertyTableLifecycle {
    type: string;
    value: string;
}

export interface GetMaxcomputeProjectsProjectSecurityProperty {
    enableDownloadPrivilege: boolean;
    labelSecurity: boolean;
    objectCreatorHasAccessPermission: boolean;
    objectCreatorHasGrantPermission: boolean;
    projectProtections: outputs.GetMaxcomputeProjectsProjectSecurityPropertyProjectProtection[];
    usingAcl: boolean;
    usingPolicy: boolean;
}

export interface GetMaxcomputeProjectsProjectSecurityPropertyProjectProtection {
    exceptionPolicy: string;
    protected: boolean;
}

export interface GetMessageServiceQueuesQueue {
    activeMessages: number;
    createTime: number;
    delayMessages: number;
    delaySeconds: number;
    id: string;
    inactiveMessages: number;
    lastModifyTime: number;
    loggingEnabled: boolean;
    maximumMessageSize: number;
    messageRetentionPeriod: number;
    pollingWaitSeconds: number;
    queueInternalUrl: string;
    queueName: string;
    queueUrl: string;
    visibilityTimeout: number;
}

export interface GetMessageServiceSubscriptionsSubscription {
    createTime: number;
    endpoint: string;
    filterTag: string;
    id: string;
    lastModifyTime: number;
    notifyContentFormat: string;
    notifyStrategy: string;
    subscriptionName: string;
    subscriptionUrl: string;
    topicName: string;
    topicOwner: string;
}

export interface GetMessageServiceTopicsTopic {
    createTime: number;
    id: string;
    lastModifyTime: number;
    loggingEnabled: boolean;
    maxMessageSize: number;
    messageCount: number;
    messageRetentionPeriod: number;
    topicInnerUrl: string;
    topicName: string;
    topicUrl: string;
}

export interface GetMhubAppsApp {
    appKey: string;
    appName: string;
    bundleId: string;
    createTime: string;
    encodedIcon: string;
    id: string;
    industryId: string;
    packageName: string;
    productId: string;
    type: string;
}

export interface GetMhubProductsProduct {
    id: string;
    productId: string;
    productName: string;
}

export interface GetMnsQueuesQueue {
    delaySeconds: number;
    id: string;
    maximumMessageSize: number;
    messageRetentionPeriod: number;
    name: string;
    pollingWaitSeconds: number;
    visibilityTimeouts: number;
}

export interface GetMnsTopicSubscriptionsSubscription {
    endpoint: string;
    filterTag: string;
    id: string;
    name: string;
    notifyContentFormat: string;
    notifyStrategy: string;
    topicName: string;
}

export interface GetMnsTopicsTopic {
    id: string;
    loggingEnabled: boolean;
    maximumMessageSize: number;
    name: string;
}

export interface GetMongoInstancesInstance {
    availabilityZone: string;
    chargeType: string;
    creationTime: string;
    engine: string;
    engineVersion: string;
    expirationTime: string;
    id: string;
    instanceClass: string;
    instanceType: string;
    lockMode: string;
    mongos: outputs.GetMongoInstancesInstanceMongo[];
    name: string;
    networkType: string;
    regionId: string;
    replication: string;
    shards: outputs.GetMongoInstancesInstanceShard[];
    status: string;
    storage: number;
    tags: {[key: string]: string};
}

export interface GetMongoInstancesInstanceMongo {
    class: string;
    description: string;
    nodeId: string;
}

export interface GetMongoInstancesInstanceShard {
    class: string;
    description: string;
    nodeId: string;
    storage: number;
}

export interface GetMongodbAccountsAccount {
    accountDescription: string;
    accountName: string;
    characterType: string;
    id: string;
    instanceId: string;
    status: string;
}

export interface GetMongodbAuditPoliciesPolicy {
    auditStatus: string;
    dbInstanceId: string;
    id: string;
}

export interface GetMongodbInstancesInstance {
    availabilityZone: string;
    chargeType: string;
    creationTime: string;
    engine: string;
    engineVersion: string;
    expirationTime: string;
    id: string;
    instanceClass: string;
    instanceType: string;
    lockMode: string;
    mongos: outputs.GetMongodbInstancesInstanceMongo[];
    name: string;
    networkType: string;
    regionId: string;
    replication: string;
    shards: outputs.GetMongodbInstancesInstanceShard[];
    status: string;
    storage: number;
    tags: {[key: string]: string};
}

export interface GetMongodbInstancesInstanceMongo {
    class: string;
    description: string;
    nodeId: string;
}

export interface GetMongodbInstancesInstanceShard {
    class: string;
    description: string;
    nodeId: string;
    storage: number;
}

export interface GetMongodbServerlessInstancesInstance {
    capacityUnit: number;
    dbInstanceClass: string;
    dbInstanceDescription: string;
    dbInstanceId: string;
    dbInstanceReleaseProtection: boolean;
    dbInstanceStorage: number;
    engine: string;
    engineVersion: string;
    expireTime: string;
    id: string;
    kindCode: string;
    lockMode: string;
    maintainEndTime: string;
    maintainStartTime: string;
    maxConnections: number;
    maxIops: number;
    networkType: string;
    paymentType: string;
    protocolType: string;
    resourceGroupId: string;
    securityIpGroups: outputs.GetMongodbServerlessInstancesInstanceSecurityIpGroup[];
    status: string;
    storageEngine: string;
    tags: {[key: string]: string};
    vpcAuthMode: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetMongodbServerlessInstancesInstanceSecurityIpGroup {
    securityIpGroupAttribute: string;
    securityIpGroupName: string;
    securityIpList: string;
}

export interface GetMongodbShardingNetworkPrivateAddressesAddress {
    dbInstanceId: string;
    expiredTime: string;
    ipAddress: string;
    networkAddress: string;
    networkType: string;
    nodeId: string;
    nodeType: string;
    port: string;
    role: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetMongodbShardingNetworkPublicAddressesAddress {
    dbInstanceId: string;
    expiredTime: string;
    ipAddress: string;
    networkAddress: string;
    networkType: string;
    nodeId: string;
    nodeType: string;
    port: string;
    role: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetMongodbZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetMscSubContactsContact {
    accountUid: string;
    contactId: string;
    contactName: string;
    email: string;
    id: string;
    isAccount: boolean;
    isObsolete: boolean;
    isVerifiedEmail: boolean;
    isVerifiedMobile: boolean;
    lastEmailVerificationTimeStamp: string;
    lastMobileVerificationTimeStamp: string;
    mobile: string;
    position: string;
}

export interface GetMscSubSubscriptionsSubscription {
    channel: string;
    contactIds: number[];
    description: string;
    emailStatus: number;
    id: string;
    itemId: string;
    itemName: string;
    pmsgStatus: number;
    smsStatus: number;
    ttsStatus: number;
    webhookIds: number[];
    webhookStatus: number;
}

export interface GetMscSubWebhooksWebhook {
    id: string;
    serverUrl: string;
    webhookId: string;
    webhookName: string;
}

export interface GetMseClustersCluster {
    aclId: string;
    appVersion: string;
    clusterId: string;
    clusterName: string;
    clusterType: string;
    cpu: number;
    healthStatus: string;
    id: string;
    initCostTime: number;
    instanceCount: number;
    instanceId: string;
    instanceModels: outputs.GetMseClustersClusterInstanceModel[];
    internetAddress: string;
    internetDomain: string;
    internetPort: string;
    intranetAddress: string;
    intranetDomain: string;
    intranetPort: string;
    memoryCapacity: number;
    payInfo: string;
    pubNetworkFlow: string;
    status: string;
}

export interface GetMseClustersClusterInstanceModel {
    healthStatus: string;
    instanceType: string;
    internetIp: string;
    ip: string;
    podName: string;
    role: string;
    singleTunnelVip: string;
    vip: string;
}

export interface GetMseEngineNamespacesNamespace {
    configCount: number;
    id: string;
    namespaceDesc: string;
    namespaceId: string;
    namespaceShowName: string;
    quota: number;
    serviceCount: string;
    type: number;
}

export interface GetMseGatewaysGateway {
    backupVswitchId: string;
    gatewayName: string;
    gatewayUniqueId: string;
    id: string;
    paymentType: string;
    replica: string;
    slbLists: outputs.GetMseGatewaysGatewaySlbList[];
    spec: string;
    status: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetMseGatewaysGatewaySlbList {
    associateId: string;
    gatewaySlbMode: string;
    gatewaySlbStatus: string;
    gmtCreate: string;
    slbId: string;
    slbIp: string;
    slbPort: string;
    type: string;
}

export interface GetMseZnodesZnode {
    clusterId: string;
    data: string;
    dir: boolean;
    id: string;
    path: string;
    znodeName: string;
}

export interface GetNasAccessGroupsGroup {
    accessGroupName: string;
    accessGroupType: string;
    description: string;
    id: string;
    mountTargetCount: number;
    ruleCount: number;
    type: string;
}

export interface GetNasAccessRulesRule {
    accessRuleId: string;
    priority: number;
    rwAccess: string;
    sourceCidrIp: string;
    userAccess: string;
}

export interface GetNasAutoSnapshotPoliciesPolicy {
    autoSnapshotPolicyId: string;
    autoSnapshotPolicyName: string;
    createTime: string;
    fileSystemNums: number;
    id: string;
    repeatWeekdays: string[];
    retentionDays: number;
    status: string;
    timePoints: string[];
}

export interface GetNasDataFlowsFlow {
    createTime: string;
    dataFlowId: string;
    description: string;
    errorMessage: string;
    fileSystemId: string;
    fileSystemPath: string;
    fsetDescription: string;
    fsetId: string;
    id: string;
    sourceSecurityType: string;
    sourceStorage: string;
    status: string;
    throughput: number;
}

export interface GetNasFileSystemsSystem {
    capacity: number;
    createTime: string;
    description: string;
    encryptType: number;
    fileSystemType: string;
    id: string;
    kmsKeyId: string;
    meteredSize: number;
    protocolType: string;
    regionId: string;
    storageType: string;
    zoneId: string;
}

export interface GetNasFilesetsFileset {
    createTime: string;
    description: string;
    fileSystemId: string;
    fileSystemPath: string;
    filesetId: string;
    id: string;
    status: string;
    updateTime: string;
}

export interface GetNasLifecyclePoliciesPolicy {
    createTime: string;
    fileSystemId: string;
    id: string;
    lifecyclePolicyName: string;
    lifecycleRuleName: string;
    paths: string[];
    storageType: string;
}

export interface GetNasMountTargetsTarget {
    accessGroupName: string;
    id: string;
    mountTargetDomain: string;
    networkType: string;
    status: string;
    type: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetNasSnapshotsSnapshot {
    createTime: string;
    description: string;
    encryptType: number;
    id: string;
    progress: string;
    remainTime: number;
    retentionDays: number;
    snapshotId: string;
    snapshotName: string;
    sourceFileSystemId: string;
    sourceFileSystemSize: string;
    sourceFileSystemVersion: string;
    status: string;
}

export interface GetNasZonesZone {
    instanceTypes: outputs.GetNasZonesZoneInstanceType[];
    zoneId: string;
}

export interface GetNasZonesZoneInstanceType {
    protocolType: string;
    storageType: string;
}

export interface GetNatGatewaysGateway {
    businessStatus: string;
    deletionProtection: boolean;
    description: string;
    ecsMetricEnabled: boolean;
    expiredTime: string;
    forwardTableIds: string[];
    id: string;
    internetChargeType: string;
    ipLists: string[];
    name: string;
    natGatewayId: string;
    natGatewayName: string;
    natType: string;
    networkType: string;
    paymentType: string;
    resourceGroupId: string;
    snatTableIds: string[];
    spec: string;
    specification: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetNetworkAclsAcl {
    description: string;
    egressAclEntries: outputs.GetNetworkAclsAclEgressAclEntry[];
    id: string;
    ingressAclEntries: outputs.GetNetworkAclsAclIngressAclEntry[];
    networkAclId: string;
    networkAclName: string;
    resources: outputs.GetNetworkAclsAclResource[];
    status: string;
    vpcId: string;
}

export interface GetNetworkAclsAclEgressAclEntry {
    description: string;
    destinationCidrIp: string;
    networkAclEntryName: string;
    policy: string;
    port: string;
    protocol: string;
}

export interface GetNetworkAclsAclIngressAclEntry {
    description: string;
    networkAclEntryName: string;
    policy: string;
    port: string;
    protocol: string;
    sourceCidrIp: string;
}

export interface GetNetworkAclsAclResource {
    resourceId: string;
    resourceType: string;
    status: string;
}

export interface GetNetworkInterfacesInterface {
    associatedPublicIps: outputs.GetNetworkInterfacesInterfaceAssociatedPublicIp[];
    creationTime: string;
    description: string;
    id: string;
    instanceId: string;
    ipv6Sets: string[];
    mac: string;
    name: string;
    networkInterfaceId: string;
    networkInterfaceName: string;
    networkInterfaceTrafficMode: string;
    ownerId: string;
    primaryIpAddress: string;
    privateIp: string;
    privateIpAddresses: string[];
    privateIps: string[];
    queueNumber: number;
    resourceGroupId: string;
    securityGroupIds: string[];
    securityGroups: string[];
    serviceId: number;
    serviceManaged: boolean;
    status: string;
    tags: {[key: string]: string};
    type: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetNetworkInterfacesInterfaceAssociatedPublicIp {
    publicIpAddress: string;
}

export interface GetNlbListenersListener {
    alpnEnabled: boolean;
    alpnPolicy: string;
    caCertificateIds: string[];
    caEnabled: boolean;
    certificateIds: string[];
    cps: number;
    endPort: string;
    id: string;
    idleTimeout: number;
    listenerDescription: string;
    listenerId: string;
    listenerPort: number;
    listenerProtocol: string;
    loadBalancerId: string;
    mss: number;
    proxyProtocolEnabled: boolean;
    secSensorEnabled: boolean;
    securityPolicyId: string;
    serverGroupId: string;
    startPort: string;
    status: string;
}

export interface GetNlbLoadBalancersBalancer {
    addressIpVersion: string;
    addressType: string;
    bandwidthPackageId: string;
    createTime: string;
    crossZoneEnabled: boolean;
    dnsName: string;
    id: string;
    ipv6AddressType: string;
    loadBalancerBusinessStatus: string;
    loadBalancerId: string;
    loadBalancerName: string;
    loadBalancerType: string;
    operationLocks: outputs.GetNlbLoadBalancersBalancerOperationLock[];
    resourceGroupId: string;
    securityGroupIds: string[];
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    zoneMappings: outputs.GetNlbLoadBalancersBalancerZoneMapping[];
}

export interface GetNlbLoadBalancersBalancerOperationLock {
    lockReason: string;
    lockType: string;
}

export interface GetNlbLoadBalancersBalancerZoneMapping {
    allocationId: string;
    eniId: string;
    ipv6Address: string;
    privateIpv4Address: string;
    publicIpv4Address: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetNlbSecurityPoliciesPolicy {
    ciphers: string[];
    id: string;
    resourceGroupId: string;
    securityPolicyName: string;
    status: string;
    tags: {[key: string]: string};
    tlsVersions: string[];
}

export interface GetNlbServerGroupServerAttachmentsAttachment {
    description: string;
    id: string;
    port: number;
    serverGroupId: string;
    serverId: string;
    serverIp: string;
    serverType: string;
    status: string;
    weight: number;
    zoneId: string;
}

export interface GetNlbServerGroupsGroup {
    addressIpVersion: string;
    connectionDrain: boolean;
    connectionDrainTimeout: number;
    healthChecks: outputs.GetNlbServerGroupsGroupHealthCheck[];
    id: string;
    preserveClientIpEnabled: boolean;
    protocol: string;
    relatedLoadBalancerIds: string[];
    resourceGroupId: string;
    scheduler: string;
    serverCount: number;
    serverGroupName: string;
    serverGroupType: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
}

export interface GetNlbServerGroupsGroupHealthCheck {
    healthCheckConnectPort: number;
    healthCheckConnectTimeout: number;
    healthCheckDomain: string;
    healthCheckEnabled: boolean;
    healthCheckHttpCodes: string[];
    healthCheckInterval: number;
    healthCheckType: string;
    healthCheckUrl: string;
    healthyThreshold: number;
    httpCheckMethod: string;
    unhealthyThreshold: number;
}

export interface GetNlbZonesZone {
    id: string;
    localName: string;
    zoneId: string;
}

export interface GetOceanBaseInstancesInstance {
    commodityCode: string;
    cpu: number;
    createTime: string;
    diskSize: string;
    id: string;
    instanceClass: string;
    instanceId: string;
    instanceName: string;
    nodeNum: string;
    paymentType: string;
    resourceGroupId: string;
    series: string;
    status: string;
    zones: string[];
}

export interface GetOnsGroupsGroup {
    groupName: string;
    groupType: string;
    id: string;
    independentNaming: boolean;
    instanceId: string;
    owner: string;
    remark: string;
    tags: {[key: string]: string};
}

export interface GetOnsInstancesInstance {
    httpInternalEndpoint: string;
    httpInternetEndpoint: string;
    httpInternetSecureEndpoint: string;
    id: string;
    independentNaming: boolean;
    instanceId: string;
    instanceName: string;
    instanceStatus: number;
    instanceType: number;
    releaseTime: string;
    remark: string;
    status: number;
    tags: {[key: string]: string};
    tcpEndpoint: string;
}

export interface GetOnsTopicsTopic {
    id: string;
    independentNaming: boolean;
    instanceId: string;
    messageType: number;
    owner: string;
    perm: number;
    relation: number;
    relationName: string;
    remark: string;
    tags: {[key: string]: string};
    topic: string;
    topicName: string;
}

export interface GetOosApplicationGroupsGroup {
    applicationGroupName: string;
    applicationName: string;
    cmsGroupId: string;
    createTime: string;
    deployRegionId: string;
    description: string;
    id: string;
    importTagKey: string;
    importTagValue: string;
    updateTime: string;
}

export interface GetOosApplicationsApplication {
    applicationName: string;
    createTime: string;
    description: string;
    id: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
    updateTime: string;
}

export interface GetOosExecutionsExecution {
    category: string;
    counters: string;
    createDate: string;
    endDate: string;
    executedBy: string;
    executionId: string;
    id: string;
    isParent: boolean;
    mode: string;
    outputs: string;
    parameters: string;
    parentExecutionId: string;
    ramRole: string;
    startDate: string;
    status: string;
    statusMessage: string;
    statusReason: string;
    templateId: string;
    templateName: string;
    templateVersion: string;
    updateDate: string;
}

export interface GetOosParametersParameter {
    constraints: string;
    createTime: string;
    createdBy: string;
    description: string;
    id: string;
    parameterId: string;
    parameterName: string;
    parameterVersion: number;
    resourceGroupId: string;
    shareType: string;
    tags: {[key: string]: string};
    type: string;
    updatedBy: string;
    updatedDate: string;
    value: string;
}

export interface GetOosPatchBaselinesBaseline {
    approvalRules: string;
    createTime: string;
    createdBy: string;
    description: string;
    id: string;
    isDefault: boolean;
    operationSystem: string;
    patchBaselineId: string;
    patchBaselineName: string;
    shareType: string;
    updatedBy: string;
    updatedDate: string;
}

export interface GetOosSecretParametersParameter {
    constraints: string;
    createTime: string;
    createdBy: string;
    description: string;
    id: string;
    keyId: string;
    parameterVersion: number;
    resourceGroupId: string;
    secretParameterId: string;
    secretParameterName: string;
    shareType: string;
    tags: {[key: string]: string};
    type: string;
    updatedBy: string;
    updatedDate: string;
}

export interface GetOosStateConfigurationsConfiguration {
    configureMode: string;
    createTime: string;
    description: string;
    id: string;
    parameters: string;
    resourceGroupId: string;
    scheduleExpression: string;
    scheduleType: string;
    stateConfigurationId: string;
    tags: {[key: string]: string};
    targets: string;
    templateId: string;
    templateName: string;
    templateVersion: string;
    updateTime: string;
}

export interface GetOosTemplatesTemplate {
    category: string;
    createdBy: string;
    createdDate: string;
    description: string;
    hasTrigger: boolean;
    id: string;
    shareType: string;
    tags: {[key: string]: string};
    templateFormat: string;
    templateId: string;
    templateName: string;
    templateType: string;
    templateVersion: string;
    updatedBy: string;
    updatedDate: string;
}

export interface GetOpenSearchAppGroupsGroup {
    appGroupId: string;
    appGroupName: string;
    chargeWay: number;
    commodityCode: string;
    createTime: number;
    currentVersion: string;
    description: string;
    domain: string;
    expireOn: string;
    firstRankAlgoDeploymentId: number;
    hasPendingQuotaReviewTask: number;
    id: string;
    instanceId: string;
    lockMode: string;
    lockedByExpiration: number;
    paymentType: string;
    pendingSecondRankAlgoDeploymentId: number;
    processingOrderId: string;
    produced: number;
    projectId: string;
    quotas: outputs.GetOpenSearchAppGroupsGroupQuota[];
    resourceGroupId: string;
    secondRankAlgoDeploymentId: number;
    status: string;
    switchedTime: number;
    type: string;
}

export interface GetOpenSearchAppGroupsGroupQuota {
    computeResource: string;
    docSize: string;
    spec: string;
}

export interface GetOssBucketObjectsObject {
    acl: string;
    cacheControl: string;
    contentDisposition: string;
    contentEncoding: string;
    contentLength: string;
    contentMd5: string;
    contentType: string;
    etag: string;
    expires: string;
    key: string;
    lastModificationTime: string;
    serverSideEncryption: string;
    sseKmsKeyId: string;
    storageClass: string;
}

export interface GetOssBucketsBucket {
    acl: string;
    corsRules: outputs.GetOssBucketsBucketCorsRule[];
    creationDate: string;
    extranetEndpoint: string;
    intranetEndpoint: string;
    lifecycleRules: outputs.GetOssBucketsBucketLifecycleRule[];
    location: string;
    loggings: outputs.GetOssBucketsBucketLogging[];
    name: string;
    owner: string;
    policy: string;
    redundancyType: string;
    refererConfigs: outputs.GetOssBucketsBucketRefererConfig[];
    serverSideEncryptionRules: outputs.GetOssBucketsBucketServerSideEncryptionRule[];
    storageClass: string;
    tags: {[key: string]: string};
    versionings: outputs.GetOssBucketsBucketVersioning[];
    websites: outputs.GetOssBucketsBucketWebsite[];
}

export interface GetOssBucketsBucketCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders: string[];
    maxAgeSeconds: number;
}

export interface GetOssBucketsBucketLifecycleRule {
    enabled: boolean;
    expirations: outputs.GetOssBucketsBucketLifecycleRuleExpiration[];
    id: string;
    prefix: string;
}

export interface GetOssBucketsBucketLifecycleRuleExpiration {
    date: string;
    days: number;
}

export interface GetOssBucketsBucketLogging {
    targetBucket: string;
    targetPrefix: string;
}

export interface GetOssBucketsBucketRefererConfig {
    allowEmpty: boolean;
    referers: string[];
}

export interface GetOssBucketsBucketServerSideEncryptionRule {
    kmsMasterKeyId: string;
    sseAlgorithm: string;
}

export interface GetOssBucketsBucketVersioning {
    status: string;
}

export interface GetOssBucketsBucketWebsite {
    errorDocument: string;
    indexDocument: string;
}

export interface GetOtsInstanceAttachmentsAttachment {
    domain: string;
    endpoint: string;
    id: string;
    instanceName: string;
    region: string;
    vpcId: string;
    vpcName: string;
}

export interface GetOtsInstancesInstance {
    clusterType: string;
    createTime: string;
    description: string;
    entityQuota: number;
    id: string;
    name: string;
    network: string;
    networkSourceAcls: string[];
    networkTypeAcls: string[];
    policy: string;
    policyVersion: number;
    resourceGroupId: string;
    status: string;
    tableQuota: number;
    tags: {[key: string]: string};
    userId: string;
}

export interface GetOtsSearchIndexesIndex {
    createTime: number;
    currentSyncTimestamp: number;
    id: string;
    indexName: string;
    instanceName: string;
    meteringLastUpdateTime: number;
    reservedReadCu: number;
    rowCount: number;
    schema: string;
    storageSize: number;
    syncPhase: string;
    tableName: string;
    timeToLive: number;
}

export interface GetOtsSecondaryIndexesIndex {
    definedColumns: string[];
    id: string;
    indexName: string;
    indexType: string;
    instanceName: string;
    primaryKeys: string[];
    tableName: string;
}

export interface GetOtsTablesTable {
    definedColumns: outputs.GetOtsTablesTableDefinedColumn[];
    id: string;
    instanceName: string;
    maxVersion: number;
    primaryKeys: outputs.GetOtsTablesTablePrimaryKey[];
    tableName: string;
    timeToLive: number;
}

export interface GetOtsTablesTableDefinedColumn {
    name: string;
    type: string;
}

export interface GetOtsTablesTablePrimaryKey {
    name: string;
    type: string;
}

export interface GetOtsTunnelsTunnel {
    channels: outputs.GetOtsTunnelsTunnelChannel[];
    createTime: number;
    expired: boolean;
    id: string;
    instanceName: string;
    tableName: string;
    tunnelId: string;
    tunnelName: string;
    tunnelRpo: number;
    tunnelStage: string;
    tunnelType: string;
}

export interface GetOtsTunnelsTunnelChannel {
    channelId: string;
    channelRpo: number;
    channelStatus: string;
    channelType: string;
    clientId: string;
}

export interface GetPolardbAccountsAccount {
    accountDescription: string;
    accountLockState: string;
    accountName: string;
    accountStatus: string;
    accountType: string;
    databasePrivileges: outputs.GetPolardbAccountsAccountDatabasePrivilege[];
}

export interface GetPolardbAccountsAccountDatabasePrivilege {
    accountPrivilege: string;
    dbName: string;
}

export interface GetPolardbClustersCluster {
    chargeType: string;
    connectionString: string;
    createTime: string;
    dbNodeClass: string;
    dbNodeNumber: number;
    dbNodes: outputs.GetPolardbClustersClusterDbNode[];
    dbType: string;
    dbVersion: string;
    deleteLock: number;
    description: string;
    engine: string;
    expireTime: string;
    expired: string;
    id: string;
    lockMode: string;
    networkType: string;
    port: string;
    regionId: string;
    status: string;
    storageUsed: number;
    vpcId: string;
    zoneId: string;
}

export interface GetPolardbClustersClusterDbNode {
    createTime: string;
    dbNodeClass: string;
    dbNodeId: string;
    dbNodeRole: string;
    dbNodeStatus: string;
    maxConnections: number;
    maxIops: number;
    regionId: string;
    zoneId: string;
}

export interface GetPolardbDatabasesDatabase {
    accounts: outputs.GetPolardbDatabasesDatabaseAccount[];
    characterSetName: string;
    dbDescription: string;
    dbName: string;
    dbStatus: string;
    engine: string;
}

export interface GetPolardbDatabasesDatabaseAccount {
    accountName: string;
    accountStatus: string;
    privilegeStatus: string;
}

export interface GetPolardbEndpointsEndpoint {
    addressItems: outputs.GetPolardbEndpointsEndpointAddressItem[];
    autoAddNewNodes: string;
    dbEndpointId: string;
    endpointConfig: string;
    endpointType: string;
    nodes: string;
    readWriteMode: string;
}

export interface GetPolardbEndpointsEndpointAddressItem {
    connectionString: string;
    ipAddress: string;
    netType: string;
    port: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetPolardbGlobalDatabaseNetworksNetwork {
    createTime: string;
    dbClusters: outputs.GetPolardbGlobalDatabaseNetworksNetworkDbCluster[];
    dbType: string;
    dbVersion: string;
    description: string;
    gdnId: string;
    id: string;
    status: string;
}

export interface GetPolardbGlobalDatabaseNetworksNetworkDbCluster {
    dbClusterId: string;
    regionId: string;
    role: string;
}

export interface GetPolardbNodeClassesClass {
    supportedEngines: outputs.GetPolardbNodeClassesClassSupportedEngine[];
    zoneId: string;
}

export interface GetPolardbNodeClassesClassSupportedEngine {
    availableResources: outputs.GetPolardbNodeClassesClassSupportedEngineAvailableResource[];
    engine: string;
}

export interface GetPolardbNodeClassesClassSupportedEngineAvailableResource {
    dbNodeClass: string;
}

export interface GetPolardbParameterGroupsGroup {
    createTime: string;
    dbType: string;
    dbVersion: string;
    forceRestart: string;
    id: string;
    parameterCounts: number;
    parameterGroupDesc: string;
    parameterGroupId: string;
    parameterGroupName: string;
    parameterGroupType: string;
}

export interface GetPolardbZonesZone {
    id: string;
    multiZoneIds: string[];
}

export interface GetPrivatelinkVpcEndpointConnectionsConnection {
    bandwidth: number;
    endpointId: string;
    id: string;
    status: string;
}

export interface GetPrivatelinkVpcEndpointServiceResourcesResource {
    id: string;
    resourceId: string;
    resourceType: string;
}

export interface GetPrivatelinkVpcEndpointServiceUsersUser {
    id: string;
    userId: string;
}

export interface GetPrivatelinkVpcEndpointServicesService {
    autoAcceptConnection: boolean;
    connectBandwidth: number;
    id: string;
    serviceBusinessStatus: string;
    serviceDescription: string;
    serviceDomain: string;
    serviceId: string;
    status: string;
    vpcEndpointServiceName: string;
}

export interface GetPrivatelinkVpcEndpointZonesZone {
    eniId: string;
    eniIp: string;
    id: string;
    status: string;
    vswitchId: string;
    zoneDomain: string;
    zoneId: string;
}

export interface GetPrivatelinkVpcEndpointsEndpoint {
    bandwidth: number;
    connectionStatus: string;
    endpointBusinessStatus: string;
    endpointDescription: string;
    endpointDomain: string;
    endpointId: string;
    id: string;
    securityGroupIds: string[];
    serviceId: string;
    serviceName: string;
    status: string;
    vpcEndpointName: string;
    vpcId: string;
}

export interface GetPvtzEndpointsEndpoint {
    createTime: string;
    endpointName: string;
    id: string;
    ipConfigs: outputs.GetPvtzEndpointsEndpointIpConfig[];
    securityGroupId: string;
    status: string;
    vpcId: string;
    vpcName: string;
    vpcRegionId: string;
}

export interface GetPvtzEndpointsEndpointIpConfig {
    cidrBlock: string;
    ip: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetPvtzResolverZonesZone {
    status: string;
    zoneId: string;
}

export interface GetPvtzRulesRule {
    bindVpcs: outputs.GetPvtzRulesRuleBindVpc[];
    createTime: string;
    endpointId: string;
    endpointName: string;
    forwardIps: outputs.GetPvtzRulesRuleForwardIp[];
    id: string;
    ruleId: string;
    ruleName: string;
    type: string;
    zoneName: string;
}

export interface GetPvtzRulesRuleBindVpc {
    regionId: string;
    regionName: string;
    vpcId: string;
    vpcName: string;
}

export interface GetPvtzRulesRuleForwardIp {
    ip: string;
    port: number;
}

export interface GetPvtzZoneRecordsRecord {
    id: string;
    priority: number;
    recordId: string;
    remark: string;
    resourceRecord: string;
    rr: string;
    status: string;
    ttl: number;
    type: string;
    value: string;
}

export interface GetPvtzZonesZone {
    bindVpcs: outputs.GetPvtzZonesZoneBindVpc[];
    createTimestamp: number;
    creationTime: string;
    id: string;
    isPtr: boolean;
    name: string;
    proxyPattern: string;
    recordCount: number;
    remark: string;
    resourceGroupId: string;
    slaveDns: boolean;
    updateTime: string;
    updateTimestamp: number;
    zoneId: string;
    zoneName: string;
}

export interface GetPvtzZonesZoneBindVpc {
    regionId: string;
    regionName: string;
    vpcId: string;
    vpcName: string;
}

export interface GetQuickBiUsersUser {
    accountId: string;
    accountName: string;
    adminUser: boolean;
    authAdminUser: boolean;
    email: string;
    id: string;
    nickName: string;
    phone: string;
    userId: string;
    userType: string;
}

export interface GetQuotasApplicationInfosApplication {
    applicationId: string;
    approveValue: string;
    auditReason: string;
    desireValue: number;
    dimensions: outputs.GetQuotasApplicationInfosApplicationDimension[];
    effectiveTime: string;
    expireTime: string;
    id: string;
    noticeType: number;
    productCode: string;
    quotaActionCode: string;
    quotaDescription: string;
    quotaName: string;
    quotaUnit: string;
    reason: string;
    status: string;
}

export interface GetQuotasApplicationInfosApplicationDimension {
    key: string;
    value: string;
}

export interface GetQuotasApplicationInfosDimension {
    key?: string;
    value?: string;
}

export interface GetQuotasQuotaAlarmsAlarm {
    alarmId: string;
    id: string;
    productCode: string;
    quotaActionCode: string;
    quotaAlarmName: string;
    quotaDimensions: outputs.GetQuotasQuotaAlarmsAlarmQuotaDimension[];
    threshold: number;
    thresholdPercent: number;
    webHook: string;
}

export interface GetQuotasQuotaAlarmsAlarmQuotaDimension {
    key: string;
    value: string;
}

export interface GetQuotasQuotaAlarmsQuotaDimension {
    key?: string;
    value?: string;
}

export interface GetQuotasQuotaApplicationsApplication {
    applicationId: string;
    approveValue: string;
    auditReason: string;
    desireValue: number;
    dimensions: outputs.GetQuotasQuotaApplicationsApplicationDimension[];
    effectiveTime: string;
    expireTime: string;
    id: string;
    noticeType: number;
    productCode: string;
    quotaActionCode: string;
    quotaDescription: string;
    quotaName: string;
    quotaUnit: string;
    reason: string;
    status: string;
}

export interface GetQuotasQuotaApplicationsApplicationDimension {
    key: string;
    value: string;
}

export interface GetQuotasQuotaApplicationsDimension {
    key?: string;
    value?: string;
}

export interface GetQuotasQuotasDimension {
    key?: string;
    value?: string;
}

export interface GetQuotasQuotasQuota {
    adjustable: boolean;
    applicableRanges: string[];
    applicableType: string;
    consumable: boolean;
    id: string;
    quotaActionCode: string;
    quotaDescription: string;
    quotaName: string;
    quotaType: string;
    quotaUnit: string;
    totalQuota: number;
    totalUsage: number;
    unadjustableDetail: string;
}

export interface GetQuotasTemplateApplicationsApplication {
    aliyunUids: string[];
    applyTime: string;
    auditStatusVos: outputs.GetQuotasTemplateApplicationsApplicationAuditStatusVo[];
    batchQuotaApplicationId: string;
    desireValue: number;
    dimensions: outputs.GetQuotasTemplateApplicationsApplicationDimension[];
    effectiveTime: string;
    expireTime: string;
    id: string;
    productCode: string;
    quotaActionCode: string;
    quotaCategory: string;
    reason: string;
}

export interface GetQuotasTemplateApplicationsApplicationAuditStatusVo {
    count: number;
    status: string;
}

export interface GetQuotasTemplateApplicationsApplicationDimension {
    key: string;
    value: string;
}

export interface GetRamGroupsGroup {
    comments: string;
    name: string;
}

export interface GetRamPoliciesPolicy {
    attachmentCount: number;
    createDate: string;
    defaultVersion: string;
    description: string;
    document: string;
    id: string;
    name: string;
    policyDocument: string;
    policyName: string;
    type: string;
    updateDate: string;
    userName: string;
    versionId: string;
}

export interface GetRamPolicyDocumentStatement {
    actions: string[];
    conditions?: outputs.GetRamPolicyDocumentStatementCondition[];
    effect?: string;
    principals?: outputs.GetRamPolicyDocumentStatementPrincipal[];
    resources?: string[];
}

export interface GetRamPolicyDocumentStatementCondition {
    operator: string;
    values: string[];
    variable: string;
}

export interface GetRamPolicyDocumentStatementPrincipal {
    entity: string;
    identifiers: string[];
}

export interface GetRamRolesRole {
    arn: string;
    assumeRolePolicyDocument: string;
    createDate: string;
    description: string;
    document: string;
    id: string;
    name: string;
    updateDate: string;
}

export interface GetRamSamlProvidersProvider {
    arn: string;
    description: string;
    encodedsamlMetadataDocument: string;
    id: string;
    samlProviderName: string;
    updateDate: string;
}

export interface GetRamUsersUser {
    createDate: string;
    id: string;
    lastLoginDate: string;
    name: string;
}

export interface GetRdcOrganizationsOrganization {
    id: string;
    organizationId: string;
    organizationName: string;
}

export interface GetRdsAccountsAccount {
    accountDescription: string;
    accountName: string;
    accountType: string;
    databasePrivileges: outputs.GetRdsAccountsAccountDatabasePrivilege[];
    id: string;
    privExceeded: string;
    status: string;
}

export interface GetRdsAccountsAccountDatabasePrivilege {
    accountPrivilege: string;
    accountPrivilegeDetail: string;
    dbName: string;
}

export interface GetRdsBackupsBackup {
    backupDownloadUrl: string;
    backupEndTime: string;
    backupId: string;
    backupInitiator: string;
    backupIntranetDownloadUrl: string;
    backupMethod: string;
    backupMode: string;
    backupSize: string;
    backupStartTime: string;
    backupStatus: string;
    backupType: string;
    consistentTime: string;
    copyOnlyBackup: string;
    dbInstanceId: string;
    encryption: string;
    hostInstanceId: string;
    id: string;
    isAvail: number;
    metaStatus: string;
    storageClass: string;
    storeStatus: string;
}

export interface GetRdsCollationTimeZonesCollationTimeZone {
    description?: string;
    standardTimeOffset?: string;
    timeZone?: string;
}

export interface GetRdsCrossRegionBackupsBackup {
    backupEndTime: string;
    backupMethod: string;
    backupSetScale: string;
    backupSetStatus: number;
    backupStartTime: string;
    backupType: string;
    category: string;
    consistentTime: string;
    crossBackupDownloadLink: string;
    crossBackupId: string;
    crossBackupRegion: string;
    crossBackupSetFile: string;
    crossBackupSetLocation: string;
    crossBackupSetSize: number;
    dbInstanceStorageType: string;
    engine: string;
    engineVersion: string;
    id: string;
    instanceId: number;
    recoveryBeginTime: string;
    recoveryEndTime: string;
    restoreRegions: string[];
}

export interface GetRdsCrossRegionsRegion {
    id: string;
}

export interface GetRdsModifyParameterLogsLog {
    modifyTime: string;
    newParameterValue: string;
    oldParameterValue: string;
    parameterName: string;
    status: string;
}

export interface GetRdsParameterGroupsGroup {
    engine: string;
    engineVersion: string;
    forceRestart: number;
    id: string;
    paramCounts: number;
    paramDetails: outputs.GetRdsParameterGroupsGroupParamDetail[];
    parameterGroupDesc: string;
    parameterGroupId: string;
    parameterGroupName: string;
    parameterGroupType: number;
}

export interface GetRdsParameterGroupsGroupParamDetail {
    paramName: string;
    paramValue: string;
}

export interface GetRdsSlotsSlot {
    database: string;
    plugin: string;
    slotName: string;
    slotStatus: string;
    slotType: string;
    temporary: string;
    walDelay: string;
}

export interface GetRegionsRegion {
    id: string;
    localName: string;
    regionId: string;
}

export interface GetResourceManagerAccountDeletionCheckTaskAbandonAbleCheck {
    checkId: string;
    checkName: string;
    description: string;
}

export interface GetResourceManagerAccountDeletionCheckTaskNotAllowReason {
    checkId: string;
    checkName: string;
    description: string;
}

export interface GetResourceManagerAccountsAccount {
    accountId: string;
    accountName: string;
    displayName: string;
    folderId: string;
    id: string;
    joinMethod: string;
    joinTime: string;
    modifyTime: string;
    payerAccountId: string;
    resourceDirectoryId: string;
    status: string;
    type: string;
}

export interface GetResourceManagerControlPoliciesPolicy {
    attachmentCount: number;
    controlPolicyName: string;
    description: string;
    effectScope: string;
    id: string;
    policyDocument: string;
    policyId: string;
    policyType: string;
}

export interface GetResourceManagerControlPolicyAttachmentsAttachment {
    attachDate: string;
    description: string;
    id: string;
    policyId: string;
    policyName: string;
    policyType: string;
}

export interface GetResourceManagerDelegatedAdministratorsAdministrator {
    accountId: string;
    delegationEnabledTime: string;
    id: string;
    servicePrincipal: string;
}

export interface GetResourceManagerFoldersFolder {
    folderId: string;
    folderName: string;
    id: string;
    parentFolderId: string;
}

export interface GetResourceManagerHandshakesHandshake {
    expireTime: string;
    handshakeId: string;
    id: string;
    invitedAccountRealName: string;
    masterAccountId: string;
    masterAccountName: string;
    masterAccountRealName: string;
    modifyTime: string;
    note: string;
    resourceDirectoryId: string;
    status: string;
    targetEntity: string;
    targetType: string;
}

export interface GetResourceManagerPoliciesPolicy {
    attachmentCount: number;
    defaultVersion: string;
    description: string;
    id: string;
    policyName: string;
    policyType: string;
    updateDate: string;
}

export interface GetResourceManagerPolicyAttachmentsAttachment {
    attachDate: string;
    description: string;
    id: string;
    policyName: string;
    policyType: string;
    principalName: string;
    principalType: string;
    resourceGroupId: string;
}

export interface GetResourceManagerPolicyVersionsVersion {
    id: string;
    isDefaultVersion: boolean;
    policyDocument: string;
    versionId: string;
}

export interface GetResourceManagerResourceDirectoriesDirectory {
    id: string;
    masterAccountId: string;
    masterAccountName: string;
    resourceDirectoryId: string;
    rootFolderId: string;
    status: string;
}

export interface GetResourceManagerResourceGroupsGroup {
    accountId: string;
    displayName: string;
    id: string;
    name: string;
    regionStatuses: outputs.GetResourceManagerResourceGroupsGroupRegionStatus[];
    resourceGroupName: string;
    status: string;
}

export interface GetResourceManagerResourceGroupsGroupRegionStatus {
    regionId: string;
    status: string;
}

export interface GetResourceManagerResourceSharesShare {
    id: string;
    resourceShareId: string;
    resourceShareName: string;
    resourceShareOwner: string;
    status: string;
}

export interface GetResourceManagerRolesRole {
    arn: string;
    assumeRolePolicyDocument: string;
    description: string;
    id: string;
    maxSessionDuration: number;
    roleId: string;
    roleName: string;
    updateDate: string;
}

export interface GetResourceManagerSharedResourcesResource {
    id: string;
    resourceId: string;
    resourceShareId: string;
    resourceType: string;
    status: string;
}

export interface GetResourceManagerSharedTargetsTarget {
    id: string;
    resourceShareId: string;
    status: string;
    targetId: string;
}

export interface GetRosChangeSetsSet {
    changeSetId: string;
    changeSetName: string;
    changeSetType: string;
    description: string;
    disableRollback: boolean;
    executionStatus: string;
    id: string;
    parameters: outputs.GetRosChangeSetsSetParameter[];
    stackId: string;
    stackName: string;
    status: string;
    templateBody: string;
    timeoutInMinutes: number;
}

export interface GetRosChangeSetsSetParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetRosRegionsRegion {
    localName: string;
    regionEndpoint: string;
    regionId: string;
}

export interface GetRosStackGroupsGroup {
    administrationRoleName: string;
    description: string;
    executionRoleName: string;
    id: string;
    parameters: outputs.GetRosStackGroupsGroupParameter[];
    stackGroupId: string;
    stackGroupName: string;
    status: string;
    templateBody: string;
}

export interface GetRosStackGroupsGroupParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetRosStackInstancesInstance {
    id: string;
    parameterOverrides: outputs.GetRosStackInstancesInstanceParameterOverride[];
    stackGroupId: string;
    stackGroupName: string;
    stackId: string;
    stackInstanceAccountId: string;
    stackInstanceRegionId: string;
    status: string;
    statusReason: string;
}

export interface GetRosStackInstancesInstanceParameterOverride {
    parameterKey: string;
    parameterValue: string;
}

export interface GetRosStacksStack {
    deletionProtection: string;
    description: string;
    disableRollback: boolean;
    driftDetectionTime: string;
    id: string;
    parameters: outputs.GetRosStacksStackParameter[];
    parentStackId: string;
    ramRoleName: string;
    rootStackId: string;
    stackDriftStatus: string;
    stackId: string;
    stackName: string;
    stackPolicyBody: string;
    status: string;
    statusReason: string;
    tags: {[key: string]: string};
    templateDescription: string;
    timeoutInMinutes: number;
}

export interface GetRosStacksStackParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetRosTemplateScratchesScratch {
    createTime: string;
    description: string;
    id: string;
    logicalIdStrategy: string;
    preferenceParameters: outputs.GetRosTemplateScratchesScratchPreferenceParameter[];
    sourceResourceGroups: outputs.GetRosTemplateScratchesScratchSourceResourceGroup[];
    sourceResources: outputs.GetRosTemplateScratchesScratchSourceResource[];
    sourceTags: outputs.GetRosTemplateScratchesScratchSourceTag[];
    stacks: outputs.GetRosTemplateScratchesScratchStack[];
    status: string;
    templateScratchId: string;
    templateScratchType: string;
}

export interface GetRosTemplateScratchesScratchPreferenceParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetRosTemplateScratchesScratchSourceResource {
    resourceId: string;
    resourceType: string;
}

export interface GetRosTemplateScratchesScratchSourceResourceGroup {
    resourceGroupId: string;
    resourceTypeFilters: string[];
}

export interface GetRosTemplateScratchesScratchSourceTag {
    resourceTags: {[key: string]: string};
    resourceTypeFilters: string[];
}

export interface GetRosTemplateScratchesScratchStack {
    stackId: string;
}

export interface GetRosTemplatesTemplate {
    changeSetId: string;
    description: string;
    id: string;
    shareType: string;
    stackGroupName: string;
    stackId: string;
    tags: {[key: string]: string};
    templateBody: string;
    templateId: string;
    templateName: string;
    templateVersion: string;
}

export interface GetRouteEntriesEntry {
    cidrBlock: string;
    instanceId: string;
    nextHopType: string;
    routeTableId: string;
    status: string;
    type: string;
}

export interface GetRouteTablesTable {
    description: string;
    id: string;
    name: string;
    resourceGroupId: string;
    routeTableId: string;
    routeTableName: string;
    routeTableType: string;
    routerId: string;
    routerType: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchIds: string[];
}

export interface GetRouterInterfacesInterface {
    accessPointId: string;
    creationTime: string;
    description: string;
    healthCheckSourceIp: string;
    healthCheckTargetIp: string;
    id: string;
    name: string;
    oppositeInterfaceId: string;
    oppositeInterfaceOwnerId: string;
    oppositeRegionId: string;
    oppositeRouterId: string;
    oppositeRouterType: string;
    role: string;
    routerId: string;
    routerType: string;
    specification: string;
    status: string;
    vpcId: string;
}

export interface GetSaeApplicationScalingRulesRule {
    appId: string;
    createTime: string;
    id: string;
    scalingRuleEnable: boolean;
    scalingRuleMetrics: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetric[];
    scalingRuleName: string;
    scalingRuleTimers: outputs.GetSaeApplicationScalingRulesRuleScalingRuleTimer[];
    scalingRuleType: string;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetric {
    maxReplicas: number;
    metrics: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricMetric[];
    metricsStatuses: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatus[];
    minReplicas: number;
    scaleDownRules: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricScaleDownRule[];
    scaleUpRules: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricScaleUpRule[];
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricMetric {
    metricTargetAverageUtilization: number;
    metricType: string;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatus {
    currentMetrics: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetric[];
    currentReplicas: number;
    desiredReplicas: number;
    lastScaleTime: string;
    maxReplicas: number;
    minReplicas: number;
    nextScaleMetrics: outputs.GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetric[];
    nextScaleTimePeriod: number;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatusCurrentMetric {
    currentValue: number;
    name: string;
    type: string;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricMetricsStatusNextScaleMetric {
    name: string;
    nextScaleInAverageUtilization: number;
    nextScaleOutAverageUtilization: number;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricScaleDownRule {
    disabled: boolean;
    stabilizationWindowSeconds: number;
    step: number;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleMetricScaleUpRule {
    disabled: boolean;
    stabilizationWindowSeconds: number;
    step: number;
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleTimer {
    beginDate: string;
    endDate: string;
    period: string;
    schedules: outputs.GetSaeApplicationScalingRulesRuleScalingRuleTimerSchedule[];
}

export interface GetSaeApplicationScalingRulesRuleScalingRuleTimerSchedule {
    atTime: string;
    maxReplicas: number;
    minReplicas: number;
    targetReplicas: number;
}

export interface GetSaeApplicationsApplication {
    acrAssumeRoleArn: string;
    acrInstanceId: string;
    appDescription: string;
    appName: string;
    applicationId: string;
    command: string;
    commandArgs: string;
    configMapMountDesc: string;
    cpu: number;
    createTime: string;
    customHostAlias: string;
    edasContainerVersion: string;
    envs: string;
    id: string;
    imageUrl: string;
    jarStartArgs: string;
    jarStartOptions: string;
    jdk: string;
    liveness: string;
    memory: number;
    minReadyInstances: number;
    mountDescs: outputs.GetSaeApplicationsApplicationMountDesc[];
    mountHost: string;
    namespaceId: string;
    nasId: string;
    ossAkId: string;
    ossAkSecret: string;
    ossMountDescs: string;
    ossMountDetails: outputs.GetSaeApplicationsApplicationOssMountDetail[];
    packageType: string;
    packageUrl: string;
    packageVersion: string;
    phpArmsConfigLocation: string;
    phpConfig: string;
    phpConfigLocation: string;
    postStart: string;
    preStop: string;
    readiness: string;
    regionId: string;
    replicas: number;
    repoName: string;
    repoNamespace: string;
    repoOriginType: string;
    securityGroupId: string;
    slsConfigs: string;
    status: string;
    tags: {[key: string]: string};
    terminationGracePeriodSeconds: number;
    timezone: string;
    tomcatConfig: string;
    vpcId: string;
    vswitchId: string;
    warStartOptions: string;
    webContainer: string;
}

export interface GetSaeApplicationsApplicationMountDesc {
    mountPath: string;
    nasPath: string;
}

export interface GetSaeApplicationsApplicationOssMountDetail {
    bucketName: string;
    bucketPath: string;
    mountPath: string;
    readOnly: boolean;
}

export interface GetSaeConfigMapsMap {
    configMapId: string;
    createTime: string;
    data: string;
    description: string;
    id: string;
    name: string;
    namespaceId: string;
}

export interface GetSaeGreyTagRoutesRoute {
    description: string;
    dubboRules: outputs.GetSaeGreyTagRoutesRouteDubboRule[];
    greyTagRouteName: string;
    id: string;
    scRules: outputs.GetSaeGreyTagRoutesRouteScRule[];
}

export interface GetSaeGreyTagRoutesRouteDubboRule {
    condition: string;
    group: string;
    items: outputs.GetSaeGreyTagRoutesRouteDubboRuleItem[];
    methodName: string;
    serviceName: string;
    version: string;
}

export interface GetSaeGreyTagRoutesRouteDubboRuleItem {
    cond: string;
    expr: string;
    index: number;
    operator: string;
    value: string;
}

export interface GetSaeGreyTagRoutesRouteScRule {
    condition: string;
    items: outputs.GetSaeGreyTagRoutesRouteScRuleItem[];
    path: string;
}

export interface GetSaeGreyTagRoutesRouteScRuleItem {
    cond: string;
    name: string;
    operator: string;
    type: string;
    value: string;
}

export interface GetSaeIngressesIngress {
    certId: string;
    defaultRule: string;
    description: string;
    id: string;
    ingressId: string;
    listenerPort: number;
    namespaceId: string;
    slbId: string;
}

export interface GetSaeInstanceSpecificationsSpecification {
    cpu: number;
    enable: boolean;
    id: string;
    instanceSpecificationId: string;
    memory: number;
    specInfo: string;
    version: number;
}

export interface GetSaeNamespacesNamespace {
    id: string;
    namespaceDescription: string;
    namespaceId: string;
    namespaceName: string;
}

export interface GetSagAclsAcl {
    id: string;
    name: string;
}

export interface GetScdnDomainsDomain {
    certInfos: outputs.GetScdnDomainsDomainCertInfo[];
    cname: string;
    createTime: string;
    description: string;
    domainName: string;
    gmtModified: string;
    id: string;
    resourceGroupId: string;
    sources: outputs.GetScdnDomainsDomainSource[];
    status: string;
}

export interface GetScdnDomainsDomainCertInfo {
    certName: string;
    certType: string;
    sslProtocol: string;
    sslPub: string;
}

export interface GetScdnDomainsDomainSource {
    content: string;
    enabled: string;
    port: number;
    priority: string;
    type: string;
}

export interface GetSchedulerxNamespacesNamespace {
    description: string;
    id: string;
    namespaceId: string;
    namespaceName: string;
}

export interface GetSddpConfigsConfig {
    code: string;
    configId: string;
    defaultValue: string;
    description: string;
    id: string;
    value: string;
}

export interface GetSddpDataLimitsLimit {
    auditStatus: number;
    checkStatus: number;
    dataLimitId: string;
    engineType: string;
    id: string;
    localName: string;
    logStoreDay: number;
    parentId: string;
    port: number;
    resourceType: string;
    userName: string;
}

export interface GetSddpInstancesInstance {
    authed: boolean;
    id: string;
    instanceId: string;
    instanceNum: string;
    odpsSet: boolean;
    ossBucketSet: boolean;
    ossSize: string;
    paymentType: string;
    rdsSet: boolean;
    status: string;
}

export interface GetSddpRulesRule {
    category: number;
    categoryName: string;
    content: string;
    contentCategory: string;
    createTime: string;
    customType: number;
    description: string;
    displayName: string;
    gmtModified: string;
    id: string;
    loginName: string;
    majorKey: string;
    name: string;
    productCode: string;
    productId: string;
    riskLevelId: string;
    riskLevelName: string;
    ruleId: string;
    statExpress: string;
    status: number;
    target: string;
    userId: string;
    warnLevel: number;
}

export interface GetSecurityCenterGroupsGroup {
    groupFlag: number;
    groupId: string;
    groupName: string;
    id: string;
}

export interface GetSecurityGroupRulesRule {
    description: string;
    destCidrIp: string;
    destGroupId: string;
    destGroupOwnerAccount: string;
    direction: string;
    ipProtocol: string;
    nicType: string;
    policy: string;
    portRange: string;
    priority: number;
    sourceCidrIp: string;
    sourceGroupId: string;
    sourceGroupOwnerAccount: string;
}

export interface GetSecurityGroupsGroup {
    creationTime: string;
    description: string;
    id: string;
    innerAccess: boolean;
    name: string;
    resourceGroupId: string;
    securityGroupType: string;
    tags: {[key: string]: string};
    vpcId: string;
}

export interface GetSelectdbDbClustersCluster {
    cacheSize: number;
    cpu: number;
    createTime: string;
    dbClusterClass: string;
    dbClusterDescription: string;
    dbClusterId: string;
    dbInstanceId: string;
    engine: string;
    engineVersion: string;
    id: string;
    memory: number;
    paramChangeLogs: outputs.GetSelectdbDbClustersClusterParamChangeLog[];
    params: outputs.GetSelectdbDbClustersClusterParam[];
    paymentType: string;
    regionId: string;
    status: string;
    vpcId: string;
    zoneId: string;
}

export interface GetSelectdbDbClustersClusterParam {
    comment: string;
    defaultValue: string;
    isDynamic: number;
    isUserModifiable: number;
    name: string;
    optional: number;
    paramCategory: string;
    value: string;
}

export interface GetSelectdbDbClustersClusterParamChangeLog {
    configId: number;
    gmtCreated: string;
    gmtModified: string;
    isApplied: number;
    name: string;
    newValue: string;
    oldValue: string;
}

export interface GetSelectdbDbInstancesInstance {
    cacheSizePostpaid: number;
    cacheSizePrepaid: number;
    clusterCountPostpaid: number;
    clusterCountPrepaid: number;
    cpuPostpaid: number;
    cpuPrepaid: number;
    dbInstanceDescription: string;
    dbInstanceId: string;
    engine: string;
    engineMinorVersion: string;
    engineVersion: string;
    gmtCreated: string;
    gmtExpired: string;
    gmtModified: string;
    id: string;
    lockMode: string;
    lockReason: string;
    memoryPostpaid: number;
    memoryPrepaid: number;
    paymentType: string;
    regionId: string;
    status: string;
    subDomain: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetServiceCatalogEndUserProductsEndUserProduct {
    createTime: string;
    description: string;
    hasDefaultLaunchOption: boolean;
    id: string;
    productArn: string;
    productId: string;
    productName: string;
    productType: string;
    providerName: string;
}

export interface GetServiceCatalogLaunchOptionsLaunchOption {
    constraintSummaries: outputs.GetServiceCatalogLaunchOptionsLaunchOptionConstraintSummary[];
    id: string;
    portfolioId: string;
    portfolioName: string;
}

export interface GetServiceCatalogLaunchOptionsLaunchOptionConstraintSummary {
    constraintType: string;
    description: string;
}

export interface GetServiceCatalogLaunchOptionsOption {
    constraintSummaries: outputs.GetServiceCatalogLaunchOptionsOptionConstraintSummary[];
    id: string;
    portfolioId: string;
    portfolioName: string;
}

export interface GetServiceCatalogLaunchOptionsOptionConstraintSummary {
    constraintType: string;
    description: string;
}

export interface GetServiceCatalogPortfoliosPortfolio {
    createTime: string;
    description: string;
    id: string;
    portfolioArn: string;
    portfolioId: string;
    portfolioName: string;
    providerName: string;
}

export interface GetServiceCatalogProductAsEndUsersUser {
    createTime: string;
    description: string;
    hasDefaultLaunchOption: boolean;
    id: string;
    productArn: string;
    productId: string;
    productName: string;
    productType: string;
    providerName: string;
}

export interface GetServiceCatalogProductVersionsProductVersion {
    active: boolean;
    createTime: string;
    description: string;
    guidance: string;
    id: string;
    productId: string;
    productVersionId: string;
    productVersionName: string;
    templateType: string;
    templateUrl: string;
}

export interface GetServiceCatalogProductVersionsVersion {
    active: boolean;
    createTime: string;
    description: string;
    guidance: string;
    id: string;
    productId: string;
    productVersionId: string;
    productVersionName: string;
    templateType: string;
    templateUrl: string;
}

export interface GetServiceCatalogProvisionedProductsProduct {
    createTime: string;
    id: string;
    lastProvisioningTaskId: string;
    lastSuccessfulProvisioningTaskId: string;
    lastTaskId: string;
    outputs: outputs.GetServiceCatalogProvisionedProductsProductOutput[];
    ownerPrincipalId: string;
    ownerPrincipalType: string;
    parameters: outputs.GetServiceCatalogProvisionedProductsProductParameter[];
    portfolioId: string;
    productId: string;
    productName: string;
    productVersionId: string;
    productVersionName: string;
    provisionedProductArn: string;
    provisionedProductId: string;
    provisionedProductName: string;
    provisionedProductType: string;
    stackId: string;
    stackRegionId: string;
    status: string;
    statusMessage: string;
    tags: {[key: string]: string};
}

export interface GetServiceCatalogProvisionedProductsProductOutput {
    description: string;
    outputKey: string;
    outputValue: string;
}

export interface GetServiceCatalogProvisionedProductsProductParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetServiceCatalogProvisionedProductsProvisionedProduct {
    createTime: string;
    id: string;
    lastProvisioningTaskId: string;
    lastSuccessfulProvisioningTaskId: string;
    lastTaskId: string;
    outputs: outputs.GetServiceCatalogProvisionedProductsProvisionedProductOutput[];
    ownerPrincipalId: string;
    ownerPrincipalType: string;
    parameters: outputs.GetServiceCatalogProvisionedProductsProvisionedProductParameter[];
    portfolioId: string;
    productId: string;
    productName: string;
    productVersionId: string;
    productVersionName: string;
    provisionedProductArn: string;
    provisionedProductId: string;
    provisionedProductName: string;
    provisionedProductType: string;
    stackId: string;
    stackRegionId: string;
    status: string;
    statusMessage: string;
    tags: {[key: string]: string};
}

export interface GetServiceCatalogProvisionedProductsProvisionedProductOutput {
    description: string;
    outputKey: string;
    outputValue: string;
}

export interface GetServiceCatalogProvisionedProductsProvisionedProductParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface GetServiceMeshExtensionProvidersProvider {
    config: string;
    extensionProviderName: string;
    id: string;
    serviceMeshId: string;
    type: string;
}

export interface GetServiceMeshServiceMeshesMesh {
    clusters: string[];
    createTime: string;
    edition: string;
    endpoints: outputs.GetServiceMeshServiceMeshesMeshEndpoint[];
    errorMessage: string;
    id: string;
    istioOperatorVersion: string;
    kubeConfig: string;
    loadBalancers: outputs.GetServiceMeshServiceMeshesMeshLoadBalancer[];
    meshConfigs: outputs.GetServiceMeshServiceMeshesMeshMeshConfig[];
    networks: outputs.GetServiceMeshServiceMeshesMeshNetwork[];
    serviceMeshId: string;
    serviceMeshName: string;
    sidecarVersion: string;
    status: string;
    version: string;
}

export interface GetServiceMeshServiceMeshesMeshEndpoint {
    intranetApiServerEndpoint: string;
    intranetPilotEndpoint: string;
    publicApiServerEndpoint: string;
    publicPilotEndpoint: string;
}

export interface GetServiceMeshServiceMeshesMeshLoadBalancer {
    apiServerLoadbalancerId: string;
    apiServerPublicEip: boolean;
    pilotPublicEip: boolean;
    pilotPublicLoadbalancerId: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfig {
    accessLogs: outputs.GetServiceMeshServiceMeshesMeshMeshConfigAccessLog[];
    audits: outputs.GetServiceMeshServiceMeshesMeshMeshConfigAudit[];
    controlPlaneLogs: outputs.GetServiceMeshServiceMeshesMeshMeshConfigControlPlaneLog[];
    customizedZipkin: boolean;
    enableLocalityLb: boolean;
    includeIpRanges: string;
    kialis: outputs.GetServiceMeshServiceMeshesMeshMeshConfigKiali[];
    opas: outputs.GetServiceMeshServiceMeshesMeshMeshConfigOpa[];
    outboundTrafficPolicy: string;
    pilots: outputs.GetServiceMeshServiceMeshesMeshMeshConfigPilot[];
    prometheuses: outputs.GetServiceMeshServiceMeshesMeshMeshConfigPrometheus[];
    proxies: outputs.GetServiceMeshServiceMeshesMeshMeshConfigProxy[];
    sidecarInjectors: outputs.GetServiceMeshServiceMeshesMeshMeshConfigSidecarInjector[];
    telemetry: boolean;
    tracing: boolean;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigAccessLog {
    enabled: boolean;
    project: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigAudit {
    enabled: boolean;
    project: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigControlPlaneLog {
    enabled: boolean;
    project: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigKiali {
    enabled: boolean;
    url: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigOpa {
    enabled: boolean;
    limitCpu: string;
    limitMemory: string;
    logLevel: string;
    requestCpu: string;
    requestMemory: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigPilot {
    http10Enabled: boolean;
    traceSampling: number;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigPrometheus {
    externalUrl: string;
    useExternal: boolean;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigProxy {
    clusterDomain: string;
    limitCpu: string;
    limitMemory: string;
    requestCpu: string;
    requestMemory: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigSidecarInjector {
    autoInjectionPolicyEnabled: boolean;
    enableNamespacesByDefault: boolean;
    initCniConfigurations: outputs.GetServiceMeshServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration[];
    limitCpu: string;
    limitMemory: string;
    requestCpu: string;
    requestMemory: string;
    sidecarInjectorWebhookAsYaml: string;
}

export interface GetServiceMeshServiceMeshesMeshMeshConfigSidecarInjectorInitCniConfiguration {
    enabled: boolean;
    excludeNamespaces: string;
}

export interface GetServiceMeshServiceMeshesMeshNetwork {
    securityGroupId: string;
    vpcId: string;
    vswitcheLists: string[];
}

export interface GetServiceMeshVersionsVersion {
    edition: string;
    id: string;
    version: string;
}

export interface GetSimpleApplicationServerCustomImagesImage {
    customImageId: string;
    customImageName: string;
    description: string;
    id: string;
    platform: string;
}

export interface GetSimpleApplicationServerDisksDisk {
    category: string;
    createTime: string;
    device: string;
    diskId: string;
    diskName: string;
    diskType: string;
    id: string;
    instanceId: string;
    paymentType: string;
    size: number;
    status: string;
}

export interface GetSimpleApplicationServerFirewallRulesRule {
    firewallRuleId: string;
    id: string;
    instanceId: string;
    port: string;
    remark: string;
    ruleProtocol: string;
}

export interface GetSimpleApplicationServerImagesImage {
    description: string;
    id: string;
    imageId: string;
    imageName: string;
    imageType: string;
    platform: string;
}

export interface GetSimpleApplicationServerInstancesInstance {
    businessStatus: string;
    createTime: string;
    ddosStatus: string;
    expiredTime: string;
    id: string;
    imageId: string;
    innerIpAddress: string;
    instanceId: string;
    instanceName: string;
    paymentType: string;
    planId: string;
    publicIpAddress: string;
    status: string;
}

export interface GetSimpleApplicationServerPlansPlan {
    bandwidth: number;
    core: number;
    diskSize: number;
    flow: number;
    id: string;
    memory: number;
    planId: string;
    supportPlatform: string;
}

export interface GetSimpleApplicationServerSnapshotsSnapshot {
    createTime: string;
    diskId: string;
    id: string;
    progress: string;
    remark: string;
    snapshotId: string;
    snapshotName: string;
    sourceDiskType: string;
    status: string;
}

export interface GetSlbAclsAcl {
    entryLists: outputs.GetSlbAclsAclEntryList[];
    id: string;
    ipVersion: string;
    name: string;
    relatedListeners: outputs.GetSlbAclsAclRelatedListener[];
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetSlbAclsAclEntryList {
    comment: string;
    entry: string;
}

export interface GetSlbAclsAclRelatedListener {
    aclType: string;
    frontendPort: number;
    loadBalancerId: string;
    protocol: string;
}

export interface GetSlbAttachmentsSlbAttachment {
    instanceId: string;
    weight: number;
}

export interface GetSlbBackendServersBackendServer {
    id: string;
    serverType: string;
    weight: number;
}

export interface GetSlbCaCertificatesCertificate {
    caCertificateId: string;
    caCertificateName: string;
    commonName: string;
    createdTimestamp: number;
    expiredTime: string;
    expiredTimestamp: number;
    fingerprint: string;
    id: string;
    name: string;
    resourceGroupId: string;
    tags: {[key: string]: string};
}

export interface GetSlbDomainExtensionsExtension {
    domain: string;
    id: string;
    serverCertificateId: string;
}

export interface GetSlbListenersSlbListener {
    backendPort: number;
    bandwidth: number;
    caCertificateId: string;
    cookie: string;
    cookieTimeout: number;
    description: string;
    enableHttp2: string;
    establishedTimeout: number;
    frontendPort: number;
    gzip: string;
    healthCheck: string;
    healthCheckConnectPort: number;
    healthCheckConnectTimeout: number;
    healthCheckDomain: string;
    healthCheckHttpCode: string;
    healthCheckInterval: number;
    healthCheckTimeout: number;
    healthCheckType: string;
    healthCheckUri: string;
    healthyThreshold: number;
    idleTimeout: number;
    masterSlaveServerGroupId: string;
    persistenceTimeout: number;
    protocol: string;
    proxyProtocolV2Enabled: boolean;
    requestTimeout: number;
    scheduler: string;
    securityStatus: string;
    serverCertificateId: string;
    serverGroupId: string;
    sslCertificateId: string;
    status: string;
    stickySession: string;
    stickySessionType: string;
    tlsCipherPolicy: string;
    unhealthyThreshold: number;
    xForwardedFor: string;
    xForwardedForSlbId: string;
    xForwardedForSlbIp: string;
    xForwardedForSlbProto: string;
}

export interface GetSlbLoadBalancersBalancer {
    address: string;
    addressIpVersion: string;
    addressType: string;
    autoReleaseTime: number;
    backendServers: outputs.GetSlbLoadBalancersBalancerBackendServer[];
    bandwidth: number;
    createTimeStamp: number;
    deleteProtection: string;
    endTime: string;
    endTimeStamp: number;
    id: string;
    internetChargeType: string;
    listenerPortsAndProtocals: outputs.GetSlbLoadBalancersBalancerListenerPortsAndProtocal[];
    listenerPortsAndProtocols: outputs.GetSlbLoadBalancersBalancerListenerPortsAndProtocol[];
    loadBalancerId: string;
    loadBalancerName: string;
    loadBalancerSpec: string;
    masterZoneId: string;
    modificationProtectionReason: string;
    modificationProtectionStatus: string;
    networkType: string;
    paymentType: string;
    regionIdAlias: string;
    renewalCycUnit: string;
    renewalDuration: number;
    renewalStatus: string;
    resourceGroupId: string;
    slaveZoneId: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetSlbLoadBalancersBalancerBackendServer {
    description: string;
    serverId: string;
    type: string;
    weight: number;
}

export interface GetSlbLoadBalancersBalancerListenerPortsAndProtocal {
    listenerPort: number;
    listenerProtocal: string;
}

export interface GetSlbLoadBalancersBalancerListenerPortsAndProtocol {
    description: string;
    forwardPort: number;
    listenerForward: string;
    listenerPort: number;
    listenerProtocol: string;
}

export interface GetSlbLoadBalancersSlb {
    address: string;
    creationTime: string;
    id: string;
    internet: boolean;
    masterAvailabilityZone: string;
    name: string;
    networkType: string;
    regionId: string;
    slaveAvailabilityZone: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetSlbMasterSlaveServerGroupsGroup {
    id: string;
    name: string;
    servers: outputs.GetSlbMasterSlaveServerGroupsGroupServer[];
}

export interface GetSlbMasterSlaveServerGroupsGroupServer {
    instanceId: string;
    isBackup: number;
    port: number;
    serverType: string;
    weight: number;
}

export interface GetSlbRulesSlbRule {
    domain: string;
    id: string;
    name: string;
    serverGroupId: string;
    url: string;
}

export interface GetSlbServerCertificatesCertificate {
    alicloudCertificateId: string;
    alicloudCertificateName: string;
    commonName: string;
    createdTime: string;
    createdTimestamp: number;
    expiredTime: string;
    expiredTimestamp: number;
    fingerprint: string;
    id: string;
    isAlicloudCertificate: boolean;
    name: string;
    resourceGroupId: string;
    subjectAlternativeNames: string[];
    tags: {[key: string]: string};
}

export interface GetSlbServerGroupsSlbServerGroup {
    id: string;
    name: string;
    servers: outputs.GetSlbServerGroupsSlbServerGroupServer[];
}

export interface GetSlbServerGroupsSlbServerGroupServer {
    instanceId: string;
    weight: number;
}

export interface GetSlbTlsCipherPoliciesPolicy {
    ciphers: string[];
    createTime: string;
    id: string;
    relateListeners: outputs.GetSlbTlsCipherPoliciesPolicyRelateListener[];
    status: string;
    tlsCipherPolicyId: string;
    tlsCipherPolicyName: string;
    tlsVersions: string[];
}

export interface GetSlbTlsCipherPoliciesPolicyRelateListener {
    loadBalancerId: string;
    port: number;
    protocol: string;
}

export interface GetSlbZonesZone {
    id: string;
    masterZoneId: string;
    slaveZoneId: string;
    slbSlaveZoneIds: string[];
    supportedResources: outputs.GetSlbZonesZoneSupportedResource[];
}

export interface GetSlbZonesZoneSupportedResource {
    addressIpVersion: string;
    addressType: string;
}

export interface GetSlbsBalancer {
    address: string;
    addressIpVersion: string;
    addressType: string;
    autoReleaseTime: number;
    backendServers: outputs.GetSlbsBalancerBackendServer[];
    bandwidth: number;
    createTimeStamp: number;
    deleteProtection: string;
    endTime: string;
    endTimeStamp: number;
    id: string;
    internetChargeType: string;
    listenerPortsAndProtocals: outputs.GetSlbsBalancerListenerPortsAndProtocal[];
    listenerPortsAndProtocols: outputs.GetSlbsBalancerListenerPortsAndProtocol[];
    loadBalancerId: string;
    loadBalancerName: string;
    loadBalancerSpec: string;
    masterZoneId: string;
    modificationProtectionReason: string;
    modificationProtectionStatus: string;
    networkType: string;
    paymentType: string;
    regionIdAlias: string;
    renewalCycUnit: string;
    renewalDuration: number;
    renewalStatus: string;
    resourceGroupId: string;
    slaveZoneId: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetSlbsBalancerBackendServer {
    description: string;
    serverId: string;
    type: string;
    weight: number;
}

export interface GetSlbsBalancerListenerPortsAndProtocal {
    listenerPort: number;
    listenerProtocal: string;
}

export interface GetSlbsBalancerListenerPortsAndProtocol {
    description: string;
    forwardPort: number;
    listenerForward: string;
    listenerPort: number;
    listenerProtocol: string;
}

export interface GetSlbsSlb {
    address: string;
    creationTime: string;
    id: string;
    internet: boolean;
    masterAvailabilityZone: string;
    name: string;
    networkType: string;
    regionId: string;
    slaveAvailabilityZone: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
}

export interface GetSmartagFlowLogsLog {
    activeAging: number;
    description: string;
    flowLogId: string;
    flowLogName: string;
    id: string;
    inactiveAging: number;
    logstoreName: string;
    netflowServerIp: string;
    netflowServerPort: number;
    netflowVersion: string;
    outputType: string;
    projectName: string;
    resourceGroupId: string;
    slsRegionId: string;
    status: string;
    totalSagNum: number;
}

export interface GetSnapshotsSnapshot {
    category: string;
    creationTime: string;
    description: string;
    diskId: string;
    encrypted: boolean;
    id: string;
    instantAccess: boolean;
    instantAccessRetentionDays: number;
    name: string;
    productCode: string;
    progress: string;
    remainTime: number;
    resourceGroupId: string;
    retentionDays: number;
    snapshotId: string;
    snapshotName: string;
    snapshotSn: string;
    snapshotType: string;
    sourceDiskId: string;
    sourceDiskSize: string;
    sourceDiskType: string;
    sourceStorageType: string;
    status: string;
    tags: {[key: string]: string};
    type: string;
    usage: string;
}

export interface GetSnatEntriesEntry {
    id: string;
    snatEntryId: string;
    snatEntryName: string;
    snatIp: string;
    sourceCidr: string;
    sourceVswitchId: string;
    status: string;
}

export interface GetSslCertificatesServiceCertificatesCertificate {
    buyInAliyun: boolean;
    cert: string;
    certId: string;
    certificateName: string;
    city: string;
    common: string;
    country: string;
    endDate: string;
    expired: boolean;
    fingerprint: string;
    id: string;
    issuer: string;
    key: string;
    name: string;
    orgName: string;
    province: string;
    sans: string;
    startDate: string;
}

export interface GetSslVpnClientCertsCert {
    createTime: string;
    endTime: number;
    id: string;
    name: string;
    sslVpnServerId: string;
    status: string;
}

export interface GetSslVpnServersServer {
    cipher: string;
    clientIpPool: string;
    compress: boolean;
    connections: number;
    createTime: string;
    id: string;
    internetIp: string;
    localSubnet: string;
    maxConnections: number;
    name: string;
    port: number;
    proto: string;
    vpnGatewayId: string;
}

export interface GetTagMetaTagsTag {
    category: string;
    keyName: string;
    valueName: string;
}

export interface GetThreatDetectionAntiBruteForceRulesRule {
    antiBruteForceRuleId: string;
    antiBruteForceRuleName: string;
    defaultRule: boolean;
    failCount: number;
    forbiddenTime: number;
    id: string;
    span: number;
    uuidLists: string[];
}

export interface GetThreatDetectionAssetsAsset {
    createTime: string;
    id: string;
    uuid: string;
}

export interface GetThreatDetectionBackupPoliciesPolicy {
    backupPolicyId: number;
    backupPolicyName: string;
    id: number;
    policy: string;
    policyRegionId: string;
    policyVersion: string;
    status: string;
    uuidLists: string[];
}

export interface GetThreatDetectionBaselineStrategiesStrategy {
    baselineStrategyId: string;
    baselineStrategyName: string;
    customType: string;
    cycleDays: number;
    cycleStartTime: number;
    endTime: string;
    id: string;
    riskSubTypeName: string;
    startTime: string;
    targetType: string;
}

export interface GetThreatDetectionHoneyPotsPot {
    honeypotId: string;
    honeypotImageId: string;
    honeypotImageName: string;
    honeypotName: string;
    id: string;
    nodeId: string;
    presetId: string;
    states: string[];
    status: string;
}

export interface GetThreatDetectionHoneypotImagesImage {
    honeypotImageDisplayName: string;
    honeypotImageId: string;
    honeypotImageName: string;
    honeypotImageType: string;
    honeypotImageVersion: string;
    id: string;
    multiports: string;
    proto: string;
    servicePort: string;
    template: string;
}

export interface GetThreatDetectionHoneypotNodesNode {
    allowHoneypotAccessInternet: boolean;
    availableProbeNum: number;
    createTime: string;
    id: string;
    nodeId: string;
    nodeName: string;
    securityGroupProbeIpLists: string[];
    status: number;
}

export interface GetThreatDetectionHoneypotPresetsPreset {
    honeypotImageName: string;
    honeypotPresetId: string;
    id: string;
    metas: outputs.GetThreatDetectionHoneypotPresetsPresetMeta[];
    nodeId: string;
    presetName: string;
}

export interface GetThreatDetectionHoneypotPresetsPresetMeta {
    burp: string;
    portraitOption: boolean;
    trojanGit: string;
}

export interface GetThreatDetectionHoneypotProbesProbe {
    arp: boolean;
    controlNodeId: string;
    displayName: string;
    honeypotBindLists: outputs.GetThreatDetectionHoneypotProbesProbeHoneypotBindList[];
    honeypotProbeId: string;
    id: string;
    ping: boolean;
    probeType: string;
    serviceIpLists: string[];
    status: string;
    uuid: string;
    vpcId: string;
}

export interface GetThreatDetectionHoneypotProbesProbeHoneypotBindList {
    bindPortLists: outputs.GetThreatDetectionHoneypotProbesProbeHoneypotBindListBindPortList[];
    honeypotId: string;
}

export interface GetThreatDetectionHoneypotProbesProbeHoneypotBindListBindPortList {
    bindPort: boolean;
    endPort: number;
    fixed: boolean;
    startPort: number;
    targetPort: number;
}

export interface GetThreatDetectionInstancesInstance {
    createTime: string;
    id: string;
    instanceId: string;
    paymentType: string;
    status: string;
}

export interface GetThreatDetectionVulWhitelistsWhitelist {
    id: string;
    reason: string;
    targetInfo: string;
    vulWhitelistId: string;
    whitelist: string;
}

export interface GetThreatDetectionWebLockConfigsConfig {
    defenceMode: string;
    dir: string;
    exclusiveDir: string;
    exclusiveFile: string;
    exclusiveFileType: string;
    id: string;
    inclusiveFileType: string;
    localBackupDir: string;
    mode: string;
    uuid: string;
}

export interface GetTsdbInstancesInstance {
    autoRenew: string;
    cpuNumber: string;
    diskCategory: string;
    engineType: string;
    expiredTime: number;
    id: string;
    instanceAlias: string;
    instanceClass: string;
    instanceId: string;
    instanceStorage: string;
    memorySize: string;
    networkType: string;
    paymentType: string;
    status: string;
    vpcConnectionAddress: string;
    vpcId: string;
    vswitchId: string;
    zoneId: string;
}

export interface GetTsdbZonesZone {
    id: string;
    localName: string;
    zoneId: string;
}

export interface GetVideoSurveillanceSystemGroupsGroup {
    app: string;
    callback: string;
    createTime: string;
    description: string;
    enabled: boolean;
    gbId: string;
    gbIp: string;
    groupId: string;
    groupName: string;
    id: string;
    inProtocol: string;
    outProtocol: string;
    playDomain: string;
    pushDomain: string;
    stats: outputs.GetVideoSurveillanceSystemGroupsGroupStat[];
}

export interface GetVideoSurveillanceSystemGroupsGroupStat {
    deviceNum: string;
    iedNum: string;
    ipcNum: string;
    platformNum: string;
}

export interface GetVodDomainsDomain {
    cname: string;
    description: string;
    domainName: string;
    gmtCreated: string;
    gmtModified: string;
    id: string;
    sandBox: string;
    sources: outputs.GetVodDomainsDomainSource[];
    sslProtocol: string;
    status: string;
}

export interface GetVodDomainsDomainSource {
    sourceContent: string;
    sourcePort: string;
    sourcePriority: string;
    sourceType: string;
}

export interface GetVpcBgpGroupsGroup {
    authKey: string;
    bgpGroupName: string;
    description: string;
    hold: string;
    id: string;
    ipVersion: string;
    isFakeAsn: boolean;
    keepalive: string;
    localAsn: number;
    peerAsn: number;
    routeLimit: string;
    routerId: string;
    status: string;
}

export interface GetVpcBgpNetworksNetwork {
    dstCidrBlock: string;
    id: string;
    routerId: string;
    status: string;
}

export interface GetVpcBgpPeersPeer {
    authKey: string;
    bfdMultiHop: number;
    bgpGroupId: string;
    bgpPeerId: string;
    bgpPeerName: string;
    bgpStatus: string;
    description: string;
    enableBfd: boolean;
    hold: string;
    id: string;
    ipVersion: string;
    isFake: boolean;
    keepalive: string;
    localAsn: string;
    peerAsn: string;
    peerIpAddress: string;
    routeLimit: string;
    routerId: string;
    status: string;
}

export interface GetVpcDhcpOptionsSetsSet {
    associateVpcCount: number;
    dhcpOptionsSetDescription: string;
    dhcpOptionsSetId: string;
    dhcpOptionsSetName: string;
    domainName: string;
    domainNameServers: string;
    id: string;
    ownerId: string;
    status: string;
}

export interface GetVpcFlowLogsLog {
    description: string;
    flowLogId: string;
    flowLogName: string;
    id: string;
    logStoreName: string;
    projectName: string;
    resourceId: string;
    resourceType: string;
    status: string;
    trafficType: string;
}

export interface GetVpcIpv4GatewaysGateway {
    createTime: string;
    enabled: boolean;
    id: string;
    ipv4GatewayDescription: string;
    ipv4GatewayId: string;
    ipv4GatewayName: string;
    ipv4GatewayRouteTableId: string;
    status: string;
    vpcId: string;
}

export interface GetVpcIpv6AddressesAddress {
    associatedInstanceId: string;
    associatedInstanceType: string;
    createTime: string;
    id: string;
    ipv6Address: string;
    ipv6AddressId: string;
    ipv6AddressName: string;
    ipv6GatewayId: string;
    networkType: string;
    status: string;
    vpcId: string;
    vswitchId: string;
}

export interface GetVpcIpv6EgressRulesRule {
    description: string;
    id: string;
    instanceId: string;
    instanceType: string;
    ipv6EgressRuleId: string;
    ipv6EgressRuleName: string;
    ipv6GatewayId: string;
    status: string;
}

export interface GetVpcIpv6GatewaysGateway {
    businessStatus: string;
    createTime: string;
    description: string;
    expiredTime: string;
    id: string;
    instanceChargeType: string;
    ipv6GatewayId: string;
    ipv6GatewayName: string;
    spec: string;
    status: string;
    vpcId: string;
}

export interface GetVpcIpv6InternetBandwidthsBandwidth {
    bandwidth: number;
    id: string;
    internetChargeType: string;
    ipv6AddressId: string;
    ipv6GatewayId: string;
    ipv6InternetBandwidthId: string;
    paymentType: string;
    status: string;
}

export interface GetVpcNatIpCidrsCidr {
    createTime: string;
    id: string;
    isDefault: boolean;
    natGatewayId: string;
    natIpCidr: string;
    natIpCidrDescription: string;
    natIpCidrId: string;
    natIpCidrName: string;
    status: string;
}

export interface GetVpcNatIpsIp {
    id: string;
    isDefault: boolean;
    natGatewayId: string;
    natIp: string;
    natIpCidr: string;
    natIpDescription: string;
    natIpId: string;
    natIpName: string;
    status: string;
}

export interface GetVpcPeerConnectionsConnection {
    acceptingAliUid: number;
    acceptingRegionId: string;
    acceptingVpcId: string;
    bandwidth: number;
    createTime: string;
    description: string;
    id: string;
    peerConnectionId: string;
    peerConnectionName: string;
    status: string;
    vpcId: string;
}

export interface GetVpcPrefixListsList {
    createTime: string;
    entrys: outputs.GetVpcPrefixListsListEntry[];
    id: string;
    ipVersion: string;
    maxEntries: number;
    prefixListDescription: string;
    prefixListId: string;
    prefixListName: string;
    shareType: string;
}

export interface GetVpcPrefixListsListEntry {
    cidr: string;
    description: string;
}

export interface GetVpcPublicIpAddressPoolCidrBlocksBlock {
    cidrBlock: string;
    createTime: string;
    id: string;
    publicIpAddressPoolId: string;
    status: string;
    totalIpNum: number;
    usedIpNum: number;
}

export interface GetVpcPublicIpAddressPoolsPool {
    createTime: string;
    description: string;
    id: string;
    ipAddressRemaining: boolean;
    isp: string;
    publicIpAddressPoolId: string;
    publicIpAddressPoolName: string;
    regionId: string;
    status: string;
    totalIpNum: number;
    usedIpNum: number;
    userType: string;
}

export interface GetVpcTrafficMirrorFilterEgressRulesRule {
    destinationCidrBlock: string;
    destinationPortRange: string;
    id: string;
    priority: number;
    protocol: string;
    ruleAction: string;
    sourceCidrBlock: string;
    sourcePortRange: string;
    status: string;
    trafficMirrorFilterId: string;
    trafficMirrorFilterRuleId: string;
}

export interface GetVpcTrafficMirrorFilterIngressRulesRule {
    destinationCidrBlock: string;
    destinationPortRange: string;
    id: string;
    priority: number;
    protocol: string;
    ruleAction: string;
    sourceCidrBlock: string;
    sourcePortRange: string;
    status: string;
    trafficMirrorFilterId: string;
    trafficMirrorFilterRuleId: string;
}

export interface GetVpcTrafficMirrorFiltersFilter {
    id: string;
    status: string;
    trafficMirrorFilterDescription: string;
    trafficMirrorFilterId: string;
    trafficMirrorFilterName: string;
}

export interface GetVpcTrafficMirrorSessionsSession {
    enabled: boolean;
    id: string;
    packetLength: number;
    priority: number;
    status: string;
    trafficMirrorFilterId: string;
    trafficMirrorSessionBusinessStatus: string;
    trafficMirrorSessionDescription: string;
    trafficMirrorSessionId: string;
    trafficMirrorSessionName: string;
    trafficMirrorSourceIds: string[];
    trafficMirrorTargetId: string;
    trafficMirrorTargetType: string;
    virtualNetworkId: number;
}

export interface GetVpcsVpc {
    cidrBlock: string;
    creationTime: string;
    description: string;
    id: string;
    ipv6CidrBlock: string;
    isDefault: boolean;
    regionId: string;
    resourceGroupId: string;
    routeTableId: string;
    routerId: string;
    secondaryCidrBlocks: string[];
    status: string;
    tags: {[key: string]: string};
    userCidrs: string[];
    vpcId: string;
    vpcName: string;
    vrouterId: string;
    vswitchIds: string[];
}

export interface GetVpnConnectionsConnection {
    createTime: string;
    customerGatewayId: string;
    effectImmediately: boolean;
    enableDpd: boolean;
    enableNatTraversal: boolean;
    enableTunnelsBgp: boolean;
    id: string;
    ikeConfigs: outputs.GetVpnConnectionsConnectionIkeConfig[];
    ipsecConfigs: outputs.GetVpnConnectionsConnectionIpsecConfig[];
    localSubnet: string;
    name: string;
    remoteSubnet: string;
    status: string;
    tunnelOptionsSpecifications: outputs.GetVpnConnectionsConnectionTunnelOptionsSpecification[];
    vcoHealthChecks: outputs.GetVpnConnectionsConnectionVcoHealthCheck[];
    vpnBgpConfigs: outputs.GetVpnConnectionsConnectionVpnBgpConfig[];
    vpnGatewayId: string;
}

export interface GetVpnConnectionsConnectionIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg: string;
    ikeLifetime: number;
    ikeLocalId: string;
    ikeMode: string;
    ikePfs: string;
    ikeRemoteId: string;
    ikeVersion: string;
    psk: string;
}

export interface GetVpnConnectionsConnectionIpsecConfig {
    ipsecAuthAlg: string;
    ipsecEncAlg: string;
    ipsecLifetime: number;
    ipsecPfs: string;
}

export interface GetVpnConnectionsConnectionTunnelOptionsSpecification {
    customerGatewayId: string;
    enableDpd: boolean;
    enableNatTraversal: boolean;
    internetIp: string;
    role: string;
    state: string;
    status: string;
    tunnelBgpConfigs: outputs.GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelBgpConfig[];
    tunnelId: string;
    tunnelIkeConfigs: outputs.GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelIkeConfig[];
    tunnelIpsecConfigs: outputs.GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelIpsecConfig[];
    zoneNo: string;
}

export interface GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelBgpConfig {
    bgpStatus: string;
    localAsn: string;
    localBgpIp: string;
    peerAsn: string;
    peerBgpIp: string;
    tunnelCidr: string;
}

export interface GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg: string;
    ikeLifetime: number;
    ikeMode: string;
    ikePfs: string;
    ikeVersion: string;
    localId: string;
    psk: string;
    remoteId: string;
}

export interface GetVpnConnectionsConnectionTunnelOptionsSpecificationTunnelIpsecConfig {
    ipsecAuthAlg: string;
    ipsecEncAlg: string;
    ipsecLifetime: number;
    ipsecPfs: string;
}

export interface GetVpnConnectionsConnectionVcoHealthCheck {
    dip: string;
    enable: string;
    interval: number;
    retry: number;
    sip: string;
    status: string;
}

export interface GetVpnConnectionsConnectionVpnBgpConfig {
    authKey: string;
    localAsn: number;
    localBgpIp: string;
    peerAsn: number;
    peerBgpIp: string;
    status: string;
    tunnelCidr: string;
}

export interface GetVpnCustomerGatewaysGateway {
    asn: number;
    createTime: string;
    description: string;
    id: string;
    ipAddress: string;
    name: string;
}

export interface GetVpnGatewayVcoRoutesRoute {
    asPath: string;
    createTime: string;
    id: string;
    nextHop: string;
    routeDest: string;
    source: string;
    status: string;
    vpnConnectionId: string;
    weight: number;
}

export interface GetVpnGatewayVpnAttachmentsAttachment {
    bgpConfigs: outputs.GetVpnGatewayVpnAttachmentsAttachmentBgpConfig[];
    connectionStatus: string;
    createTime: string;
    customerGatewayId: string;
    effectImmediately: boolean;
    healthCheckConfigs: outputs.GetVpnGatewayVpnAttachmentsAttachmentHealthCheckConfig[];
    id: string;
    ikeConfigs: outputs.GetVpnGatewayVpnAttachmentsAttachmentIkeConfig[];
    internetIp: string;
    ipsecConfigs: outputs.GetVpnGatewayVpnAttachmentsAttachmentIpsecConfig[];
    localSubnet: string;
    networkType: string;
    remoteSubnet: string;
    status: string;
    vpnAttachmentName: string;
    vpnConnectionId: string;
}

export interface GetVpnGatewayVpnAttachmentsAttachmentBgpConfig {
    localAsn: string;
    localBgpIp: string;
    status: string;
    tunnelCidr: string;
}

export interface GetVpnGatewayVpnAttachmentsAttachmentHealthCheckConfig {
    dip: string;
    enable: boolean;
    interval: number;
    policy: string;
    retry: number;
    sip: string;
    status: string;
}

export interface GetVpnGatewayVpnAttachmentsAttachmentIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg: string;
    ikeLifetime: string;
    ikeMode: string;
    ikePfs: string;
    ikeVersion: string;
    localId: string;
    psk: string;
    remoteId: string;
}

export interface GetVpnGatewayVpnAttachmentsAttachmentIpsecConfig {
    ipsecAuthAlg: string;
    ipsecEncAlg: string;
    ipsecLifetime: string;
    ipsecPfs: string;
}

export interface GetVpnGatewayZonesZone {
    zoneId: string;
    zoneName: string;
}

export interface GetVpnGatewaysGateway {
    autoPropagate: string;
    businessStatus: string;
    createTime: string;
    description: string;
    disasterRecoveryInternetIp: string;
    disasterRecoveryVswitchId: string;
    enableIpsec: string;
    enableSsl: string;
    endTime: string;
    id: string;
    instanceChargeType: string;
    internetIp: string;
    name: string;
    networkType: string;
    resourceGroupId: string;
    specification: string;
    sslConnections: number;
    sslVpnInternetIp: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vpnType: string;
    vswitchId: string;
}

export interface GetVpnIpsecServersServer {
    clientIpPool: string;
    createTime: string;
    effectImmediately: boolean;
    id: string;
    idaasInstanceId: string;
    ikeConfigs: outputs.GetVpnIpsecServersServerIkeConfig[];
    internetIp: string;
    ipsecConfigs: outputs.GetVpnIpsecServersServerIpsecConfig[];
    ipsecServerId: string;
    ipsecServerName: string;
    localSubnet: string;
    maxConnections: number;
    multiFactorAuthEnabled: boolean;
    onlineClientCount: number;
    psk: string;
    pskEnabled: boolean;
    vpnGatewayId: string;
}

export interface GetVpnIpsecServersServerIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg: string;
    ikeLifetime: number;
    ikeMode: string;
    ikePfs: string;
    ikeVersion: string;
    localId: string;
    remoteId: string;
}

export interface GetVpnIpsecServersServerIpsecConfig {
    ipsecAuthAlg: string;
    ipsecEncAlg: string;
    ipsecLifetime: number;
    ipsecPfs: string;
}

export interface GetVpnPbrRouteEntriesEntry {
    createTime: string;
    id: string;
    nextHop: string;
    routeDest: string;
    routeSource: string;
    status: string;
    vpnGatewayId: string;
    weight: number;
}

export interface GetVswitchesVswitch {
    availableIpAddressCount: number;
    cidrBlock: string;
    creationTime: string;
    description: string;
    id: string;
    ipv6CidrBlock: string;
    isDefault: boolean;
    name: string;
    resourceGroupId: string;
    routeTableId: string;
    status: string;
    tags: {[key: string]: string};
    vpcId: string;
    vswitchId: string;
    vswitchName: string;
    zoneId: string;
}

export interface GetWafCertificatesCertificate {
    certificateId: string;
    certificateName: string;
    commonName: string;
    domain: string;
    id: string;
    instanceId: string;
    isUsing: boolean;
    sans: string[];
}

export interface GetWafDomainsDomain {
    clusterType: string;
    cname: string;
    connectionTime: number;
    domain: string;
    domainName: string;
    http2Ports: string[];
    httpPorts: string[];
    httpToUserIp: string;
    httpsPorts: string[];
    httpsRedirect: string;
    id: string;
    isAccessProduct: string;
    loadBalancing: string;
    logHeaders: outputs.GetWafDomainsDomainLogHeader[];
    readTime: number;
    resourceGroupId: string;
    sourceIps: string[];
    version: number;
    writeTime: number;
}

export interface GetWafDomainsDomainLogHeader {
    key: string;
    value: string;
}

export interface GetWafInstancesInstance {
    endDate: number;
    id: string;
    inDebt: number;
    instanceId: string;
    remainDay: number;
    status: number;
    subscriptionType: string;
    trial: number;
}

export interface GetWafv3DomainsDomain {
    domain: string;
    id: string;
    listens: outputs.GetWafv3DomainsDomainListen[];
    redirects: outputs.GetWafv3DomainsDomainRedirect[];
    resourceManagerResourceGroupId: string;
    status: string;
}

export interface GetWafv3DomainsDomainListen {
    certId: string;
    cipherSuite: number;
    customCiphers: string[];
    enableTlsv3: boolean;
    exclusiveIp: boolean;
    focusHttps: boolean;
    http2Enabled: boolean;
    httpPorts: number[];
    httpsPorts: number[];
    ipv6Enabled: boolean;
    protectionResource: string;
    tlsVersion: string;
    xffHeaderMode: number;
    xffHeaders: string[];
}

export interface GetWafv3DomainsDomainRedirect {
    backends: string[];
    connectTimeout: number;
    focusHttpBackend: boolean;
    keepalive: boolean;
    keepaliveRequests: number;
    keepaliveTimeout: number;
    loadbalance: string;
    readTimeout: number;
    requestHeaders: outputs.GetWafv3DomainsDomainRedirectRequestHeader[];
    retry: boolean;
    sniEnabled: boolean;
    sniHost: string;
    writeTimeout: number;
}

export interface GetWafv3DomainsDomainRedirectRequestHeader {
    key: string;
    value: string;
}

export interface GetWafv3InstancesInstance {
    createTime: string;
    id: string;
    instanceId: string;
    status: string;
}

export interface GetYundunBastionhostInstancesInstance {
    description: string;
    id: string;
    instanceStatus: string;
    licenseCode: string;
    privateDomain: string;
    publicDomain: string;
    publicNetworkAccess: boolean;
    securityGroupIds: string[];
    tags: {[key: string]: string};
    userVswitchId: string;
}

export interface GetYundunDbauditInstanceInstance {
    description: string;
    id: string;
    instanceStatus: string;
    licenseCode: string;
    privateDomain: string;
    publicDomain: string;
    publicNetworkAccess: boolean;
    tags: {[key: string]: string};
    userVswitchId: string;
}

export interface GetZonesZone {
    availableDiskCategories: string[];
    availableInstanceTypes: string[];
    availableResourceCreations: string[];
    id: string;
    localName: string;
    multiZoneIds: string[];
    slbSlaveZoneIds: string[];
}

export interface GovernanceAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GovernanceBaselineBaselineItem {
    config?: string;
    name?: string;
    version: string;
}

export interface GovernanceBaselineTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbAccountTimeouts {
    create?: string;
}

export interface GpdbBackupPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbDbInstancePlanPlanConfig {
    pause?: outputs.GpdbDbInstancePlanPlanConfigPause;
    resume?: outputs.GpdbDbInstancePlanPlanConfigResume;
    scaleIn?: outputs.GpdbDbInstancePlanPlanConfigScaleIn;
    scaleOut?: outputs.GpdbDbInstancePlanPlanConfigScaleOut;
}

export interface GpdbDbInstancePlanPlanConfigPause {
    executeTime: string;
    planCronTime?: string;
}

export interface GpdbDbInstancePlanPlanConfigResume {
    executeTime: string;
    planCronTime?: string;
}

export interface GpdbDbInstancePlanPlanConfigScaleIn {
    executeTime: string;
    planCronTime?: string;
    segmentNodeNum?: string;
}

export interface GpdbDbInstancePlanPlanConfigScaleOut {
    executeTime: string;
    planCronTime?: string;
    segmentNodeNum?: string;
}

export interface GpdbDbInstancePlanTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbDbResourceGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbElasticInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbExternalDataServiceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbInstanceIpWhitelist {
    ipGroupAttribute: string;
    ipGroupName: string;
    securityIpList: string;
}

export interface GpdbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbRemoteAdbDataSourceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbStreamingDataServiceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GpdbStreamingDataSourceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GraphDatabaseDbInstanceDbInstanceIpArray {
    dbInstanceIpArrayAttribute?: string;
    dbInstanceIpArrayName?: string;
    securityIps?: string;
}

export interface GraphDatabaseDbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HavipAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HavipTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbaseInstanceSlbConnAddr {
    connAddr: string;
    connAddrPort: string;
    netType: string;
}

export interface HbaseInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbaseInstanceUiProxyConnAddr {
    connAddr: string;
    connAddrPort: string;
    netType: string;
}

export interface HbaseInstanceZkConnAddr {
    connAddr: string;
    connAddrPort: string;
    netType: string;
}

export interface HbrEcsBackupClientTimeouts {
    create?: string;
}

export interface HbrHanaBackupClientTimeouts {
    create?: string;
    delete?: string;
}

export interface HbrHanaBackupPlanTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbrHanaInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbrOtsBackupPlanOtsDetail {
    tableNames?: string[];
}

export interface HbrOtsBackupPlanRule {
    backupType?: string;
    disabled?: boolean;
    retention?: string;
    ruleName?: string;
    schedule?: string;
}

export interface HbrPolicyBindingAdvancedOptions {
    udmDetail?: outputs.HbrPolicyBindingAdvancedOptionsUdmDetail;
}

export interface HbrPolicyBindingAdvancedOptionsUdmDetail {
    destinationKmsKeyId?: string;
    diskIdLists?: string[];
    excludeDiskIdLists?: string[];
}

export interface HbrPolicyBindingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbrPolicyRule {
    archiveDays: number;
    backupType?: string;
    keepLatestSnapshots?: number;
    replicationRegionId?: string;
    retention?: number;
    retentionRules?: outputs.HbrPolicyRuleRetentionRule[];
    ruleId: string;
    ruleType: string;
    schedule?: string;
    vaultId?: string;
}

export interface HbrPolicyRuleRetentionRule {
    advancedRetentionType?: string;
    retention?: number;
}

export interface HbrPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HbrRestoreJobOtsDetail {
    overwriteExisting: boolean;
}

export interface HbrRestoreJobTimeouts {
    create?: string;
}

export interface HbrServerBackupPlanDetail {
    appConsistent: boolean;
    destinationRegionId?: string;
    destinationRetention?: number;
    diskIdLists?: string[];
    doCopy?: boolean;
    enableFsFreeze?: boolean;
    postScriptPath?: string;
    preScriptPath?: string;
    snapshotGroup: boolean;
    timeoutInSeconds?: number;
}

export interface HbrVaultTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface HologramInstanceEndpoint {
    alternativeEndpoints: string;
    enabled: boolean;
    endpoint: string;
    type: string;
    vpcId: string;
    vpcInstanceId: string;
    vswitchId: string;
}

export interface HologramInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ImageCopyTimeouts {
    create?: string;
    delete?: string;
}

export interface ImageDiskDeviceMapping {
    device: string;
    diskType: string;
    format: string;
    importOssBucket: string;
    importOssObject: string;
    progress: string;
    remainTime: number;
    size: number;
    snapshotId: string;
}

export interface ImageExportTimeouts {
    create?: string;
}

export interface ImageFeatures {
    nvmeSupport: string;
}

export interface ImageImportDiskDeviceMapping {
    device: string;
    diskImageSize?: number;
    format: string;
    ossBucket?: string;
    ossObject?: string;
}

export interface ImageImportTimeouts {
    create?: string;
    delete?: string;
}

export interface ImageTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ImpAppTemplateConfigList {
    key: string;
    value: string;
}

export interface ImsOidcProviderTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface InstanceDataDisk {
    autoSnapshotPolicyId?: string;
    category?: string;
    deleteWithInstance?: boolean;
    description?: string;
    device?: string;
    encrypted?: boolean;
    kmsKeyId?: string;
    name?: string;
    performanceLevel: string;
    size: number;
    snapshotId?: string;
}

export interface InstanceMaintenanceTime {
    endTime?: string;
    startTime?: string;
}

export interface InstanceNetworkInterface {
    networkCardIndex: number;
    networkInterfaceId: string;
    networkInterfaceTrafficMode: string;
    queuePairNumber: number;
    securityGroupIds: string[];
    vswitchId: string;
}

export interface InstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KeyPairTimeouts {
    delete?: string;
}

export interface KmsApplicationAccessPointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsClientKeyTimeouts {
    create?: string;
    delete?: string;
}

export interface KmsInstanceBindVpc {
    regionId?: string;
    vpcId?: string;
    vpcOwnerId?: number;
    vswitchId?: string;
}

export interface KmsInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsKeyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsNetworkRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KmsSecretTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KvstoreAccountTimeouts {
    create?: string;
    update?: string;
}

export interface KvstoreAuditLogConfigTimeouts {
    create?: string;
    update?: string;
}

export interface KvstoreBackupPolicyTimeouts {
    update?: string;
}

export interface KvstoreConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface KvstoreInstanceParameter {
    /**
     * @deprecated Deprecated
     */
    name?: string;
    /**
     * @deprecated Deprecated
     */
    value?: string;
}

export interface KvstoreInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LaunchTemplateDataDisk {
    category?: string;
    deleteWithInstance?: boolean;
    description?: string;
    encrypted?: boolean;
    name?: string;
    performanceLevel?: string;
    size?: number;
    snapshotId?: string;
}

export interface LaunchTemplateNetworkInterfaces {
    description?: string;
    name?: string;
    primaryIp?: string;
    securityGroupId?: string;
    vswitchId?: string;
}

export interface LaunchTemplateSystemDisk {
    category: string;
    deleteWithInstance?: boolean;
    description: string;
    encrypted?: boolean;
    iops?: string;
    name: string;
    performanceLevel: string;
    size: number;
}

export interface LindormInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogAlertAnnotation {
    key: string;
    value: string;
}

export interface LogAlertGroupConfiguration {
    fields?: string[];
    type: string;
}

export interface LogAlertJoinConfiguration {
    condition: string;
    type: string;
}

export interface LogAlertLabel {
    key: string;
    value: string;
}

export interface LogAlertNotificationList {
    content: string;
    emailLists?: string[];
    mobileLists?: string[];
    serviceUri?: string;
    type: string;
}

export interface LogAlertPolicyConfiguration {
    actionPolicyId?: string;
    alertPolicyId: string;
    repeatInterval: string;
}

export interface LogAlertQueryList {
    chartTitle?: string;
    dashboardId?: string;
    end: string;
    /**
     * @deprecated Deprecated
     */
    logstore?: string;
    powerSqlMode?: string;
    project?: string;
    query: string;
    region?: string;
    roleArn?: string;
    start: string;
    store?: string;
    storeType?: string;
    timeSpanType?: string;
}

export interface LogAlertSchedule {
    cronExpression?: string;
    dayOfWeek?: number;
    delay?: number;
    hour?: number;
    interval?: string;
    runImmediately?: boolean;
    timeZone?: string;
    type: string;
}

export interface LogAlertSeverityConfiguration {
    evalCondition: {[key: string]: string};
    severity: number;
}

export interface LogAlertTemplateConfiguration {
    annotations?: {[key: string]: string};
    id: string;
    lang?: string;
    tokens?: {[key: string]: string};
    type: string;
}

export interface LogEtlEtlSink {
    accessKeyId?: string;
    accessKeySecret?: string;
    endpoint: string;
    kmsEncryptedAccessKeyId?: string;
    kmsEncryptedAccessKeySecret?: string;
    logstore: string;
    name: string;
    project: string;
    roleArn?: string;
    type?: string;
}

export interface LogEtlTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogIngestionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogOssExportConfigColumn {
    name: string;
    type: string;
}

export interface LogOssExportTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogOssShipperParquetConfig {
    name: string;
    type: string;
}

export interface LogOssShipperTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LogStoreEncryptConf {
    enable: boolean;
    encryptType: string;
    userCmkInfo?: outputs.LogStoreEncryptConfUserCmkInfo;
}

export interface LogStoreEncryptConfUserCmkInfo {
    arn: string;
    cmkKeyId: string;
    regionId: string;
}

export interface LogStoreIndexFieldSearch {
    alias?: string;
    caseSensitive?: boolean;
    enableAnalytics?: boolean;
    includeChinese?: boolean;
    jsonKeys?: outputs.LogStoreIndexFieldSearchJsonKey[];
    name: string;
    token?: string;
    type?: string;
}

export interface LogStoreIndexFieldSearchJsonKey {
    alias?: string;
    docValue?: boolean;
    name: string;
    type?: string;
}

export interface LogStoreIndexFullText {
    caseSensitive?: boolean;
    includeChinese?: boolean;
    token?: string;
}

export interface LogStoreShard {
    beginKey: string;
    endKey: string;
    id: number;
    status: string;
}

export interface LogStoreTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MaxcomputeProjectIpWhiteList {
    ipList?: string;
    vpcIpList?: string;
}

export interface MaxcomputeProjectProperties {
    allowFullScan?: boolean;
    enableDecimal2?: boolean;
    encryption?: outputs.MaxcomputeProjectPropertiesEncryption;
    retentionDays?: number;
    sqlMeteringMax?: string;
    tableLifecycle?: outputs.MaxcomputeProjectPropertiesTableLifecycle;
    timezone: string;
    typeSystem?: string;
}

export interface MaxcomputeProjectPropertiesEncryption {
    algorithm?: string;
    enable?: boolean;
    key?: string;
}

export interface MaxcomputeProjectPropertiesTableLifecycle {
    type: string;
    value: string;
}

export interface MaxcomputeProjectSecurityProperties {
    enableDownloadPrivilege?: boolean;
    labelSecurity?: boolean;
    objectCreatorHasAccessPermission?: boolean;
    objectCreatorHasGrantPermission?: boolean;
    projectProtection?: outputs.MaxcomputeProjectSecurityPropertiesProjectProtection;
    usingAcl?: boolean;
    usingPolicy?: boolean;
}

export interface MaxcomputeProjectSecurityPropertiesProjectProtection {
    exceptionPolicy?: string;
    protected?: boolean;
}

export interface MaxcomputeProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MessageServiceQueueTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MessageServiceSubscriptionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MessageServiceTopicTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MongodbAccountTimeouts {
    create?: string;
    update?: string;
}

export interface MongodbAuditPolicyTimeouts {
    create?: string;
    update?: string;
}

export interface MongodbInstanceParameter {
    name: string;
    value: string;
}

export interface MongodbInstanceReplicaSet {
    connectionDomain: string;
    connectionPort: string;
    networkType: string;
    replicaSetRole: string;
    vpcCloudInstanceId: string;
    vpcId: string;
    vswitchId: string;
}

export interface MongodbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MongodbServerlessInstanceSecurityIpGroup {
    securityIpGroupAttribute?: string;
    securityIpGroupName?: string;
    securityIpList?: string;
}

export interface MongodbServerlessInstanceTimeouts {
    create?: string;
    update?: string;
}

export interface MongodbShardingInstanceConfigServerList {
    connectString: string;
    maxConnections: number;
    maxIops: number;
    nodeClass: string;
    nodeDescription: string;
    nodeId: string;
    nodeStorage: number;
    port: number;
}

export interface MongodbShardingInstanceMongoList {
    connectString: string;
    nodeClass: string;
    nodeId: string;
    port: number;
}

export interface MongodbShardingInstanceShardList {
    nodeClass: string;
    nodeId: string;
    nodeStorage: number;
    readonlyReplicas: number;
}

export interface MongodbShardingInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MongodbShardingNetworkPrivateAddressNetworkAddress {
    expiredTime: string;
    ipAddress: string;
    networkAddress: string;
    networkType: string;
    nodeId: string;
    nodeType: string;
    port: string;
    role: string;
    vpcId: string;
    vswitchId: string;
}

export interface MongodbShardingNetworkPublicAddressNetworkAddress {
    expiredTime: string;
    ipAddress: string;
    networkAddress: string;
    networkType: string;
    nodeId: string;
    nodeType: string;
    port: string;
    role: string;
    vpcId: string;
    vswitchId: string;
}

export interface MongodbShardingNetworkPublicAddressTimeouts {
    create?: string;
    delete?: string;
}

export interface MseClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MseEngineNamespaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MseGatewaySlbList {
    associateId: string;
    gatewaySlbMode: string;
    gatewaySlbStatus: string;
    gmtCreate: string;
    slbId: string;
    slbIp: string;
    slbPort: string;
    type: string;
}

export interface MseGatewayTimeouts {
    create?: string;
    delete?: string;
}

export interface MseZnodeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasAccessGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasAccessPointPosixUser {
    posixGroupId: number;
    posixSecondaryGroupIds: number[];
    posixUserId: number;
}

export interface NasAccessPointRootPathPermission {
    ownerGroupId: number;
    ownerUserId: number;
    permission?: string;
}

export interface NasAccessPointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasAccessRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasAutoSnapshotPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasDataFlowTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasFileSystemTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasFilesetTimeouts {
    create?: string;
    delete?: string;
}

export interface NasMountTargetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NasSnapshotTimeouts {
    create?: string;
    delete?: string;
}

export interface NatGatewayBandwidthPackage {
    bandwidth: number;
    ipCount: number;
    publicIpAddresses: string;
    zone: string;
}

export interface NatGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NetworkAclAttachmentResource {
    resourceId: string;
    resourceType: string;
}

export interface NetworkAclEgressAclEntry {
    description?: string;
    destinationCidrIp?: string;
    entryType: string;
    ipVersion: string;
    networkAclEntryName?: string;
    policy?: string;
    port?: string;
    protocol?: string;
}

export interface NetworkAclEntriesEgress {
    description: string;
    destinationCidrIp: string;
    entryType: string;
    name: string;
    policy: string;
    port: string;
    protocol: string;
}

export interface NetworkAclEntriesIngress {
    description: string;
    entryType: string;
    name: string;
    policy: string;
    port: string;
    protocol: string;
    sourceCidrIp: string;
}

export interface NetworkAclIngressAclEntry {
    description?: string;
    entryType: string;
    ipVersion: string;
    networkAclEntryName?: string;
    policy?: string;
    port?: string;
    protocol?: string;
    sourceCidrIp?: string;
}

export interface NetworkAclResource {
    resourceId: string;
    resourceType: string;
    status: string;
}

export interface NetworkAclTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NetworkInterfaceAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface NetworkInterfaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbListenerAdditionalCertificateAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbListenerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbLoadBalancerDeletionProtectionConfig {
    enabled: boolean;
    enabledTime: string;
    reason: string;
}

export interface NlbLoadBalancerModificationProtectionConfig {
    enabledTime: string;
    reason: string;
    status: string;
}

export interface NlbLoadBalancerSecurityGroupAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbLoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbLoadBalancerZoneMapping {
    allocationId: string;
    eniId: string;
    ipv6Address: string;
    privateIpv4Address: string;
    publicIpv4Address: string;
    status: string;
    vswitchId: string;
    zoneId: string;
}

export interface NlbLoadbalancerCommonBandwidthPackageAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface NlbSecurityPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbServerGroupHealthCheck {
    healthCheckConnectPort: number;
    healthCheckConnectTimeout: number;
    healthCheckDomain: string;
    healthCheckEnabled: boolean;
    healthCheckHttpCodes: string[];
    healthCheckInterval: number;
    healthCheckType: string;
    healthCheckUrl: string;
    healthyThreshold: number;
    httpCheckMethod?: string;
    unhealthyThreshold: number;
}

export interface NlbServerGroupServerAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NlbServerGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OceanBaseInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OnsGroupTimeouts {
    create?: string;
    delete?: string;
}

export interface OnsInstanceTimeouts {
    create?: string;
    delete?: string;
}

export interface OnsTopicTimeouts {
    create?: string;
    delete?: string;
}

export interface OosDefaultPatchBaselineTimeouts {
    create?: string;
    delete?: string;
}

export interface OosExecutionTimeouts {
    create?: string;
}

export interface OosPatchBaselineTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OpenSearchAppGroupOrder {
    autoRenew?: boolean;
    duration?: number;
    pricingCycle?: string;
}

export interface OpenSearchAppGroupQuota {
    computeResource: number;
    docSize: number;
    qps?: number;
    spec: string;
}

export interface OssAccountPublicAccessBlockTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketAccessMonitor {
    status: string;
}

export interface OssBucketAccessMonitorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketAclTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketCorsCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins?: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface OssBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface OssBucketCorsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketDataRedundancyTransitionTimeouts {
    create?: string;
    delete?: string;
}

export interface OssBucketHttpsConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketLifecycleRule {
    abortMultipartUploads?: outputs.OssBucketLifecycleRuleAbortMultipartUpload[];
    enabled: boolean;
    expirations?: outputs.OssBucketLifecycleRuleExpiration[];
    filter?: outputs.OssBucketLifecycleRuleFilter;
    id: string;
    noncurrentVersionExpirations?: outputs.OssBucketLifecycleRuleNoncurrentVersionExpiration[];
    noncurrentVersionTransitions?: outputs.OssBucketLifecycleRuleNoncurrentVersionTransition[];
    prefix?: string;
    tags?: {[key: string]: string};
    transitions?: outputs.OssBucketLifecycleRuleTransition[];
}

export interface OssBucketLifecycleRuleAbortMultipartUpload {
    createdBeforeDate?: string;
    days?: number;
}

export interface OssBucketLifecycleRuleExpiration {
    createdBeforeDate?: string;
    date?: string;
    days?: number;
    expiredObjectDeleteMarker?: boolean;
}

export interface OssBucketLifecycleRuleFilter {
    not?: outputs.OssBucketLifecycleRuleFilterNot;
    objectSizeGreaterThan?: number;
    objectSizeLessThan?: number;
}

export interface OssBucketLifecycleRuleFilterNot {
    prefix?: string;
    tag?: outputs.OssBucketLifecycleRuleFilterNotTag;
}

export interface OssBucketLifecycleRuleFilterNotTag {
    key: string;
    value: string;
}

export interface OssBucketLifecycleRuleNoncurrentVersionExpiration {
    days: number;
}

export interface OssBucketLifecycleRuleNoncurrentVersionTransition {
    days: number;
    isAccessTime?: boolean;
    returnToStdWhenVisit?: boolean;
    storageClass: string;
}

export interface OssBucketLifecycleRuleTransition {
    createdBeforeDate?: string;
    days?: number;
    isAccessTime?: boolean;
    returnToStdWhenVisit?: boolean;
    storageClass: string;
}

export interface OssBucketLogging {
    targetBucket: string;
    targetPrefix?: string;
}

export interface OssBucketLoggingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketMetaQueryTimeouts {
    create?: string;
    delete?: string;
}

export interface OssBucketPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketPublicAccessBlockTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketRefererConfig {
    allowEmpty: boolean;
    referers: string[];
}

export interface OssBucketRefererTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketReplicationDestination {
    bucket: string;
    location: string;
    transferType?: string;
}

export interface OssBucketReplicationEncryptionConfiguration {
    replicaKmsKeyId: string;
}

export interface OssBucketReplicationPrefixSet {
    prefixes: string[];
}

export interface OssBucketReplicationProgress {
    historicalObject: string;
    newObject: string;
}

export interface OssBucketReplicationSourceSelectionCriteria {
    sseKmsEncryptedObjects?: outputs.OssBucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjects;
}

export interface OssBucketReplicationSourceSelectionCriteriaSseKmsEncryptedObjects {
    status?: string;
}

export interface OssBucketReplicationTimeouts {
    delete?: string;
}

export interface OssBucketRequestPaymentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketServerSideEncryptionRule {
    kmsMasterKeyId?: string;
    sseAlgorithm: string;
}

export interface OssBucketServerSideEncryptionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketTransferAcceleration {
    enabled: boolean;
}

export interface OssBucketTransferAccelerationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketUserDefinedLogFieldsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketVersioning {
    status: string;
}

export interface OssBucketVersioningTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OssBucketWebsite {
    errorDocument?: string;
    indexDocument: string;
}

export interface OtsSearchIndexSchema {
    fieldSchemas: outputs.OtsSearchIndexSchemaFieldSchema[];
    indexSettings?: outputs.OtsSearchIndexSchemaIndexSetting[];
    indexSorts?: outputs.OtsSearchIndexSchemaIndexSort[];
}

export interface OtsSearchIndexSchemaFieldSchema {
    analyzer?: string;
    enableSortAndAgg?: boolean;
    fieldName: string;
    fieldType: string;
    index?: boolean;
    isArray?: boolean;
    store?: boolean;
}

export interface OtsSearchIndexSchemaIndexSetting {
    routingFields?: string[];
}

export interface OtsSearchIndexSchemaIndexSort {
    sorters: outputs.OtsSearchIndexSchemaIndexSortSorter[];
}

export interface OtsSearchIndexSchemaIndexSortSorter {
    fieldName?: string;
    mode?: string;
    order?: string;
    sorterType?: string;
}

export interface OtsTableDefinedColumn {
    name: string;
    type: string;
}

export interface OtsTablePrimaryKey {
    name: string;
    type: string;
}

export interface OtsTunnelChannel {
    channelId: string;
    channelRpo: number;
    channelStatus: string;
    channelType: string;
    clientId: string;
}

export interface OtsTunnelTimeouts {
    create?: string;
    delete?: string;
}

export interface PolardbClusterDbClusterIpArray {
    dbClusterIpArrayName?: string;
    modifyMode?: string;
    securityIps?: string[];
}

export interface PolardbClusterDbRevisionVersionList {
    releaseNote: string;
    releaseType: string;
    revisionVersionCode: string;
    revisionVersionName: string;
}

export interface PolardbClusterParameter {
    name: string;
    value: string;
}

export interface PolardbClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PolardbGlobalDatabaseNetworkTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PolardbParameterGroupParameter {
    paramName: string;
    paramValue: string;
}

export interface PolardbParameterGroupTimeouts {
    create?: string;
    delete?: string;
}

export interface PrivatelinkVpcEndpointConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkVpcEndpointServiceResourceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkVpcEndpointServiceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkVpcEndpointServiceUserTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkVpcEndpointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivatelinkVpcEndpointZoneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PvtzEndpointIpConfig {
    cidrBlock: string;
    ip: string;
    vswitchId: string;
    zoneId: string;
}

export interface PvtzEndpointTimeouts {
    create?: string;
    update?: string;
}

export interface PvtzRuleAttachmentVpc {
    regionId: string;
    vpcId: string;
}

export interface PvtzRuleForwardIp {
    ip: string;
    port: number;
}

export interface PvtzUserVpcAuthorizationTimeouts {
    create?: string;
    delete?: string;
}

export interface PvtzZoneAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PvtzZoneAttachmentVpc {
    regionId: string;
    vpcId: string;
}

export interface PvtzZoneRecordTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PvtzZoneTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PvtzZoneUserInfo {
    regionIds?: string[];
    userId?: string;
}

export interface QuotasApplicationInfoDimension {
    key?: string;
    value?: string;
}

export interface QuotasApplicationInfoTimeouts {
    create?: string;
    delete?: string;
}

export interface QuotasQuotaAlarmQuotaDimension {
    key?: string;
    value?: string;
}

export interface QuotasQuotaAlarmTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface QuotasQuotaApplicationDimension {
    key?: string;
    value?: string;
}

export interface QuotasQuotaApplicationTimeouts {
    create?: string;
    delete?: string;
}

export interface QuotasTemplateApplicationsDimension {
    key?: string;
    value?: string;
}

export interface QuotasTemplateApplicationsQuotaApplicationDetail {
    aliyunUid: string;
    applicationId: string;
    approveValue: number;
    auditReason: string;
    dimensions: {[key: string]: string};
    envLanguage: string;
    noticeType: number;
    periods: outputs.QuotasTemplateApplicationsQuotaApplicationDetailPeriod[];
    quotaArn: string;
    quotaDescription: string;
    quotaName: string;
    quotaUnit: string;
    reason: string;
    status: string;
}

export interface QuotasTemplateApplicationsQuotaApplicationDetailPeriod {
    periodUnit: string;
    periodValue: number;
}

export interface QuotasTemplateApplicationsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface QuotasTemplateQuotaDimension {
    key?: string;
    value?: string;
}

export interface QuotasTemplateQuotaTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RamPolicyStatement {
    actions: string[];
    effect: string;
    resources: string[];
}

export interface RamPolicyTimeouts {
    delete?: string;
}

export interface RamRolePolicyAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface RamRoleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RamUserTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsBackupTimeouts {
    create?: string;
    delete?: string;
}

export interface RdsCloneDbInstanceParameter {
    name: string;
    value: string;
}

export interface RdsCloneDbInstancePgHbaConf {
    address: string;
    database: string;
    mask?: string;
    method: string;
    option?: string;
    priorityId: number;
    type: string;
    user: string;
}

export interface RdsCloneDbInstanceServerlessConfig {
    autoPause?: boolean;
    maxCapacity: number;
    minCapacity: number;
    switchForce?: boolean;
}

export interface RdsCloneDbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsDbInstanceEndpointAddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsDbInstanceEndpointNodeItem {
    nodeId: string;
    weight: number;
}

export interface RdsDbInstanceEndpointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsDbNodeTimeouts {
    create?: string;
    delete?: string;
}

export interface RdsDbProxyReadOnlyInstanceWeight {
    instanceId: string;
    weight: string;
}

export interface RdsDbProxyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsDdrInstanceParameter {
    name: string;
    value: string;
}

export interface RdsDdrInstancePgHbaConf {
    address: string;
    database: string;
    mask: string;
    method: string;
    option: string;
    priorityId: number;
    type: string;
    user: string;
}

export interface RdsDdrInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsInstanceCrossBackupPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RdsParameterGroupParamDetail {
    paramName: string;
    paramValue: string;
}

export interface RdsUpgradeDbInstanceParameter {
    name: string;
    value: string;
}

export interface RdsUpgradeDbInstancePgHbaConf {
    address: string;
    database: string;
    mask?: string;
    method: string;
    option?: string;
    priorityId: number;
    type: string;
    user: string;
}

export interface RdsUpgradeDbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RealtimeComputeVvpInstanceResourceSpec {
    cpu: number;
    memoryGb: number;
}

export interface RealtimeComputeVvpInstanceStorage {
    oss: outputs.RealtimeComputeVvpInstanceStorageOss;
}

export interface RealtimeComputeVvpInstanceStorageOss {
    bucket: string;
}

export interface RealtimeComputeVvpInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RedisTairInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ReservedInstanceOperationLock {
    lockReason: string;
}

export interface ReservedInstanceTimeouts {
    create?: string;
    update?: string;
}

export interface ResourceManagerAccountTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ResourceManagerDelegatedAdministratorTimeouts {
    create?: string;
    delete?: string;
}

export interface ResourceManagerResourceDirectoryTimeouts {
    update?: string;
}

export interface ResourceManagerResourceGroupRegionStatus {
    regionId: string;
    status: string;
}

export interface ResourceManagerResourceGroupTimeouts {
    create?: string;
}

export interface ResourceManagerResourceShareTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ResourceManagerSavedQueryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ResourceManagerSharedResourceTimeouts {
    create?: string;
    delete?: string;
}

export interface ResourceManagerSharedTargetTimeouts {
    create?: string;
    delete?: string;
}

export interface RocketmqConsumerGroupConsumeRetryPolicy {
    maxRetryTimes?: number;
    retryPolicy?: string;
}

export interface RocketmqConsumerGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RocketmqInstanceNetworkInfo {
    endpoints: outputs.RocketmqInstanceNetworkInfoEndpoint[];
    internetInfo: outputs.RocketmqInstanceNetworkInfoInternetInfo;
    vpcInfo: outputs.RocketmqInstanceNetworkInfoVpcInfo;
}

export interface RocketmqInstanceNetworkInfoEndpoint {
    endpointType: string;
    endpointUrl: string;
    ipWhiteLists: string[];
}

export interface RocketmqInstanceNetworkInfoInternetInfo {
    flowOutBandwidth?: number;
    flowOutType: string;
    internetSpec: string;
    ipWhitelists?: string[];
}

export interface RocketmqInstanceNetworkInfoVpcInfo {
    vpcId: string;
    vswitchId: string;
}

export interface RocketmqInstanceProductInfo {
    autoScaling?: boolean;
    messageRetentionTime?: number;
    msgProcessSpec: string;
    sendReceiveRatio?: number;
    supportAutoScaling: boolean;
}

export interface RocketmqInstanceSoftware {
    maintainTime: string;
    softwareVersion: string;
    upgradeMethod: string;
}

export interface RocketmqInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RocketmqTopicTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RosChangeSetParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface RosChangeSetTimeouts {
    create?: string;
}

export interface RosStackGroupParameter {
    parameterKey?: string;
    parameterValue?: string;
}

export interface RosStackGroupTimeouts {
    create?: string;
    update?: string;
}

export interface RosStackInstanceParameterOverride {
    parameterKey?: string;
    parameterValue?: string;
}

export interface RosStackInstanceTimeouts {
    create?: string;
}

export interface RosStackParameter {
    parameterKey?: string;
    parameterValue: string;
}

export interface RosStackTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RosTemplateScratchPreferenceParameter {
    parameterKey: string;
    parameterValue: string;
}

export interface RosTemplateScratchSourceResource {
    resourceId: string;
    resourceType: string;
}

export interface RosTemplateScratchSourceResourceGroup {
    resourceGroupId: string;
    resourceTypeFilters?: string[];
}

export interface RosTemplateScratchSourceTag {
    resourceTags: {[key: string]: string};
    resourceTypeFilters?: string[];
}

export interface RosTemplateScratchTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RosTemplateTimeouts {
    create?: string;
}

export interface RouteTableAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface RouteTableTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SaeApplicationConfigMapMountDescV2 {
    configMapId: string;
    key: string;
    mountPath: string;
}

export interface SaeApplicationCustomHostAliasV2 {
    hostName: string;
    ip: string;
}

export interface SaeApplicationKafkaConfigs {
    kafkaConfigs?: outputs.SaeApplicationKafkaConfigsKafkaConfig[];
    kafkaEndpoint?: string;
    kafkaInstanceId?: string;
}

export interface SaeApplicationKafkaConfigsKafkaConfig {
    kafkaTopic?: string;
    logDir?: string;
    logType?: string;
}

export interface SaeApplicationLivenessV2 {
    exec?: outputs.SaeApplicationLivenessV2Exec;
    httpGet?: outputs.SaeApplicationLivenessV2HttpGet;
    initialDelaySeconds: number;
    periodSeconds: number;
    tcpSocket?: outputs.SaeApplicationLivenessV2TcpSocket;
    timeoutSeconds: number;
}

export interface SaeApplicationLivenessV2Exec {
    commands: string[];
}

export interface SaeApplicationLivenessV2HttpGet {
    isContainKeyWord: boolean;
    keyWord: string;
    path: string;
    port: number;
    scheme: string;
}

export interface SaeApplicationLivenessV2TcpSocket {
    port: number;
}

export interface SaeApplicationNasConfig {
    mountDomain?: string;
    mountPath?: string;
    nasId?: string;
    nasPath?: string;
    readOnly?: boolean;
}

export interface SaeApplicationOssMountDescsV2 {
    bucketName: string;
    bucketPath: string;
    mountPath: string;
    readOnly: boolean;
}

export interface SaeApplicationPostStartV2 {
    exec?: outputs.SaeApplicationPostStartV2Exec;
}

export interface SaeApplicationPostStartV2Exec {
    commands: string[];
}

export interface SaeApplicationPreStopV2 {
    exec?: outputs.SaeApplicationPreStopV2Exec;
}

export interface SaeApplicationPreStopV2Exec {
    commands: string[];
}

export interface SaeApplicationPvtzDiscoverySvc {
    enable?: boolean;
    namespaceId?: string;
    portProtocols?: outputs.SaeApplicationPvtzDiscoverySvcPortProtocol[];
    serviceName?: string;
}

export interface SaeApplicationPvtzDiscoverySvcPortProtocol {
    port?: number;
    protocol?: string;
}

export interface SaeApplicationReadinessV2 {
    exec?: outputs.SaeApplicationReadinessV2Exec;
    httpGet?: outputs.SaeApplicationReadinessV2HttpGet;
    initialDelaySeconds: number;
    periodSeconds: number;
    tcpSocket?: outputs.SaeApplicationReadinessV2TcpSocket;
    timeoutSeconds: number;
}

export interface SaeApplicationReadinessV2Exec {
    commands: string[];
}

export interface SaeApplicationReadinessV2HttpGet {
    isContainKeyWord: boolean;
    keyWord: string;
    path: string;
    port: number;
    scheme: string;
}

export interface SaeApplicationReadinessV2TcpSocket {
    port: number;
}

export interface SaeApplicationScalingRuleScalingRuleMetric {
    maxReplicas?: number;
    metrics?: outputs.SaeApplicationScalingRuleScalingRuleMetricMetric[];
    minReplicas?: number;
    scaleDownRules?: outputs.SaeApplicationScalingRuleScalingRuleMetricScaleDownRules;
    scaleUpRules?: outputs.SaeApplicationScalingRuleScalingRuleMetricScaleUpRules;
}

export interface SaeApplicationScalingRuleScalingRuleMetricMetric {
    metricTargetAverageUtilization?: number;
    metricType?: string;
    slbId?: string;
    slbLogStore?: string;
    slbProject?: string;
    vport?: string;
}

export interface SaeApplicationScalingRuleScalingRuleMetricScaleDownRules {
    disabled?: boolean;
    stabilizationWindowSeconds?: number;
    step?: number;
}

export interface SaeApplicationScalingRuleScalingRuleMetricScaleUpRules {
    disabled?: boolean;
    stabilizationWindowSeconds?: number;
    step?: number;
}

export interface SaeApplicationScalingRuleScalingRuleTimer {
    beginDate?: string;
    endDate?: string;
    period?: string;
    schedules?: outputs.SaeApplicationScalingRuleScalingRuleTimerSchedule[];
}

export interface SaeApplicationScalingRuleScalingRuleTimerSchedule {
    atTime?: string;
    maxReplicas?: number;
    minReplicas?: number;
    targetReplicas?: number;
}

export interface SaeApplicationTomcatConfigV2 {
    contextPath: string;
    maxThreads: number;
    port: number;
    uriEncoding: string;
    useBodyEncodingForUri: string;
}

export interface SaeApplicationUpdateStrategyV2 {
    batchUpdate?: outputs.SaeApplicationUpdateStrategyV2BatchUpdate;
    type: string;
}

export interface SaeApplicationUpdateStrategyV2BatchUpdate {
    batch: number;
    batchWaitTime: number;
    releaseType: string;
}

export interface SaeGreyTagRouteDubboRule {
    condition?: string;
    group?: string;
    items?: outputs.SaeGreyTagRouteDubboRuleItem[];
    methodName?: string;
    serviceName?: string;
    version?: string;
}

export interface SaeGreyTagRouteDubboRuleItem {
    cond?: string;
    expr?: string;
    index?: number;
    operator?: string;
    value?: string;
}

export interface SaeGreyTagRouteScRule {
    condition?: string;
    items?: outputs.SaeGreyTagRouteScRuleItem[];
    path?: string;
}

export interface SaeGreyTagRouteScRuleItem {
    cond?: string;
    name?: string;
    operator?: string;
    type?: string;
    value?: string;
}

export interface SaeGreyTagRouteTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SaeIngressDefaultRule {
    appId?: string;
    appName?: string;
    containerPort?: number;
}

export interface SaeIngressRule {
    appId: string;
    appName: string;
    backendProtocol?: string;
    containerPort: number;
    domain: string;
    path: string;
    rewritePath?: string;
}

export interface SaeLoadBalancerInternetInternet {
    httpsCertId?: string;
    port?: number;
    protocol?: string;
    targetPort?: number;
}

export interface SaeLoadBalancerIntranetIntranet {
    httpsCertId?: string;
    port?: number;
    protocol?: string;
    targetPort?: number;
}

export interface SaeNamespaceTimeouts {
    delete?: string;
}

export interface ScdnDomainCertInfo {
    certName?: string;
    certType?: string;
    sslPri?: string;
    sslProtocol?: string;
    sslPub?: string;
}

export interface ScdnDomainConfigFunctionArg {
    argName: string;
    argValue: string;
}

export interface ScdnDomainSource {
    content: string;
    enabled: string;
    port: number;
    priority: string;
    type: string;
}

export interface ScdnDomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SchedulerxNamespaceTimeouts {
    create?: string;
    update?: string;
}

export interface SecurityCenterGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecurityCenterServiceLinkedRoleTimeouts {
    create?: string;
    delete?: string;
}

export interface SecurityGroupTimeouts {
    delete?: string;
}

export interface SelectdbDbClusterDesiredParam {
    name?: string;
    value?: string;
}

export interface SelectdbDbClusterParamChangeLog {
    configId: number;
    gmtCreated: string;
    gmtModified: string;
    isApplied: boolean;
    name: string;
    newValue: string;
    oldValue: string;
}

export interface SelectdbDbClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SelectdbDbInstanceDesiredSecurityIpList {
    groupName?: string;
    securityIpList?: string;
}

export interface SelectdbDbInstanceInstanceNetInfo {
    connectionString: string;
    dbIp: string;
    netType: string;
    portLists: outputs.SelectdbDbInstanceInstanceNetInfoPortList[];
    vpcInstanceId: string;
    vswitchId: string;
}

export interface SelectdbDbInstanceInstanceNetInfoPortList {
    port: string;
    protocol: string;
}

export interface SelectdbDbInstanceSecurityIpList {
    groupName: string;
    groupTag: string;
    listNetType: string;
    securityIpList: string;
    securityIpType: string;
}

export interface SelectdbDbInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServiceCatalogPortfolioTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServiceCatalogProvisionedProductOutput {
    description: string;
    outputKey: string;
    outputValue: string;
}

export interface ServiceCatalogProvisionedProductParameter {
    parameterKey?: string;
    parameterValue?: string;
}

export interface ServiceCatalogProvisionedProductTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServiceMeshExtensionProviderTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServiceMeshServiceMeshExtraConfiguration {
    crAggregationEnabled?: boolean;
}

export interface ServiceMeshServiceMeshLoadBalancer {
    apiServerLoadbalancerId: string;
    apiServerPublicEip?: boolean;
    pilotPublicEip?: boolean;
    pilotPublicLoadbalancerId: string;
}

export interface ServiceMeshServiceMeshMeshConfig {
    accessLog?: outputs.ServiceMeshServiceMeshMeshConfigAccessLog;
    audit?: outputs.ServiceMeshServiceMeshMeshConfigAudit;
    controlPlaneLog?: outputs.ServiceMeshServiceMeshMeshConfigControlPlaneLog;
    customizedZipkin?: boolean;
    enableLocalityLb?: boolean;
    includeIpRanges: string;
    kiali?: outputs.ServiceMeshServiceMeshMeshConfigKiali;
    opa?: outputs.ServiceMeshServiceMeshMeshConfigOpa;
    outboundTrafficPolicy?: string;
    pilot?: outputs.ServiceMeshServiceMeshMeshConfigPilot;
    prometheuses: outputs.ServiceMeshServiceMeshMeshConfigPrometheus[];
    proxy?: outputs.ServiceMeshServiceMeshMeshConfigProxy;
    sidecarInjector?: outputs.ServiceMeshServiceMeshMeshConfigSidecarInjector;
    telemetry?: boolean;
    tracing?: boolean;
}

export interface ServiceMeshServiceMeshMeshConfigAccessLog {
    enabled?: boolean;
    gatewayEnabled?: boolean;
    gatewayLifecycle: number;
    project?: string;
    sidecarEnabled?: boolean;
    sidecarLifecycle: number;
}

export interface ServiceMeshServiceMeshMeshConfigAudit {
    enabled: boolean;
    project: string;
}

export interface ServiceMeshServiceMeshMeshConfigControlPlaneLog {
    enabled: boolean;
    logTtlInDay: number;
    project?: string;
}

export interface ServiceMeshServiceMeshMeshConfigKiali {
    enabled?: boolean;
    url: string;
}

export interface ServiceMeshServiceMeshMeshConfigOpa {
    enabled?: boolean;
    limitCpu?: string;
    limitMemory?: string;
    logLevel?: string;
    requestCpu?: string;
    requestMemory?: string;
}

export interface ServiceMeshServiceMeshMeshConfigPilot {
    http10Enabled?: boolean;
    traceSampling?: number;
}

export interface ServiceMeshServiceMeshMeshConfigPrometheus {
    externalUrl: string;
    useExternal: boolean;
}

export interface ServiceMeshServiceMeshMeshConfigProxy {
    clusterDomain: string;
    limitCpu?: string;
    limitMemory?: string;
    requestCpu?: string;
    requestMemory?: string;
}

export interface ServiceMeshServiceMeshMeshConfigSidecarInjector {
    autoInjectionPolicyEnabled?: boolean;
    enableNamespacesByDefault?: boolean;
    initCniConfiguration?: outputs.ServiceMeshServiceMeshMeshConfigSidecarInjectorInitCniConfiguration;
    limitCpu?: string;
    limitMemory?: string;
    requestCpu?: string;
    requestMemory?: string;
    sidecarInjectorWebhookAsYaml: string;
}

export interface ServiceMeshServiceMeshMeshConfigSidecarInjectorInitCniConfiguration {
    enabled?: boolean;
    excludeNamespaces?: string;
}

export interface ServiceMeshServiceMeshNetwork {
    securityGroupId: string;
    vpcId: string;
    vswitcheLists: string[];
}

export interface ServiceMeshServiceMeshTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServiceMeshUserPermissionPermission {
    isCustom: boolean;
    isRamRole: boolean;
    roleName: string;
    roleType: string;
    serviceMeshId: string;
}

export interface ServiceMeshUserPermissionTimeouts {
    create?: string;
    update?: string;
}

export interface SimpleApplicationServerInstanceTimeouts {
    create?: string;
    update?: string;
}

export interface SimpleApplicationServerSnapshotTimeouts {
    create?: string;
}

export interface SlbAclEntryAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface SlbAclEntryList {
    comment: string;
    entry: string;
}

export interface SlbBackendServerBackendServer {
    serverId: string;
    serverIp: string;
    type?: string;
    weight: number;
}

export interface SlbCaCertificateTimeouts {
    delete?: string;
}

export interface SlbListenerXForwardedFor {
    retriveClientIp: boolean;
    retriveSlbId?: boolean;
    retriveSlbIp?: boolean;
    retriveSlbProto?: boolean;
}

export interface SlbLoadBalancerTimeouts {
    create?: string;
    delete?: string;
}

export interface SlbMasterSlaveServerGroupServer {
    isBackup?: number;
    port: number;
    serverId: string;
    serverType?: string;
    type?: string;
    weight?: number;
}

export interface SlbRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SlbServerGroupServer {
    port: number;
    serverIds: string[];
    type?: string;
    weight?: number;
}

export interface SlbServerGroupServerAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface SlbTimeouts {
    create?: string;
    delete?: string;
}

export interface SlsAlertConfiguration {
    annotations?: outputs.SlsAlertConfigurationAnnotation[];
    autoAnnotation: boolean;
    conditionConfiguration?: outputs.SlsAlertConfigurationConditionConfiguration;
    dashboard?: string;
    groupConfiguration?: outputs.SlsAlertConfigurationGroupConfiguration;
    joinConfigurations?: outputs.SlsAlertConfigurationJoinConfiguration[];
    labels?: outputs.SlsAlertConfigurationLabel[];
    muteUntil?: number;
    noDataFire: boolean;
    noDataSeverity?: number;
    policyConfiguration?: outputs.SlsAlertConfigurationPolicyConfiguration;
    queryLists?: outputs.SlsAlertConfigurationQueryList[];
    sendResolved: boolean;
    severityConfigurations?: outputs.SlsAlertConfigurationSeverityConfiguration[];
    sinkAlerthub?: outputs.SlsAlertConfigurationSinkAlerthub;
    sinkCms?: outputs.SlsAlertConfigurationSinkCms;
    sinkEventStore?: outputs.SlsAlertConfigurationSinkEventStore;
    tags?: string[];
    templateConfiguration?: outputs.SlsAlertConfigurationTemplateConfiguration;
    threshold?: number;
    type: string;
    version?: string;
}

export interface SlsAlertConfigurationAnnotation {
    key?: string;
    value?: string;
}

export interface SlsAlertConfigurationConditionConfiguration {
    condition?: string;
    countCondition?: string;
}

export interface SlsAlertConfigurationGroupConfiguration {
    fields?: string[];
    type?: string;
}

export interface SlsAlertConfigurationJoinConfiguration {
    condition?: string;
    type?: string;
}

export interface SlsAlertConfigurationLabel {
    key?: string;
    value?: string;
}

export interface SlsAlertConfigurationPolicyConfiguration {
    actionPolicyId?: string;
    alertPolicyId?: string;
    repeatInterval?: string;
}

export interface SlsAlertConfigurationQueryList {
    chartTitle?: string;
    dashboardId?: string;
    end?: string;
    powerSqlMode?: string;
    project?: string;
    query?: string;
    region?: string;
    roleArn?: string;
    start?: string;
    store?: string;
    storeType?: string;
    timeSpanType?: string;
    ui?: string;
}

export interface SlsAlertConfigurationSeverityConfiguration {
    evalCondition?: outputs.SlsAlertConfigurationSeverityConfigurationEvalCondition;
    severity?: number;
}

export interface SlsAlertConfigurationSeverityConfigurationEvalCondition {
    condition?: string;
    countCondition?: string;
}

export interface SlsAlertConfigurationSinkAlerthub {
    enabled?: boolean;
}

export interface SlsAlertConfigurationSinkCms {
    enabled?: boolean;
}

export interface SlsAlertConfigurationSinkEventStore {
    enabled?: boolean;
    endpoint?: string;
    eventStore?: string;
    project?: string;
    roleArn?: string;
}

export interface SlsAlertConfigurationTemplateConfiguration {
    annotations?: {[key: string]: string};
    lang?: string;
    templateId?: string;
    tokens?: {[key: string]: string};
    type?: string;
    version?: string;
}

export interface SlsAlertSchedule {
    cronExpression?: string;
    delay?: number;
    interval?: string;
    runImmdiately?: boolean;
    timeZone?: string;
    type?: string;
}

export interface SlsAlertTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SlsScheduledSqlSchedule {
    cronExpression?: string;
    delay?: number;
    interval?: string;
    runImmediately?: boolean;
    timeZone?: string;
    type?: string;
}

export interface SlsScheduledSqlScheduledSqlConfiguration {
    dataFormat?: string;
    destEndpoint?: string;
    destLogstore?: string;
    destProject?: string;
    destRoleArn?: string;
    fromTime?: number;
    fromTimeExpr?: string;
    maxRetries?: number;
    maxRunTimeInSeconds?: number;
    parameters?: {[key: string]: string};
    resourcePool?: string;
    roleArn?: string;
    script?: string;
    sourceLogstore?: string;
    sqlType?: string;
    toTime?: number;
    toTimeExpr?: string;
}

export interface SlsScheduledSqlTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SmartagFlowLogTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SmsShortUrlTimeouts {
    create?: string;
    delete?: string;
}

export interface SnapshotPolicyTimeouts {
    create?: string;
    delete?: string;
}

export interface SnapshotTimeouts {
    create?: string;
    delete?: string;
}

export interface SnatEntryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SubnetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionBackupPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionClientFileProtectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionClientUserDefineRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionFileUploadLimitTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionHoneyPotTimeouts {
    delete?: string;
}

export interface ThreatDetectionHoneypotNodeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionHoneypotPresetMeta {
    burp: string;
    portraitOption?: boolean;
    trojanGit?: string;
}

export interface ThreatDetectionHoneypotPresetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionHoneypotProbeHoneypotBindList {
    bindPortLists?: outputs.ThreatDetectionHoneypotProbeHoneypotBindListBindPortList[];
    honeypotId?: string;
}

export interface ThreatDetectionHoneypotProbeHoneypotBindListBindPortList {
    bindPort: boolean;
    endPort: number;
    fixed: boolean;
    startPort: number;
    targetPort: number;
}

export interface ThreatDetectionHoneypotProbeTimeouts {
    create?: string;
    delete?: string;
}

export interface ThreatDetectionImageEventOperationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionMaliciousFileWhitelistConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionOssScanConfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ThreatDetectionSasTrailServiceTrail {
    config: string;
    updateTime: number;
}

export interface ThreatDetectionSasTrailTimeouts {
    create?: string;
    delete?: string;
}

export interface ThreatDetectionVulWhitelistTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TsdbInstanceTimeouts {
    create?: string;
    update?: string;
}

export interface VodDomainSource {
    sourceContent: string;
    sourcePort: string;
    sourcePriority: string;
    sourceType: string;
}

export interface VodEditingProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcBgpGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcBgpNetworkTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcBgpPeerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcDhcpOptionsSetAssociateVpc {
    associateStatus: string;
    vpcId: string;
}

export interface VpcDhcpOptionsSetAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcDhcpOptionsSetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcFlowLogTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcGatewayEndpointRouteTableAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcGatewayEndpointTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcGatewayRouteTableAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcHaVipTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcIpv4CidrBlockTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcIpv4GatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcIpv6AddressTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcIpv6CidrBlock {
    ipv6CidrBlock: string;
    ipv6Isp: string;
}

export interface VpcIpv6EgressRuleTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcIpv6GatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcIpv6InternetBandwidthTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcNatIpTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcNetworkAclAttachmentTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcPeerConnectionAccepterTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcPeerConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcPrefixListEntry {
    cidr?: string;
    description?: string;
}

export interface VpcPrefixListPrefixListAssociation {
    ownerId: string;
    prefixListId: string;
    reason: string;
    regionId: string;
    resourceId: string;
    resourceType: string;
    resourceUid: string;
    status: string;
}

export interface VpcPrefixListTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcPublicIpAddressPoolCidrBlockTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcPublicIpAddressPoolTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcTrafficMirrorFilterEgressRule {
    action: string;
    destinationCidrBlock?: string;
    destinationPortRange?: string;
    priority?: number;
    protocol: string;
    sourceCidrBlock?: string;
    sourcePortRange?: string;
    trafficMirrorFilterRuleStatus: string;
}

export interface VpcTrafficMirrorFilterEgressRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcTrafficMirrorFilterIngressRule {
    action: string;
    destinationCidrBlock?: string;
    destinationPortRange?: string;
    priority?: number;
    protocol: string;
    sourceCidrBlock?: string;
    sourcePortRange?: string;
    trafficMirrorFilterRuleStatus: string;
}

export interface VpcTrafficMirrorFilterIngressRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcTrafficMirrorFilterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcTrafficMirrorSessionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcVbrHaTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcVswitchCidrReservationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnConnectionBgpConfig {
    enable: boolean;
    localAsn: string;
    localBgpIp: string;
    status: string;
    tunnelCidr: string;
}

export interface VpnConnectionHealthCheckConfig {
    dip: string;
    enable: boolean;
    interval: number;
    retry: number;
    sip: string;
}

export interface VpnConnectionIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg: string;
    ikeLifetime: number;
    ikeLocalId: string;
    ikeMode: string;
    ikePfs: string;
    ikeRemoteId: string;
    ikeVersion: string;
    psk: string;
}

export interface VpnConnectionIpsecConfig {
    ipsecAuthAlg: string;
    ipsecEncAlg: string;
    ipsecLifetime: number;
    ipsecPfs: string;
}

export interface VpnConnectionTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnConnectionTunnelOptionsSpecification {
    customerGatewayId?: string;
    enableDpd?: boolean;
    enableNatTraversal?: boolean;
    internetIp: string;
    role?: string;
    state: string;
    status: string;
    tunnelBgpConfig?: outputs.VpnConnectionTunnelOptionsSpecificationTunnelBgpConfig;
    tunnelId: string;
    tunnelIkeConfig?: outputs.VpnConnectionTunnelOptionsSpecificationTunnelIkeConfig;
    tunnelIpsecConfig?: outputs.VpnConnectionTunnelOptionsSpecificationTunnelIpsecConfig;
    zoneNo: string;
}

export interface VpnConnectionTunnelOptionsSpecificationTunnelBgpConfig {
    bgpStatus: string;
    localAsn?: string;
    localBgpIp?: string;
    peerAsn: string;
    peerBgpIp: string;
    tunnelCidr?: string;
}

export interface VpnConnectionTunnelOptionsSpecificationTunnelIkeConfig {
    ikeAuthAlg?: string;
    ikeEncAlg?: string;
    ikeLifetime?: number;
    ikeMode?: string;
    ikePfs?: string;
    ikeVersion?: string;
    localId?: string;
    psk?: string;
    remoteId?: string;
}

export interface VpnConnectionTunnelOptionsSpecificationTunnelIpsecConfig {
    ipsecAuthAlg?: string;
    ipsecEncAlg?: string;
    ipsecLifetime?: number;
    ipsecPfs?: string;
}

export interface VpnCustomerGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnGatewayVcoRouteTimeouts {
    create?: string;
    delete?: string;
}

export interface VpnGatewayVpnAttachmentBgpConfig {
    enable: boolean;
    localAsn: number;
    localBgpIp: string;
    tunnelCidr: string;
}

export interface VpnGatewayVpnAttachmentHealthCheckConfig {
    dip: string;
    enable: boolean;
    interval: number;
    policy: string;
    retry: number;
    sip: string;
}

export interface VpnGatewayVpnAttachmentIkeConfig {
    ikeAuthAlg: string;
    ikeEncAlg?: string;
    ikeLifetime?: number;
    ikeMode?: string;
    ikePfs?: string;
    ikeVersion?: string;
    localId: string;
    psk?: string;
    remoteId: string;
}

export interface VpnGatewayVpnAttachmentIpsecConfig {
    ipsecAuthAlg?: string;
    ipsecEncAlg?: string;
    ipsecLifetime?: number;
    ipsecPfs?: string;
}

export interface VpnGatewayVpnAttachmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnIpsecServerIkeConfig {
    ikeAuthAlg?: string;
    ikeEncAlg?: string;
    ikeLifetime?: number;
    ikeMode?: string;
    ikePfs?: string;
    ikeVersion?: string;
    localId?: string;
    remoteId?: string;
}

export interface VpnIpsecServerIpsecConfig {
    ipsecAuthAlg?: string;
    ipsecEncAlg?: string;
    ipsecLifetime?: number;
    ipsecPfs?: string;
}

export interface VpnIpsecServerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnPbrRouteEntryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpnRouteEntryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VswitchTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface WafDomainLogHeader {
    key?: string;
    value?: string;
}

export interface Wafv3DefenseTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Wafv3DomainListen {
    certId?: string;
    cipherSuite?: number;
    customCiphers?: string[];
    enableTlsv3?: boolean;
    exclusiveIp?: boolean;
    focusHttps?: boolean;
    http2Enabled?: boolean;
    httpPorts?: number[];
    httpsPorts?: number[];
    ipv6Enabled?: boolean;
    protectionResource?: string;
    tlsVersion?: string;
    xffHeaderMode?: number;
    xffHeaders?: string[];
}

export interface Wafv3DomainRedirect {
    backends?: string[];
    connectTimeout?: number;
    focusHttpBackend?: boolean;
    keepalive?: boolean;
    keepaliveRequests?: number;
    keepaliveTimeout?: number;
    loadbalance: string;
    readTimeout?: number;
    requestHeaders?: outputs.Wafv3DomainRedirectRequestHeader[];
    retry?: boolean;
    sniEnabled?: boolean;
    sniHost?: string;
    writeTimeout?: number;
}

export interface Wafv3DomainRedirectRequestHeader {
    key?: string;
    value?: string;
}

export interface Wafv3DomainTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Wafv3InstanceTimeouts {
    create?: string;
    delete?: string;
}

export interface YundunBastionhostInstanceAdAuthServer {
    account: string;
    baseDn: string;
    domain: string;
    emailMapping?: string;
    filter?: string;
    isSsl: boolean;
    mobileMapping?: string;
    nameMapping?: string;
    password: string;
    port: number;
    server: string;
    standbyServer?: string;
}

export interface YundunBastionhostInstanceLdapAuthServer {
    account: string;
    baseDn: string;
    emailMapping?: string;
    filter?: string;
    isSsl?: boolean;
    loginNameMapping?: string;
    mobileMapping?: string;
    nameMapping?: string;
    password: string;
    port: number;
    server: string;
    standbyServer?: string;
}

export interface YundunBastionhostInstanceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface YundunDbauditInstanceTimeouts {
    create?: string;
    update?: string;
}

export namespace config {
    export interface AssumeRole {
        externalId?: string;
        /**
         * The permissions applied when assuming a role. You cannot use, this policy to grant further permissions that are in excess to those of the, role that is being assumed.
         */
        policy?: string;
        /**
         * The ARN of a RAM role to assume prior to making API calls.
         */
        roleArn: string;
        /**
         * The time after which the established session for assuming role expires. Valid value range: [900-3600] seconds. Default to 0 (in this case Alicloud use own default value).
         */
        sessionExpiration?: number;
        sessionName?: string;
    }

    export interface AssumeRoleWithOidc {
        /**
         * ARN of the OIDC IdP.
         */
        oidcProviderArn?: string;
        oidcToken?: string;
        /**
         * The file path of OIDC token that is issued by the external IdP.
         */
        oidcTokenFile?: string;
        /**
         * The policy that specifies the permissions of the returned STS token. You can use this parameter to grant the STS token fewer permissions than the permissions granted to the RAM role.
         */
        policy?: string;
        /**
         * ARN of a RAM role to assume prior to making API calls.
         */
        roleArn?: string;
        /**
         * The custom name of the role session. Set this parameter based on your business requirements. In most cases, this parameter is set to the identity of the user who calls the operation, for example, the username.
         */
        roleSessionName?: string;
        /**
         * The validity period of the STS token. Unit: seconds. Default value: 3600. Minimum value: 900. Maximum value: the value of the MaxSessionDuration parameter when creating a ram role.
         */
        sessionExpiration?: number;
    }

    export interface Endpoints {
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom acr endpoints.
         */
        acr?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Actiontrail endpoints.
         */
        actiontrail?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom AnalyticDB endpoints.
         */
        adb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom alb endpoints.
         */
        alb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom alidfs endpoints.
         */
        alidfs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom alidns endpoints.
         */
        alidns?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ALIKAFKA endpoints.
         */
        alikafka?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Api Gateway endpoints.
         */
        apigateway?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom arms endpoints.
         */
        arms?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom bastionhost endpoints.
         */
        bastionhost?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom beebot endpoints.
         */
        beebot?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom bpstudio endpoints.
         */
        bpstudio?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom brain_industrial endpoints.
         */
        brainIndustrial?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom BSSOPENAPI endpoints.
         */
        bssopenapi?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom CAS endpoints.
         */
        cas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cassandra endpoints.
         */
        cassandra?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cbn endpoints.
         */
        cbn?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cbs endpoints.
         */
        cbs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cddc endpoints.
         */
        cddc?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom CDN endpoints.
         */
        cdn?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cds endpoints.
         */
        cds?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom clickhouse endpoints.
         */
        clickhouse?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cloudauth endpoints.
         */
        cloudauth?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cloudfirewall endpoints.
         */
        cloudfirewall?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cloudfw endpoints.
         */
        cloudfw?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cloudphone endpoints.
         */
        cloudphone?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom cloudsso endpoints.
         */
        cloudsso?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Cloud Monitor endpoints.
         */
        cms?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom computenest endpoints.
         */
        computenest?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom config endpoints.
         */
        config?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Container Registry endpoints.
         */
        cr?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Container Service endpoints.
         */
        cs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom das endpoints.
         */
        das?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Datahub endpoints.
         */
        datahub?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dataworkspublic endpoints.
         */
        dataworkspublic?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dbfs endpoints.
         */
        dbfs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dcdn endpoints.
         */
        dcdn?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ddosbasic endpoints.
         */
        ddosbasic?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom DDOSBGP endpoints.
         */
        ddosbgp?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom DDOSCOO endpoints.
         */
        ddoscoo?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom MongoDB endpoints.
         */
        dds?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom devopsrdc endpoints.
         */
        devopsrdc?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dg endpoints.
         */
        dg?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dm endpoints.
         */
        dm?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dms_enterprise endpoints.
         */
        dmsEnterprise?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dmsenterprise endpoints.
         */
        dmsenterprise?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom DNS endpoints.
         */
        dns?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom DRDS endpoints.
         */
        drds?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom dts endpoints.
         */
        dts?: string;
        dysms?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom eais endpoints.
         */
        eais?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ebs endpoints.
         */
        ebs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom eci endpoints.
         */
        eci?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ECS endpoints.
         */
        ecs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom edas endpoints.
         */
        edas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom edasschedulerx endpoints.
         */
        edasschedulerx?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom edsuser endpoints.
         */
        edsuser?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom eflo endpoints.
         */
        eflo?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ehpc endpoints.
         */
        ehpc?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ehs endpoints.
         */
        ehs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom eipanycast endpoints.
         */
        eipanycast?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Elasticsearch endpoints.
         */
        elasticsearch?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom EMR endpoints.
         */
        emr?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ens endpoints.
         */
        ens?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Autoscaling endpoints.
         */
        ess?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom eventbridge_share endpoints.
         */
        eventbridge?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Function Computing endpoints.
         */
        fc?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom fnf endpoints.
         */
        fnf?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ga endpoints.
         */
        ga?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom gaplus endpoints.
         */
        gaplus?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom gds endpoints.
         */
        gds?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom GPDB endpoints.
         */
        gpdb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom gwsecd endpoints.
         */
        gwsecd?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom hbr endpoints.
         */
        hbr?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom hcs_sgw endpoints.
         */
        hcsSgw?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom hitsdb endpoints.
         */
        hitsdb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom imm endpoints.
         */
        imm?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom imp endpoints.
         */
        imp?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ims endpoints.
         */
        ims?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom iot endpoints.
         */
        iot?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom KMS endpoints.
         */
        kms?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom R-KVStore endpoints.
         */
        kvstore?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Location Service endpoints.
         */
        location?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Log Service endpoints.
         */
        log?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Market Place endpoints.
         */
        market?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom MaxCompute endpoints.
         */
        maxcompute?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom mhub endpoints.
         */
        mhub?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom MNS endpoints.
         */
        mns?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom mscopensubscription endpoints.
         */
        mscopensubscription?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom mse endpoints.
         */
        mse?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom NAS endpoints.
         */
        nas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom nlb endpoints.
         */
        nlb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom oceanbase endpoints.
         */
        oceanbase?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ONS endpoints.
         */
        ons?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom onsproxy endpoints.
         */
        onsproxy?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom oos endpoints.
         */
        oos?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom opensearch endpoints.
         */
        opensearch?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom OSS endpoints.
         */
        oss?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Table Store endpoints.
         */
        ots?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom PolarDB endpoints.
         */
        polardb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom privatelink endpoints.
         */
        privatelink?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom Private Zone endpoints.
         */
        pvtz?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom quickbi endpoints.
         */
        quickbi?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom quotas endpoints.
         */
        quotas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom r_kvstore endpoints.
         */
        rKvstore?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom RAM endpoints.
         */
        ram?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom RDS endpoints.
         */
        rds?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom redisa endpoints.
         */
        redisa?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom resourcemanager endpoints.
         */
        resourcemanager?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom resourcesharing endpoints.
         */
        ressharing?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom ros endpoints.
         */
        ros?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom sas endpoints.
         */
        sas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom scdn endpoints.
         */
        scdn?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom sddp endpoints.
         */
        sddp?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom selectdb endpoints.
         */
        selectdb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom serverless endpoints.
         */
        serverless?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom servicemesh endpoints.
         */
        servicemesh?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom sgw endpoints.
         */
        sgw?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom SLB endpoints.
         */
        slb?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom smartag endpoints.
         */
        smartag?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom srvcatalog endpoints.
         */
        srvcatalog?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom STS endpoints.
         */
        sts?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom swas endpoints.
         */
        swas?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom tag endpoints.
         */
        tag?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom vod endpoints.
         */
        vod?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom VPC and VPN endpoints.
         */
        vpc?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom vpcpeer endpoints.
         */
        vpcpeer?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom vs endpoints.
         */
        vs?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom waf endpoints.
         */
        waf?: string;
        /**
         * Use this to override the default endpoint URL constructed from the `region`. It's typically used to connect to custom waf_openapi endpoints.
         */
        wafOpenapi?: string;
    }

    export interface SignVersion {
        oss?: string;
        sls?: string;
    }

}
