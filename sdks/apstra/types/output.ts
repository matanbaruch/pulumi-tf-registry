// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AsnPoolRange {
    first: number;
    last: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    status: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    total: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    used: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    usedPercentage: number;
}

export interface ConfigletGenerator {
    /**
     * Specifies the switch platform, must be one of 'cumulus', 'nxos', 'eos', 'junos', 'sonic'.
     */
    configStyle: string;
    /**
     * FileName
     */
    filename?: string;
    /**
     * Negation Template Text
     */
    negationTemplateText?: string;
    /**
     * Specifies where in the target device the configlet should be  applied. Varies by network OS:
     *
     *   | **Config Style**  | **Valid Sections** |
     *   |---|---|
     *   |cumulus|file, frr, interface, ospf, system|
     *   |eos|interface, ospf, system, system_top|
     *   |junos|interface_level_hierarchical, interface_level_delete, interface_level_set, top_level_hierarchical, top_level_set_delete|
     *   |nxos|system, interface, system_top, ospf|
     *   |sonic|file, frr, ospf, system|
     */
    section: string;
    /**
     * Template Text
     */
    templateText: string;
}

export interface DatacenterBlueprintAntiAffinityPolicy {
    /**
     * Maximum total number of links connected to the interfaces of the specific port regardless of the system they are targeted to. It controls how many links can be connected to one port in one system. Example: Several transformations of one port. In this case, it controls how many transformations can be used in links.
     */
    maxLinksCountPerPort: number;
    /**
     * Maximum total number of links connected to ports/interfaces of the specified slot regardless of the systemthey are targeted to. It controls how many links can be connected to one slot of one system. Example: A line card slot in a chassis.
     */
    maxLinksCountPerSlot: number;
    /**
     * Restricts the number of interfaces on a port used to connect to a certain system. It controls how many links can be connected from one system to one port of another system. This is the one that you will most likely use, for port breakouts.
     */
    maxLinksCountPerSystemPerPort: number;
    /**
     * Restricts the number of links to a certain system connected to the ports/interfaces in a specific slot. It controls how many links can be connected to one system to one slot of another system.
     */
    maxLinksCountPerSystemPerSlot: number;
}

export interface DatacenterConfigletGenerator {
    /**
     * Specifies the switch platform, must be one of 'cumulus', 'nxos', 'eos', 'junos', 'sonic'.
     */
    configStyle: string;
    /**
     * FileName
     */
    filename?: string;
    /**
     * Negation Template Text
     */
    negationTemplateText?: string;
    /**
     * Specifies where in the target device the configlet should be  applied. Varies by network OS:
     *
     *   | **Config Style**  | **Valid Sections** |
     *   |---|---|
     *   |cumulus|file, frr, interface, ospf, system|
     *   |eos|interface, ospf, system, system_top|
     *   |junos|interface_level_hierarchical, interface_level_delete, interface_level_set, top_level_hierarchical, top_level_set_delete|
     *   |nxos|system, interface, system_top, ospf|
     *   |sonic|file, frr, ospf, system|
     */
    section: string;
    /**
     * Template Text
     */
    templateText: string;
}

export interface DatacenterConnectivityTemplateInterfaceIpLink {
    /**
     * Set of BGP Peering (Generic System) primitives
     */
    bgpPeeringGenericSystems?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringGenericSystem[];
    /**
     * Set of *BGP Peering (IP Endpoint)* Primitives in this Connectivity Template
     */
    bgpPeeringIpEndpoints?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringIpEndpoint[];
    /**
     * Set of *Dynamic BGP Peering* Primitives in this Connectivity Template
     */
    dynamicBgpPeerings?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkDynamicBgpPeering[];
    /**
     * One of `none`, `numbered`
     */
    ipv4AddressingType: string;
    /**
     * One of `none`, `link_local`, `numbered`
     */
    ipv6AddressingType: string;
    /**
     * L3 MTU for sub-interfaces on leaf (spine/superspine) side and generic side. Configuration is applicable only when Fabric MTU is enabled. Value must be even number rom 1280 to 9216, if not specified - Default IP Links to Generic Systems MTU from Virtual Network Policy s used
     */
    l3Mtu?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Node ID of the Routing Zone to which this IP Link should belong.
     */
    routingZoneId: string;
    /**
     * Set of network IPv4 or IPv6 destination prefixes reachable via this IP Link
     */
    staticRoutes?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkStaticRoute[];
    /**
     * 802.1Q tag number to use for tagged IP Link. Omit for untagged IP Link.
     */
    vlanId?: number;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringGenericSystem {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * Must be one of: 
     *   - none
     *   - addressed
     */
    ipv4AddressingType: string;
    /**
     * Must be one of: 
     *   - none
     *   - addressed
     *   - link_local
     */
    ipv6AddressingType: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * When `true`, the BGP process will accept connections from any peer AS.
     */
    neighborAsnDynamic: boolean;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Enable to peer from loopback interface. Default behavior peers from physical interface.
     */
    peerFromLoopback: boolean;
    /**
     * Must be one of: 
     *   - interface_or_ip_endpoint
     *   - interface_or_shared_ip_endpoint
     *   - loopback
     */
    peerTo: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringGenericSystemRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringGenericSystemRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringIpEndpoint {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * IPv4 address of peer.
     */
    ipv4Address?: string;
    /**
     * IPv6 address of peer.
     */
    ipv6Address?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Neighbor ASN. Omit for *Neighbor ASN Type Dynamic*.
     */
    neighborAsn?: number;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringIpEndpointRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkBgpPeeringIpEndpointRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkDynamicBgpPeering {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * Enables peering with IPv4 neighbors.
     */
    ipv4Enabled: boolean;
    /**
     * IPv4 Subnet for BGP Prefix Dynamic Neighbors. Leave blank to derive subnet from application point.
     */
    ipv4PeerPrefix?: string;
    /**
     * Enables peering with IPv6 neighbors.
     */
    ipv6Enabled: boolean;
    /**
     * IPv6 Subnet for BGP Prefix Dynamic Neighbors. Leave blank to derive subnet from application point.
     */
    ipv6PeerPrefix?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateInterfaceIpLinkDynamicBgpPeeringRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkDynamicBgpPeeringRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateInterfaceIpLinkStaticRoute {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Destination network in CIDR notation
     */
    network: string;
    /**
     * Indicates whether the next-hop IP address is shared across multiple remote systems. Default:  Default: `false`
     */
    shareIpEndpoint: boolean;
}

export interface DatacenterConnectivityTemplateInterfaceRoutingZoneConstraint {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Zone Constraint ID to be applied
     */
    routingZoneConstraintId: string;
}

export interface DatacenterConnectivityTemplateInterfaceVirtualNetworkMultiple {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * IDs of the Virtual Networks which should be tagged on the link
     */
    taggedVnIds?: string[];
    /**
     * ID of the Virtual Network which should be untagged on the link
     */
    untaggedVnId?: string;
}

export interface DatacenterConnectivityTemplateInterfaceVirtualNetworkSingle {
    /**
     * Set of BGP Peering (Generic System) primitives
     */
    bgpPeeringGenericSystems?: outputs.DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleBgpPeeringGenericSystem[];
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Set of Static Route primitives
     */
    staticRoutes?: outputs.DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleStaticRoute[];
    /**
     * Indicates whether the selected Virtual Network should be presented with an 802.1Q tag
     */
    tagged: boolean;
    /**
     * ID of the desired Virtual Network
     */
    virtualNetworkId: string;
}

export interface DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleBgpPeeringGenericSystem {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * Must be one of: 
     *   - none
     *   - addressed
     */
    ipv4AddressingType: string;
    /**
     * Must be one of: 
     *   - none
     *   - addressed
     *   - link_local
     */
    ipv6AddressingType: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * When `true`, the BGP process will accept connections from any peer AS.
     */
    neighborAsnDynamic: boolean;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Enable to peer from loopback interface. Default behavior peers from physical interface.
     */
    peerFromLoopback: boolean;
    /**
     * Must be one of: 
     *   - interface_or_ip_endpoint
     *   - interface_or_shared_ip_endpoint
     *   - loopback
     */
    peerTo: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleBgpPeeringGenericSystemRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleBgpPeeringGenericSystemRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateInterfaceVirtualNetworkSingleStaticRoute {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Destination network in CIDR notation
     */
    network: string;
    /**
     * Indicates whether the next-hop IP address is shared across multiple remote systems. Default:  Default: `false`
     */
    shareIpEndpoint: boolean;
}

export interface DatacenterConnectivityTemplateLoopbackBgpPeeringIpEndpoint {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * IPv4 address of peer.
     */
    ipv4Address?: string;
    /**
     * IPv6 address of peer.
     */
    ipv6Address?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Neighbor ASN. Omit for *Neighbor ASN Type Dynamic*.
     */
    neighborAsn?: number;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateLoopbackBgpPeeringIpEndpointRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateLoopbackBgpPeeringIpEndpointRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateSviBgpPeeringIpEndpoint {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * IPv4 address of peer.
     */
    ipv4Address?: string;
    /**
     * IPv6 address of peer.
     */
    ipv6Address?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Neighbor ASN. Omit for *Neighbor ASN Type Dynamic*.
     */
    neighborAsn?: number;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateSviBgpPeeringIpEndpointRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateSviBgpPeeringIpEndpointRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateSviDynamicBgpPeering {
    /**
     * Enable BFD.
     */
    bfdEnabled: boolean;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * Enables peering with IPv4 neighbors.
     */
    ipv4Enabled: boolean;
    /**
     * IPv4 Subnet for BGP Prefix Dynamic Neighbors. Leave blank to derive subnet from application point.
     */
    ipv4PeerPrefix?: string;
    /**
     * Enables peering with IPv6 neighbors.
     */
    ipv6Enabled: boolean;
    /**
     * IPv6 Subnet for BGP Prefix Dynamic Neighbors. Leave blank to derive subnet from application point.
     */
    ipv6PeerPrefix?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * This feature is configured on a per-peer basis. It allows a router to appear to be a member of a second autonomous system (AS) by prepending a local-as AS number, in addition to its real AS number, announced to its eBGP peer, resulting in an AS path length of two.
     */
    localAsn?: number;
    /**
     * Label used by the web UI on the Primitive "block" in the Connectivity Template.
     */
    name: string;
    /**
     * Password used to secure the BGP session.
     */
    password?: string;
    /**
     * Set of Routing Policy Primitives to be used with this *Protocol Endpoint*.
     */
    routingPolicies?: outputs.DatacenterConnectivityTemplateSviDynamicBgpPeeringRoutingPolicy[];
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface DatacenterConnectivityTemplateSviDynamicBgpPeeringRoutingPolicy {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Routing Policy ID to be applied
     */
    routingPolicyId: string;
}

export interface DatacenterConnectivityTemplateSystemCustomStaticRoute {
    /**
     * Label used on the Primitive "block" in the Connectivity Template
     */
    name: string;
    /**
     * Destination network in CIDR notation
     */
    network: string;
    /**
     * Next-hop router address
     */
    nextHop: string;
    /**
     * Routing Zone ID where this route should be installed
     */
    routingZoneId: string;
}

export interface DatacenterDeviceAllocationSystemAttributes {
    /**
     * ASN of the system node. Setting ASN is supported only for Spine and Leaf switches.
     */
    asn: number;
    /**
     * Set the [deploy mode](https://www.juniper.net/documentation/us/en/software/apstra4.1/apstra-user-guide/topics/topic-map/datacenter-deploy-mode-set.html) of the associated fabric node.
     */
    deployMode: string;
    /**
     * Hostname of the System node.
     */
    hostname: string;
    /**
     * IPv4 address of loopback interface in CIDR notation, must use 32-bit mask. Setting loopback addresses is supported only for Spine and Leaf switches.
     */
    loopbackIpv4: string;
    /**
     * IPv6 address of loopback interface in CIDR notation, must use 128-bit mask. Setting loopback addresses is supported only for Spine and Leaf switches. IPv6 must be enabled in the Blueprint to use this attribute.
     */
    loopbackIpv6: string;
    /**
     * Web UI label for the system node.
     */
    name: string;
    /**
     * Tag labels to be applied to the System node. If a Tag doesn't exist in the Blueprint it will be created automatically.
     */
    tags?: string[];
}

export interface DatacenterGenericSystemLink {
    /**
     * This field is used to collect multiple links into aggregation groups. For example, to create two LAG pairs from four physical links, you might use `group_label` value "bond0" on two links and "bond1" on the other two links. Apstra assigns a unique group ID to each link by default.
     */
    groupLabel?: string;
    /**
     * LAG negotiation mode of the Link. All links with the same `group_label` must use the value.
     */
    lagMode?: string;
    /**
     * Names of Tag to be applied to this Link. If a Tag doesn't exist in the Blueprint it will be created automatically.
     */
    tags?: string[];
    /**
     * Graph Node ID of the Leaf Switch or Access Switch where the link connects.
     */
    targetSwitchId: string;
    /**
     * Name of the physical interface where the link connects on the Leaf Switch or Access Switch ("ge-0/0/1" or similar).
     */
    targetSwitchIfName: string;
    /**
     * Transformation ID sets the operational mode of an interface.
     */
    targetSwitchIfTransformId: number;
}

export interface DatacenterRoutingPolicyExportPolicy {
    /**
     * Exports all virtual networks (VLANs) that have L3 addresses within a routing zone (VRF).
     */
    exportL2EdgeSubnets: boolean;
    /**
     * Exports all leaf to L3 server links within a routing zone (VRF). This will be an empty list on a layer2 based blueprint
     */
    exportL3EdgeServerLinks: boolean;
    /**
     * Exports all loopbacks within a routing zone (VRF) across spine, leaf, and L3 servers.
     */
    exportLoopbacks: boolean;
    /**
     * Exports all spine-supersine (fabric) links within the default routing zone (VRF)
     */
    exportSpineLeafLinks: boolean;
    /**
     * Exports all spine-leaf (fabric) links within a VRF. EVPN routing zones do not have spine-leaf addressing, so this generated list may be empty. For routing zones of type Virtual L3 Fabric, subinterfaces between spine-leaf will be included.
     */
    exportSpineSuperspineLinks: boolean;
    /**
     * Exports all subnets in a VRF associated with static routes from all fabric systems to external routers associated with this routing policy
     */
    exportStaticRoutes: boolean;
}

export interface DatacenterRoutingPolicyExtraExport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask?: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask?: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix: string;
}

export interface DatacenterRoutingPolicyExtraImport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask?: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask?: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix: string;
}

export interface DatacenterSecurityPolicyRule {
    /**
     * Action - One of: deny, deny_log, permit, permit_log
     */
    action: string;
    /**
     * Security Policy Rule Description.
     */
    description?: string;
    /**
     * Set of TCP/UDP destination ports matched by this rule. A `null` set matches any port. Valid only when `protocol` is `tcp` or `udp`.
     */
    destinationPorts?: outputs.DatacenterSecurityPolicyRuleDestinationPort[];
    /**
     * When `true`, the rendered rule will use the NOS `established` or `tcp-established` keyword/feature for TCP access control list entries.
     */
    established: boolean;
    /**
     * Security Policy Rule ID.
     */
    id: string;
    /**
     * Security Policy Rule Name.
     */
    name: string;
    /**
     * Security Policy Rule Protocol; one of: 'icmp', 'ip', 'tcp', 'udp'
     */
    protocol: string;
    /**
     * Set of TCP/UDP source ports matched by this rule. A `null` set matches any port. Valid only when `protocol` is `tcp` or `udp`.
     */
    sourcePorts?: outputs.DatacenterSecurityPolicyRuleSourcePort[];
}

export interface DatacenterSecurityPolicyRuleDestinationPort {
    /**
     * First (low) port number in a range of ports matched by the policy rule.
     */
    fromPort: number;
    /**
     * Last (high) port number in a range of ports matched by the policy rule.
     */
    toPort: number;
}

export interface DatacenterSecurityPolicyRuleSourcePort {
    /**
     * First (low) port number in a range of ports matched by the policy rule.
     */
    fromPort: number;
    /**
     * Last (high) port number in a range of ports matched by the policy rule.
     */
    toPort: number;
}

export interface DatacenterVirtualNetworkBindings {
    /**
     * The graph db node ID of the access switch `system` node (nonredundant access switch) or `redundancy_group` node (ESI LAG access switches) beneath `leaf_id` to which this VN should be bound.
     */
    accessIds: string[];
    /**
     * When not specified, Apstra will choose the VLAN to be used on each switch.
     */
    vlanId: number;
}

export interface FreeformLinkEndpoints {
    /**
     * Graph node ID of the associated interface
     */
    interfaceId: string;
    /**
     * The interface name, as found in the associated Device Profile, e.g. `xe-0/0/0`
     */
    interfaceName?: string;
    /**
     * Ipv4 address of the interface in CIDR notation
     */
    ipv4Address: string;
    /**
     * Ipv6 address of the interface in CIDR notation
     */
    ipv6Address: string;
    /**
     * Set of Tags applied to the interface
     */
    tags?: string[];
    /**
     * ID # of the transformation in the Device Profile
     */
    transformationId?: number;
}

export interface GetAgentsFilter {
    /**
     * Apstra ID for the Managed Device Agent.
     */
    agentId?: string;
    /**
     * ID of the Agent Profile associated with the Agent.
     */
    agentProfileId?: string;
    /**
     * Key which uniquely identifies a System asset, probably a serial number.
     */
    deviceKey?: string;
    /**
     * Management IP address of the System.
     */
    managementIp?: string;
    /**
     * Indicates whether the agent runs on the switch (true) or on an Apstra node (false).
     */
    offBox?: boolean;
    /**
     * Apstra ID for the System onboarded by the Managed Device Agent.
     */
    systemId?: string;
}

export interface GetAnomaliesDetail {
    /**
     * Extended Anomaly attribute describing the actual value/state/condition in JSON format.
     */
    actual: string;
    /**
     * Extended Anomaly attribute which further contextualizes the Anomaly.
     */
    anomalous: string;
    /**
     * Apstra Anomaly ID.
     */
    anomalyId: string;
    /**
     * Extended Anomaly attribute describing the expected value/state/condition in JSON format.
     */
    expected: string;
    /**
     * Extended Anomaly attribute which identifies the anomalous value/state/condition in JSON format.
     */
    identity: string;
    /**
     * Anomaly role further contextualizes `type`.
     */
    role: string;
    /**
     * Severity of Anomaly.
     */
    severity: string;
    /**
     * Anomaly Type.
     */
    type: string;
}

export interface GetAnomaliesSummaryByNode {
    /**
     * Number of ARP Anomalies related to the Node.
     */
    arp: number;
    /**
     * Number of BGP Anomalies related to the Node.
     */
    bgp: number;
    /**
     * Number of Blueprint Rendering Anomalies related to the Node.
     */
    blueprintRendering: number;
    /**
     * Number of Cabling Anomalies related to the Node.
     */
    cabling: number;
    /**
     * Number of Config Anomalies related to the Node.
     */
    config: number;
    /**
     * Number of Counter Anomalies related to the Node.
     */
    counter: number;
    /**
     * Number of Deployment Anomalies related to the Node.
     */
    deployment: number;
    /**
     * Number of Hostname Anomalies related to the Node.
     */
    hostname: number;
    /**
     * Number of Interface Anomalies related to the Node.
     */
    interface: number;
    /**
     * Number of LAG Anomalies related to the Node.
     */
    lag: number;
    /**
     * Number of Liveness Anomalies related to the Node.
     */
    liveness: number;
    /**
     * Number of MAC Anomalies related to the Node.
     */
    mac: number;
    /**
     * Number of MLAG Anomalies related to the Node.
     */
    mlag: number;
    /**
     * Name of the Node experiencing Anomalies.
     */
    nodeName: string;
    /**
     * Number of Probe Anomalies related to the Node.
     */
    probe: number;
    /**
     * Number of Route Anomalies related to the Node.
     */
    route: number;
    /**
     * Number of Series Anomalies related to the Node.
     */
    series: number;
    /**
     * Number of Streaming Anomalies related to the Node.
     */
    streaming: number;
    /**
     * System ID of the Node experiencing Anomalies.
     */
    systemId: string;
    /**
     * Total number of Anomalies related to the Node.
     */
    total: number;
}

export interface GetAnomaliesSummaryByService {
    /**
     * Count of Anomalies related to the Fabric Service and Role.
     */
    count: number;
    /**
     * Further context about the Fabric Service Anomalies.
     */
    role: string;
    /**
     * Fabric Service experiencing Anomalies.
     */
    type: string;
}

export interface GetAsnPoolRange {
    /**
     * Lowest numbered AS in this ASN Pool Range.
     */
    first: number;
    /**
     * Highest numbered AS in this ASN Pool Range.
     */
    last: number;
    /**
     * Status of the ASN Pool Range, as reported by Apstra.
     */
    status: string;
    /**
     * Total number of ASNs in the ASN Pool Range.
     */
    total: number;
    /**
     * Count of used ASNs in the ASN Pool Range.
     */
    used: number;
    /**
     * Percent of used ASNs in the ASN Pool Range.
     */
    usedPercentage: number;
}

export interface GetConfigletGenerator {
    /**
     * Indicates Platform Specific Configuration Style
     */
    configStyle: string;
    /**
     * FileName
     */
    filename: string;
    /**
     * Negation Template Text
     */
    negationTemplateText: string;
    /**
     * Config Section
     */
    section: string;
    /**
     * Template Text
     */
    templateText: string;
}

export interface GetDatacenterBlueprintAntiAffinityPolicy {
    /**
     * Maximum total number of links connected to the interfaces of the specific port regardless of the system they are targeted to. It controls how many links can be connected to one port in one system. Example: Several transformations of one port. In this case, it controls how many transformations can be used in links.
     */
    maxLinksCountPerPort: number;
    /**
     * Maximum total number of links connected to ports/interfaces of the specified slot regardless of the systemthey are targeted to. It controls how many links can be connected to one slot of one system. Example: A line card slot in a chassis.
     */
    maxLinksCountPerSlot: number;
    /**
     * Restricts the number of interfaces on a port used to connect to a certain system. It controls how many links can be connected from one system to one port of another system. This is the one that you will most likely use, for port breakouts.
     */
    maxLinksCountPerSystemPerPort: number;
    /**
     * Restricts the number of links to a certain system connected to the ports/interfaces in a specific slot. It controls how many links can be connected to one system to one slot of another system.
     */
    maxLinksCountPerSystemPerSlot: number;
}

export interface GetDatacenterConfigletGenerator {
    /**
     * Indicates Platform Specific Configuration Style
     */
    configStyle: string;
    /**
     * FileName
     */
    filename: string;
    /**
     * Negation Template Text
     */
    negationTemplateText: string;
    /**
     * Config Section
     */
    section: string;
    /**
     * Template Text
     */
    templateText: string;
}

export interface GetDatacenterExternalGatewaysFilter {
    /**
     * External Gateway AS Number
     */
    asn?: number;
    /**
     * Not applicable in filter context. Ignore.
     */
    blueprintId: string;
    /**
     * EVPN route types. Valid values are: ["all", "type5_only"]. Default: "all"
     */
    evpnRouteTypes?: string;
    /**
     * BGP hold time (seconds).
     */
    holdTime?: number;
    /**
     * Apstra Object ID.
     */
    id?: string;
    /**
     * External Gateway IP address
     */
    ipAddress?: string;
    /**
     * BGP keepalive time (seconds).
     */
    keepaliveTime?: number;
    /**
     * Set of IDs of switch nodes which will be configured to peer with the External Gateway
     */
    localGatewayNodes?: string[];
    /**
     * External Gateway name
     */
    name?: string;
    /**
     * BGP TCP authentication password
     */
    password?: string;
    /**
     * BGP Time To Live. Omit to use device defaults.
     */
    ttl?: number;
}

export interface GetDatacenterRoutingPoliciesFilter {
    /**
     * All `aggregate_prefixes` specified here are required for the filter to match, but the list need not be an *exact match*. That is, a policy containting `10.1.0.0/16` and `10.2.0.0/16` will match a filter which specifies only `10.1.0.0/16`
     */
    aggregatePrefixes?: string[];
    /**
     * Not applicable in filter context. Ignore.
     */
    blueprintId: string;
    /**
     * Web UI 'description' field.
     */
    description?: string;
    /**
     * Default IPv4 route is expected to be imported via protocol session using this policy. Used for rendering route expectations.
     */
    expectDefaultIpv4?: boolean;
    /**
     * Default IPv6 route is expected to be imported via protocol session using this policy. Used for rendering route expectations.
     */
    expectDefaultIpv6?: boolean;
    /**
     * The export policy controls export of various types of fabric prefixes.
     */
    exportPolicy?: outputs.GetDatacenterRoutingPoliciesFilterExportPolicy;
    /**
     * All `extra_exports` specified here are required for the filter to match, using the same logic as `aggregate_prefixes`.
     */
    extraExports?: outputs.GetDatacenterRoutingPoliciesFilterExtraExport[];
    /**
     * All `extra_imports` specified here are required for the filter to match, using the same logic as `aggregate_prefixes`.
     */
    extraImports?: outputs.GetDatacenterRoutingPoliciesFilterExtraImport[];
    /**
     * Apstra graph node ID.
     */
    id?: string;
    /**
     * One of '', 'default_only', 'all', 'extra_only'
     */
    importPolicy?: string;
    /**
     * Web UI `name` field.
     */
    name?: string;
}

export interface GetDatacenterRoutingPoliciesFilterExportPolicy {
    /**
     * Exports all virtual networks (VLANs) that have L3 addresses within a routing zone (VRF).
     */
    exportL2EdgeSubnets?: boolean;
    /**
     * Exports all leaf to L3 server links within a routing zone (VRF). This will be an empty list on a layer2 based blueprint
     */
    exportL3EdgeServerLinks?: boolean;
    /**
     * Exports all loopbacks within a routing zone (VRF) across spine, leaf, and L3 servers.
     */
    exportLoopbacks?: boolean;
    /**
     * Exports all spine-supersine (fabric) links within the default routing zone (VRF)
     */
    exportSpineLeafLinks?: boolean;
    /**
     * Exports all spine-leaf (fabric) links within a VRF. EVPN routing zones do not have spine-leaf addressing, so this generated list may be empty. For routing zones of type Virtual L3 Fabric, subinterfaces between spine-leaf will be included.
     */
    exportSpineSuperspineLinks?: boolean;
    /**
     * Exports all subnets in a VRF associated with static routes from all fabric systems to external routers associated with this routing policy
     */
    exportStaticRoutes?: boolean;
}

export interface GetDatacenterRoutingPoliciesFilterExtraExport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action?: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask?: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask?: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix?: string;
}

export interface GetDatacenterRoutingPoliciesFilterExtraImport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action?: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask?: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask?: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix?: string;
}

export interface GetDatacenterRoutingPolicyExportPolicy {
    /**
     * Exports all virtual networks (VLANs) that have L3 addresses within a routing zone (VRF).
     */
    exportL2EdgeSubnets: boolean;
    /**
     * Exports all leaf to L3 server links within a routing zone (VRF). This will be an empty list on a layer2 based blueprint
     */
    exportL3EdgeServerLinks: boolean;
    /**
     * Exports all loopbacks within a routing zone (VRF) across spine, leaf, and L3 servers.
     */
    exportLoopbacks: boolean;
    /**
     * Exports all spine-supersine (fabric) links within the default routing zone (VRF)
     */
    exportSpineLeafLinks: boolean;
    /**
     * Exports all spine-leaf (fabric) links within a VRF. EVPN routing zones do not have spine-leaf addressing, so this generated list may be empty. For routing zones of type Virtual L3 Fabric, subinterfaces between spine-leaf will be included.
     */
    exportSpineSuperspineLinks: boolean;
    /**
     * Exports all subnets in a VRF associated with static routes from all fabric systems to external routers associated with this routing policy
     */
    exportStaticRoutes: boolean;
}

export interface GetDatacenterRoutingPolicyExtraExport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix: string;
}

export interface GetDatacenterRoutingPolicyExtraImport {
    /**
     * If the action is "permit", match the route. If the action is "deny", do not match the route. For composing complex policies, all prefix-list items will be processed in the order specified, top-down. This allows the user to deny a subset of a route that may otherwise be permitted.
     */
    action: string;
    /**
     * Match less-specific prefixes from a parent prefix, up from `ge_mask` to the prefix length of the route. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `le_mask`. `ge_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    geMask: number;
    /**
     * Match more-specific prefixes from a parent prefix, up until `le_mask` prefix len. Range is 0-32 for IPv4, 0-128 for IPv6. If not specified, implies the prefix-list entry should be an exact match. The option can be optionally be used in combination with `ge_mask`. `le_mask` must be longer than the subnet prefix length. If `le_mask` and `ge_mask` are both specified, then `le_mask` must be greater than `ge_mask`.
     */
    leMask: number;
    /**
     * IPv4 or IPv6 network address specified in the form of network/prefixlen.
     */
    prefix: string;
}

export interface GetDatacenterRoutingZonesFilter {
    /**
     * Not applicable in filter context. Ignore.
     */
    blueprintId: string;
    /**
     * Set of addresses of DHCP servers (IPv4 or IPv6) which must be configured in the Routing Zone. This is a list of *required* servers, not an exact-match list.
     */
    dhcpServers?: string[];
    /**
     * This is a set of *required* RTs, not an exact-match list.
     */
    exportRouteTargets?: string[];
    /**
     * Not applicable in filter context. Ignore.
     */
    hadPriorVlanIdConfig: boolean;
    /**
     * Not applicable in filter context. Ignore.
     */
    hadPriorVniConfig: boolean;
    /**
     * Not applicable in filter context. Ignore.
     */
    id: string;
    /**
     * This is a set of *required* RTs, not an exact-match list.
     */
    importRouteTargets?: string[];
    /**
     * Symmetric IRB Routing for EVPN on Junos devices makes use of an L3 VNI for inter-subnet routing which is embedded into EVPN Type2-routes to support better scaling for networks with large amounts of VLANs.
     */
    junosEvpnIrbMode?: string;
    /**
     * Name displayed in the Apstra web UI.
     */
    name?: string;
    /**
     * Non-EVPN blueprints must use the default policy, so this field must be null. Set this attribute in an EVPN blueprint to use a non-default policy.
     */
    routingPolicyId?: string;
    /**
     * Used for VLAN tagged Layer 3 links on external connections.
     */
    vlanId?: number;
    /**
     * VxLAN VNI associated with the routing zone.
     */
    vni?: number;
    /**
     * VRF name.
     */
    vrfName?: string;
}

export interface GetDatacenterSecurityPoliciesFilter {
    /**
     * Not applicable in filter context. Ignore.
     */
    blueprintId: string;
    /**
     * Security Policy description, as seen in the Web UI.
     */
    description?: string;
    /**
     * Graph node ID of the destination Application Point (Virtual Network ID, Routing Zone ID, etc...)
     */
    destinationApplicationPointId?: string;
    /**
     * Indicates whether the Security Policy is enabled.
     */
    enabled?: boolean;
    /**
     * Not applicable in filter context. Ignore.
     */
    id: string;
    /**
     * Security Policy name.
     */
    name?: string;
    rules: outputs.GetDatacenterSecurityPoliciesFilterRule[];
    /**
     * Graph node ID of the source Application Point (Virtual Network ID, Routing Zone ID, etc...)
     */
    sourceApplicationPointId?: string;
    /**
     * Set of Tags. All tags supplied here are used to match the Security Policy, but a matching Security Policy may have additional tags not enumerated in this set.
     */
    tags?: string[];
}

export interface GetDatacenterSecurityPoliciesFilterRule {
    action: string;
    description: string;
    destinationPorts: outputs.GetDatacenterSecurityPoliciesFilterRuleDestinationPort[];
    established: boolean;
    id: string;
    name: string;
    protocol: string;
    sourcePorts: outputs.GetDatacenterSecurityPoliciesFilterRuleSourcePort[];
}

export interface GetDatacenterSecurityPoliciesFilterRuleDestinationPort {
    fromPort: number;
    toPort: number;
}

export interface GetDatacenterSecurityPoliciesFilterRuleSourcePort {
    fromPort: number;
    toPort: number;
}

export interface GetDatacenterSecurityPolicyRule {
    /**
     * Security Policy Rule Action; one of: deny, deny_log, permit, permit_log
     */
    action: string;
    /**
     * Security Policy Rule Description.
     */
    description: string;
    /**
     * Set of TCP/UDP destination ports matched by this rule. A `null` set matches any port. Applies only when `protocol` is `tcp` or `udp`.
     */
    destinationPorts: outputs.GetDatacenterSecurityPolicyRuleDestinationPort[];
    /**
     * When `true`, the rendered rule will use the NOS `established` or `tcp-established` keyword/feature for TCP access control list entries.
     */
    established: boolean;
    /**
     * Security Policy Rule ID.
     */
    id: string;
    /**
     * Security Policy Rule Name.
     */
    name: string;
    /**
     * Security Policy Rule Protocol; one of: 'icmp', 'ip', 'tcp', 'udp'
     */
    protocol: string;
    /**
     * Set of TCP/UDP source ports matched by this rule. A `null` set matches any port. Applies only when `protocol` is `tcp` or `udp`.
     */
    sourcePorts: outputs.GetDatacenterSecurityPolicyRuleSourcePort[];
}

export interface GetDatacenterSecurityPolicyRuleDestinationPort {
    /**
     * First (low) port number in a range of ports matched by the policy rule.
     */
    fromPort: number;
    /**
     * Last (high) port number in a range of ports matched by the policy rule.
     */
    toPort: number;
}

export interface GetDatacenterSecurityPolicyRuleSourcePort {
    /**
     * First (low) port number in a range of ports matched by the policy rule.
     */
    fromPort: number;
    /**
     * Last (high) port number in a range of ports matched by the policy rule.
     */
    toPort: number;
}

export interface GetDatacenterSvisMapById {
    id: string;
    ipv4Addr: string;
    ipv4Mode: string;
    ipv6Addr: string;
    ipv6Mode: string;
    name: string;
    systemId: string;
    virtualNetworkId: string;
}

export interface GetDatacenterSvisMapBySystem {
    id: string;
    ipv4Addr: string;
    ipv4Mode: string;
    ipv6Addr: string;
    ipv6Mode: string;
    name: string;
    systemId: string;
    virtualNetworkId: string;
}

export interface GetDatacenterSvisMapByVirtualNetwork {
    id: string;
    ipv4Addr: string;
    ipv4Mode: string;
    ipv6Addr: string;
    ipv6Mode: string;
    name: string;
    systemId: string;
    virtualNetworkId: string;
}

export interface GetDatacenterSystemAttributes {
    /**
     * Apstra Graph DB node `hostname`
     */
    hostname: string;
    /**
     * Apstra Graph DB node ID
     */
    id: string;
    /**
     * Apstra Graph DB node `label`
     */
    label: string;
    /**
     * Apstra Graph DB node `role`
     */
    role: string;
    /**
     * Apstra ID of the physical system (not to be confused with its fabric role)
     */
    systemId: string;
    /**
     * Apstra Graph DB node `system_type`
     */
    systemType: string;
    /**
     * Apstra Graph DB tags associated with this system
     */
    tagIds: string[];
}

export interface GetDatacenterSystemsFilter {
    /**
     * Apstra Graph DB node `hostname`
     */
    hostname?: string;
    /**
     * Apstra Graph DB node ID
     */
    id?: string;
    /**
     * Apstra Graph DB node `label`
     */
    label?: string;
    /**
     * Apstra Graph DB node `role`
     */
    role?: string;
    /**
     * Apstra ID of the physical system (not to be confused with its fabric role)
     */
    systemId?: string;
    /**
     * Apstra Graph DB node `system_type`
     */
    systemType?: string;
    /**
     * Set of Tag IDs (labels) - only nodes with all tags will match this filter
     */
    tagIds?: string[];
}

export interface GetDatacenterVirtualNetworkBindingConstructorBindings {
    /**
     * A set of zero or more graph db node IDs representing Access Switch `system` nodes or a `redundancy_group` nodes.
     */
    accessIds: string[];
    /**
     * The value supplied as `vlan_id` at the root of this datasource configuration, if any. May be `null`, in which case Apstra will choose.
     */
    vlanId: number;
}

export interface GetDatacenterVirtualNetworkBindings {
    /**
     * A set of zero or more graph db node IDs representing Access Switch `system` nodes or a `redundancy_group` nodes.
     */
    accessIds: string[];
    /**
     * VLAN id on the specified switch, switch pair and access switches.
     */
    vlanId: number;
}

export interface GetDatacenterVirtualNetworksFilter {
    /**
     * Not applicable in filter context. Ignore.
     */
    bindings: {[key: string]: outputs.GetDatacenterVirtualNetworksFilterBindings};
    /**
     * Not applicable in filter context. Ignore.
     */
    blueprintId: string;
    /**
     * Enables a DHCP relay agent.
     */
    dhcpServiceEnabled?: boolean;
    /**
     * This is a set of *required* export RTs, not an exact-match list.
     */
    exportRouteTargets?: string[];
    /**
     * Not applicable in filter context. Ignore.
     */
    hadPriorVniConfig: boolean;
    /**
     * Not applicable in filter context. Ignore.
     */
    id: string;
    /**
     * This is a set of *required* import RTs, not an exact-match list.
     */
    importRouteTargets?: string[];
    /**
     * Enables IPv4 within the Virtual Network.
     */
    ipv4ConnectivityEnabled?: boolean;
    /**
     * IPv4 subnet associated with the Virtual Network.
     */
    ipv4Subnet?: string;
    /**
     * Specifies the IPv4 virtual gateway address within the Virtual Network.
     */
    ipv4VirtualGateway?: string;
    /**
     * Controls and indicates whether the IPv4 gateway within the Virtual Network is enabled.
     */
    ipv4VirtualGatewayEnabled?: boolean;
    /**
     * Enables IPv6 within the Virtual Network.
     */
    ipv6ConnectivityEnabled?: boolean;
    /**
     * IPv6 subnet associated with the Virtual Network. Note that this attribute will not appear in the `graph_query` output because IPv6 zero compression rules are problematic for mechanisms which rely on string matching.
     */
    ipv6Subnet?: string;
    /**
     * Specifies the IPv6 virtual gateway address within the Virtual Network. Note that this attribute will not appear in the `graph_query` output because IPv6 zero compression rules are problematic for mechanisms which rely on string matching.
     */
    ipv6VirtualGateway?: string;
    /**
     * Controls and indicates whether the IPv6 gateway within the Virtual Network is enabled.
     */
    ipv6VirtualGatewayEnabled?: boolean;
    /**
     * L3 MTU used by the L3 switch interfaces participating in the Virtual Network. Requires Apstra 4.2 or later.
     */
    l3Mtu?: number;
    /**
     * Virtual Network Name
     */
    name?: string;
    /**
     * For use only with `vxlan` type Virtual networks when all `bindings` use the same VLAN ID. This option reserves the VLAN fabric-wide, even on switches to which the Virtual Network has not yet been deployed.
     */
    reserveVlan?: boolean;
    /**
     * Routing Zone ID (required when `type == vxlan`)
     */
    routingZoneId?: string;
    /**
     * Virtual Network Type
     */
    type?: string;
    /**
     * EVPN Virtual Network ID to be associated with this Virtual Network.
     */
    vni?: number;
}

export interface GetDatacenterVirtualNetworksFilterBindings {
}

export interface GetFreeformLinkEndpoints {
    /**
     * Graph node ID of the associated interface
     */
    interfaceId: string;
    /**
     * The interface name, as found in the associated Device Profile, e.g. `xe-0/0/0`
     */
    interfaceName: string;
    /**
     * Ipv4 address of the interface in CIDR notation
     */
    ipv4Address: string;
    /**
     * Ipv6 address of the interface in CIDR notation
     */
    ipv6Address: string;
    /**
     * Set of Tags applied to the interface
     */
    tags: string[];
    /**
     * ID # of the transformation in the Device Profile
     */
    transformationId: number;
}

export interface GetIntegerPoolRange {
    /**
     * Lowest numbered ID in this Integer Pool Range.
     */
    first: number;
    /**
     * Highest numbered ID in this Integer Pool Range.
     */
    last: number;
    /**
     * Status of the Integer Pool Range, as reported by Apstra.
     */
    status: string;
    /**
     * Total number of IDs in the Integer Pool Range.
     */
    total: number;
    /**
     * Count of used Integers in the Integer Pool Range.
     */
    used: number;
    /**
     * Percent of used IDs in the Integer Pool Range.
     */
    usedPercentage: number;
}

export interface GetInterfaceMapInterface {
    /**
     * Indicates whether the interface is used by the Interface Map
     */
    active: boolean;
    /**
     * Mapping info for each physical interface
     */
    mapping: outputs.GetInterfaceMapInterfaceMapping;
    /**
     * Physical device interface name
     */
    name: string;
    /**
     * todo - need to find out what this is
     */
    position: number;
    /**
     * Logical Device role ("connected to") of the interface.
     */
    roles: string[];
    /**
     * Vendor specific commands needed to configure the interface, from the device profile.
     */
    setting: string;
    /**
     * Interface speed
     */
    speed: string;
}

export interface GetInterfaceMapInterfaceMapping {
    /**
     * Port-specific interface ID from the device profile (used to identify interfaces in breakout scenarios.)
     */
    deviceProfileInterfaceId: number;
    /**
     * Port number(ID) from the Device Profile.
     */
    deviceProfilePortId: number;
    /**
     * Port-specific transform ID from the Device Profile.
     */
    deviceProfileTransformationId: number;
    /**
     * Panel number (first panel is 1) of the Logical Device port which corresponds to this interface.
     */
    logicalDevicePanel: number;
    /**
     * Port number (first port is 1) of the Logical Device port which corresponds to this interface.
     */
    logicalDevicePanelPort: number;
}

export interface GetIpv4PoolSubnet {
    /**
     * Network specification in CIDR syntax ("10.0.0.0/8").
     */
    network: string;
    /**
     * Status of the IPv4 resource pool.
     */
    status: string;
    /**
     * Total number of addresses in this IPv4 range.
     */
    total: number;
    /**
     * Count of used addresses in this IPv4 range.
     */
    used: number;
    /**
     * Percent of used addresses in this IPv4 range.
     */
    usedPercentage: number;
}

export interface GetIpv6PoolSubnet {
    /**
     * Network specification in CIDR syntax ("2001:db8::/32").
     */
    network: string;
    /**
     * Status of the IPv6 resource pool.
     */
    status: string;
    /**
     * Total number of addresses in this IPv6 range.
     */
    total: number;
    /**
     * Count of used addresses in this IPv6 range.
     */
    used: number;
    /**
     * Percent of used addresses in this IPv6 range.
     */
    usedPercentage: number;
}

export interface GetLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetRackTypeAccessSwitches {
    /**
     * Count of Access Switches of this type.
     */
    count: number;
    /**
     * Interconnect information for Access Switches in ESI-LAG redundancy mode.
     */
    esiLagInfo: outputs.GetRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Details links from this Access Switch to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether 'the switch' is actually a LAG-capable redundant pair and if so, what type.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Access Switch.
     */
    tags: outputs.GetRackTypeAccessSwitchesTag[];
}

export interface GetRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface GetRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface GetRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetRackTypeAccessSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Details links from this Generic System to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Generic System.
     */
    tags: outputs.GetRackTypeGenericSystemsTag[];
}

export interface GetRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetRackTypeGenericSystemsLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface GetRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetRackTypeGenericSystemsTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetRackTypeLeafSwitches {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Details settings when the Leaf Switch is an MLAG-capable pair.
     */
    mlagInfo: outputs.GetRackTypeLeafSwitchesMlagInfo;
    /**
     * When set, 'the switch' is actually a LAG-capable redundant pair of the given type.
     */
    redundancyProtocol: string;
    /**
     * Number of links to each Spine switch.
     */
    spineLinkCount: number;
    /**
     * Speed of links to Spine switches.
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Leaf Switch.
     */
    tags: outputs.GetRackTypeLeafSwitchesTag[];
}

export interface GetRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface GetRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount: number;
    /**
     * L3 peer link port-channel ID.
     */
    l3PeerLinkPortChannelId: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Peer link port-channel ID.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface GetRackTypeLeafSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateCollapsedRackType {
    /**
     * A map of Access Switches in this Rack Type, keyed by name.
     */
    accessSwitches: {[key: string]: outputs.GetTemplateCollapsedRackTypeAccessSwitches};
    /**
     * Rack Type description displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Indicates designs for which this Rack Type is intended.
     */
    fabricConnectivityDesign: string;
    /**
     * A map of Generic Systems in the Rack Type, keyed by name.
     */
    genericSystems: {[key: string]: outputs.GetTemplateCollapsedRackTypeGenericSystems};
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * A map of Leaf Switches in this Rack Type, keyed by name.
     */
    leafSwitches: {[key: string]: outputs.GetTemplateCollapsedRackTypeLeafSwitches};
    /**
     * Rack Type name displayed in the Apstra web UI.
     */
    name: string;
}

export interface GetTemplateCollapsedRackTypeAccessSwitches {
    /**
     * Count of Access Switches of this type.
     */
    count: number;
    /**
     * Interconnect information for Access Switches in ESI-LAG redundancy mode.
     */
    esiLagInfo: outputs.GetTemplateCollapsedRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Details links from this Access Switch to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplateCollapsedRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether 'the switch' is actually a LAG-capable redundant pair and if so, what type.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Access Switch.
     */
    tags: outputs.GetTemplateCollapsedRackTypeAccessSwitchesTag[];
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplateCollapsedRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateCollapsedRackTypeAccessSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateCollapsedRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Details links from this Generic System to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplateCollapsedRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateCollapsedRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Generic System.
     */
    tags: outputs.GetTemplateCollapsedRackTypeGenericSystemsTag[];
}

export interface GetTemplateCollapsedRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplateCollapsedRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplateCollapsedRackTypeGenericSystemsLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateCollapsedRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateCollapsedRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface GetTemplateCollapsedRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateCollapsedRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateCollapsedRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateCollapsedRackTypeGenericSystemsTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateCollapsedRackTypeLeafSwitches {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Details settings when the Leaf Switch is an MLAG-capable pair.
     */
    mlagInfo: outputs.GetTemplateCollapsedRackTypeLeafSwitchesMlagInfo;
    /**
     * When set, 'the switch' is actually a LAG-capable redundant pair of the given type.
     */
    redundancyProtocol: string;
    /**
     * Number of links to each Spine switch.
     */
    spineLinkCount: number;
    /**
     * Speed of links to Spine switches.
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Leaf Switch.
     */
    tags: outputs.GetTemplateCollapsedRackTypeLeafSwitchesTag[];
}

export interface GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateCollapsedRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount: number;
    /**
     * L3 peer link port-channel ID.
     */
    l3PeerLinkPortChannelId: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Peer link port-channel ID.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface GetTemplateCollapsedRackTypeLeafSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfos {
    /**
     * Number of instances of this Pod Type.
     */
    count: number;
    /**
     * Pod Type attributes cloned from the Global Catalog at creation time.
     */
    podType: outputs.GetTemplatePodBasedPodInfosPodType;
}

export interface GetTemplatePodBasedPodInfosPodType {
    /**
     * "unique" is for 3-stage designs; "single" is for 5-stage designs.
     */
    asnAllocationScheme: string;
    /**
     * Fabric addressing scheme for Spine/Leaf links. Applies only to Apstra 4.1.0.
     */
    fabricLinkAddressing: string;
    /**
     * ID of the pod inside the 5 stage template.
     */
    id: string;
    /**
     * Name of the pod inside the 5 stage template.
     */
    name: string;
    /**
     * Defines the inter-rack virtual network overlay protocol in the fabric.
     */
    overlayControlProtocol: string;
    /**
     * Map of Rack Type info (count + details)
     */
    rackInfos: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfos};
    /**
     * Spine layer details
     */
    spine: outputs.GetTemplatePodBasedPodInfosPodTypeSpine;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfos {
    /**
     * Number of instances of this Rack Type.
     */
    count: number;
    /**
     * Rack Type attributes cloned from the Global Catalog at creation time.
     */
    rackType: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackType;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackType {
    /**
     * A map of Access Switches in this Rack Type, keyed by name.
     */
    accessSwitches: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitches};
    /**
     * Rack Type description displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Indicates designs for which this Rack Type is intended.
     */
    fabricConnectivityDesign: string;
    /**
     * A map of Generic Systems in the Rack Type, keyed by name.
     */
    genericSystems: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystems};
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * A map of Leaf Switches in this Rack Type, keyed by name.
     */
    leafSwitches: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitches};
    /**
     * Rack Type name displayed in the Apstra web UI.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitches {
    /**
     * Count of Access Switches of this type.
     */
    count: number;
    /**
     * Interconnect information for Access Switches in ESI-LAG redundancy mode.
     */
    esiLagInfo: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Details links from this Access Switch to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether 'the switch' is actually a LAG-capable redundant pair and if so, what type.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Access Switch.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesTag[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Details links from this Generic System to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Generic System.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsTag[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitches {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Details settings when the Leaf Switch is an MLAG-capable pair.
     */
    mlagInfo: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesMlagInfo;
    /**
     * When set, 'the switch' is actually a LAG-capable redundant pair of the given type.
     */
    redundancyProtocol: string;
    /**
     * Number of links to each Spine switch.
     */
    spineLinkCount: number;
    /**
     * Speed of links to Spine switches.
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Leaf Switch.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesTag[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount: number;
    /**
     * L3 peer link port-channel ID.
     */
    l3PeerLinkPortChannelId: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Peer link port-channel ID.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeSpine {
    /**
     * Number of Spine switches.
     */
    count: number;
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Count of links to each super Spine switch.
     */
    superSpineLinkCount: number;
    /**
     * Speed of links to super Spine switches.
     */
    superSpineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to the Spine Switches.
     */
    tags: outputs.GetTemplatePodBasedPodInfosPodTypeSpineTag[];
}

export interface GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanel[];
}

export interface GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplatePodBasedPodInfosPodTypeSpineTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplatePodBasedSuperSpine {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplatePodBasedSuperSpineLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Number of Super Spine switches per plane.
     */
    perPlaneCount: number;
    /**
     * Number of planes.
     */
    planeCount: number;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to the Super Spine Switches.
     */
    tags: outputs.GetTemplatePodBasedSuperSpineTag[];
}

export interface GetTemplatePodBasedSuperSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplatePodBasedSuperSpineLogicalDevicePanel[];
}

export interface GetTemplatePodBasedSuperSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplatePodBasedSuperSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplatePodBasedSuperSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplatePodBasedSuperSpineTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfos {
    /**
     * Number of instances of this Rack Type.
     */
    count: number;
    /**
     * Rack Type attributes cloned from the Global Catalog at creation time.
     */
    rackType: outputs.GetTemplateRackBasedRackInfosRackType;
}

export interface GetTemplateRackBasedRackInfosRackType {
    /**
     * A map of Access Switches in this Rack Type, keyed by name.
     */
    accessSwitches: {[key: string]: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitches};
    /**
     * Rack Type description displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Indicates designs for which this Rack Type is intended.
     */
    fabricConnectivityDesign: string;
    /**
     * A map of Generic Systems in the Rack Type, keyed by name.
     */
    genericSystems: {[key: string]: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystems};
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * A map of Leaf Switches in this Rack Type, keyed by name.
     */
    leafSwitches: {[key: string]: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitches};
    /**
     * Rack Type name displayed in the Apstra web UI.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitches {
    /**
     * Count of Access Switches of this type.
     */
    count: number;
    /**
     * Interconnect information for Access Switches in ESI-LAG redundancy mode.
     */
    esiLagInfo: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Details links from this Access Switch to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether 'the switch' is actually a LAG-capable redundant pair and if so, what type.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Access Switch.
     */
    tags: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesTag[];
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeAccessSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Details links from this Generic System to upstream switches within this Rack Type.
     */
    links: {[key: string]: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Generic System.
     */
    tags: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsTag[];
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-LAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Link.
     */
    tags: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsLinksTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeGenericSystemsTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitches {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Details settings when the Leaf Switch is an MLAG-capable pair.
     */
    mlagInfo: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitchesMlagInfo;
    /**
     * When set, 'the switch' is actually a LAG-capable redundant pair of the given type.
     */
    redundancyProtocol: string;
    /**
     * Number of links to each Spine switch.
     */
    spineLinkCount: number;
    /**
     * Speed of links to Spine switches.
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to this Leaf Switch.
     */
    tags: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitchesTag[];
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount: number;
    /**
     * L3 peer link port-channel ID.
     */
    l3PeerLinkPortChannelId: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Peer link port-channel ID.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface GetTemplateRackBasedRackInfosRackTypeLeafSwitchesTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetTemplateRackBasedSpine {
    /**
     * Number of Spine switches.
     */
    count: number;
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.GetTemplateRackBasedSpineLogicalDevice;
    /**
     * ID will always be `<null>` in data source contexts.
     */
    logicalDeviceId: string;
    /**
     * Count of links to each super Spine switch.
     */
    superSpineLinkCount: number;
    /**
     * Speed of links to super Spine switches.
     */
    superSpineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in data source contexts.
     */
    tagIds: string[];
    /**
     * Details any tags applied to the Spine Switches.
     */
    tags: outputs.GetTemplateRackBasedSpineTag[];
}

export interface GetTemplateRackBasedSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.GetTemplateRackBasedSpineLogicalDevicePanel[];
}

export interface GetTemplateRackBasedSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.GetTemplateRackBasedSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface GetTemplateRackBasedSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * Describes the device types to which this port can connect.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface GetTemplateRackBasedSpineTag {
    /**
     * Tag description.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name.
     */
    name: string;
}

export interface GetVniPoolRange {
    /**
     * Lowest numbered ID in this VNI Pool Range.
     */
    first: number;
    /**
     * Highest numbered ID in this VNI Pool Range.
     */
    last: number;
    /**
     * Status of the VNI Pool Range, as reported by Apstra.
     */
    status: string;
    /**
     * Total number of IDs in the VNI Pool Range.
     */
    total: number;
    /**
     * Count of used VNIs in the VNI Pool Range.
     */
    used: number;
    /**
     * Percent of used IDs in the VNI Pool Range.
     */
    usedPercentage: number;
}

export interface IntegerPoolRange {
    first: number;
    last: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    status: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    total: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    used: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    usedPercentage: number;
}

export interface InterfaceMapInterface {
    /**
     * Panel and Port number of logical device expressed in the form "<panel>/<port>". Both numbers are 1-indexed, so the 2nd port on the 1st panel would be "1/2".
     */
    logicalDevicePort: string;
    /**
     * Interface name found in the Device Profile, e.g. "et-0/0/1:2"
     */
    physicalInterfaceName: string;
    /**
     * Transformation ID number identifying the desired port behavior, detailed in the Device Profile. Required only when multiple transformation candidates are found for a given physical_interface_name and speed as determined by definitions found the Logical Device definition and logical_device_port field.
     */
    transformationId: number;
}

export interface InterfaceMapUnusedInterface {
    /**
     * Panel and Port number of logical device expressed in the form "<panel>/<port>". Both numbers are 1-indexed, so the 2nd port on the 1st panel would be "1/2".
     */
    logicalDevicePort: string;
    /**
     * Interface name found in the Device Profile, e.g. "et-0/0/1:2"
     */
    physicalInterfaceName: string;
    /**
     * Transformation ID number identifying the desired port behavior, as found in the Device Profile.
     */
    transformationId: number;
}

export interface Ipv4PoolSubnet {
    /**
     * Network specification in CIDR syntax ("192.0.2.0/24").
     */
    network: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    status: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    total: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    used: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    usedPercentage: number;
}

export interface Ipv6PoolSubnet {
    /**
     * Network specification in CIDR syntax ("2001:db8::/64").
     */
    network: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    status: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    total: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    used: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    usedPercentage: number;
}

export interface LogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.LogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface LogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: 'spine', 'superspine', 'leaf', 'access', 'l3_server', 'peer', 'unused', 'generic', by default all values except 'unused' are selected
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface RackTypeAccessSwitches {
    /**
     * Number of Access Switches of this type.
     */
    count: number;
    /**
     * Including this stanza converts the Access Switch into a redundant pair.
     */
    esiLagInfo?: outputs.RackTypeAccessSwitchesEsiLagInfo;
    /**
     * Each Access Switch is required to have at least one Link to a Leaf Switch.
     */
    links: {[key: string]: outputs.RackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.RackTypeAccessSwitchesLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Access Switch.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether the switch is a redundant pair.
     */
    redundancyProtocol: string;
    /**
     * Set of Tag IDs to be applied to this Access Switch
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to this Access Switch
     */
    tags: outputs.RackTypeAccessSwitchesTag[];
}

export interface RackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface RackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * Set of Tag IDs to be applied to this Link
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.RackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface RackTypeAccessSwitchesLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface RackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.RackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface RackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.RackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface RackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface RackTypeAccessSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface RackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Each Generic System is required to have at least one Link to a Leaf Switch or Access Switch.
     */
    links: {[key: string]: outputs.RackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.RackTypeGenericSystemsLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Generic System.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * Set of Tag IDs to be applied to this Generic System
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to this Generic System
     */
    tags: outputs.RackTypeGenericSystemsTag[];
}

export interface RackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * Set of Tag IDs to be applied to this Link
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.RackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface RackTypeGenericSystemsLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface RackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.RackTypeGenericSystemsLogicalDevicePanel[];
}

export interface RackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.RackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface RackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface RackTypeGenericSystemsTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface RackTypeLeafSwitches {
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.RackTypeLeafSwitchesLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Leaf Switch.
     */
    logicalDeviceId: string;
    /**
     * Required when `redundancy_protocol` set to `mlag`, defines the connectivity between MLAG peers.
     */
    mlagInfo?: outputs.RackTypeLeafSwitchesMlagInfo;
    /**
     * Enabling a redundancy protocol converts a single Leaf Switch into a LAG-capable switch pair. Must be one of 'esi', 'mlag'.
     */
    redundancyProtocol?: string;
    /**
     * Links per Spine.
     */
    spineLinkCount: number;
    /**
     * Speed of Spine-facing links, something like '10G'
     */
    spineLinkSpeed?: string;
    /**
     * Set of Tag IDs to be applied to this Leaf Switch
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to this Leaf Switch
     */
    tags: outputs.RackTypeLeafSwitchesTag[];
}

export interface RackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.RackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface RackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.RackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface RackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface RackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount?: number;
    /**
     * Port channel number used for L3 Peer Link. Omit to allow Apstra to choose.
     */
    l3PeerLinkPortChannelId?: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed?: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Port channel number used for L2 Peer Link.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface RackTypeLeafSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackType {
    /**
     * Access Switches are optional, link to Leaf Switches in the same rack
     */
    accessSwitches: {[key: string]: outputs.TemplateCollapsedRackTypeAccessSwitches};
    /**
     * Rack Type description, displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Must be one of 'l3clos', 'l3collapsed'.
     */
    fabricConnectivityDesign: string;
    /**
     * Generic Systems are optional rack elements notmanaged by Apstra: Servers, routers, firewalls, etc...
     */
    genericSystems: {[key: string]: outputs.TemplateCollapsedRackTypeGenericSystems};
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Each Rack Type is required to have at least one Leaf Switch.
     */
    leafSwitches: {[key: string]: outputs.TemplateCollapsedRackTypeLeafSwitches};
    /**
     * Rack Type name, displayed in the Apstra web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackTypeAccessSwitches {
    /**
     * Number of Access Switches of this type.
     */
    count: number;
    /**
     * Defines connectivity between ESI LAG peers when `redundancy_protocol` is set to `esi`.
     */
    esiLagInfo: outputs.TemplateCollapsedRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Each Access Switch is required to have at least one Link to a Leaf Switch.
     */
    links: {[key: string]: outputs.TemplateCollapsedRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateCollapsedRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether the switch is a redundant pair.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Access Switch
     */
    tags: outputs.TemplateCollapsedRackTypeAccessSwitchesTag[];
}

export interface TemplateCollapsedRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface TemplateCollapsedRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplateCollapsedRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplateCollapsedRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface TemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateCollapsedRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateCollapsedRackTypeAccessSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Each Generic System is required to have at least one Link to a Leaf Switch or Access Switch.
     */
    links: {[key: string]: outputs.TemplateCollapsedRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateCollapsedRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Generic System
     */
    tags: outputs.TemplateCollapsedRackTypeGenericSystemsTag[];
}

export interface TemplateCollapsedRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplateCollapsedRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplateCollapsedRackTypeGenericSystemsLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateCollapsedRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface TemplateCollapsedRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateCollapsedRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateCollapsedRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateCollapsedRackTypeGenericSystemsTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateCollapsedRackTypeLeafSwitches {
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateCollapsedRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Defines connectivity between MLAG peers when `redundancy_protocol` is set to `mlag`.
     */
    mlagInfo: outputs.TemplateCollapsedRackTypeLeafSwitchesMlagInfo;
    /**
     * Enabling a redundancy protocol converts a single Leaf Switch into a LAG-capable switch pair. Must be one of 'esi', 'mlag'.
     */
    redundancyProtocol: string;
    /**
     * Links per Spine.
     */
    spineLinkCount: number;
    /**
     * Speed of Spine-facing links, something like '10G'
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Leaf Switch
     */
    tags: outputs.TemplateCollapsedRackTypeLeafSwitchesTag[];
}

export interface TemplateCollapsedRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface TemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateCollapsedRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateCollapsedRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount?: number;
    /**
     * Port channel number used for L3 Peer Link. Omit to allow Apstra to choose.
     */
    l3PeerLinkPortChannelId?: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed?: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Port channel number used for L2 Peer Link.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface TemplateCollapsedRackTypeLeafSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfos {
    /**
     * Number of instances of this Pod Type.
     */
    count: number;
    /**
     * Pod Type attributes cloned from the Global Catalog at creation time.
     */
    podType: outputs.TemplatePodBasedPodInfosPodType;
}

export interface TemplatePodBasedPodInfosPodType {
    /**
     * "unique" is for 3-stage designs; "single" is for 5-stage designs.
     */
    asnAllocationScheme: string;
    /**
     * Fabric addressing scheme for Spine/Leaf links. Applies only to Apstra 4.1.0.
     */
    fabricLinkAddressing: string;
    /**
     * ID of the pod inside the 5 stage template.
     */
    id: string;
    /**
     * Name of the pod inside the 5 stage template.
     */
    name: string;
    /**
     * Defines the inter-rack virtual network overlay protocol in the fabric.
     */
    overlayControlProtocol: string;
    /**
     * Map of Rack Type info (count + details)
     */
    rackInfos: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfos};
    /**
     * Spine layer details
     */
    spine: outputs.TemplatePodBasedPodInfosPodTypeSpine;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfos {
    /**
     * Number of instances of this Rack Type.
     */
    count: number;
    /**
     * Rack Type attributes cloned from the Global Catalog at creation time.
     */
    rackType: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackType;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackType {
    /**
     * Access Switches are optional, link to Leaf Switches in the same rack
     */
    accessSwitches: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitches};
    /**
     * Rack Type description, displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Must be one of 'l3clos', 'l3collapsed'.
     */
    fabricConnectivityDesign: string;
    /**
     * Generic Systems are optional rack elements notmanaged by Apstra: Servers, routers, firewalls, etc...
     */
    genericSystems: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystems};
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Each Rack Type is required to have at least one Leaf Switch.
     */
    leafSwitches: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitches};
    /**
     * Rack Type name, displayed in the Apstra web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitches {
    /**
     * Number of Access Switches of this type.
     */
    count: number;
    /**
     * Defines connectivity between ESI LAG peers when `redundancy_protocol` is set to `esi`.
     */
    esiLagInfo: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Each Access Switch is required to have at least one Link to a Leaf Switch.
     */
    links: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether the switch is a redundant pair.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Access Switch
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesTag[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeAccessSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Each Generic System is required to have at least one Link to a Leaf Switch or Access Switch.
     */
    links: {[key: string]: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Generic System
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsTag[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeGenericSystemsTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitches {
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Defines connectivity between MLAG peers when `redundancy_protocol` is set to `mlag`.
     */
    mlagInfo: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesMlagInfo;
    /**
     * Enabling a redundancy protocol converts a single Leaf Switch into a LAG-capable switch pair. Must be one of 'esi', 'mlag'.
     */
    redundancyProtocol: string;
    /**
     * Links per Spine.
     */
    spineLinkCount: number;
    /**
     * Speed of Spine-facing links, something like '10G'
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Leaf Switch
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesTag[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount?: number;
    /**
     * Port channel number used for L3 Peer Link. Omit to allow Apstra to choose.
     */
    l3PeerLinkPortChannelId?: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed?: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Port channel number used for L2 Peer Link.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeRackInfosRackTypeLeafSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedPodInfosPodTypeSpine {
    /**
     * Number of Spine Switches.
     */
    count: number;
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.TemplatePodBasedPodInfosPodTypeSpineLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Spine Switch.
     */
    logicalDeviceId: string;
    /**
     * Count of links to each super Spine switch.
     */
    superSpineLinkCount?: number;
    /**
     * Speed of links to super Spine switches.
     */
    superSpineLinkSpeed?: string;
    /**
     * Set of Tag IDs to be applied to Spine Switches
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to Spine Switches
     */
    tags: outputs.TemplatePodBasedPodInfosPodTypeSpineTag[];
}

export interface TemplatePodBasedPodInfosPodTypeSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanel[];
}

export interface TemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplatePodBasedPodInfosPodTypeSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplatePodBasedPodInfosPodTypeSpineTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplatePodBasedSuperSpine {
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.TemplatePodBasedSuperSpineLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Spine Switch.
     */
    logicalDeviceId: string;
    /**
     * Number of Super Spine switches per plane.
     */
    perPlaneCount: number;
    /**
     * Permits creation of multi-planar 5-stage topologies. Default: 1
     */
    planeCount: number;
    /**
     * Set of Tag IDs to be applied to SuperSpine Switches
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to SuperSpine Switches
     */
    tags: outputs.TemplatePodBasedSuperSpineTag[];
}

export interface TemplatePodBasedSuperSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplatePodBasedSuperSpineLogicalDevicePanel[];
}

export interface TemplatePodBasedSuperSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplatePodBasedSuperSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplatePodBasedSuperSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplatePodBasedSuperSpineTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfos {
    /**
     * Number of instances of this Rack Type.
     */
    count: number;
    /**
     * Rack Type attributes cloned from the Global Catalog at creation time.
     */
    rackType: outputs.TemplateRackBasedRackInfosRackType;
}

export interface TemplateRackBasedRackInfosRackType {
    /**
     * Access Switches are optional, link to Leaf Switches in the same rack
     */
    accessSwitches: {[key: string]: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitches};
    /**
     * Rack Type description, displayed in the Apstra web UI.
     */
    description: string;
    /**
     * Must be one of 'l3clos', 'l3collapsed'.
     */
    fabricConnectivityDesign: string;
    /**
     * Generic Systems are optional rack elements notmanaged by Apstra: Servers, routers, firewalls, etc...
     */
    genericSystems: {[key: string]: outputs.TemplateRackBasedRackInfosRackTypeGenericSystems};
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Each Rack Type is required to have at least one Leaf Switch.
     */
    leafSwitches: {[key: string]: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitches};
    /**
     * Rack Type name, displayed in the Apstra web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitches {
    /**
     * Number of Access Switches of this type.
     */
    count: number;
    /**
     * Defines connectivity between ESI LAG peers when `redundancy_protocol` is set to `esi`.
     */
    esiLagInfo: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesEsiLagInfo;
    /**
     * Each Access Switch is required to have at least one Link to a Leaf Switch.
     */
    links: {[key: string]: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Indicates whether the switch is a redundant pair.
     */
    redundancyProtocol: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Access Switch
     */
    tags: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesTag[];
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesEsiLagInfo {
    /**
     * Count of L3 links between ESI peers.
     */
    l3PeerLinkCount: number;
    /**
     * Speed of L3 links between ESI peers.
     */
    l3PeerLinkSpeed: string;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanel[];
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateRackBasedRackInfosRackTypeAccessSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystems {
    /**
     * Number of Generic Systems of this type.
     */
    count: number;
    /**
     * Each Generic System is required to have at least one Link to a Leaf Switch or Access Switch.
     */
    links: {[key: string]: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsLinks};
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMax: number;
    /**
     * Port channel IDs are used when rendering leaf device port-channel configuration towards generic systems.
     */
    portChannelIdMin: number;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Generic System
     */
    tags: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsTag[];
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsLinks {
    /**
     * LAG negotiation mode of the Link.
     */
    lagMode: string;
    /**
     * Number of Links to each switch.
     */
    linksPerSwitch: number;
    /**
     * Speed of this Link.
     */
    speed: string;
    /**
     * For non-lAG connections to redundant switch pairs, this field selects the target switch.
     */
    switchPeer: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Link
     */
    tags: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsLinksTag[];
    /**
     * The `name` of the switch in this Rack Type to which this Link connects.
     */
    targetSwitchName: string;
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsLinksTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description?: string;
    /**
     * Apstra ID of the Tag.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanel[];
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateRackBasedRackInfosRackTypeGenericSystemsTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitches {
    /**
     * Logical Device attributes cloned from the Global Catalog at creation time.
     */
    logicalDevice: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevice;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    logicalDeviceId: string;
    /**
     * Defines connectivity between MLAG peers when `redundancy_protocol` is set to `mlag`.
     */
    mlagInfo: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitchesMlagInfo;
    /**
     * Enabling a redundancy protocol converts a single Leaf Switch into a LAG-capable switch pair. Must be one of 'esi', 'mlag'.
     */
    redundancyProtocol: string;
    /**
     * Links per Spine.
     */
    spineLinkCount: number;
    /**
     * Speed of Spine-facing links, something like '10G'
     */
    spineLinkSpeed: string;
    /**
     * IDs will always be `<null>` in nested contexts.
     */
    tagIds: string[];
    /**
     * Set of Tags (Name + Description) applied to this Leaf Switch
     */
    tags: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitchesTag[];
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanel[];
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitchesLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitchesMlagInfo {
    /**
     * Number of L3 links between MLAG devices.
     */
    l3PeerLinkCount?: number;
    /**
     * Port channel number used for L3 Peer Link. Omit to allow Apstra to choose.
     */
    l3PeerLinkPortChannelId?: number;
    /**
     * Speed of l3 links between MLAG devices.
     */
    l3PeerLinkSpeed?: string;
    /**
     * MLAG keepalive VLAN ID.
     */
    mlagKeepaliveVlan: number;
    /**
     * Number of links between MLAG devices.
     */
    peerLinkCount: number;
    /**
     * Port channel number used for L2 Peer Link.
     */
    peerLinkPortChannelId: number;
    /**
     * Speed of links between MLAG devices.
     */
    peerLinkSpeed: string;
}

export interface TemplateRackBasedRackInfosRackTypeLeafSwitchesTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface TemplateRackBasedSpine {
    /**
     * Number of Spine Switches.
     */
    count: number;
    /**
     * Logical Device attributes as represented in the Global Catalog.
     */
    logicalDevice: outputs.TemplateRackBasedSpineLogicalDevice;
    /**
     * Apstra Object ID of the Logical Device used to model this Spine Switch.
     */
    logicalDeviceId: string;
    /**
     * Count of links to each super Spine switch.
     */
    superSpineLinkCount?: number;
    /**
     * Speed of links to super Spine switches.
     */
    superSpineLinkSpeed?: string;
    /**
     * Set of Tag IDs to be applied to Spine Switches
     */
    tagIds?: string[];
    /**
     * Set of Tags (Name + Description) applied to Spine Switches
     */
    tags: outputs.TemplateRackBasedSpineTag[];
}

export interface TemplateRackBasedSpineLogicalDevice {
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Logical device display name.
     */
    name: string;
    /**
     * Details physical layout of interfaces on the device.
     */
    panels: outputs.TemplateRackBasedSpineLogicalDevicePanel[];
}

export interface TemplateRackBasedSpineLogicalDevicePanel {
    /**
     * Physical horizontal dimension of the panel.
     */
    columns: number;
    /**
     * Ordered logical groupings of interfaces by speed or purpose within a panel
     */
    portGroups: outputs.TemplateRackBasedSpineLogicalDevicePanelPortGroup[];
    /**
     * Physical vertical dimension of the panel.
     */
    rows: number;
}

export interface TemplateRackBasedSpineLogicalDevicePanelPortGroup {
    /**
     * Number of ports in the group.
     */
    portCount: number;
    /**
     * One or more of: access, generic, l3_server, leaf, peer, server, spine, superspine and unused.
     */
    portRoles: string[];
    /**
     * Port speed.
     */
    portSpeed: string;
}

export interface TemplateRackBasedSpineTag {
    /**
     * Tag description field as seen in the web UI.
     */
    description: string;
    /**
     * ID will always be `<null>` in nested contexts.
     */
    id: string;
    /**
     * Tag name field as seen in the web UI.
     */
    name: string;
}

export interface VniPoolRange {
    first: number;
    last: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    status: string;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    total: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    used: number;
    /**
     * Mutable read-only is always null in a Resource. Use the matching Data Source for this information.
     */
    usedPercentage: number;
}

