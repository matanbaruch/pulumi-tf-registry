// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class NrqlAlertCondition extends pulumi.CustomResource {
    /**
     * Get an existing NrqlAlertCondition resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: NrqlAlertConditionState, opts?: pulumi.CustomResourceOptions): NrqlAlertCondition {
        return new NrqlAlertCondition(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'newrelic:index/nrqlAlertCondition:NrqlAlertCondition';

    /**
     * Returns true if the given object is an instance of NrqlAlertCondition.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is NrqlAlertCondition {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === NrqlAlertCondition.__pulumiType;
    }

    /**
     * The New Relic account ID for managing your NRQL alert conditions.
     */
    public readonly accountId!: pulumi.Output<number>;
    /**
     * How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase
     * accuracy but delay notifications. Use aggregationDelay with the EVENT_FLOW and CADENCE aggregation methods.
     */
    public readonly aggregationDelay!: pulumi.Output<string | undefined>;
    /**
     * The method that determines when we consider an aggregation window to be complete so that we can evaluate the signal for
     * incidents. Default is EVENT_FLOW.
     */
    public readonly aggregationMethod!: pulumi.Output<string | undefined>;
    /**
     * How long we wait after each data point arrives to make sure we've processed the whole batch. Use aggregationTimer with
     * the EVENT_TIMER aggregation method.
     */
    public readonly aggregationTimer!: pulumi.Output<string | undefined>;
    /**
     * The duration of the time window used to evaluate the NRQL query, in seconds.
     */
    public readonly aggregationWindow!: pulumi.Output<number>;
    /**
     * The baseline direction of a baseline NRQL alert condition. Valid values are: 'LOWER_ONLY', 'UPPER_AND_LOWER',
     * 'UPPER_ONLY' (case insensitive).
     */
    public readonly baselineDirection!: pulumi.Output<string | undefined>;
    /**
     * Whether to close all open incidents when the signal expires.
     */
    public readonly closeViolationsOnExpiration!: pulumi.Output<boolean | undefined>;
    /**
     * A condition term with priority set to critical.
     */
    public readonly critical!: pulumi.Output<outputs.NrqlAlertConditionCritical | undefined>;
    /**
     * The description of the NRQL alert condition.
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * Whether or not to enable the alert condition.
     */
    public readonly enabled!: pulumi.Output<boolean | undefined>;
    /**
     * The unique entity identifier of the NRQL Condition in New Relic.
     */
    public /*out*/ readonly entityGuid!: pulumi.Output<string>;
    /**
     * How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes)
     */
    public readonly evaluationDelay!: pulumi.Output<number | undefined>;
    /**
     * The amount of time (in seconds) to wait before considering the signal expired. Must be in the range of 30 to 172800
     * (inclusive)
     */
    public readonly expirationDuration!: pulumi.Output<number | undefined>;
    /**
     * Which strategy to use when filling gaps in the signal. If static, the 'fill value' will be used for filling gaps in the
     * signal. Valid values are: 'NONE', 'LAST_VALUE', or 'STATIC' (case insensitive).
     */
    public readonly fillOption!: pulumi.Output<string | undefined>;
    /**
     * If using the 'static' fill option, this value will be used for filling gaps in the signal.
     */
    public readonly fillValue!: pulumi.Output<number | undefined>;
    /**
     * Whether to ignore expected termination of a signal when considering whether to create a loss of signal incident
     */
    public readonly ignoreOnExpectedTermination!: pulumi.Output<boolean | undefined>;
    /**
     * The title of the condition.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * A NRQL query.
     */
    public readonly nrql!: pulumi.Output<outputs.NrqlAlertConditionNrql>;
    /**
     * Whether to create a new incident to capture that the signal expired.
     */
    public readonly openViolationOnExpiration!: pulumi.Output<boolean | undefined>;
    /**
     * The ID of the policy where this condition should be used.
     */
    public readonly policyId!: pulumi.Output<number>;
    /**
     * Runbook URL to display in notifications.
     */
    public readonly runbookUrl!: pulumi.Output<string | undefined>;
    /**
     * The duration of overlapping time windows used to smooth the chart line, in seconds. Must be a factor of
     * `aggregation_window` and less than the aggregation window. If `aggregation_window` is less than or equal to 3600
     * seconds, it should be greater or equal to 30 seconds. If `aggregation_window` is greater than 3600 seconds but less than
     * 7200 seconds, it should be greater or equal to `aggregation_window / 120`. If `aggregation_window` is greater than 7200
     * seconds, it should be greater or equal to `aggregation_window / 24
     */
    public readonly slideBy!: pulumi.Output<number | undefined>;
    /**
     * A set of terms for this condition. Max 2 terms allowed - at least one 1 critical term and 1 optional warning term.
     *
     * @deprecated Deprecated
     */
    public readonly terms!: pulumi.Output<outputs.NrqlAlertConditionTerm[] | undefined>;
    public readonly timeouts!: pulumi.Output<outputs.NrqlAlertConditionTimeouts | undefined>;
    /**
     * This field allows you to create a custom title to be used when incidents are opened by the condition. Setting this field
     * will override the default title. Must be Handlebars format.
     */
    public readonly titleTemplate!: pulumi.Output<string | undefined>;
    /**
     * The type of NRQL alert condition to create. Valid values are: 'static', 'baseline'.
     */
    public readonly type!: pulumi.Output<string | undefined>;
    /**
     * Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you
     * select. Possible values are 'ONE_HOUR', 'TWO_HOURS', 'FOUR_HOURS', 'EIGHT_HOURS', 'TWELVE_HOURS', 'TWENTY_FOUR_HOURS',
     * 'THIRTY_DAYS' (case insensitive).
     *
     * @deprecated Deprecated
     */
    public readonly violationTimeLimit!: pulumi.Output<string>;
    /**
     * Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you
     * select. Must be in the range of 300 to 2592000 (inclusive)
     */
    public readonly violationTimeLimitSeconds!: pulumi.Output<number | undefined>;
    /**
     * A condition term with priority set to warning.
     */
    public readonly warning!: pulumi.Output<outputs.NrqlAlertConditionWarning | undefined>;

    /**
     * Create a NrqlAlertCondition resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: NrqlAlertConditionArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: NrqlAlertConditionArgs | NrqlAlertConditionState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as NrqlAlertConditionState | undefined;
            resourceInputs["accountId"] = state ? state.accountId : undefined;
            resourceInputs["aggregationDelay"] = state ? state.aggregationDelay : undefined;
            resourceInputs["aggregationMethod"] = state ? state.aggregationMethod : undefined;
            resourceInputs["aggregationTimer"] = state ? state.aggregationTimer : undefined;
            resourceInputs["aggregationWindow"] = state ? state.aggregationWindow : undefined;
            resourceInputs["baselineDirection"] = state ? state.baselineDirection : undefined;
            resourceInputs["closeViolationsOnExpiration"] = state ? state.closeViolationsOnExpiration : undefined;
            resourceInputs["critical"] = state ? state.critical : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["enabled"] = state ? state.enabled : undefined;
            resourceInputs["entityGuid"] = state ? state.entityGuid : undefined;
            resourceInputs["evaluationDelay"] = state ? state.evaluationDelay : undefined;
            resourceInputs["expirationDuration"] = state ? state.expirationDuration : undefined;
            resourceInputs["fillOption"] = state ? state.fillOption : undefined;
            resourceInputs["fillValue"] = state ? state.fillValue : undefined;
            resourceInputs["ignoreOnExpectedTermination"] = state ? state.ignoreOnExpectedTermination : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["nrql"] = state ? state.nrql : undefined;
            resourceInputs["openViolationOnExpiration"] = state ? state.openViolationOnExpiration : undefined;
            resourceInputs["policyId"] = state ? state.policyId : undefined;
            resourceInputs["runbookUrl"] = state ? state.runbookUrl : undefined;
            resourceInputs["slideBy"] = state ? state.slideBy : undefined;
            resourceInputs["terms"] = state ? state.terms : undefined;
            resourceInputs["timeouts"] = state ? state.timeouts : undefined;
            resourceInputs["titleTemplate"] = state ? state.titleTemplate : undefined;
            resourceInputs["type"] = state ? state.type : undefined;
            resourceInputs["violationTimeLimit"] = state ? state.violationTimeLimit : undefined;
            resourceInputs["violationTimeLimitSeconds"] = state ? state.violationTimeLimitSeconds : undefined;
            resourceInputs["warning"] = state ? state.warning : undefined;
        } else {
            const args = argsOrState as NrqlAlertConditionArgs | undefined;
            if ((!args || args.nrql === undefined) && !opts.urn) {
                throw new Error("Missing required property 'nrql'");
            }
            if ((!args || args.policyId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'policyId'");
            }
            resourceInputs["accountId"] = args ? args.accountId : undefined;
            resourceInputs["aggregationDelay"] = args ? args.aggregationDelay : undefined;
            resourceInputs["aggregationMethod"] = args ? args.aggregationMethod : undefined;
            resourceInputs["aggregationTimer"] = args ? args.aggregationTimer : undefined;
            resourceInputs["aggregationWindow"] = args ? args.aggregationWindow : undefined;
            resourceInputs["baselineDirection"] = args ? args.baselineDirection : undefined;
            resourceInputs["closeViolationsOnExpiration"] = args ? args.closeViolationsOnExpiration : undefined;
            resourceInputs["critical"] = args ? args.critical : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["enabled"] = args ? args.enabled : undefined;
            resourceInputs["evaluationDelay"] = args ? args.evaluationDelay : undefined;
            resourceInputs["expirationDuration"] = args ? args.expirationDuration : undefined;
            resourceInputs["fillOption"] = args ? args.fillOption : undefined;
            resourceInputs["fillValue"] = args ? args.fillValue : undefined;
            resourceInputs["ignoreOnExpectedTermination"] = args ? args.ignoreOnExpectedTermination : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["nrql"] = args ? args.nrql : undefined;
            resourceInputs["openViolationOnExpiration"] = args ? args.openViolationOnExpiration : undefined;
            resourceInputs["policyId"] = args ? args.policyId : undefined;
            resourceInputs["runbookUrl"] = args ? args.runbookUrl : undefined;
            resourceInputs["slideBy"] = args ? args.slideBy : undefined;
            resourceInputs["terms"] = args ? args.terms : undefined;
            resourceInputs["timeouts"] = args ? args.timeouts : undefined;
            resourceInputs["titleTemplate"] = args ? args.titleTemplate : undefined;
            resourceInputs["type"] = args ? args.type : undefined;
            resourceInputs["violationTimeLimit"] = args ? args.violationTimeLimit : undefined;
            resourceInputs["violationTimeLimitSeconds"] = args ? args.violationTimeLimitSeconds : undefined;
            resourceInputs["warning"] = args ? args.warning : undefined;
            resourceInputs["entityGuid"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(NrqlAlertCondition.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering NrqlAlertCondition resources.
 */
export interface NrqlAlertConditionState {
    /**
     * The New Relic account ID for managing your NRQL alert conditions.
     */
    accountId?: pulumi.Input<number>;
    /**
     * How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase
     * accuracy but delay notifications. Use aggregationDelay with the EVENT_FLOW and CADENCE aggregation methods.
     */
    aggregationDelay?: pulumi.Input<string>;
    /**
     * The method that determines when we consider an aggregation window to be complete so that we can evaluate the signal for
     * incidents. Default is EVENT_FLOW.
     */
    aggregationMethod?: pulumi.Input<string>;
    /**
     * How long we wait after each data point arrives to make sure we've processed the whole batch. Use aggregationTimer with
     * the EVENT_TIMER aggregation method.
     */
    aggregationTimer?: pulumi.Input<string>;
    /**
     * The duration of the time window used to evaluate the NRQL query, in seconds.
     */
    aggregationWindow?: pulumi.Input<number>;
    /**
     * The baseline direction of a baseline NRQL alert condition. Valid values are: 'LOWER_ONLY', 'UPPER_AND_LOWER',
     * 'UPPER_ONLY' (case insensitive).
     */
    baselineDirection?: pulumi.Input<string>;
    /**
     * Whether to close all open incidents when the signal expires.
     */
    closeViolationsOnExpiration?: pulumi.Input<boolean>;
    /**
     * A condition term with priority set to critical.
     */
    critical?: pulumi.Input<inputs.NrqlAlertConditionCritical>;
    /**
     * The description of the NRQL alert condition.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether or not to enable the alert condition.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * The unique entity identifier of the NRQL Condition in New Relic.
     */
    entityGuid?: pulumi.Input<string>;
    /**
     * How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes)
     */
    evaluationDelay?: pulumi.Input<number>;
    /**
     * The amount of time (in seconds) to wait before considering the signal expired. Must be in the range of 30 to 172800
     * (inclusive)
     */
    expirationDuration?: pulumi.Input<number>;
    /**
     * Which strategy to use when filling gaps in the signal. If static, the 'fill value' will be used for filling gaps in the
     * signal. Valid values are: 'NONE', 'LAST_VALUE', or 'STATIC' (case insensitive).
     */
    fillOption?: pulumi.Input<string>;
    /**
     * If using the 'static' fill option, this value will be used for filling gaps in the signal.
     */
    fillValue?: pulumi.Input<number>;
    /**
     * Whether to ignore expected termination of a signal when considering whether to create a loss of signal incident
     */
    ignoreOnExpectedTermination?: pulumi.Input<boolean>;
    /**
     * The title of the condition.
     */
    name?: pulumi.Input<string>;
    /**
     * A NRQL query.
     */
    nrql?: pulumi.Input<inputs.NrqlAlertConditionNrql>;
    /**
     * Whether to create a new incident to capture that the signal expired.
     */
    openViolationOnExpiration?: pulumi.Input<boolean>;
    /**
     * The ID of the policy where this condition should be used.
     */
    policyId?: pulumi.Input<number>;
    /**
     * Runbook URL to display in notifications.
     */
    runbookUrl?: pulumi.Input<string>;
    /**
     * The duration of overlapping time windows used to smooth the chart line, in seconds. Must be a factor of
     * `aggregation_window` and less than the aggregation window. If `aggregation_window` is less than or equal to 3600
     * seconds, it should be greater or equal to 30 seconds. If `aggregation_window` is greater than 3600 seconds but less than
     * 7200 seconds, it should be greater or equal to `aggregation_window / 120`. If `aggregation_window` is greater than 7200
     * seconds, it should be greater or equal to `aggregation_window / 24
     */
    slideBy?: pulumi.Input<number>;
    /**
     * A set of terms for this condition. Max 2 terms allowed - at least one 1 critical term and 1 optional warning term.
     *
     * @deprecated Deprecated
     */
    terms?: pulumi.Input<pulumi.Input<inputs.NrqlAlertConditionTerm>[]>;
    timeouts?: pulumi.Input<inputs.NrqlAlertConditionTimeouts>;
    /**
     * This field allows you to create a custom title to be used when incidents are opened by the condition. Setting this field
     * will override the default title. Must be Handlebars format.
     */
    titleTemplate?: pulumi.Input<string>;
    /**
     * The type of NRQL alert condition to create. Valid values are: 'static', 'baseline'.
     */
    type?: pulumi.Input<string>;
    /**
     * Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you
     * select. Possible values are 'ONE_HOUR', 'TWO_HOURS', 'FOUR_HOURS', 'EIGHT_HOURS', 'TWELVE_HOURS', 'TWENTY_FOUR_HOURS',
     * 'THIRTY_DAYS' (case insensitive).
     *
     * @deprecated Deprecated
     */
    violationTimeLimit?: pulumi.Input<string>;
    /**
     * Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you
     * select. Must be in the range of 300 to 2592000 (inclusive)
     */
    violationTimeLimitSeconds?: pulumi.Input<number>;
    /**
     * A condition term with priority set to warning.
     */
    warning?: pulumi.Input<inputs.NrqlAlertConditionWarning>;
}

/**
 * The set of arguments for constructing a NrqlAlertCondition resource.
 */
export interface NrqlAlertConditionArgs {
    /**
     * The New Relic account ID for managing your NRQL alert conditions.
     */
    accountId?: pulumi.Input<number>;
    /**
     * How long we wait for data that belongs in each aggregation window. Depending on your data, a longer delay may increase
     * accuracy but delay notifications. Use aggregationDelay with the EVENT_FLOW and CADENCE aggregation methods.
     */
    aggregationDelay?: pulumi.Input<string>;
    /**
     * The method that determines when we consider an aggregation window to be complete so that we can evaluate the signal for
     * incidents. Default is EVENT_FLOW.
     */
    aggregationMethod?: pulumi.Input<string>;
    /**
     * How long we wait after each data point arrives to make sure we've processed the whole batch. Use aggregationTimer with
     * the EVENT_TIMER aggregation method.
     */
    aggregationTimer?: pulumi.Input<string>;
    /**
     * The duration of the time window used to evaluate the NRQL query, in seconds.
     */
    aggregationWindow?: pulumi.Input<number>;
    /**
     * The baseline direction of a baseline NRQL alert condition. Valid values are: 'LOWER_ONLY', 'UPPER_AND_LOWER',
     * 'UPPER_ONLY' (case insensitive).
     */
    baselineDirection?: pulumi.Input<string>;
    /**
     * Whether to close all open incidents when the signal expires.
     */
    closeViolationsOnExpiration?: pulumi.Input<boolean>;
    /**
     * A condition term with priority set to critical.
     */
    critical?: pulumi.Input<inputs.NrqlAlertConditionCritical>;
    /**
     * The description of the NRQL alert condition.
     */
    description?: pulumi.Input<string>;
    /**
     * Whether or not to enable the alert condition.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * How long we wait until the signal starts evaluating. The maximum delay is 7200 seconds (120 minutes)
     */
    evaluationDelay?: pulumi.Input<number>;
    /**
     * The amount of time (in seconds) to wait before considering the signal expired. Must be in the range of 30 to 172800
     * (inclusive)
     */
    expirationDuration?: pulumi.Input<number>;
    /**
     * Which strategy to use when filling gaps in the signal. If static, the 'fill value' will be used for filling gaps in the
     * signal. Valid values are: 'NONE', 'LAST_VALUE', or 'STATIC' (case insensitive).
     */
    fillOption?: pulumi.Input<string>;
    /**
     * If using the 'static' fill option, this value will be used for filling gaps in the signal.
     */
    fillValue?: pulumi.Input<number>;
    /**
     * Whether to ignore expected termination of a signal when considering whether to create a loss of signal incident
     */
    ignoreOnExpectedTermination?: pulumi.Input<boolean>;
    /**
     * The title of the condition.
     */
    name?: pulumi.Input<string>;
    /**
     * A NRQL query.
     */
    nrql: pulumi.Input<inputs.NrqlAlertConditionNrql>;
    /**
     * Whether to create a new incident to capture that the signal expired.
     */
    openViolationOnExpiration?: pulumi.Input<boolean>;
    /**
     * The ID of the policy where this condition should be used.
     */
    policyId: pulumi.Input<number>;
    /**
     * Runbook URL to display in notifications.
     */
    runbookUrl?: pulumi.Input<string>;
    /**
     * The duration of overlapping time windows used to smooth the chart line, in seconds. Must be a factor of
     * `aggregation_window` and less than the aggregation window. If `aggregation_window` is less than or equal to 3600
     * seconds, it should be greater or equal to 30 seconds. If `aggregation_window` is greater than 3600 seconds but less than
     * 7200 seconds, it should be greater or equal to `aggregation_window / 120`. If `aggregation_window` is greater than 7200
     * seconds, it should be greater or equal to `aggregation_window / 24
     */
    slideBy?: pulumi.Input<number>;
    /**
     * A set of terms for this condition. Max 2 terms allowed - at least one 1 critical term and 1 optional warning term.
     *
     * @deprecated Deprecated
     */
    terms?: pulumi.Input<pulumi.Input<inputs.NrqlAlertConditionTerm>[]>;
    timeouts?: pulumi.Input<inputs.NrqlAlertConditionTimeouts>;
    /**
     * This field allows you to create a custom title to be used when incidents are opened by the condition. Setting this field
     * will override the default title. Must be Handlebars format.
     */
    titleTemplate?: pulumi.Input<string>;
    /**
     * The type of NRQL alert condition to create. Valid values are: 'static', 'baseline'.
     */
    type?: pulumi.Input<string>;
    /**
     * Sets a time limit, in hours, that will automatically force-close a long-lasting incident after the time limit you
     * select. Possible values are 'ONE_HOUR', 'TWO_HOURS', 'FOUR_HOURS', 'EIGHT_HOURS', 'TWELVE_HOURS', 'TWENTY_FOUR_HOURS',
     * 'THIRTY_DAYS' (case insensitive).
     *
     * @deprecated Deprecated
     */
    violationTimeLimit?: pulumi.Input<string>;
    /**
     * Sets a time limit, in seconds, that will automatically force-close a long-lasting incident after the time limit you
     * select. Must be in the range of 300 to 2592000 (inclusive)
     */
    violationTimeLimitSeconds?: pulumi.Input<number>;
    /**
     * A condition term with priority set to warning.
     */
    warning?: pulumi.Input<inputs.NrqlAlertConditionWarning>;
}
