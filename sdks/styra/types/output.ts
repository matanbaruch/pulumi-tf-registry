// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetLibraryResult {
    datasources: outputs.GetLibraryResultDatasource[];
    description: string;
    id: string;
    metadata: outputs.GetLibraryResultMetadata;
    policies: outputs.GetLibraryResultPolicy[];
    readOnly: boolean;
    sourceControl: outputs.GetLibraryResultSourceControl;
    usedBies: outputs.GetLibraryResultUsedBy[];
}

export interface GetLibraryResultDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.GetLibraryResultDatasourceStatus;
}

export interface GetLibraryResultDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface GetLibraryResultMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface GetLibraryResultPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.GetLibraryResultPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.GetLibraryResultPolicyModule[];
    rules: outputs.GetLibraryResultPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface GetLibraryResultPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface GetLibraryResultPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.GetLibraryResultPolicyModuleRules;
}

export interface GetLibraryResultPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetLibraryResultPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetLibraryResultSourceControl {
    libraryOrigin: outputs.GetLibraryResultSourceControlLibraryOrigin;
    useWorkspaceSettings: boolean;
}

export interface GetLibraryResultSourceControlLibraryOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials: outputs.GetLibraryResultSourceControlLibraryOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface GetLibraryResultSourceControlLibraryOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface GetLibraryResultUsedBy {
    bundles: outputs.GetLibraryResultUsedByBundle[];
    systemId: string;
}

export interface GetLibraryResultUsedByBundle {
    bundleId: string;
    version: number;
}

export interface GetSecretMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface GetStackAuthz {
    /**
     * a list of role binding configs
     */
    roleBindings: outputs.GetStackAuthzRoleBinding[];
}

export interface GetStackAuthzRoleBinding {
    /**
     * role binding ID
     */
    id: string;
    /**
     * role name
     */
    roleName: string;
}

export interface GetStackDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.GetStackDatasourceStatus;
}

export interface GetStackDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface GetStackErrors {
    /**
     * list of system errors
     */
    errors: outputs.GetStackErrorsError[];
    /**
     * true if the the system is waiting for error to be resolved
     */
    waiting: boolean;
}

export interface GetStackErrorsError {
    code: string;
    message: string;
    timestamp: string;
}

export interface GetStackMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface GetStackMigrationHistory {
    from: string;
    initiatedBy: string;
    initiatingUser: string;
    migratedAt: string;
    recovered: boolean;
    to: string;
}

export interface GetStackPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.GetStackPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.GetStackPolicyModule[];
    rules: outputs.GetStackPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface GetStackPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface GetStackPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.GetStackPolicyModuleRules;
}

export interface GetStackPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetStackPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetStackSourceControl {
    stackOrigin: outputs.GetStackSourceControlStackOrigin;
    useWorkspaceSettings: boolean;
}

export interface GetStackSourceControlStackOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials: outputs.GetStackSourceControlStackOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface GetStackSourceControlStackOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface GetStackTypeParameters {
}

export interface GetSystemResult {
    authz: outputs.GetSystemResultAuthz;
    bundleDownload: outputs.GetSystemResultBundleDownload;
    bundleRegistry: outputs.GetSystemResultBundleRegistry;
    /**
     * only put data in the context bundle
     */
    contextBundleDataOnly: boolean;
    /**
     * list of path prefixes for policies/datasources that go into the second (context) bundle
     */
    contextBundleRoots: string[];
    /**
     * datasources created for the system
     */
    datasources: outputs.GetSystemResultDatasource[];
    /**
     * location of key attributes and additional columns in the decisions grouped by policy entry point path
     */
    decisionMappings: {[key: string]: outputs.GetSystemResultDecisionMappings};
    deploymentParameters: outputs.GetSystemResultDeploymentParameters;
    /**
     * description for the system
     */
    description: string;
    /**
     * error/warning configuration: one of "all", "errors", "none"
     */
    errorSetting: string;
    /**
     * current deployment errors
     */
    errors: {[key: string]: outputs.GetSystemResultErrors};
    externalBundles: outputs.GetSystemResultExternalBundles;
    /**
     * optional parameter to map Styra DAS system ID to external IDs used by a customer. (mapping can be retrieved with TranslateExternalIds operation)
     */
    externalId: string;
    /**
     * when set, stacks that are not linked to this system will be filtered out of its bundles
     */
    filterStacks: boolean;
    /**
     * system ID
     */
    id: string;
    /**
     * optional parameter to specify the Kafka topic where the decision logs for this system should be published (ignored if Kafka is not configured for the workspace for decision export)
     */
    kafkaTopic: string;
    /**
     * IDs of stacks matching the system
     */
    matchingStacks: string[];
    metadata: outputs.GetSystemResultMetadata;
    /**
     * A history of any migrations performed on this system
     */
    migrationHistories: outputs.GetSystemResultMigrationHistory[];
    /**
     * minimum running OPA version for the systems
     */
    minimumOpaVersion: string;
    /**
     * enable mock OPAs for this system
     */
    mockOpaEnabled: boolean;
    /**
     * system name
     */
    name: string;
    /**
     * policies created for the system
     */
    policies: outputs.GetSystemResultPolicy[];
    /**
     * prevents users from modifying policies using Styra UIs
     */
    readOnly: boolean;
    sourceControl: outputs.GetSystemResultSourceControl;
    /**
     * system status
     */
    status: string;
    /**
     * tokens created for the system
     */
    tokens: outputs.GetSystemResultToken[];
    /**
     * system type e.g. kubernetes
     */
    type: string;
    /**
     * system type parameter values (for template.* types)
     */
    typeParameters: outputs.GetSystemResultTypeParameters;
    /**
     * uninstallation instructions by installation method (deprecated)
     */
    uninstall: {[key: string]: string};
}

export interface GetSystemResultAuthz {
    /**
     * a list of role binding configs
     */
    roleBindings: outputs.GetSystemResultAuthzRoleBinding[];
}

export interface GetSystemResultAuthzRoleBinding {
    /**
     * role binding ID
     */
    id: string;
    /**
     * role name
     */
    roleName: string;
}

export interface GetSystemResultBundleDownload {
    /**
     * enabled delta bundles on bundle download
     */
    deltaBundles: boolean;
}

export interface GetSystemResultBundleRegistry {
    /**
     * when checked, bundles will be activated regardless of their compatibility with currently running agents
     */
    disableBundleCompatibilityCheck: boolean;
    distributionS3: outputs.GetSystemResultBundleRegistryDistributionS3;
    /**
     * extra bundle entry points to use when compiling bundles
     */
    entrypoints: string[];
    /**
     * manual deployment mode to prevent automatic deployment of new bundles
     */
    manualDeployment: boolean;
    /**
     * Override of manual deployment mode flag per bundle type
     */
    manualDeploymentOverrides: {[key: string]: boolean};
    /**
     * maximum number of all bundles to store
     */
    maxBundles: number;
    /**
     * maximum number of previously deployed bundles to store
     */
    maxDeployedBundles: number;
    /**
     * OPA optimization level to use when building bundles
     */
    optimizationLevel: number;
}

export interface GetSystemResultBundleRegistryDistributionS3 {
    /**
     * access key id and secret access key are looked under the key <name>/<access_keys>
     */
    accessKeys: string;
    /**
     * bucket name
     */
    bucket: string;
    /**
     * context bundle path. The name must not use template variables
     */
    contextPath: string;
    /**
     * discovery bundle path. Template variables can be used in the name
     */
    discoveryPath: string;
    /**
     * AWS endpoint
     */
    endpoint: string;
    opaCredentials: outputs.GetSystemResultBundleRegistryDistributionS3OpaCredentials;
    /**
     * policy bundle path. Template variables can be used in the name
     */
    policyPath: string;
    /**
     * AWS region
     */
    region: string;
    /**
     * AWS role
     */
    roleArn: string;
}

export interface GetSystemResultBundleRegistryDistributionS3OpaCredentials {
    environmentCredentials: outputs.GetSystemResultBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials;
    metadataCredentials: outputs.GetSystemResultBundleRegistryDistributionS3OpaCredentialsMetadataCredentials;
    webIdentityCredentials: outputs.GetSystemResultBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials;
}

export interface GetSystemResultBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials {
}

export interface GetSystemResultBundleRegistryDistributionS3OpaCredentialsMetadataCredentials {
    awsRegion: string;
    iamRole: string;
}

export interface GetSystemResultBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials {
    awsRegion: string;
    sessionName: string;
}

export interface GetSystemResultDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.GetSystemResultDatasourceStatus;
}

export interface GetSystemResultDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface GetSystemResultDecisionMappings {
    allowed: outputs.GetSystemResultDecisionMappingsAllowed;
    /**
     * decision mappings for additional columns
     */
    columns: outputs.GetSystemResultDecisionMappingsColumn[];
    reason: outputs.GetSystemResultDecisionMappingsReason;
}

export interface GetSystemResultDecisionMappingsAllowed {
    /**
     * Parsed as JSON.
     */
    expected: string;
    /**
     * when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value
     */
    negated: boolean;
    /**
     * dot-separated decision property path
     */
    path: string;
}

export interface GetSystemResultDecisionMappingsColumn {
    /**
     * column key (also the search key)
     */
    key: string;
    /**
     * dot-separated decision property path
     */
    path: string;
    /**
     * column type: one of "string", "boolean", "date", "integer", "float"
     */
    type: string;
}

export interface GetSystemResultDecisionMappingsReason {
    /**
     * dot-separated decision property path
     */
    path: string;
}

export interface GetSystemResultDeploymentParameters {
    /**
     * true to fail close
     */
    denyOnOpaFail: boolean;
    /**
     * discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)
     */
    discovery: outputs.GetSystemResultDeploymentParametersDiscovery;
    /**
     * extra deployment settings
     */
    extra: outputs.GetSystemResultDeploymentParametersExtra;
    /**
     * HTTP proxy URL
     */
    httpProxy: string;
    /**
     * HTTPS proxy URL
     */
    httpsProxy: string;
    /**
     * minimum Kubernetes version expected (where applicable)
     */
    kubernetesVersion: string;
    /**
     * Custom name for mutating webhook (useful for changing webhook order of execution)
     */
    mutatingWebhookName: string;
    /**
     * Kubernetes namespace the system is deployed to
     */
    namespace: string;
    /**
     * URLs that should be excluded from proxying
     */
    noProxy: string;
    /**
     * Kubernetes webhook timeout (where applicable)
     */
    timeoutSeconds: number;
    /**
     * trusted CA certificates
     */
    trustedCaCerts: string[];
    /**
     * trusted container registry
     */
    trustedContainerRegistry: string;
}

export interface GetSystemResultDeploymentParametersDiscovery {
}

export interface GetSystemResultDeploymentParametersExtra {
}

export interface GetSystemResultErrors {
    /**
     * list of system errors
     */
    errors: outputs.GetSystemResultErrorsError[];
    /**
     * true if the the system is waiting for error to be resolved
     */
    waiting: boolean;
}

export interface GetSystemResultErrorsError {
    code: string;
    message: string;
    timestamp: string;
}

export interface GetSystemResultExternalBundles {
    /**
     * externally configured bundles, use name of bundle as key
     */
    bundles: {[key: string]: outputs.GetSystemResultExternalBundlesBundles};
    /**
     * externally configured services
     */
    services: outputs.GetSystemResultExternalBundlesService[];
}

export interface GetSystemResultExternalBundlesBundles {
    /**
     * persist activated bundles to disk
     */
    persist: boolean;
    polling: outputs.GetSystemResultExternalBundlesBundlesPolling;
    /**
     * resource path to use to download bundle from configured service
     */
    resource: string;
    /**
     * name of service to use to contact remote server
     */
    service: string;
    signing: outputs.GetSystemResultExternalBundlesBundlesSigning;
    /**
     * size limit for individual files contained in the bundle
     */
    sizeLimitBytes: number;
}

export interface GetSystemResultExternalBundlesBundlesPolling {
    /**
     * maximum amount of time the server should wait before issuing a timeout if there’s no update available
     */
    longPollingTimeoutSeconds: number;
    /**
     * maximum amount of time to wait between bundle downloads
     */
    maxDelaySeconds: number;
    /**
     * minimum amount of time to wait between bundle downloads
     */
    minDelaySeconds: number;
}

export interface GetSystemResultExternalBundlesBundlesSigning {
    /**
     * files in the bundle to exclude during verification
     */
    excludeFiles: string[];
    /**
     * name of the key to use for bundle signature verification
     */
    keyid: string;
    /**
     * information about necessary public signing keys
     */
    publicKeys: {[key: string]: outputs.GetSystemResultExternalBundlesBundlesSigningPublicKeys};
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface GetSystemResultExternalBundlesBundlesSigningPublicKeys {
    /**
     * name of the signing algorithm
     */
    algorithm: string;
    /**
     * PEM encoded public key to use for signature verification
     */
    key: string;
    /**
     * PEM encoded private key to use for signing
     */
    privateKey: string;
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface GetSystemResultExternalBundlesService {
    /**
     * allow insecure TLS
     */
    allowInsecureTls: boolean;
    credentials: outputs.GetSystemResultExternalBundlesServiceCredentials;
    /**
     * HTTP headers to include in the requests to the service
     */
    headers: {[key: string]: string};
    /**
     * keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.
     */
    keys: {[key: string]: outputs.GetSystemResultExternalBundlesServiceKeys};
    /**
     * unique name for each service, referred to by plugins
     */
    name: string;
    /**
     * amount of time to wait for a server's response headers after fully writing the request
     */
    responseHeaderTimeoutSeconds: number;
    tls: outputs.GetSystemResultExternalBundlesServiceTls;
    /**
     * optional parameter that allows to use an “OCI” service type
     */
    type: string;
    /**
     * base URL to contact the service with
     */
    url: string;
}

export interface GetSystemResultExternalBundlesServiceCredentials {
    azureManagedIdentity: outputs.GetSystemResultExternalBundlesServiceCredentialsAzureManagedIdentity;
    bearer: outputs.GetSystemResultExternalBundlesServiceCredentialsBearer;
    clientTls: outputs.GetSystemResultExternalBundlesServiceCredentialsClientTls;
    gcpMetadata: outputs.GetSystemResultExternalBundlesServiceCredentialsGcpMetadata;
    oauth2: outputs.GetSystemResultExternalBundlesServiceCredentialsOauth2;
    /**
     * authenticate using a custom plugin
     */
    plugin: string;
    s3Signing: outputs.GetSystemResultExternalBundlesServiceCredentialsS3Signing;
}

export interface GetSystemResultExternalBundlesServiceCredentialsAzureManagedIdentity {
    /**
     * API version to use
     */
    apiVersion: string;
    /**
     * optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities
     */
    clientId: string;
    /**
     * request endpoint
     */
    endpoint: string;
    /**
     * optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities
     */
    miResId: string;
    /**
     * optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities
     */
    objectId: string;
    /**
     * app ID URI of the target resource
     */
    resource: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsBearer {
    /**
     * bearer token scheme to specify
     */
    scheme: string;
    /**
     * enables token-based authentication and supplies the bearer token to authenticate with
     */
    token: string;
    /**
     * enables token-based authentication and supplies the path to the bearer token to authenticate with
     */
    tokenPath: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsClientTls {
    /**
     * the path to the client certificate to authenticate with
     */
    cert: string;
    /**
     * the path to the private key of the client certificate
     */
    privateKey: string;
    /**
     * the passphrase to use for the private key
     */
    privateKeyPassphrase: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsGcpMetadata {
    /**
     * the access token metadata path to use
     */
    accessTokenPath: string;
    /**
     * the audience to use when fetching identity tokens
     */
    audience: string;
    /**
     * the metadata endpoint to use
     */
    endpoint: string;
    /**
     * the identity token metadata path to use
     */
    idTokenPath: string;
    /**
     * the set of scopes to use when fetching access token
     */
    scopes: string[];
}

export interface GetSystemResultExternalBundlesServiceCredentialsOauth2 {
    /**
     * map of claims to include in the JWT
     */
    additionalClaims: outputs.GetSystemResultExternalBundlesServiceCredentialsOauth2AdditionalClaims;
    /**
     * map of additional headers to send to token endpoint at the OAuth2 authorization server
     */
    additionalHeaders: {[key: string]: string};
    /**
     * map of additional body parameters to send token endpoint at the OAuth2 authorization server
     */
    additionalParameters: {[key: string]: string};
    /**
     * the client ID to use for authentication
     */
    clientId: string;
    /**
     * the client secret to use for authentication
     */
    clientSecret: string;
    /**
     * defaults to client_credentials
     */
    grantType: string;
    /**
     * include a uniquely generated jti claim in any issued JWT
     */
    includeJtiClaim: boolean;
    /**
     * optional list of scopes to request for the token
     */
    scopes: string[];
    /**
     * reference to private key used for signing the JWT
     */
    signingKey: string;
    /**
     * certificate thumbprint to use for x5t header generation
     */
    thumbprint: string;
    /**
     * URL pointing to the token endpoint at the OAuth2 authorization server
     */
    tokenUrl: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsOauth2AdditionalClaims {
}

export interface GetSystemResultExternalBundlesServiceCredentialsS3Signing {
    /**
     * Parsed as JSON.
     */
    environmentCredentials: string;
    metadataCredentials: outputs.GetSystemResultExternalBundlesServiceCredentialsS3SigningMetadataCredentials;
    profileCredentials: outputs.GetSystemResultExternalBundlesServiceCredentialsS3SigningProfileCredentials;
    /**
     * the AWS service to sign requests with, eg execute-api or s3 (default: s3)
     */
    service: string;
    webIdentityCredentials: outputs.GetSystemResultExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials;
}

export interface GetSystemResultExternalBundlesServiceCredentialsS3SigningMetadataCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method
     */
    awsRegion: string;
    /**
     * the IAM role to use for the AWS signing service credential method
     */
    iamRole: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsS3SigningProfileCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method
     */
    awsRegion: string;
    /**
     * the path to the shared credentials file
     */
    path: string;
    /**
     * AWS Profile to extract credentials from the credentials file
     */
    profile: string;
}

export interface GetSystemResultExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials {
    /**
     * the AWS region to use for the sts regional endpoint (default: global)
     */
    awsRegion: string;
    /**
     * the session name used to identify the assumed role session (default: open-policy-agent)
     */
    sessionName: string;
}

export interface GetSystemResultExternalBundlesServiceKeys {
    algorithm: string;
    key: string;
    privateKey: string;
    scope: string;
}

export interface GetSystemResultExternalBundlesServiceTls {
    /**
     * the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set
     */
    caCert: string;
    /**
     * require system certificate appended with root CA certificate
     */
    systemCaRequired: boolean;
}

export interface GetSystemResultMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface GetSystemResultMigrationHistory {
    from: string;
    initiatedBy: string;
    initiatingUser: string;
    migratedAt: string;
    recovered: boolean;
    to: string;
}

export interface GetSystemResultPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.GetSystemResultPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.GetSystemResultPolicyModule[];
    rules: outputs.GetSystemResultPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface GetSystemResultPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface GetSystemResultPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.GetSystemResultPolicyModuleRules;
}

export interface GetSystemResultPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetSystemResultPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface GetSystemResultSourceControl {
    origin: outputs.GetSystemResultSourceControlOrigin;
}

export interface GetSystemResultSourceControlOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials: outputs.GetSystemResultSourceControlOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface GetSystemResultSourceControlOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface GetSystemResultToken {
    allowPathPatterns: string[];
    description: string;
    expires: string;
    id: string;
    metadata: outputs.GetSystemResultTokenMetadata;
    token: string;
    ttl: string;
    uses: number;
}

export interface GetSystemResultTokenMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface GetSystemResultTypeParameters {
}

export interface LibraryResult {
    datasources: outputs.LibraryResultDatasource[];
    description: string;
    id: string;
    metadata: outputs.LibraryResultMetadata;
    policies: outputs.LibraryResultPolicy[];
    readOnly: boolean;
    sourceControl: outputs.LibraryResultSourceControl;
    usedBies: outputs.LibraryResultUsedBy[];
}

export interface LibraryResultDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.LibraryResultDatasourceStatus;
}

export interface LibraryResultDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface LibraryResultMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface LibraryResultPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.LibraryResultPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.LibraryResultPolicyModule[];
    rules: outputs.LibraryResultPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface LibraryResultPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface LibraryResultPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.LibraryResultPolicyModuleRules;
}

export interface LibraryResultPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface LibraryResultPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface LibraryResultSourceControl {
    libraryOrigin: outputs.LibraryResultSourceControlLibraryOrigin;
    useWorkspaceSettings: boolean;
}

export interface LibraryResultSourceControlLibraryOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials: outputs.LibraryResultSourceControlLibraryOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface LibraryResultSourceControlLibraryOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface LibraryResultUsedBy {
    bundles: outputs.LibraryResultUsedByBundle[];
    systemId: string;
}

export interface LibraryResultUsedByBundle {
    bundleId: string;
    version: number;
}

export interface LibrarySourceControl {
    libraryOrigin?: outputs.LibrarySourceControlLibraryOrigin;
    useWorkspaceSettings: boolean;
}

export interface LibrarySourceControlLibraryOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials?: outputs.LibrarySourceControlLibraryOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface LibrarySourceControlLibraryOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface PolicySignature {
    /**
     * Parsed as JSON.
     */
    excluded?: string;
    /**
     * Parsed as JSON.
     */
    signatures?: string;
}

export interface SecretMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface StackAuthz {
    /**
     * a list of role binding configs
     */
    roleBindings: outputs.StackAuthzRoleBinding[];
}

export interface StackAuthzRoleBinding {
    /**
     * role binding ID
     */
    id: string;
    /**
     * role name
     */
    roleName: string;
}

export interface StackDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.StackDatasourceStatus;
}

export interface StackDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface StackErrors {
    /**
     * list of system errors
     */
    errors: outputs.StackErrorsError[];
    /**
     * true if the the system is waiting for error to be resolved
     */
    waiting: boolean;
}

export interface StackErrorsError {
    code: string;
    message: string;
    timestamp: string;
}

export interface StackMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface StackMigrationHistory {
    from: string;
    initiatedBy: string;
    initiatingUser: string;
    migratedAt: string;
    recovered: boolean;
    to: string;
}

export interface StackPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.StackPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.StackPolicyModule[];
    rules: outputs.StackPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface StackPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface StackPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.StackPolicyModuleRules;
}

export interface StackPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface StackPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface StackSourceControl {
    stackOrigin: outputs.StackSourceControlStackOrigin;
    /**
     * Not Null
     */
    useWorkspaceSettings: boolean;
}

export interface StackSourceControlStackOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time. Not Null
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>. Not Null
     */
    credentials: string;
    /**
     * Path to limit the import to. Not Null
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time. Not Null
     */
    reference: string;
    sshCredentials: outputs.StackSourceControlStackOriginSshCredentials;
    /**
     * Repository URL. Not Null
     */
    url: string;
}

export interface StackSourceControlStackOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>. Not Null
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>. Not Null
     */
    privateKey: string;
}

export interface StackTypeParameters {
}

export interface SystemAuthz {
    /**
     * a list of role binding configs
     */
    roleBindings: outputs.SystemAuthzRoleBinding[];
}

export interface SystemAuthzRoleBinding {
    /**
     * role binding ID
     */
    id: string;
    /**
     * role name
     */
    roleName: string;
}

export interface SystemBundleDownload {
    /**
     * enabled delta bundles on bundle download. Default: false
     */
    deltaBundles: boolean;
}

export interface SystemBundleRegistry {
    /**
     * when checked, bundles will be activated regardless of their compatibility with currently running agents
     */
    disableBundleCompatibilityCheck: boolean;
    distributionS3: outputs.SystemBundleRegistryDistributionS3;
    /**
     * extra bundle entry points to use when compiling bundles
     */
    entrypoints: string[];
    /**
     * manual deployment mode to prevent automatic deployment of new bundles
     */
    manualDeployment: boolean;
    /**
     * Override of manual deployment mode flag per bundle type
     */
    manualDeploymentOverrides: {[key: string]: boolean};
    /**
     * maximum number of all bundles to store
     */
    maxBundles: number;
    /**
     * maximum number of previously deployed bundles to store
     */
    maxDeployedBundles: number;
    /**
     * OPA optimization level to use when building bundles
     */
    optimizationLevel: number;
}

export interface SystemBundleRegistryDistributionS3 {
    /**
     * access key id and secret access key are looked under the key <name>/<access_keys>
     */
    accessKeys: string;
    /**
     * bucket name. Not Null
     */
    bucket: string;
    /**
     * context bundle path. The name must not use template variables. Default: "context-{policy_path}"
     */
    contextPath: string;
    /**
     * discovery bundle path. Template variables can be used in the name. Default: "discovery.tgz"
     */
    discoveryPath: string;
    /**
     * AWS endpoint
     */
    endpoint: string;
    opaCredentials: outputs.SystemBundleRegistryDistributionS3OpaCredentials;
    /**
     * policy bundle path. Template variables can be used in the name. Default: "bundle.tgz"
     */
    policyPath: string;
    /**
     * AWS region. Not Null
     */
    region: string;
    /**
     * AWS role
     */
    roleArn: string;
}

export interface SystemBundleRegistryDistributionS3OpaCredentials {
    environmentCredentials: outputs.SystemBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials;
    metadataCredentials: outputs.SystemBundleRegistryDistributionS3OpaCredentialsMetadataCredentials;
    webIdentityCredentials: outputs.SystemBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials;
}

export interface SystemBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials {
}

export interface SystemBundleRegistryDistributionS3OpaCredentialsMetadataCredentials {
    /**
     * Not Null
     */
    awsRegion: string;
    iamRole: string;
}

export interface SystemBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials {
    /**
     * Not Null
     */
    awsRegion: string;
    /**
     * Not Null
     */
    sessionName: string;
}

export interface SystemDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.SystemDatasourceStatus;
}

export interface SystemDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface SystemDecisionMappings {
    allowed: outputs.SystemDecisionMappingsAllowed;
    /**
     * decision mappings for additional columns
     */
    columns: outputs.SystemDecisionMappingsColumn[];
    reason: outputs.SystemDecisionMappingsReason;
}

export interface SystemDecisionMappingsAllowed {
    /**
     * Parsed as JSON.
     */
    expected: string;
    /**
     * when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value. Default: false
     */
    negated: boolean;
    /**
     * dot-separated decision property path. Not Null
     */
    path: string;
}

export interface SystemDecisionMappingsColumn {
    /**
     * column key (also the search key). Not Null
     */
    key: string;
    /**
     * dot-separated decision property path. Not Null
     */
    path: string;
    /**
     * column type: one of "string", "boolean", "date", "integer", "float". Default: "string"
     */
    type: string;
}

export interface SystemDecisionMappingsReason {
    /**
     * dot-separated decision property path. Not Null
     */
    path: string;
}

export interface SystemDeploymentParameters {
    /**
     * true to fail close. Default: false
     */
    denyOnOpaFail: boolean;
    /**
     * discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)
     */
    discovery: outputs.SystemDeploymentParametersDiscovery;
    /**
     * extra deployment settings
     */
    extra: outputs.SystemDeploymentParametersExtra;
    /**
     * HTTP proxy URL
     */
    httpProxy: string;
    /**
     * HTTPS proxy URL
     */
    httpsProxy: string;
    /**
     * minimum Kubernetes version expected (where applicable)
     */
    kubernetesVersion: string;
    /**
     * Custom name for mutating webhook (useful for changing webhook order of execution)
     */
    mutatingWebhookName: string;
    /**
     * Kubernetes namespace the system is deployed to
     */
    namespace: string;
    /**
     * URLs that should be excluded from proxying
     */
    noProxy: string;
    /**
     * Kubernetes webhook timeout (where applicable)
     */
    timeoutSeconds: number;
    /**
     * trusted CA certificates
     */
    trustedCaCerts: string[];
    /**
     * trusted container registry
     */
    trustedContainerRegistry: string;
}

export interface SystemDeploymentParametersDiscovery {
}

export interface SystemDeploymentParametersExtra {
}

export interface SystemErrors {
    /**
     * list of system errors
     */
    errors: outputs.SystemErrorsError[];
    /**
     * true if the the system is waiting for error to be resolved
     */
    waiting: boolean;
}

export interface SystemErrorsError {
    code: string;
    message: string;
    timestamp: string;
}

export interface SystemExternalBundles {
    /**
     * externally configured bundles, use name of bundle as key
     */
    bundles: {[key: string]: outputs.SystemExternalBundlesBundles};
    /**
     * externally configured services. Not Null
     */
    services: outputs.SystemExternalBundlesService[];
}

export interface SystemExternalBundlesBundles {
    /**
     * persist activated bundles to disk
     */
    persist: boolean;
    polling: outputs.SystemExternalBundlesBundlesPolling;
    /**
     * resource path to use to download bundle from configured service
     */
    resource: string;
    /**
     * name of service to use to contact remote server. Not Null
     */
    service: string;
    signing: outputs.SystemExternalBundlesBundlesSigning;
    /**
     * size limit for individual files contained in the bundle
     */
    sizeLimitBytes: number;
}

export interface SystemExternalBundlesBundlesPolling {
    /**
     * maximum amount of time the server should wait before issuing a timeout if there’s no update available
     */
    longPollingTimeoutSeconds: number;
    /**
     * maximum amount of time to wait between bundle downloads
     */
    maxDelaySeconds: number;
    /**
     * minimum amount of time to wait between bundle downloads
     */
    minDelaySeconds: number;
}

export interface SystemExternalBundlesBundlesSigning {
    /**
     * files in the bundle to exclude during verification
     */
    excludeFiles: string[];
    /**
     * name of the key to use for bundle signature verification
     */
    keyid: string;
    /**
     * information about necessary public signing keys
     */
    publicKeys: {[key: string]: outputs.SystemExternalBundlesBundlesSigningPublicKeys};
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface SystemExternalBundlesBundlesSigningPublicKeys {
    /**
     * name of the signing algorithm
     */
    algorithm: string;
    /**
     * PEM encoded public key to use for signature verification
     */
    key: string;
    /**
     * PEM encoded private key to use for signing
     */
    privateKey: string;
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface SystemExternalBundlesService {
    /**
     * allow insecure TLS
     */
    allowInsecureTls: boolean;
    credentials: outputs.SystemExternalBundlesServiceCredentials;
    /**
     * HTTP headers to include in the requests to the service
     */
    headers: {[key: string]: string};
    /**
     * keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.
     */
    keys: {[key: string]: outputs.SystemExternalBundlesServiceKeys};
    /**
     * unique name for each service, referred to by plugins. Not Null
     */
    name: string;
    /**
     * amount of time to wait for a server's response headers after fully writing the request
     */
    responseHeaderTimeoutSeconds: number;
    tls: outputs.SystemExternalBundlesServiceTls;
    /**
     * optional parameter that allows to use an “OCI” service type
     */
    type: string;
    /**
     * base URL to contact the service with. Not Null
     */
    url: string;
}

export interface SystemExternalBundlesServiceCredentials {
    azureManagedIdentity: outputs.SystemExternalBundlesServiceCredentialsAzureManagedIdentity;
    bearer: outputs.SystemExternalBundlesServiceCredentialsBearer;
    clientTls: outputs.SystemExternalBundlesServiceCredentialsClientTls;
    gcpMetadata: outputs.SystemExternalBundlesServiceCredentialsGcpMetadata;
    oauth2: outputs.SystemExternalBundlesServiceCredentialsOauth2;
    /**
     * authenticate using a custom plugin
     */
    plugin: string;
    s3Signing: outputs.SystemExternalBundlesServiceCredentialsS3Signing;
}

export interface SystemExternalBundlesServiceCredentialsAzureManagedIdentity {
    /**
     * API version to use. Not Null
     */
    apiVersion: string;
    /**
     * optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities. Not Null
     */
    clientId: string;
    /**
     * request endpoint. Not Null
     */
    endpoint: string;
    /**
     * optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities. Not Null
     */
    miResId: string;
    /**
     * optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities. Not Null
     */
    objectId: string;
    /**
     * app ID URI of the target resource. Not Null
     */
    resource: string;
}

export interface SystemExternalBundlesServiceCredentialsBearer {
    /**
     * bearer token scheme to specify
     */
    scheme: string;
    /**
     * enables token-based authentication and supplies the bearer token to authenticate with. Not Null
     */
    token: string;
    /**
     * enables token-based authentication and supplies the path to the bearer token to authenticate with. Not Null
     */
    tokenPath: string;
}

export interface SystemExternalBundlesServiceCredentialsClientTls {
    /**
     * the path to the client certificate to authenticate with. Not Null
     */
    cert: string;
    /**
     * the path to the private key of the client certificate. Not Null
     */
    privateKey: string;
    /**
     * the passphrase to use for the private key
     */
    privateKeyPassphrase: string;
}

export interface SystemExternalBundlesServiceCredentialsGcpMetadata {
    /**
     * the access token metadata path to use. Not Null
     */
    accessTokenPath: string;
    /**
     * the audience to use when fetching identity tokens. Not Null
     */
    audience: string;
    /**
     * the metadata endpoint to use. Not Null
     */
    endpoint: string;
    /**
     * the identity token metadata path to use. Not Null
     */
    idTokenPath: string;
    /**
     * the set of scopes to use when fetching access token. Not Null
     */
    scopes: string[];
}

export interface SystemExternalBundlesServiceCredentialsOauth2 {
    /**
     * map of claims to include in the JWT. Not Null
     */
    additionalClaims: outputs.SystemExternalBundlesServiceCredentialsOauth2AdditionalClaims;
    /**
     * map of additional headers to send to token endpoint at the OAuth2 authorization server
     */
    additionalHeaders: {[key: string]: string};
    /**
     * map of additional body parameters to send token endpoint at the OAuth2 authorization server
     */
    additionalParameters: {[key: string]: string};
    /**
     * the client ID to use for authentication. Not Null
     */
    clientId: string;
    /**
     * the client secret to use for authentication. Not Null
     */
    clientSecret: string;
    /**
     * defaults to client_credentials. Not Null
     */
    grantType: string;
    /**
     * include a uniquely generated jti claim in any issued JWT. Not Null
     */
    includeJtiClaim: boolean;
    /**
     * optional list of scopes to request for the token
     */
    scopes: string[];
    /**
     * reference to private key used for signing the JWT. Not Null
     */
    signingKey: string;
    /**
     * certificate thumbprint to use for x5t header generation. Not Null
     */
    thumbprint: string;
    /**
     * URL pointing to the token endpoint at the OAuth2 authorization server. Not Null
     */
    tokenUrl: string;
}

export interface SystemExternalBundlesServiceCredentialsOauth2AdditionalClaims {
}

export interface SystemExternalBundlesServiceCredentialsS3Signing {
    /**
     * Parsed as JSON.
     */
    environmentCredentials: string;
    metadataCredentials: outputs.SystemExternalBundlesServiceCredentialsS3SigningMetadataCredentials;
    profileCredentials: outputs.SystemExternalBundlesServiceCredentialsS3SigningProfileCredentials;
    /**
     * the AWS service to sign requests with, eg execute-api or s3 (default: s3)
     */
    service: string;
    webIdentityCredentials: outputs.SystemExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials;
}

export interface SystemExternalBundlesServiceCredentialsS3SigningMetadataCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method. Not Null
     */
    awsRegion: string;
    /**
     * the IAM role to use for the AWS signing service credential method
     */
    iamRole: string;
}

export interface SystemExternalBundlesServiceCredentialsS3SigningProfileCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method. Not Null
     */
    awsRegion: string;
    /**
     * the path to the shared credentials file
     */
    path: string;
    /**
     * AWS Profile to extract credentials from the credentials file
     */
    profile: string;
}

export interface SystemExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials {
    /**
     * the AWS region to use for the sts regional endpoint (default: global). Not Null
     */
    awsRegion: string;
    /**
     * the session name used to identify the assumed role session (default: open-policy-agent). Not Null
     */
    sessionName: string;
}

export interface SystemExternalBundlesServiceKeys {
    /**
     * Not Null
     */
    algorithm: string;
    /**
     * Not Null
     */
    key: string;
    /**
     * Not Null
     */
    privateKey: string;
    /**
     * Not Null
     */
    scope: string;
}

export interface SystemExternalBundlesServiceTls {
    /**
     * the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set
     */
    caCert: string;
    /**
     * require system certificate appended with root CA certificate
     */
    systemCaRequired: boolean;
}

export interface SystemMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface SystemMigrationHistory {
    from: string;
    initiatedBy: string;
    initiatingUser: string;
    migratedAt: string;
    recovered: boolean;
    to: string;
}

export interface SystemPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.SystemPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.SystemPolicyModule[];
    rules: outputs.SystemPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface SystemPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface SystemPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.SystemPolicyModuleRules;
}

export interface SystemPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface SystemPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface SystemResult {
    authz: outputs.SystemResultAuthz;
    bundleDownload: outputs.SystemResultBundleDownload;
    bundleRegistry: outputs.SystemResultBundleRegistry;
    /**
     * only put data in the context bundle
     */
    contextBundleDataOnly: boolean;
    /**
     * list of path prefixes for policies/datasources that go into the second (context) bundle
     */
    contextBundleRoots: string[];
    /**
     * datasources created for the system
     */
    datasources: outputs.SystemResultDatasource[];
    /**
     * location of key attributes and additional columns in the decisions grouped by policy entry point path
     */
    decisionMappings: {[key: string]: outputs.SystemResultDecisionMappings};
    deploymentParameters: outputs.SystemResultDeploymentParameters;
    /**
     * description for the system
     */
    description: string;
    /**
     * error/warning configuration: one of "all", "errors", "none"
     */
    errorSetting: string;
    /**
     * current deployment errors
     */
    errors: {[key: string]: outputs.SystemResultErrors};
    externalBundles: outputs.SystemResultExternalBundles;
    /**
     * optional parameter to map Styra DAS system ID to external IDs used by a customer. (mapping can be retrieved with TranslateExternalIds operation)
     */
    externalId: string;
    /**
     * when set, stacks that are not linked to this system will be filtered out of its bundles
     */
    filterStacks: boolean;
    /**
     * system ID
     */
    id: string;
    /**
     * optional parameter to specify the Kafka topic where the decision logs for this system should be published (ignored if Kafka is not configured for the workspace for decision export)
     */
    kafkaTopic: string;
    /**
     * IDs of stacks matching the system
     */
    matchingStacks: string[];
    metadata: outputs.SystemResultMetadata;
    /**
     * A history of any migrations performed on this system
     */
    migrationHistories: outputs.SystemResultMigrationHistory[];
    /**
     * minimum running OPA version for the systems
     */
    minimumOpaVersion: string;
    /**
     * enable mock OPAs for this system
     */
    mockOpaEnabled: boolean;
    /**
     * system name
     */
    name: string;
    /**
     * policies created for the system
     */
    policies: outputs.SystemResultPolicy[];
    /**
     * prevents users from modifying policies using Styra UIs
     */
    readOnly: boolean;
    sourceControl: outputs.SystemResultSourceControl;
    /**
     * system status
     */
    status: string;
    /**
     * tokens created for the system
     */
    tokens: outputs.SystemResultToken[];
    /**
     * system type e.g. kubernetes
     */
    type: string;
    /**
     * system type parameter values (for template.* types)
     */
    typeParameters: outputs.SystemResultTypeParameters;
    /**
     * uninstallation instructions by installation method (deprecated)
     */
    uninstall: {[key: string]: string};
}

export interface SystemResultAuthz {
    /**
     * a list of role binding configs
     */
    roleBindings: outputs.SystemResultAuthzRoleBinding[];
}

export interface SystemResultAuthzRoleBinding {
    /**
     * role binding ID
     */
    id: string;
    /**
     * role name
     */
    roleName: string;
}

export interface SystemResultBundleDownload {
    /**
     * enabled delta bundles on bundle download
     */
    deltaBundles: boolean;
}

export interface SystemResultBundleRegistry {
    /**
     * when checked, bundles will be activated regardless of their compatibility with currently running agents
     */
    disableBundleCompatibilityCheck: boolean;
    distributionS3: outputs.SystemResultBundleRegistryDistributionS3;
    /**
     * extra bundle entry points to use when compiling bundles
     */
    entrypoints: string[];
    /**
     * manual deployment mode to prevent automatic deployment of new bundles
     */
    manualDeployment: boolean;
    /**
     * Override of manual deployment mode flag per bundle type
     */
    manualDeploymentOverrides: {[key: string]: boolean};
    /**
     * maximum number of all bundles to store
     */
    maxBundles: number;
    /**
     * maximum number of previously deployed bundles to store
     */
    maxDeployedBundles: number;
    /**
     * OPA optimization level to use when building bundles
     */
    optimizationLevel: number;
}

export interface SystemResultBundleRegistryDistributionS3 {
    /**
     * access key id and secret access key are looked under the key <name>/<access_keys>
     */
    accessKeys: string;
    /**
     * bucket name
     */
    bucket: string;
    /**
     * context bundle path. The name must not use template variables
     */
    contextPath: string;
    /**
     * discovery bundle path. Template variables can be used in the name
     */
    discoveryPath: string;
    /**
     * AWS endpoint
     */
    endpoint: string;
    opaCredentials: outputs.SystemResultBundleRegistryDistributionS3OpaCredentials;
    /**
     * policy bundle path. Template variables can be used in the name
     */
    policyPath: string;
    /**
     * AWS region
     */
    region: string;
    /**
     * AWS role
     */
    roleArn: string;
}

export interface SystemResultBundleRegistryDistributionS3OpaCredentials {
    environmentCredentials: outputs.SystemResultBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials;
    metadataCredentials: outputs.SystemResultBundleRegistryDistributionS3OpaCredentialsMetadataCredentials;
    webIdentityCredentials: outputs.SystemResultBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials;
}

export interface SystemResultBundleRegistryDistributionS3OpaCredentialsEnvironmentCredentials {
}

export interface SystemResultBundleRegistryDistributionS3OpaCredentialsMetadataCredentials {
    awsRegion: string;
    iamRole: string;
}

export interface SystemResultBundleRegistryDistributionS3OpaCredentialsWebIdentityCredentials {
    awsRegion: string;
    sessionName: string;
}

export interface SystemResultDatasource {
    /**
     * datasource category
     */
    category: string;
    /**
     * datasource ID
     */
    id: string;
    /**
     * optional datasources can be deleted without being recreated automatically
     */
    optional: boolean;
    status: outputs.SystemResultDatasourceStatus;
}

export interface SystemResultDatasourceStatus {
    code: string;
    message: string;
    timestamp: string;
}

export interface SystemResultDecisionMappings {
    allowed: outputs.SystemResultDecisionMappingsAllowed;
    /**
     * decision mappings for additional columns
     */
    columns: outputs.SystemResultDecisionMappingsColumn[];
    reason: outputs.SystemResultDecisionMappingsReason;
}

export interface SystemResultDecisionMappingsAllowed {
    /**
     * Parsed as JSON.
     */
    expected: string;
    /**
     * when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value
     */
    negated: boolean;
    /**
     * dot-separated decision property path
     */
    path: string;
}

export interface SystemResultDecisionMappingsColumn {
    /**
     * column key (also the search key)
     */
    key: string;
    /**
     * dot-separated decision property path
     */
    path: string;
    /**
     * column type: one of "string", "boolean", "date", "integer", "float"
     */
    type: string;
}

export interface SystemResultDecisionMappingsReason {
    /**
     * dot-separated decision property path
     */
    path: string;
}

export interface SystemResultDeploymentParameters {
    /**
     * true to fail close
     */
    denyOnOpaFail: boolean;
    /**
     * discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)
     */
    discovery: outputs.SystemResultDeploymentParametersDiscovery;
    /**
     * extra deployment settings
     */
    extra: outputs.SystemResultDeploymentParametersExtra;
    /**
     * HTTP proxy URL
     */
    httpProxy: string;
    /**
     * HTTPS proxy URL
     */
    httpsProxy: string;
    /**
     * minimum Kubernetes version expected (where applicable)
     */
    kubernetesVersion: string;
    /**
     * Custom name for mutating webhook (useful for changing webhook order of execution)
     */
    mutatingWebhookName: string;
    /**
     * Kubernetes namespace the system is deployed to
     */
    namespace: string;
    /**
     * URLs that should be excluded from proxying
     */
    noProxy: string;
    /**
     * Kubernetes webhook timeout (where applicable)
     */
    timeoutSeconds: number;
    /**
     * trusted CA certificates
     */
    trustedCaCerts: string[];
    /**
     * trusted container registry
     */
    trustedContainerRegistry: string;
}

export interface SystemResultDeploymentParametersDiscovery {
}

export interface SystemResultDeploymentParametersExtra {
}

export interface SystemResultErrors {
    /**
     * list of system errors
     */
    errors: outputs.SystemResultErrorsError[];
    /**
     * true if the the system is waiting for error to be resolved
     */
    waiting: boolean;
}

export interface SystemResultErrorsError {
    code: string;
    message: string;
    timestamp: string;
}

export interface SystemResultExternalBundles {
    /**
     * externally configured bundles, use name of bundle as key
     */
    bundles: {[key: string]: outputs.SystemResultExternalBundlesBundles};
    /**
     * externally configured services
     */
    services: outputs.SystemResultExternalBundlesService[];
}

export interface SystemResultExternalBundlesBundles {
    /**
     * persist activated bundles to disk
     */
    persist: boolean;
    polling: outputs.SystemResultExternalBundlesBundlesPolling;
    /**
     * resource path to use to download bundle from configured service
     */
    resource: string;
    /**
     * name of service to use to contact remote server
     */
    service: string;
    signing: outputs.SystemResultExternalBundlesBundlesSigning;
    /**
     * size limit for individual files contained in the bundle
     */
    sizeLimitBytes: number;
}

export interface SystemResultExternalBundlesBundlesPolling {
    /**
     * maximum amount of time the server should wait before issuing a timeout if there’s no update available
     */
    longPollingTimeoutSeconds: number;
    /**
     * maximum amount of time to wait between bundle downloads
     */
    maxDelaySeconds: number;
    /**
     * minimum amount of time to wait between bundle downloads
     */
    minDelaySeconds: number;
}

export interface SystemResultExternalBundlesBundlesSigning {
    /**
     * files in the bundle to exclude during verification
     */
    excludeFiles: string[];
    /**
     * name of the key to use for bundle signature verification
     */
    keyid: string;
    /**
     * information about necessary public signing keys
     */
    publicKeys: {[key: string]: outputs.SystemResultExternalBundlesBundlesSigningPublicKeys};
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface SystemResultExternalBundlesBundlesSigningPublicKeys {
    /**
     * name of the signing algorithm
     */
    algorithm: string;
    /**
     * PEM encoded public key to use for signature verification
     */
    key: string;
    /**
     * PEM encoded private key to use for signing
     */
    privateKey: string;
    /**
     * scope to use for bundle signature verification
     */
    scope: string;
}

export interface SystemResultExternalBundlesService {
    /**
     * allow insecure TLS
     */
    allowInsecureTls: boolean;
    credentials: outputs.SystemResultExternalBundlesServiceCredentials;
    /**
     * HTTP headers to include in the requests to the service
     */
    headers: {[key: string]: string};
    /**
     * keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.
     */
    keys: {[key: string]: outputs.SystemResultExternalBundlesServiceKeys};
    /**
     * unique name for each service, referred to by plugins
     */
    name: string;
    /**
     * amount of time to wait for a server's response headers after fully writing the request
     */
    responseHeaderTimeoutSeconds: number;
    tls: outputs.SystemResultExternalBundlesServiceTls;
    /**
     * optional parameter that allows to use an “OCI” service type
     */
    type: string;
    /**
     * base URL to contact the service with
     */
    url: string;
}

export interface SystemResultExternalBundlesServiceCredentials {
    azureManagedIdentity: outputs.SystemResultExternalBundlesServiceCredentialsAzureManagedIdentity;
    bearer: outputs.SystemResultExternalBundlesServiceCredentialsBearer;
    clientTls: outputs.SystemResultExternalBundlesServiceCredentialsClientTls;
    gcpMetadata: outputs.SystemResultExternalBundlesServiceCredentialsGcpMetadata;
    oauth2: outputs.SystemResultExternalBundlesServiceCredentialsOauth2;
    /**
     * authenticate using a custom plugin
     */
    plugin: string;
    s3Signing: outputs.SystemResultExternalBundlesServiceCredentialsS3Signing;
}

export interface SystemResultExternalBundlesServiceCredentialsAzureManagedIdentity {
    /**
     * API version to use
     */
    apiVersion: string;
    /**
     * optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities
     */
    clientId: string;
    /**
     * request endpoint
     */
    endpoint: string;
    /**
     * optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities
     */
    miResId: string;
    /**
     * optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities
     */
    objectId: string;
    /**
     * app ID URI of the target resource
     */
    resource: string;
}

export interface SystemResultExternalBundlesServiceCredentialsBearer {
    /**
     * bearer token scheme to specify
     */
    scheme: string;
    /**
     * enables token-based authentication and supplies the bearer token to authenticate with
     */
    token: string;
    /**
     * enables token-based authentication and supplies the path to the bearer token to authenticate with
     */
    tokenPath: string;
}

export interface SystemResultExternalBundlesServiceCredentialsClientTls {
    /**
     * the path to the client certificate to authenticate with
     */
    cert: string;
    /**
     * the path to the private key of the client certificate
     */
    privateKey: string;
    /**
     * the passphrase to use for the private key
     */
    privateKeyPassphrase: string;
}

export interface SystemResultExternalBundlesServiceCredentialsGcpMetadata {
    /**
     * the access token metadata path to use
     */
    accessTokenPath: string;
    /**
     * the audience to use when fetching identity tokens
     */
    audience: string;
    /**
     * the metadata endpoint to use
     */
    endpoint: string;
    /**
     * the identity token metadata path to use
     */
    idTokenPath: string;
    /**
     * the set of scopes to use when fetching access token
     */
    scopes: string[];
}

export interface SystemResultExternalBundlesServiceCredentialsOauth2 {
    /**
     * map of claims to include in the JWT
     */
    additionalClaims: outputs.SystemResultExternalBundlesServiceCredentialsOauth2AdditionalClaims;
    /**
     * map of additional headers to send to token endpoint at the OAuth2 authorization server
     */
    additionalHeaders: {[key: string]: string};
    /**
     * map of additional body parameters to send token endpoint at the OAuth2 authorization server
     */
    additionalParameters: {[key: string]: string};
    /**
     * the client ID to use for authentication
     */
    clientId: string;
    /**
     * the client secret to use for authentication
     */
    clientSecret: string;
    /**
     * defaults to client_credentials
     */
    grantType: string;
    /**
     * include a uniquely generated jti claim in any issued JWT
     */
    includeJtiClaim: boolean;
    /**
     * optional list of scopes to request for the token
     */
    scopes: string[];
    /**
     * reference to private key used for signing the JWT
     */
    signingKey: string;
    /**
     * certificate thumbprint to use for x5t header generation
     */
    thumbprint: string;
    /**
     * URL pointing to the token endpoint at the OAuth2 authorization server
     */
    tokenUrl: string;
}

export interface SystemResultExternalBundlesServiceCredentialsOauth2AdditionalClaims {
}

export interface SystemResultExternalBundlesServiceCredentialsS3Signing {
    /**
     * Parsed as JSON.
     */
    environmentCredentials: string;
    metadataCredentials: outputs.SystemResultExternalBundlesServiceCredentialsS3SigningMetadataCredentials;
    profileCredentials: outputs.SystemResultExternalBundlesServiceCredentialsS3SigningProfileCredentials;
    /**
     * the AWS service to sign requests with, eg execute-api or s3 (default: s3)
     */
    service: string;
    webIdentityCredentials: outputs.SystemResultExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials;
}

export interface SystemResultExternalBundlesServiceCredentialsS3SigningMetadataCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method
     */
    awsRegion: string;
    /**
     * the IAM role to use for the AWS signing service credential method
     */
    iamRole: string;
}

export interface SystemResultExternalBundlesServiceCredentialsS3SigningProfileCredentials {
    /**
     * the AWS region to use for the AWS signing service credential method
     */
    awsRegion: string;
    /**
     * the path to the shared credentials file
     */
    path: string;
    /**
     * AWS Profile to extract credentials from the credentials file
     */
    profile: string;
}

export interface SystemResultExternalBundlesServiceCredentialsS3SigningWebIdentityCredentials {
    /**
     * the AWS region to use for the sts regional endpoint (default: global)
     */
    awsRegion: string;
    /**
     * the session name used to identify the assumed role session (default: open-policy-agent)
     */
    sessionName: string;
}

export interface SystemResultExternalBundlesServiceKeys {
    algorithm: string;
    key: string;
    privateKey: string;
    scope: string;
}

export interface SystemResultExternalBundlesServiceTls {
    /**
     * the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set
     */
    caCert: string;
    /**
     * require system certificate appended with root CA certificate
     */
    systemCaRequired: boolean;
}

export interface SystemResultMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface SystemResultMigrationHistory {
    from: string;
    initiatedBy: string;
    initiatingUser: string;
    migratedAt: string;
    recovered: boolean;
    to: string;
}

export interface SystemResultPolicy {
    /**
     * policy on when to (re)generate the policy
     */
    created: string;
    enforcement: outputs.SystemResultPolicyEnforcement;
    /**
     * policy ID (path)
     */
    id: string;
    /**
     * rego modules policy consists of
     */
    modules: outputs.SystemResultPolicyModule[];
    rules: outputs.SystemResultPolicyRules;
    /**
     * policy type e.g. validating/rules
     */
    type: string;
}

export interface SystemResultPolicyEnforcement {
    /**
     * true if the policy is enforced
     */
    enforced: boolean;
    /**
     * enforcement type e.g. opa, test, mask
     */
    type: string;
}

export interface SystemResultPolicyModule {
    /**
     * module name
     */
    name: string;
    /**
     * module is a placeholder
     */
    placeholder: boolean;
    /**
     * true if module is read-only
     */
    readOnly: boolean;
    rules: outputs.SystemResultPolicyModuleRules;
}

export interface SystemResultPolicyModuleRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface SystemResultPolicyRules {
    /**
     * number of allow rules
     */
    allow: number;
    /**
     * number of deny rules
     */
    deny: number;
    /**
     * number of enforce rules
     */
    enforce: number;
    /**
     * number of ignore rules
     */
    ignore: number;
    /**
     * number of monitor rules
     */
    monitor: number;
    /**
     * number of notify rules
     */
    notify: number;
    /**
     * number of unclassified rules
     */
    other: number;
    /**
     * number of test rules
     */
    test: number;
    /**
     * total number of rules
     */
    total: number;
}

export interface SystemResultSourceControl {
    origin: outputs.SystemResultSourceControlOrigin;
}

export interface SystemResultSourceControlOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>
     */
    credentials: string;
    /**
     * Path to limit the import to
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time
     */
    reference: string;
    sshCredentials: outputs.SystemResultSourceControlOriginSshCredentials;
    /**
     * Repository URL
     */
    url: string;
}

export interface SystemResultSourceControlOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>
     */
    privateKey: string;
}

export interface SystemResultToken {
    allowPathPatterns: string[];
    description: string;
    expires: string;
    id: string;
    metadata: outputs.SystemResultTokenMetadata;
    token: string;
    ttl: string;
    uses: number;
}

export interface SystemResultTokenMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface SystemResultTypeParameters {
}

export interface SystemSourceControl {
    /**
     * Not Null
     */
    origin: outputs.SystemSourceControlOrigin;
}

export interface SystemSourceControlOrigin {
    /**
     * Commit SHA. Only one of reference or commit can be set at any time. Not Null
     */
    commit: string;
    /**
     * Credentials are looked under the key <name>/<creds>. Not Null
     */
    credentials: string;
    /**
     * Path to limit the import to. Not Null
     */
    path: string;
    /**
     * Remote reference. Only one of reference or commit can be set at any time. Not Null
     */
    reference: string;
    sshCredentials: outputs.SystemSourceControlOriginSshCredentials;
    /**
     * Repository URL. Not Null
     */
    url: string;
}

export interface SystemSourceControlOriginSshCredentials {
    /**
     * Passphrase is looked under the key passphrase/<pass>. Not Null
     */
    passphrase: string;
    /**
     * PrivateKey is looked under the key private-key/<key>. Not Null
     */
    privateKey: string;
}

export interface SystemToken {
    allowPathPatterns: string[];
    description: string;
    expires: string;
    id: string;
    metadata: outputs.SystemTokenMetadata;
    token: string;
    ttl: string;
    uses: number;
}

export interface SystemTokenMetadata {
    createdAt: string;
    createdBy: string;
    createdThrough: string;
    lastModifiedAt: string;
    lastModifiedBy: string;
    lastModifiedThrough: string;
}

export interface SystemTypeParameters {
}

