// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertExpirationDate {
    /**
     * Day of a month. Must be from 1 to 31 and valid for the year and month.
     */
    day: number;
    /**
     * Month of a year. Must be from 1 to 12.
     */
    month: number;
    /**
     * Year of the date. Must be from 1 to 9999.
     */
    year: number;
}

export interface AlertFlow {
    groupBies?: string[];
    stages: outputs.AlertFlowStage[];
}

export interface AlertFlowStage {
    groups: outputs.AlertFlowStageGroup[];
    /**
     * Timeframe for flow stage.
     */
    timeWindow?: outputs.AlertFlowStageTimeWindow;
}

export interface AlertFlowStageGroup {
    /**
     * The operator to use on the alert. can be one of ["AND" "OR"]
     */
    nextOperator: string;
    subAlerts: outputs.AlertFlowStageGroupSubAlerts;
}

export interface AlertFlowStageGroupSubAlerts {
    flowAlerts: outputs.AlertFlowStageGroupSubAlertsFlowAlert[];
    /**
     * The operator to use on the alert. can be one of ["AND" "OR"]
     */
    operator: string;
}

export interface AlertFlowStageGroupSubAlertsFlowAlert {
    not?: boolean;
    userAlertId: string;
}

export interface AlertFlowStageTimeWindow {
    hours?: number;
    minutes?: number;
    seconds?: number;
}

export interface AlertIncidentSettings {
    /**
     * Defines the alert's triggering logic. Can be one of ["Triggered_only" "Triggered_and_resolved"]. Triggered_and_resolved conflicts with new_value, unique_count and flow alerts, and with immediately and more_than_usual conditions
     */
    notifyOn?: string;
    retriggeringPeriodMinutes: number;
}

export interface AlertMetric {
    lucene?: outputs.AlertMetricLucene;
    promql?: outputs.AlertMetricPromql;
}

export interface AlertMetricLucene {
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertMetricLuceneCondition;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    searchQuery: string;
}

export interface AlertMetricLuceneCondition {
    /**
     * The arithmetic operator to use on the alert. can be one of ["Sum" "Count" "Percentile" "Avg" "Min" "Max"]
     */
    arithmeticOperator: string;
    /**
     * When arithmetic_operator = "Percentile" you need to supply the value in this property, 0 < value < 100.
     */
    arithmeticOperatorModifier?: number;
    /**
     * The fields to 'group by' on.
     */
    groupBies?: string[];
    /**
     * Determines the condition operator. Must be one of - less_than or more_than.
     */
    lessThan?: boolean;
    /**
     * Manage your logs undetected values - when relevant, enable/disable triggering on undetected values and change the auto retire interval. By default (when relevant), triggering is enabled with retire-ratio=NEVER.
     */
    manageUndetectedValues?: outputs.AlertMetricLuceneConditionManageUndetectedValues;
    /**
     * The name of the metric field to alert on.
     */
    metricField: string;
    /**
     * The minimum percentage of the timeframe that should have values for this alert to trigger
     */
    minNonNullValuesPercentage?: number;
    /**
     * Determines the condition operator. Must be one of - less_than or more_than.
     */
    moreThan?: boolean;
    /**
     * If set to true, missing data will be considered as 0, otherwise, it will not be considered at all.
     */
    replaceMissingValueWithZero?: boolean;
    /**
     * The metric value must cross the threshold within this percentage of the timeframe (sum and count arithmetic operators do not use this parameter since they aggregate over the entire requested timeframe), increments of 10, 0 <= value <= 100.
     */
    sampleThresholdPercentage: number;
    /**
     * The number of log threshold that is needed to trigger the alert.
     */
    threshold: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["4H" "15Min" "30Min" "1H" "20Min" "2H" "6H" "12H" "24H" "1Min" "5Min" "10Min"]
     */
    timeWindow: string;
}

export interface AlertMetricLuceneConditionManageUndetectedValues {
    /**
     * Defines the triggering auto-retire ratio. Can be one of ["1H" "2H" "6H" "12H" "24H" "Never" "5Min" "10Min"]
     */
    autoRetireRatio?: string;
    /**
     * Determines whether the deadman-option is enabled. When set to true, auto_retire_ratio is required otherwise auto_retire_ratio should be omitted.
     */
    enableTriggeringOnUndetectedValues: boolean;
}

export interface AlertMetricPromql {
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertMetricPromqlCondition;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    searchQuery: string;
}

export interface AlertMetricPromqlCondition {
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    lessThan?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    lessThanOrEqual?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    lessThanUsual?: boolean;
    /**
     * Manage your logs undetected values - when relevant, enable/disable triggering on undetected values and change the auto retire interval. By default (when relevant), triggering is enabled with retire-ratio=NEVER.
     */
    manageUndetectedValues?: outputs.AlertMetricPromqlConditionManageUndetectedValues;
    minNonNullValuesPercentage?: number;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    moreThan?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    moreThanOrEqual?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than, more_than_usual, less_than_usual, more_than_or_equal or less_than_or_equal.
     */
    moreThanUsual?: boolean;
    /**
     * If set to true, missing data will be considered as 0, otherwise, it will not be considered at all.
     */
    replaceMissingValueWithZero?: boolean;
    sampleThresholdPercentage: number;
    /**
     * The threshold that is needed to trigger the alert.
     */
    threshold: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["4H" "15Min" "30Min" "1H" "20Min" "2H" "6H" "12H" "24H" "1Min" "5Min" "10Min"]
     */
    timeWindow: string;
}

export interface AlertMetricPromqlConditionManageUndetectedValues {
    /**
     * Defines the triggering auto-retire ratio. Can be one of ["1H" "2H" "6H" "12H" "24H" "Never" "5Min" "10Min"]
     */
    autoRetireRatio?: string;
    /**
     * Determines whether the deadman-option is enabled. When set to true, auto_retire_ratio is required otherwise auto_retire_ratio should be omitted.
     */
    enableTriggeringOnUndetectedValues: boolean;
}

export interface AlertNewValue {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * An array that contains log’s categories that we want to be notified on.
     */
    categories?: string[];
    /**
     * An array that contains log’s class names that we want to be notified on.
     */
    classes?: string[];
    /**
     * An array that contains log’s computer names that we want to be notified on.
     */
    computers?: string[];
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertNewValueCondition;
    /**
     * An array that contains log’s IP addresses that we want to be notified on.
     */
    ipAddresses?: string[];
    /**
     * An array that contains log’s method names that we want to be notified on.
     */
    methods?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertNewValueCondition {
    /**
     * Select a key to track. Note, this key needs to have less than 50K unique values in the defined timeframe.
     */
    keyToTrack: string;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["24H" "48H" "72H" "1W" "1Month" "2Month" "3Month" "12H"]
     */
    timeWindow: string;
}

export interface AlertNotificationsGroup {
    /**
     * List of group-by fields to apply the notification logic on (can be empty). Every notification should contain unique group_by_fields permutation (the order doesn't matter).
     */
    groupByFields?: string[];
    /**
     * Defines notification logic with optional recipients. Can contain single webhook or email recipients list.
     */
    notifications?: outputs.AlertNotificationsGroupNotification[];
}

export interface AlertNotificationsGroupNotification {
    /**
     * Conflicts with integration_id.
     */
    emailRecipients?: string[];
    /**
     * Conflicts with emails.
     */
    integrationId?: string;
    /**
     * Defines the alert's triggering logic. Can be one of ["Triggered_only" "Triggered_and_resolved"]. Triggered_and_resolved conflicts with new_value, unique_count and flow alerts, and with immediately and more_than_usual conditions
     */
    notifyOn?: string;
    /**
     * By default, retriggering_period_minutes will be populated with min for immediate, more_than and more_than_usual alerts. For less_than alert it will be populated with the chosen time frame for the less_than condition (in minutes). You may choose to change the suppress window so the alert will be suppressed for a longer period.
     */
    retriggeringPeriodMinutes?: number;
}

export interface AlertRatio {
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertRatioCondition;
    query1: outputs.AlertRatioQuery1;
    query2: outputs.AlertRatioQuery2;
}

export interface AlertRatioCondition {
    /**
     * The fields to 'group by' on.
     */
    groupBies?: string[];
    groupByBoth?: boolean;
    groupByQ1?: boolean;
    groupByQ2?: boolean;
    /**
     * Not triggered when threshold is infinity (divided by zero).
     */
    ignoreInfinity?: boolean;
    lessThan?: boolean;
    /**
     * Manage your logs undetected values - when relevant, enable/disable triggering on undetected values and change the auto retire interval. By default (when relevant), triggering is enabled with retire-ratio=NEVER.
     */
    manageUndetectedValues?: outputs.AlertRatioConditionManageUndetectedValues;
    /**
     * Determines the condition operator. Must be one of - less_than or more_than.
     */
    moreThan?: boolean;
    /**
     * The ratio(between the queries) threshold that is needed to trigger the alert.
     */
    ratioThreshold: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["15Min" "30Min" "4H" "36H" "5Min" "20Min" "1H" "2H" "6H" "12H" "24H" "10Min"]
     */
    timeWindow: string;
}

export interface AlertRatioConditionManageUndetectedValues {
    /**
     * Defines the triggering auto-retire ratio. Can be one of ["1H" "2H" "6H" "12H" "24H" "Never" "5Min" "10Min"]
     */
    autoRetireRatio?: string;
    /**
     * Determines whether the deadman-option is enabled. When set to true, auto_retire_ratio is required otherwise auto_retire_ratio should be omitted.
     */
    enableTriggeringOnUndetectedValues: boolean;
}

export interface AlertRatioQuery1 {
    /**
     * Query1 alias.
     */
    alias?: string;
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * An array that contains log’s categories that we want to be notified on.
     */
    categories?: string[];
    /**
     * An array that contains log’s class names that we want to be notified on.
     */
    classes?: string[];
    /**
     * An array that contains log’s computer names that we want to be notified on.
     */
    computers?: string[];
    /**
     * An array that contains log’s IP addresses that we want to be notified on.
     */
    ipAddresses?: string[];
    /**
     * An array that contains log’s method names that we want to be notified on.
     */
    methods?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertRatioQuery2 {
    /**
     * Query2 alias.
     */
    alias?: string;
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertScheduling {
    /**
     * time_frame is a set of days and hours when the alert will be active. ***Currently, supported only for one time_frame***
     */
    timeFrame: outputs.AlertSchedulingTimeFrame;
    /**
     * Specifies the time zone to be used in interpreting the schedule. Can be one of ["UTC-11" "UTC-10" "UTC-9" "UTC-8" "UTC-7" "UTC-6" "UTC-5" "UTC-4" "UTC-3" "UTC-2" "UTC-1" "UTC+0" "UTC+1" "UTC+2" "UTC+3" "UTC+4" "UTC+5" "UTC+6" "UTC+7" "UTC+8" "UTC+9" "UTC+10" "UTC+11" "UTC+12" "UTC+13" "UTC+14"]
     */
    timeZone?: string;
}

export interface AlertSchedulingTimeFrame {
    /**
     * Days of week. Can be one of ["Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday"]
     */
    daysEnableds: string[];
    /**
     * Limit the triggering of this alert to end at specific hour.
     */
    endTime: string;
    /**
     * Limit the triggering of this alert to start at specific hour.
     */
    startTime: string;
}

export interface AlertStandard {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * An array that contains log’s categories that we want to be notified on.
     */
    categories?: string[];
    /**
     * An array that contains log’s class names that we want to be notified on.
     */
    classes?: string[];
    /**
     * An array that contains log’s computer names that we want to be notified on.
     */
    computers?: string[];
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertStandardCondition;
    /**
     * An array that contains log’s IP addresses that we want to be notified on.
     */
    ipAddresses?: string[];
    /**
     * An array that contains log’s method names that we want to be notified on.
     */
    methods?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertStandardCondition {
    /**
     * Defines the evaluation-window logic to determine if the threshold has been crossed. Relevant only for more_than condition. Can be one of ["Rolling" "Dynamic"].
     */
    evaluationWindow: string;
    /**
     * The fields to 'group by' on. In case of immediately = true switch to group_by_key.
     */
    groupBies?: string[];
    /**
     * The key to 'group by' on. When immediately = true, 'group_by_key' (single string) can be set instead of 'group_by'.
     */
    groupByKey?: string;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than or more_than_usual.
     */
    immediately?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than or more_than_usual.
     */
    lessThan?: boolean;
    /**
     * Manage your logs undetected values - when relevant, enable/disable triggering on undetected values and change the auto retire interval. By default (when relevant), triggering is enabled with retire-ratio=NEVER.
     */
    manageUndetectedValues?: outputs.AlertStandardConditionManageUndetectedValues;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than or more_than_usual.
     */
    moreThan?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately, less_than, more_than or more_than_usual.
     */
    moreThanUsual?: boolean;
    /**
     * The number of log occurrences that is needed to trigger the alert.
     */
    threshold?: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["15Min" "30Min" "4H" "36H" "5Min" "20Min" "1H" "2H" "6H" "12H" "24H" "10Min"]
     */
    timeWindow?: string;
}

export interface AlertStandardConditionManageUndetectedValues {
    /**
     * Defines the triggering auto-retire ratio. Can be one of ["1H" "2H" "6H" "12H" "24H" "Never" "5Min" "10Min"]
     */
    autoRetireRatio?: string;
    /**
     * Determines whether the deadman-option is enabled. When set to true, auto_retire_ratio is required otherwise auto_retire_ratio should be omitted.
     */
    enableTriggeringOnUndetectedValues: boolean;
}

export interface AlertTimeRelative {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * An array that contains log’s categories that we want to be notified on.
     */
    categories?: string[];
    /**
     * An array that contains log’s class names that we want to be notified on.
     */
    classes?: string[];
    /**
     * An array that contains log’s computer names that we want to be notified on.
     */
    computers?: string[];
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertTimeRelativeCondition;
    /**
     * An array that contains log’s IP addresses that we want to be notified on.
     */
    ipAddresses?: string[];
    /**
     * An array that contains log’s method names that we want to be notified on.
     */
    methods?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertTimeRelativeCondition {
    /**
     * The fields to 'group by' on.
     */
    groupBies?: string[];
    /**
     * Not triggered when threshold is infinity (divided by zero).
     */
    ignoreInfinity?: boolean;
    /**
     * Determines the condition operator. Must be one of - less_than or more_than.
     */
    lessThan?: boolean;
    /**
     * Manage your logs undetected values - when relevant, enable/disable triggering on undetected values and change the auto retire interval. By default (when relevant), triggering is enabled with retire-ratio=NEVER.
     */
    manageUndetectedValues?: outputs.AlertTimeRelativeConditionManageUndetectedValues;
    /**
     * Determines the condition operator. Must be one of - less_than or more_than.
     */
    moreThan?: boolean;
    /**
     * The ratio threshold that is needed to trigger the alert.
     */
    ratioThreshold: number;
    /**
     * Time-window to compare with. Can be one of ["Previous_hour" "Same_hour_yesterday" "Same_hour_last_week" "Yesterday" "Same_day_last_week" "Same_day_last_month"].
     */
    relativeTimeWindow: string;
}

export interface AlertTimeRelativeConditionManageUndetectedValues {
    /**
     * Defines the triggering auto-retire ratio. Can be one of ["1H" "2H" "6H" "12H" "24H" "Never" "5Min" "10Min"]
     */
    autoRetireRatio?: string;
    /**
     * Determines whether the deadman-option is enabled. When set to true, auto_retire_ratio is required otherwise auto_retire_ratio should be omitted.
     */
    enableTriggeringOnUndetectedValues: boolean;
}

export interface AlertTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AlertTracing {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:notEquals:xxx, filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertTracingCondition;
    latencyThresholdMilliseconds?: number;
    /**
     * An array that contains log’s services names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:notEquals:xxx, filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    services?: string[];
    /**
     * An array that contains log’s subsystems names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:notEquals:xxx, filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
    tagFilters?: outputs.AlertTracingTagFilter[];
}

export interface AlertTracingCondition {
    /**
     * The fields to 'group by' on.
     */
    groupBies?: string[];
    /**
     * Determines the condition operator. Must be one of - immediately or more_than.
     */
    immediately?: boolean;
    /**
     * Determines the condition operator. Must be one of - immediately or more_than.
     */
    moreThan?: boolean;
    /**
     * The number of log occurrences that is needed to trigger the alert.
     */
    threshold?: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["15Min" "30Min" "4H" "36H" "5Min" "20Min" "1H" "2H" "6H" "12H" "24H" "10Min"]
     */
    timeWindow?: string;
}

export interface AlertTracingTagFilter {
    field: string;
    /**
     * Tag filter values can be filtered by prefix, suffix, and contains using the next patterns - filter:notEquals:xxx, filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    values: string[];
}

export interface AlertUniqueCount {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * An array that contains log’s categories that we want to be notified on.
     */
    categories?: string[];
    /**
     * An array that contains log’s class names that we want to be notified on.
     */
    classes?: string[];
    /**
     * An array that contains log’s computer names that we want to be notified on.
     */
    computers?: string[];
    /**
     * Defines the conditions for triggering and notify by the alert
     */
    condition: outputs.AlertUniqueCountCondition;
    /**
     * An array that contains log’s IP addresses that we want to be notified on.
     */
    ipAddresses?: string[];
    /**
     * An array that contains log’s method names that we want to be notified on.
     */
    methods?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    searchQuery?: string;
    /**
     * An array of log severities that we interested in. Can be one of ["Debug" "Verbose" "Info" "Warning" "Error" "Critical"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on. Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface AlertUniqueCountCondition {
    /**
     * The key to 'group by' on.
     */
    groupByKey?: string;
    maxUniqueValues: number;
    maxUniqueValuesForGroupBy?: number;
    /**
     * The bounded time frame for the threshold to be occurred within, to trigger the alert. Can be one of ["1Min" "15Min" "30Min" "2H" "6H" "5Min" "10Min" "20Min" "1H" "4H" "12H" "24H"]
     */
    timeWindow: string;
    /**
     * Defines the key to match to track its unique count.
     */
    uniqueCountKey: string;
}

export interface AlertsSchedulerFilter {
    alertsUniqueIds?: string[];
    metaLabels?: outputs.AlertsSchedulerFilterMetaLabel[];
    /**
     * DataPrime query expression. - [DataPrime query language](https://coralogix.com/docs/dataprime-query-language/).
     */
    whatExpression: string;
}

export interface AlertsSchedulerFilterMetaLabel {
    key: string;
    value?: string;
}

export interface AlertsSchedulerMetaLabel {
    key: string;
    value?: string;
}

export interface AlertsSchedulerSchedule {
    oneTime?: outputs.AlertsSchedulerScheduleOneTime;
    /**
     * The operation to perform. Can be `mute` or `active`.
     */
    operation: string;
    recurring?: outputs.AlertsSchedulerScheduleRecurring;
}

export interface AlertsSchedulerScheduleOneTime {
    timeFrame: outputs.AlertsSchedulerScheduleOneTimeTimeFrame;
}

export interface AlertsSchedulerScheduleOneTimeTimeFrame {
    /**
     * The duration from the start time to wait.
     */
    duration?: outputs.AlertsSchedulerScheduleOneTimeTimeFrameDuration;
    /**
     * The end time of the time frame. In a isodate format. For example, `2021-01-01T00:00:00.000`.
     */
    endTime?: string;
    startTime: string;
    timeZone: string;
}

export interface AlertsSchedulerScheduleOneTimeTimeFrameDuration {
    /**
     * The number of time units to wait before the alert is triggered. For example, if the frequency is set to `hours` and the value is set to `2`, the alert will be triggered after 2 hours.
     */
    forOver: number;
    /**
     * The time unit to wait before the alert is triggered. Can be `minutes`, `hours` or `days`.
     */
    frequency: string;
}

export interface AlertsSchedulerScheduleRecurring {
    dynamic?: outputs.AlertsSchedulerScheduleRecurringDynamic;
}

export interface AlertsSchedulerScheduleRecurringDynamic {
    frequency: outputs.AlertsSchedulerScheduleRecurringDynamicFrequency;
    repeatEvery: number;
    terminationDate: string;
    timeFrame: outputs.AlertsSchedulerScheduleRecurringDynamicTimeFrame;
}

export interface AlertsSchedulerScheduleRecurringDynamicFrequency {
    daily?: outputs.AlertsSchedulerScheduleRecurringDynamicFrequencyDaily;
    monthly?: outputs.AlertsSchedulerScheduleRecurringDynamicFrequencyMonthly;
    weekly?: outputs.AlertsSchedulerScheduleRecurringDynamicFrequencyWeekly;
}

export interface AlertsSchedulerScheduleRecurringDynamicFrequencyDaily {
}

export interface AlertsSchedulerScheduleRecurringDynamicFrequencyMonthly {
    days?: number[];
}

export interface AlertsSchedulerScheduleRecurringDynamicFrequencyWeekly {
    days?: string[];
}

export interface AlertsSchedulerScheduleRecurringDynamicTimeFrame {
    /**
     * The duration from the start time to wait.
     */
    duration?: outputs.AlertsSchedulerScheduleRecurringDynamicTimeFrameDuration;
    /**
     * The end time of the time frame. In a isodate format. For example, `2021-01-01T00:00:00.000`.
     */
    endTime?: string;
    startTime: string;
    timeZone: string;
}

export interface AlertsSchedulerScheduleRecurringDynamicTimeFrameDuration {
    /**
     * The number of time units to wait before the alert is triggered. For example, if the frequency is set to `hours` and the value is set to `2`, the alert will be triggered after 2 hours.
     */
    forOver: number;
    /**
     * The time unit to wait before the alert is triggered. Can be `minutes`, `hours` or `days`.
     */
    frequency: string;
}

export interface ApiKeyOwner {
    organisationId?: string;
    teamId?: string;
    userId?: string;
}

export interface ArchiveMetricsIbm {
    crn: string;
    endpoint: string;
}

export interface ArchiveMetricsRetentionPolicy {
    fiveMinutesResolution: number;
    oneHourResolution: number;
    rawResolution: number;
}

export interface ArchiveMetricsS3 {
    /**
     * The bucket name to store the archived metrics in.
     */
    bucket: string;
    /**
     * The bucket region. see - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html#Concepts.RegionsAndAvailabilityZones.Regions
     */
    region: string;
}

export interface ArchiveRetentionsRetention {
    /**
     * Is the retention editable.
     */
    editable: boolean;
    /**
     * The retention id.
     */
    id: string;
    /**
     * The retention name. If not set, the retention will be named by backend.
     */
    name: string;
    /**
     * The retention order. Computed by the order of the retention in the retentions list definition.
     */
    order: number;
}

export interface DashboardAnnotation {
    enabled: boolean;
    id: string;
    name: string;
    source: outputs.DashboardAnnotationSource;
}

export interface DashboardAnnotationSource {
    logs?: outputs.DashboardAnnotationSourceLogs;
    metrics?: outputs.DashboardAnnotationSourceMetrics;
    spans?: outputs.DashboardAnnotationSourceSpans;
}

export interface DashboardAnnotationSourceLogs {
    labelFields?: outputs.DashboardAnnotationSourceLogsLabelField[];
    luceneQuery?: string;
    messageTemplate?: string;
    strategy: outputs.DashboardAnnotationSourceLogsStrategy;
}

export interface DashboardAnnotationSourceLogsLabelField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceLogsStrategy {
    duration?: outputs.DashboardAnnotationSourceLogsStrategyDuration;
    instant?: outputs.DashboardAnnotationSourceLogsStrategyInstant;
    range?: outputs.DashboardAnnotationSourceLogsStrategyRange;
}

export interface DashboardAnnotationSourceLogsStrategyDuration {
    durationField: outputs.DashboardAnnotationSourceLogsStrategyDurationDurationField;
    startTimestampField: outputs.DashboardAnnotationSourceLogsStrategyDurationStartTimestampField;
}

export interface DashboardAnnotationSourceLogsStrategyDurationDurationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceLogsStrategyDurationStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceLogsStrategyInstant {
    timestampField: outputs.DashboardAnnotationSourceLogsStrategyInstantTimestampField;
}

export interface DashboardAnnotationSourceLogsStrategyInstantTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceLogsStrategyRange {
    endTimestampField: outputs.DashboardAnnotationSourceLogsStrategyRangeEndTimestampField;
    startTimestampField: outputs.DashboardAnnotationSourceLogsStrategyRangeStartTimestampField;
}

export interface DashboardAnnotationSourceLogsStrategyRangeEndTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceLogsStrategyRangeStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceMetrics {
    labels?: string[];
    messageTemplate?: string;
    promqlQuery: string;
    strategy: outputs.DashboardAnnotationSourceMetricsStrategy;
}

export interface DashboardAnnotationSourceMetricsStrategy {
    startTime: outputs.DashboardAnnotationSourceMetricsStrategyStartTime;
}

export interface DashboardAnnotationSourceMetricsStrategyStartTime {
}

export interface DashboardAnnotationSourceSpans {
    labelFields?: outputs.DashboardAnnotationSourceSpansLabelField[];
    luceneQuery?: string;
    messageTemplate?: string;
    strategy: outputs.DashboardAnnotationSourceSpansStrategy;
}

export interface DashboardAnnotationSourceSpansLabelField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceSpansStrategy {
    duration?: outputs.DashboardAnnotationSourceSpansStrategyDuration;
    instant?: outputs.DashboardAnnotationSourceSpansStrategyInstant;
    range?: outputs.DashboardAnnotationSourceSpansStrategyRange;
}

export interface DashboardAnnotationSourceSpansStrategyDuration {
    durationField: outputs.DashboardAnnotationSourceSpansStrategyDurationDurationField;
    startTimestampField: outputs.DashboardAnnotationSourceSpansStrategyDurationStartTimestampField;
}

export interface DashboardAnnotationSourceSpansStrategyDurationDurationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceSpansStrategyDurationStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceSpansStrategyInstant {
    timestampField: outputs.DashboardAnnotationSourceSpansStrategyInstantTimestampField;
}

export interface DashboardAnnotationSourceSpansStrategyInstantTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceSpansStrategyRange {
    endTimestampField: outputs.DashboardAnnotationSourceSpansStrategyRangeEndTimestampField;
    startTimestampField: outputs.DashboardAnnotationSourceSpansStrategyRangeStartTimestampField;
}

export interface DashboardAnnotationSourceSpansStrategyRangeEndTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAnnotationSourceSpansStrategyRangeStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface DashboardAutoRefresh {
    type: string;
}

export interface DashboardFilter {
    collapsed: boolean;
    enabled: boolean;
    source: outputs.DashboardFilterSource;
}

export interface DashboardFilterSource {
    logs?: outputs.DashboardFilterSourceLogs;
    metrics?: outputs.DashboardFilterSourceMetrics;
    spans?: outputs.DashboardFilterSourceSpans;
}

export interface DashboardFilterSourceLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField?: outputs.DashboardFilterSourceLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardFilterSourceLogsOperator;
}

export interface DashboardFilterSourceLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardFilterSourceLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardFilterSourceMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardFilterSourceMetricsOperator;
}

export interface DashboardFilterSourceMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardFilterSourceSpans {
    field: outputs.DashboardFilterSourceSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardFilterSourceSpansOperator;
}

export interface DashboardFilterSourceSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardFilterSourceSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardFolder {
    id: string;
    path: string;
}

export interface DashboardLayout {
    sections?: outputs.DashboardLayoutSection[];
}

export interface DashboardLayoutSection {
    id: string;
    options?: outputs.DashboardLayoutSectionOptions;
    rows?: outputs.DashboardLayoutSectionRow[];
}

export interface DashboardLayoutSectionOptions {
    collapsed?: boolean;
    /**
     * Section color, valid values: [unspecified cyan green blue purple magenta pink orange]
     */
    color?: string;
    description?: string;
    name: string;
}

export interface DashboardLayoutSectionRow {
    /**
     * The height of the row.
     */
    height: number;
    id: string;
    /**
     * The list of widgets to display in the dashboard.
     */
    widgets?: outputs.DashboardLayoutSectionRowWidget[];
}

export interface DashboardLayoutSectionRowWidget {
    /**
     * The widget definition. Can contain one of 'line_chart', 'data_table', 'gauge', 'pie_chart', 'bar_chart', 'horizontal_bar_chart', 'markdown'.
     */
    definition: outputs.DashboardLayoutSectionRowWidgetDefinition;
    /**
     * Widget description.
     */
    description?: string;
    id: string;
    /**
     * Widget title. Required for all widgets except markdown.
     */
    title?: string;
    /**
     * The width of the chart.
     */
    width: number;
}

export interface DashboardLayoutSectionRowWidgetDefinition {
    barChart?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChart;
    dataTable?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTable;
    gauge?: outputs.DashboardLayoutSectionRowWidgetDefinitionGauge;
    horizontalBarChart?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChart;
    lineChart?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChart;
    markdown?: outputs.DashboardLayoutSectionRowWidgetDefinitionMarkdown;
    pieChart?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChart;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme?: string;
    colorsBy?: string;
    dataModeType: string;
    groupNameTemplate?: string;
    maxBarsPerChart?: number;
    query?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuery;
    scaleType: string;
    /**
     * The field to sort by. Can be one of unspecified, value, name.
     */
    sortBy: string;
    stackDefinition?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartStackDefinition;
    /**
     * The unit of the chart. Can be one of seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
    xaxis?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartXaxis;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuery {
    dataPrime?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrime;
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrime {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilter[];
    groupNames?: string[];
    query: string;
    stackedGroupName?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilter {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetricsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpans {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogs {
    aggregation: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilter[];
    groupNames?: string[];
    groupNamesFields?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsGroupNamesField[];
    luceneQuery?: string;
    stackedGroupName?: string;
    stackedGroupNameField?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsStackedGroupNameField;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetrics {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilter[];
    groupNames?: string[];
    promqlQuery: string;
    stackedGroupName?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpans {
    aggregation?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilter[];
    groupNames?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansGroupName[];
    luceneQuery?: string;
    stackedGroupName?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansStackedGroupName;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartStackDefinition {
    maxSlicesPerBar?: number;
    stackNameTemplate?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartXaxis {
    time?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartXaxisTime;
    value?: outputs.DashboardLayoutSectionRowWidgetDefinitionBarChartXaxisValue;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartXaxisTime {
    bucketsPresented?: number;
    /**
     * The time interval to use for the x-axis. Valid values are in duration format, for example `1m0s` or `1h0m0s` (currently leading zeros should be added).
     */
    interval: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionBarChartXaxisValue {
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTable {
    columns?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableColumn[];
    /**
     * The data mode type. Can be one of ["archive" "unspecified"].
     */
    dataModeType: string;
    orderBy?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableOrderBy;
    query: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuery;
    /**
     * The number of results to display per page.
     */
    resultsPerPage: number;
    /**
     * The style of the rows. Can be one of ["two_line" "condensed" "json" "one_line"].
     */
    rowStyle: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableColumn {
    field: string;
    width: number;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableOrderBy {
    field?: string;
    /**
     * The order direction. Can be one of ["asc" "desc"].
     */
    orderDirection: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuery {
    dataPrime?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrime;
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrime {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilter[];
    query?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilter {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetricsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpans {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogs {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilter[];
    grouping?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGrouping;
    luceneQuery?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGrouping {
    aggregations?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregation[];
    groupBies?: string[];
    groupBys?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingGroupBy[];
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregation {
    aggregation: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregation;
    id: string;
    isVisible: boolean;
    name?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingGroupBy {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetrics {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilter[];
    promqlQuery: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpans {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilter[];
    grouping?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGrouping;
    luceneQuery?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGrouping {
    aggregations?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregation[];
    groupBies?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingGroupBy[];
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregation {
    aggregation?: outputs.DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregationAggregation;
    id: string;
    isVisible: boolean;
    name?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregationAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingGroupBy {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGauge {
    /**
     * The data mode type. Can be one of ["archive" "unspecified"].
     */
    dataModeType: string;
    max: number;
    min: number;
    query: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuery;
    showInnerArc: boolean;
    showOuterArc: boolean;
    /**
     * The threshold by. Can be one of ["unspecified" "value" "background"].
     */
    thresholdBy: string;
    thresholds?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeThreshold[];
    /**
     * The unit of the gauge. Can be one of ["milliseconds" "bytes" "gbytes" "bytes_iec" "gibytes" "usd" "none" "microseconds" "euro_cents" "usd_cents" "percent" "kbytes" "mibytes" "mbytes" "kibytes" "seconds" "euro"].
     */
    unit: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuery {
    dataPrime?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrime;
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrime {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilter[];
    query?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilter {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetricsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpans {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogs {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilter[];
    logsAggregation: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregation;
    luceneQuery?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetrics {
    /**
     * The type of aggregation. Can be one of ["min" "max" "avg" "sum" "unspecified" "last"].
     */
    aggregation: string;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilter[];
    promqlQuery: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpans {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilter[];
    luceneQuery?: string;
    spansAggregation?: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansSpansAggregation;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansSpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionGaugeThreshold {
    color?: string;
    from?: number;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme?: string;
    colorsBy?: string;
    dataModeType: string;
    displayOnBar: boolean;
    groupNameTemplate?: string;
    maxBarsPerChart?: number;
    query?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuery;
    scaleType: string;
    sortBy: string;
    stackDefinition?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartStackDefinition;
    /**
     * The unit of the chart. Can be one of seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
    yAxisViewBy?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuery {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogs {
    aggregation: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilter[];
    groupNames?: string[];
    groupNamesFields?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsGroupNamesField[];
    luceneQuery?: string;
    stackedGroupName?: string;
    stackedGroupNameField?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsStackedGroupNameField;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetrics {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilter[];
    groupNames?: string[];
    promqlQuery: string;
    stackedGroupName?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpans {
    aggregation?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilter[];
    groupNames?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansGroupName[];
    luceneQuery?: string;
    stackedGroupName?: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansStackedGroupName;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartStackDefinition {
    maxSlicesPerBar?: number;
    stackNameTemplate?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChart {
    legend?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartLegend;
    queryDefinitions: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinition[];
    tooltip?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartTooltip;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartLegend {
    /**
     * The columns to display in the legend. Valid values are: sum, avg, last, unspecified, min, max.
     */
    columns?: string[];
    groupByQuery: boolean;
    /**
     * Whether to display the legend. False by default.
     */
    isVisible: boolean;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinition {
    colorScheme?: string;
    dataModeType: string;
    id: string;
    isVisible: boolean;
    name?: string;
    query: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuery;
    resolution?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionResolution;
    /**
     * The scale type. Valid values are: unspecified, linear, logarithmic.
     */
    scaleType: string;
    seriesCountLimit?: number;
    seriesNameTemplate?: string;
    /**
     * The unit. Valid values are: seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuery {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogs {
    aggregations: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregation[];
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilter[];
    groupBies?: string[];
    luceneQuery?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetrics {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilter[];
    promqlQuery: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpans {
    aggregations?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansAggregation[];
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilter[];
    groupBies?: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansGroupBy[];
    luceneQuery?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansGroupBy {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionResolution {
    bucketsPresented?: number;
    interval?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionLineChartTooltip {
    showLabels: boolean;
    /**
     * The tooltip type. Valid values are: all, single, unspecified.
     */
    type?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionMarkdown {
    markdownText?: string;
    tooltipText?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme?: string;
    dataModeType: string;
    groupNameTemplate?: string;
    labelDefinition: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartLabelDefinition;
    maxSlicesPerChart?: number;
    minSlicePercentage?: number;
    query: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuery;
    showLegend: boolean;
    stackDefinition?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartStackDefinition;
    unit: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartLabelDefinition {
    isVisible: boolean;
    /**
     * The source of the label. Valid values are: stack, unspecified, inner
     */
    labelSource: string;
    showName: boolean;
    showPercentage: boolean;
    showValue: boolean;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuery {
    dataPrime?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrime;
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrime {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilter[];
    groupNames?: string[];
    query: string;
    stackedGroupName?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilter {
    logs?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogs;
    metrics?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetrics;
    spans?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpans;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetricsOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpans {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogs {
    aggregation: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilter[];
    groupNames?: string[];
    groupNamesFields?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsGroupNamesField[];
    luceneQuery?: string;
    stackedGroupName?: string;
    stackedGroupNameField?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsStackedGroupNameField;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregation {
    field?: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent?: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilter {
    field: string;
    observationField?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetrics {
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilter[];
    groupNames?: string[];
    promqlQuery: string;
    stackedGroupName?: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label?: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpans {
    aggregation?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansAggregation;
    filters?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilter[];
    groupNames?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansGroupName[];
    luceneQuery?: string;
    stackedGroupName?: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansStackedGroupName;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilter {
    field: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterOperator;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues?: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardLayoutSectionRowWidgetDefinitionPieChartStackDefinition {
    maxSlicesPerStack?: number;
    stackNameTemplate?: string;
}

export interface DashboardTimeFrame {
    /**
     * Absolute time frame specifying a fixed start and end time.
     */
    absolute?: outputs.DashboardTimeFrameAbsolute;
    /**
     * Relative time frame specifying a duration from the current time.
     */
    relative?: outputs.DashboardTimeFrameRelative;
}

export interface DashboardTimeFrameAbsolute {
    end: string;
    start: string;
}

export interface DashboardTimeFrameRelative {
    duration: string;
}

export interface DashboardVariable {
    definition: outputs.DashboardVariableDefinition;
    displayName: string;
    name?: string;
}

export interface DashboardVariableDefinition {
    constantValue?: string;
    multiSelect?: outputs.DashboardVariableDefinitionMultiSelect;
}

export interface DashboardVariableDefinitionMultiSelect {
    selectedValues?: string[];
    source?: outputs.DashboardVariableDefinitionMultiSelectSource;
    /**
     * The order direction of the values. Can be one of `asc`, `desc`.
     */
    valuesOrderDirection: string;
}

export interface DashboardVariableDefinitionMultiSelectSource {
    constantLists?: string[];
    logsPath?: string;
    metricLabel?: outputs.DashboardVariableDefinitionMultiSelectSourceMetricLabel;
    query?: outputs.DashboardVariableDefinitionMultiSelectSourceQuery;
    spanField?: outputs.DashboardVariableDefinitionMultiSelectSourceSpanField;
}

export interface DashboardVariableDefinitionMultiSelectSourceMetricLabel {
    label: string;
    metricName: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQuery {
    query: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQuery;
    refreshStrategy: string;
    valueDisplayOptions?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryValueDisplayOptions;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQuery {
    logs?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryLogs;
    metrics?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetrics;
    spans?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQuerySpans;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryLogs {
    fieldName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldName;
    fieldValue?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValue;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldName {
    logRegex: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValue {
    observationField: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValueObservationField;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValueObservationField {
    keypaths: string[];
    scope: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetrics {
    labelName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelName;
    labelValue?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValue;
    metricName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsMetricName;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelName {
    metricRegex: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValue {
    labelFilters?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilter[];
    labelName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelName;
    metricName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueMetricName;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilter {
    label?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterLabel;
    metric?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterMetric;
    operator?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperator;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterLabel {
    stringValue?: string;
    variableName?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterMetric {
    stringValue?: string;
    variableName?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperator {
    selectedValues?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperatorSelectedValue[];
    type: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperatorSelectedValue {
    stringValue?: string;
    variableName?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelName {
    stringValue?: string;
    variableName?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueMetricName {
    stringValue?: string;
    variableName?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsMetricName {
    metricRegex: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQuerySpans {
    fieldName?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldName;
    fieldValue?: outputs.DashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldValue;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldName {
    spanRegex: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldValue {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceQueryValueDisplayOptions {
    labelRegex?: string;
    valueRegex?: string;
}

export interface DashboardVariableDefinitionMultiSelectSourceSpanField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface DataSetTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface DataSetUploadedFile {
    modificationTimeUploaded: string;
    path: string;
    updatedFromUploading?: boolean;
}

export interface EnrichmentAws {
    /**
     * Set of fields to enrich with aws information.
     */
    fields?: outputs.EnrichmentAwsField[];
}

export interface EnrichmentAwsField {
    id: number;
    name: string;
    resource: string;
}

export interface EnrichmentCustom {
    customEnrichmentId: number;
    /**
     * Set of fields to enrich with the custom information.
     */
    fields?: outputs.EnrichmentCustomField[];
}

export interface EnrichmentCustomField {
    id: number;
    name: string;
}

export interface EnrichmentGeoIp {
    /**
     * Set of fields to enrich with geo_ip information.
     */
    fields?: outputs.EnrichmentGeoIpField[];
}

export interface EnrichmentGeoIpField {
    id: number;
    name: string;
}

export interface EnrichmentSuspiciousIp {
    /**
     * Set of fields to enrich with suspicious_ip information.
     */
    fields?: outputs.EnrichmentSuspiciousIpField[];
}

export interface EnrichmentSuspiciousIpField {
    id: number;
    name: string;
}

export interface EnrichmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface Events2metricLogsQuery {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    lucene?: string;
    /**
     * An array of severities that we interested in. Can be one of ["Error" "Critical" "Unspecified" "Debug" "Verbose" "Info" "Warning"]
     */
    severities?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on.  Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface Events2metricMetricFields {
    aggregations: outputs.Events2metricMetricFieldsAggregations;
    sourceField: string;
}

export interface Events2metricMetricFieldsAggregations {
    avg: outputs.Events2metricMetricFieldsAggregationsAvg;
    count: outputs.Events2metricMetricFieldsAggregationsCount;
    histogram: outputs.Events2metricMetricFieldsAggregationsHistogram;
    max: outputs.Events2metricMetricFieldsAggregationsMax;
    min: outputs.Events2metricMetricFieldsAggregationsMin;
    samples: outputs.Events2metricMetricFieldsAggregationsSamples;
    sum: outputs.Events2metricMetricFieldsAggregationsSum;
}

export interface Events2metricMetricFieldsAggregationsAvg {
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricMetricFieldsAggregationsCount {
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricMetricFieldsAggregationsHistogram {
    buckets: number[];
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricMetricFieldsAggregationsMax {
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricMetricFieldsAggregationsMin {
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricMetricFieldsAggregationsSamples {
    enable: boolean;
    targetMetricName: string;
    /**
     * Can be one of ["Min" "Max"].
     */
    type: string;
}

export interface Events2metricMetricFieldsAggregationsSum {
    enable: boolean;
    targetMetricName: string;
}

export interface Events2metricPermutations {
    /**
     * Notify if the limit permutations' limit of the events2metric has exceed (computed).
     */
    hasExceedLimit: boolean;
    /**
     * Defines the permutations' limit of the events2metric.
     */
    limit: number;
}

export interface Events2metricSpansQuery {
    /**
     * An array that contains log’s actions names that we want to be notified on.  Actions can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    actions?: string[];
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications?: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    lucene?: string;
    /**
     * An array that contains log’s services names that we want to be notified on.  Services can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    services?: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on.  Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems?: string[];
}

export interface GetAlertExpirationDate {
    day: number;
    month: number;
    year: number;
}

export interface GetAlertFlow {
    groupBies: string[];
    stages: outputs.GetAlertFlowStage[];
}

export interface GetAlertFlowStage {
    groups: outputs.GetAlertFlowStageGroup[];
    timeWindows: outputs.GetAlertFlowStageTimeWindow[];
}

export interface GetAlertFlowStageGroup {
    nextOperator: string;
    subAlerts: outputs.GetAlertFlowStageGroupSubAlert[];
}

export interface GetAlertFlowStageGroupSubAlert {
    flowAlerts: outputs.GetAlertFlowStageGroupSubAlertFlowAlert[];
    operator: string;
}

export interface GetAlertFlowStageGroupSubAlertFlowAlert {
    not: boolean;
    userAlertId: string;
}

export interface GetAlertFlowStageTimeWindow {
    hours: number;
    minutes: number;
    seconds: number;
}

export interface GetAlertIncidentSetting {
    notifyOn: string;
    retriggeringPeriodMinutes: number;
}

export interface GetAlertMetric {
    lucenes: outputs.GetAlertMetricLucene[];
    promqls: outputs.GetAlertMetricPromql[];
}

export interface GetAlertMetricLucene {
    conditions: outputs.GetAlertMetricLuceneCondition[];
    searchQuery: string;
}

export interface GetAlertMetricLuceneCondition {
    arithmeticOperator: string;
    arithmeticOperatorModifier: number;
    groupBies: string[];
    lessThan: boolean;
    manageUndetectedValues: outputs.GetAlertMetricLuceneConditionManageUndetectedValue[];
    metricField: string;
    minNonNullValuesPercentage: number;
    moreThan: boolean;
    replaceMissingValueWithZero: boolean;
    sampleThresholdPercentage: number;
    threshold: number;
    timeWindow: string;
}

export interface GetAlertMetricLuceneConditionManageUndetectedValue {
    autoRetireRatio: string;
    enableTriggeringOnUndetectedValues: boolean;
}

export interface GetAlertMetricPromql {
    conditions: outputs.GetAlertMetricPromqlCondition[];
    searchQuery: string;
}

export interface GetAlertMetricPromqlCondition {
    lessThan: boolean;
    lessThanOrEqual: boolean;
    lessThanUsual: boolean;
    manageUndetectedValues: outputs.GetAlertMetricPromqlConditionManageUndetectedValue[];
    minNonNullValuesPercentage: number;
    moreThan: boolean;
    moreThanOrEqual: boolean;
    moreThanUsual: boolean;
    replaceMissingValueWithZero: boolean;
    sampleThresholdPercentage: number;
    threshold: number;
    timeWindow: string;
}

export interface GetAlertMetricPromqlConditionManageUndetectedValue {
    autoRetireRatio: string;
    enableTriggeringOnUndetectedValues: boolean;
}

export interface GetAlertNewValue {
    applications: string[];
    categories: string[];
    classes: string[];
    computers: string[];
    conditions: outputs.GetAlertNewValueCondition[];
    ipAddresses: string[];
    methods: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertNewValueCondition {
    keyToTrack: string;
    timeWindow: string;
}

export interface GetAlertNotificationsGroup {
    groupByFields: string[];
    notifications: outputs.GetAlertNotificationsGroupNotification[];
}

export interface GetAlertNotificationsGroupNotification {
    emailRecipients: string[];
    integrationId: string;
    notifyOn: string;
    retriggeringPeriodMinutes: number;
}

export interface GetAlertRatio {
    conditions: outputs.GetAlertRatioCondition[];
    query1s: outputs.GetAlertRatioQuery1[];
    query2s: outputs.GetAlertRatioQuery2[];
}

export interface GetAlertRatioCondition {
    groupBies: string[];
    groupByBoth: boolean;
    groupByQ1: boolean;
    groupByQ2: boolean;
    ignoreInfinity: boolean;
    lessThan: boolean;
    manageUndetectedValues: outputs.GetAlertRatioConditionManageUndetectedValue[];
    moreThan: boolean;
    ratioThreshold: number;
    timeWindow: string;
}

export interface GetAlertRatioConditionManageUndetectedValue {
    autoRetireRatio: string;
    enableTriggeringOnUndetectedValues: boolean;
}

export interface GetAlertRatioQuery1 {
    alias: string;
    applications: string[];
    categories: string[];
    classes: string[];
    computers: string[];
    ipAddresses: string[];
    methods: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertRatioQuery2 {
    alias: string;
    applications: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertScheduling {
    timeFrames: outputs.GetAlertSchedulingTimeFrame[];
    timeZone: string;
}

export interface GetAlertSchedulingTimeFrame {
    daysEnableds: string[];
    endTime: string;
    startTime: string;
}

export interface GetAlertStandard {
    applications: string[];
    categories: string[];
    classes: string[];
    computers: string[];
    conditions: outputs.GetAlertStandardCondition[];
    ipAddresses: string[];
    methods: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertStandardCondition {
    evaluationWindow: string;
    groupBies: string[];
    groupByKey: string;
    immediately: boolean;
    lessThan: boolean;
    manageUndetectedValues: outputs.GetAlertStandardConditionManageUndetectedValue[];
    moreThan: boolean;
    moreThanUsual: boolean;
    threshold: number;
    timeWindow: string;
}

export interface GetAlertStandardConditionManageUndetectedValue {
    autoRetireRatio: string;
    enableTriggeringOnUndetectedValues: boolean;
}

export interface GetAlertTimeRelative {
    applications: string[];
    categories: string[];
    classes: string[];
    computers: string[];
    conditions: outputs.GetAlertTimeRelativeCondition[];
    ipAddresses: string[];
    methods: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertTimeRelativeCondition {
    groupBies: string[];
    ignoreInfinity: boolean;
    lessThan: boolean;
    manageUndetectedValues: outputs.GetAlertTimeRelativeConditionManageUndetectedValue[];
    moreThan: boolean;
    ratioThreshold: number;
    relativeTimeWindow: string;
}

export interface GetAlertTimeRelativeConditionManageUndetectedValue {
    autoRetireRatio: string;
    enableTriggeringOnUndetectedValues: boolean;
}

export interface GetAlertTracing {
    applications: string[];
    conditions: outputs.GetAlertTracingCondition[];
    latencyThresholdMilliseconds: number;
    services: string[];
    subsystems: string[];
    tagFilters: outputs.GetAlertTracingTagFilter[];
}

export interface GetAlertTracingCondition {
    groupBies: string[];
    immediately: boolean;
    moreThan: boolean;
    threshold: number;
    timeWindow: string;
}

export interface GetAlertTracingTagFilter {
    field: string;
    values: string[];
}

export interface GetAlertUniqueCount {
    applications: string[];
    categories: string[];
    classes: string[];
    computers: string[];
    conditions: outputs.GetAlertUniqueCountCondition[];
    ipAddresses: string[];
    methods: string[];
    searchQuery: string;
    severities: string[];
    subsystems: string[];
}

export interface GetAlertUniqueCountCondition {
    groupByKey: string;
    maxUniqueValues: number;
    maxUniqueValuesForGroupBy: number;
    timeWindow: string;
    uniqueCountKey: string;
}

export interface GetAlertsSchedulerFilter {
    alertsUniqueIds: string[];
    metaLabels: outputs.GetAlertsSchedulerFilterMetaLabel[];
    /**
     * DataPrime query expression. - [DataPrime query language](https://coralogix.com/docs/dataprime-query-language/).
     */
    whatExpression: string;
}

export interface GetAlertsSchedulerFilterMetaLabel {
    key: string;
    value: string;
}

export interface GetAlertsSchedulerMetaLabel {
    key: string;
    value: string;
}

export interface GetAlertsSchedulerSchedule {
    oneTime: outputs.GetAlertsSchedulerScheduleOneTime;
    /**
     * The operation to perform. Can be `mute` or `active`.
     */
    operation: string;
    recurring: outputs.GetAlertsSchedulerScheduleRecurring;
}

export interface GetAlertsSchedulerScheduleOneTime {
    timeFrame: outputs.GetAlertsSchedulerScheduleOneTimeTimeFrame;
}

export interface GetAlertsSchedulerScheduleOneTimeTimeFrame {
    /**
     * The duration from the start time to wait.
     */
    duration: outputs.GetAlertsSchedulerScheduleOneTimeTimeFrameDuration;
    /**
     * The end time of the time frame. In a isodate format. For example, `2021-01-01T00:00:00.000`.
     */
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface GetAlertsSchedulerScheduleOneTimeTimeFrameDuration {
    /**
     * The number of time units to wait before the alert is triggered. For example, if the frequency is set to `hours` and the value is set to `2`, the alert will be triggered after 2 hours.
     */
    forOver: number;
    /**
     * The time unit to wait before the alert is triggered. Can be `minutes`, `hours` or `days`.
     */
    frequency: string;
}

export interface GetAlertsSchedulerScheduleRecurring {
    dynamic: outputs.GetAlertsSchedulerScheduleRecurringDynamic;
}

export interface GetAlertsSchedulerScheduleRecurringDynamic {
    frequency: outputs.GetAlertsSchedulerScheduleRecurringDynamicFrequency;
    repeatEvery: number;
    terminationDate: string;
    timeFrame: outputs.GetAlertsSchedulerScheduleRecurringDynamicTimeFrame;
}

export interface GetAlertsSchedulerScheduleRecurringDynamicFrequency {
    daily: outputs.GetAlertsSchedulerScheduleRecurringDynamicFrequencyDaily;
    monthly: outputs.GetAlertsSchedulerScheduleRecurringDynamicFrequencyMonthly;
    weekly: outputs.GetAlertsSchedulerScheduleRecurringDynamicFrequencyWeekly;
}

export interface GetAlertsSchedulerScheduleRecurringDynamicFrequencyDaily {
}

export interface GetAlertsSchedulerScheduleRecurringDynamicFrequencyMonthly {
    days: number[];
}

export interface GetAlertsSchedulerScheduleRecurringDynamicFrequencyWeekly {
    days: string[];
}

export interface GetAlertsSchedulerScheduleRecurringDynamicTimeFrame {
    /**
     * The duration from the start time to wait.
     */
    duration: outputs.GetAlertsSchedulerScheduleRecurringDynamicTimeFrameDuration;
    /**
     * The end time of the time frame. In a isodate format. For example, `2021-01-01T00:00:00.000`.
     */
    endTime: string;
    startTime: string;
    timeZone: string;
}

export interface GetAlertsSchedulerScheduleRecurringDynamicTimeFrameDuration {
    /**
     * The number of time units to wait before the alert is triggered. For example, if the frequency is set to `hours` and the value is set to `2`, the alert will be triggered after 2 hours.
     */
    forOver: number;
    /**
     * The time unit to wait before the alert is triggered. Can be `minutes`, `hours` or `days`.
     */
    frequency: string;
}

export interface GetApiKeyOwner {
    organisationId: string;
    teamId: string;
    userId: string;
}

export interface GetArchiveMetricsIbm {
    crn: string;
    endpoint: string;
}

export interface GetArchiveMetricsRetentionPolicy {
    fiveMinutesResolution: number;
    oneHourResolution: number;
    rawResolution: number;
}

export interface GetArchiveMetricsS3 {
    /**
     * The bucket name to store the archived metrics in.
     */
    bucket: string;
    /**
     * The bucket region. see - https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.RegionsAndAvailabilityZones.html#Concepts.RegionsAndAvailabilityZones.Regions
     */
    region: string;
}

export interface GetArchiveRetentionsRetention {
    /**
     * Is the retention editable.
     */
    editable: boolean;
    /**
     * The retention id.
     */
    id: string;
    /**
     * The retention name. If not set, the retention will be named by backend.
     */
    name: string;
    /**
     * The retention order. Computed by the order of the retention in the retentions list definition.
     */
    order: number;
}

export interface GetDashboardAnnotation {
    enabled: boolean;
    id: string;
    name: string;
    source: outputs.GetDashboardAnnotationSource;
}

export interface GetDashboardAnnotationSource {
    logs: outputs.GetDashboardAnnotationSourceLogs;
    metrics: outputs.GetDashboardAnnotationSourceMetrics;
    spans: outputs.GetDashboardAnnotationSourceSpans;
}

export interface GetDashboardAnnotationSourceLogs {
    labelFields: outputs.GetDashboardAnnotationSourceLogsLabelField[];
    luceneQuery: string;
    messageTemplate: string;
    strategy: outputs.GetDashboardAnnotationSourceLogsStrategy;
}

export interface GetDashboardAnnotationSourceLogsLabelField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceLogsStrategy {
    duration: outputs.GetDashboardAnnotationSourceLogsStrategyDuration;
    instant: outputs.GetDashboardAnnotationSourceLogsStrategyInstant;
    range: outputs.GetDashboardAnnotationSourceLogsStrategyRange;
}

export interface GetDashboardAnnotationSourceLogsStrategyDuration {
    durationField: outputs.GetDashboardAnnotationSourceLogsStrategyDurationDurationField;
    startTimestampField: outputs.GetDashboardAnnotationSourceLogsStrategyDurationStartTimestampField;
}

export interface GetDashboardAnnotationSourceLogsStrategyDurationDurationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceLogsStrategyDurationStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceLogsStrategyInstant {
    timestampField: outputs.GetDashboardAnnotationSourceLogsStrategyInstantTimestampField;
}

export interface GetDashboardAnnotationSourceLogsStrategyInstantTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceLogsStrategyRange {
    endTimestampField: outputs.GetDashboardAnnotationSourceLogsStrategyRangeEndTimestampField;
    startTimestampField: outputs.GetDashboardAnnotationSourceLogsStrategyRangeStartTimestampField;
}

export interface GetDashboardAnnotationSourceLogsStrategyRangeEndTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceLogsStrategyRangeStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceMetrics {
    labels: string[];
    messageTemplate: string;
    promqlQuery: string;
    strategy: outputs.GetDashboardAnnotationSourceMetricsStrategy;
}

export interface GetDashboardAnnotationSourceMetricsStrategy {
    startTime: outputs.GetDashboardAnnotationSourceMetricsStrategyStartTime;
}

export interface GetDashboardAnnotationSourceMetricsStrategyStartTime {
}

export interface GetDashboardAnnotationSourceSpans {
    labelFields: outputs.GetDashboardAnnotationSourceSpansLabelField[];
    luceneQuery: string;
    messageTemplate: string;
    strategy: outputs.GetDashboardAnnotationSourceSpansStrategy;
}

export interface GetDashboardAnnotationSourceSpansLabelField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceSpansStrategy {
    duration: outputs.GetDashboardAnnotationSourceSpansStrategyDuration;
    instant: outputs.GetDashboardAnnotationSourceSpansStrategyInstant;
    range: outputs.GetDashboardAnnotationSourceSpansStrategyRange;
}

export interface GetDashboardAnnotationSourceSpansStrategyDuration {
    durationField: outputs.GetDashboardAnnotationSourceSpansStrategyDurationDurationField;
    startTimestampField: outputs.GetDashboardAnnotationSourceSpansStrategyDurationStartTimestampField;
}

export interface GetDashboardAnnotationSourceSpansStrategyDurationDurationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceSpansStrategyDurationStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceSpansStrategyInstant {
    timestampField: outputs.GetDashboardAnnotationSourceSpansStrategyInstantTimestampField;
}

export interface GetDashboardAnnotationSourceSpansStrategyInstantTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceSpansStrategyRange {
    endTimestampField: outputs.GetDashboardAnnotationSourceSpansStrategyRangeEndTimestampField;
    startTimestampField: outputs.GetDashboardAnnotationSourceSpansStrategyRangeStartTimestampField;
}

export interface GetDashboardAnnotationSourceSpansStrategyRangeEndTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAnnotationSourceSpansStrategyRangeStartTimestampField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardAutoRefresh {
    type: string;
}

export interface GetDashboardFilter {
    collapsed: boolean;
    enabled: boolean;
    source: outputs.GetDashboardFilterSource;
}

export interface GetDashboardFilterSource {
    logs: outputs.GetDashboardFilterSourceLogs;
    metrics: outputs.GetDashboardFilterSourceMetrics;
    spans: outputs.GetDashboardFilterSourceSpans;
}

export interface GetDashboardFilterSourceLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField: outputs.GetDashboardFilterSourceLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardFilterSourceLogsOperator;
}

export interface GetDashboardFilterSourceLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardFilterSourceLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardFilterSourceMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardFilterSourceMetricsOperator;
}

export interface GetDashboardFilterSourceMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardFilterSourceSpans {
    field: outputs.GetDashboardFilterSourceSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardFilterSourceSpansOperator;
}

export interface GetDashboardFilterSourceSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardFilterSourceSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardFolder {
    id: string;
    path: string;
}

export interface GetDashboardLayout {
    sections: outputs.GetDashboardLayoutSection[];
}

export interface GetDashboardLayoutSection {
    id: string;
    options: outputs.GetDashboardLayoutSectionOptions;
    rows: outputs.GetDashboardLayoutSectionRow[];
}

export interface GetDashboardLayoutSectionOptions {
    collapsed: boolean;
    /**
     * Section color, valid values: [unspecified cyan green blue purple magenta pink orange]
     */
    color: string;
    description: string;
    name: string;
}

export interface GetDashboardLayoutSectionRow {
    /**
     * The height of the row.
     */
    height: number;
    id: string;
    /**
     * The list of widgets to display in the dashboard.
     */
    widgets: outputs.GetDashboardLayoutSectionRowWidget[];
}

export interface GetDashboardLayoutSectionRowWidget {
    /**
     * The widget definition. Can contain one of 'line_chart', 'data_table', 'gauge', 'pie_chart', 'bar_chart', 'horizontal_bar_chart', 'markdown'.
     */
    definition: outputs.GetDashboardLayoutSectionRowWidgetDefinition;
    /**
     * Widget description.
     */
    description: string;
    id: string;
    /**
     * Widget title. Required for all widgets except markdown.
     */
    title: string;
    /**
     * The width of the chart.
     */
    width: number;
}

export interface GetDashboardLayoutSectionRowWidgetDefinition {
    barChart: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChart;
    dataTable: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTable;
    gauge: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGauge;
    horizontalBarChart: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChart;
    lineChart: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChart;
    markdown: outputs.GetDashboardLayoutSectionRowWidgetDefinitionMarkdown;
    pieChart: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChart;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme: string;
    colorsBy: string;
    dataModeType: string;
    groupNameTemplate: string;
    maxBarsPerChart: number;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuery;
    scaleType: string;
    /**
     * The field to sort by. Can be one of unspecified, value, name.
     */
    sortBy: string;
    stackDefinition: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartStackDefinition;
    /**
     * The unit of the chart. Can be one of seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
    xaxis: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxis;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuery {
    dataPrime: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrime;
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrime {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilter[];
    groupNames: string[];
    query: string;
    stackedGroupName: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilter {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetricsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpans {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogs {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilter[];
    groupNames: string[];
    groupNamesFields: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsGroupNamesField[];
    luceneQuery: string;
    stackedGroupName: string;
    stackedGroupNameField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsStackedGroupNameField;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetrics {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilter[];
    groupNames: string[];
    promqlQuery: string;
    stackedGroupName: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpans {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilter[];
    groupNames: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansGroupName[];
    luceneQuery: string;
    stackedGroupName: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansStackedGroupName;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartStackDefinition {
    maxSlicesPerBar: number;
    stackNameTemplate: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxis {
    time: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxisTime;
    value: outputs.GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxisValue;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxisTime {
    bucketsPresented: number;
    /**
     * The time interval to use for the x-axis. Valid values are in duration format, for example `1m0s` or `1h0m0s` (currently leading zeros should be added).
     */
    interval: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionBarChartXaxisValue {
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTable {
    columns: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableColumn[];
    /**
     * The data mode type. Can be one of ["archive" "unspecified"].
     */
    dataModeType: string;
    orderBy: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableOrderBy;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuery;
    /**
     * The number of results to display per page.
     */
    resultsPerPage: number;
    /**
     * The style of the rows. Can be one of ["two_line" "condensed" "json" "one_line"].
     */
    rowStyle: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableColumn {
    field: string;
    width: number;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableOrderBy {
    field: string;
    /**
     * The order direction. Can be one of ["asc" "desc"].
     */
    orderDirection: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuery {
    dataPrime: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrime;
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrime {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilter[];
    query: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilter {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetricsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpans {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogs {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilter[];
    grouping: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGrouping;
    luceneQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGrouping {
    aggregations: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregation[];
    groupBies: string[];
    groupBys: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingGroupBy[];
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregation {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregation;
    id: string;
    isVisible: boolean;
    name: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingAggregationAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryLogsGroupingGroupBy {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetrics {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilter[];
    promqlQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpans {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilter[];
    grouping: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGrouping;
    luceneQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGrouping {
    aggregations: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregation[];
    groupBies: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingGroupBy[];
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregation {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregationAggregation;
    id: string;
    isVisible: boolean;
    name: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingAggregationAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionDataTableQuerySpansGroupingGroupBy {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGauge {
    /**
     * The data mode type. Can be one of ["archive" "unspecified"].
     */
    dataModeType: string;
    max: number;
    min: number;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuery;
    showInnerArc: boolean;
    showOuterArc: boolean;
    /**
     * The threshold by. Can be one of ["unspecified" "value" "background"].
     */
    thresholdBy: string;
    thresholds: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeThreshold[];
    /**
     * The unit of the gauge. Can be one of ["milliseconds" "bytes" "gbytes" "bytes_iec" "gibytes" "usd" "none" "microseconds" "euro_cents" "usd_cents" "percent" "kbytes" "mibytes" "mbytes" "kibytes" "seconds" "euro"].
     */
    unit: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuery {
    dataPrime: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrime;
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrime {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilter[];
    query: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilter {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetricsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpans {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogs {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilter[];
    logsAggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregation;
    luceneQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryLogsLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetrics {
    /**
     * The type of aggregation. Can be one of ["min" "max" "avg" "sum" "unspecified" "last"].
     */
    aggregation: string;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilter[];
    promqlQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpans {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilter[];
    luceneQuery: string;
    spansAggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansSpansAggregation;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeQuerySpansSpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionGaugeThreshold {
    color: string;
    from: number;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme: string;
    colorsBy: string;
    dataModeType: string;
    displayOnBar: boolean;
    groupNameTemplate: string;
    maxBarsPerChart: number;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuery;
    scaleType: string;
    sortBy: string;
    stackDefinition: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartStackDefinition;
    /**
     * The unit of the chart. Can be one of seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
    yAxisViewBy: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuery {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogs {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilter[];
    groupNames: string[];
    groupNamesFields: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsGroupNamesField[];
    luceneQuery: string;
    stackedGroupName: string;
    stackedGroupNameField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsStackedGroupNameField;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetrics {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilter[];
    groupNames: string[];
    promqlQuery: string;
    stackedGroupName: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpans {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilter[];
    groupNames: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansGroupName[];
    luceneQuery: string;
    stackedGroupName: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansStackedGroupName;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionHorizontalBarChartStackDefinition {
    maxSlicesPerBar: number;
    stackNameTemplate: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChart {
    legend: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartLegend;
    queryDefinitions: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinition[];
    tooltip: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartTooltip;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartLegend {
    /**
     * The columns to display in the legend. Valid values are: sum, avg, last, unspecified, min, max.
     */
    columns: string[];
    groupByQuery: boolean;
    /**
     * Whether to display the legend. False by default.
     */
    isVisible: boolean;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinition {
    colorScheme: string;
    dataModeType: string;
    id: string;
    isVisible: boolean;
    name: string;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuery;
    resolution: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionResolution;
    /**
     * The scale type. Valid values are: unspecified, linear, logarithmic.
     */
    scaleType: string;
    seriesCountLimit: number;
    seriesNameTemplate: string;
    /**
     * The unit. Valid values are: seconds, bytes, kbytes, mibytes, euro, usd, microseconds, milliseconds, gbytes, unspecified, mbytes, usd_cents, kibytes, euro_cents, bytes_iec, gibytes.
     */
    unit: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuery {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogs {
    aggregations: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregation[];
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilter[];
    groupBies: string[];
    luceneQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetrics {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilter[];
    promqlQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpans {
    aggregations: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansAggregation[];
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilter[];
    groupBies: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansGroupBy[];
    luceneQuery: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionQuerySpansGroupBy {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartQueryDefinitionResolution {
    bucketsPresented: number;
    interval: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionLineChartTooltip {
    showLabels: boolean;
    /**
     * The tooltip type. Valid values are: all, single, unspecified.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionMarkdown {
    markdownText: string;
    tooltipText: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChart {
    /**
     * The color scheme. Can be one of classic, severity, cold, negative, green, red, blue.
     */
    colorScheme: string;
    dataModeType: string;
    groupNameTemplate: string;
    labelDefinition: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartLabelDefinition;
    maxSlicesPerChart: number;
    minSlicePercentage: number;
    query: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuery;
    showLegend: boolean;
    stackDefinition: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartStackDefinition;
    unit: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartLabelDefinition {
    isVisible: boolean;
    /**
     * The source of the label. Valid values are: stack, unspecified, inner
     */
    labelSource: string;
    showName: boolean;
    showPercentage: boolean;
    showValue: boolean;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuery {
    dataPrime: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrime;
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrime {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilter[];
    groupNames: string[];
    query: string;
    stackedGroupName: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilter {
    logs: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogs;
    metrics: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetrics;
    spans: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpans;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogs {
    /**
     * Field in the logs to apply the filter on.
     */
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterLogsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetrics {
    label: string;
    metricName: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetricsOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterMetricsOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpans {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryDataPrimeFilterSpansOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogs {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilter[];
    groupNames: string[];
    groupNamesFields: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsGroupNamesField[];
    luceneQuery: string;
    stackedGroupName: string;
    stackedGroupNameField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsStackedGroupNameField;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregation {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregationObservationField;
    /**
     * The percentage of the aggregation to return. required when type is `percentile`.
     */
    percent: number;
    /**
     * The type of the aggregation. Can be one of ["count" "count_distinct" "sum" "avg" "min" "max" "percentile"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsAggregationObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilter {
    field: string;
    observationField: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterObservationField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsGroupNamesField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryLogsStackedGroupNameField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetrics {
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilter[];
    groupNames: string[];
    promqlQuery: string;
    stackedGroupName: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilter {
    /**
     * Label associated with the metric.
     */
    label: string;
    /**
     * Metric name to apply the filter on.
     */
    metric: string;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQueryMetricsFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpans {
    aggregation: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansAggregation;
    filters: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilter[];
    groupNames: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansGroupName[];
    luceneQuery: string;
    stackedGroupName: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansStackedGroupName;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansAggregation {
    /**
     * The type of the aggregation. When the aggregation type is `metrics`, can be one of ["percentile_50" "unspecified" "min" "max" "avg" "sum" "percentile_99" "percentile_95"]. When the aggregation type is `dimension`, can be one of ["unspecified" "unique_count" "error_count"].
     */
    aggregationType: string;
    /**
     * The field to aggregate on. When the aggregation type is `metrics`, can be one of ["duration" "unspecified"]. When the aggregation type is `dimension`, can be one of ["unspecified" "trace_id"].
     */
    field: string;
    /**
     * Can be one of ["metric" "dimension"]
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilter {
    field: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterField;
    /**
     * Operator to use for filtering.
     */
    operator: outputs.GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterOperator;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansFilterOperator {
    /**
     * the values to filter by. When the type is `equals`, this field is optional, the filter will match only the selected values, and all the values if not set. When the type is `not_equals`, this field is required, and the filter will match spans without the selected values.
     */
    selectedValues: string[];
    /**
     * The type of the operator. Can be one of `equals` or `not_equals`.
     */
    type: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartQuerySpansStackedGroupName {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardLayoutSectionRowWidgetDefinitionPieChartStackDefinition {
    maxSlicesPerStack: number;
    stackNameTemplate: string;
}

export interface GetDashboardTimeFrame {
    /**
     * Absolute time frame specifying a fixed start and end time.
     */
    absolute: outputs.GetDashboardTimeFrameAbsolute;
    /**
     * Relative time frame specifying a duration from the current time.
     */
    relative: outputs.GetDashboardTimeFrameRelative;
}

export interface GetDashboardTimeFrameAbsolute {
    end: string;
    start: string;
}

export interface GetDashboardTimeFrameRelative {
    duration: string;
}

export interface GetDashboardVariable {
    definition: outputs.GetDashboardVariableDefinition;
    displayName: string;
    name: string;
}

export interface GetDashboardVariableDefinition {
    constantValue: string;
    multiSelect: outputs.GetDashboardVariableDefinitionMultiSelect;
}

export interface GetDashboardVariableDefinitionMultiSelect {
    selectedValues: string[];
    source: outputs.GetDashboardVariableDefinitionMultiSelectSource;
    /**
     * The order direction of the values. Can be one of `asc`, `desc`.
     */
    valuesOrderDirection: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSource {
    constantLists: string[];
    logsPath: string;
    metricLabel: outputs.GetDashboardVariableDefinitionMultiSelectSourceMetricLabel;
    query: outputs.GetDashboardVariableDefinitionMultiSelectSourceQuery;
    spanField: outputs.GetDashboardVariableDefinitionMultiSelectSourceSpanField;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceMetricLabel {
    label: string;
    metricName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQuery {
    query: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQuery;
    refreshStrategy: string;
    valueDisplayOptions: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryValueDisplayOptions;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQuery {
    logs: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogs;
    metrics: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetrics;
    spans: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpans;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogs {
    fieldName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldName;
    fieldValue: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValue;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldName {
    logRegex: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValue {
    observationField: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValueObservationField;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryLogsFieldValueObservationField {
    keypaths: string[];
    scope: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetrics {
    labelName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelName;
    labelValue: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValue;
    metricName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsMetricName;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelName {
    metricRegex: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValue {
    labelFilters: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilter[];
    labelName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelName;
    metricName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueMetricName;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilter {
    label: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterLabel;
    metric: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterMetric;
    operator: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperator;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterLabel {
    stringValue: string;
    variableName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterMetric {
    stringValue: string;
    variableName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperator {
    selectedValues: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperatorSelectedValue[];
    type: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelFilterOperatorSelectedValue {
    stringValue: string;
    variableName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueLabelName {
    stringValue: string;
    variableName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsLabelValueMetricName {
    stringValue: string;
    variableName: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQueryMetricsMetricName {
    metricRegex: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpans {
    fieldName: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldName;
    fieldValue: outputs.GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldValue;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldName {
    spanRegex: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryQuerySpansFieldValue {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceQueryValueDisplayOptions {
    labelRegex: string;
    valueRegex: string;
}

export interface GetDashboardVariableDefinitionMultiSelectSourceSpanField {
    /**
     * The type of the field. Can be one of ["metadata" "tag" "process_tag"]
     */
    type: string;
    /**
     * The value of the field. When the field type is `metadata`, can be one of ["unspecified" "application_name" "subsystem_name" "service_name" "operation_name"]
     */
    value: string;
}

export interface GetDataSetUploadedFile {
    modificationTimeUploaded: string;
    path: string;
    updatedFromUploading: boolean;
}

export interface GetEnrichmentAw {
    fields: outputs.GetEnrichmentAwField[];
}

export interface GetEnrichmentAwField {
    id: number;
    name: string;
    resource: string;
}

export interface GetEnrichmentCustom {
    customEnrichmentId: number;
    fields: outputs.GetEnrichmentCustomField[];
}

export interface GetEnrichmentCustomField {
    id: number;
    name: string;
}

export interface GetEnrichmentGeoIp {
    fields: outputs.GetEnrichmentGeoIpField[];
}

export interface GetEnrichmentGeoIpField {
    id: number;
    name: string;
}

export interface GetEnrichmentSuspiciousIp {
    fields: outputs.GetEnrichmentSuspiciousIpField[];
}

export interface GetEnrichmentSuspiciousIpField {
    id: number;
    name: string;
}

export interface GetEvents2metricLogsQuery {
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    lucene: string;
    /**
     * An array of severities that we interested in. Can be one of ["Error" "Critical" "Unspecified" "Debug" "Verbose" "Info" "Warning"]
     */
    severities: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on.  Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems: string[];
}

export interface GetEvents2metricMetricFields {
    aggregations: outputs.GetEvents2metricMetricFieldsAggregations;
    sourceField: string;
}

export interface GetEvents2metricMetricFieldsAggregations {
    avg: outputs.GetEvents2metricMetricFieldsAggregationsAvg;
    count: outputs.GetEvents2metricMetricFieldsAggregationsCount;
    histogram: outputs.GetEvents2metricMetricFieldsAggregationsHistogram;
    max: outputs.GetEvents2metricMetricFieldsAggregationsMax;
    min: outputs.GetEvents2metricMetricFieldsAggregationsMin;
    samples: outputs.GetEvents2metricMetricFieldsAggregationsSamples;
    sum: outputs.GetEvents2metricMetricFieldsAggregationsSum;
}

export interface GetEvents2metricMetricFieldsAggregationsAvg {
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricMetricFieldsAggregationsCount {
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricMetricFieldsAggregationsHistogram {
    buckets: number[];
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricMetricFieldsAggregationsMax {
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricMetricFieldsAggregationsMin {
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricMetricFieldsAggregationsSamples {
    enable: boolean;
    targetMetricName: string;
    /**
     * Can be one of ["Min" "Max"].
     */
    type: string;
}

export interface GetEvents2metricMetricFieldsAggregationsSum {
    enable: boolean;
    targetMetricName: string;
}

export interface GetEvents2metricPermutations {
    /**
     * Notify if the limit permutations' limit of the events2metric has exceed (computed).
     */
    hasExceedLimit: boolean;
    /**
     * Defines the permutations' limit of the events2metric.
     */
    limit: number;
}

export interface GetEvents2metricSpansQuery {
    /**
     * An array that contains log’s actions names that we want to be notified on.  Actions can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    actions: string[];
    /**
     * An array that contains log’s application names that we want to be alerted on. Applications can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    applications: string[];
    /**
     * The search_query that we wanted to be notified on.
     */
    lucene: string;
    /**
     * An array that contains log’s services names that we want to be notified on.  Services can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    services: string[];
    /**
     * An array that contains log’s subsystem names that we want to be notified on.  Subsystems can be filtered by prefix, suffix, and contains using the next patterns - filter:startsWith:xxx, filter:endsWith:xxx, filter:contains:xxx
     */
    subsystems: string[];
}

export interface GetHostedDashboardGrafana {
    configJson: string;
    dashboardId: number;
    folder: number;
    isStarred: boolean;
    title: string;
    uid: string;
    url: string;
    version: number;
}

export interface GetRecordingRulesGroupsSetGroup {
    /**
     * How often rules in the group are evaluated (in seconds).
     */
    interval: number;
    /**
     * Limit the number of alerts an alerting rule and series a recording-rule can produce. 0 is no limit.
     */
    limit: number;
    /**
     * The rule-group name. Have to be unique.
     */
    name: string;
    rules: outputs.GetRecordingRulesGroupsSetGroupRule[];
}

export interface GetRecordingRulesGroupsSetGroupRule {
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by 'record'.
     */
    expr: string;
    /**
     * Labels to add or overwrite before storing the result.
     */
    labels: {[key: string]: string};
    /**
     * The name of the time series to output to. Must be a valid metric name.
     */
    record: string;
}

export interface GetRulesGroupRuleSubgroup {
    active: boolean;
    id: string;
    order: number;
    rules: outputs.GetRulesGroupRuleSubgroupRule[];
}

export interface GetRulesGroupRuleSubgroupRule {
    blocks: outputs.GetRulesGroupRuleSubgroupRuleBlock[];
    extractTimestamps: outputs.GetRulesGroupRuleSubgroupRuleExtractTimestamp[];
    extracts: outputs.GetRulesGroupRuleSubgroupRuleExtract[];
    jsonExtracts: outputs.GetRulesGroupRuleSubgroupRuleJsonExtract[];
    jsonStringifies: outputs.GetRulesGroupRuleSubgroupRuleJsonStringify[];
    parseJsonFields: outputs.GetRulesGroupRuleSubgroupRuleParseJsonField[];
    parses: outputs.GetRulesGroupRuleSubgroupRuleParse[];
    removeFields: outputs.GetRulesGroupRuleSubgroupRuleRemoveField[];
    replaces: outputs.GetRulesGroupRuleSubgroupRuleReplace[];
}

export interface GetRulesGroupRuleSubgroupRuleBlock {
    active: boolean;
    blockingAllMatchingBlocks: boolean;
    description: string;
    id: string;
    keepBlockedLogs: boolean;
    name: string;
    order: number;
    regularExpression: string;
    sourceField: string;
}

export interface GetRulesGroupRuleSubgroupRuleExtract {
    active: boolean;
    description: string;
    id: string;
    name: string;
    order: number;
    regularExpression: string;
    sourceField: string;
}

export interface GetRulesGroupRuleSubgroupRuleExtractTimestamp {
    active: boolean;
    description: string;
    fieldFormatStandard: string;
    id: string;
    name: string;
    order: number;
    sourceField: string;
    timeFormat: string;
}

export interface GetRulesGroupRuleSubgroupRuleJsonExtract {
    active: boolean;
    description: string;
    destinationField: string;
    id: string;
    jsonKey: string;
    name: string;
    order: number;
}

export interface GetRulesGroupRuleSubgroupRuleJsonStringify {
    active: boolean;
    description: string;
    destinationField: string;
    id: string;
    keepSourceField: boolean;
    name: string;
    order: number;
    sourceField: string;
}

export interface GetRulesGroupRuleSubgroupRuleParse {
    active: boolean;
    description: string;
    destinationField: string;
    id: string;
    name: string;
    order: number;
    regularExpression: string;
    sourceField: string;
}

export interface GetRulesGroupRuleSubgroupRuleParseJsonField {
    active: boolean;
    description: string;
    destinationField: string;
    id: string;
    keepDestinationField: boolean;
    keepSourceField: boolean;
    name: string;
    order: number;
    sourceField: string;
}

export interface GetRulesGroupRuleSubgroupRuleRemoveField {
    active: boolean;
    description: string;
    excludedFields: string[];
    id: string;
    name: string;
    order: number;
}

export interface GetRulesGroupRuleSubgroupRuleReplace {
    active: boolean;
    description: string;
    destinationField: string;
    id: string;
    name: string;
    order: number;
    regularExpression: string;
    replacementString: string;
    sourceField: string;
}

export interface GetScopeFilter {
    /**
     * Entity type to apply the expression on
     */
    entityType: string;
    /**
     * Expression to run
     */
    expression: string;
}

export interface GetSloFilter {
    /**
     * Compare type. This is the compare type of the SLO. Valid values are: ["starts_with" "ends_with" "includes" "unspecified" "is"]
     */
    compareType: string;
    field: string;
    fieldValues: string[];
}

export interface GetTcoPoliciesLogsPolicy {
    /**
     * The applications to apply the policy on. Applies the policy on all the applications by default.
     */
    applications: outputs.GetTcoPoliciesLogsPolicyApplications;
    /**
     * Allowing logs with a specific retention to be tagged.
     */
    archiveRetentionId: string;
    /**
     * The policy description
     */
    description: string;
    /**
     * Determines weather the policy will be enabled. True by default.
     */
    enabled: boolean;
    /**
     * tco-policy ID.
     */
    id: string;
    /**
     * tco-policy name.
     */
    name: string;
    /**
     * The policy's order between the other policies.
     */
    order: number;
    /**
     * The policy priority. Can be one of ["block" "high" "low" "medium"].
     */
    priority: string;
    /**
     * The severities to apply the policy on. Can be few of ["debug" "verbose" "info" "warning" "error" "critical"].
     */
    severities: string[];
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    subsystems: outputs.GetTcoPoliciesLogsPolicySubsystems;
}

export interface GetTcoPoliciesLogsPolicyApplications {
    names: string[];
    /**
     * The rule type. Can be one of ["includes" "is" "is_not" "starts_with"].
     */
    ruleType: string;
}

export interface GetTcoPoliciesLogsPolicySubsystems {
    names: string[];
    ruleType: string;
}

export interface GetTcoPoliciesTracesPolicy {
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    actions: outputs.GetTcoPoliciesTracesPolicyActions;
    /**
     * The applications to apply the policy on. Applies the policy on all the applications by default.
     */
    applications: outputs.GetTcoPoliciesTracesPolicyApplications;
    /**
     * Allowing logs with a specific retention to be tagged.
     */
    archiveRetentionId: string;
    /**
     * The policy description
     */
    description: string;
    /**
     * Determines weather the policy will be enabled. True by default.
     */
    enabled: boolean;
    /**
     * tco-policy ID.
     */
    id: string;
    /**
     * tco-policy name.
     */
    name: string;
    /**
     * The policy's order between the other policies.
     */
    order: number;
    /**
     * The policy priority. Can be one of ["block" "high" "low" "medium"].
     */
    priority: string;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    services: outputs.GetTcoPoliciesTracesPolicyServices;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    subsystems: outputs.GetTcoPoliciesTracesPolicySubsystems;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    tags: {[key: string]: outputs.GetTcoPoliciesTracesPolicyTags};
}

export interface GetTcoPoliciesTracesPolicyActions {
    names: string[];
    ruleType: string;
}

export interface GetTcoPoliciesTracesPolicyApplications {
    names: string[];
    ruleType: string;
}

export interface GetTcoPoliciesTracesPolicyServices {
    names: string[];
    ruleType: string;
}

export interface GetTcoPoliciesTracesPolicySubsystems {
    names: string[];
    ruleType: string;
}

export interface GetTcoPoliciesTracesPolicyTags {
    names: string[];
    ruleType: string;
}

export interface GetUserEmail {
    primary: boolean;
    type: string;
    value: string;
}

export interface GetUserName {
    familyName: string;
    givenName: string;
}

export interface GetWebhookCustom {
    /**
     * Webhook headers. Map of string to string.
     */
    headers: {[key: string]: string};
    /**
     * Webhook method. can be one of: get, post, put
     */
    method: string;
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Webhook URL.
     */
    url: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface GetWebhookDemisto {
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Microsoft Teams URL.
     */
    url: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface GetWebhookEmailGroup {
    /**
     * Emails list.
     */
    emails: string[];
}

export interface GetWebhookEventBridge {
    detail: string;
    /**
     * Free text to be included in the event.
     */
    detailType: string;
    /**
     * Corresponds to the event bus, which will receive notifications. The policy attached must contain permission to publish.
     */
    eventBusArn: string;
    /**
     * Corresponds to the AWS IAM role that will be created in your account.
     */
    roleName: string;
    /**
     * Free text is used to identify the messages Coralogix sends.
     */
    source: string;
}

export interface GetWebhookJira {
    /**
     * Jira API token.
     */
    apiToken: string;
    /**
     * email.
     */
    email: string;
    /**
     * Jira project key.
     */
    projectKey: string;
    /**
     * Jira URL.
     */
    url: string;
}

export interface GetWebhookMicrosoftTeams {
    /**
     * Microsoft Teams URL.
     */
    url: string;
}

export interface GetWebhookMicrosoftTeamsWorkflow {
    /**
     * Microsoft Teams Workflow URL.
     */
    url: string;
}

export interface GetWebhookOpsgenie {
    /**
     * Opsgenie URL.
     */
    url: string;
}

export interface GetWebhookPagerDuty {
    /**
     * PagerDuty service key.
     */
    serviceKey: string;
}

export interface GetWebhookSendlog {
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Webhook URL.
     */
    url: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface GetWebhookSlack {
    /**
     * Slack attachments.
     */
    attachments: outputs.GetWebhookSlackAttachment[];
    /**
     * Slack notifications. can be one of: spike_anomalies, data_usage, error_and_critical_logs, flow_anomalies
     */
    notifyOns: string[];
    /**
     * Slack URL.
     */
    url: string;
}

export interface GetWebhookSlackAttachment {
    /**
     * Determines if the attachment is active. Default is true.
     */
    active: boolean;
    /**
     * Slack attachment type. can be one of: empty, metric_snapshot, logs
     */
    type: string;
}

export interface HostedDashboardGrafana {
    /**
     * The complete dashboard model JSON.
     */
    configJson: string;
    /**
     * The numeric ID of the dashboard computed by Grafana.
     */
    dashboardId: number;
    /**
     * The id or UID of the folder to save the dashboard in.
     */
    folder?: string;
    /**
     * Set a commit message for the version history.
     */
    message?: string;
    /**
     * Set to true if you want to overwrite existing dashboard with newer version, same dashboard title in folder or same dashboard uid.
     */
    overwrite?: boolean;
    /**
     * The unique identifier of a dashboard. This is used to construct its URL. It's automatically generated if not provided when creating a dashboard. The uid allows having consistent URLs for accessing dashboards and when syncing dashboards between multiple Grafana installs.
     */
    uid: string;
    /**
     * The full URL of the dashboard.
     */
    url: string;
    /**
     * Whenever you save a version of your dashboard, a copy of that version is saved so that previous versions of your dashboard are not lost.
     */
    version: number;
}

export interface HostedDashboardTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface RecordingRulesGroupsSetGroup {
    /**
     * How often rules in the group are evaluated (in seconds).
     */
    interval: number;
    /**
     * Limit the number of alerts an alerting rule and series a recording-rule can produce. 0 is no limit.
     */
    limit: number;
    /**
     * The rule-group name. Have to be unique.
     */
    name: string;
    rules: outputs.RecordingRulesGroupsSetGroupRule[];
}

export interface RecordingRulesGroupsSetGroupRule {
    /**
     * The PromQL expression to evaluate. Every evaluation cycle this is evaluated at the current time, and the result recorded as a new set of time series with the metric name as given by 'record'.
     */
    expr: string;
    /**
     * Labels to add or overwrite before storing the result.
     */
    labels?: {[key: string]: string};
    /**
     * The name of the time series to output to. Must be a valid metric name.
     */
    record: string;
}

export interface RulesGroupRuleSubgroup {
    /**
     * Determines whether the rule-subgroup will be active.
     */
    active?: boolean;
    /**
     * The ID of thr rule-subgroup. Will be computed by Coralogix endpoint.
     */
    id: string;
    /**
     * Determines the index of the rule-subgroup inside the rule-group.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    rules: outputs.RulesGroupRuleSubgroupRule[];
}

export interface RulesGroupRuleSubgroupRule {
    /**
     * Block rules allow for refined filtering of incoming logs with a RegEx.
     */
    block?: outputs.RulesGroupRuleSubgroupRuleBlock;
    /**
     * Use a named RegEx group to extract specific values you need as JSON getKeysStrings without having to parse the entire log.
     */
    extract?: outputs.RulesGroupRuleSubgroupRuleExtract;
    /**
     * Replace rules are used to replace logs timestamp with JSON field.
     */
    extractTimestamp?: outputs.RulesGroupRuleSubgroupRuleExtractTimestamp;
    /**
     * Name a JSON field to extract its value directly into a Coralogix metadata field
     */
    jsonExtract?: outputs.RulesGroupRuleSubgroupRuleJsonExtract;
    /**
     * Convert JSON object to JSON string.
     */
    jsonStringify?: outputs.RulesGroupRuleSubgroupRuleJsonStringify;
    /**
     * Parse unstructured logs into JSON format using named Regex groups.
     */
    parse?: outputs.RulesGroupRuleSubgroupRuleParse;
    /**
     * Convert JSON string to JSON object.
     */
    parseJsonField?: outputs.RulesGroupRuleSubgroupRuleParseJsonField;
    /**
     * Remove Fields allows to select fields that will not be indexed.
     */
    removeFields?: outputs.RulesGroupRuleSubgroupRuleRemoveFields;
    /**
     * Replace rules are used to strings in order to fix log structure, change log severity, or obscure information.
     */
    replace?: outputs.RulesGroupRuleSubgroupRuleReplace;
}

export interface RulesGroupRuleSubgroupRuleBlock {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * Block Logic. If true or nor set - blocking all matching blocks, if false - blocking all non-matching blocks.
     */
    blockingAllMatchingBlocks?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * Determines if to view blocked logs in LiveTail and archive to S3.
     */
    keepBlockedLogs?: boolean;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    regularExpression: string;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupRuleSubgroupRuleExtract {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    regularExpression: string;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupRuleSubgroupRuleExtractTimestamp {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The format standard you want to use. Can be one of ["Golang" "SecondTS" "MilliTS" "MicroTS" "NanoTS" "Strftime" "JavaSDF"]
     */
    fieldFormatStandard: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
    /**
     * A time format that matches the field format standard
     */
    timeFormat: string;
}

export interface RulesGroupRuleSubgroupRuleJsonExtract {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The field that will be populated by the results of RegEx operation.Can be one of [Category Class Method ThreadID Severity].
     */
    destinationField: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * JSON key to extract its value directly into a Coralogix metadata field.
     */
    jsonKey: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
}

export interface RulesGroupRuleSubgroupRuleJsonStringify {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The field that will be populated by the results of the RegEx operation.
     */
    destinationField: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * Determines whether to keep or to delete the source field.
     */
    keepSourceField?: boolean;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupRuleSubgroupRuleParse {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The field that will be populated by the results of the RegEx operation.
     */
    destinationField: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    regularExpression: string;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupRuleSubgroupRuleParseJsonField {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The field that will be populated by the results of the RegEx operation.
     */
    destinationField: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * Determines whether to keep or to delete the destination field.
     */
    keepDestinationField?: boolean;
    /**
     * Determines whether to keep or to delete the source field.
     */
    keepSourceField?: boolean;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupRuleSubgroupRuleRemoveFields {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * Excluded fields won't be indexed.
     */
    excludedFields: string[];
    /**
     * The rule id.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
}

export interface RulesGroupRuleSubgroupRuleReplace {
    /**
     * Determines whether to rule will be active or not.
     */
    active?: boolean;
    /**
     * The rule description.
     */
    description?: string;
    /**
     * The field that will be populated by the results of the RegEx operation.
     */
    destinationField: string;
    /**
     * The rule id.
     */
    id: string;
    /**
     * The rule name.
     */
    name: string;
    /**
     * Determines the index of the rule inside the rule-subgroup.When not set, will be computed by the order it was declared. (1 based indexing).
     */
    order: number;
    /**
     * Regular expiration. More info: https://coralogix.com/blog/regex-101/
     */
    regularExpression: string;
    /**
     * The string that will replace the matched RegEx
     */
    replacementString?: string;
    /**
     * The field on which the Regex will operate on. Accepts lowercase only.
     */
    sourceField: string;
}

export interface RulesGroupTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ScopeFilter {
    /**
     * Entity type to apply the expression on
     */
    entityType: string;
    /**
     * Expression to run
     */
    expression: string;
}

export interface SloFilter {
    /**
     * Compare type. This is the compare type of the SLO. Valid values are: ["starts_with" "ends_with" "includes" "unspecified" "is"]
     */
    compareType: string;
    field: string;
    fieldValues?: string[];
}

export interface TcoPoliciesLogsPolicy {
    /**
     * The applications to apply the policy on. Applies the policy on all the applications by default.
     */
    applications?: outputs.TcoPoliciesLogsPolicyApplications;
    /**
     * Allowing logs with a specific retention to be tagged.
     */
    archiveRetentionId?: string;
    /**
     * The policy description
     */
    description: string;
    /**
     * Determines weather the policy will be enabled. True by default.
     */
    enabled: boolean;
    /**
     * tco-policy ID.
     */
    id: string;
    /**
     * tco-policy name.
     */
    name: string;
    /**
     * The policy's order between the other policies.
     */
    order: number;
    /**
     * The policy priority. Can be one of ["block" "high" "low" "medium"].
     */
    priority: string;
    /**
     * The severities to apply the policy on. Can be few of ["debug" "verbose" "info" "warning" "error" "critical"].
     */
    severities?: string[];
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    subsystems?: outputs.TcoPoliciesLogsPolicySubsystems;
}

export interface TcoPoliciesLogsPolicyApplications {
    names: string[];
    /**
     * The rule type. Can be one of ["includes" "is" "is_not" "starts_with"].
     */
    ruleType: string;
}

export interface TcoPoliciesLogsPolicySubsystems {
    names: string[];
    ruleType: string;
}

export interface TcoPoliciesTracesPolicy {
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    actions?: outputs.TcoPoliciesTracesPolicyActions;
    /**
     * The applications to apply the policy on. Applies the policy on all the applications by default.
     */
    applications?: outputs.TcoPoliciesTracesPolicyApplications;
    /**
     * Allowing logs with a specific retention to be tagged.
     */
    archiveRetentionId?: string;
    /**
     * The policy description
     */
    description: string;
    /**
     * Determines weather the policy will be enabled. True by default.
     */
    enabled: boolean;
    /**
     * tco-policy ID.
     */
    id: string;
    /**
     * tco-policy name.
     */
    name: string;
    /**
     * The policy's order between the other policies.
     */
    order: number;
    /**
     * The policy priority. Can be one of ["block" "high" "low" "medium"].
     */
    priority: string;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    services?: outputs.TcoPoliciesTracesPolicyServices;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    subsystems?: outputs.TcoPoliciesTracesPolicySubsystems;
    /**
     * The subsystems to apply the policy on. Applies the policy on all the subsystems by default.
     */
    tags?: {[key: string]: outputs.TcoPoliciesTracesPolicyTags};
}

export interface TcoPoliciesTracesPolicyActions {
    names: string[];
    ruleType: string;
}

export interface TcoPoliciesTracesPolicyApplications {
    names: string[];
    ruleType: string;
}

export interface TcoPoliciesTracesPolicyServices {
    names: string[];
    ruleType: string;
}

export interface TcoPoliciesTracesPolicySubsystems {
    names: string[];
    ruleType: string;
}

export interface TcoPoliciesTracesPolicyTags {
    names: string[];
    ruleType: string;
}

export interface UserEmail {
    primary: boolean;
    type: string;
    value: string;
}

export interface UserName {
    familyName?: string;
    givenName?: string;
}

export interface WebhookCustom {
    /**
     * Webhook headers. Map of string to string.
     */
    headers?: {[key: string]: string};
    /**
     * Webhook method. can be one of: get, post, put
     */
    method?: string;
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Webhook URL.
     */
    url?: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface WebhookDemisto {
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Microsoft Teams URL.
     */
    url: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface WebhookEmailGroup {
    /**
     * Emails list.
     */
    emails?: string[];
}

export interface WebhookEventBridge {
    detail?: string;
    /**
     * Free text to be included in the event.
     */
    detailType: string;
    /**
     * Corresponds to the event bus, which will receive notifications. The policy attached must contain permission to publish.
     */
    eventBusArn: string;
    /**
     * Corresponds to the AWS IAM role that will be created in your account.
     */
    roleName: string;
    /**
     * Free text is used to identify the messages Coralogix sends.
     */
    source: string;
}

export interface WebhookJira {
    /**
     * Jira API token.
     */
    apiToken?: string;
    /**
     * email.
     */
    email?: string;
    /**
     * Jira project key.
     */
    projectKey?: string;
    /**
     * Jira URL.
     */
    url: string;
}

export interface WebhookMicrosoftTeams {
    /**
     * Microsoft Teams URL.
     */
    url?: string;
}

export interface WebhookMicrosoftTeamsWorkflow {
    /**
     * Microsoft Teams Workflow URL.
     */
    url?: string;
}

export interface WebhookOpsgenie {
    /**
     * Opsgenie URL.
     */
    url: string;
}

export interface WebhookPagerDuty {
    /**
     * PagerDuty service key.
     */
    serviceKey?: string;
}

export interface WebhookSendlog {
    /**
     * Webhook payload. JSON string.
     */
    payload: string;
    /**
     * Webhook URL.
     */
    url: string;
    /**
     * Webhook UUID. Computed automatically.
     */
    uuid: string;
}

export interface WebhookSlack {
    /**
     * Slack attachments.
     */
    attachments?: outputs.WebhookSlackAttachment[];
    /**
     * Slack notifications. can be one of: spike_anomalies, data_usage, error_and_critical_logs, flow_anomalies
     */
    notifyOns?: string[];
    /**
     * Slack URL.
     */
    url?: string;
}

export interface WebhookSlackAttachment {
    /**
     * Determines if the attachment is active. Default is true.
     */
    active: boolean;
    /**
     * Slack attachment type. can be one of: empty, metric_snapshot, logs
     */
    type: string;
}

