// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CredentialAwsSecurity {
    associations?: outputs.CredentialAwsSecurityAssociation[];
    /**
     * Owner of a credential can be a user or user group
     */
    owners?: outputs.CredentialAwsSecurityOwner[];
}

export interface CredentialAwsSecurityAssociation {
    /**
     * To check if the user/user group associated is the owner.
     */
    iscreatorassociation: string;
    /**
     * List of permissions associated with the entity. Either categoryId and categoryName or permissionId and permissionName will be returned. If categoryId or categoryName is returned, all the corresponding permissions in the category are associated with the entity.
     */
    permissions?: outputs.CredentialAwsSecurityAssociationPermission[];
    usergroups?: outputs.CredentialAwsSecurityAssociationUsergroup[];
    users?: outputs.CredentialAwsSecurityAssociationUser[];
}

export interface CredentialAwsSecurityAssociationPermission {
    categoryid: number;
    categoryname: string;
    /**
     * Flag to specify if this is included permission or excluded permission.
     */
    exclude: string;
    permissionid: number;
    permissionname: string;
    /**
     * Returns the type of association. [ALL_CATEGORIES, CATEGORY_ENTITY, PERMISSION_ENTITY]
     */
    type: string;
}

export interface CredentialAwsSecurityAssociationUser {
    id: number;
}

export interface CredentialAwsSecurityAssociationUsergroup {
    id: number;
}

export interface CredentialAwsSecurityOwner {
    usergroups?: outputs.CredentialAwsSecurityOwnerUsergroup[];
    users?: outputs.CredentialAwsSecurityOwnerUser[];
}

export interface CredentialAwsSecurityOwnerUser {
    id: number;
    name: string;
}

export interface CredentialAwsSecurityOwnerUsergroup {
    id: number;
    name: string;
}

export interface CredentialAwswithrolearnSecurity {
    associations?: outputs.CredentialAwswithrolearnSecurityAssociation[];
    /**
     * Owner of a credential can be a user or user group
     */
    owners?: outputs.CredentialAwswithrolearnSecurityOwner[];
}

export interface CredentialAwswithrolearnSecurityAssociation {
    /**
     * To check if the user/user group associated is the owner.
     */
    iscreatorassociation: string;
    /**
     * List of permissions associated with the entity. Either categoryId and categoryName or permissionId and permissionName will be returned. If categoryId or categoryName is returned, all the corresponding permissions in the category are associated with the entity.
     */
    permissions?: outputs.CredentialAwswithrolearnSecurityAssociationPermission[];
    usergroups?: outputs.CredentialAwswithrolearnSecurityAssociationUsergroup[];
    users?: outputs.CredentialAwswithrolearnSecurityAssociationUser[];
}

export interface CredentialAwswithrolearnSecurityAssociationPermission {
    categoryid: number;
    categoryname: string;
    /**
     * Flag to specify if this is included permission or excluded permission.
     */
    exclude: string;
    permissionid: number;
    permissionname: string;
    /**
     * Returns the type of association. [ALL_CATEGORIES, CATEGORY_ENTITY, PERMISSION_ENTITY]
     */
    type: string;
}

export interface CredentialAwswithrolearnSecurityAssociationUser {
    id: number;
}

export interface CredentialAwswithrolearnSecurityAssociationUsergroup {
    id: number;
}

export interface CredentialAwswithrolearnSecurityOwner {
    usergroups?: outputs.CredentialAwswithrolearnSecurityOwnerUsergroup[];
    users?: outputs.CredentialAwswithrolearnSecurityOwnerUser[];
}

export interface CredentialAwswithrolearnSecurityOwnerUser {
    id: number;
    name: string;
}

export interface CredentialAwswithrolearnSecurityOwnerUsergroup {
    id: number;
    name: string;
}

export interface CredentialAzureSecurity {
    associations?: outputs.CredentialAzureSecurityAssociation[];
    /**
     * Owner of a credential can be a user or user group
     */
    owners?: outputs.CredentialAzureSecurityOwner[];
}

export interface CredentialAzureSecurityAssociation {
    /**
     * To check if the user/user group associated is the owner.
     */
    iscreatorassociation: string;
    /**
     * List of permissions associated with the entity. Either categoryId and categoryName or permissionId and permissionName will be returned. If categoryId or categoryName is returned, all the corresponding permissions in the category are associated with the entity.
     */
    permissions?: outputs.CredentialAzureSecurityAssociationPermission[];
    usergroups?: outputs.CredentialAzureSecurityAssociationUsergroup[];
    users?: outputs.CredentialAzureSecurityAssociationUser[];
}

export interface CredentialAzureSecurityAssociationPermission {
    categoryid: number;
    categoryname: string;
    /**
     * Flag to specify if this is included permission or excluded permission.
     */
    exclude: string;
    permissionid: number;
    permissionname: string;
    /**
     * Returns the type of association. [ALL_CATEGORIES, CATEGORY_ENTITY, PERMISSION_ENTITY]
     */
    type: string;
}

export interface CredentialAzureSecurityAssociationUser {
    id: number;
}

export interface CredentialAzureSecurityAssociationUsergroup {
    id: number;
}

export interface CredentialAzureSecurityOwner {
    usergroups?: outputs.CredentialAzureSecurityOwnerUsergroup[];
    users?: outputs.CredentialAzureSecurityOwnerUser[];
}

export interface CredentialAzureSecurityOwnerUser {
    id: number;
    name: string;
}

export interface CredentialAzureSecurityOwnerUsergroup {
    id: number;
    name: string;
}

export interface CredentialAzurewithtenantidEndpoint {
    activedirectory: string;
    resourcemanager: string;
    storage: string;
}

export interface CredentialAzurewithtenantidSecurity {
    associations?: outputs.CredentialAzurewithtenantidSecurityAssociation[];
    /**
     * Owner of a credential can be a user or user group
     */
    owners?: outputs.CredentialAzurewithtenantidSecurityOwner[];
}

export interface CredentialAzurewithtenantidSecurityAssociation {
    /**
     * To check if the user/user group associated is the owner.
     */
    iscreatorassociation: string;
    /**
     * List of permissions associated with the entity. Either categoryId and categoryName or permissionId and permissionName will be returned. If categoryId or categoryName is returned, all the corresponding permissions in the category are associated with the entity.
     */
    permissions?: outputs.CredentialAzurewithtenantidSecurityAssociationPermission[];
    usergroups?: outputs.CredentialAzurewithtenantidSecurityAssociationUsergroup[];
    users?: outputs.CredentialAzurewithtenantidSecurityAssociationUser[];
}

export interface CredentialAzurewithtenantidSecurityAssociationPermission {
    categoryid: number;
    categoryname: string;
    /**
     * Flag to specify if this is included permission or excluded permission.
     */
    exclude: string;
    permissionid: number;
    permissionname: string;
    /**
     * Returns the type of association. [ALL_CATEGORIES, CATEGORY_ENTITY, PERMISSION_ENTITY]
     */
    type: string;
}

export interface CredentialAzurewithtenantidSecurityAssociationUser {
    id: number;
}

export interface CredentialAzurewithtenantidSecurityAssociationUsergroup {
    id: number;
}

export interface CredentialAzurewithtenantidSecurityOwner {
    usergroups?: outputs.CredentialAzurewithtenantidSecurityOwnerUsergroup[];
    users?: outputs.CredentialAzurewithtenantidSecurityOwnerUser[];
}

export interface CredentialAzurewithtenantidSecurityOwnerUser {
    id: number;
    name: string;
}

export interface CredentialAzurewithtenantidSecurityOwnerUsergroup {
    id: number;
    name: string;
}

export interface DiskAccesspathMediaagent {
    id?: number;
}

export interface HypervisorAwsAccessnode {
    id?: number;
    /**
     * Type of access node , Ex: 3 - access Node , 28 - Access Node Groups
     */
    type?: number;
}

export interface HypervisorAwsActivitycontrol {
    backupactivitycontroloptions?: outputs.HypervisorAwsActivitycontrolBackupactivitycontroloption[];
    /**
     * true if Backup is enabled
     */
    enablebackup: string;
    /**
     * true if Restore is enabled
     */
    enablerestore: string;
    restoreactivitycontroloptions?: outputs.HypervisorAwsActivitycontrolRestoreactivitycontroloption[];
}

export interface HypervisorAwsActivitycontrolBackupactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.HypervisorAwsActivitycontrolBackupactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface HypervisorAwsActivitycontrolBackupactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.HypervisorAwsActivitycontrolBackupactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface HypervisorAwsActivitycontrolBackupactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface HypervisorAwsActivitycontrolRestoreactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.HypervisorAwsActivitycontrolRestoreactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface HypervisorAwsActivitycontrolRestoreactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.HypervisorAwsActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface HypervisorAwsActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface HypervisorAwsCredential {
    id: number;
    name: string;
}

export interface HypervisorAwsEtcdprotection {
    /**
     * Denote if etcd protection is enabled
     */
    enabled: string;
    plans?: outputs.HypervisorAwsEtcdprotectionPlan[];
}

export interface HypervisorAwsEtcdprotectionPlan {
    id: number;
    name: string;
}

export interface HypervisorAwsFbrunixmediaagent {
    id: number;
    name: string;
}

export interface HypervisorAwsSecurity {
    associatedusergroups?: outputs.HypervisorAwsSecurityAssociatedusergroup[];
    /**
     * Client owners for the Hypervisor
     */
    clientowners: string;
}

export interface HypervisorAwsSecurityAssociatedusergroup {
    id: number;
}

export interface HypervisorAwsSetting {
    applicationcredentials?: outputs.HypervisorAwsSettingApplicationcredential[];
    customattributes?: outputs.HypervisorAwsSettingCustomattribute[];
    guestcredentials?: outputs.HypervisorAwsSettingGuestcredential[];
    metricsmonitoringpolicies?: outputs.HypervisorAwsSettingMetricsmonitoringpolicy[];
    mountaccessnodes?: outputs.HypervisorAwsSettingMountaccessnode[];
    regioninfos?: outputs.HypervisorAwsSettingRegioninfo[];
    timezones?: outputs.HypervisorAwsSettingTimezone[];
}

export interface HypervisorAwsSettingApplicationcredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface HypervisorAwsSettingCustomattribute {
    /**
     * client custom attribute type . Ex- 3 - For client 8- For clientGroup
     */
    type: number;
    /**
     * client/Client Group custom attribute value
     */
    value: string;
}

export interface HypervisorAwsSettingGuestcredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface HypervisorAwsSettingMetricsmonitoringpolicy {
    /**
     * Metrics Moitoring PolicyId
     */
    id: number;
    /**
     * True if Metrics Monioring policy is enabled
     */
    isenabled: string;
    /**
     * Metrics Moitoring Policy Name
     */
    name: string;
}

export interface HypervisorAwsSettingMountaccessnode {
    id: number;
    name: string;
}

export interface HypervisorAwsSettingRegioninfo {
    /**
     * Display Name of Region
     */
    displayname: string;
    /**
     * Region Id
     */
    id: number;
    /**
     * Geolocation Latitude
     */
    latitude: string;
    /**
     * Geolocation Longitude
     */
    longitude: string;
    /**
     * Region Name
     */
    name: string;
}

export interface HypervisorAwsSettingTimezone {
    id: number;
    name: string;
}

export interface HypervisorAzureAccessnode {
    id?: number;
    /**
     * Type of access node , Ex: 3 - access Node , 28 - Access Node Groups
     */
    type?: number;
}

export interface HypervisorAzureActivitycontrol {
    backupactivitycontroloptions?: outputs.HypervisorAzureActivitycontrolBackupactivitycontroloption[];
    /**
     * true if Backup is enabled
     */
    enablebackup: string;
    /**
     * true if Restore is enabled
     */
    enablerestore: string;
    restoreactivitycontroloptions?: outputs.HypervisorAzureActivitycontrolRestoreactivitycontroloption[];
}

export interface HypervisorAzureActivitycontrolBackupactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.HypervisorAzureActivitycontrolBackupactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface HypervisorAzureActivitycontrolBackupactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.HypervisorAzureActivitycontrolBackupactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface HypervisorAzureActivitycontrolBackupactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface HypervisorAzureActivitycontrolRestoreactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.HypervisorAzureActivitycontrolRestoreactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface HypervisorAzureActivitycontrolRestoreactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.HypervisorAzureActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface HypervisorAzureActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface HypervisorAzureCredential {
    id: number;
    name: string;
}

export interface HypervisorAzureEtcdprotection {
    /**
     * Denote if etcd protection is enabled
     */
    enabled: string;
    plans?: outputs.HypervisorAzureEtcdprotectionPlan[];
}

export interface HypervisorAzureEtcdprotectionPlan {
    id: number;
    name: string;
}

export interface HypervisorAzureFbrunixmediaagent {
    id: number;
    name: string;
}

export interface HypervisorAzureSecurity {
    associatedusergroups?: outputs.HypervisorAzureSecurityAssociatedusergroup[];
    /**
     * Client owners for the Hypervisor
     */
    clientowners: string;
}

export interface HypervisorAzureSecurityAssociatedusergroup {
    id: number;
}

export interface HypervisorAzureSetting {
    applicationcredentials?: outputs.HypervisorAzureSettingApplicationcredential[];
    customattributes?: outputs.HypervisorAzureSettingCustomattribute[];
    guestcredentials?: outputs.HypervisorAzureSettingGuestcredential[];
    metricsmonitoringpolicies?: outputs.HypervisorAzureSettingMetricsmonitoringpolicy[];
    mountaccessnodes?: outputs.HypervisorAzureSettingMountaccessnode[];
    regioninfos?: outputs.HypervisorAzureSettingRegioninfo[];
    timezones?: outputs.HypervisorAzureSettingTimezone[];
}

export interface HypervisorAzureSettingApplicationcredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface HypervisorAzureSettingCustomattribute {
    /**
     * client custom attribute type . Ex- 3 - For client 8- For clientGroup
     */
    type: number;
    /**
     * client/Client Group custom attribute value
     */
    value: string;
}

export interface HypervisorAzureSettingGuestcredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface HypervisorAzureSettingMetricsmonitoringpolicy {
    /**
     * Metrics Moitoring PolicyId
     */
    id: number;
    /**
     * True if Metrics Monioring policy is enabled
     */
    isenabled: string;
    /**
     * Metrics Moitoring Policy Name
     */
    name: string;
}

export interface HypervisorAzureSettingMountaccessnode {
    id: number;
    name: string;
}

export interface HypervisorAzureSettingRegioninfo {
    /**
     * Display Name of Region
     */
    displayname: string;
    /**
     * Region Id
     */
    id: number;
    /**
     * Geolocation Latitude
     */
    latitude: string;
    /**
     * Geolocation Longitude
     */
    longitude: string;
    /**
     * Region Name
     */
    name: string;
}

export interface HypervisorAzureSettingTimezone {
    id: number;
    name: string;
}

export interface HypervisorAzureWorkloadregion {
    id: number;
    name: string;
}

export interface KubernetesAppgroupActivitycontrol {
    enablebackup: string;
}

export interface KubernetesAppgroupCluster {
    id: number;
    name: string;
}

export interface KubernetesAppgroupContent {
    /**
     * List of applications to be added as content
     */
    applications?: outputs.KubernetesAppgroupContentApplication[];
    /**
     * List of label selectors to be added as content
     */
    labelselectors?: outputs.KubernetesAppgroupContentLabelselector[];
}

export interface KubernetesAppgroupContentApplication {
    /**
     * GUID value of the Kubernetes Application to be associated as content
     */
    guid: string;
    /**
     * Name of the application
     */
    name?: string;
    /**
     * Type of the Kubernetes application [NAMESPACE, APPLICATION, PVC, LABELS]
     */
    type: string;
}

export interface KubernetesAppgroupContentLabelselector {
    /**
     * Selector level of the label selector [Application, Volumes, Namespace]
     */
    selectorlevel: string;
    /**
     * Value of the label selector in key=value format
     */
    selectorvalue: string;
}

export interface KubernetesAppgroupFilter {
    /**
     * List of applications to be added as content
     */
    applications?: outputs.KubernetesAppgroupFilterApplication[];
    /**
     * List of label selectors to be added as content
     */
    labelselectors?: outputs.KubernetesAppgroupFilterLabelselector[];
    /**
     * Specify whether to skip backup of stateless applications
     */
    skipstatelessapps: string;
}

export interface KubernetesAppgroupFilterApplication {
    /**
     * GUID value of the Kubernetes Application to be associated as content
     */
    guid: string;
    /**
     * Name of the application
     */
    name?: string;
    /**
     * Type of the Kubernetes application [NAMESPACE, APPLICATION, PVC, LABELS]
     */
    type: string;
}

export interface KubernetesAppgroupFilterLabelselector {
    /**
     * Selector level of the label selector [Application, Volumes, Namespace]
     */
    selectorlevel: string;
    /**
     * Value of the label selector in key=value format
     */
    selectorvalue: string;
}

export interface KubernetesAppgroupOption {
    /**
     * Define number of parallel data readers
     */
    backupstreams: number;
    /**
     * Define setting to enable scheduling worker Pods to CV Namespace for CSI-Snapshot enabled backups
     */
    cvnamespacescheduling: string;
    /**
     * Define the backup job start time in epochs
     */
    jobstarttime: number;
    /**
     * Define setting to enable fallback to live volume backup in case of snap failure
     */
    snapfallbacktolivevolumebackup: string;
    workerresources?: outputs.KubernetesAppgroupOptionWorkerresource[];
}

export interface KubernetesAppgroupOptionWorkerresource {
    /**
     * Define limits.cpu to set on the worker Pod
     */
    cpulimits: string;
    /**
     * Define requests.cpu to set on the worker Pod
     */
    cpurequests: string;
    /**
     * Define limits.memory to set on the worker Pod
     */
    memorylimits: string;
    /**
     * Define requests.memory to set on the worker Pod
     */
    memoryrequests: string;
}

export interface KubernetesAppgroupPlan {
    id: number;
    name: string;
}

export interface KubernetesAppgroupTag {
    name?: string;
    value?: string;
}

export interface KubernetesAppgroupTimezone {
    id: number;
    name: string;
}

export interface KubernetesClusterAccessnode {
    id?: number;
    type?: string;
}

export interface KubernetesClusterActivitycontrol {
    /**
     * Enable or disable backup for cluster
     */
    enablebackup: string;
    /**
     * Enabling backup after a delay. Provide UTC Time in Unix format
     */
    enablebackupafteradelay: number;
    /**
     * Enable or disable restore for cluster
     */
    enablerestore: string;
    /**
     * Enabling restore after a delay. Provide UTC Time in Unix format
     */
    enablerestoreafteradelay: number;
}

export interface KubernetesClusterEtcdprotection {
    /**
     * Denote if etcd protection is enabled
     */
    enabled: string;
    plans?: outputs.KubernetesClusterEtcdprotectionPlan[];
}

export interface KubernetesClusterEtcdprotectionPlan {
    id: number;
    name: string;
}

export interface KubernetesClusterOption {
    /**
     * Request definition changing image registry options for cluster
     */
    imageregistries?: outputs.KubernetesClusterOptionImageregistry[];
}

export interface KubernetesClusterOptionImageregistry {
    /**
     * Specify image pull secret to authenticate with the image repository
     */
    imagepullsecret: string;
    /**
     * Specify image registry URL for internal image repository
     */
    registryurl: string;
}

export interface KubernetesClusterRegion {
    id: number;
    name: string;
}

export interface KubernetesClusterTag {
    name?: string;
    value?: string;
}

export interface PlanBackupdestinationExtendedretentionrule {
    firstextendedretentionrules?: outputs.PlanBackupdestinationExtendedretentionruleFirstextendedretentionrule[];
    secondextendedretentionrules?: outputs.PlanBackupdestinationExtendedretentionruleSecondextendedretentionrule[];
    thirdextendedretentionrules?: outputs.PlanBackupdestinationExtendedretentionruleThirdextendedretentionrule[];
}

export interface PlanBackupdestinationExtendedretentionruleFirstextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type: string;
}

export interface PlanBackupdestinationExtendedretentionruleSecondextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type: string;
}

export interface PlanBackupdestinationExtendedretentionruleThirdextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type: string;
}

export interface PlanBackupdestinationMapping {
    sources?: outputs.PlanBackupdestinationMappingSource[];
    sourcevendors?: outputs.PlanBackupdestinationMappingSourcevendor[];
    targets?: outputs.PlanBackupdestinationMappingTarget[];
    targetvendors?: outputs.PlanBackupdestinationMappingTargetvendor[];
    /**
     * Snapshot vendors available for Snap Copy mappings [NETAPP, AMAZON, PURE]
     */
    vendor?: string;
}

export interface PlanBackupdestinationMappingSource {
    id?: number;
    name?: string;
}

export interface PlanBackupdestinationMappingSourcevendor {
    id?: number;
    name?: string;
}

export interface PlanBackupdestinationMappingTarget {
    id?: number;
    name?: string;
}

export interface PlanBackupdestinationMappingTargetvendor {
    id?: number;
    name?: string;
}

export interface PlanBackupdestinationRegion {
    id: number;
    name: string;
}

export interface PlanBackupdestinationSourcecopy {
    id: number;
    name: string;
}

export interface PlanBackupdestinationStoragepool {
    id: number;
    name: string;
}

export interface PlanServerBackupcontent {
    /**
     * Do you want to back up the system state? Applicable only for Windows
     */
    backupsystemstate: string;
    /**
     * Do you want to back up system state only with full backup? Applicable only if the value of backupSystemState is true
     */
    backupsystemstateonlywithfullbackup: string;
    /**
     * Do you want to sync properties on associated subclients even if properties are overriden at subclient level?
     */
    forceupdateproperties: string;
    /**
     * Paths to exclude for Mac
     */
    macexcludedpaths: string[];
    /**
     * Paths that are exception to excluded paths for Mac
     */
    macfiltertoexcludepaths: string[];
    /**
     * Paths to include for Mac
     */
    macincludedpaths: string[];
    macnumberofdatareaders?: outputs.PlanServerBackupcontentMacnumberofdatareader[];
    /**
     * Paths to exclude for UNIX
     */
    unixexcludedpaths: string[];
    /**
     * Paths that are exception to excluded paths for Unix
     */
    unixfiltertoexcludepaths: string[];
    /**
     * Paths to include for UNIX
     */
    unixincludedpaths: string[];
    unixnumberofdatareaders?: outputs.PlanServerBackupcontentUnixnumberofdatareader[];
    /**
     * Do you want to back up system state with VSS? Applicable only if the value of backupSystemState is true
     */
    usevssforsystemstate: string;
    /**
     * Paths to exclude for Windows
     */
    windowsexcludedpaths: string[];
    /**
     * Paths that are exception to excluded paths for Windows
     */
    windowsfiltertoexcludepaths: string[];
    /**
     * Paths to include for Windows
     */
    windowsincludedpaths: string[];
    windowsnumberofdatareaders?: outputs.PlanServerBackupcontentWindowsnumberofdatareader[];
}

export interface PlanServerBackupcontentMacnumberofdatareader {
    /**
     * Number of data readers.
     */
    count: number;
    /**
     * Set optimal number of data readers. if it is set to true, count will be ignored.
     */
    useoptimal: string;
}

export interface PlanServerBackupcontentUnixnumberofdatareader {
    /**
     * Number of data readers.
     */
    count: number;
    /**
     * Set optimal number of data readers. if it is set to true, count will be ignored.
     */
    useoptimal: string;
}

export interface PlanServerBackupcontentWindowsnumberofdatareader {
    /**
     * Number of data readers.
     */
    count: number;
    /**
     * Set optimal number of data readers. if it is set to true, count will be ignored.
     */
    useoptimal: string;
}

export interface PlanServerBackupdestination {
    /**
     * Backup destination details. Enter the name during creation.
     */
    backupdestinationname?: string;
    /**
     * Backup start time in seconds. The time is provided in unix time format.
     */
    backupstarttime?: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    backupstocopy?: string;
    /**
     * If you want to update, specify the whole object. Extended retention rules should be bigger than retention period.
     */
    extendedretentionrules?: outputs.PlanServerBackupdestinationExtendedretentionrule[];
    /**
     * Which type of backup type should be copied for the given backup destination when backup type is not all jobs. Default is LAST while adding new backup destination. [FIRST, LAST]
     */
    fullbackuptypestocopy?: string;
    /**
     * Is this a mirror copy? Only considered when isSnapCopy is true.
     */
    ismirrorcopy?: string;
    /**
     * Is this a snap copy? If isMirrorCopy is not set, then default is Vault/Replica.
     */
    issnapcopy?: string;
    mappings?: outputs.PlanServerBackupdestinationMapping[];
    /**
     * Only for snap copy. Enabling this changes SVM Mapping  to NetApp cloud targets only.
     */
    netappcloudtarget?: string;
    /**
     * Flag to specify if primary storage is copy data management enabled.
     */
    optimizeforinstantclone?: string;
    /**
     * Tells if this copy should use storage pool retention period days or the retention defined for this copy. Set as true to use retention defined on this copy.
     */
    overrideretentionsettings?: string;
    regions?: outputs.PlanServerBackupdestinationRegion[];
    /**
     * Retention period in days. -1 can be specified for infinite retention. If this and snapRecoveryPoints both are not specified, this takes  precedence.
     */
    retentionperioddays?: number;
    /**
     * Which type of retention rule should be used for the given backup destination [RETENTION_PERIOD, SNAP_RECOVERY_POINTS]
     */
    retentionruletype?: string;
    /**
     * Number of snap recovery points for snap copy for retention. Can be specified instead of retention period in Days for snap copy.
     */
    snaprecoverypoints?: number;
    sourcecopies?: outputs.PlanServerBackupdestinationSourcecopy[];
    storagepools: outputs.PlanServerBackupdestinationStoragepool[];
    /**
     * [ALL, DISK, CLOUD, HYPERSCALE, TAPE]
     */
    storagetype?: string;
    /**
     * Use extended retention rules
     */
    useextendedretentionrules?: string;
}

export interface PlanServerBackupdestinationExtendedretentionrule {
    firstextendedretentionrules?: outputs.PlanServerBackupdestinationExtendedretentionruleFirstextendedretentionrule[];
    secondextendedretentionrules?: outputs.PlanServerBackupdestinationExtendedretentionruleSecondextendedretentionrule[];
    thirdextendedretentionrules?: outputs.PlanServerBackupdestinationExtendedretentionruleThirdextendedretentionrule[];
}

export interface PlanServerBackupdestinationExtendedretentionruleFirstextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention?: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays?: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type?: string;
}

export interface PlanServerBackupdestinationExtendedretentionruleSecondextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention?: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays?: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type?: string;
}

export interface PlanServerBackupdestinationExtendedretentionruleThirdextendedretentionrule {
    /**
     * If this is set as true, no need to specify retentionPeriodDays.
     */
    isinfiniteretention?: string;
    /**
     * If this is set, no need to specify isInfiniteRetention as false.
     */
    retentionperioddays?: number;
    /**
     * All_JOBS means SYNCHRONOUS copy type, others are applicable for SELECTIVE copy Type only. [All_JOBS, ALL_FULLS, HOURLY_FULLS, DAILY_FULLS, WEEKLY_FULLS, MONTHLY_FULLS, QUARTERLY_FULLS, HALF_YEARLY_FULLS, YEARLY_FULLS, ADVANCED]
     */
    type?: string;
}

export interface PlanServerBackupdestinationMapping {
    sources?: outputs.PlanServerBackupdestinationMappingSource[];
    sourcevendors?: outputs.PlanServerBackupdestinationMappingSourcevendor[];
    targets?: outputs.PlanServerBackupdestinationMappingTarget[];
    targetvendors?: outputs.PlanServerBackupdestinationMappingTargetvendor[];
    /**
     * Snapshot vendors available for Snap Copy mappings [NETAPP, AMAZON, PURE]
     */
    vendor?: string;
}

export interface PlanServerBackupdestinationMappingSource {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationMappingSourcevendor {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationMappingTarget {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationMappingTargetvendor {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationRegion {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationSourcecopy {
    id?: number;
    name?: string;
}

export interface PlanServerBackupdestinationStoragepool {
    id?: number;
    name?: string;
}

export interface PlanServerDatabaseoption {
    /**
     * Commit frequency in hours
     */
    commitfrequencyinhours: number;
    /**
     * Log backup RPO in minutes
     */
    logbackuprpomins: number;
    /**
     * Full backup frequency in days
     */
    runfullbackupevery: number;
    /**
     * Use disk cache for log backups
     */
    usediskcacheforlogbackups: string;
}

export interface PlanServerOverrideinheritsetting {
    /**
     * Flag to specify if parent or derived plan backupContent should be used when inherit mode is optional. True - derived, False - Base.
     */
    backupcontent: string;
    /**
     * Flag to specify if parent or derived plan backupDestination should be used when inherit mode is optional. True - derived, False - Base.
     */
    backupdestination: string;
    /**
     * Flag to specify if parent or derived plan rpo should be used when inherit mode is optional. True - derived, False - Base.
     */
    rpo: string;
}

export interface PlanServerOverriderestriction {
    /**
     * [OPTIONAL, MUST, NOT_ALLOWED]
     */
    backupcontent: string;
    /**
     * [OPTIONAL, MUST, NOT_ALLOWED]
     */
    rpo: string;
    /**
     * [OPTIONAL, MUST, NOT_ALLOWED]
     */
    storagepool: string;
}

export interface PlanServerParentplan {
    id: number;
    name: string;
}

export interface PlanServerRegiontoconfigure {
    id: number;
    name: string;
}

export interface PlanServerRpo {
    backupfrequencies?: outputs.PlanServerRpoBackupfrequency[];
    /**
     * Backup window for incremental backup
     */
    backupwindows?: outputs.PlanServerRpoBackupwindow[];
    /**
     * Backup window for full backup
     */
    fullbackupwindows?: outputs.PlanServerRpoFullbackupwindow[];
    /**
     * A server meets SLA (Service Level Agreement) when all of its subclients have at least one successful backup during the number of days specified at the CommCell, Server Group or plan level.
     */
    slas?: outputs.PlanServerRpoSla[];
}

export interface PlanServerRpoBackupfrequency {
    schedules?: outputs.PlanServerRpoBackupfrequencySchedule[];
}

export interface PlanServerRpoBackupfrequencySchedule {
    /**
     * Schedule Backup level [FULL, INCREMENTAL, DIFFERENTIAL, SYNTHETICFULL, TRANSACTIONLOG]
     */
    backuptype: string;
    /**
     * Boolean to indicate if schedule is for database agents
     */
    fordatabasesonly: string;
    /**
     * Name of the schedule, for modify
     */
    schedulename: string;
    /**
     * Specific options to be set on schedules
     */
    scheduleoptions?: outputs.PlanServerRpoBackupfrequencyScheduleScheduleoption[];
    /**
     * Used to describe when the schedule runs
     */
    schedulepatterns: outputs.PlanServerRpoBackupfrequencyScheduleSchedulepattern[];
    /**
     * Type of DR operation (only applicable for Failover groups) [PLANNED_FAILOVER, TEST_BOOT]
     */
    vmoperationtype: string;
}

export interface PlanServerRpoBackupfrequencyScheduleScheduleoption {
    /**
     * Commit frequency in hours for disk cache backups from automatic schedules
     */
    commitfrequencyinhours: number;
    /**
     * Number of days between auto conversion of backup level applicable for databases on incremental and differential schedules of server plan
     */
    daysbetweenautoconvert: number;
    /**
     * total job running time in minutes
     */
    jobrunningtimeinmins: number;
    /**
     * item backup option for O365 V2 backup jobs [SELECT_ALL, SELECT_NEVER_PROCESSED, SELECT_MEETING_SLA, SELECT_NOT_MEETING_SLA_PROCESSED_ATLEAST_ONCE, SELECT_FAILED_LAST_ATTEMPT, SELECT_PROCESSED_ATLEAST_ONCE, SELECT_NOT_MEETING_SLA, SELECT_MEETING_SLA_NOT_RECENTLY_BACKED_UP]
     */
    o365itemselectionoption: string;
    /**
     * Used to enable disk caching feature on databases for automatic schedules on server plan
     */
    usediskcacheforlogbackups: string;
}

export interface PlanServerRpoBackupfrequencyScheduleSchedulepattern {
    /**
     * Day on which to run the schedule, applicable for monthly, yearly
     */
    dayofmonth: number;
    /**
     * [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, DAY, WEEKDAY, WEEKEND_DAYS]
     */
    dayofweek: string;
    /**
     * No of days between two synthetic full jobs
     */
    daysbetweensyntheticfulls: number;
    /**
     * Schedule end date in epoch format
     */
    enddate: number;
    /**
     * Exceptions to when a schedule should not run, either in dates or week of month and days
     */
    exceptions?: outputs.PlanServerRpoBackupfrequencyScheduleSchedulepatternException[];
    /**
     * Frequency of the schedule based on schedule frequency type eg. for Hours, value 2 is 2 hours, for Minutes, 30 is 30 minutes, for Daily, 2 is 2 days. for Monthly 2 is it repeats every 2 months
     */
    frequency: number;
    /**
     * The number of mins to force a backup on automatic schedule.
     */
    maxbackupintervalinmins: number;
    /**
     * [JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER]
     */
    monthofyear: string;
    /**
     * The number of times you want the schedule to run.
     */
    nooftimes: number;
    /**
     * How often in minutes in a day the schedule runs, applicable for daily, weekly, monthly and yearly frequency types.
     */
    repeatintervalinminutes: number;
    /**
     * Until what time to repeat the schedule in a day, requires repeatIntervalInMinutes
     */
    repeatuntiltime: number;
    /**
     * schedule frequency type [MINUTES, DAILY, WEEKLY, MONTHLY, YEARLY, AUTOMATIC]
     */
    schedulefrequencytype: string;
    /**
     * start date of schedule in epoch format
     */
    startdate: number;
    /**
     * start time of schedule in seconds
     */
    starttime: number;
    timezones?: outputs.PlanServerRpoBackupfrequencyScheduleSchedulepatternTimezone[];
    /**
     * Days of the week for weekly frequency
     */
    weeklydays: string[];
    /**
     * Specific week of a month [FIRST, SECOND, THIRD, FOURTH, LAST]
     */
    weekofmonth: string;
}

export interface PlanServerRpoBackupfrequencyScheduleSchedulepatternException {
    /**
     * list of dates in a month. For ex: 1, 20
     */
    ondates: number[];
    /**
     * On which days, for ex: MONDAY, FRIDAY
     */
    ondayoftheweeks: string[];
    /**
     * On which week of month, for ex: FIRST, LAST
     */
    onweekofthemonths: string[];
}

export interface PlanServerRpoBackupfrequencyScheduleSchedulepatternTimezone {
    id: number;
    name: string;
}

export interface PlanServerRpoBackupwindow {
    dayofweeks: string[];
    /**
     * Time in seconds since the beginning of the day
     */
    endtime: number;
    /**
     * Time in seconds since the beginning of the day
     */
    starttime: number;
}

export interface PlanServerRpoFullbackupwindow {
    dayofweeks: string[];
    /**
     * Time in seconds since the beginning of the day
     */
    endtime: number;
    /**
     * Time in seconds since the beginning of the day
     */
    starttime: number;
}

export interface PlanServerRpoSla {
    /**
     * Time provided in Unix format. Give 0 to reset any existing delay.
     */
    enableafterdelay: number;
    /**
     * Flag to set to exclude plan from SLA
     */
    excludefromsla: string;
    /**
     * Reason for exclusion from SLA
     */
    exclusionreason: string;
    /**
     * SLA Period in Days
     */
    slaperiod: number;
    /**
     * Flag to set to use System Default Service Level Agreement
     */
    usesystemdefaultsla: string;
}

export interface PlanServerSetting {
    /**
     * Setting to suggest plan has some advanced settings present. Setting is OEM specific and not applicable for all cases.
     */
    enableadvancedview: string;
    /**
     * This feature applies to file servers and virtualization. Enabling this feature allows you to search for backed-up files using the global search bar, and creates resource pools with required infrastructure entities.
     */
    filesearches?: outputs.PlanServerSettingFilesearch[];
}

export interface PlanServerSettingFilesearch {
    /**
     * Flag for enabling indexing
     */
    enabled: string;
    /**
     * Type of indexing status. [NOT_APPLICABLE, ENABLED, SETUP_IN_PROGRESS]
     */
    status: string;
    /**
     * Tells what is happening behind the scene, so that user can knows why indexing is not enabled or if its in progress
     */
    statusmessage: string;
}

export interface PlanServerSnapshotoption {
    /**
     * Backup copy RPO in minutes
     */
    backupcopyrpomins: number;
    /**
     * Flag to enable backup copy
     */
    enablebackupcopy: string;
}

export interface PlanServerWorkload {
    solutions?: outputs.PlanServerWorkloadSolution[];
    workloadgrouptypes: string[];
    workloadtypes?: outputs.PlanServerWorkloadWorkloadtype[];
}

export interface PlanServerWorkloadSolution {
    id: number;
}

export interface PlanServerWorkloadWorkloadtype {
    id: number;
}

export interface RolePermissionlist {
    categories?: outputs.RolePermissionlistCategory[];
    permissions?: outputs.RolePermissionlistPermission[];
}

export interface RolePermissionlistCategory {
    id?: number;
}

export interface RolePermissionlistPermission {
    id?: number;
}

export interface RoleSecurity {
    roles?: outputs.RoleSecurityRole[];
    usergroups?: outputs.RoleSecurityUsergroup[];
    users?: outputs.RoleSecurityUser[];
}

export interface RoleSecurityRole {
    id?: number;
}

export interface RoleSecurityUser {
    id?: number;
}

export interface RoleSecurityUsergroup {
    id?: number;
}

export interface SecurityAssociationV2Entity {
    id: number;
    name: string;
    typeid: number;
    typename: string;
}

export interface SecurityAssociationV2Role {
    id: number;
    name: string;
}

export interface SecurityAssociationV2Usergroup {
    id: number;
    name: string;
}

export interface StorageCloudAccesspathMediaagent {
    id: number;
    name: string;
}

export interface StorageCloudAzureCredential {
    id: number;
    name: string;
}

export interface StorageCloudAzureDeduplicationdblocation {
    mediaagents?: outputs.StorageCloudAzureDeduplicationdblocationMediaagent[];
    path?: string;
}

export interface StorageCloudAzureDeduplicationdblocationMediaagent {
    id?: number;
    name?: string;
}

export interface StorageCloudAzureEncryption {
    /**
     * The different types of encryption keys that can be used for encrypting the data. The values are case sensitive [BlowFish, AES, DES3, GOST, Serpent, Twofish]
     */
    cipher: string;
    encrypt: string;
    /**
     * Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256.
     */
    keylength: number;
    keyproviders?: outputs.StorageCloudAzureEncryptionKeyprovider[];
}

export interface StorageCloudAzureEncryptionKeyprovider {
    id: number;
    name: string;
}

export interface StorageCloudAzureMediaagent {
    id: number;
    name: string;
}

export interface StorageCloudAzureSecurity {
    roles?: outputs.StorageCloudAzureSecurityRole[];
    usergroups?: outputs.StorageCloudAzureSecurityUsergroup[];
    users?: outputs.StorageCloudAzureSecurityUser[];
}

export interface StorageCloudAzureSecurityRole {
    id?: number;
}

export interface StorageCloudAzureSecurityUser {
    id?: number;
}

export interface StorageCloudAzureSecurityUsergroup {
    id?: number;
}

export interface StorageCloudBucketS3Configuration {
    /**
     * When true, prevents new data writes to backup location by changing number of writers to zero
     */
    disablebackuplocationforfuturebackups: string;
    /**
     * When true, means mount path is enabled
     */
    enable: string;
    /**
     * When true, the deduplicated blocks in the mount path will not be referenced when there are multiple mount paths in the library.
     */
    prepareforretirement: string;
    storageacceleratorcredentials?: outputs.StorageCloudBucketS3ConfigurationStorageacceleratorcredential[];
}

export interface StorageCloudBucketS3ConfigurationStorageacceleratorcredential {
    id: number;
    name: string;
}

export interface StorageCloudBucketS3Credential {
    id: number;
    name: string;
}

export interface StorageCloudBucketS3Mediaagent {
    id: number;
    name: string;
}

export interface StorageCloudS3Credential {
    id: number;
    name: string;
}

export interface StorageCloudS3Deduplicationdblocation {
    mediaagents?: outputs.StorageCloudS3DeduplicationdblocationMediaagent[];
    path?: string;
}

export interface StorageCloudS3DeduplicationdblocationMediaagent {
    id?: number;
    name?: string;
}

export interface StorageCloudS3Encryption {
    /**
     * The different types of encryption keys that can be used for encrypting the data. The values are case sensitive [BlowFish, AES, DES3, GOST, Serpent, Twofish]
     */
    cipher: string;
    encrypt: string;
    /**
     * Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256.
     */
    keylength: number;
    keyproviders?: outputs.StorageCloudS3EncryptionKeyprovider[];
}

export interface StorageCloudS3EncryptionKeyprovider {
    id: number;
    name: string;
}

export interface StorageCloudS3Mediaagent {
    id: number;
    name: string;
}

export interface StorageCloudS3Security {
    roles?: outputs.StorageCloudS3SecurityRole[];
    usergroups?: outputs.StorageCloudS3SecurityUsergroup[];
    users?: outputs.StorageCloudS3SecurityUser[];
}

export interface StorageCloudS3SecurityRole {
    id?: number;
}

export interface StorageCloudS3SecurityUser {
    id?: number;
}

export interface StorageCloudS3SecurityUsergroup {
    id?: number;
}

export interface StorageContainerAzureConfiguration {
    /**
     * When true, prevents new data writes to backup location by changing number of writers to zero
     */
    disablebackuplocationforfuturebackups: string;
    /**
     * When true, means mount path is enabled
     */
    enable: string;
    /**
     * When true, the deduplicated blocks in the mount path will not be referenced when there are multiple mount paths in the library.
     */
    prepareforretirement: string;
    storageacceleratorcredentials?: outputs.StorageContainerAzureConfigurationStorageacceleratorcredential[];
}

export interface StorageContainerAzureConfigurationStorageacceleratorcredential {
    id: number;
    name: string;
}

export interface StorageContainerAzureCredential {
    id: number;
    name: string;
}

export interface StorageContainerAzureMediaagent {
    id: number;
    name: string;
}

export interface StorageDiskBackupLocationConfiguration {
    /**
     * Used to determine if backup location has to be disabled or enabled for future backups
     */
    disablebackuplocationforfuturebackups: string;
    /**
     * Used to enable or disable backup location
     */
    enablebackuplocation: string;
    /**
     * Used to determine if the backup location has to be prepared for retirement
     */
    prepareforretirement: string;
}

export interface StorageDiskBackupLocationCredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface StorageDiskBackupLocationMediaagent {
    id: number;
    name: string;
}

export interface StorageDiskBackupLocationSavedcredential {
    id: number;
    name: string;
}

export interface StorageDiskDataencryption {
    /**
     * The different types of encryption keys that can be used for encrypting the data. The values are case sensitive [BlowFish, AES, DES3, GOST, Serpent, Twofish]
     */
    cipher: string;
    encrypt: string;
    /**
     * Different keylengths are present for different kinds of ciphers. Blowfish,Twofish,AES and Serpent all accept both 128 and 256. DES3 accepts only 192. GOST accepts only 256.
     */
    keylength: number;
    keyproviders?: outputs.StorageDiskDataencryptionKeyprovider[];
}

export interface StorageDiskDataencryptionKeyprovider {
    id: number;
    name: string;
}

export interface StorageDiskDeduplicationdbstorage {
    mediaagents?: outputs.StorageDiskDeduplicationdbstorageMediaagent[];
    path?: string;
}

export interface StorageDiskDeduplicationdbstorageMediaagent {
    id?: number;
    name?: string;
}

export interface StorageDiskSecurity {
    roles?: outputs.StorageDiskSecurityRole[];
    usergroups?: outputs.StorageDiskSecurityUsergroup[];
    users?: outputs.StorageDiskSecurityUser[];
}

export interface StorageDiskSecurityRole {
    id?: number;
}

export interface StorageDiskSecurityUser {
    id?: number;
}

export interface StorageDiskSecurityUsergroup {
    id?: number;
}

export interface StorageDiskStorage {
    backuplocation?: string;
    credentials?: outputs.StorageDiskStorageCredential[];
    mediaagents: outputs.StorageDiskStorageMediaagent[];
    savedcredentials?: outputs.StorageDiskStorageSavedcredential[];
}

export interface StorageDiskStorageCredential {
    /**
     * username to access the network path
     */
    name?: string;
    /**
     * password to access the network path
     */
    password?: string;
}

export interface StorageDiskStorageMediaagent {
    id?: number;
    name?: string;
}

export interface StorageDiskStorageSavedcredential {
    id?: number;
    name?: string;
}

export interface UserV2Company {
    id: number;
    name: string;
}

export interface UserV2Plan {
    id?: number;
    name?: string;
}

export interface UsergroupAssociatedexternalgroup {
    id?: number;
}

export interface UsergroupRestrictconsoletype {
    consoletypes?: string[];
}

export interface UsergroupUser {
    id: number;
}

export interface VmgroupV2Accessnode {
    id?: number;
}

export interface VmgroupV2Activitycontrol {
    backupactivitycontroloptions?: outputs.VmgroupV2ActivitycontrolBackupactivitycontroloption[];
    /**
     * true if Backup is enabled
     */
    enablebackup: string;
    /**
     * true if Restore is enabled
     */
    enablerestore: string;
    restoreactivitycontroloptions?: outputs.VmgroupV2ActivitycontrolRestoreactivitycontroloption[];
}

export interface VmgroupV2ActivitycontrolBackupactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.VmgroupV2ActivitycontrolBackupactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface VmgroupV2ActivitycontrolBackupactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.VmgroupV2ActivitycontrolBackupactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface VmgroupV2ActivitycontrolBackupactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface VmgroupV2ActivitycontrolRestoreactivitycontroloption {
    /**
     * denotes the activity type being considered [BACKUP, RESTORE, ONLINECI, ARCHIVEPRUNE]
     */
    activitytype: string;
    delaytimes?: outputs.VmgroupV2ActivitycontrolRestoreactivitycontroloptionDelaytime[];
    /**
     * True if the activity type is enabled
     */
    enableactivitytype: string;
    /**
     * True if the activity will be enabled after a delay time interval
     */
    enableafteradelay: string;
}

export interface VmgroupV2ActivitycontrolRestoreactivitycontroloptionDelaytime {
    /**
     * delay time in unix timestamp
     */
    time: number;
    timezones?: outputs.VmgroupV2ActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone[];
    /**
     * actual delay time value in string format according to the timezone
     */
    value: string;
}

export interface VmgroupV2ActivitycontrolRestoreactivitycontroloptionDelaytimeTimezone {
    id: number;
    name: string;
}

export interface VmgroupV2Applicationvalidation {
    /**
     * Application validation source copy details
     */
    copies?: outputs.VmgroupV2ApplicationvalidationCopy[];
    /**
     * Custom validation script to be used during VM backup validation
     */
    customvalidationscripts?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscript[];
    guestcredentials?: outputs.VmgroupV2ApplicationvalidationGuestcredential[];
    /**
     * If true then validated VMs will be available until expiration time set on the recovery target
     */
    keepvalidatedvmsrunning: string;
    /**
     * Number of backup Validation Threads
     */
    maximumnoofthreads: number;
    recoverytargets?: outputs.VmgroupV2ApplicationvalidationRecoverytarget[];
    /**
     * Schedule for application validation for VM Group
     */
    schedules?: outputs.VmgroupV2ApplicationvalidationSchedule[];
    /**
     * Use Source VM ESX To Mount
     */
    usesourcevmesxtomount: string;
    /**
     * True if VM Backup validation is enabled
     */
    validatevmbackups: string;
}

export interface VmgroupV2ApplicationvalidationCopy {
    backupdestinations?: outputs.VmgroupV2ApplicationvalidationCopyBackupdestination[];
    /**
     * Order of backup destinaion copy created in storage policy
     */
    copyprecedence: number;
    /**
     * Id of the source copy
     */
    id: number;
    /**
     * Is this an active backup destination?
     */
    isactive: string;
    /**
     * Is this a snap copy?
     */
    issnapcopy: string;
    /**
     * Name of the source copy
     */
    name: string;
}

export interface VmgroupV2ApplicationvalidationCopyBackupdestination {
    id: number;
    name: string;
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscript {
    unixes?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptUnix[];
    windows?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptWindow[];
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptUnix {
    /**
     * Arguments for the script
     */
    arguments: string;
    /**
     * Is the script disabled
     */
    isdisabled: string;
    /**
     * True if the script is local
     */
    islocal: string;
    /**
     * Path for the validation script
     */
    path: string;
    unccredentials?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptUnixUnccredential[];
    uncsavedcredentials?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptUnixUncsavedcredential[];
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptUnixUnccredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptUnixUncsavedcredential {
    id: number;
    name: string;
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptWindow {
    /**
     * Arguments for the script
     */
    arguments: string;
    /**
     * Is the script disabled
     */
    isdisabled: string;
    /**
     * True if the script is local
     */
    islocal: string;
    /**
     * Path for the validation script
     */
    path: string;
    unccredentials?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptWindowUnccredential[];
    uncsavedcredentials?: outputs.VmgroupV2ApplicationvalidationCustomvalidationscriptWindowUncsavedcredential[];
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptWindowUnccredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface VmgroupV2ApplicationvalidationCustomvalidationscriptWindowUncsavedcredential {
    id: number;
    name: string;
}

export interface VmgroupV2ApplicationvalidationGuestcredential {
    credentials?: outputs.VmgroupV2ApplicationvalidationGuestcredentialCredential[];
    savedcredentials?: outputs.VmgroupV2ApplicationvalidationGuestcredentialSavedcredential[];
}

export interface VmgroupV2ApplicationvalidationGuestcredentialCredential {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface VmgroupV2ApplicationvalidationGuestcredentialSavedcredential {
    name: string;
}

export interface VmgroupV2ApplicationvalidationRecoverytarget {
    id: number;
    name: string;
}

export interface VmgroupV2ApplicationvalidationSchedule {
    /**
     * Description for validation schedule
     */
    description: string;
    id: number;
    /**
     * True if application validation schedule is enabled
     */
    isscheduleenabled: string;
    /**
     * Job Id for the application validation task. 0 if schedule is disabled
     */
    taskid: number;
}

export interface VmgroupV2Content {
    /**
     * True if content in vmgroup has to be overwritten, by default it will append the content
     */
    overwrite: string;
    rulegroups?: outputs.VmgroupV2ContentRulegroup[];
}

export interface VmgroupV2ContentRulegroup {
    /**
     * Enum which specifies the whether to match all rules or any of the rules [ALL, ANY]
     */
    matchrule?: string;
    rules?: outputs.VmgroupV2ContentRulegroupRule[];
}

export interface VmgroupV2ContentRulegroupRule {
    /**
     * Operation type for VM rules/filters [CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_EQUAL, ENDS_WITH, EQUALS, STARTS_WITH]
     */
    condition?: string;
    /**
     * name of the VM to be added as content
     */
    name?: string;
    /**
     * [NONE, SERVER, RES_POOL, VAPP, DATACENTER, FOLDER, CLUSTER, DATASTORE, DATASTORE_CLUSTER, VM, VM_NAME, VM_GUEST_OS, VM_GUEST_HOST_NAME, CLUSTER_SHARED_VOLUMES, LOCAL_DISK, CLUSTER_DISK, UNPROTECTED_VMS, ROOT, FILE_SERVER, SMB_SHARE, TYPES_FOLDER, VM_FOLDER, SERVER_FOLDER, TEMPLATE_FOLDER, STORAGE_REPOSITORY_FOLDER, VAPPFOLDER, DATACENTER_FOLDER, CLUSTER_FOLDER, VM_POWER_STATE, VM_NOTES, VM_CUSTOM_ATTRIBUTE, NETWORK, USER, VM_TEMPLATE, TAG, TAG_CATEGORY, SUBCLIENT, CLIENT_GROUP, PROTECTION_DOMAIN, CONSISTENCY_GROUP, INSTANCE_SIZE, ORGANIZATION, IMAGES, STORAGE_POLICY, DATABASE, TABLE, PROJECT, SELECTOR, MANAGED_BY, REPLICATION_MODE, METADATATAG, CATALOG, VAPPTEMPLATE, VOLUME]
     */
    type?: string;
}

export interface VmgroupV2Diskfilter {
    /**
     * True if content in vmgroup has to be overwritten, by default it will append the content
     */
    overwrite: string;
    rules?: outputs.VmgroupV2DiskfilterRule[];
}

export interface VmgroupV2DiskfilterRule {
    /**
     * Operation type for VM rules/filters [CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_EQUAL, ENDS_WITH, EQUALS, STARTS_WITH]
     */
    condition: string;
    /**
     * [NONE, DISK_PATH, DISK_PATTERN, DISK_VIRTUAL_DEVICE_NODE, DISK_DATASTORE, DISK_LABEL, DISK_TYPE, DISK_ADDRESS, CONTAINER_PATTERN, DISK_TAG]
     */
    filtertype: string;
    /**
     * The string to be filtered
     */
    name: string;
    /**
     * True if disk filter in vmgroup has to be overwritten, by default it will append the content
     */
    overwrite: string;
    /**
     * The value string to be filtered, in case of disk tag , value of tag to be filtered
     */
    value: string;
    /**
     * VM Guid of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
     */
    vmguid: string;
    /**
     * VM Name of the Virtual Machine whose disk has to be filtered . This is optional. if not given, all disks of name and type from all Vms added in content will be filtered
     */
    vmname: string;
}

export interface VmgroupV2Filter {
    /**
     * True if content in vmgroup has to be overwritten, by default it will append the content
     */
    overwrite: string;
    rulegroups?: outputs.VmgroupV2FilterRulegroup[];
}

export interface VmgroupV2FilterRulegroup {
    /**
     * Enum which specifies the whether to match all rules or any of the rules [ALL, ANY]
     */
    matchrule?: string;
    rules?: outputs.VmgroupV2FilterRulegroupRule[];
}

export interface VmgroupV2FilterRulegroupRule {
    /**
     * Operation type for VM rules/filters [CONTAINS, DOES_NOT_CONTAIN, DOES_NOT_EQUAL, ENDS_WITH, EQUALS, STARTS_WITH]
     */
    condition?: string;
    /**
     * name of the VM to be added as content
     */
    name?: string;
    /**
     * [NONE, SERVER, RES_POOL, VAPP, DATACENTER, FOLDER, CLUSTER, DATASTORE, DATASTORE_CLUSTER, VM, VM_NAME, VM_GUEST_OS, VM_GUEST_HOST_NAME, CLUSTER_SHARED_VOLUMES, LOCAL_DISK, CLUSTER_DISK, UNPROTECTED_VMS, ROOT, FILE_SERVER, SMB_SHARE, TYPES_FOLDER, VM_FOLDER, SERVER_FOLDER, TEMPLATE_FOLDER, STORAGE_REPOSITORY_FOLDER, VAPPFOLDER, DATACENTER_FOLDER, CLUSTER_FOLDER, VM_POWER_STATE, VM_NOTES, VM_CUSTOM_ATTRIBUTE, NETWORK, USER, VM_TEMPLATE, TAG, TAG_CATEGORY, SUBCLIENT, CLIENT_GROUP, PROTECTION_DOMAIN, CONSISTENCY_GROUP, INSTANCE_SIZE, ORGANIZATION, IMAGES, STORAGE_POLICY, DATABASE, TABLE, PROJECT, SELECTOR, MANAGED_BY, REPLICATION_MODE, METADATATAG, CATALOG, VAPPTEMPLATE, VOLUME]
     */
    type?: string;
}

export interface VmgroupV2Hypervisor {
    id: number;
    name: string;
}

export interface VmgroupV2Meditech {
    /**
     * Meditech Listener IP of FQDN name
     */
    listenerip: string;
    /**
     * Meditech Listener Port
     */
    listenerport: number;
    /**
     * MBF timeout (in seconds)
     */
    mbftimeout: number;
    /**
     * Meditech system name
     */
    systemname: string;
    useraccounts?: outputs.VmgroupV2MeditechUseraccount[];
}

export interface VmgroupV2MeditechUseraccount {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface VmgroupV2Meditechsystem {
    /**
     * Meditech Listener IP of FQDN name
     */
    listenerip: string;
    /**
     * Meditech Listener Port
     */
    listenerport: number;
    /**
     * MBF timeout (in seconds)
     */
    mbftimeout: number;
    /**
     * Meditech system name
     */
    systemname: string;
    useraccounts?: outputs.VmgroupV2MeditechsystemUseraccount[];
}

export interface VmgroupV2MeditechsystemUseraccount {
    /**
     * username to access the network path
     */
    name: string;
    /**
     * password to access the network path
     */
    password: string;
}

export interface VmgroupV2Plan {
    id: number;
    name: string;
}

export interface VmgroupV2Securityassociation {
    /**
     * External User Group Entity
     */
    externalusergroups?: outputs.VmgroupV2SecurityassociationExternalusergroup[];
    iscreatorassociation?: string;
    permissionlists?: outputs.VmgroupV2SecurityassociationPermissionlist[];
    roles?: outputs.VmgroupV2SecurityassociationRole[];
    usergroups?: outputs.VmgroupV2SecurityassociationUsergroup[];
    users?: outputs.VmgroupV2SecurityassociationUser[];
}

export interface VmgroupV2SecurityassociationExternalusergroup {
    /**
     * User Group Id
     */
    id?: number;
    /**
     * External Group Name
     */
    name?: string;
    /**
     * Provider id
     */
    providerid?: number;
    /**
     * Provider Name
     */
    providername?: string;
}

export interface VmgroupV2SecurityassociationPermissionlist {
    categoryid?: number;
    categoryname?: string;
    /**
     * Flag to specify if this is included permission or excluded permission.
     */
    exclude?: string;
    permissionid?: number;
    permissionname?: string;
    /**
     * Returns the type of association. [ALL_CATEGORIES, CATEGORY_ENTITY, PERMISSION_ENTITY]
     */
    type?: string;
}

export interface VmgroupV2SecurityassociationRole {
    id?: number;
    name?: string;
}

export interface VmgroupV2SecurityassociationUser {
    id?: number;
    name?: string;
}

export interface VmgroupV2SecurityassociationUsergroup {
    id?: number;
    name?: string;
}

export interface VmgroupV2Setting {
    /**
     * True if empty subclient is allowed
     */
    allowemptysubclient?: string;
    /**
     * True if auto detect VM Owner enabled
     */
    autodetectvmowner?: string;
    /**
     * True if metadata collection is enabled. Only applicable for Indexing v1
     */
    collectfiledetailsforgranularrecovery?: string;
    /**
     * True if metadata collection is enabled for intellisnap jobs. Only applicable for Indexing v1
     */
    collectfiledetailsfromsnapshotcopy?: string;
    crossaccounts?: outputs.VmgroupV2SettingCrossaccount[];
    /**
     * Custom snapshot resource group name for Azure
     */
    customsnapshotresourcegroup?: string;
    /**
     * represents custom tags to be set on snapshots
     */
    customsnapshottags?: outputs.VmgroupV2SettingCustomsnapshottag[];
    /**
     * True if Datastore Free space check is enabled
     */
    datastorefreespacecheck?: string;
    /**
     * precentage of datastore free space check value
     */
    datastorefreespacerequired?: number;
    guestcredentials?: outputs.VmgroupV2SettingGuestcredential[];
    /**
     * Is the VM App Aware
     */
    isapplicationaware?: string;
    /**
     * Is VM group disk filters included in VM instance disk filters
     */
    isvmgroupdiskfiltersincluded?: string;
    /**
     * Start Time for the VM Group Job
     */
    jobstarttime?: number;
    /**
     * Number of readers for backup
     */
    noofreaders?: number;
    /**
     * True when snapshot storage location is regional
     */
    regionalsnapshot?: string;
    /**
     * transport mode based on environment. Values are case sensitive [AUTO, SAN, HOT_ADD, NAS, NBD_SSL, NBD]
     */
    transportmode?: string;
    /**
     * True if Changed Block Tracking is enabled
     */
    usechangedblocktrackingonvm?: string;
    /**
     * True if use VM CheckPoint setting is enabled
     */
    usevmcheckpointsetting?: string;
    /**
     * [APPLICATION_AWARE, FILE_SYSTEM_AND_APPLICATION_CONSISTENT, CRASH_CONSISTENT, APP_BASED_BACKUP, INHERITED]
     */
    vmbackuptype?: string;
}

export interface VmgroupV2SettingCrossaccount {
    destinationaccounts?: outputs.VmgroupV2SettingCrossaccountDestinationaccount[];
    /**
     * True if full copy of amazon snapshot to different amazon account is enabled
     */
    fullcopy?: string;
    /**
     * True if replicate and copy or sharing of amazon snapshot to different amazon account in same or different geographic location is enabled
     */
    shareonly?: string;
}

export interface VmgroupV2SettingCrossaccountDestinationaccount {
    id?: number;
    name?: string;
}

export interface VmgroupV2SettingCustomsnapshottag {
    /**
     * represents name of the tag
     */
    name?: string;
    /**
     * represents value of the tag
     */
    value?: string;
}

export interface VmgroupV2SettingGuestcredential {
    credentials?: outputs.VmgroupV2SettingGuestcredentialCredential[];
    savedcredentials?: outputs.VmgroupV2SettingGuestcredentialSavedcredential[];
}

export interface VmgroupV2SettingGuestcredentialCredential {
    /**
     * username to access the network path
     */
    name?: string;
    /**
     * password to access the network path
     */
    password?: string;
}

export interface VmgroupV2SettingGuestcredentialSavedcredential {
    name?: string;
}

export interface VmgroupV2Snapshotmanagement {
    /**
     * [FILE_SYSTEM, RMAN, VOLUME_COPY]
     */
    backupcopyinterface: string;
    /**
     * True if hardware snapshot is enabled
     */
    enablehardwaresnapshot: string;
    /**
     * True if independent disk option is enabled
     */
    isindependentdisksenabled: string;
    /**
     * True if raw device maps option is enabled
     */
    israwdevicemapsenabled: string;
    snapengines?: outputs.VmgroupV2SnapshotmanagementSnapengine[];
    /**
     * Name of ESX Host
     */
    snapmountesxhost: string;
    snapmountproxies?: outputs.VmgroupV2SnapshotmanagementSnapmountproxy[];
    /**
     * True if separate proxy client is used for snap to tape
     */
    useseparateproxyforsnaptotape: string;
    /**
     * Virtual machine application user name
     */
    vmapplicationusername: string;
}

export interface VmgroupV2SnapshotmanagementSnapengine {
    id: number;
    name: string;
}

export interface VmgroupV2SnapshotmanagementSnapmountproxy {
    id: number;
    name: string;
}

export interface VmgroupV2Storage {
    id: number;
    name: string;
}

export interface VmgroupV2Timezone {
    id: number;
    name: string;
}

