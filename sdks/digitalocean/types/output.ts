// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AppDedicatedIp {
    /**
     * The ID of the dedicated egress IP.
     */
    id: string;
    /**
     * The IP address of the dedicated egress IP.
     */
    ip: string;
    /**
     * The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
     */
    status: string;
}

export interface AppSpec {
    alerts?: outputs.AppSpecAlert[];
    databases?: outputs.AppSpecDatabase[];
    domain?: outputs.AppSpecDomain[];
    /**
     * @deprecated Deprecated
     */
    domains: string[];
    egresses?: outputs.AppSpecEgress[];
    envs?: outputs.AppSpecEnv[];
    /**
     * List of features which is applied to the app
     */
    features: string[];
    functions?: outputs.AppSpecFunction[];
    ingress?: outputs.AppSpecIngress;
    jobs?: outputs.AppSpecJob[];
    /**
     * The name of the app. Must be unique across all apps in the same account.
     */
    name: string;
    /**
     * The slug for the DigitalOcean data center region hosting the app
     */
    region?: string;
    services?: outputs.AppSpecService[];
    staticSites?: outputs.AppSpecStaticSite[];
    workers?: outputs.AppSpecWorker[];
}

export interface AppSpecAlert {
    disabled?: boolean;
    rule: string;
}

export interface AppSpecDatabase {
    /**
     * The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if cluster_name is not set, a new cluster will be provisioned.
     */
    clusterName?: string;
    /**
     * The name of the MySQL or PostgreSQL database to configure.
     */
    dbName?: string;
    /**
     * The name of the MySQL or PostgreSQL user to configure.
     */
    dbUser?: string;
    /**
     * The database engine to use.
     */
    engine?: string;
    /**
     * The name of the component
     */
    name?: string;
    /**
     * Whether this is a production or dev database.
     */
    production?: boolean;
    /**
     * The version of the database engine.
     */
    version?: string;
}

export interface AppSpecDomain {
    /**
     * The hostname for the domain.
     */
    name: string;
    /**
     * The type of the domain.
     */
    type: string;
    /**
     * Indicates whether the domain includes all sub-domains, in addition to the given domain.
     */
    wildcard: boolean;
    /**
     * If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
     */
    zone?: string;
}

export interface AppSpecEgress {
    /**
     * The app egress type.
     */
    type?: string;
}

export interface AppSpecEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecFunction {
    /**
     * Alert policies for the app component
     */
    alerts?: outputs.AppSpecFunctionAlert[];
    /**
     * @deprecated Deprecated
     */
    cors?: outputs.AppSpecFunctionCors;
    envs?: outputs.AppSpecFunctionEnv[];
    git?: outputs.AppSpecFunctionGit;
    github?: outputs.AppSpecFunctionGithub;
    gitlab?: outputs.AppSpecFunctionGitlab;
    /**
     * Logs
     */
    logDestinations?: outputs.AppSpecFunctionLogDestination[];
    /**
     * The name of the component
     */
    name: string;
    /**
     * @deprecated Deprecated
     */
    routes?: outputs.AppSpecFunctionRoute[];
    /**
     * An optional path to the working directory to use for the build.
     */
    sourceDir?: string;
}

export interface AppSpecFunctionAlert {
    disabled?: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface AppSpecFunctionCors {
    /**
     * Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
     */
    allowCredentials?: boolean;
    /**
     * The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
     */
    allowHeaders?: string[];
    /**
     * The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
     */
    allowMethods?: string[];
    /**
     * The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
     */
    allowOrigins?: outputs.AppSpecFunctionCorsAllowOrigins;
    /**
     * The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
     */
    exposeHeaders?: string[];
    /**
     * An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
     */
    maxAge?: string;
}

export interface AppSpecFunctionCorsAllowOrigins {
    /**
     * Exact string match.
     */
    exact?: string;
    /**
     * Prefix-based match.
     *
     * @deprecated Deprecated
     */
    prefix?: string;
    /**
     * RE2 style regex-based match.
     */
    regex?: string;
}

export interface AppSpecFunctionEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecFunctionGit {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * The clone URL of the repo.
     */
    repoCloneUrl?: string;
}

export interface AppSpecFunctionGithub {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecFunctionGitlab {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecFunctionLogDestination {
    /**
     * Datadog configuration.
     */
    datadog?: outputs.AppSpecFunctionLogDestinationDatadog;
    /**
     * Logtail configuration.
     */
    logtail?: outputs.AppSpecFunctionLogDestinationLogtail;
    /**
     * Name of the log destination
     */
    name: string;
    /**
     * Papertrail configuration.
     */
    papertrail?: outputs.AppSpecFunctionLogDestinationPapertrail;
}

export interface AppSpecFunctionLogDestinationDatadog {
    /**
     * Datadog API key.
     */
    apiKey: string;
    /**
     * Datadog HTTP log intake endpoint.
     */
    endpoint?: string;
}

export interface AppSpecFunctionLogDestinationLogtail {
    /**
     * Logtail token.
     */
    token: string;
}

export interface AppSpecFunctionLogDestinationPapertrail {
    /**
     * Papertrail syslog endpoint.
     */
    endpoint: string;
}

export interface AppSpecFunctionRoute {
    /**
     * Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app.
     */
    path?: string;
    /**
     * An optional flag to preserve the path that is forwarded to the backend service.
     */
    preservePathPrefix?: boolean;
}

export interface AppSpecIngress {
    rules?: outputs.AppSpecIngressRule[];
}

export interface AppSpecIngressRule {
    component?: outputs.AppSpecIngressRuleComponent;
    cors?: outputs.AppSpecIngressRuleCors;
    match?: outputs.AppSpecIngressRuleMatch;
    redirect?: outputs.AppSpecIngressRuleRedirect;
}

export interface AppSpecIngressRuleComponent {
    name: string;
    preservePathPrefix: boolean;
    rewrite: string;
}

export interface AppSpecIngressRuleCors {
    /**
     * Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
     */
    allowCredentials?: boolean;
    /**
     * The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
     */
    allowHeaders?: string[];
    /**
     * The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
     */
    allowMethods?: string[];
    /**
     * The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
     */
    allowOrigins?: outputs.AppSpecIngressRuleCorsAllowOrigins;
    /**
     * The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
     */
    exposeHeaders?: string[];
    /**
     * An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
     */
    maxAge?: string;
}

export interface AppSpecIngressRuleCorsAllowOrigins {
    /**
     * Exact string match.
     */
    exact?: string;
    /**
     * Prefix-based match.
     *
     * @deprecated Deprecated
     */
    prefix?: string;
    /**
     * RE2 style regex-based match.
     */
    regex?: string;
}

export interface AppSpecIngressRuleMatch {
    path?: outputs.AppSpecIngressRuleMatchPath;
}

export interface AppSpecIngressRuleMatchPath {
    prefix: string;
}

export interface AppSpecIngressRuleRedirect {
    authority?: string;
    port?: number;
    redirectCode?: number;
    scheme?: string;
    uri?: string;
}

export interface AppSpecJob {
    /**
     * Alert policies for the app component
     */
    alerts?: outputs.AppSpecJobAlert[];
    /**
     * An optional build command to run while building this component from source.
     */
    buildCommand?: string;
    /**
     * The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
     */
    dockerfilePath?: string;
    /**
     * An environment slug describing the type of this app.
     */
    environmentSlug?: string;
    envs?: outputs.AppSpecJobEnv[];
    git?: outputs.AppSpecJobGit;
    github?: outputs.AppSpecJobGithub;
    gitlab?: outputs.AppSpecJobGitlab;
    image?: outputs.AppSpecJobImage;
    /**
     * The amount of instances that this component should be scaled to.
     */
    instanceCount?: number;
    /**
     * The instance size to use for this component.
     */
    instanceSizeSlug?: string;
    /**
     * The type of job and when it will be run during the deployment process.
     */
    kind?: string;
    /**
     * Logs
     */
    logDestinations?: outputs.AppSpecJobLogDestination[];
    /**
     * The name of the component
     */
    name: string;
    /**
     * An optional run command to override the component's default.
     */
    runCommand?: string;
    /**
     * An optional path to the working directory to use for the build.
     */
    sourceDir?: string;
}

export interface AppSpecJobAlert {
    disabled?: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface AppSpecJobEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecJobGit {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * The clone URL of the repo.
     */
    repoCloneUrl?: string;
}

export interface AppSpecJobGithub {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecJobGitlab {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecJobImage {
    /**
     * Configures automatically deploying images pushed to DOCR.
     */
    deployOnPushes?: outputs.AppSpecJobImageDeployOnPush[];
    /**
     * The registry name. Must be left empty for the DOCR registry type.
     */
    registry?: string;
    /**
     * Access credentials for third-party registries
     */
    registryCredentials?: string;
    /**
     * The registry type.
     */
    registryType: string;
    /**
     * The repository name.
     */
    repository: string;
    /**
     * The repository tag. Defaults to latest if not provided.
     */
    tag?: string;
}

export interface AppSpecJobImageDeployOnPush {
    /**
     * Whether to automatically deploy images pushed to DOCR.
     */
    enabled?: boolean;
}

export interface AppSpecJobLogDestination {
    /**
     * Datadog configuration.
     */
    datadog?: outputs.AppSpecJobLogDestinationDatadog;
    /**
     * Logtail configuration.
     */
    logtail?: outputs.AppSpecJobLogDestinationLogtail;
    /**
     * Name of the log destination
     */
    name: string;
    /**
     * Papertrail configuration.
     */
    papertrail?: outputs.AppSpecJobLogDestinationPapertrail;
}

export interface AppSpecJobLogDestinationDatadog {
    /**
     * Datadog API key.
     */
    apiKey: string;
    /**
     * Datadog HTTP log intake endpoint.
     */
    endpoint?: string;
}

export interface AppSpecJobLogDestinationLogtail {
    /**
     * Logtail token.
     */
    token: string;
}

export interface AppSpecJobLogDestinationPapertrail {
    /**
     * Papertrail syslog endpoint.
     */
    endpoint: string;
}

export interface AppSpecService {
    /**
     * Alert policies for the app component
     */
    alerts?: outputs.AppSpecServiceAlert[];
    autoscaling?: outputs.AppSpecServiceAutoscaling;
    /**
     * An optional build command to run while building this component from source.
     */
    buildCommand?: string;
    /**
     * @deprecated Deprecated
     */
    cors?: outputs.AppSpecServiceCors;
    /**
     * The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
     */
    dockerfilePath?: string;
    /**
     * An environment slug describing the type of this app.
     */
    environmentSlug?: string;
    envs?: outputs.AppSpecServiceEnv[];
    git?: outputs.AppSpecServiceGit;
    github?: outputs.AppSpecServiceGithub;
    gitlab?: outputs.AppSpecServiceGitlab;
    healthCheck?: outputs.AppSpecServiceHealthCheck;
    /**
     * The internal port on which this service's run command will listen.
     */
    httpPort: number;
    image?: outputs.AppSpecServiceImage;
    /**
     * The amount of instances that this component should be scaled to.
     */
    instanceCount?: number;
    /**
     * The instance size to use for this component.
     */
    instanceSizeSlug?: string;
    internalPorts: number[];
    /**
     * Logs
     */
    logDestinations?: outputs.AppSpecServiceLogDestination[];
    /**
     * The name of the component
     */
    name: string;
    /**
     * @deprecated Deprecated
     */
    routes?: outputs.AppSpecServiceRoute[];
    /**
     * An optional run command to override the component's default.
     */
    runCommand: string;
    /**
     * An optional path to the working directory to use for the build.
     */
    sourceDir?: string;
}

export interface AppSpecServiceAlert {
    disabled?: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface AppSpecServiceAutoscaling {
    /**
     * The maximum amount of instances for this component. Must be more than min_instance_count.
     */
    maxInstanceCount: number;
    /**
     * The metrics that the component is scaled on.
     */
    metrics: outputs.AppSpecServiceAutoscalingMetrics;
    /**
     * The minimum amount of instances for this component. Must be less than max_instance_count.
     */
    minInstanceCount: number;
}

export interface AppSpecServiceAutoscalingMetrics {
    /**
     * Settings for scaling the component based on CPU utilization.
     */
    cpu?: outputs.AppSpecServiceAutoscalingMetricsCpu;
}

export interface AppSpecServiceAutoscalingMetricsCpu {
    /**
     * The average target CPU utilization for the component.
     */
    percent: number;
}

export interface AppSpecServiceCors {
    /**
     * Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
     */
    allowCredentials?: boolean;
    /**
     * The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
     */
    allowHeaders?: string[];
    /**
     * The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
     */
    allowMethods?: string[];
    /**
     * The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
     */
    allowOrigins?: outputs.AppSpecServiceCorsAllowOrigins;
    /**
     * The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
     */
    exposeHeaders?: string[];
    /**
     * An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
     */
    maxAge?: string;
}

export interface AppSpecServiceCorsAllowOrigins {
    /**
     * Exact string match.
     */
    exact?: string;
    /**
     * Prefix-based match.
     *
     * @deprecated Deprecated
     */
    prefix?: string;
    /**
     * RE2 style regex-based match.
     */
    regex?: string;
}

export interface AppSpecServiceEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecServiceGit {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * The clone URL of the repo.
     */
    repoCloneUrl?: string;
}

export interface AppSpecServiceGithub {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecServiceGitlab {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecServiceHealthCheck {
    /**
     * The number of failed health checks before considered unhealthy.
     */
    failureThreshold?: number;
    /**
     * The route path used for the HTTP health check ping.
     */
    httpPath?: string;
    /**
     * The number of seconds to wait before beginning health checks.
     */
    initialDelaySeconds?: number;
    /**
     * The number of seconds to wait between health checks.
     */
    periodSeconds?: number;
    /**
     * The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
     */
    port?: number;
    /**
     * The number of successful health checks before considered healthy.
     */
    successThreshold?: number;
    /**
     * The number of seconds after which the check times out.
     */
    timeoutSeconds?: number;
}

export interface AppSpecServiceImage {
    /**
     * Configures automatically deploying images pushed to DOCR.
     */
    deployOnPushes?: outputs.AppSpecServiceImageDeployOnPush[];
    /**
     * The registry name. Must be left empty for the DOCR registry type.
     */
    registry?: string;
    /**
     * Access credentials for third-party registries
     */
    registryCredentials?: string;
    /**
     * The registry type.
     */
    registryType: string;
    /**
     * The repository name.
     */
    repository: string;
    /**
     * The repository tag. Defaults to latest if not provided.
     */
    tag?: string;
}

export interface AppSpecServiceImageDeployOnPush {
    /**
     * Whether to automatically deploy images pushed to DOCR.
     */
    enabled?: boolean;
}

export interface AppSpecServiceLogDestination {
    /**
     * Datadog configuration.
     */
    datadog?: outputs.AppSpecServiceLogDestinationDatadog;
    /**
     * Logtail configuration.
     */
    logtail?: outputs.AppSpecServiceLogDestinationLogtail;
    /**
     * Name of the log destination
     */
    name: string;
    /**
     * Papertrail configuration.
     */
    papertrail?: outputs.AppSpecServiceLogDestinationPapertrail;
}

export interface AppSpecServiceLogDestinationDatadog {
    /**
     * Datadog API key.
     */
    apiKey: string;
    /**
     * Datadog HTTP log intake endpoint.
     */
    endpoint?: string;
}

export interface AppSpecServiceLogDestinationLogtail {
    /**
     * Logtail token.
     */
    token: string;
}

export interface AppSpecServiceLogDestinationPapertrail {
    /**
     * Papertrail syslog endpoint.
     */
    endpoint: string;
}

export interface AppSpecServiceRoute {
    /**
     * Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app.
     */
    path?: string;
    /**
     * An optional flag to preserve the path that is forwarded to the backend service.
     */
    preservePathPrefix?: boolean;
}

export interface AppSpecStaticSite {
    /**
     * An optional build command to run while building this component from source.
     */
    buildCommand?: string;
    /**
     * The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
     */
    catchallDocument?: string;
    /**
     * @deprecated Deprecated
     */
    cors?: outputs.AppSpecStaticSiteCors;
    /**
     * The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
     */
    dockerfilePath?: string;
    /**
     * An environment slug describing the type of this app.
     */
    environmentSlug?: string;
    envs?: outputs.AppSpecStaticSiteEnv[];
    /**
     * The name of the error document to use when serving this static site.
     */
    errorDocument?: string;
    git?: outputs.AppSpecStaticSiteGit;
    github?: outputs.AppSpecStaticSiteGithub;
    gitlab?: outputs.AppSpecStaticSiteGitlab;
    /**
     * The name of the index document to use when serving this static site.
     */
    indexDocument?: string;
    /**
     * The name of the component
     */
    name: string;
    /**
     * An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
     */
    outputDir?: string;
    /**
     * @deprecated Deprecated
     */
    routes?: outputs.AppSpecStaticSiteRoute[];
    /**
     * An optional path to the working directory to use for the build.
     */
    sourceDir?: string;
}

export interface AppSpecStaticSiteCors {
    /**
     * Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
     */
    allowCredentials?: boolean;
    /**
     * The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
     */
    allowHeaders?: string[];
    /**
     * The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
     */
    allowMethods?: string[];
    /**
     * The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
     */
    allowOrigins?: outputs.AppSpecStaticSiteCorsAllowOrigins;
    /**
     * The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
     */
    exposeHeaders?: string[];
    /**
     * An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
     */
    maxAge?: string;
}

export interface AppSpecStaticSiteCorsAllowOrigins {
    /**
     * Exact string match.
     */
    exact?: string;
    /**
     * Prefix-based match.
     *
     * @deprecated Deprecated
     */
    prefix?: string;
    /**
     * RE2 style regex-based match.
     */
    regex?: string;
}

export interface AppSpecStaticSiteEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecStaticSiteGit {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * The clone URL of the repo.
     */
    repoCloneUrl?: string;
}

export interface AppSpecStaticSiteGithub {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecStaticSiteGitlab {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecStaticSiteRoute {
    /**
     * Path specifies an route by HTTP path prefix. Paths must start with / and must be unique within the app.
     */
    path?: string;
    /**
     * An optional flag to preserve the path that is forwarded to the backend service.
     */
    preservePathPrefix?: boolean;
}

export interface AppSpecWorker {
    /**
     * Alert policies for the app component
     */
    alerts?: outputs.AppSpecWorkerAlert[];
    /**
     * An optional build command to run while building this component from source.
     */
    buildCommand?: string;
    /**
     * The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
     */
    dockerfilePath?: string;
    /**
     * An environment slug describing the type of this app.
     */
    environmentSlug?: string;
    envs?: outputs.AppSpecWorkerEnv[];
    git?: outputs.AppSpecWorkerGit;
    github?: outputs.AppSpecWorkerGithub;
    gitlab?: outputs.AppSpecWorkerGitlab;
    image?: outputs.AppSpecWorkerImage;
    /**
     * The amount of instances that this component should be scaled to.
     */
    instanceCount?: number;
    /**
     * The instance size to use for this component.
     */
    instanceSizeSlug?: string;
    /**
     * Logs
     */
    logDestinations?: outputs.AppSpecWorkerLogDestination[];
    /**
     * The name of the component
     */
    name: string;
    /**
     * An optional run command to override the component's default.
     */
    runCommand?: string;
    /**
     * An optional path to the working directory to use for the build.
     */
    sourceDir?: string;
}

export interface AppSpecWorkerAlert {
    disabled?: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface AppSpecWorkerEnv {
    /**
     * The name of the environment variable.
     */
    key?: string;
    /**
     * The visibility scope of the environment variable.
     */
    scope?: string;
    /**
     * The type of the environment variable.
     */
    type: string;
    /**
     * The value of the environment variable.
     */
    value?: string;
}

export interface AppSpecWorkerGit {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * The clone URL of the repo.
     */
    repoCloneUrl?: string;
}

export interface AppSpecWorkerGithub {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecWorkerGitlab {
    /**
     * The name of the branch to use.
     */
    branch?: string;
    /**
     * Whether to automatically deploy new commits made to the repo
     */
    deployOnPush?: boolean;
    /**
     * The name of the repo in the format `owner/repo`.
     */
    repo?: string;
}

export interface AppSpecWorkerImage {
    /**
     * Configures automatically deploying images pushed to DOCR.
     */
    deployOnPushes?: outputs.AppSpecWorkerImageDeployOnPush[];
    /**
     * The registry name. Must be left empty for the DOCR registry type.
     */
    registry?: string;
    /**
     * Access credentials for third-party registries
     */
    registryCredentials?: string;
    /**
     * The registry type.
     */
    registryType: string;
    /**
     * The repository name.
     */
    repository: string;
    /**
     * The repository tag. Defaults to latest if not provided.
     */
    tag?: string;
}

export interface AppSpecWorkerImageDeployOnPush {
    /**
     * Whether to automatically deploy images pushed to DOCR.
     */
    enabled?: boolean;
}

export interface AppSpecWorkerLogDestination {
    /**
     * Datadog configuration.
     */
    datadog?: outputs.AppSpecWorkerLogDestinationDatadog;
    /**
     * Logtail configuration.
     */
    logtail?: outputs.AppSpecWorkerLogDestinationLogtail;
    /**
     * Name of the log destination
     */
    name: string;
    /**
     * Papertrail configuration.
     */
    papertrail?: outputs.AppSpecWorkerLogDestinationPapertrail;
}

export interface AppSpecWorkerLogDestinationDatadog {
    /**
     * Datadog API key.
     */
    apiKey: string;
    /**
     * Datadog HTTP log intake endpoint.
     */
    endpoint?: string;
}

export interface AppSpecWorkerLogDestinationLogtail {
    /**
     * Logtail token.
     */
    token: string;
}

export interface AppSpecWorkerLogDestinationPapertrail {
    /**
     * Papertrail syslog endpoint.
     */
    endpoint: string;
}

export interface AppTimeouts {
    create?: string;
}

export interface CustomImageTimeouts {
    create?: string;
}

export interface DatabaseClusterBackupRestore {
    backupCreatedAt?: string;
    databaseName: string;
}

export interface DatabaseClusterMaintenanceWindow {
    day: string;
    hour: string;
}

export interface DatabaseClusterTimeouts {
    create?: string;
}

export interface DatabaseFirewallRule {
    createdAt: string;
    type: string;
    uuid: string;
    value: string;
}

export interface DatabaseKafkaTopicConfig {
    cleanupPolicy: string;
    compressionType: string;
    deleteRetentionMs: string;
    fileDeleteDelayMs: string;
    flushMessages: string;
    flushMs: string;
    indexIntervalBytes: string;
    maxCompactionLagMs: string;
    maxMessageBytes: string;
    messageDownConversionEnable: boolean;
    messageFormatVersion: string;
    messageTimestampDifferenceMaxMs: string;
    messageTimestampType: string;
    minCleanableDirtyRatio: number;
    minCompactionLagMs: string;
    minInsyncReplicas?: number;
    preallocate: boolean;
    retentionBytes: string;
    retentionMs: string;
    segmentBytes: string;
    segmentIndexBytes: string;
    segmentJitterMs: string;
    segmentMs: string;
}

export interface DatabasePostgresqlConfigPgbouncer {
    autodbIdleTimeout: number;
    autodbMaxDbConnections: number;
    autodbPoolMode: string;
    autodbPoolSize: number;
    ignoreStartupParameters: string[];
    minPoolSize: number;
    serverIdleTimeout: number;
    serverLifetime: number;
    serverResetQueryAlways: boolean;
}

export interface DatabasePostgresqlConfigTimescaledb {
    timescaledb?: number;
}

export interface DatabaseUserSetting {
    acls?: outputs.DatabaseUserSettingAcl[];
}

export interface DatabaseUserSettingAcl {
    id: string;
    permission: string;
    topic: string;
}

export interface DropletTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FirewallInboundRule {
    portRange?: string;
    protocol: string;
    sourceAddresses?: string[];
    sourceDropletIds?: number[];
    sourceKubernetesIds?: string[];
    sourceLoadBalancerUids?: string[];
    sourceTags?: string[];
}

export interface FirewallOutboundRule {
    destinationAddresses?: string[];
    destinationDropletIds?: number[];
    destinationKubernetesIds?: string[];
    destinationLoadBalancerUids?: string[];
    destinationTags?: string[];
    portRange?: string;
    protocol: string;
}

export interface FirewallPendingChange {
    dropletId: number;
    removing: boolean;
    status: string;
}

export interface GetAppDedicatedIp {
    /**
     * The ID of the dedicated egress IP.
     */
    id: string;
    /**
     * The IP address of the dedicated egress IP.
     */
    ip: string;
    /**
     * The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
     */
    status: string;
}

export interface GetAppSpec {
    alerts: outputs.GetAppSpecAlert[];
    databases: outputs.GetAppSpecDatabase[];
    domain: outputs.GetAppSpecDomain[];
    domains: string[];
    egresses: outputs.GetAppSpecEgress[];
    envs: outputs.GetAppSpecEnv[];
    features: string[];
    functions: outputs.GetAppSpecFunction[];
    ingresses: outputs.GetAppSpecIngress[];
    jobs: outputs.GetAppSpecJob[];
    name: string;
    region: string;
    services: outputs.GetAppSpecService[];
    staticSites: outputs.GetAppSpecStaticSite[];
    workers: outputs.GetAppSpecWorker[];
}

export interface GetAppSpecAlert {
    disabled: boolean;
    rule: string;
}

export interface GetAppSpecDatabase {
    clusterName: string;
    dbName: string;
    dbUser: string;
    engine: string;
    name: string;
    production: boolean;
    version: string;
}

export interface GetAppSpecDomain {
    name: string;
    type: string;
    wildcard: boolean;
    zone: string;
}

export interface GetAppSpecEgress {
    type: string;
}

export interface GetAppSpecEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecFunction {
    alerts: outputs.GetAppSpecFunctionAlert[];
    cors: outputs.GetAppSpecFunctionCor[];
    envs: outputs.GetAppSpecFunctionEnv[];
    githubs: outputs.GetAppSpecFunctionGithub[];
    gitlabs: outputs.GetAppSpecFunctionGitlab[];
    gits: outputs.GetAppSpecFunctionGit[];
    logDestinations: outputs.GetAppSpecFunctionLogDestination[];
    name: string;
    routes: outputs.GetAppSpecFunctionRoute[];
    sourceDir: string;
}

export interface GetAppSpecFunctionAlert {
    disabled: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface GetAppSpecFunctionCor {
    allowCredentials: boolean;
    allowHeaders: string[];
    allowMethods: string[];
    allowOrigins: outputs.GetAppSpecFunctionCorAllowOrigin[];
    exposeHeaders: string[];
    maxAge: string;
}

export interface GetAppSpecFunctionCorAllowOrigin {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAppSpecFunctionEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecFunctionGit {
    branch: string;
    repoCloneUrl: string;
}

export interface GetAppSpecFunctionGithub {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecFunctionGitlab {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecFunctionLogDestination {
    datadogs: outputs.GetAppSpecFunctionLogDestinationDatadog[];
    logtails: outputs.GetAppSpecFunctionLogDestinationLogtail[];
    name: string;
    papertrails: outputs.GetAppSpecFunctionLogDestinationPapertrail[];
}

export interface GetAppSpecFunctionLogDestinationDatadog {
    apiKey: string;
    endpoint: string;
}

export interface GetAppSpecFunctionLogDestinationLogtail {
    token: string;
}

export interface GetAppSpecFunctionLogDestinationPapertrail {
    endpoint: string;
}

export interface GetAppSpecFunctionRoute {
    path: string;
    preservePathPrefix: boolean;
}

export interface GetAppSpecIngress {
    rules: outputs.GetAppSpecIngressRule[];
}

export interface GetAppSpecIngressRule {
    components: outputs.GetAppSpecIngressRuleComponent[];
    cors: outputs.GetAppSpecIngressRuleCor[];
    matches: outputs.GetAppSpecIngressRuleMatch[];
    redirects: outputs.GetAppSpecIngressRuleRedirect[];
}

export interface GetAppSpecIngressRuleComponent {
    name: string;
    preservePathPrefix: boolean;
    rewrite: string;
}

export interface GetAppSpecIngressRuleCor {
    allowCredentials: boolean;
    allowHeaders: string[];
    allowMethods: string[];
    allowOrigins: outputs.GetAppSpecIngressRuleCorAllowOrigin[];
    exposeHeaders: string[];
    maxAge: string;
}

export interface GetAppSpecIngressRuleCorAllowOrigin {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAppSpecIngressRuleMatch {
    paths: outputs.GetAppSpecIngressRuleMatchPath[];
}

export interface GetAppSpecIngressRuleMatchPath {
    prefix: string;
}

export interface GetAppSpecIngressRuleRedirect {
    authority: string;
    port: number;
    redirectCode: number;
    scheme: string;
    uri: string;
}

export interface GetAppSpecJob {
    alerts: outputs.GetAppSpecJobAlert[];
    buildCommand: string;
    dockerfilePath: string;
    environmentSlug: string;
    envs: outputs.GetAppSpecJobEnv[];
    githubs: outputs.GetAppSpecJobGithub[];
    gitlabs: outputs.GetAppSpecJobGitlab[];
    gits: outputs.GetAppSpecJobGit[];
    images: outputs.GetAppSpecJobImage[];
    instanceCount: number;
    instanceSizeSlug: string;
    kind: string;
    logDestinations: outputs.GetAppSpecJobLogDestination[];
    name: string;
    runCommand: string;
    sourceDir: string;
}

export interface GetAppSpecJobAlert {
    disabled: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface GetAppSpecJobEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecJobGit {
    branch: string;
    repoCloneUrl: string;
}

export interface GetAppSpecJobGithub {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecJobGitlab {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecJobImage {
    deployOnPushes: outputs.GetAppSpecJobImageDeployOnPush[];
    registry: string;
    registryCredentials: string;
    registryType: string;
    repository: string;
    tag: string;
}

export interface GetAppSpecJobImageDeployOnPush {
    enabled: boolean;
}

export interface GetAppSpecJobLogDestination {
    datadogs: outputs.GetAppSpecJobLogDestinationDatadog[];
    logtails: outputs.GetAppSpecJobLogDestinationLogtail[];
    name: string;
    papertrails: outputs.GetAppSpecJobLogDestinationPapertrail[];
}

export interface GetAppSpecJobLogDestinationDatadog {
    apiKey: string;
    endpoint: string;
}

export interface GetAppSpecJobLogDestinationLogtail {
    token: string;
}

export interface GetAppSpecJobLogDestinationPapertrail {
    endpoint: string;
}

export interface GetAppSpecService {
    alerts: outputs.GetAppSpecServiceAlert[];
    autoscalings: outputs.GetAppSpecServiceAutoscaling[];
    buildCommand: string;
    cors: outputs.GetAppSpecServiceCor[];
    dockerfilePath: string;
    environmentSlug: string;
    envs: outputs.GetAppSpecServiceEnv[];
    githubs: outputs.GetAppSpecServiceGithub[];
    gitlabs: outputs.GetAppSpecServiceGitlab[];
    gits: outputs.GetAppSpecServiceGit[];
    healthChecks: outputs.GetAppSpecServiceHealthCheck[];
    httpPort: number;
    images: outputs.GetAppSpecServiceImage[];
    instanceCount: number;
    instanceSizeSlug: string;
    internalPorts: number[];
    logDestinations: outputs.GetAppSpecServiceLogDestination[];
    name: string;
    routes: outputs.GetAppSpecServiceRoute[];
    runCommand: string;
    sourceDir: string;
}

export interface GetAppSpecServiceAlert {
    disabled: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface GetAppSpecServiceAutoscaling {
    maxInstanceCount: number;
    metrics: outputs.GetAppSpecServiceAutoscalingMetric[];
    minInstanceCount: number;
}

export interface GetAppSpecServiceAutoscalingMetric {
    cpus: outputs.GetAppSpecServiceAutoscalingMetricCpus[];
}

export interface GetAppSpecServiceAutoscalingMetricCpus {
    percent: number;
}

export interface GetAppSpecServiceCor {
    allowCredentials: boolean;
    allowHeaders: string[];
    allowMethods: string[];
    allowOrigins: outputs.GetAppSpecServiceCorAllowOrigin[];
    exposeHeaders: string[];
    maxAge: string;
}

export interface GetAppSpecServiceCorAllowOrigin {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAppSpecServiceEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecServiceGit {
    branch: string;
    repoCloneUrl: string;
}

export interface GetAppSpecServiceGithub {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecServiceGitlab {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecServiceHealthCheck {
    failureThreshold: number;
    httpPath: string;
    initialDelaySeconds: number;
    periodSeconds: number;
    port: number;
    successThreshold: number;
    timeoutSeconds: number;
}

export interface GetAppSpecServiceImage {
    deployOnPushes: outputs.GetAppSpecServiceImageDeployOnPush[];
    registry: string;
    registryCredentials: string;
    registryType: string;
    repository: string;
    tag: string;
}

export interface GetAppSpecServiceImageDeployOnPush {
    enabled: boolean;
}

export interface GetAppSpecServiceLogDestination {
    datadogs: outputs.GetAppSpecServiceLogDestinationDatadog[];
    logtails: outputs.GetAppSpecServiceLogDestinationLogtail[];
    name: string;
    papertrails: outputs.GetAppSpecServiceLogDestinationPapertrail[];
}

export interface GetAppSpecServiceLogDestinationDatadog {
    apiKey: string;
    endpoint: string;
}

export interface GetAppSpecServiceLogDestinationLogtail {
    token: string;
}

export interface GetAppSpecServiceLogDestinationPapertrail {
    endpoint: string;
}

export interface GetAppSpecServiceRoute {
    path: string;
    preservePathPrefix: boolean;
}

export interface GetAppSpecStaticSite {
    buildCommand: string;
    catchallDocument: string;
    cors: outputs.GetAppSpecStaticSiteCor[];
    dockerfilePath: string;
    environmentSlug: string;
    envs: outputs.GetAppSpecStaticSiteEnv[];
    errorDocument: string;
    githubs: outputs.GetAppSpecStaticSiteGithub[];
    gitlabs: outputs.GetAppSpecStaticSiteGitlab[];
    gits: outputs.GetAppSpecStaticSiteGit[];
    indexDocument: string;
    name: string;
    outputDir: string;
    routes: outputs.GetAppSpecStaticSiteRoute[];
    sourceDir: string;
}

export interface GetAppSpecStaticSiteCor {
    allowCredentials: boolean;
    allowHeaders: string[];
    allowMethods: string[];
    allowOrigins: outputs.GetAppSpecStaticSiteCorAllowOrigin[];
    exposeHeaders: string[];
    maxAge: string;
}

export interface GetAppSpecStaticSiteCorAllowOrigin {
    exact: string;
    prefix: string;
    regex: string;
}

export interface GetAppSpecStaticSiteEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecStaticSiteGit {
    branch: string;
    repoCloneUrl: string;
}

export interface GetAppSpecStaticSiteGithub {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecStaticSiteGitlab {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecStaticSiteRoute {
    path: string;
    preservePathPrefix: boolean;
}

export interface GetAppSpecWorker {
    alerts: outputs.GetAppSpecWorkerAlert[];
    buildCommand: string;
    dockerfilePath: string;
    environmentSlug: string;
    envs: outputs.GetAppSpecWorkerEnv[];
    githubs: outputs.GetAppSpecWorkerGithub[];
    gitlabs: outputs.GetAppSpecWorkerGitlab[];
    gits: outputs.GetAppSpecWorkerGit[];
    images: outputs.GetAppSpecWorkerImage[];
    instanceCount: number;
    instanceSizeSlug: string;
    logDestinations: outputs.GetAppSpecWorkerLogDestination[];
    name: string;
    runCommand: string;
    sourceDir: string;
}

export interface GetAppSpecWorkerAlert {
    disabled: boolean;
    operator: string;
    rule: string;
    value: number;
    window: string;
}

export interface GetAppSpecWorkerEnv {
    key: string;
    scope: string;
    type: string;
    value: string;
}

export interface GetAppSpecWorkerGit {
    branch: string;
    repoCloneUrl: string;
}

export interface GetAppSpecWorkerGithub {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecWorkerGitlab {
    branch: string;
    deployOnPush: boolean;
    repo: string;
}

export interface GetAppSpecWorkerImage {
    deployOnPushes: outputs.GetAppSpecWorkerImageDeployOnPush[];
    registry: string;
    registryCredentials: string;
    registryType: string;
    repository: string;
    tag: string;
}

export interface GetAppSpecWorkerImageDeployOnPush {
    enabled: boolean;
}

export interface GetAppSpecWorkerLogDestination {
    datadogs: outputs.GetAppSpecWorkerLogDestinationDatadog[];
    logtails: outputs.GetAppSpecWorkerLogDestinationLogtail[];
    name: string;
    papertrails: outputs.GetAppSpecWorkerLogDestinationPapertrail[];
}

export interface GetAppSpecWorkerLogDestinationDatadog {
    apiKey: string;
    endpoint: string;
}

export interface GetAppSpecWorkerLogDestinationLogtail {
    token: string;
}

export interface GetAppSpecWorkerLogDestinationPapertrail {
    endpoint: string;
}

export interface GetDatabaseClusterMaintenanceWindow {
    day: string;
    hour: string;
}

export interface GetDatabaseUserSetting {
    acls: outputs.GetDatabaseUserSettingAcl[];
}

export interface GetDatabaseUserSettingAcl {
    id: string;
    permission: string;
    topic: string;
}

export interface GetDomainsDomain {
    name: string;
    ttl: number;
    urn: string;
}

export interface GetDomainsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetDomainsSort {
    direction?: string;
    key: string;
}

export interface GetDropletsDroplet {
    backups: boolean;
    createdAt: string;
    disk: number;
    id: number;
    image: string;
    ipv4Address: string;
    ipv4AddressPrivate: string;
    ipv6: boolean;
    ipv6Address: string;
    ipv6AddressPrivate: string;
    locked: boolean;
    memory: number;
    monitoring: boolean;
    name: string;
    priceHourly: number;
    priceMonthly: number;
    privateNetworking: boolean;
    region: string;
    size: string;
    status: string;
    tags: string[];
    urn: string;
    vcpus: number;
    volumeIds: string[];
    vpcUuid: string;
}

export interface GetDropletsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetDropletsSort {
    direction?: string;
    key: string;
}

export interface GetFirewallInboundRule {
    portRange?: string;
    protocol: string;
    sourceAddresses?: string[];
    sourceDropletIds?: number[];
    sourceKubernetesIds?: string[];
    sourceLoadBalancerUids?: string[];
    sourceTags?: string[];
}

export interface GetFirewallOutboundRule {
    destinationAddresses?: string[];
    destinationDropletIds?: number[];
    destinationKubernetesIds?: string[];
    destinationLoadBalancerUids?: string[];
    destinationTags?: string[];
    portRange?: string;
    protocol: string;
}

export interface GetFirewallPendingChange {
    dropletId: number;
    removing: boolean;
    status: string;
}

export interface GetImagesFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetImagesImage {
    created: string;
    description: string;
    distribution: string;
    errorMessage: string;
    id: number;
    image: string;
    minDiskSize: number;
    name: string;
    private: boolean;
    regions: string[];
    sizeGigabytes: number;
    slug: string;
    status: string;
    tags: string[];
    type: string;
}

export interface GetImagesSort {
    direction?: string;
    key: string;
}

export interface GetKubernetesClusterKubeConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    expiresAt: string;
    host: string;
    rawConfig: string;
    token: string;
}

export interface GetKubernetesClusterMaintenancePolicy {
    day: string;
    duration: string;
    startTime: string;
}

export interface GetKubernetesClusterNodePool {
    actualNodeCount: number;
    autoScale: boolean;
    id: string;
    labels: {[key: string]: string};
    maxNodes: number;
    minNodes: number;
    name: string;
    nodeCount: number;
    nodes: outputs.GetKubernetesClusterNodePoolNode[];
    size: string;
    tags: string[];
    taints: outputs.GetKubernetesClusterNodePoolTaint[];
}

export interface GetKubernetesClusterNodePoolNode {
    createdAt: string;
    dropletId: string;
    id: string;
    name: string;
    status: string;
    updatedAt: string;
}

export interface GetKubernetesClusterNodePoolTaint {
    effect: string;
    key: string;
    value: string;
}

export interface GetLoadbalancerDomain {
    certificateId: string;
    certificateName: string;
    isManaged: boolean;
    name: string;
    sslValidationErrorReasons: string[];
    verificationErrorReasons: string[];
}

export interface GetLoadbalancerFirewall {
    allows: string[];
    denies: string[];
}

export interface GetLoadbalancerForwardingRule {
    certificateId: string;
    certificateName: string;
    entryPort: number;
    entryProtocol: string;
    targetPort: number;
    targetProtocol: string;
    tlsPassthrough: boolean;
}

export interface GetLoadbalancerGlbSetting {
    cdns: outputs.GetLoadbalancerGlbSettingCdn[];
    failoverThreshold: number;
    regionPriorities: {[key: string]: number};
    targetPort: number;
    targetProtocol: string;
}

export interface GetLoadbalancerGlbSettingCdn {
    isEnabled: boolean;
}

export interface GetLoadbalancerHealthcheck {
    checkIntervalSeconds: number;
    healthyThreshold: number;
    path: string;
    port: number;
    protocol: string;
    responseTimeoutSeconds: number;
    unhealthyThreshold: number;
}

export interface GetLoadbalancerStickySession {
    cookieName: string;
    cookieTtlSeconds: number;
    type: string;
}

export interface GetProjectsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetProjectsProject {
    createdAt: string;
    description: string;
    environment: string;
    id: string;
    isDefault: boolean;
    name: string;
    ownerId: number;
    ownerUuid: string;
    purpose: string;
    resources: string[];
    updatedAt: string;
}

export interface GetProjectsSort {
    direction?: string;
    key: string;
}

export interface GetRecordsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetRecordsRecord {
    domain: string;
    flags: number;
    id: number;
    name: string;
    port: number;
    priority: number;
    tag: string;
    ttl: number;
    type: string;
    value: string;
    weight: number;
}

export interface GetRecordsSort {
    direction?: string;
    key: string;
}

export interface GetRegionsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetRegionsRegion {
    available: boolean;
    features: string[];
    name: string;
    sizes: string[];
    slug: string;
}

export interface GetRegionsSort {
    direction?: string;
    key: string;
}

export interface GetSizesFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetSizesSize {
    available: boolean;
    disk: number;
    memory: number;
    priceHourly: number;
    priceMonthly: number;
    regions: string[];
    slug: string;
    transfer: number;
    vcpus: number;
}

export interface GetSizesSort {
    direction?: string;
    key: string;
}

export interface GetSpacesBucketsBucket {
    bucketDomainName: string;
    endpoint: string;
    name: string;
    region: string;
    urn: string;
}

export interface GetSpacesBucketsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetSpacesBucketsSort {
    direction?: string;
    key: string;
}

export interface GetSshKeysFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetSshKeysSort {
    direction?: string;
    key: string;
}

export interface GetSshKeysSshKey {
    fingerprint: string;
    id: number;
    name: string;
    publicKey: string;
}

export interface GetTagsFilter {
    all?: boolean;
    key: string;
    matchBy?: string;
    values: string[];
}

export interface GetTagsSort {
    direction?: string;
    key: string;
}

export interface GetTagsTag {
    databasesCount: number;
    dropletsCount: number;
    imagesCount: number;
    name: string;
    totalResourceCount: number;
    volumeSnapshotsCount: number;
    volumesCount: number;
}

export interface KubernetesClusterKubeConfig {
    clientCertificate: string;
    clientKey: string;
    clusterCaCertificate: string;
    expiresAt: string;
    host: string;
    rawConfig: string;
    token: string;
}

export interface KubernetesClusterMaintenancePolicy {
    day: string;
    duration: string;
    startTime: string;
}

export interface KubernetesClusterNodePool {
    actualNodeCount: number;
    autoScale?: boolean;
    id: string;
    labels?: {[key: string]: string};
    maxNodes?: number;
    minNodes?: number;
    name: string;
    nodeCount?: number;
    nodes: outputs.KubernetesClusterNodePoolNode[];
    size: string;
    tags?: string[];
    taints?: outputs.KubernetesClusterNodePoolTaint[];
}

export interface KubernetesClusterNodePoolNode {
    createdAt: string;
    dropletId: string;
    id: string;
    name: string;
    status: string;
    updatedAt: string;
}

export interface KubernetesClusterNodePoolTaint {
    effect: string;
    key: string;
    value: string;
}

export interface KubernetesClusterTimeouts {
    create?: string;
}

export interface KubernetesNodePoolNode {
    createdAt: string;
    dropletId: string;
    id: string;
    name: string;
    status: string;
    updatedAt: string;
}

export interface KubernetesNodePoolTaint {
    effect: string;
    key: string;
    value: string;
}

export interface KubernetesNodePoolTimeouts {
    create?: string;
    delete?: string;
}

export interface LoadbalancerDomain {
    /**
     * name of certificate required for TLS handshaking
     */
    certificateName: string;
    /**
     * flag indicating if domain is managed by DigitalOcean
     */
    isManaged?: boolean;
    /**
     * domain name
     */
    name: string;
    /**
     * list of domain SSL validation errors
     */
    sslValidationErrorReasons: string[];
    /**
     * list of domain verification errors
     */
    verificationErrorReasons: string[];
}

export interface LoadbalancerFirewall {
    /**
     * the rules for ALLOWING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
     */
    allows?: string[];
    /**
     * the rules for DENYING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
     */
    denies?: string[];
}

export interface LoadbalancerForwardingRule {
    /**
     * @deprecated Deprecated
     */
    certificateId: string;
    certificateName: string;
    entryPort: number;
    entryProtocol: string;
    targetPort: number;
    targetProtocol: string;
    tlsPassthrough?: boolean;
}

export interface LoadbalancerGlbSettings {
    /**
     * CDN specific configurations
     */
    cdn?: outputs.LoadbalancerGlbSettingsCdn;
    /**
     * fail-over threshold
     */
    failoverThreshold?: number;
    /**
     * region priority map
     */
    regionPriorities?: {[key: string]: number};
    /**
     * target port rules
     */
    targetPort: number;
    /**
     * target protocol rules
     */
    targetProtocol: string;
}

export interface LoadbalancerGlbSettingsCdn {
    /**
     * cache enable flag
     */
    isEnabled?: boolean;
}

export interface LoadbalancerHealthcheck {
    checkIntervalSeconds?: number;
    healthyThreshold?: number;
    path?: string;
    port: number;
    protocol: string;
    responseTimeoutSeconds?: number;
    unhealthyThreshold?: number;
}

export interface LoadbalancerStickySessions {
    cookieName?: string;
    cookieTtlSeconds?: number;
    type?: string;
}

export interface MonitorAlertAlerts {
    /**
     * List of email addresses to sent notifications to
     */
    emails?: string[];
    slacks?: outputs.MonitorAlertAlertsSlack[];
}

export interface MonitorAlertAlertsSlack {
    /**
     * The Slack channel to send alerts to
     */
    channel: string;
    /**
     * The webhook URL for Slack
     */
    url: string;
}

export interface ProjectTimeouts {
    delete?: string;
}

export interface SpacesBucketCorsConfigurationCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    id?: string;
    maxAgeSeconds?: number;
}

export interface SpacesBucketCorsRule {
    /**
     * A list of headers that will be included in the CORS preflight request's Access-Control-Request-Headers. A header may contain one wildcard (e.g. x-amz-*).
     */
    allowedHeaders?: string[];
    /**
     * A list of HTTP methods (e.g. GET) which are allowed from the specified origin.
     */
    allowedMethods: string[];
    /**
     * A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
     */
    allowedOrigins: string[];
    maxAgeSeconds?: number;
}

export interface SpacesBucketLifecycleRule {
    abortIncompleteMultipartUploadDays?: number;
    enabled: boolean;
    expiration?: outputs.SpacesBucketLifecycleRuleExpiration;
    id: string;
    noncurrentVersionExpiration?: outputs.SpacesBucketLifecycleRuleNoncurrentVersionExpiration;
    prefix?: string;
}

export interface SpacesBucketLifecycleRuleExpiration {
    date?: string;
    days?: number;
    expiredObjectDeleteMarker?: boolean;
}

export interface SpacesBucketLifecycleRuleNoncurrentVersionExpiration {
    days?: number;
}

export interface SpacesBucketVersioning {
    enabled?: boolean;
}

export interface UptimeAlertNotification {
    /**
     * List of email addresses to sent notifications to
     */
    emails?: string[];
    slacks?: outputs.UptimeAlertNotificationSlack[];
}

export interface UptimeAlertNotificationSlack {
    /**
     * The Slack channel to send alerts to
     */
    channel: string;
    /**
     * The webhook URL for Slack
     */
    url: string;
}

export interface VpcPeeringTimeouts {
    create?: string;
    delete?: string;
}

export interface VpcTimeouts {
    delete?: string;
}

