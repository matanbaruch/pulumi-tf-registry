// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CeipTimeouts {
    create?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface CertificateAuthorityMicrosoft {
    /**
     * Microsoft CA server password
     */
    secret: pulumi.Input<string>;
    /**
     * Microsoft CA server URL
     */
    serverUrl: pulumi.Input<string>;
    /**
     * Microsoft CA server template name
     */
    templateName: pulumi.Input<string>;
    /**
     * Microsoft CA server username
     */
    username: pulumi.Input<string>;
}

export interface CertificateAuthorityOpenSsl {
    /**
     * OpenSSL CA domain name
     */
    commonName: pulumi.Input<string>;
    /**
     * ISO 3166 country code where company is legally registered
     */
    country: pulumi.Input<string>;
    /**
     * The city or locality where company is legally registered
     */
    locality: pulumi.Input<string>;
    /**
     * The name under which your company is known. The listed organization must be the legal registrant of the domain name in the certificate request.
     */
    organization: pulumi.Input<string>;
    /**
     * Organization with which the certificate is associated
     */
    organizationUnit: pulumi.Input<string>;
    /**
     * Full name (do not abbreviate) of the state, province, region, or territory where your company is legally registered.
     */
    state: pulumi.Input<string>;
}

export interface CertificateAuthorityTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface CertificateCertificate {
    certificateError: pulumi.Input<string>;
    domain: pulumi.Input<string>;
    expirationStatus: pulumi.Input<string>;
    issuedBy: pulumi.Input<string>;
    issuedTo: pulumi.Input<string>;
    keySize: pulumi.Input<string>;
    notAfter: pulumi.Input<string>;
    notBefore: pulumi.Input<string>;
    numberOfDaysToExpire: pulumi.Input<number>;
    pemEncoded: pulumi.Input<string>;
    publicKey: pulumi.Input<string>;
    publicKeyAlgorithm: pulumi.Input<string>;
    serialNumber: pulumi.Input<string>;
    signatureAlgorithm: pulumi.Input<string>;
    subject: pulumi.Input<string>;
    subjectAlternativeNames: pulumi.Input<pulumi.Input<string>[]>;
    thumbprint: pulumi.Input<string>;
    thumbprintAlgorithm: pulumi.Input<string>;
    version: pulumi.Input<string>;
}

export interface CertificateTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface ClusterHost {
    /**
     * Availability Zone Name. This is required while performing a stretched cluster expand operation
     */
    availabilityZoneName?: pulumi.Input<string>;
    /**
     * Host name of the ESXi host
     */
    hostName?: pulumi.Input<string>;
    /**
     * ID of the ESXi host in the free pool
     */
    id: pulumi.Input<string>;
    /**
     * IPv4 address of the ESXi host
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * License key for an ESXi host in the free pool. This is required except in cases where the ESXi host has already been licensed outside of the VMware Cloud Foundation system
     */
    licenseKey?: pulumi.Input<string>;
    /**
     * Password to authenticate to the ESXi host
     */
    password?: pulumi.Input<string>;
    /**
     * Serial number of the ESXi host
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * SSH thumbprint of the ESXi host
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * Username to authenticate to the ESXi host
     */
    username?: pulumi.Input<string>;
    /**
     * vmnic configuration for the ESXi host
     */
    vmnics?: pulumi.Input<pulumi.Input<inputs.ClusterHostVmnic>[]>;
}

export interface ClusterHostVmnic {
    /**
     * ESXI host vmnic ID to be associated with a VDS, once added to cluster
     */
    id: pulumi.Input<string>;
    /**
     * Uplink to be associated with vmnic
     */
    uplink?: pulumi.Input<string>;
    /**
     * Name of the VDS to associate with the ESXi host
     */
    vdsName?: pulumi.Input<string>;
}

export interface ClusterIpAddressPool {
    /**
     * Description of the IP address pool
     */
    description?: pulumi.Input<string>;
    /**
     * Ignore unavailable NSX cluster(s) during IP pool spec validation
     */
    ignoreUnavailableNsxCluster?: pulumi.Input<boolean>;
    /**
     * Providing only name of existing IP Address Pool reuses it, while providing a new name with subnets creates a new one
     */
    name: pulumi.Input<string>;
    /**
     * List of IP address pool subnet specifications
     */
    subnets?: pulumi.Input<pulumi.Input<inputs.ClusterIpAddressPoolSubnet>[]>;
}

export interface ClusterIpAddressPoolSubnet {
    /**
     * The subnet representation, contains the network address and the prefix length
     */
    cidr: pulumi.Input<string>;
    /**
     * The default gateway address of the network
     */
    gateway: pulumi.Input<string>;
    /**
     * List of the IP allocation ranges. At least 1 IP address range has to be specified
     */
    ipAddressPoolRanges?: pulumi.Input<pulumi.Input<inputs.ClusterIpAddressPoolSubnetIpAddressPoolRange>[]>;
}

export interface ClusterIpAddressPoolSubnetIpAddressPoolRange {
    /**
     * The last IP Address of the IP Address Range
     */
    end: pulumi.Input<string>;
    /**
     * The first IP Address of the IP Address Range
     */
    start: pulumi.Input<string>;
}

export interface ClusterNfsDatastore {
    /**
     * NFS datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * Shared directory path used for NFS based cluster creation
     */
    path: pulumi.Input<string>;
    /**
     * Readonly is used to identify whether to mount the directory as readOnly or not
     */
    readOnly: pulumi.Input<boolean>;
    /**
     * Fully qualified domain name or IP address of the NFS endpoint
     */
    serverName: pulumi.Input<string>;
    /**
     * User tag used to annotate NFS share
     */
    userTag?: pulumi.Input<string>;
}

export interface ClusterPersonalityTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface ClusterTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface ClusterVd {
    /**
     * Identifies if the vSphere distributed switch is used by NSX
     */
    isUsedByNsx?: pulumi.Input<boolean>;
    /**
     * vSphere Distributed Switch name
     */
    name: pulumi.Input<string>;
    /**
     * List of Network I/O Control Bandwidth Allocations for System Traffic based on shares, reservation, and limit, you can configure Network I/O Control to allocate certain amount of bandwidth for traffic generated by vSphere Fault Tolerance, iSCSI storage, vSphere vMotion, and so on. You can use Network I/O Control on a distributed switch to configure bandwidth allocation for the traffic  that is related to the main system features in vSphere
     */
    niocBandwidthAllocations?: pulumi.Input<pulumi.Input<inputs.ClusterVdNiocBandwidthAllocation>[]>;
    /**
     * List of portgroups to be associated with the vSphere Distributed Switch
     */
    portgroups?: pulumi.Input<pulumi.Input<inputs.ClusterVdPortgroup>[]>;
}

export interface ClusterVdNiocBandwidthAllocation {
    /**
     * The maximum allowed usage for a traffic class belonging to this resource pool per host physical NIC. The utilization of a traffic class will not exceed the specified limit even if there are available network resources. If this value is unset or set to -1 in an update operation, then there is no limit on the network resource usage (only bounded by available resource and shares). Units are in Mbits/sec
     */
    limit?: pulumi.Input<number>;
    /**
     * Amount of bandwidth resource that is guaranteed available to the host infrastructure traffic class. If the utilization is less than the reservation, the extra bandwidth is used for other host infrastructure traffic class types. Unit is Mbits/sec
     */
    reservation?: pulumi.Input<number>;
    /**
     * The number of shares allocated. Used to determine resource allocation in case of resource contention. This value is only set if level is set to custom. If level is not set to custom, this value is ignored. Therefore, only shares with custom values can be compared. There is no unit for this value. It is a relative measure based on the settings for other resource pools.
     */
    shares?: pulumi.Input<number>;
    /**
     * The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. If the shares value does not map to a predefined size, then the level is set as custom. One among: low, normal, high, custom
     */
    sharesLevel?: pulumi.Input<string>;
    /**
     * Host infrastructure traffic type. Example: management, faultTolerance, vmotion, virtualMachine, iSCSI, nfs, hbr, vsan, vdp etc.
     */
    type: pulumi.Input<string>;
}

export interface ClusterVdPortgroup {
    /**
     * List of active uplinks associated with portgroup. This is only supported for VxRail.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Port group name
     */
    name: pulumi.Input<string>;
    /**
     * Port group transport type, One among: VSAN, VMOTION, MANAGEMENT, PUBLIC, NFS, VREALIZE, ISCSI, EDGE_INFRA_OVERLAY_UPLINK
     */
    transportType: pulumi.Input<string>;
}

export interface ClusterVmfsDatastore {
    /**
     * VMFS datastore names used for VMFS on FC for cluster creation
     */
    datastoreNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterVsanDatastore {
    /**
     * vSAN datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * Enable vSAN deduplication and compression
     */
    dedupAndCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Enable vSAN ESA
     */
    esaEnabled?: pulumi.Input<boolean>;
    /**
     * Number of ESXi host failures to tolerate in the vSAN cluster. One of 0, 1, or 2.
     */
    failuresToTolerate?: pulumi.Input<number>;
    /**
     * vSAN license key to be used
     */
    licenseKey?: pulumi.Input<string>;
}

export interface ClusterVsanRemoteDatastoreCluster {
    /**
     * vSAN HCI Mesh remote datastore UUIDs
     */
    datastoreUuids: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterVsanStretchConfiguration {
    /**
     * The list of hosts that will go into the secondary fault domain
     */
    secondaryFdHosts?: pulumi.Input<pulumi.Input<inputs.ClusterVsanStretchConfigurationSecondaryFdHost>[]>;
    /**
     * Configuration for the witness host
     */
    witnessHost?: pulumi.Input<inputs.ClusterVsanStretchConfigurationWitnessHost>;
}

export interface ClusterVsanStretchConfigurationSecondaryFdHost {
    /**
     * Availability Zone Name. This is required while performing a stretched cluster expand operation
     */
    availabilityZoneName?: pulumi.Input<string>;
    /**
     * Host name of the ESXi host
     */
    hostName?: pulumi.Input<string>;
    /**
     * ID of the ESXi host in the free pool
     */
    id: pulumi.Input<string>;
    /**
     * IPv4 address of the ESXi host
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * License key for an ESXi host in the free pool. This is required except in cases where the ESXi host has already been licensed outside of the VMware Cloud Foundation system
     */
    licenseKey?: pulumi.Input<string>;
    /**
     * Password to authenticate to the ESXi host
     */
    password?: pulumi.Input<string>;
    /**
     * Serial number of the ESXi host
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * SSH thumbprint of the ESXi host
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * Username to authenticate to the ESXi host
     */
    username?: pulumi.Input<string>;
    /**
     * vmnic configuration for the ESXi host
     */
    vmnics?: pulumi.Input<pulumi.Input<inputs.ClusterVsanStretchConfigurationSecondaryFdHostVmnic>[]>;
}

export interface ClusterVsanStretchConfigurationSecondaryFdHostVmnic {
    /**
     * ESXI host vmnic ID to be associated with a VDS, once added to cluster
     */
    id: pulumi.Input<string>;
    /**
     * Uplink to be associated with vmnic
     */
    uplink?: pulumi.Input<string>;
    /**
     * Name of the VDS to associate with the ESXi host
     */
    vdsName?: pulumi.Input<string>;
}

export interface ClusterVsanStretchConfigurationWitnessHost {
    /**
     * Fully qualified domain name of the witness host. It should be routable on the vSAN network
     */
    fqdn: pulumi.Input<string>;
    /**
     * CIDR address for the witness host on the vSAN network
     */
    vsanCidr: pulumi.Input<string>;
    /**
     * IP address for the witness host on the vSAN network
     */
    vsanIp: pulumi.Input<string>;
}

export interface ClusterVvolDatastore {
    /**
     * vVol datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * UUID of the VASA storage container
     */
    storageContainerId: pulumi.Input<string>;
    /**
     * Type of the VASA storage protocol. One among: ISCSI, NFS, FC.
     */
    storageProtocolType: pulumi.Input<string>;
    /**
     * UUID of the VASA storage user
     */
    userId: pulumi.Input<string>;
    /**
     * UUID of the VASA storage provider
     */
    vasaProviderId: pulumi.Input<string>;
}

export interface CredentialsRotateCredential {
    /**
     * The type(s) of the account. One among: SSO, SSH, API, FTP, AUDIT
     */
    credentialType: pulumi.Input<string>;
    /**
     * The password for the account.
     */
    password?: pulumi.Input<string>;
    /**
     * The user name of the account.
     */
    userName: pulumi.Input<string>;
}

export interface CredentialsUpdateCredential {
    /**
     * The type(s) of the account. One among: SSO, SSH, API, FTP, AUDIT
     */
    credentialType: pulumi.Input<string>;
    /**
     * The password for the account.
     */
    password: pulumi.Input<string>;
    /**
     * The user name of the account.
     */
    userName: pulumi.Input<string>;
}

export interface CsrCsr {
    csrPem: pulumi.Input<string>;
    csrString: pulumi.Input<string>;
    resources: pulumi.Input<pulumi.Input<inputs.CsrCsrResource>[]>;
}

export interface CsrCsrResource {
    fqdn: pulumi.Input<string>;
    name: pulumi.Input<string>;
    resourceId: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface CsrTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface DomainCluster {
    /**
     * ID of the cluster image to be used with the cluster
     */
    clusterImageId?: pulumi.Input<string>;
    /**
     * EVC mode for new cluster, if needed. One among: INTEL_MEROM, INTEL_PENRYN, INTEL_NEALEM, INTEL_WESTMERE, INTEL_SANDYBRIDGE, INTEL_IVYBRIDGE, INTEL_HASWELL, INTEL_BROADWELL, INTEL_SKYLAKE, INTEL_CASCADELAKE, AMD_REV_E, AMD_REV_F, AMD_GREYHOUND_NO3DNOW, AMD_GREYHOUND, AMD_BULLDOZER, AMD_PILEDRIVER, AMD_STREAMROLLER, AMD_ZEN
     */
    evcMode?: pulumi.Input<string>;
    /**
     * VLAN ID use for NSX Geneve in the workload domain
     */
    geneveVlanId?: pulumi.Input<number>;
    /**
     * vSphere High Availability settings for the cluster
     */
    highAvailabilityEnabled?: pulumi.Input<boolean>;
    /**
     * List of ESXi host information from the free pool to consume in a workload domain
     */
    hosts: pulumi.Input<pulumi.Input<inputs.DomainClusterHost>[]>;
    /**
     * ID of the cluster
     */
    id?: pulumi.Input<string>;
    /**
     * Contains the parameters required to create or reuse an IP address pool. Omit for DHCP, provide name only to reuse existing IP Pool, if subnets are provided a new IP Pool will be created
     */
    ipAddressPool?: pulumi.Input<inputs.DomainClusterIpAddressPool>;
    /**
     * Status of the cluster if default or not
     */
    isDefault?: pulumi.Input<boolean>;
    /**
     * Status of the cluster if stretched or not
     */
    isStretched?: pulumi.Input<boolean>;
    /**
     * Name of the cluster to add to the workload domain
     */
    name: pulumi.Input<string>;
    /**
     * Cluster storage configuration for NFS
     */
    nfsDatastores?: pulumi.Input<pulumi.Input<inputs.DomainClusterNfsDatastore>[]>;
    /**
     * Name of the primary datastore
     */
    primaryDatastoreName?: pulumi.Input<string>;
    /**
     * Storage type of the primary datastore
     */
    primaryDatastoreType?: pulumi.Input<string>;
    /**
     * vSphere Distributed Switches to add to the cluster
     */
    vds: pulumi.Input<pulumi.Input<inputs.DomainClusterVd>[]>;
    /**
     * Cluster storage configuration for VMFS
     */
    vmfsDatastore?: pulumi.Input<inputs.DomainClusterVmfsDatastore>;
    /**
     * Cluster storage configuration for vSAN
     */
    vsanDatastore?: pulumi.Input<inputs.DomainClusterVsanDatastore>;
    /**
     * Cluster storage configuration for vSAN Remote Datastore
     */
    vsanRemoteDatastoreCluster?: pulumi.Input<inputs.DomainClusterVsanRemoteDatastoreCluster>;
    /**
     * Settings for stretched vSAN clusters
     */
    vsanStretchConfiguration?: pulumi.Input<inputs.DomainClusterVsanStretchConfiguration>;
    /**
     * Cluster storage configuration for VVOL
     */
    vvolDatastores?: pulumi.Input<pulumi.Input<inputs.DomainClusterVvolDatastore>[]>;
}

export interface DomainClusterHost {
    /**
     * Availability Zone Name. This is required while performing a stretched cluster expand operation
     */
    availabilityZoneName?: pulumi.Input<string>;
    /**
     * Host name of the ESXi host
     */
    hostName?: pulumi.Input<string>;
    /**
     * ID of the ESXi host in the free pool
     */
    id: pulumi.Input<string>;
    /**
     * IPv4 address of the ESXi host
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * License key for an ESXi host in the free pool. This is required except in cases where the ESXi host has already been licensed outside of the VMware Cloud Foundation system
     */
    licenseKey?: pulumi.Input<string>;
    /**
     * Password to authenticate to the ESXi host
     */
    password?: pulumi.Input<string>;
    /**
     * Serial number of the ESXi host
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * SSH thumbprint of the ESXi host
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * Username to authenticate to the ESXi host
     */
    username?: pulumi.Input<string>;
    /**
     * vmnic configuration for the ESXi host
     */
    vmnics?: pulumi.Input<pulumi.Input<inputs.DomainClusterHostVmnic>[]>;
}

export interface DomainClusterHostVmnic {
    /**
     * ESXI host vmnic ID to be associated with a VDS, once added to cluster
     */
    id: pulumi.Input<string>;
    /**
     * Uplink to be associated with vmnic
     */
    uplink?: pulumi.Input<string>;
    /**
     * Name of the VDS to associate with the ESXi host
     */
    vdsName?: pulumi.Input<string>;
}

export interface DomainClusterIpAddressPool {
    /**
     * Description of the IP address pool
     */
    description?: pulumi.Input<string>;
    /**
     * Ignore unavailable NSX cluster(s) during IP pool spec validation
     */
    ignoreUnavailableNsxCluster?: pulumi.Input<boolean>;
    /**
     * Providing only name of existing IP Address Pool reuses it, while providing a new name with subnets creates a new one
     */
    name: pulumi.Input<string>;
    /**
     * List of IP address pool subnet specifications
     */
    subnets?: pulumi.Input<pulumi.Input<inputs.DomainClusterIpAddressPoolSubnet>[]>;
}

export interface DomainClusterIpAddressPoolSubnet {
    /**
     * The subnet representation, contains the network address and the prefix length
     */
    cidr: pulumi.Input<string>;
    /**
     * The default gateway address of the network
     */
    gateway: pulumi.Input<string>;
    /**
     * List of the IP allocation ranges. At least 1 IP address range has to be specified
     */
    ipAddressPoolRanges?: pulumi.Input<pulumi.Input<inputs.DomainClusterIpAddressPoolSubnetIpAddressPoolRange>[]>;
}

export interface DomainClusterIpAddressPoolSubnetIpAddressPoolRange {
    /**
     * The last IP Address of the IP Address Range
     */
    end: pulumi.Input<string>;
    /**
     * The first IP Address of the IP Address Range
     */
    start: pulumi.Input<string>;
}

export interface DomainClusterNfsDatastore {
    /**
     * NFS datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * Shared directory path used for NFS based cluster creation
     */
    path: pulumi.Input<string>;
    /**
     * Readonly is used to identify whether to mount the directory as readOnly or not
     */
    readOnly: pulumi.Input<boolean>;
    /**
     * Fully qualified domain name or IP address of the NFS endpoint
     */
    serverName: pulumi.Input<string>;
    /**
     * User tag used to annotate NFS share
     */
    userTag?: pulumi.Input<string>;
}

export interface DomainClusterVd {
    /**
     * Identifies if the vSphere distributed switch is used by NSX
     */
    isUsedByNsx?: pulumi.Input<boolean>;
    /**
     * vSphere Distributed Switch name
     */
    name: pulumi.Input<string>;
    /**
     * List of Network I/O Control Bandwidth Allocations for System Traffic based on shares, reservation, and limit, you can configure Network I/O Control to allocate certain amount of bandwidth for traffic generated by vSphere Fault Tolerance, iSCSI storage, vSphere vMotion, and so on. You can use Network I/O Control on a distributed switch to configure bandwidth allocation for the traffic  that is related to the main system features in vSphere
     */
    niocBandwidthAllocations?: pulumi.Input<pulumi.Input<inputs.DomainClusterVdNiocBandwidthAllocation>[]>;
    /**
     * List of portgroups to be associated with the vSphere Distributed Switch
     */
    portgroups?: pulumi.Input<pulumi.Input<inputs.DomainClusterVdPortgroup>[]>;
}

export interface DomainClusterVdNiocBandwidthAllocation {
    /**
     * The maximum allowed usage for a traffic class belonging to this resource pool per host physical NIC. The utilization of a traffic class will not exceed the specified limit even if there are available network resources. If this value is unset or set to -1 in an update operation, then there is no limit on the network resource usage (only bounded by available resource and shares). Units are in Mbits/sec
     */
    limit?: pulumi.Input<number>;
    /**
     * Amount of bandwidth resource that is guaranteed available to the host infrastructure traffic class. If the utilization is less than the reservation, the extra bandwidth is used for other host infrastructure traffic class types. Unit is Mbits/sec
     */
    reservation?: pulumi.Input<number>;
    /**
     * The number of shares allocated. Used to determine resource allocation in case of resource contention. This value is only set if level is set to custom. If level is not set to custom, this value is ignored. Therefore, only shares with custom values can be compared. There is no unit for this value. It is a relative measure based on the settings for other resource pools.
     */
    shares?: pulumi.Input<number>;
    /**
     * The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. If the shares value does not map to a predefined size, then the level is set as custom. One among: low, normal, high, custom
     */
    sharesLevel?: pulumi.Input<string>;
    /**
     * Host infrastructure traffic type. Example: management, faultTolerance, vmotion, virtualMachine, iSCSI, nfs, hbr, vsan, vdp etc.
     */
    type: pulumi.Input<string>;
}

export interface DomainClusterVdPortgroup {
    /**
     * List of active uplinks associated with portgroup. This is only supported for VxRail.
     */
    activeUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Port group name
     */
    name: pulumi.Input<string>;
    /**
     * Port group transport type, One among: VSAN, VMOTION, MANAGEMENT, PUBLIC, NFS, VREALIZE, ISCSI, EDGE_INFRA_OVERLAY_UPLINK
     */
    transportType: pulumi.Input<string>;
}

export interface DomainClusterVmfsDatastore {
    /**
     * VMFS datastore names used for VMFS on FC for cluster creation
     */
    datastoreNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DomainClusterVsanDatastore {
    /**
     * vSAN datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * Enable vSAN deduplication and compression
     */
    dedupAndCompressionEnabled?: pulumi.Input<boolean>;
    /**
     * Enable vSAN ESA
     */
    esaEnabled?: pulumi.Input<boolean>;
    /**
     * Number of ESXi host failures to tolerate in the vSAN cluster. One of 0, 1, or 2.
     */
    failuresToTolerate?: pulumi.Input<number>;
    /**
     * vSAN license key to be used
     */
    licenseKey?: pulumi.Input<string>;
}

export interface DomainClusterVsanRemoteDatastoreCluster {
    /**
     * vSAN HCI Mesh remote datastore UUIDs
     */
    datastoreUuids: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DomainClusterVsanStretchConfiguration {
    /**
     * The list of hosts that will go into the secondary fault domain
     */
    secondaryFdHosts?: pulumi.Input<pulumi.Input<inputs.DomainClusterVsanStretchConfigurationSecondaryFdHost>[]>;
    /**
     * Configuration for the witness host
     */
    witnessHost?: pulumi.Input<inputs.DomainClusterVsanStretchConfigurationWitnessHost>;
}

export interface DomainClusterVsanStretchConfigurationSecondaryFdHost {
    /**
     * Availability Zone Name. This is required while performing a stretched cluster expand operation
     */
    availabilityZoneName?: pulumi.Input<string>;
    /**
     * Host name of the ESXi host
     */
    hostName?: pulumi.Input<string>;
    /**
     * ID of the ESXi host in the free pool
     */
    id: pulumi.Input<string>;
    /**
     * IPv4 address of the ESXi host
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * License key for an ESXi host in the free pool. This is required except in cases where the ESXi host has already been licensed outside of the VMware Cloud Foundation system
     */
    licenseKey?: pulumi.Input<string>;
    /**
     * Password to authenticate to the ESXi host
     */
    password?: pulumi.Input<string>;
    /**
     * Serial number of the ESXi host
     */
    serialNumber?: pulumi.Input<string>;
    /**
     * SSH thumbprint of the ESXi host
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * Username to authenticate to the ESXi host
     */
    username?: pulumi.Input<string>;
    /**
     * vmnic configuration for the ESXi host
     */
    vmnics?: pulumi.Input<pulumi.Input<inputs.DomainClusterVsanStretchConfigurationSecondaryFdHostVmnic>[]>;
}

export interface DomainClusterVsanStretchConfigurationSecondaryFdHostVmnic {
    /**
     * ESXI host vmnic ID to be associated with a VDS, once added to cluster
     */
    id: pulumi.Input<string>;
    /**
     * Uplink to be associated with vmnic
     */
    uplink?: pulumi.Input<string>;
    /**
     * Name of the VDS to associate with the ESXi host
     */
    vdsName?: pulumi.Input<string>;
}

export interface DomainClusterVsanStretchConfigurationWitnessHost {
    /**
     * Fully qualified domain name of the witness host. It should be routable on the vSAN network
     */
    fqdn: pulumi.Input<string>;
    /**
     * CIDR address for the witness host on the vSAN network
     */
    vsanCidr: pulumi.Input<string>;
    /**
     * IP address for the witness host on the vSAN network
     */
    vsanIp: pulumi.Input<string>;
}

export interface DomainClusterVvolDatastore {
    /**
     * vVol datastore name used for cluster creation
     */
    datastoreName: pulumi.Input<string>;
    /**
     * UUID of the VASA storage container
     */
    storageContainerId: pulumi.Input<string>;
    /**
     * Type of the VASA storage protocol. One among: ISCSI, NFS, FC.
     */
    storageProtocolType: pulumi.Input<string>;
    /**
     * UUID of the VASA storage user
     */
    userId: pulumi.Input<string>;
    /**
     * UUID of the VASA storage provider
     */
    vasaProviderId: pulumi.Input<string>;
}

export interface DomainNsxConfiguration {
    /**
     * Form factor for the NSX Manager appliance. One among: large, medium, small
     */
    formFactor?: pulumi.Input<string>;
    /**
     * ID of the NSX Manager cluster
     */
    id?: pulumi.Input<string>;
    /**
     * NSX license to be used
     */
    licenseKey: pulumi.Input<string>;
    /**
     * NSX Manager admin user password
     */
    nsxManagerAdminPassword: pulumi.Input<string>;
    /**
     * NSX Manager audit user password
     */
    nsxManagerAuditPassword?: pulumi.Input<string>;
    /**
     * Specification details of the NSX Manager virtual machines. 3 of these are required for the first workload domain
     */
    nsxManagerNodes: pulumi.Input<pulumi.Input<inputs.DomainNsxConfigurationNsxManagerNode>[]>;
    /**
     * Virtual IP (VIP) for the NSX Manager cluster
     */
    vip: pulumi.Input<string>;
    /**
     * Fully qualified domain name of the NSX Manager cluster VIP
     */
    vipFqdn: pulumi.Input<string>;
}

export interface DomainNsxConfigurationNsxManagerNode {
    /**
     * Fully qualified domain name of the NSX Manager appliance, e.g., sfo-w01-nsx01a.sfo.rainpole.io
     */
    fqdn: pulumi.Input<string>;
    /**
     * IPv4 gateway the NSX Manager appliance
     */
    gateway: pulumi.Input<string>;
    /**
     * IPv4 address of the NSX Manager appliance
     */
    ipAddress: pulumi.Input<string>;
    /**
     * Name of the NSX Manager appliance, e.g., sfo-w01-nsx01
     */
    name: pulumi.Input<string>;
    /**
     * IPv4 subnet mask for the NSX Manager appliance
     */
    subnetMask: pulumi.Input<string>;
}

export interface DomainTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface DomainVcenterConfiguration {
    /**
     * vSphere datacenter name
     */
    datacenterName: pulumi.Input<string>;
    /**
     * Fully qualified domain name of the vCenter Server instance
     */
    fqdn: pulumi.Input<string>;
    /**
     * IPv4 gateway of the vCenter Server instance
     */
    gateway: pulumi.Input<string>;
    /**
     * ID of the vCenter Server instance
     */
    id?: pulumi.Input<string>;
    /**
     * IPv4 address of the vCenter virtual machine
     */
    ipAddress: pulumi.Input<string>;
    /**
     * Name of the vCenter Server Appliance virtual machine to be created for the workload domain
     */
    name: pulumi.Input<string>;
    /**
     * root password for the vCenter Server Appliance (8-20 characters)
     */
    rootPassword: pulumi.Input<string>;
    /**
     * vCenter Server storage size. One among: lstorage, xlstorage
     */
    storageSize?: pulumi.Input<string>;
    /**
     * IPv4 subnet mask of the vCenter Server instance
     */
    subnetMask: pulumi.Input<string>;
    /**
     * vCenter Server instance size. One among: xlarge, large, medium, small, tiny
     */
    vmSize?: pulumi.Input<string>;
}

export interface EdgeClusterEdgeNode {
    /**
     * The administrator password for the edge node
     */
    adminPassword: pulumi.Input<string>;
    /**
     * The audit password for the edge node
     */
    auditPassword: pulumi.Input<string>;
    /**
     * The id of the compute cluster
     */
    computeClusterId?: pulumi.Input<string>;
    /**
     * The name of the compute cluster
     */
    computeClusterName?: pulumi.Input<string>;
    /**
     * The name of the first NSX-enabled VDS uplink
     */
    firstNsxVdsUplink?: pulumi.Input<string>;
    /**
     * Whether or not this is an inter-rack cluster. True for L2 non-uniform and L3, false for L2 uniform
     */
    interRackCluster: pulumi.Input<boolean>;
    /**
     * The gateway address for the management network
     */
    managementGateway: pulumi.Input<string>;
    /**
     * The IP address (CIDR) for the management network
     */
    managementIp: pulumi.Input<string>;
    /**
     * The management network which will be created for this node
     */
    managementNetwork?: pulumi.Input<inputs.EdgeClusterEdgeNodeManagementNetwork>;
    /**
     * The name of the edge node
     */
    name: pulumi.Input<string>;
    /**
     * The root user password for the edge node
     */
    rootPassword: pulumi.Input<string>;
    /**
     * The name of the second NSX-enabled VDS uplink
     */
    secondNsxVdsUplink?: pulumi.Input<string>;
    /**
     * The IP address (CIDR) of the first tunnel endpoint
     */
    tep1Ip: pulumi.Input<string>;
    /**
     * The IP address (CIDR) of the second tunnel endpoint
     */
    tep2Ip: pulumi.Input<string>;
    /**
     * The gateway for the tunnel endpoints
     */
    tepGateway: pulumi.Input<string>;
    /**
     * The VLAN ID for the tunnel endpoint
     */
    tepVlan: pulumi.Input<number>;
    /**
     * Specifications of Tier-0 uplinks for the edge node
     */
    uplinks?: pulumi.Input<pulumi.Input<inputs.EdgeClusterEdgeNodeUplink>[]>;
}

export interface EdgeClusterEdgeNodeManagementNetwork {
    /**
     * The name of the portgroup
     */
    portgroupName: pulumi.Input<string>;
    /**
     * The VLAN ID for the portgroup
     */
    vlanId: pulumi.Input<number>;
}

export interface EdgeClusterEdgeNodeUplink {
    /**
     * List of BGP Peer configurations
     */
    bgpPeers?: pulumi.Input<pulumi.Input<inputs.EdgeClusterEdgeNodeUplinkBgpPeer>[]>;
    /**
     * The IP address (CIDR) for the distributed switch uplink
     */
    interfaceIp: pulumi.Input<string>;
    /**
     * The VLAN ID for the distributed switch uplink
     */
    vlan: pulumi.Input<number>;
}

export interface EdgeClusterEdgeNodeUplinkBgpPeer {
    /**
     * ASN
     */
    asn: pulumi.Input<number>;
    /**
     * IP address
     */
    ip: pulumi.Input<string>;
    /**
     * Password
     */
    password: pulumi.Input<string>;
}

export interface EdgeClusterProfile {
    /**
     * BFD allowed hop
     */
    bfdAllowedHop: pulumi.Input<number>;
    /**
     * BFD declare dead multiple
     */
    bfdDeclareDeadMultiple: pulumi.Input<number>;
    /**
     * BFD probe interval
     */
    bfdProbeInterval: pulumi.Input<number>;
    /**
     * The name of the profile
     */
    name: pulumi.Input<string>;
    /**
     * Standby relocation threshold
     */
    standbyRelocationThreshold: pulumi.Input<number>;
}

export interface EdgeClusterTimeouts {
    create?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface ExternalCertificateCertificate {
    certificateError: pulumi.Input<string>;
    domain: pulumi.Input<string>;
    expirationStatus: pulumi.Input<string>;
    issuedBy: pulumi.Input<string>;
    issuedTo: pulumi.Input<string>;
    keySize: pulumi.Input<string>;
    notAfter: pulumi.Input<string>;
    notBefore: pulumi.Input<string>;
    numberOfDaysToExpire: pulumi.Input<number>;
    pemEncoded: pulumi.Input<string>;
    publicKey: pulumi.Input<string>;
    publicKeyAlgorithm: pulumi.Input<string>;
    serialNumber: pulumi.Input<string>;
    signatureAlgorithm: pulumi.Input<string>;
    subject: pulumi.Input<string>;
    subjectAlternativeNames: pulumi.Input<pulumi.Input<string>[]>;
    thumbprint: pulumi.Input<string>;
    thumbprintAlgorithm: pulumi.Input<string>;
    version: pulumi.Input<string>;
}

export interface ExternalCertificateTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
    read?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface GetClusterTimeouts {
    read?: string;
}

export interface GetClusterTimeoutsArgs {
    read?: pulumi.Input<string>;
}

export interface GetDomainTimeouts {
    read?: string;
}

export interface GetDomainTimeoutsArgs {
    read?: pulumi.Input<string>;
}

export interface HostTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface InstanceCluster {
    /**
     * vCenter cluster EVC mode
     */
    clusterEvcMode?: pulumi.Input<string>;
    /**
     * Whether to enable vSphere Lifecycle Manager images for this cluster
     */
    clusterImageEnabled?: pulumi.Input<boolean>;
    /**
     * vCenter Cluster Name
     */
    clusterName: pulumi.Input<string>;
    /**
     * Host failures to tolerate. In between 0 and 3
     */
    hostFailuresToTolerate?: pulumi.Input<number>;
    resourcePools?: pulumi.Input<pulumi.Input<inputs.InstanceClusterResourcePool>[]>;
    /**
     * Virtual Machine folders map. One among: MANAGEMENT, NETWORKING
     */
    vmFolder?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface InstanceClusterResourcePool {
    /**
     * CPU limit, default -1 (unlimited)
     */
    cpuLimit?: pulumi.Input<number>;
    /**
     * Is CPU reservation expandable, default true
     */
    cpuReservationExpandable?: pulumi.Input<boolean>;
    /**
     * CPU reservation in Mhz
     */
    cpuReservationMhz?: pulumi.Input<number>;
    /**
     * CPU reservation percentage, from 0 to 100, default 0
     */
    cpuReservationPercentage?: pulumi.Input<number>;
    /**
     * CPU shares level, default 'normal', possible values: "custom", "high", "low", "normal"
     */
    cpuSharesLevel?: pulumi.Input<string>;
    /**
     * CPU shares value, only required when shares level is 'normal'
     */
    cpuSharesValue?: pulumi.Input<number>;
    /**
     * Memory limit, default -1 (unlimited)
     */
    memoryLimit?: pulumi.Input<number>;
    /**
     * Is Memory reservation expandable, default true
     */
    memoryReservationExpandable?: pulumi.Input<boolean>;
    /**
     * Memory reservation in MB
     */
    memoryReservationMb?: pulumi.Input<number>;
    /**
     * Memory reservation percentage, from 0 to 100, default 0
     */
    memoryReservationPercentage?: pulumi.Input<number>;
    /**
     * Memory shares level, default 'normal', possible values: "custom", "high", "low", "normal"
     */
    memorySharesLevel?: pulumi.Input<string>;
    /**
     * Memory shares value, only required when shares level is 'normal'
     */
    memorySharesValue?: pulumi.Input<number>;
    /**
     * Resource Pool name
     */
    name: pulumi.Input<string>;
    /**
     * Type of resource pool, possible values: "management", "compute", "network"
     */
    type?: pulumi.Input<string>;
}

export interface InstanceDns {
    /**
     * Tenant domain. Parent tenant domain including TLD suffix Example: vmware.com
     */
    domain: pulumi.Input<string>;
    /**
     * Primary nameserver IPv4 address. Example: 172.0.0.4
     */
    nameServer?: pulumi.Input<string>;
    /**
     * Secondary nameserver IPv4 address. Example: 172.0.0.5
     */
    secondaryNameServer?: pulumi.Input<string>;
}

export interface InstanceDv {
    /**
     * DVS Name
     */
    dvsName: pulumi.Input<string>;
    /**
     * Flag indicating whether the DVS is used by NSX
     */
    isUsedByNsxt?: pulumi.Input<boolean>;
    /**
     * DVS MTU (default value is 9000). In between 1500 and 9000
     */
    mtu?: pulumi.Input<number>;
    /**
     * Types of networks in this portgroup. Possible values: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT
     */
    networks: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of NIOC specs for networks
     */
    niocs?: pulumi.Input<pulumi.Input<inputs.InstanceDvNioc>[]>;
    /**
     * Vmnics to be attached to the DVS
     */
    vmnics: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceDvNioc {
    /**
     * Traffic Type One among:VSAN, VMOTION, VIRTUALMACHINE, MANAGEMENT, NFS, VDP, HBR, FAULTTOLERANCE, ISCSI
     */
    trafficType: pulumi.Input<string>;
    /**
     * NIOC Value. Example: LOW, NORMAL, HIGH
     */
    value: pulumi.Input<string>;
}

export interface InstanceHost {
    /**
     * Host Association: Location/Datacenter
     */
    association: pulumi.Input<string>;
    credentials?: pulumi.Input<inputs.InstanceHostCredentials>;
    /**
     * ESXi hostname. If just the short hostname is provided, then FQDN will be generated using the "domain" from dns configuration. Must also adhere to RFC 1123 naming conventions. Example: "esx-1" length from 3 to 63
     */
    hostname: pulumi.Input<string>;
    /**
     * Host Private Management IP
     */
    ipAddressPrivate: pulumi.Input<inputs.InstanceHostIpAddressPrivate>;
    /**
     * Host SSH thumbprint (RSA SHA256)
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * Host SSH thumbprint (RSA SHA256)
     */
    sslThumbprint?: pulumi.Input<string>;
    /**
     * Host vSwitch name
     */
    vswitch: pulumi.Input<string>;
}

export interface InstanceHostCredentials {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface InstanceHostIpAddressPrivate {
    /**
     * Classless Inter-Domain Routing (CIDR), Example: 172.0.0.0/24
     */
    cidr?: pulumi.Input<string>;
    /**
     * Gateway
     */
    gateway: pulumi.Input<string>;
    /**
     * IP Address
     */
    ipAddress: pulumi.Input<string>;
    /**
     * Subnet
     */
    subnet?: pulumi.Input<string>;
}

export interface InstanceNetwork {
    /**
     * Active Uplinks for teaming policy, specify uplink1 for failover_explicit VSAN Teaming Policy
     */
    activeUpLinks?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * IP Address ranges to be excluded
     */
    excludeIpAddressRanges?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * IP Addresses to be excluded
     */
    excludeIpAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    gateway?: pulumi.Input<string>;
    includeIpAddressRanges?: pulumi.Input<pulumi.Input<inputs.InstanceNetworkIncludeIpAddressRange>[]>;
    includeIpAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * MTU size
     */
    mtu: pulumi.Input<string>;
    /**
     * Network Type. One among: VSAN, VMOTION, MANAGEMENT, VM_MANAGEMENT or any custom network type
     */
    networkType: pulumi.Input<string>;
    /**
     * Portgroup key name. When adding a cluster with a new DVS, this value must be provided. When adding a cluster to an existing DVS, this value must not be provided.
     */
    portGroupKey?: pulumi.Input<string>;
    /**
     * Standby Uplinks for teaming policy, specify uplink2 for failover_explicit VSAN Teaming Policy
     */
    standbyUplinks?: pulumi.Input<pulumi.Input<string>[]>;
    subnet?: pulumi.Input<string>;
    subnetMask?: pulumi.Input<string>;
    /**
     * Teaming Policy for VSAN and VMOTION network types, Default is loadbalance_loadbased. One among: loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, loadbalance_loadbased
     */
    teamingPolicy?: pulumi.Input<string>;
    /**
     * VLAN Id
     */
    vlanId: pulumi.Input<string>;
}

export interface InstanceNetworkIncludeIpAddressRange {
    /**
     * End IPv4 Address
     */
    endIpAddress: pulumi.Input<string>;
    /**
     * Start IPv4 Address
     */
    startIpAddress: pulumi.Input<string>;
}

export interface InstanceNsx {
    /**
     * NSX IP address pool specification
     */
    ipAddressPool?: pulumi.Input<inputs.InstanceNsxIpAddressPool>;
    /**
     * NSX Manager license
     */
    license?: pulumi.Input<string>;
    /**
     * NSX admin password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consecutively.
     */
    nsxAdminPassword?: pulumi.Input<string>;
    /**
     * NSX audit password. The password must be at least 12 characters long. Must contain at-least 1 uppercase, 1 lowercase, 1 special character and 1 digit. In addition, a character cannot be repeated 3 or more times consecutively.
     */
    nsxAuditPassword?: pulumi.Input<string>;
    /**
     * NSX-T Manager size. One among: medium, large
     */
    nsxManagerSize: pulumi.Input<string>;
    /**
     * Parameters for NSX manager
     */
    nsxManagers: pulumi.Input<pulumi.Input<inputs.InstanceNsxNsxManager>[]>;
    /**
     * NSX OverLay Transport zone
     */
    overlayTransportZone?: pulumi.Input<inputs.InstanceNsxOverlayTransportZone>;
    /**
     * NSX Manager root password. Password should have 1) At least eight characters, 2) At least one lower-case letter, 3) At least one upper-case letter 4) At least one digit 5) At least one special character, 6) At least five different characters , 7) No dictionary words, 6) No palindromes
     */
    rootNsxManagerPassword: pulumi.Input<string>;
    /**
     * Transport VLAN ID
     */
    transportVlanId: pulumi.Input<number>;
    /**
     * Virtual IP address which would act as proxy/alias for NSX Managers
     */
    vip: pulumi.Input<string>;
    /**
     * FQDN for VIP so that common SSL certificates can be installed across all managers
     */
    vipFqdn: pulumi.Input<string>;
}

export interface InstanceNsxIpAddressPool {
    /**
     * Description of the IP address pool
     */
    description?: pulumi.Input<string>;
    /**
     * Ignore unavailable NSX cluster(s) during IP pool spec validation
     */
    ignoreUnavailableNsxCluster?: pulumi.Input<boolean>;
    /**
     * Providing only name of existing IP Address Pool reuses it, while providing a new name with subnets creates a new one
     */
    name: pulumi.Input<string>;
    /**
     * List of IP address pool subnet specifications
     */
    subnets?: pulumi.Input<pulumi.Input<inputs.InstanceNsxIpAddressPoolSubnet>[]>;
}

export interface InstanceNsxIpAddressPoolSubnet {
    /**
     * The subnet representation, contains the network address and the prefix length
     */
    cidr: pulumi.Input<string>;
    /**
     * The default gateway address of the network
     */
    gateway: pulumi.Input<string>;
    /**
     * List of the IP allocation ranges. At least 1 IP address range has to be specified
     */
    ipAddressPoolRanges?: pulumi.Input<pulumi.Input<inputs.InstanceNsxIpAddressPoolSubnetIpAddressPoolRange>[]>;
}

export interface InstanceNsxIpAddressPoolSubnetIpAddressPoolRange {
    /**
     * The last IP Address of the IP Address Range
     */
    end: pulumi.Input<string>;
    /**
     * The first IP Address of the IP Address Range
     */
    start: pulumi.Input<string>;
}

export interface InstanceNsxNsxManager {
    /**
     * NSX Manager hostname. If just the short hostname is provided, then FQDN will be generated using the "domain" from dns configuration
     */
    hostname?: pulumi.Input<string>;
    /**
     * NSX Manager IPv4 Address
     */
    ip?: pulumi.Input<string>;
}

export interface InstanceNsxOverlayTransportZone {
    /**
     * Transport zone network name
     */
    networkName: pulumi.Input<string>;
    /**
     * Transport zone name
     */
    zoneName: pulumi.Input<string>;
}

export interface InstancePsc {
    /**
     * Admin user sso password. Password needs to be a strong password with at least one Uppercase alphabet, one lowercase alphabet, one digit and one special character specified in braces [!$%^] and 8-20 characters in length,and 3 maximum identical adjacent characters!
     */
    adminUserSsoPassword: pulumi.Input<string>;
    /**
     * PSC SSO Domain. Example: vsphere.local
     */
    pscSsoDomain?: pulumi.Input<string>;
}

export interface InstanceSddcManager {
    /**
     * SDDC Manager Hostname. If just the short hostname is provided, then FQDN will be generated using the "domain" from dns configuration, length 3-63
     */
    hostname?: pulumi.Input<string>;
    /**
     * SDDC Manager IPv4 address
     */
    ipAddress?: pulumi.Input<string>;
    /**
     * The local account is a built-in admin account (password for the break glass user admin@local) in VCF that can be used in emergency scenarios. The password of this account must be at least 12 characters long. It also must contain at-least 1 uppercase, 1 lowercase, 1 special character specified in braces [!%@$^#?] and 1 digit. In addition, a character cannot be repeated more than 3 times consecutively.
     */
    localUserPassword?: pulumi.Input<string>;
    /**
     * Root user credentials for the SDDC Manager VM, UserName must be root. Password needs to be a strong password with at least one alphabet and one special character and at least 8 characters in length.
     */
    rootUserCredentials?: pulumi.Input<inputs.InstanceSddcManagerRootUserCredentials>;
    /**
     * Second user credentials for the SDDC Manager VM, UserName must be vcf.  Password needs to be a strong password with at least one alphabet and one special character and at least 8 characters in length.
     */
    secondUserCredentials?: pulumi.Input<inputs.InstanceSddcManagerSecondUserCredentials>;
}

export interface InstanceSddcManagerRootUserCredentials {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface InstanceSddcManagerSecondUserCredentials {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface InstanceSecurity {
    /**
     * ESXi certificates mode. One among: Custom, VMCA
     */
    esxiCertsMode?: pulumi.Input<string>;
    /**
     * Root Certificate Authority certificate list
     */
    rootCaCerts?: pulumi.Input<pulumi.Input<inputs.InstanceSecurityRootCaCert>[]>;
}

export interface InstanceSecurityRootCaCert {
    /**
     * Certificate alias
     */
    alias?: pulumi.Input<string>;
    /**
     * List of Base64 encoded certificates
     */
    certChains?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InstanceTimeouts {
    create?: pulumi.Input<string>;
}

export interface InstanceVcenter {
    /**
     * vCenter License
     */
    license?: pulumi.Input<string>;
    /**
     * vCenter root password. The password must be between 8 characters and 20 characters long. It must also contain at least one uppercase and lowercase letter, one number, and one character from '! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { &Iota; } ~' and all characters must be ASCII. Space is not allowed in password.
     */
    rootVcenterPassword: pulumi.Input<string>;
    /**
     * vCenter Server SSH thumbprint (RSA SHA256)
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * vCenter Server SSL thumbprint (SHA256)
     */
    sslThumbprint?: pulumi.Input<string>;
    /**
     * vCenter VM storage size. One among:lstorage, xlstorage
     */
    storageSize?: pulumi.Input<string>;
    /**
     * vCenter Server hostname address. If just the short hostname is provided, then FQDN will be generated using the "domain" from dns configuration
     */
    vcenterHostname: pulumi.Input<string>;
    /**
     * vCenter Server IPv4 address
     */
    vcenterIp?: pulumi.Input<string>;
    /**
     * vCenter Server Appliance  size. One among: tiny, small, medium, large, xlarge
     */
    vmSize?: pulumi.Input<string>;
}

export interface InstanceVsan {
    /**
     * Datastore Name
     */
    datastoreName: pulumi.Input<string>;
    /**
     * Enable vSAN ESA
     */
    esaEnabled?: pulumi.Input<boolean>;
    /**
     * A path (URL or local path) to an HCL file that will be uploaded to vCenter prior to configuring vSAN
     */
    hclFile?: pulumi.Input<string>;
    /**
     * VSAN License
     */
    license?: pulumi.Input<string>;
    /**
     * VSAN feature Deduplication and Compression flag, one flag for both features
     */
    vsanDedup?: pulumi.Input<boolean>;
}

export interface InstanceVxManager {
    defaultAdminUserCredentials?: pulumi.Input<inputs.InstanceVxManagerDefaultAdminUserCredentials>;
    defaultRootUserCredentials?: pulumi.Input<inputs.InstanceVxManagerDefaultRootUserCredentials>;
    /**
     * VxRail Manager SSH thumbprint (RSA SHA256)
     */
    sshThumbprint?: pulumi.Input<string>;
    /**
     * VxRail Manager SSL thumbprint (SHA256)
     */
    sslThumbprint?: pulumi.Input<string>;
    /**
     * VxManager host name
     */
    vxManagerHostname: pulumi.Input<string>;
}

export interface InstanceVxManagerDefaultAdminUserCredentials {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface InstanceVxManagerDefaultRootUserCredentials {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface NetworkPoolNetwork {
    /**
     * Gateway for the network
     */
    gateway?: pulumi.Input<string>;
    /**
     * List of IP pool ranges to use
     */
    ipPools?: pulumi.Input<pulumi.Input<inputs.NetworkPoolNetworkIpPool>[]>;
    /**
     * Subnet mask for the subnet of the network
     */
    mask?: pulumi.Input<string>;
    /**
     * Gateway for the network
     */
    mtu?: pulumi.Input<number>;
    /**
     * Subnet associated with the network
     */
    subnet?: pulumi.Input<string>;
    /**
     * Network Type of the network
     */
    type?: pulumi.Input<string>;
    /**
     * VLAN ID associated with the network
     */
    vlanId: pulumi.Input<number>;
}

export interface NetworkPoolNetworkIpPool {
    /**
     * End IP address of the IP pool
     */
    end?: pulumi.Input<string>;
    /**
     * Start IP address of the IP pool
     */
    start?: pulumi.Input<string>;
}

export interface NetworkPoolTimeouts {
    create?: pulumi.Input<string>;
}

export interface UserTimeouts {
    create?: pulumi.Input<string>;
}
