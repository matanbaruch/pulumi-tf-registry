// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class IpAnomalyDrop extends pulumi.CustomResource {
    /**
     * Get an existing IpAnomalyDrop resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: IpAnomalyDropState, opts?: pulumi.CustomResourceOptions): IpAnomalyDrop {
        return new IpAnomalyDrop(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'thunder:index/ipAnomalyDrop:IpAnomalyDrop';

    /**
     * Returns true if the given object is an instance of IpAnomalyDrop.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is IpAnomalyDrop {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === IpAnomalyDrop.__pulumiType;
    }

    /**
     * bad content threshold (threshold value)
     */
    public readonly badContent!: pulumi.Output<number | undefined>;
    /**
     * drop all IP anomaly packets
     */
    public readonly dropAll!: pulumi.Output<number | undefined>;
    /**
     * drop all fragmented packets
     */
    public readonly frag!: pulumi.Output<number | undefined>;
    /**
     * drop packets with IP options
     */
    public readonly ipOption!: pulumi.Output<number | undefined>;
    public readonly ipv6ExtHeader!: pulumi.Output<outputs.IpAnomalyDropIpv6ExtHeader | undefined>;
    /**
     * drop IP packets with the same source and destination addresses
     */
    public readonly landAttack!: pulumi.Output<number | undefined>;
    /**
     * out of sequence packet threshold (threshold value)
     */
    public readonly outOfSequence!: pulumi.Output<number | undefined>;
    public readonly packetDeformity!: pulumi.Output<outputs.IpAnomalyDropPacketDeformity | undefined>;
    /**
     * drop oversize ICMP packets
     */
    public readonly pingOfDeath!: pulumi.Output<number | undefined>;
    public readonly samplingEnables!: pulumi.Output<outputs.IpAnomalyDropSamplingEnable[] | undefined>;
    public readonly securityAttack!: pulumi.Output<outputs.IpAnomalyDropSecurityAttack | undefined>;
    /**
     * drop TCP packets with no flag
     */
    public readonly tcpNoFlag!: pulumi.Output<number | undefined>;
    /**
     * drop TCP packets with both syn and fin flags set
     */
    public readonly tcpSynFin!: pulumi.Output<number | undefined>;
    /**
     * drop fragmented TCP packets with syn flag set
     */
    public readonly tcpSynFrag!: pulumi.Output<number | undefined>;
    /**
     * uuid of the object
     */
    public readonly uuid!: pulumi.Output<string>;
    /**
     * zero window size threshold (threshold value)
     */
    public readonly zeroWindow!: pulumi.Output<number | undefined>;

    /**
     * Create a IpAnomalyDrop resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: IpAnomalyDropArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: IpAnomalyDropArgs | IpAnomalyDropState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as IpAnomalyDropState | undefined;
            resourceInputs["badContent"] = state ? state.badContent : undefined;
            resourceInputs["dropAll"] = state ? state.dropAll : undefined;
            resourceInputs["frag"] = state ? state.frag : undefined;
            resourceInputs["ipOption"] = state ? state.ipOption : undefined;
            resourceInputs["ipv6ExtHeader"] = state ? state.ipv6ExtHeader : undefined;
            resourceInputs["landAttack"] = state ? state.landAttack : undefined;
            resourceInputs["outOfSequence"] = state ? state.outOfSequence : undefined;
            resourceInputs["packetDeformity"] = state ? state.packetDeformity : undefined;
            resourceInputs["pingOfDeath"] = state ? state.pingOfDeath : undefined;
            resourceInputs["samplingEnables"] = state ? state.samplingEnables : undefined;
            resourceInputs["securityAttack"] = state ? state.securityAttack : undefined;
            resourceInputs["tcpNoFlag"] = state ? state.tcpNoFlag : undefined;
            resourceInputs["tcpSynFin"] = state ? state.tcpSynFin : undefined;
            resourceInputs["tcpSynFrag"] = state ? state.tcpSynFrag : undefined;
            resourceInputs["uuid"] = state ? state.uuid : undefined;
            resourceInputs["zeroWindow"] = state ? state.zeroWindow : undefined;
        } else {
            const args = argsOrState as IpAnomalyDropArgs | undefined;
            resourceInputs["badContent"] = args ? args.badContent : undefined;
            resourceInputs["dropAll"] = args ? args.dropAll : undefined;
            resourceInputs["frag"] = args ? args.frag : undefined;
            resourceInputs["ipOption"] = args ? args.ipOption : undefined;
            resourceInputs["ipv6ExtHeader"] = args ? args.ipv6ExtHeader : undefined;
            resourceInputs["landAttack"] = args ? args.landAttack : undefined;
            resourceInputs["outOfSequence"] = args ? args.outOfSequence : undefined;
            resourceInputs["packetDeformity"] = args ? args.packetDeformity : undefined;
            resourceInputs["pingOfDeath"] = args ? args.pingOfDeath : undefined;
            resourceInputs["samplingEnables"] = args ? args.samplingEnables : undefined;
            resourceInputs["securityAttack"] = args ? args.securityAttack : undefined;
            resourceInputs["tcpNoFlag"] = args ? args.tcpNoFlag : undefined;
            resourceInputs["tcpSynFin"] = args ? args.tcpSynFin : undefined;
            resourceInputs["tcpSynFrag"] = args ? args.tcpSynFrag : undefined;
            resourceInputs["uuid"] = args ? args.uuid : undefined;
            resourceInputs["zeroWindow"] = args ? args.zeroWindow : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(IpAnomalyDrop.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering IpAnomalyDrop resources.
 */
export interface IpAnomalyDropState {
    /**
     * bad content threshold (threshold value)
     */
    badContent?: pulumi.Input<number>;
    /**
     * drop all IP anomaly packets
     */
    dropAll?: pulumi.Input<number>;
    /**
     * drop all fragmented packets
     */
    frag?: pulumi.Input<number>;
    /**
     * drop packets with IP options
     */
    ipOption?: pulumi.Input<number>;
    ipv6ExtHeader?: pulumi.Input<inputs.IpAnomalyDropIpv6ExtHeader>;
    /**
     * drop IP packets with the same source and destination addresses
     */
    landAttack?: pulumi.Input<number>;
    /**
     * out of sequence packet threshold (threshold value)
     */
    outOfSequence?: pulumi.Input<number>;
    packetDeformity?: pulumi.Input<inputs.IpAnomalyDropPacketDeformity>;
    /**
     * drop oversize ICMP packets
     */
    pingOfDeath?: pulumi.Input<number>;
    samplingEnables?: pulumi.Input<pulumi.Input<inputs.IpAnomalyDropSamplingEnable>[]>;
    securityAttack?: pulumi.Input<inputs.IpAnomalyDropSecurityAttack>;
    /**
     * drop TCP packets with no flag
     */
    tcpNoFlag?: pulumi.Input<number>;
    /**
     * drop TCP packets with both syn and fin flags set
     */
    tcpSynFin?: pulumi.Input<number>;
    /**
     * drop fragmented TCP packets with syn flag set
     */
    tcpSynFrag?: pulumi.Input<number>;
    /**
     * uuid of the object
     */
    uuid?: pulumi.Input<string>;
    /**
     * zero window size threshold (threshold value)
     */
    zeroWindow?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a IpAnomalyDrop resource.
 */
export interface IpAnomalyDropArgs {
    /**
     * bad content threshold (threshold value)
     */
    badContent?: pulumi.Input<number>;
    /**
     * drop all IP anomaly packets
     */
    dropAll?: pulumi.Input<number>;
    /**
     * drop all fragmented packets
     */
    frag?: pulumi.Input<number>;
    /**
     * drop packets with IP options
     */
    ipOption?: pulumi.Input<number>;
    ipv6ExtHeader?: pulumi.Input<inputs.IpAnomalyDropIpv6ExtHeader>;
    /**
     * drop IP packets with the same source and destination addresses
     */
    landAttack?: pulumi.Input<number>;
    /**
     * out of sequence packet threshold (threshold value)
     */
    outOfSequence?: pulumi.Input<number>;
    packetDeformity?: pulumi.Input<inputs.IpAnomalyDropPacketDeformity>;
    /**
     * drop oversize ICMP packets
     */
    pingOfDeath?: pulumi.Input<number>;
    samplingEnables?: pulumi.Input<pulumi.Input<inputs.IpAnomalyDropSamplingEnable>[]>;
    securityAttack?: pulumi.Input<inputs.IpAnomalyDropSecurityAttack>;
    /**
     * drop TCP packets with no flag
     */
    tcpNoFlag?: pulumi.Input<number>;
    /**
     * drop TCP packets with both syn and fin flags set
     */
    tcpSynFin?: pulumi.Input<number>;
    /**
     * drop fragmented TCP packets with syn flag set
     */
    tcpSynFrag?: pulumi.Input<number>;
    /**
     * uuid of the object
     */
    uuid?: pulumi.Input<string>;
    /**
     * zero window size threshold (threshold value)
     */
    zeroWindow?: pulumi.Input<number>;
}
