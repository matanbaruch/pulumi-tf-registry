// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class SlbServiceGroup extends pulumi.CustomResource {
    /**
     * Get an existing SlbServiceGroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: SlbServiceGroupState, opts?: pulumi.CustomResourceOptions): SlbServiceGroup {
        return new SlbServiceGroup(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'thunder:index/slbServiceGroup:SlbServiceGroup';

    /**
     * Returns true if the given object is an instance of SlbServiceGroup.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is SlbServiceGroup {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === SlbServiceGroup.__pulumiType;
    }

    /**
     * Send log info on back up server events
     */
    public readonly backupServerEventLog!: pulumi.Output<number | undefined>;
    /**
     * Dynamically enable stateless method by conn-rate (Rate to trigger stateless method(conn/sec))
     */
    public readonly connRate!: pulumi.Output<number | undefined>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    public readonly connRateDuration!: pulumi.Output<number | undefined>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    public readonly connRateGracePeriod!: pulumi.Output<number | undefined>;
    /**
     * Send log if transition happens
     */
    public readonly connRateLog!: pulumi.Output<number | undefined>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    public readonly connRateRevertDuration!: pulumi.Output<number | undefined>;
    /**
     * Rate to revert to statelful method (conn/sec)
     */
    public readonly connRevertRate!: pulumi.Output<number | undefined>;
    /**
     * Enable extended statistics on service group
     */
    public readonly extendedStats!: pulumi.Output<number | undefined>;
    /**
     * Health Check (Monitor Name)
     */
    public readonly healthCheck!: pulumi.Output<string | undefined>;
    /**
     * Disable health check
     */
    public readonly healthCheckDisable!: pulumi.Output<number | undefined>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    public readonly l4SessionRevertDuration!: pulumi.Output<number | undefined>;
    /**
     * Dynamically enable stateless method by session usage (Usage to trigger stateless method)
     */
    public readonly l4SessionUsage!: pulumi.Output<number | undefined>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    public readonly l4SessionUsageDuration!: pulumi.Output<number | undefined>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    public readonly l4SessionUsageGracePeriod!: pulumi.Output<number | undefined>;
    /**
     * Send log if transition happens
     */
    public readonly l4SessionUsageLog!: pulumi.Output<number | undefined>;
    /**
     * Usage to revert to statelful method
     */
    public readonly l4SessionUsageRevertRate!: pulumi.Output<number | undefined>;
    /**
     * 'dst-ip-hash': Load-balancing based on only Dst IP and Port hash; 'dst-ip-only-hash': Load-balancing based on only Dst
     * IP hash; 'fastest-response': Fastest response time on service port level; 'least-request': Least request on service port
     * level; 'src-ip-hash': Load-balancing based on only Src IP and Port hash; 'src-ip-only-hash': Load-balancing based on
     * only Src IP hash; 'weighted-rr': Weighted round robin on server level; 'service-weighted-rr': Weighted round robin on
     * service port level; 'round-robin': Round robin on server level; 'round-robin-strict': Strict mode round robin on server
     * level; 'odd-even-hash': odd/even hash based of client src-ip;
     */
    public readonly lbMethod!: pulumi.Output<string | undefined>;
    /**
     * 'least-connection': Least connection on server level; 'service-least-connection': Least connection on service port
     * level; 'weighted-least-connection': Weighted least connection on server level; 'service-weighted-least-connection':
     * Weighted least connection on service port level;
     */
    public readonly lcMethod!: pulumi.Output<string | undefined>;
    /**
     * 'link-cost-load-balance': Link cost load balance;
     */
    public readonly lclbMethod!: pulumi.Output<string | undefined>;
    /**
     * Link Probe template (Link Probe template name)
     */
    public readonly linkProbeTemplate!: pulumi.Output<string | undefined>;
    /**
     * 'next-hop-link': Server selection w/ link probe template on service port level;
     */
    public readonly llbMethod!: pulumi.Output<string | undefined>;
    /**
     * 'service-least-request-pseudo-round-robin': Least request on service port level and select the oldest node for
     * sub-select;
     */
    public readonly lrprrMethod!: pulumi.Output<string | undefined>;
    public readonly memberLists!: pulumi.Output<outputs.SlbServiceGroupMemberList[] | undefined>;
    /**
     * Minimum Active Member Per Priority (Minimum Active Member before Action)
     */
    public readonly minActiveMember!: pulumi.Output<number | undefined>;
    /**
     * 'dynamic-priority': dynamic change member priority to met the min-active-member requirement; 'skip-pri-set': Skip
     * Current Priority Set If Min not met;
     */
    public readonly minActiveMemberAction!: pulumi.Output<string | undefined>;
    /**
     * SLB Service Name
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * 'global': Use Global Configuration; 'enable': Enable persist-scoring; 'disable': Disable persist-scoring;
     */
    public readonly persistScoring!: pulumi.Output<string | undefined>;
    public readonly priorities!: pulumi.Output<outputs.SlbServiceGroupPriority[] | undefined>;
    /**
     * Priority affinity. Persist to the same priority if possible.
     */
    public readonly priorityAffinity!: pulumi.Output<number | undefined>;
    /**
     * 'tcp': TCP LB service; 'udp': UDP LB service;
     */
    public readonly protocol!: pulumi.Output<string | undefined>;
    /**
     * PRR, select the oldest node for sub-select
     */
    public readonly pseudoRoundRobin!: pulumi.Output<number | undefined>;
    /**
     * Reporting frequency (in minutes)
     */
    public readonly reportDelay!: pulumi.Output<number | undefined>;
    public readonly reset!: pulumi.Output<outputs.SlbServiceGroupReset | undefined>;
    /**
     * Send reset to client if server selection fails
     */
    public readonly resetOnServerSelectionFail!: pulumi.Output<number | undefined>;
    /**
     * Reset
     */
    public readonly resetPriorityAffinity!: pulumi.Output<number | undefined>;
    /**
     * Report top 10 fastest/slowest servers
     */
    public readonly rptExtServer!: pulumi.Output<number | undefined>;
    /**
     * sample server response time
     */
    public readonly sampleRspTime!: pulumi.Output<number | undefined>;
    public readonly samplingEnables!: pulumi.Output<outputs.SlbServiceGroupSamplingEnable[] | undefined>;
    /**
     * Reference a policy template from shared partition
     */
    public readonly sharedPartitionPolicyTemplate!: pulumi.Output<number | undefined>;
    /**
     * Reference a health-check from shared partition
     */
    public readonly sharedPartitionSvcgrpHealthCheck!: pulumi.Output<number | undefined>;
    /**
     * Enable auto stateless method
     */
    public readonly statelessAutoSwitch!: pulumi.Output<number | undefined>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    public readonly statelessLbMethod!: pulumi.Output<string | undefined>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    public readonly statelessLbMethod2!: pulumi.Output<string | undefined>;
    /**
     * 'stats-data-enable': Enable statistical data collection for service group; 'stats-data-disable': Disable statistical
     * data collection for service group;
     */
    public readonly statsDataAction!: pulumi.Output<string | undefined>;
    /**
     * strict selection
     */
    public readonly strictSelect!: pulumi.Output<number | undefined>;
    /**
     * Health Check (Monitor Name)
     */
    public readonly svcgrpHealthCheckShared!: pulumi.Output<string | undefined>;
    /**
     * Policy template (Policy template name)
     */
    public readonly templatePolicy!: pulumi.Output<string | undefined>;
    /**
     * Policy template
     */
    public readonly templatePolicyShared!: pulumi.Output<string | undefined>;
    /**
     * Port template (Port template name)
     */
    public readonly templatePort!: pulumi.Output<string | undefined>;
    /**
     * Report top 10 fastest servers
     */
    public readonly topFastest!: pulumi.Output<number | undefined>;
    /**
     * Report top 10 slowest servers
     */
    public readonly topSlowest!: pulumi.Output<number | undefined>;
    /**
     * Mirror Bi-directional Packet
     */
    public readonly trafficReplicationMirror!: pulumi.Output<number | undefined>;
    /**
     * Replace Destination MAC
     */
    public readonly trafficReplicationMirrorDaRepl!: pulumi.Output<number | undefined>;
    /**
     * Replaces IP with server-IP
     */
    public readonly trafficReplicationMirrorIpRepl!: pulumi.Output<number | undefined>;
    /**
     * Replace Source MAC and Destination MAC
     */
    public readonly trafficReplicationMirrorSaDaRepl!: pulumi.Output<number | undefined>;
    /**
     * Replace Source MAC
     */
    public readonly trafficReplicationMirrorSaRepl!: pulumi.Output<number | undefined>;
    /**
     * Customized tag
     */
    public readonly userTag!: pulumi.Output<string | undefined>;
    /**
     * uuid of the object
     */
    public readonly uuid!: pulumi.Output<string>;

    /**
     * Create a SlbServiceGroup resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: SlbServiceGroupArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: SlbServiceGroupArgs | SlbServiceGroupState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as SlbServiceGroupState | undefined;
            resourceInputs["backupServerEventLog"] = state ? state.backupServerEventLog : undefined;
            resourceInputs["connRate"] = state ? state.connRate : undefined;
            resourceInputs["connRateDuration"] = state ? state.connRateDuration : undefined;
            resourceInputs["connRateGracePeriod"] = state ? state.connRateGracePeriod : undefined;
            resourceInputs["connRateLog"] = state ? state.connRateLog : undefined;
            resourceInputs["connRateRevertDuration"] = state ? state.connRateRevertDuration : undefined;
            resourceInputs["connRevertRate"] = state ? state.connRevertRate : undefined;
            resourceInputs["extendedStats"] = state ? state.extendedStats : undefined;
            resourceInputs["healthCheck"] = state ? state.healthCheck : undefined;
            resourceInputs["healthCheckDisable"] = state ? state.healthCheckDisable : undefined;
            resourceInputs["l4SessionRevertDuration"] = state ? state.l4SessionRevertDuration : undefined;
            resourceInputs["l4SessionUsage"] = state ? state.l4SessionUsage : undefined;
            resourceInputs["l4SessionUsageDuration"] = state ? state.l4SessionUsageDuration : undefined;
            resourceInputs["l4SessionUsageGracePeriod"] = state ? state.l4SessionUsageGracePeriod : undefined;
            resourceInputs["l4SessionUsageLog"] = state ? state.l4SessionUsageLog : undefined;
            resourceInputs["l4SessionUsageRevertRate"] = state ? state.l4SessionUsageRevertRate : undefined;
            resourceInputs["lbMethod"] = state ? state.lbMethod : undefined;
            resourceInputs["lcMethod"] = state ? state.lcMethod : undefined;
            resourceInputs["lclbMethod"] = state ? state.lclbMethod : undefined;
            resourceInputs["linkProbeTemplate"] = state ? state.linkProbeTemplate : undefined;
            resourceInputs["llbMethod"] = state ? state.llbMethod : undefined;
            resourceInputs["lrprrMethod"] = state ? state.lrprrMethod : undefined;
            resourceInputs["memberLists"] = state ? state.memberLists : undefined;
            resourceInputs["minActiveMember"] = state ? state.minActiveMember : undefined;
            resourceInputs["minActiveMemberAction"] = state ? state.minActiveMemberAction : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["persistScoring"] = state ? state.persistScoring : undefined;
            resourceInputs["priorities"] = state ? state.priorities : undefined;
            resourceInputs["priorityAffinity"] = state ? state.priorityAffinity : undefined;
            resourceInputs["protocol"] = state ? state.protocol : undefined;
            resourceInputs["pseudoRoundRobin"] = state ? state.pseudoRoundRobin : undefined;
            resourceInputs["reportDelay"] = state ? state.reportDelay : undefined;
            resourceInputs["reset"] = state ? state.reset : undefined;
            resourceInputs["resetOnServerSelectionFail"] = state ? state.resetOnServerSelectionFail : undefined;
            resourceInputs["resetPriorityAffinity"] = state ? state.resetPriorityAffinity : undefined;
            resourceInputs["rptExtServer"] = state ? state.rptExtServer : undefined;
            resourceInputs["sampleRspTime"] = state ? state.sampleRspTime : undefined;
            resourceInputs["samplingEnables"] = state ? state.samplingEnables : undefined;
            resourceInputs["sharedPartitionPolicyTemplate"] = state ? state.sharedPartitionPolicyTemplate : undefined;
            resourceInputs["sharedPartitionSvcgrpHealthCheck"] = state ? state.sharedPartitionSvcgrpHealthCheck : undefined;
            resourceInputs["statelessAutoSwitch"] = state ? state.statelessAutoSwitch : undefined;
            resourceInputs["statelessLbMethod"] = state ? state.statelessLbMethod : undefined;
            resourceInputs["statelessLbMethod2"] = state ? state.statelessLbMethod2 : undefined;
            resourceInputs["statsDataAction"] = state ? state.statsDataAction : undefined;
            resourceInputs["strictSelect"] = state ? state.strictSelect : undefined;
            resourceInputs["svcgrpHealthCheckShared"] = state ? state.svcgrpHealthCheckShared : undefined;
            resourceInputs["templatePolicy"] = state ? state.templatePolicy : undefined;
            resourceInputs["templatePolicyShared"] = state ? state.templatePolicyShared : undefined;
            resourceInputs["templatePort"] = state ? state.templatePort : undefined;
            resourceInputs["topFastest"] = state ? state.topFastest : undefined;
            resourceInputs["topSlowest"] = state ? state.topSlowest : undefined;
            resourceInputs["trafficReplicationMirror"] = state ? state.trafficReplicationMirror : undefined;
            resourceInputs["trafficReplicationMirrorDaRepl"] = state ? state.trafficReplicationMirrorDaRepl : undefined;
            resourceInputs["trafficReplicationMirrorIpRepl"] = state ? state.trafficReplicationMirrorIpRepl : undefined;
            resourceInputs["trafficReplicationMirrorSaDaRepl"] = state ? state.trafficReplicationMirrorSaDaRepl : undefined;
            resourceInputs["trafficReplicationMirrorSaRepl"] = state ? state.trafficReplicationMirrorSaRepl : undefined;
            resourceInputs["userTag"] = state ? state.userTag : undefined;
            resourceInputs["uuid"] = state ? state.uuid : undefined;
        } else {
            const args = argsOrState as SlbServiceGroupArgs | undefined;
            resourceInputs["backupServerEventLog"] = args ? args.backupServerEventLog : undefined;
            resourceInputs["connRate"] = args ? args.connRate : undefined;
            resourceInputs["connRateDuration"] = args ? args.connRateDuration : undefined;
            resourceInputs["connRateGracePeriod"] = args ? args.connRateGracePeriod : undefined;
            resourceInputs["connRateLog"] = args ? args.connRateLog : undefined;
            resourceInputs["connRateRevertDuration"] = args ? args.connRateRevertDuration : undefined;
            resourceInputs["connRevertRate"] = args ? args.connRevertRate : undefined;
            resourceInputs["extendedStats"] = args ? args.extendedStats : undefined;
            resourceInputs["healthCheck"] = args ? args.healthCheck : undefined;
            resourceInputs["healthCheckDisable"] = args ? args.healthCheckDisable : undefined;
            resourceInputs["l4SessionRevertDuration"] = args ? args.l4SessionRevertDuration : undefined;
            resourceInputs["l4SessionUsage"] = args ? args.l4SessionUsage : undefined;
            resourceInputs["l4SessionUsageDuration"] = args ? args.l4SessionUsageDuration : undefined;
            resourceInputs["l4SessionUsageGracePeriod"] = args ? args.l4SessionUsageGracePeriod : undefined;
            resourceInputs["l4SessionUsageLog"] = args ? args.l4SessionUsageLog : undefined;
            resourceInputs["l4SessionUsageRevertRate"] = args ? args.l4SessionUsageRevertRate : undefined;
            resourceInputs["lbMethod"] = args ? args.lbMethod : undefined;
            resourceInputs["lcMethod"] = args ? args.lcMethod : undefined;
            resourceInputs["lclbMethod"] = args ? args.lclbMethod : undefined;
            resourceInputs["linkProbeTemplate"] = args ? args.linkProbeTemplate : undefined;
            resourceInputs["llbMethod"] = args ? args.llbMethod : undefined;
            resourceInputs["lrprrMethod"] = args ? args.lrprrMethod : undefined;
            resourceInputs["memberLists"] = args ? args.memberLists : undefined;
            resourceInputs["minActiveMember"] = args ? args.minActiveMember : undefined;
            resourceInputs["minActiveMemberAction"] = args ? args.minActiveMemberAction : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["persistScoring"] = args ? args.persistScoring : undefined;
            resourceInputs["priorities"] = args ? args.priorities : undefined;
            resourceInputs["priorityAffinity"] = args ? args.priorityAffinity : undefined;
            resourceInputs["protocol"] = args ? args.protocol : undefined;
            resourceInputs["pseudoRoundRobin"] = args ? args.pseudoRoundRobin : undefined;
            resourceInputs["reportDelay"] = args ? args.reportDelay : undefined;
            resourceInputs["reset"] = args ? args.reset : undefined;
            resourceInputs["resetOnServerSelectionFail"] = args ? args.resetOnServerSelectionFail : undefined;
            resourceInputs["resetPriorityAffinity"] = args ? args.resetPriorityAffinity : undefined;
            resourceInputs["rptExtServer"] = args ? args.rptExtServer : undefined;
            resourceInputs["sampleRspTime"] = args ? args.sampleRspTime : undefined;
            resourceInputs["samplingEnables"] = args ? args.samplingEnables : undefined;
            resourceInputs["sharedPartitionPolicyTemplate"] = args ? args.sharedPartitionPolicyTemplate : undefined;
            resourceInputs["sharedPartitionSvcgrpHealthCheck"] = args ? args.sharedPartitionSvcgrpHealthCheck : undefined;
            resourceInputs["statelessAutoSwitch"] = args ? args.statelessAutoSwitch : undefined;
            resourceInputs["statelessLbMethod"] = args ? args.statelessLbMethod : undefined;
            resourceInputs["statelessLbMethod2"] = args ? args.statelessLbMethod2 : undefined;
            resourceInputs["statsDataAction"] = args ? args.statsDataAction : undefined;
            resourceInputs["strictSelect"] = args ? args.strictSelect : undefined;
            resourceInputs["svcgrpHealthCheckShared"] = args ? args.svcgrpHealthCheckShared : undefined;
            resourceInputs["templatePolicy"] = args ? args.templatePolicy : undefined;
            resourceInputs["templatePolicyShared"] = args ? args.templatePolicyShared : undefined;
            resourceInputs["templatePort"] = args ? args.templatePort : undefined;
            resourceInputs["topFastest"] = args ? args.topFastest : undefined;
            resourceInputs["topSlowest"] = args ? args.topSlowest : undefined;
            resourceInputs["trafficReplicationMirror"] = args ? args.trafficReplicationMirror : undefined;
            resourceInputs["trafficReplicationMirrorDaRepl"] = args ? args.trafficReplicationMirrorDaRepl : undefined;
            resourceInputs["trafficReplicationMirrorIpRepl"] = args ? args.trafficReplicationMirrorIpRepl : undefined;
            resourceInputs["trafficReplicationMirrorSaDaRepl"] = args ? args.trafficReplicationMirrorSaDaRepl : undefined;
            resourceInputs["trafficReplicationMirrorSaRepl"] = args ? args.trafficReplicationMirrorSaRepl : undefined;
            resourceInputs["userTag"] = args ? args.userTag : undefined;
            resourceInputs["uuid"] = args ? args.uuid : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(SlbServiceGroup.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering SlbServiceGroup resources.
 */
export interface SlbServiceGroupState {
    /**
     * Send log info on back up server events
     */
    backupServerEventLog?: pulumi.Input<number>;
    /**
     * Dynamically enable stateless method by conn-rate (Rate to trigger stateless method(conn/sec))
     */
    connRate?: pulumi.Input<number>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    connRateDuration?: pulumi.Input<number>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    connRateGracePeriod?: pulumi.Input<number>;
    /**
     * Send log if transition happens
     */
    connRateLog?: pulumi.Input<number>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    connRateRevertDuration?: pulumi.Input<number>;
    /**
     * Rate to revert to statelful method (conn/sec)
     */
    connRevertRate?: pulumi.Input<number>;
    /**
     * Enable extended statistics on service group
     */
    extendedStats?: pulumi.Input<number>;
    /**
     * Health Check (Monitor Name)
     */
    healthCheck?: pulumi.Input<string>;
    /**
     * Disable health check
     */
    healthCheckDisable?: pulumi.Input<number>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    l4SessionRevertDuration?: pulumi.Input<number>;
    /**
     * Dynamically enable stateless method by session usage (Usage to trigger stateless method)
     */
    l4SessionUsage?: pulumi.Input<number>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    l4SessionUsageDuration?: pulumi.Input<number>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    l4SessionUsageGracePeriod?: pulumi.Input<number>;
    /**
     * Send log if transition happens
     */
    l4SessionUsageLog?: pulumi.Input<number>;
    /**
     * Usage to revert to statelful method
     */
    l4SessionUsageRevertRate?: pulumi.Input<number>;
    /**
     * 'dst-ip-hash': Load-balancing based on only Dst IP and Port hash; 'dst-ip-only-hash': Load-balancing based on only Dst
     * IP hash; 'fastest-response': Fastest response time on service port level; 'least-request': Least request on service port
     * level; 'src-ip-hash': Load-balancing based on only Src IP and Port hash; 'src-ip-only-hash': Load-balancing based on
     * only Src IP hash; 'weighted-rr': Weighted round robin on server level; 'service-weighted-rr': Weighted round robin on
     * service port level; 'round-robin': Round robin on server level; 'round-robin-strict': Strict mode round robin on server
     * level; 'odd-even-hash': odd/even hash based of client src-ip;
     */
    lbMethod?: pulumi.Input<string>;
    /**
     * 'least-connection': Least connection on server level; 'service-least-connection': Least connection on service port
     * level; 'weighted-least-connection': Weighted least connection on server level; 'service-weighted-least-connection':
     * Weighted least connection on service port level;
     */
    lcMethod?: pulumi.Input<string>;
    /**
     * 'link-cost-load-balance': Link cost load balance;
     */
    lclbMethod?: pulumi.Input<string>;
    /**
     * Link Probe template (Link Probe template name)
     */
    linkProbeTemplate?: pulumi.Input<string>;
    /**
     * 'next-hop-link': Server selection w/ link probe template on service port level;
     */
    llbMethod?: pulumi.Input<string>;
    /**
     * 'service-least-request-pseudo-round-robin': Least request on service port level and select the oldest node for
     * sub-select;
     */
    lrprrMethod?: pulumi.Input<string>;
    memberLists?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupMemberList>[]>;
    /**
     * Minimum Active Member Per Priority (Minimum Active Member before Action)
     */
    minActiveMember?: pulumi.Input<number>;
    /**
     * 'dynamic-priority': dynamic change member priority to met the min-active-member requirement; 'skip-pri-set': Skip
     * Current Priority Set If Min not met;
     */
    minActiveMemberAction?: pulumi.Input<string>;
    /**
     * SLB Service Name
     */
    name?: pulumi.Input<string>;
    /**
     * 'global': Use Global Configuration; 'enable': Enable persist-scoring; 'disable': Disable persist-scoring;
     */
    persistScoring?: pulumi.Input<string>;
    priorities?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupPriority>[]>;
    /**
     * Priority affinity. Persist to the same priority if possible.
     */
    priorityAffinity?: pulumi.Input<number>;
    /**
     * 'tcp': TCP LB service; 'udp': UDP LB service;
     */
    protocol?: pulumi.Input<string>;
    /**
     * PRR, select the oldest node for sub-select
     */
    pseudoRoundRobin?: pulumi.Input<number>;
    /**
     * Reporting frequency (in minutes)
     */
    reportDelay?: pulumi.Input<number>;
    reset?: pulumi.Input<inputs.SlbServiceGroupReset>;
    /**
     * Send reset to client if server selection fails
     */
    resetOnServerSelectionFail?: pulumi.Input<number>;
    /**
     * Reset
     */
    resetPriorityAffinity?: pulumi.Input<number>;
    /**
     * Report top 10 fastest/slowest servers
     */
    rptExtServer?: pulumi.Input<number>;
    /**
     * sample server response time
     */
    sampleRspTime?: pulumi.Input<number>;
    samplingEnables?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupSamplingEnable>[]>;
    /**
     * Reference a policy template from shared partition
     */
    sharedPartitionPolicyTemplate?: pulumi.Input<number>;
    /**
     * Reference a health-check from shared partition
     */
    sharedPartitionSvcgrpHealthCheck?: pulumi.Input<number>;
    /**
     * Enable auto stateless method
     */
    statelessAutoSwitch?: pulumi.Input<number>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    statelessLbMethod?: pulumi.Input<string>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    statelessLbMethod2?: pulumi.Input<string>;
    /**
     * 'stats-data-enable': Enable statistical data collection for service group; 'stats-data-disable': Disable statistical
     * data collection for service group;
     */
    statsDataAction?: pulumi.Input<string>;
    /**
     * strict selection
     */
    strictSelect?: pulumi.Input<number>;
    /**
     * Health Check (Monitor Name)
     */
    svcgrpHealthCheckShared?: pulumi.Input<string>;
    /**
     * Policy template (Policy template name)
     */
    templatePolicy?: pulumi.Input<string>;
    /**
     * Policy template
     */
    templatePolicyShared?: pulumi.Input<string>;
    /**
     * Port template (Port template name)
     */
    templatePort?: pulumi.Input<string>;
    /**
     * Report top 10 fastest servers
     */
    topFastest?: pulumi.Input<number>;
    /**
     * Report top 10 slowest servers
     */
    topSlowest?: pulumi.Input<number>;
    /**
     * Mirror Bi-directional Packet
     */
    trafficReplicationMirror?: pulumi.Input<number>;
    /**
     * Replace Destination MAC
     */
    trafficReplicationMirrorDaRepl?: pulumi.Input<number>;
    /**
     * Replaces IP with server-IP
     */
    trafficReplicationMirrorIpRepl?: pulumi.Input<number>;
    /**
     * Replace Source MAC and Destination MAC
     */
    trafficReplicationMirrorSaDaRepl?: pulumi.Input<number>;
    /**
     * Replace Source MAC
     */
    trafficReplicationMirrorSaRepl?: pulumi.Input<number>;
    /**
     * Customized tag
     */
    userTag?: pulumi.Input<string>;
    /**
     * uuid of the object
     */
    uuid?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a SlbServiceGroup resource.
 */
export interface SlbServiceGroupArgs {
    /**
     * Send log info on back up server events
     */
    backupServerEventLog?: pulumi.Input<number>;
    /**
     * Dynamically enable stateless method by conn-rate (Rate to trigger stateless method(conn/sec))
     */
    connRate?: pulumi.Input<number>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    connRateDuration?: pulumi.Input<number>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    connRateGracePeriod?: pulumi.Input<number>;
    /**
     * Send log if transition happens
     */
    connRateLog?: pulumi.Input<number>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    connRateRevertDuration?: pulumi.Input<number>;
    /**
     * Rate to revert to statelful method (conn/sec)
     */
    connRevertRate?: pulumi.Input<number>;
    /**
     * Enable extended statistics on service group
     */
    extendedStats?: pulumi.Input<number>;
    /**
     * Health Check (Monitor Name)
     */
    healthCheck?: pulumi.Input<string>;
    /**
     * Disable health check
     */
    healthCheckDisable?: pulumi.Input<number>;
    /**
     * Period that revert condition consistently happens(seconds)
     */
    l4SessionRevertDuration?: pulumi.Input<number>;
    /**
     * Dynamically enable stateless method by session usage (Usage to trigger stateless method)
     */
    l4SessionUsage?: pulumi.Input<number>;
    /**
     * Period that trigger condition consistently happens(seconds)
     */
    l4SessionUsageDuration?: pulumi.Input<number>;
    /**
     * Define the grace period during transition (Define the grace period during transition(seconds))
     */
    l4SessionUsageGracePeriod?: pulumi.Input<number>;
    /**
     * Send log if transition happens
     */
    l4SessionUsageLog?: pulumi.Input<number>;
    /**
     * Usage to revert to statelful method
     */
    l4SessionUsageRevertRate?: pulumi.Input<number>;
    /**
     * 'dst-ip-hash': Load-balancing based on only Dst IP and Port hash; 'dst-ip-only-hash': Load-balancing based on only Dst
     * IP hash; 'fastest-response': Fastest response time on service port level; 'least-request': Least request on service port
     * level; 'src-ip-hash': Load-balancing based on only Src IP and Port hash; 'src-ip-only-hash': Load-balancing based on
     * only Src IP hash; 'weighted-rr': Weighted round robin on server level; 'service-weighted-rr': Weighted round robin on
     * service port level; 'round-robin': Round robin on server level; 'round-robin-strict': Strict mode round robin on server
     * level; 'odd-even-hash': odd/even hash based of client src-ip;
     */
    lbMethod?: pulumi.Input<string>;
    /**
     * 'least-connection': Least connection on server level; 'service-least-connection': Least connection on service port
     * level; 'weighted-least-connection': Weighted least connection on server level; 'service-weighted-least-connection':
     * Weighted least connection on service port level;
     */
    lcMethod?: pulumi.Input<string>;
    /**
     * 'link-cost-load-balance': Link cost load balance;
     */
    lclbMethod?: pulumi.Input<string>;
    /**
     * Link Probe template (Link Probe template name)
     */
    linkProbeTemplate?: pulumi.Input<string>;
    /**
     * 'next-hop-link': Server selection w/ link probe template on service port level;
     */
    llbMethod?: pulumi.Input<string>;
    /**
     * 'service-least-request-pseudo-round-robin': Least request on service port level and select the oldest node for
     * sub-select;
     */
    lrprrMethod?: pulumi.Input<string>;
    memberLists?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupMemberList>[]>;
    /**
     * Minimum Active Member Per Priority (Minimum Active Member before Action)
     */
    minActiveMember?: pulumi.Input<number>;
    /**
     * 'dynamic-priority': dynamic change member priority to met the min-active-member requirement; 'skip-pri-set': Skip
     * Current Priority Set If Min not met;
     */
    minActiveMemberAction?: pulumi.Input<string>;
    /**
     * SLB Service Name
     */
    name?: pulumi.Input<string>;
    /**
     * 'global': Use Global Configuration; 'enable': Enable persist-scoring; 'disable': Disable persist-scoring;
     */
    persistScoring?: pulumi.Input<string>;
    priorities?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupPriority>[]>;
    /**
     * Priority affinity. Persist to the same priority if possible.
     */
    priorityAffinity?: pulumi.Input<number>;
    /**
     * 'tcp': TCP LB service; 'udp': UDP LB service;
     */
    protocol?: pulumi.Input<string>;
    /**
     * PRR, select the oldest node for sub-select
     */
    pseudoRoundRobin?: pulumi.Input<number>;
    /**
     * Reporting frequency (in minutes)
     */
    reportDelay?: pulumi.Input<number>;
    reset?: pulumi.Input<inputs.SlbServiceGroupReset>;
    /**
     * Send reset to client if server selection fails
     */
    resetOnServerSelectionFail?: pulumi.Input<number>;
    /**
     * Reset
     */
    resetPriorityAffinity?: pulumi.Input<number>;
    /**
     * Report top 10 fastest/slowest servers
     */
    rptExtServer?: pulumi.Input<number>;
    /**
     * sample server response time
     */
    sampleRspTime?: pulumi.Input<number>;
    samplingEnables?: pulumi.Input<pulumi.Input<inputs.SlbServiceGroupSamplingEnable>[]>;
    /**
     * Reference a policy template from shared partition
     */
    sharedPartitionPolicyTemplate?: pulumi.Input<number>;
    /**
     * Reference a health-check from shared partition
     */
    sharedPartitionSvcgrpHealthCheck?: pulumi.Input<number>;
    /**
     * Enable auto stateless method
     */
    statelessAutoSwitch?: pulumi.Input<number>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    statelessLbMethod?: pulumi.Input<string>;
    /**
     * 'stateless-dst-ip-hash': Stateless load-balancing based on Dst IP and Dst port hash; 'stateless-per-pkt-round-robin':
     * Stateless load-balancing using per-packet round-robin; 'stateless-src-dst-ip-hash': Stateless load-balancing based on IP
     * and port hash for both Src and Dst; 'stateless-src-dst-ip-only-hash': Stateless load-balancing based on only IP hash for
     * both Src and Dst; 'stateless-src-ip-hash': Stateless load-balancing based on Src IP and Src port hash;
     * 'stateless-src-ip-only-hash': Stateless load-balancing based on only Src IP hash; 'stateless-per-pkt-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on server level; 'stateless-per-pkt-service-weighted-rr':
     * Stateless load-balancing using per-packet weighted round robin on service port level;
     */
    statelessLbMethod2?: pulumi.Input<string>;
    /**
     * 'stats-data-enable': Enable statistical data collection for service group; 'stats-data-disable': Disable statistical
     * data collection for service group;
     */
    statsDataAction?: pulumi.Input<string>;
    /**
     * strict selection
     */
    strictSelect?: pulumi.Input<number>;
    /**
     * Health Check (Monitor Name)
     */
    svcgrpHealthCheckShared?: pulumi.Input<string>;
    /**
     * Policy template (Policy template name)
     */
    templatePolicy?: pulumi.Input<string>;
    /**
     * Policy template
     */
    templatePolicyShared?: pulumi.Input<string>;
    /**
     * Port template (Port template name)
     */
    templatePort?: pulumi.Input<string>;
    /**
     * Report top 10 fastest servers
     */
    topFastest?: pulumi.Input<number>;
    /**
     * Report top 10 slowest servers
     */
    topSlowest?: pulumi.Input<number>;
    /**
     * Mirror Bi-directional Packet
     */
    trafficReplicationMirror?: pulumi.Input<number>;
    /**
     * Replace Destination MAC
     */
    trafficReplicationMirrorDaRepl?: pulumi.Input<number>;
    /**
     * Replaces IP with server-IP
     */
    trafficReplicationMirrorIpRepl?: pulumi.Input<number>;
    /**
     * Replace Source MAC and Destination MAC
     */
    trafficReplicationMirrorSaDaRepl?: pulumi.Input<number>;
    /**
     * Replace Source MAC
     */
    trafficReplicationMirrorSaRepl?: pulumi.Input<number>;
    /**
     * Customized tag
     */
    userTag?: pulumi.Input<string>;
    /**
     * uuid of the object
     */
    uuid?: pulumi.Input<string>;
}
