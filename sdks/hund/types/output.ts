// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComponentWatchdog {
    /**
     * When true, this Watchdog will run every 30 seconds, instead of the standard 1 minute.
     *
     * > You are billed extra for each high frequency Watchdog. Please see our [pricing page](https://hund.io/pricing) for more details.
     */
    highFrequency: boolean;
    /**
     * The ObjectId of this Watchdog.
     */
    id: string;
    /**
     * The ObjectId of the latest Status object generated by this Watchdog. When `null`, this Watchdog is still pending initial status.
     */
    latestStatus: string;
    /**
     * The service configuration for this Watchdog, which describes how the Watchdog determines current status.
     */
    service: outputs.ComponentWatchdogService;
}

export interface ComponentWatchdogService {
    /**
     * A Hund Native Monitoring DNS Check.
     */
    dns?: outputs.ComponentWatchdogServiceDns;
    /**
     * A Hund Native Monitoring HTTP Check.
     */
    http?: outputs.ComponentWatchdogServiceHttp;
    /**
     * A Hund Native Monitoring ICMP Check.
     */
    icmp?: outputs.ComponentWatchdogServiceIcmp;
    /**
     * A manually updated Watchdog.
     */
    manual?: outputs.ComponentWatchdogServiceManual;
    /**
     * A [pingdom](https://www.pingdom.com) service.
     */
    pingdom?: outputs.ComponentWatchdogServicePingdom;
    /**
     * A Hund Native Monitoring TCP Check.
     */
    tcp?: outputs.ComponentWatchdogServiceTcp;
    /**
     * A Hund Native Monitoring UDP Check.
     */
    udp?: outputs.ComponentWatchdogServiceUdp;
    /**
     * An [Updown.io](https://updown.io) service.
     */
    updown?: outputs.ComponentWatchdogServiceUpdown;
    /**
     * An [Uptime Robot](https://uptimerobot.com) service.
     */
    uptimerobot?: outputs.ComponentWatchdogServiceUptimerobot;
    /**
     * A [webhook](https://hund.io/help/integrations/webhooks) service.
     */
    webhook?: outputs.ComponentWatchdogServiceWebhook;
}

export interface ComponentWatchdogServiceDns {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * An optional list of nameservers to make DNS queries with. This field is
     * ignored by SOA queries since they use the nameservers yielded by querying NS
     * on the target.
     */
    nameservers?: string[];
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The type of DNS record to query for on the target.
     */
    recordType: string;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * Whether `all` of the assertions in `responses_must_contain` must match the DNS response,
     * or rather just `any` of them (i.e. at least one).
     */
    responseContainment?: string;
    /**
     * A set of assertions to make against the records yielded by the query. The
     * format of these assertions is *similar* to DNS record syntax, but is
     * slightly simplified and allows for only asserting parts of a record's RDATA,
     * rather than the entire thing. The check will fail depending on the value of
     * `response_containment`.
     *
     *   This field is ignored by the SOA check, as it does not use assertions to
     * determine the validity of SOA records. Instead, we ensure that every
     * nameserver reported by querying NS on the target reports the same SOA serial.
     * If your target's nameservers report conflicting SOA serials, we consider the
     * check failed.
     *
     *   **Example Assertions (for MX record type):**
     * ```json
     * [
     *   "10 mail.example.com",
     *   "spool.example.com",
     *   "mail2.example.com"
     * ]
     * ```
     *
     *   Note above how we can assert both the priority and domain (*without* the
     * terminating period required by canonical DNS) of an MX record, or instead
     * simply the domain.
     */
    responsesMustContains?: string[];
    /**
     * The domain/IP address that will be queried. IP addresses do not need to be
     * converted to the `z.y.x.w.in-addr.arpa` format, as this will be done
     * automatically; however, both formats are accepted.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface ComponentWatchdogServiceHttp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * Follow any HTTP redirects given by the requested target. Please note that this check will only follow up to 9 redirects.
     */
    followRedirects: boolean;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * A list of additional HTTP headers to send to the target. The following list of
     * header names are reserved and cannot be set by a check:
     *
     * ```
     * Accept-Charset
     * Accept-Encoding
     * Authentication
     * Connection
     * Content-Length
     * Date
     * Host
     * Keep-Alive
     * Origin
     * Proxy-.*
     * Sec-.*
     * Referer
     * TE
     * Trailer
     * Transfer-Encoding
     * User-Agent
     * Via
     * ```
     */
    headers: {[key: string]: string};
    /**
     * An optional HTTP Basic Authentication password.
     */
    password?: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by
     * `response_body_must_contain_mode`):
     *
     *   `exact`: If the requested page does not contain this exact (case-sensitive)
     * string, then the check will fail.
     *
     *   `regex`: If the requested page does not match against the given regex, then
     * the check will fail. [Click here](https://hund.io/help/documentation/regular-expressions) for
     * more information on the use and supported syntax of Hund regexes.
     */
    responseBodyMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_body_must_contain`.
     */
    responseBodyMustContainMode: string;
    /**
     * If the requested page does not return this response code, then the check will
     * fail.
     */
    responseCodeMustBe?: number;
    /**
     * Require the target's TLS certificate to be valid.
     */
    sslVerifyPeer: boolean;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
    /**
     * An optional HTTP Basic Authentication username.
     */
    username?: string;
}

export interface ComponentWatchdogServiceIcmp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when pinging.
     */
    ipVersion: string;
    /**
     * The percentage of addresses at the given target that must fail for a region to be counted as failed. This option only matters when there are multiple IP addresses behind the target when the target is a domain.
     */
    percentageFailedThreshold: number;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface ComponentWatchdogServiceManual {
    /**
     * An integer denoting operational state (1 => operational, 0 => degraded, -1 => outage).
     */
    state: number;
}

export interface ComponentWatchdogServicePingdom {
    /**
     * The Pingdom API v3 key.
     */
    apiToken: string;
    /**
     * The ID of the check to pull status from on Pingdom.
     */
    checkId: string;
    /**
     * The type of the Pingdom check. `check` denotes a normal Pingdom uptime check, and `transactional` denotes a Pingdom TMS check.
     */
    checkType: string;
    /**
     * When true, triggers Watchdog outage when Pingdom reports a yet unconfirmed outage.
     */
    unconfirmedIsDown: boolean;
}

export interface ComponentWatchdogServiceTcp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when calling the target.
     */
    ipVersion: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The port at the target to connect to.
     */
    port: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by `response_must_contain_mode`):
     *
     *   `exact`: Text that the response from the target must contain exactly
     * (case-sensitive). In exact match mode, this field supports
     * [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     *
     *   `regex`: A regex that the response from the target must match against.
     * [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
     * the use and supported syntax of Hund regexes.
     *
     *   If you send data and expect the target to reply, you must populate this field.
     * Leaving this field blank will prevent the check from receiving data from the
     * target unless forced to wait for an initial response.
     *
     *   The "response" from the target that this text is asserted against will be the
     * response from the target *after* sending data. If data is not sent to the
     * target, this text is asserted against the *initial* response.
     */
    responseMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_must_contain`.
     */
    responseMustContainMode: string;
    /**
     * Optional data to send to the target after connecting. If this field is left
     * blank, nothing is sent to the target after connecting. This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     */
    sendData?: string;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
    /**
     * Whether or not to wait for an initial response from the target before sending
     * data or closing the connection.
     */
    waitForInitialResponse?: boolean;
}

export interface ComponentWatchdogServiceUdp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when calling the target.
     */
    ipVersion: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The port at the target to connect to.
     */
    port: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by `response_must_contain_mode`):
     *
     *   `exact`: Text that the response from the target must contain exactly
     * (case-sensitive). In exact match mode, this field supports
     * [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     *
     *   `regex`: A regex that the response from the target must match against.
     * [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
     * the use and supported syntax of Hund regexes.
     *
     *   Leaving this field blank will still cause the check to wait for a response
     * from the target after sending data, though no assertions will be made about
     * the payload of the response.
     */
    responseMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_must_contain`.
     */
    responseMustContainMode: string;
    /**
     * Data to send to the target after connecting. Unlike in `tcp`, this
     * field is required. This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     */
    sendData: string;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface ComponentWatchdogServiceUpdown {
    /**
     * An Updown.io monitor API key. This API key can be read-only.
     */
    monitorApiKey: string;
    /**
     * An Updown.io monitor token to retrieve status from.
     */
    monitorToken: string;
}

export interface ComponentWatchdogServiceUptimerobot {
    /**
     * An Uptime Robot monitor API key to retrieve status from.
     */
    monitorApiKey: string;
    /**
     * When true, triggers Watchdog outage when UptimeRobot reports a yet unconfirmed outage.
     */
    unconfirmedIsDown: boolean;
}

export interface ComponentWatchdogServiceWebhook {
    /**
     * This property is only required when `deadman: true`. This property configures how many checks (i.e. the number of times `reporting_interval` elapses) must fail (i.e. no status reported to the webhook) before triggering the "Dead Man's Switch." For example, if `deadman: true` and `reporting_interval: 60`, then a setting of `consecutive_checks: 5` would cause the Watchdog to wait for 5 consecutive minutes to receive a webhook call before triggering outage. Since the count is consecutive, it is reset whenever a new webhook call comes through to the Watchdog.
     */
    consecutiveChecks?: number;
    /**
     * When true, turns on a "Dead Man's Switch" for the Watchdog, according to the configuration set by `reporting_interval` and `consecutive_checks`. The Watchdog will trigger an "outage" state if the webhook does not receive a call after the configured number of consecutive checks (according to the reporting interval). This switch can be useful when a lack of webhook reporting from the specific component should be taken to mean that the component itself is down.,
     */
    deadman: boolean;
    /**
     * This property is only required when `deadman: true`. This property configures how often (in seconds) that you expect to POST status to the webhook.
     */
    reportingInterval?: number;
    /**
     * The key to use for this webhook, expected in request headers.
     */
    webhookKey: string;
}

export interface GetComponentsComponent {
    createdAt: string;
    description: string;
    descriptionHtml: string;
    descriptionHtmlTranslations: {[key: string]: string};
    descriptionTranslations: {[key: string]: string};
    excludeFromGlobalHistory: boolean;
    excludeFromGlobalUptime: boolean;
    group: string;
    id: string;
    lastEventAt: string;
    name: string;
    nameTranslations: {[key: string]: string};
    percentUptime: number;
    updatedAt: string;
    watchdog: outputs.GetComponentsComponentWatchdog;
}

export interface GetComponentsComponentWatchdog {
    highFrequency: boolean;
    id: string;
    latestStatus: string;
    service: outputs.GetComponentsComponentWatchdogService;
}

export interface GetComponentsComponentWatchdogService {
    dns: outputs.GetComponentsComponentWatchdogServiceDns;
    http: outputs.GetComponentsComponentWatchdogServiceHttp;
    icmp: outputs.GetComponentsComponentWatchdogServiceIcmp;
    manual: outputs.GetComponentsComponentWatchdogServiceManual;
    pingdom: outputs.GetComponentsComponentWatchdogServicePingdom;
    tcp: outputs.GetComponentsComponentWatchdogServiceTcp;
    udp: outputs.GetComponentsComponentWatchdogServiceUdp;
    updown: outputs.GetComponentsComponentWatchdogServiceUpdown;
    uptimerobot: outputs.GetComponentsComponentWatchdogServiceUptimerobot;
    webhook: outputs.GetComponentsComponentWatchdogServiceWebhook;
}

export interface GetComponentsComponentWatchdogServiceDns {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    nameservers: string[];
    percentageRegionsFailedThreshold: number;
    recordType: string;
    regions: string[];
    responseContainment: string;
    responsesMustContains: string[];
    target: string;
    timeout: number;
}

export interface GetComponentsComponentWatchdogServiceHttp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    followRedirects: boolean;
    frequency: number;
    headers: {[key: string]: string};
    password: string;
    percentageRegionsFailedThreshold: number;
    regions: string[];
    responseBodyMustContain: string;
    responseBodyMustContainMode: string;
    responseCodeMustBe: number;
    sslVerifyPeer: boolean;
    target: string;
    timeout: number;
    username: string;
}

export interface GetComponentsComponentWatchdogServiceIcmp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageFailedThreshold: number;
    percentageRegionsFailedThreshold: number;
    regions: string[];
    target: string;
    timeout: number;
}

export interface GetComponentsComponentWatchdogServiceManual {
    state: number;
}

export interface GetComponentsComponentWatchdogServicePingdom {
    apiToken: string;
    checkId: string;
    checkType: string;
    unconfirmedIsDown: boolean;
}

export interface GetComponentsComponentWatchdogServiceTcp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageRegionsFailedThreshold: number;
    port: number;
    regions: string[];
    responseMustContain: string;
    responseMustContainMode: string;
    sendData: string;
    target: string;
    timeout: number;
    waitForInitialResponse: boolean;
}

export interface GetComponentsComponentWatchdogServiceUdp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageRegionsFailedThreshold: number;
    port: number;
    regions: string[];
    responseMustContain: string;
    responseMustContainMode: string;
    sendData: string;
    target: string;
    timeout: number;
}

export interface GetComponentsComponentWatchdogServiceUpdown {
    monitorApiKey: string;
    monitorToken: string;
}

export interface GetComponentsComponentWatchdogServiceUptimerobot {
    monitorApiKey: string;
    unconfirmedIsDown: boolean;
}

export interface GetComponentsComponentWatchdogServiceWebhook {
    consecutiveChecks: number;
    deadman: boolean;
    reportingInterval: number;
    webhookKey: string;
}

export interface GetGroupsGroup {
    collapsed: boolean;
    components: string[];
    createdAt: string;
    description: string;
    descriptionHtml: string;
    descriptionHtmlTranslations: {[key: string]: string};
    descriptionTranslations: {[key: string]: string};
    id: string;
    name: string;
    nameTranslations: {[key: string]: string};
    position: number;
    updatedAt: string;
}

export interface GetIssueTemplatesIssueTemplate {
    body: string;
    bodyTranslations: {[key: string]: string};
    createdAt: string;
    id: string;
    kind: string;
    label: string;
    name: string;
    title: string;
    titleTranslations: {[key: string]: string};
    updatedAt: string;
    variables: {[key: string]: outputs.GetIssueTemplatesIssueTemplateVariables};
}

export interface GetIssueTemplatesIssueTemplateVariables {
    required: boolean;
    type: string;
}

export interface GetIssuesIssue {
    archiveOnDestroy: boolean;
    beganAt: string;
    body: string;
    bodyHtml: string;
    bodyHtmlTranslations: {[key: string]: string};
    bodyTranslations: {[key: string]: string};
    cancelledAt: string;
    componentIds: string[];
    createdAt: string;
    duration: number;
    endedAt: string;
    id: string;
    label: string;
    openGraphImageUrl: string;
    priority: number;
    resolved: boolean;
    retrospective: boolean;
    schedule: outputs.GetIssuesIssueSchedule;
    scheduled: boolean;
    specialization: string;
    standing: boolean;
    stateOverride: number;
    template: outputs.GetIssuesIssueTemplate;
    title: string;
    titleTranslations: {[key: string]: string};
    updatedAt: string;
    updates: outputs.GetIssuesIssueUpdate[];
}

export interface GetIssuesIssueSchedule {
    ended: boolean;
    endsAt: string;
    id: string;
    notified: boolean;
    notifySubscribersAt: string;
    started: boolean;
    startsAt: string;
}

export interface GetIssuesIssueTemplate {
    body: string;
    bodyTranslations: {[key: string]: string};
    id: string;
    issueTemplateId: string;
    label: string;
    schema: {[key: string]: outputs.GetIssuesIssueTemplateSchema};
    title: string;
    titleTranslations: {[key: string]: string};
    variables: {[key: string]: outputs.GetIssuesIssueTemplateVariables};
}

export interface GetIssuesIssueTemplateSchema {
    required: boolean;
    type: string;
}

export interface GetIssuesIssueTemplateVariables {
    datetime: string;
    i18nString: {[key: string]: string};
    number: number;
    string: string;
}

export interface GetIssuesIssueUpdate {
    archiveOnDestroy: boolean;
    body: string;
    bodyHtml: string;
    bodyHtmlTranslations: {[key: string]: string};
    bodyTranslations: {[key: string]: string};
    createdAt: string;
    effective: boolean;
    effectiveAfter: string;
    id: string;
    issueId: string;
    label: string;
    reopening: boolean;
    stateOverride: number;
    template: outputs.GetIssuesIssueUpdateTemplate;
    updatedAt: string;
}

export interface GetIssuesIssueUpdateTemplate {
    body: string;
    bodyTranslations: {[key: string]: string};
    id: string;
    issueTemplateId: string;
    label: string;
    schema: {[key: string]: outputs.GetIssuesIssueUpdateTemplateSchema};
    variables: {[key: string]: outputs.GetIssuesIssueUpdateTemplateVariables};
}

export interface GetIssuesIssueUpdateTemplateSchema {
    required: boolean;
    type: string;
}

export interface GetIssuesIssueUpdateTemplateVariables {
    datetime: string;
    i18nString: {[key: string]: string};
    number: number;
    string: string;
}

export interface GetMetricProvidersMetricProvider {
    default: boolean;
    id: string;
    instances: {[key: string]: outputs.GetMetricProvidersMetricProviderInstances};
    service: outputs.GetMetricProvidersMetricProviderService;
    watchdog: string;
}

export interface GetMetricProvidersMetricProviderInstances {
    aggregation: string;
    definitionSlug: string;
    enabled: boolean;
    id: string;
    interpolation: string;
    plotType: string;
    slug: string;
    title: string;
    titleTranslations: {[key: string]: string};
    topLevelEnabled: boolean;
    xTitle: string;
    xTitleTranslations: {[key: string]: string};
    xType: string;
    ySupremum: number;
    yTitle: string;
    yTitleTranslations: {[key: string]: string};
    yType: string;
}

export interface GetMetricProvidersMetricProviderService {
    builtin: outputs.GetMetricProvidersMetricProviderServiceBuiltin;
    dns: outputs.GetMetricProvidersMetricProviderServiceDns;
    http: outputs.GetMetricProvidersMetricProviderServiceHttp;
    icmp: outputs.GetMetricProvidersMetricProviderServiceIcmp;
    pingdom: outputs.GetMetricProvidersMetricProviderServicePingdom;
    tcp: outputs.GetMetricProvidersMetricProviderServiceTcp;
    udp: outputs.GetMetricProvidersMetricProviderServiceUdp;
    updown: outputs.GetMetricProvidersMetricProviderServiceUpdown;
    uptimerobot: outputs.GetMetricProvidersMetricProviderServiceUptimerobot;
    webhook: outputs.GetMetricProvidersMetricProviderServiceWebhook;
}

export interface GetMetricProvidersMetricProviderServiceBuiltin {
}

export interface GetMetricProvidersMetricProviderServiceDns {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    nameservers: string[];
    percentageRegionsFailedThreshold: number;
    recordType: string;
    regions: string[];
    responseContainment: string;
    responsesMustContains: string[];
    target: string;
    timeout: number;
}

export interface GetMetricProvidersMetricProviderServiceHttp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    followRedirects: boolean;
    frequency: number;
    headers: {[key: string]: string};
    password: string;
    percentageRegionsFailedThreshold: number;
    regions: string[];
    responseBodyMustContain: string;
    responseBodyMustContainMode: string;
    responseCodeMustBe: number;
    sslVerifyPeer: boolean;
    target: string;
    timeout: number;
    username: string;
}

export interface GetMetricProvidersMetricProviderServiceIcmp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageFailedThreshold: number;
    percentageRegionsFailedThreshold: number;
    regions: string[];
    target: string;
    timeout: number;
}

export interface GetMetricProvidersMetricProviderServicePingdom {
    apiToken: string;
    checkId: string;
    checkType: string;
}

export interface GetMetricProvidersMetricProviderServiceTcp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageRegionsFailedThreshold: number;
    port: number;
    regions: string[];
    responseMustContain: string;
    responseMustContainMode: string;
    sendData: string;
    target: string;
    timeout: number;
    waitForInitialResponse: boolean;
}

export interface GetMetricProvidersMetricProviderServiceUdp {
    consecutiveCheckDegradedThreshold: number;
    consecutiveCheckOutageThreshold: number;
    frequency: number;
    ipVersion: string;
    percentageRegionsFailedThreshold: number;
    port: number;
    regions: string[];
    responseMustContain: string;
    responseMustContainMode: string;
    sendData: string;
    target: string;
    timeout: number;
}

export interface GetMetricProvidersMetricProviderServiceUpdown {
    monitorApiKey: string;
    monitorToken: string;
}

export interface GetMetricProvidersMetricProviderServiceUptimerobot {
    monitorApiKey: string;
}

export interface GetMetricProvidersMetricProviderServiceWebhook {
    webhookKey: string;
}

export interface IssueSchedule {
    /**
     * Whether this scheduled Issue has ended.
     */
    ended: boolean;
    /**
     * The time at which this scheduled Issue will end.
     */
    endsAt: string;
    /**
     * The ObjectId of this Schedule.
     */
    id: string;
    /**
     * Whether this scheduled Issue has fired an `issue_upcoming` notification.
     */
    notified: boolean;
    /**
     * The time at which this scheduled Issue will fire a "heads-up" `issue_upcoming` notification, informing subscribers that the Issue will begin soon. This field is `null` if the Issue will not be sending an `issue_upcoming` notification.
     *
     * > This field cannot be changed once the Issue has emitted an `issue_upcoming` notification. Consider creating a new Update if you'd like to remind subscribers additional times apart from this automated notification.
     */
    notifySubscribersAt: string;
    /**
     * Whether this scheduled Issue has started.
     */
    started: boolean;
    /**
     * The time at which this scheduled Issue will begin.
     */
    startsAt: string;
}

export interface IssueTemplate {
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `body` of the applied Issue/Update, in the default translation.
     */
    body: string;
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `body` of the applied Issue/Update, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    bodyTranslations: {[key: string]: string};
    /**
     * The ObjectId of this IssueTemplateApplication.
     */
    id: string;
    /**
     * The ObjectId of an IssueTemplate to use as the basis of this Application, which will inform the values for `body`, `label`, and `title` (when `kind = "issue"`). If this value is changed, then the application will be re-created according to the values of the given IssueTemplate.
     */
    issueTemplateId: string;
    /**
     * The template for the `label` of the applied Issue/Update.
     */
    label: string;
    /**
     * An object defining a set of typed variables that can be provided in `variables`. The variables can be accessed from any field in the IssueTemplate supporting Liquid.
     *
     * > This field is normally copied from the underlying `issue_template`, but can be overridden here as necessary. In any case, `variables` must adhere to `schema`.
     */
    schema: {[key: string]: outputs.IssueTemplateSchema};
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `title` of the applied Issue, in the default translation.
     */
    title: string;
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `title` of the applied Issue, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    titleTranslations: {[key: string]: string};
    /**
     * An object of variable assignments used to parameterize the associated IssueTemplate. If the associated IssueTemplate marks a variable as `required`, then it must appear here with an appropriate value. The type of each variable must match the type set in the template's schema.
     */
    variables?: {[key: string]: outputs.IssueTemplateVariables};
}

export interface IssueTemplateSchema {
    /**
     * Whether this variable is required when applying the template to an Issue/Update.
     */
    required: boolean;
    /**
     * The expected type of this variable. One of `datetime`, `i18n-string`, `number`, or `string`.
     */
    type: string;
}

export interface IssueTemplateVariables {
    /**
     * Whether this variable is required when applying the template to an Issue/Update.
     */
    required: boolean;
    /**
     * The expected type of this variable. One of `datetime`, `i18n-string`, `number`, or `string`.
     */
    type: string;
}

export interface IssueUpdate {
    /**
     * This field is unused when embedded in Issues.
     */
    archiveOnDestroy: boolean;
    /**
     * The body text of this Update in raw markdown, in the default translation.
     */
    body: string;
    /**
     * An HTML rendered view of the markdown in `body`, in the default translation.
     */
    bodyHtml: string;
    /**
     * An HTML rendered view of the markdown in `body`, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    bodyHtmlTranslations: {[key: string]: string};
    /**
     * The body text of this Update in raw markdown, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    bodyTranslations: {[key: string]: string};
    /**
     * The timestamp at which this Update was created.
     */
    createdAt: string;
    /**
     * When true, denotes that this Update is the latest update on this Issue (hence, the "effective" Update according to `effective_after`).
     */
    effective: boolean;
    /**
     * The time after which this Update is considered the latest Update on its Issue, until the `effective_after` time of the Update succeeding this one, if one exists.
     */
    effectiveAfter: string;
    /**
     * The ObjectId of this Update.
     */
    id: string;
    /**
     * The Issue that this Update pertains to.
     */
    issueId: string;
    /**
     * The label applied to this update, as well as the issue at large when this Update is the *latest* Update in the Issue. The label can be thought of as the "state" of the Issue as of this Update (e.g. "Problem Identified", "Monitoring", "Resolved").
     */
    label?: string;
    /**
     * Whether this Update reopened the Issue if it was already resolved in an Update before this one.
     */
    reopening: boolean;
    /**
     * The integer state which overrides the state of affected Components in `component`. A value of `null` indicates no override is present.
     */
    stateOverride?: number;
    /**
     * An application of an IssueTemplate, which contains a copy of the template fields of the associated IssueTemplate, as well as an object of user-defined variables that parameterize the template. 
     *
     * > Alterations to this field do not affect the associated `issue_template_id`, and will update the Issue/Update's content accordingly. Conversely, modification/deletion of the associated IssueTemplate do not affect the attributes of this field.
     */
    template?: outputs.IssueUpdateTemplate;
    /**
     * The timestamp at which this Update was last updated.
     */
    updatedAt: string;
}

export interface IssueUpdateTemplate {
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `body` of the applied Issue/Update, in the default translation.
     */
    body: string;
    /**
     * The [Liquid](https://shopify.github.io/liquid/) template for the `body` of the applied Issue/Update, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    bodyTranslations: {[key: string]: string};
    /**
     * The ObjectId of this IssueTemplateApplication.
     */
    id: string;
    /**
     * The ObjectId of an IssueTemplate to use as the basis of this Application, which will inform the values for `body`, `label`, and `title` (when `kind = "issue"`). If this value is changed, then the application will be re-created according to the values of the given IssueTemplate.
     */
    issueTemplateId: string;
    /**
     * The template for the `label` of the applied Issue/Update.
     */
    label: string;
    /**
     * An object defining a set of typed variables that can be provided in `variables`. The variables can be accessed from any field in the IssueTemplate supporting Liquid.
     *
     * > This field is normally copied from the underlying `issue_template`, but can be overridden here as necessary. In any case, `variables` must adhere to `schema`.
     */
    schema: {[key: string]: outputs.IssueUpdateTemplateSchema};
    /**
     * An object of variable assignments used to parameterize the associated IssueTemplate. If the associated IssueTemplate marks a variable as `required`, then it must appear here with an appropriate value. The type of each variable must match the type set in the template's schema.
     */
    variables?: {[key: string]: outputs.IssueUpdateTemplateVariables};
}

export interface IssueUpdateTemplateSchema {
    /**
     * Whether this variable is required when applying the template to an Issue/Update.
     */
    required: boolean;
    /**
     * The expected type of this variable. One of `datetime`, `i18n-string`, `number`, or `string`.
     */
    type: string;
}

export interface IssueUpdateTemplateVariables {
    datetime?: string;
    i18nString?: {[key: string]: string};
    number?: number;
    string?: string;
}

export interface MetricProviderInstances {
    /**
     * The kind of aggregation method to use in case multiple displayed data points share the same time-axis value (depending on the axis configured for time, by default x).
     *
     * > this field does not have any effect on the underlying data; it is purely cosmetic, and applied only when viewing the data on the status page.
     */
    aggregation: string;
    /**
     * A descriptive string that identifies the metric definition this instance derives from (e.g. `http.tcp_connection_time`, `apdex`, etc.).
     */
    definitionSlug: string;
    /**
     * Whether or not to show this metric on the Component that uses it (through the Watchdog).
     */
    enabled: boolean;
    /**
     * The ObjectId of this MetricInstance.
     */
    id: string;
    /**
     * The kind of interpolation to use between points displayed in the graph (line plots only). One of `linear`, `step`, `basis`, `bundle`, or `cardinal`.
     */
    interpolation: string;
    /**
     * The kind of visualization to display the metric with. One of `line` or `bar`.
     */
    plotType: string;
    /**
     * A string that uniquely identifies this MetricInstance by referencing the `definition_slug` and MetricProvider `id`.
     */
    slug: string;
    /**
     * The title of the metric, displayed above its graph on the status page, in the default translation.
     */
    title: string;
    /**
     * The title of the metric, displayed above its graph on the status page, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    titleTranslations: {[key: string]: string};
    /**
     * Whether or not to show this metric on the status page home.
     */
    topLevelEnabled: boolean;
    /**
     * The title of the x-axis of this metric, in the default translation.
     */
    xTitle: string;
    /**
     * The title of the x-axis of this metric, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    xTitleTranslations: {[key: string]: string};
    /**
     * The type of quantity represented by the x-axis. One of `time` or `measure`.
     */
    xType: string;
    /**
     * The least upper bound to display the y-axis on. The metric will always display up to at least this value on the y-axis regardless of the graphed data. If the graph exceeds this value, then the bound will be raised as much as necessary to accommodate the data.
     */
    ySupremum: number;
    /**
     * The title of the y-axis of this metric, in the default translation.
     */
    yTitle: string;
    /**
     * The title of the y-axis of this metric, translated into multiple languages. Map keys express the language each string value is to be interpreted in. The `original` field of this map denotes the language used for the non-`_translations` version of this attribute.
     */
    yTitleTranslations: {[key: string]: string};
    /**
     * The type of quantity represented by the y-axis. One of `time` or `measure`.
     */
    yType: string;
}

export interface MetricProviderService {
    /**
     * The builtin Hund metric provider, which provides metrics based on recorded uptime and incidents.
     */
    builtin?: outputs.MetricProviderServiceBuiltin;
    /**
     * A Hund Native Monitoring DNS Check.
     */
    dns?: outputs.MetricProviderServiceDns;
    /**
     * A Hund Native Monitoring HTTP Check.
     */
    http?: outputs.MetricProviderServiceHttp;
    /**
     * A Hund Native Monitoring ICMP Check.
     */
    icmp?: outputs.MetricProviderServiceIcmp;
    /**
     * A [pingdom](https://www.pingdom.com) service.
     */
    pingdom?: outputs.MetricProviderServicePingdom;
    /**
     * A Hund Native Monitoring TCP Check.
     */
    tcp?: outputs.MetricProviderServiceTcp;
    /**
     * A Hund Native Monitoring UDP Check.
     */
    udp?: outputs.MetricProviderServiceUdp;
    /**
     * An [Updown.io](https://updown.io) service.
     */
    updown?: outputs.MetricProviderServiceUpdown;
    /**
     * An [Uptime Robot](https://uptimerobot.com) service.
     */
    uptimerobot?: outputs.MetricProviderServiceUptimerobot;
    /**
     * A [webhook](https://hund.io/help/documentation/incoming-webhook-metrics) service.
     */
    webhook?: outputs.MetricProviderServiceWebhook;
}

export interface MetricProviderServiceBuiltin {
}

export interface MetricProviderServiceDns {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * An optional list of nameservers to make DNS queries with. This field is
     * ignored by SOA queries since they use the nameservers yielded by querying NS
     * on the target.
     */
    nameservers?: string[];
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The type of DNS record to query for on the target.
     */
    recordType: string;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * Whether `all` of the assertions in `responses_must_contain` must match the DNS response,
     * or rather just `any` of them (i.e. at least one).
     */
    responseContainment?: string;
    /**
     * A set of assertions to make against the records yielded by the query. The
     * format of these assertions is *similar* to DNS record syntax, but is
     * slightly simplified and allows for only asserting parts of a record's RDATA,
     * rather than the entire thing. The check will fail depending on the value of
     * `response_containment`.
     *
     *   This field is ignored by the SOA check, as it does not use assertions to
     * determine the validity of SOA records. Instead, we ensure that every
     * nameserver reported by querying NS on the target reports the same SOA serial.
     * If your target's nameservers report conflicting SOA serials, we consider the
     * check failed.
     *
     *   **Example Assertions (for MX record type):**
     * ```json
     * [
     *   "10 mail.example.com",
     *   "spool.example.com",
     *   "mail2.example.com"
     * ]
     * ```
     *
     *   Note above how we can assert both the priority and domain (*without* the
     * terminating period required by canonical DNS) of an MX record, or instead
     * simply the domain.
     */
    responsesMustContains?: string[];
    /**
     * The domain/IP address that will be queried. IP addresses do not need to be
     * converted to the `z.y.x.w.in-addr.arpa` format, as this will be done
     * automatically; however, both formats are accepted.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface MetricProviderServiceHttp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * Follow any HTTP redirects given by the requested target. Please note that this check will only follow up to 9 redirects.
     */
    followRedirects: boolean;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * A list of additional HTTP headers to send to the target. The following list of
     * header names are reserved and cannot be set by a check:
     *
     * ```
     * Accept-Charset
     * Accept-Encoding
     * Authentication
     * Connection
     * Content-Length
     * Date
     * Host
     * Keep-Alive
     * Origin
     * Proxy-.*
     * Sec-.*
     * Referer
     * TE
     * Trailer
     * Transfer-Encoding
     * User-Agent
     * Via
     * ```
     */
    headers: {[key: string]: string};
    /**
     * An optional HTTP Basic Authentication password.
     */
    password?: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by
     * `response_body_must_contain_mode`):
     *
     *   `exact`: If the requested page does not contain this exact (case-sensitive)
     * string, then the check will fail.
     *
     *   `regex`: If the requested page does not match against the given regex, then
     * the check will fail. [Click here](https://hund.io/help/documentation/regular-expressions) for
     * more information on the use and supported syntax of Hund regexes.
     */
    responseBodyMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_body_must_contain`.
     */
    responseBodyMustContainMode: string;
    /**
     * If the requested page does not return this response code, then the check will
     * fail.
     */
    responseCodeMustBe?: number;
    /**
     * Require the target's TLS certificate to be valid.
     */
    sslVerifyPeer: boolean;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
    /**
     * An optional HTTP Basic Authentication username.
     */
    username?: string;
}

export interface MetricProviderServiceIcmp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when pinging.
     */
    ipVersion: string;
    /**
     * The percentage of addresses at the given target that must fail for a region to be counted as failed. This option only matters when there are multiple IP addresses behind the target when the target is a domain.
     */
    percentageFailedThreshold: number;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface MetricProviderServicePingdom {
    /**
     * The Pingdom API v3 key.
     */
    apiToken: string;
    /**
     * The ID of the check to pull status from on Pingdom.
     */
    checkId: string;
    /**
     * The type of the Pingdom check. `check` denotes a normal Pingdom uptime check, and `transactional` denotes a Pingdom TMS check.
     */
    checkType: string;
}

export interface MetricProviderServiceTcp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when calling the target.
     */
    ipVersion: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The port at the target to connect to.
     */
    port: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by `response_must_contain_mode`):
     *
     *   `exact`: Text that the response from the target must contain exactly
     * (case-sensitive). In exact match mode, this field supports
     * [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     *
     *   `regex`: A regex that the response from the target must match against.
     * [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
     * the use and supported syntax of Hund regexes.
     *
     *   If you send data and expect the target to reply, you must populate this field.
     * Leaving this field blank will prevent the check from receiving data from the
     * target unless forced to wait for an initial response.
     *
     *   The "response" from the target that this text is asserted against will be the
     * response from the target *after* sending data. If data is not sent to the
     * target, this text is asserted against the *initial* response.
     */
    responseMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_must_contain`.
     */
    responseMustContainMode: string;
    /**
     * Optional data to send to the target after connecting. If this field is left
     * blank, nothing is sent to the target after connecting. This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     */
    sendData?: string;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
    /**
     * Whether or not to wait for an initial response from the target before sending
     * data or closing the connection.
     */
    waitForInitialResponse?: boolean;
}

export interface MetricProviderServiceUdp {
    /**
     * The number of consecutive failed checks required before posting a "degraded"
     * status.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When `null`, denotes that this check will not use a "degraded" stage
     * when encountering check failures.
     *
     *   When 0, denotes that this check will post "degraded" upon the first check failure.
     */
    consecutiveCheckDegradedThreshold?: number;
    /**
     * The number of consecutive failed checks required before posting an "outage"
     * status. If `consecutive_check_degraded_threshold` is non-null, then the outage
     * will only be posted after degraded has posted according to its own threshold.
     *
     *   Note that regardless of threshold settings, a component will post "operational"
     * whenever a check succeeds, thus resetting the consecutive check failure count.
     *
     *   When 0, denotes that this check will post "outage" upon the first check failure
     * (or the first check failure after "degraded" has been posted in case
     * `consecutive_check_degraded_threshold` is set).
     */
    consecutiveCheckOutageThreshold: number;
    /**
     * The frequency of the check in milliseconds. The maximum frequency is every 30
     * seconds.
     *
     * > Any frequency greater than every 60 seconds will force the component
     * to become High-Frequency, at an additional cost. For specific pricing
     * information, please visit the [pricing](https://hund.io/pricing) page.
     */
    frequency: number;
    /**
     * The IP version to use when calling the target.
     */
    ipVersion: string;
    /**
     * The percentage of regions that must report a failed check before the entire
     * check can be considered failed. Requiring at least two regions for this
     * threshold is recommended in order to confirm failures across regions.
     */
    percentageRegionsFailedThreshold: number;
    /**
     * The port at the target to connect to.
     */
    port: number;
    /**
     * The regions you would like the target to be checked from. All regions are
     * weighted equally when calculating the outcome of a check. Currently, a single
     * check can use up to 8 regions simultaneously. Using at least two regions for a
     * single check is recommended in order to confirm failures across regions.
     *
     * > Each check may use up to **three** regions at no extra cost. Each region added to this check beyond the base three will incur an additional cost. For specific pricing information, please visit the [pricing](https://hund.io/pricing) page.
     */
    regions: string[];
    /**
     * This field supports two different matching modes (given by `response_must_contain_mode`):
     *
     *   `exact`: Text that the response from the target must contain exactly
     * (case-sensitive). In exact match mode, this field supports
     * [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     *
     *   `regex`: A regex that the response from the target must match against.
     * [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
     * the use and supported syntax of Hund regexes.
     *
     *   Leaving this field blank will still cause the check to wait for a response
     * from the target after sending data, though no assertions will be made about
     * the payload of the response.
     */
    responseMustContain?: string;
    /**
     * The response containment mode; either `exact` or `regex`. The modes are discussed
     * under `response_must_contain`.
     */
    responseMustContainMode: string;
    /**
     * Data to send to the target after connecting. Unlike in `tcp`, this
     * field is required. This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
     */
    sendData: string;
    /**
     * The host the check will make calls to.
     */
    target: string;
    /**
     * The maximum number of milliseconds the check should wait on the host before
     * failing.
     */
    timeout: number;
}

export interface MetricProviderServiceUpdown {
    /**
     * An Updown.io monitor API key. This API key can be read-only.
     */
    monitorApiKey: string;
    /**
     * An Updown.io monitor token to retrieve status from.
     */
    monitorToken: string;
}

export interface MetricProviderServiceUptimerobot {
    /**
     * An Uptime Robot monitor API key to retrieve status from.
     */
    monitorApiKey: string;
}

export interface MetricProviderServiceWebhook {
    /**
     * The key to use for this webhook, expected in request headers.
     */
    webhookKey: string;
}

