// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetConnectorConnector {
    /**
     * the actual (Linux network) device name of the external connector.
     */
    deviceName: string;
    /**
     * External connector identifier, a UUID.
     */
    id: string;
    /**
     * The label of the external connector, like "NAT" or "System Bridge".
     */
    label: string;
    /**
     * Whether the connector is protected, e.g. BPDUs are filtered or not.
     */
    protected: boolean;
    /**
     * True if the IP address snooper listens on this connector.
     */
    snooped: boolean;
    /**
     * The external connector tag set.
     */
    tags: string[];
}

export interface GetGroupsGroup {
    /**
     * Description of the group.
     */
    description: string;
    /**
     * Group ID (UUID).
     */
    id: string;
    /**
     * Set of labs with their permission which are associated to this group.
     */
    labs: outputs.GetGroupsGroupLab[];
    /**
     * Set of user IDs who are members of this group.
     */
    members: string[];
    /**
     * Descriptive group name.
     */
    name: string;
}

export interface GetGroupsGroupLab {
    /**
     * Lab ID (UUID).
     */
    id: string;
    /**
     * Permission.
     */
    permission: string;
}

export interface GetImagesImageList {
    /**
     * Image specific boot disk size, can be null
     */
    bootDiskSize: number;
    /**
     * Image specific CPU limit, can be null
     */
    cpuLimit: number;
    /**
     * Image specific amount of CPUs, can be null
     */
    cpus: number;
    /**
     * Image specific data volume size, can be null
     */
    dataVolume: number;
    /**
     * Description of this image definition
     */
    description: string;
    /**
     * ID to identifying the image
     */
    id: string;
    /**
     * Text label of this image definition
     */
    label: string;
    /**
     * ID of the node definition this image belongs to
     */
    nodedefinition: string;
    /**
     * Image specific RAM value, can be null
     */
    ram: number;
    /**
     * Is this image definition read only?
     */
    readOnly: boolean;
    /**
     * Version of the image definition schemage
     */
    schemaVersion: string;
}

export interface GetLabLab {
    /**
     * Creation date/time string in ISO8601 format.
     */
    created: string;
    /**
     * Lab description.
     */
    description: string;
    /**
     * Groups assigned to the lab.
     */
    groups: outputs.GetLabLabGroup[];
    /**
     * Lab identifier, a UUID.
     */
    id: string;
    /**
     * Number of links in the lab.
     */
    linkCount: number;
    /**
     * Modification date/time string in ISO8601 format.
     */
    modified: string;
    /**
     * Number of nodes in the lab.
     */
    nodeCount: number;
    /**
     * Lab notes.
     */
    notes: string;
    /**
     * Owner of the lab, a UUID4.
     */
    owner: string;
    /**
     * Lab state, one of `DEFINED_ON_CORE`, `STARTED` or `STOPPED`.
     */
    state: string;
    /**
     * Title of the lab.
     */
    title: string;
}

export interface GetLabLabGroup {
    /**
     * Group ID (UUID).
     */
    id: string;
    /**
     * Descriptive group name.
     */
    name: string;
    /**
     * Permission, either `read_only` or `read_write`.
     */
    permission: string;
}

export interface GetNodeNode {
    /**
     * Size of boot disk volume, in GB. Can be changed until the node is started once. Will require a replace in that case.
     */
    bootDiskSize: number;
    /**
     * ID of a compute this node is on, a UUID4.
     */
    computeId: string;
    /**
     * Node configuration. Can be changed until the node is started once. Will require a replace in that case.
     */
    configuration: string;
    /**
     * List of node configurations. Can be changed until the node is started once. Will require a replace in that case. Note that this requires the `named_configs` provider setting and also at least CML 2.7.0. Using `configuration` and `configurations` is mutually exclusive!
     */
    configurations: outputs.GetNodeNodeConfiguration[];
    /**
     * CPU limit in %, 20-100. Can be changed until the node is started once. Will require a replace in that case.
     */
    cpuLimit: number;
    /**
     * Number of CPUs. Can be changed until the node is started once. Will require a replace in that case.
     */
    cpus: number;
    /**
     * Size of data volume, in GB. Can be changed until the node is started once. Will require a replace in that case.
     */
    dataVolume: number;
    /**
     * If true, links are not shown in the topology. This is a visual cue and does not influence any simulation function.
     */
    hideLinks: boolean;
    /**
     * Node ID (UUID).
     */
    id: string;
    /**
     * Image definition, must match the node type. Can be changed until the node is started once. Will require a replace in that case.
     */
    imagedefinition: string;
    /**
     * List of interfaces on the node.
     */
    interfaces: outputs.GetNodeNodeInterface[];
    /**
     * Lab ID containing the node (UUID).
     */
    labId: string;
    /**
     * Node label.
     */
    label: string;
    /**
     * Node definition / type. This can only be set at create time.
     */
    nodedefinition: string;
    /**
     * Amount of RAM, megabytes. Can be changed until the node is started once. Will require a replace in that case.
     */
    ram: number;
    /**
     * List of serial devices (consoles).
     */
    serialDevices: outputs.GetNodeNodeSerialDevice[];
    /**
     * Node state (`DEFINED_ON_CORE`, `STOPPED`, `STARTED`, `BOOTED`).
     */
    state: string;
    /**
     * Set of tags of the node.
     */
    tags: string[];
    /**
     * VNC key of console, a UUID4.
     */
    vncKey: string;
    /**
     * X coordinate on the topology canvas.
     */
    x: number;
    /**
     * Y coordinate on the topology canvas.
     */
    y: number;
}

export interface GetNodeNodeConfiguration {
    content: string;
    name: string;
}

export interface GetNodeNodeInterface {
    /**
     * Interface ID (UUID).
     */
    id: string;
    /**
     * IPv4 address list.
     */
    ip4s: string[];
    /**
     * IPv6 address list.
     */
    ip6s: string[];
    /**
     * Is the interface connected to a link?
     */
    isConnected: boolean;
    /**
     * Interface label.
     */
    label: string;
    /**
     * MAC address.
     */
    macAddress: string;
    /**
     * interface state (`UP` or `DOWN`).
     */
    state: string;
}

export interface GetNodeNodeSerialDevice {
    consoleKey: string;
    deviceNumber: number;
}

export interface GetUsersUser {
    /**
     * Description of the user.
     */
    description: string;
    /**
     * Directory DN of the user (when using LDAP).
     */
    directoryDn: string;
    /**
     * E-mail address of the user.
     */
    email: string;
    /**
     * Full name of the user.
     */
    fullname: string;
    /**
     * Set of group IDs where the user is member of.
     */
    groups: string[];
    /**
     * User ID (UUID).
     */
    id: string;
    /**
     * True if the user has admin rights.
     */
    isAdmin: boolean;
    /**
     * Set of lab IDs the user owns.
     */
    labs: string[];
    /**
     * True if has opted in to sending telemetry data.
     */
    optIn: boolean;
    /**
     * Password of the user.
     */
    password: string;
    /**
     * Resource pool ID, if any.
     */
    resourcePool: string;
    /**
     * Login name of the user.
     */
    username: string;
}

export interface GroupLab {
    /**
     * Lab ID (UUID).
     */
    id: string;
    /**
     * Permission.
     */
    permission: string;
}

export interface LabGroup {
    /**
     * Group ID (UUID).
     */
    id: string;
    /**
     * Descriptive group name.
     */
    name: string;
    /**
     * Permission, either `read_only` or `read_write`.
     */
    permission: string;
}

export interface LifecycleNamedConfigs {
    content: string;
    name: string;
}

export interface LifecycleNodes {
    /**
     * Size of boot disk volume, in GB. Can be changed until the node is started once. Will require a replace in that case.
     */
    bootDiskSize: number;
    /**
     * ID of a compute this node is on, a UUID4.
     */
    computeId: string;
    /**
     * Node configuration. Can be changed until the node is started once. Will require a replace in that case.
     */
    configuration: string;
    /**
     * List of node configurations. Can be changed until the node is started once. Will require a replace in that case. Note that this requires the `named_configs` provider setting and also at least CML 2.7.0. Using `configuration` and `configurations` is mutually exclusive!
     */
    configurations: outputs.LifecycleNodesConfiguration[];
    /**
     * CPU limit in %, 20-100. Can be changed until the node is started once. Will require a replace in that case.
     */
    cpuLimit: number;
    /**
     * Number of CPUs. Can be changed until the node is started once. Will require a replace in that case.
     */
    cpus: number;
    /**
     * Size of data volume, in GB. Can be changed until the node is started once. Will require a replace in that case.
     */
    dataVolume: number;
    /**
     * If true, links are not shown in the topology. This is a visual cue and does not influence any simulation function.
     */
    hideLinks: boolean;
    /**
     * Node ID (UUID).
     */
    id: string;
    /**
     * Image definition, must match the node type. Can be changed until the node is started once. Will require a replace in that case.
     */
    imagedefinition: string;
    /**
     * List of interfaces on the node.
     */
    interfaces: outputs.LifecycleNodesInterface[];
    /**
     * Lab ID containing the node (UUID).
     */
    labId: string;
    /**
     * Node label.
     */
    label: string;
    /**
     * Node definition / type. This can only be set at create time.
     */
    nodedefinition: string;
    /**
     * Amount of RAM, megabytes. Can be changed until the node is started once. Will require a replace in that case.
     */
    ram: number;
    /**
     * List of serial devices (consoles).
     */
    serialDevices: outputs.LifecycleNodesSerialDevice[];
    /**
     * Node state (`DEFINED_ON_CORE`, `STOPPED`, `STARTED`, `BOOTED`).
     */
    state: string;
    /**
     * Set of tags of the node.
     */
    tags: string[];
    /**
     * VNC key of console, a UUID4.
     */
    vncKey: string;
    /**
     * X coordinate on the topology canvas.
     */
    x: number;
    /**
     * Y coordinate on the topology canvas.
     */
    y: number;
}

export interface LifecycleNodesConfiguration {
    content: string;
    name: string;
}

export interface LifecycleNodesInterface {
    /**
     * Interface ID (UUID).
     */
    id: string;
    /**
     * IPv4 address list.
     */
    ip4s: string[];
    /**
     * IPv6 address list.
     */
    ip6s: string[];
    /**
     * Is the interface connected to a link?
     */
    isConnected: boolean;
    /**
     * Interface label.
     */
    label: string;
    /**
     * MAC address.
     */
    macAddress: string;
    /**
     * interface state (`UP` or `DOWN`).
     */
    state: string;
}

export interface LifecycleNodesSerialDevice {
    consoleKey: string;
    deviceNumber: number;
}

export interface LifecycleStaging {
    /**
     * Ordered list of node tags, controls node launch. Nodes currently not launched will be launched in the stage with the matching tag. Tags must match exactly.
     */
    stages: string[];
    /**
     * If set to `true` (which is the default) then all nodes which are not matched by the stages list and which are still unstarted after running all stages will be started.
     */
    startRemaining?: boolean;
}

export interface LifecycleTimeouts {
    /**
     * Create timeout.
     */
    create: string;
    /**
     * Delete timeout (currently unused).
     */
    delete?: string;
    /**
     * Update timeout.
     */
    update: string;
}

export interface NodeConfiguration {
    content: string;
    name: string;
}

export interface NodeInterface {
    /**
     * Interface ID (UUID).
     */
    id: string;
    /**
     * IPv4 address list.
     */
    ip4s: string[];
    /**
     * IPv6 address list.
     */
    ip6s: string[];
    /**
     * Is the interface connected to a link?
     */
    isConnected: boolean;
    /**
     * Interface label.
     */
    label: string;
    /**
     * MAC address.
     */
    macAddress: string;
    /**
     * interface state (`UP` or `DOWN`).
     */
    state: string;
}

export interface NodeSerialDevice {
    consoleKey: string;
    deviceNumber: number;
}

