// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AuthBackendTune {
    allowedResponseHeaders: string[];
    auditNonHmacRequestKeys: string[];
    auditNonHmacResponseKeys: string[];
    defaultLeaseTtl: string;
    listingVisibility: string;
    maxLeaseTtl: string;
    passthroughRequestHeaders: string[];
    tokenType: string;
}

export interface AzureSecretBackendRoleAzureGroup {
    groupName: string;
    objectId: string;
}

export interface AzureSecretBackendRoleAzureRole {
    roleId: string;
    roleName: string;
    scope: string;
}

export interface ConfigUiCustomMessageLink {
    /**
     * The URL of the hyperlink
     */
    href: string;
    /**
     * The title of the hyperlink
     */
    title: string;
}

export interface DatabaseSecretBackendConnectionCassandra {
    /**
     * The number of seconds to use as a connection timeout.
     */
    connectTimeout?: number;
    /**
     * Cassandra hosts to connect to.
     */
    hosts?: string[];
    /**
     * Whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * The password to use when authenticating with Cassandra.
     */
    password?: string;
    /**
     * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemBundle?: string;
    /**
     * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemJson?: string;
    /**
     * The transport port to use to connect to Cassandra.
     */
    port?: number;
    /**
     * The CQL protocol version to use.
     */
    protocolVersion?: number;
    /**
     * Whether to use TLS when connecting to Cassandra.
     */
    tls?: boolean;
    /**
     * The username to use when authenticating with Cassandra.
     */
    username?: string;
}

export interface DatabaseSecretBackendConnectionCouchbase {
    /**
     * Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.
     */
    base64Pem?: string;
    /**
     * Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.
     */
    bucketName?: string;
    /**
     * A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.
     */
    hosts: string[];
    /**
     * Specifies whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * Specifies whether to use TLS when connecting to Couchbase.
     */
    tls?: boolean;
    /**
     * Specifies the username for Vault to use.
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionElasticsearch {
    /**
     * The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity
     */
    caCert?: string;
    /**
     * The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity
     */
    caPath?: string;
    /**
     * The path to the certificate for the Elasticsearch client to present for communication
     */
    clientCert?: string;
    /**
     * The path to the key for the Elasticsearch client to use for communication
     */
    clientKey?: string;
    /**
     * Whether to disable certificate verification
     */
    insecure?: boolean;
    /**
     * The password to be used in the connection URL
     */
    password: string;
    /**
     * This, if set, is used to set the SNI host when connecting via TLS
     */
    tlsServerName?: string;
    /**
     * The URL for Elasticsearch's API
     */
    url: string;
    /**
     * The username to be used in the connection URL
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionHana {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
}

export interface DatabaseSecretBackendConnectionInfluxdb {
    /**
     * The number of seconds to use as a connection timeout.
     */
    connectTimeout?: number;
    /**
     * Influxdb host to connect to.
     */
    host: string;
    /**
     * Whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemBundle?: string;
    /**
     * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemJson?: string;
    /**
     * The transport port to use to connect to Influxdb.
     */
    port?: number;
    /**
     * Whether to use TLS when connecting to Influxdb.
     */
    tls?: boolean;
    /**
     * Specifies the username to use for superuser access.
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMongodb {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMongodbatlas {
    /**
     * The Private Programmatic API Key used to connect with MongoDB Atlas API.
     */
    privateKey: string;
    /**
     * The Project ID the Database User should be created within.
     */
    projectId: string;
    /**
     * The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.
     */
    publicKey: string;
}

export interface DatabaseSecretBackendConnectionMssql {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Set to true when the target is a Contained Database, e.g. AzureSQL.
     */
    containedDb?: boolean;
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMysql {
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMysqlAurora {
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMysqlLegacy {
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionMysqlRds {
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionOracle {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Set to true to disconnect any open sessions prior to running the revocation statements.
     */
    disconnectSessions?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Set to true in order to split statements after semi-colons.
     */
    splitStatements?: boolean;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionPostgresql {
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionRedis {
    /**
     * The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.
     */
    caCert?: string;
    /**
     * Specifies the host to connect to
     */
    host: string;
    /**
     * Specifies whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * The transport port to use to connect to Redis.
     */
    port?: number;
    /**
     * Specifies whether to use TLS when connecting to Redis.
     */
    tls?: boolean;
    /**
     * Specifies the username for Vault to use.
     */
    username: string;
}

export interface DatabaseSecretBackendConnectionRedisElasticache {
    /**
     * The AWS secret key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
     */
    password?: string;
    /**
     * The AWS region where the ElastiCache cluster is hosted. If omitted the plugin tries to infer the region from the environment.
     */
    region?: string;
    /**
     * The configuration endpoint for the ElastiCache cluster to connect to.
     */
    url: string;
    /**
     * The AWS access key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
     */
    username?: string;
}

export interface DatabaseSecretBackendConnectionRedshift {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretBackendConnectionSnowflake {
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
}

export interface DatabaseSecretsMountCassandra {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * The number of seconds to use as a connection timeout.
     */
    connectTimeout?: number;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Cassandra hosts to connect to.
     */
    hosts?: string[];
    /**
     * Whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The password to use when authenticating with Cassandra.
     */
    password?: string;
    /**
     * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemBundle?: string;
    /**
     * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemJson?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * The transport port to use to connect to Cassandra.
     */
    port?: number;
    /**
     * The CQL protocol version to use.
     */
    protocolVersion?: number;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Whether to use TLS when connecting to Cassandra.
     */
    tls?: boolean;
    /**
     * The username to use when authenticating with Cassandra.
     */
    username?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountCouchbase {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Required if `tls` is `true`. Specifies the certificate authority of the Couchbase server, as a PEM certificate that has been base64 encoded.
     */
    base64Pem?: string;
    /**
     * Required for Couchbase versions prior to 6.5.0. This is only used to verify vault's connection to the server.
     */
    bucketName?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * A set of Couchbase URIs to connect to. Must use `couchbases://` scheme if `tls` is `true`.
     */
    hosts: string[];
    /**
     * Specifies whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Specifies whether to use TLS when connecting to Couchbase.
     */
    tls?: boolean;
    /**
     * Specifies the username for Vault to use.
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountElasticsearch {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * The path to a PEM-encoded CA cert file to use to verify the Elasticsearch server's identity
     */
    caCert?: string;
    /**
     * The path to a directory of PEM-encoded CA cert files to use to verify the Elasticsearch server's identity
     */
    caPath?: string;
    /**
     * The path to the certificate for the Elasticsearch client to present for communication
     */
    clientCert?: string;
    /**
     * The path to the key for the Elasticsearch client to use for communication
     */
    clientKey?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Whether to disable certificate verification
     */
    insecure?: boolean;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The password to be used in the connection URL
     */
    password: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * This, if set, is used to set the SNI host when connecting via TLS
     */
    tlsServerName?: string;
    /**
     * The URL for Elasticsearch's API
     */
    url: string;
    /**
     * The username to be used in the connection URL
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountHana {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountInfluxdb {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * The number of seconds to use as a connection timeout.
     */
    connectTimeout?: number;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Influxdb host to connect to.
     */
    host: string;
    /**
     * Whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemBundle?: string;
    /**
     * Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
     */
    pemJson?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * The transport port to use to connect to Influxdb.
     */
    port?: number;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Whether to use TLS when connecting to Influxdb.
     */
    tls?: boolean;
    /**
     * Specifies the username to use for superuser access.
     */
    username: string;
    /**
     * Template describing how dynamic usernames are generated.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMongodb {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMongodbatla {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * The Private Programmatic API Key used to connect with MongoDB Atlas API.
     */
    privateKey: string;
    /**
     * The Project ID the Database User should be created within.
     */
    projectId: string;
    /**
     * The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.
     */
    publicKey: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMssql {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * Set to true when the target is a Contained Database, e.g. AzureSQL.
     */
    containedDb?: boolean;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMysql {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMysqlAurora {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMysqlLegacy {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountMysqlRd {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * x509 CA file for validating the certificate presented by the MySQL server. Must be PEM encoded.
     */
    tlsCa?: string;
    /**
     * x509 certificate for connecting to the database. This must be a PEM encoded version of the private key and the certificate combined.
     */
    tlsCertificateKey?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountOracle {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Set to true to disconnect any open sessions prior to running the revocation statements.
     */
    disconnectSessions?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Set to true in order to split statements after semi-colons.
     */
    splitStatements?: boolean;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountPostgresql {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Specify alternative authorization type. (Only 'gcp_iam' is valid currently)
     */
    authType?: string;
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * A JSON encoded credential for use with IAM authorization
     */
    serviceAccountJson?: string;
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountRedi {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * The contents of a PEM-encoded CA cert file to use to verify the Redis server's identity.
     */
    caCert?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Specifies the host to connect to
     */
    host: string;
    /**
     * Specifies whether to skip verification of the server certificate when using TLS.
     */
    insecureTls?: boolean;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * Specifies the password corresponding to the given username.
     */
    password: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * The transport port to use to connect to Redis.
     */
    port?: number;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * Specifies whether to use TLS when connecting to Redis.
     */
    tls?: boolean;
    /**
     * Specifies the username for Vault to use.
     */
    username: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountRedisElasticach {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The AWS secret key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * The AWS region where the ElastiCache cluster is hosted. If omitted the plugin tries to infer the region from the environment.
     */
    region?: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The configuration endpoint for the ElastiCache cluster to connect to.
     */
    url: string;
    /**
     * The AWS access key id to use to talk to ElastiCache. If omitted the credentials chain provider is used instead.
     */
    username?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountRedshift {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Disable special character escaping in username and password
     */
    disableEscaping?: boolean;
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface DatabaseSecretsMountSnowflake {
    /**
     * A list of roles that are allowed to use this connection.
     */
    allowedRoles?: string[];
    /**
     * Connection string to use to connect to the database.
     */
    connectionUrl?: string;
    /**
     * A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
     */
    data?: {[key: string]: string};
    /**
     * Maximum number of seconds a connection may be reused.
     */
    maxConnectionLifetime?: number;
    /**
     * Maximum number of idle connections to the database.
     */
    maxIdleConnections?: number;
    /**
     * Maximum number of open connections to the database.
     */
    maxOpenConnections?: number;
    /**
     * Name of the database connection.
     */
    name: string;
    /**
     * The root credential password used in the connection URL
     */
    password?: string;
    /**
     * Specifies the name of the plugin to use for this connection. Must be prefixed with the name of one of the supported database engine types.
     */
    pluginName: string;
    /**
     * A list of database statements to be executed to rotate the root user's credentials.
     */
    rootRotationStatements?: string[];
    /**
     * The root credential username used in the connection URL
     */
    username?: string;
    /**
     * Username generation template.
     */
    usernameTemplate?: string;
    /**
     * Specifies if the connection is verified during initial configuration.
     */
    verifyConnection?: boolean;
}

export interface GcpAuthBackendCustomEndpoint {
    /**
     * Replaces the service endpoint used in API requests to https://www.googleapis.com.
     */
    api?: string;
    /**
     * Replaces the service endpoint used in API requests to `https://compute.googleapis.com`.
     */
    compute?: string;
    /**
     * Replaces the service endpoint used in API requests to `https://cloudresourcemanager.googleapis.com`.
     */
    crm?: string;
    /**
     * Replaces the service endpoint used in API requests to `https://iam.googleapis.com`.
     */
    iam?: string;
}

export interface GcpAuthBackendTune {
    allowedResponseHeaders: string[];
    auditNonHmacRequestKeys: string[];
    auditNonHmacResponseKeys: string[];
    defaultLeaseTtl: string;
    listingVisibility: string;
    maxLeaseTtl: string;
    passthroughRequestHeaders: string[];
    tokenType: string;
}

export interface GcpSecretRolesetBinding {
    /**
     * Resource name
     */
    resource: string;
    /**
     * List of roles to apply to the resource
     */
    roles: string[];
}

export interface GcpSecretStaticAccountBinding {
    /**
     * Resource name
     */
    resource: string;
    /**
     * List of roles to apply to the resource
     */
    roles: string[];
}

export interface GetIdentityEntityAlias {
    canonicalId: string;
    creationTime: string;
    id: string;
    lastUpdateTime: string;
    mergedFromCanonicalIds: string[];
    metadata: {[key: string]: string};
    mountAccessor: string;
    mountPath: string;
    mountType: string;
    name: string;
}

export interface GetPkiSecretBackendConfigEstAuthenticator {
    cert: {[key: string]: string};
    userpass: {[key: string]: string};
}

export interface GetPolicyDocumentRule {
    allowedParameters?: outputs.GetPolicyDocumentRuleAllowedParameter[];
    capabilities: string[];
    deniedParameters?: outputs.GetPolicyDocumentRuleDeniedParameter[];
    description?: string;
    maxWrappingTtl?: string;
    minWrappingTtl?: string;
    path: string;
    requiredParameters?: string[];
}

export interface GetPolicyDocumentRuleAllowedParameter {
    key: string;
    values: string[];
}

export interface GetPolicyDocumentRuleDeniedParameter {
    key: string;
    values: string[];
}

export interface GithubAuthBackendTune {
    allowedResponseHeaders: string[];
    auditNonHmacRequestKeys: string[];
    auditNonHmacResponseKeys: string[];
    defaultLeaseTtl: string;
    listingVisibility: string;
    maxLeaseTtl: string;
    passthroughRequestHeaders: string[];
    tokenType: string;
}

export interface JwtAuthBackendTune {
    allowedResponseHeaders: string[];
    auditNonHmacRequestKeys: string[];
    auditNonHmacResponseKeys: string[];
    defaultLeaseTtl: string;
    listingVisibility: string;
    maxLeaseTtl: string;
    passthroughRequestHeaders: string[];
    tokenType: string;
}

export interface KvSecretV2CustomMetadata {
    /**
     * If true, all keys will require the cas parameter to be set on all write requests.
     */
    casRequired?: boolean;
    /**
     * A map of arbitrary string to string valued user-provided metadata meant to describe the secret.
     */
    data?: {[key: string]: string};
    /**
     * If set, specifies the length of time before a version is deleted.
     */
    deleteVersionAfter?: number;
    /**
     * The number of versions to keep per key.
     */
    maxVersions?: number;
}

export interface ManagedKeysAw {
    /**
     * The AWS access key to use
     */
    accessKey: string;
    /**
     * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
     */
    allowGenerateKey: boolean;
    /**
     * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
     */
    allowReplaceKey: boolean;
    /**
     * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
     */
    allowStoreKey: boolean;
    /**
     * Allow usage from any mount point within the namespace if 'true'
     */
    anyMount: boolean;
    /**
     * The curve to use for an ECDSA key. Used when key_type is 'ECDSA'. Required if 'allow_generate_key' is true
     */
    curve?: string;
    /**
     * Used to specify a custom AWS endpoint
     */
    endpoint?: string;
    /**
     * The size in bits for an RSA key. This field is required when 'key_type' is 'RSA'
     */
    keyBits: string;
    /**
     * The type of key to use
     */
    keyType: string;
    /**
     * An identifier for the key
     */
    kmsKey: string;
    /**
     * A unique lowercase name that serves as identifying the key
     */
    name: string;
    /**
     * The AWS region where the keys are stored (or will be stored)
     */
    region: string;
    /**
     * The AWS secret key to use
     */
    secretKey: string;
    /**
     * ID of the managed key read from Vault
     */
    uuid: string;
}

export interface ManagedKeysAzure {
    /**
     * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
     */
    allowGenerateKey: boolean;
    /**
     * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
     */
    allowReplaceKey: boolean;
    /**
     * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
     */
    allowStoreKey: boolean;
    /**
     * Allow usage from any mount point within the namespace if 'true'
     */
    anyMount: boolean;
    /**
     * The client id for credentials to query the Azure APIs
     */
    clientId: string;
    /**
     * The client secret for credentials to query the Azure APIs
     */
    clientSecret: string;
    /**
     * The Azure Cloud environment API endpoints to use
     */
    environment: string;
    /**
     * The size in bits for an RSA key. This field is required when 'key_type' is 'RSA' or when 'allow_generate_key' is true
     */
    keyBits?: string;
    /**
     * The Key Vault key to use for encryption and decryption
     */
    keyName: string;
    /**
     * The type of key to use
     */
    keyType: string;
    /**
     * A unique lowercase name that serves as identifying the key
     */
    name: string;
    /**
     * The Azure Key Vault resource's DNS Suffix to connect to
     */
    resource: string;
    /**
     * The tenant id for the Azure Active Directory organization
     */
    tenantId: string;
    /**
     * ID of the managed key read from Vault
     */
    uuid: string;
    /**
     * The Key Vault vault to use the encryption keys for encryption and decryption
     */
    vaultName: string;
}

export interface ManagedKeysPkc {
    /**
     * If no existing key can be found in the referenced backend, instructs Vault to generate a key within the backend
     */
    allowGenerateKey: boolean;
    /**
     * Controls the ability for Vault to replace through generation or importing a key into the configured backend even if a key is present, if set to false those operations are forbidden if a key exists.
     */
    allowReplaceKey: boolean;
    /**
     * Controls the ability for Vault to import a key to the configured backend, if 'false', those operations will be forbidden
     */
    allowStoreKey: boolean;
    /**
     * Allow usage from any mount point within the namespace if 'true'
     */
    anyMount: boolean;
    /**
     * Supplies the curve value when using the 'CKM_ECDSA' mechanism. Required if 'allow_generate_key' is true
     */
    curve?: string;
    /**
     * Force all operations to open up a read-write session to the HSM
     */
    forceRwSession?: string;
    /**
     * Supplies the size in bits of the key when using 'CKM_RSA_PKCS_PSS', 'CKM_RSA_PKCS_OAEP' or 'CKM_RSA_PKCS' as a value for 'mechanism'. Required if 'allow_generate_key' is true
     */
    keyBits?: string;
    /**
     * The id of a PKCS#11 key to use
     */
    keyId: string;
    /**
     * The label of the key to use
     */
    keyLabel: string;
    /**
     * The name of the kms_library stanza to use from Vault's config to lookup the local library path
     */
    library: string;
    /**
     * The encryption/decryption mechanism to use, specified as a hexadecimal (prefixed by 0x) string.
     */
    mechanism: string;
    /**
     * A unique lowercase name that serves as identifying the key
     */
    name: string;
    /**
     * The PIN for login
     */
    pin: string;
    /**
     * The slot number to use, specified as a string in a decimal format (e.g. '2305843009213693953')
     */
    slot?: string;
    /**
     * The slot token label to use
     */
    tokenLabel?: string;
    /**
     * ID of the managed key read from Vault
     */
    uuid: string;
}

export interface OktaAuthBackendGroup {
    groupName: string;
    policies: string[];
}

export interface OktaAuthBackendUser {
    groups: string[];
    policies: string[];
    username: string;
}

export interface PkiSecretBackendConfigEstAuthenticators {
    cert?: {[key: string]: string};
    userpass?: {[key: string]: string};
}

export interface PkiSecretBackendRolePolicyIdentifier {
    /**
     * Optional CPS URL
     */
    cps?: string;
    /**
     * Optional notice
     */
    notice?: string;
    /**
     * OID
     */
    oid: string;
}

export interface RabbitmqSecretBackendRoleVhost {
    /**
     * The configure permissions for this vhost.
     */
    configure: string;
    /**
     * The vhost to set permissions for.
     */
    host: string;
    /**
     * The read permissions for this vhost.
     */
    read: string;
    /**
     * The write permissions for this vhost.
     */
    write: string;
}

export interface RabbitmqSecretBackendRoleVhostTopic {
    /**
     * The vhost to set permissions for.
     */
    host: string;
    /**
     * Specifies a map of virtual hosts to permissions.
     */
    vhosts?: outputs.RabbitmqSecretBackendRoleVhostTopicVhost[];
}

export interface RabbitmqSecretBackendRoleVhostTopicVhost {
    /**
     * The read permissions for this vhost.
     */
    read: string;
    /**
     * The vhost to set permissions for.
     */
    topic: string;
    /**
     * The write permissions for this vhost.
     */
    write: string;
}

export interface SecretsSyncAssociationMetadata {
    subKey: string;
    syncStatus: string;
    updatedAt: string;
}

export interface SshSecretBackendRoleAllowedUserKeyConfig {
    /**
     * List of allowed key lengths, vault-1.10 and above
     */
    lengths: number[];
    /**
     * Key type, choices:
     * rsa, ecdsa, ec, dsa, ed25519, ssh-rsa, ssh-dss, ssh-ed25519, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521
     */
    type: string;
}

export namespace config {
    export interface AuthLogin {
        method?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        parameters?: {[key: string]: string};
        path: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginAws {
        /**
         * The AWS access key ID.
         */
        awsAccessKeyId?: string;
        /**
         * The IAM endpoint URL.
         */
        awsIamEndpoint?: string;
        /**
         * The name of the AWS profile.
         */
        awsProfile?: string;
        /**
         * The AWS region.
         */
        awsRegion?: string;
        /**
         * The ARN of the AWS Role to assume.Used during STS AssumeRole
         */
        awsRoleArn?: string;
        /**
         * Specifies the name to attach to the AWS role session. Used during STS AssumeRole
         */
        awsRoleSessionName?: string;
        /**
         * The AWS secret access key.
         */
        awsSecretAccessKey?: string;
        /**
         * The AWS session token.
         */
        awsSessionToken?: string;
        /**
         * Path to the AWS shared credentials file.
         */
        awsSharedCredentialsFile?: string;
        /**
         * The STS endpoint URL.
         */
        awsStsEndpoint?: string;
        /**
         * Path to the file containing an OAuth 2.0 access token or OpenID Connect ID token.
         */
        awsWebIdentityTokenFile?: string;
        /**
         * The Vault header value to include in the STS signing request.
         */
        headerValue?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Vault role to use when logging into Vault.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginAzure {
        /**
         * The identity's client ID.
         */
        clientId?: string;
        /**
         * A signed JSON Web Token. If not specified on will be created automatically
         */
        jwt?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The resource group for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        resourceGroupName: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * The scopes to include in the token request.
         */
        scope?: string;
        /**
         * The subscription ID for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        subscriptionId: string;
        /**
         * Provides the tenant ID to use in a multi-tenant authentication scenario.
         */
        tenantId?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The virtual machine name for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        vmName?: string;
        /**
         * The virtual machine scale set name for the machine that generated the MSI token. This information can be obtained through instance metadata.
         */
        vmssName?: string;
    }

    export interface AuthLoginCert {
        /**
         * Path to a file containing the client certificate.
         */
        certFile: string;
        /**
         * Path to a file containing the private key that the certificate was issued for.
         */
        keyFile: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * Name of the certificate's role
         */
        name?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginGcp {
        /**
         * Path to the Google Cloud credentials file.
         */
        credentials?: string;
        /**
         * A signed JSON Web Token.
         */
        jwt?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * IAM service account.
         */
        serviceAccount?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginJwt {
        /**
         * A signed JSON Web Token.
         */
        jwt: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginKerberos {
        /**
         * Disable the Kerberos FAST negotiation.
         */
        disableFastNegotiation?: boolean;
        /**
         * The Kerberos keytab file containing the entry of the login entity.
         */
        keytabPath?: string;
        /**
         * A valid Kerberos configuration file e.g. /etc/krb5.conf.
         */
        krb5confPath?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Kerberos server's authoritative authentication domain
         */
        realm?: string;
        /**
         * Strip the host from the username found in the keytab.
         */
        removeInstanceName?: boolean;
        /**
         * The service principle name.
         */
        service?: string;
        /**
         * Simple and Protected GSSAPI Negotiation Mechanism (SPNEGO) token
         */
        token?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The username to login into Kerberos with.
         */
        username?: string;
    }

    export interface AuthLoginOci {
        /**
         * Authentication type to use when getting OCI credentials.
         */
        authType: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginOidc {
        /**
         * The callback address. Must be a valid URI without the path.
         */
        callbackAddress?: string;
        /**
         * The callback listener's address. Must be a valid URI without the path.
         */
        callbackListenerAddress?: string;
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Name of the login role.
         */
        role: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginRadius {
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * The Radius password for username.
         */
        password: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * The Radius username.
         */
        username: string;
    }

    export interface AuthLoginTokenFile {
        /**
         * The name of a file containing a single line that is a valid Vault token
         */
        filename: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
    }

    export interface AuthLoginUserpass {
        /**
         * The path where the authentication engine is mounted.
         */
        mount?: string;
        /**
         * The authentication engine's namespace. Conflicts with use_root_namespace
         */
        namespace?: string;
        /**
         * Login with password
         */
        password?: string;
        /**
         * Login with password from a file
         */
        passwordFile?: string;
        /**
         * Authenticate to the root Vault namespace. Conflicts with namespace
         */
        useRootNamespace?: boolean;
        /**
         * Login with username
         */
        username: string;
    }

    export interface ClientAuth {
        /**
         * Path to a file containing the client certificate.
         */
        certFile?: string;
        /**
         * Path to a file containing the private key that the certificate was issued for.
         */
        keyFile?: string;
    }

    export interface Headers {
        /**
         * The header name
         */
        name: string;
        /**
         * The header value
         */
        value: string;
    }

}
