// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export function getCluster(args: GetClusterArgs, opts?: pulumi.InvokeOptions): Promise<GetClusterResult> {

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("biganimal:index/getCluster:getCluster", {
        "allowedIpRanges": args.allowedIpRanges,
        "backupRetentionPeriod": args.backupRetentionPeriod,
        "clusterId": args.clusterId,
        "cspAuth": args.cspAuth,
        "maintenanceWindow": args.maintenanceWindow,
        "pause": args.pause,
        "peAllowedPrincipalIds": args.peAllowedPrincipalIds,
        "pgBouncer": args.pgBouncer,
        "pgConfigs": args.pgConfigs,
        "pgIdentity": args.pgIdentity,
        "pgvector": args.pgvector,
        "postGis": args.postGis,
        "privateNetworking": args.privateNetworking,
        "projectId": args.projectId,
        "readOnlyConnections": args.readOnlyConnections,
        "serviceAccountIds": args.serviceAccountIds,
        "superuserAccess": args.superuserAccess,
        "timeouts": args.timeouts,
        "transparentDataEncryption": args.transparentDataEncryption,
        "volumeSnapshotBackup": args.volumeSnapshotBackup,
    }, opts, utilities.getPackage());
}

/**
 * A collection of arguments for invoking getCluster.
 */
export interface GetClusterArgs {
    allowedIpRanges?: inputs.GetClusterAllowedIpRange[];
    backupRetentionPeriod?: string;
    clusterId: string;
    cspAuth?: boolean;
    maintenanceWindow?: inputs.GetClusterMaintenanceWindow;
    pause?: boolean;
    peAllowedPrincipalIds?: string[];
    pgBouncer?: inputs.GetClusterPgBouncer;
    pgConfigs?: inputs.GetClusterPgConfig[];
    pgIdentity?: string;
    pgvector?: boolean;
    postGis?: boolean;
    privateNetworking?: boolean;
    projectId: string;
    readOnlyConnections?: boolean;
    serviceAccountIds?: string[];
    superuserAccess?: boolean;
    timeouts?: inputs.GetClusterTimeouts;
    transparentDataEncryption?: inputs.GetClusterTransparentDataEncryption;
    volumeSnapshotBackup?: boolean;
}

/**
 * A collection of values returned by getCluster.
 */
export interface GetClusterResult {
    readonly allowedIpRanges: outputs.GetClusterAllowedIpRange[];
    readonly backupRetentionPeriod: string;
    readonly cloudProvider: string;
    readonly clusterArchitecture: outputs.GetClusterClusterArchitecture;
    readonly clusterId: string;
    readonly clusterName: string;
    readonly clusterType: string;
    readonly connectionUri: string;
    readonly createdAt: string;
    readonly cspAuth: boolean;
    readonly farawayReplicaIds: string[];
    readonly firstRecoverabilityPointAt: string;
    readonly id: string;
    readonly instanceType: string;
    readonly logsUrl: string;
    readonly maintenanceWindow: outputs.GetClusterMaintenanceWindow;
    readonly metricsUrl: string;
    readonly password: string;
    readonly pause?: boolean;
    readonly peAllowedPrincipalIds: string[];
    readonly pgBouncer: outputs.GetClusterPgBouncer;
    readonly pgConfigs?: outputs.GetClusterPgConfig[];
    readonly pgIdentity: string;
    readonly pgType: string;
    readonly pgVersion: string;
    readonly pgvector: boolean;
    readonly phase: string;
    readonly postGis: boolean;
    readonly privateNetworking?: boolean;
    readonly projectId: string;
    readonly readOnlyConnections?: boolean;
    readonly region: string;
    readonly resizingPvcs: string[];
    readonly roConnectionUri: string;
    readonly serviceAccountIds: string[];
    readonly storage: outputs.GetClusterStorage;
    readonly superuserAccess: boolean;
    readonly timeouts?: outputs.GetClusterTimeouts;
    readonly transparentDataEncryption?: outputs.GetClusterTransparentDataEncryption;
    readonly transparentDataEncryptionAction: string;
    readonly volumeSnapshotBackup?: boolean;
}
export function getClusterOutput(args: GetClusterOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetClusterResult> {
    return pulumi.output(args).apply((a: any) => getCluster(a, opts))
}

/**
 * A collection of arguments for invoking getCluster.
 */
export interface GetClusterOutputArgs {
    allowedIpRanges?: pulumi.Input<pulumi.Input<inputs.GetClusterAllowedIpRangeArgs>[]>;
    backupRetentionPeriod?: pulumi.Input<string>;
    clusterId: pulumi.Input<string>;
    cspAuth?: pulumi.Input<boolean>;
    maintenanceWindow?: pulumi.Input<inputs.GetClusterMaintenanceWindowArgs>;
    pause?: pulumi.Input<boolean>;
    peAllowedPrincipalIds?: pulumi.Input<pulumi.Input<string>[]>;
    pgBouncer?: pulumi.Input<inputs.GetClusterPgBouncerArgs>;
    pgConfigs?: pulumi.Input<pulumi.Input<inputs.GetClusterPgConfigArgs>[]>;
    pgIdentity?: pulumi.Input<string>;
    pgvector?: pulumi.Input<boolean>;
    postGis?: pulumi.Input<boolean>;
    privateNetworking?: pulumi.Input<boolean>;
    projectId: pulumi.Input<string>;
    readOnlyConnections?: pulumi.Input<boolean>;
    serviceAccountIds?: pulumi.Input<pulumi.Input<string>[]>;
    superuserAccess?: pulumi.Input<boolean>;
    timeouts?: pulumi.Input<inputs.GetClusterTimeoutsArgs>;
    transparentDataEncryption?: pulumi.Input<inputs.GetClusterTransparentDataEncryptionArgs>;
    volumeSnapshotBackup?: pulumi.Input<boolean>;
}
