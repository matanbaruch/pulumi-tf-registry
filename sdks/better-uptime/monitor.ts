// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Monitor extends pulumi.CustomResource {
    /**
     * Get an existing Monitor resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: MonitorState, opts?: pulumi.CustomResourceOptions): Monitor {
        return new Monitor(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'better-uptime:index/monitor:Monitor';

    /**
     * Returns true if the given object is an instance of Monitor.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Monitor {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Monitor.__pulumiType;
    }

    /**
     * Basic HTTP authentication password to include with the request.
     */
    public readonly authPassword!: pulumi.Output<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    public readonly authUsername!: pulumi.Output<string>;
    /**
     * Should we call the on-call person?
     */
    public readonly call!: pulumi.Output<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    public readonly checkFrequency!: pulumi.Output<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    public readonly confirmationPeriod!: pulumi.Output<number>;
    /**
     * The time when this monitor was created.
     */
    public /*out*/ readonly createdAt!: pulumi.Output<string>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    public readonly domainExpiration!: pulumi.Output<number>;
    /**
     * Should we send an email to the on-call person?
     */
    public readonly email!: pulumi.Output<boolean>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from
     * the server is not in the list of expected status codes.
     */
    public readonly expectedStatusCodes!: pulumi.Output<number[]>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    public readonly followRedirects!: pulumi.Output<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    public readonly httpMethod!: pulumi.Output<string>;
    /**
     * Valid values: `ipv4` Use IPv4 only, `ipv6` Use IPv6 only.
     */
    public readonly ipVersion!: pulumi.Output<string>;
    /**
     * When the website was last checked.
     */
    public /*out*/ readonly lastCheckedAt!: pulumi.Output<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed
     * values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    public readonly maintenanceDays!: pulumi.Output<string[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    public readonly maintenanceFrom!: pulumi.Output<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails
     * TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    public readonly maintenanceTimezone!: pulumi.Output<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    public readonly maintenanceTo!: pulumi.Output<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    public readonly monitorGroupId!: pulumi.Output<number>;
    /**
     * Valid values: `status` We will check your website for 2XX HTTP status code. `expected_status_code` We will check if your
     * website returned one of the values in expected_status_codes. `keyword` We will check if your website contains the
     * required_keyword. `keyword_absence` We will check if your website doesn't contain the required_keyword. `ping` We will
     * ping your host specified in the url parameter. `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required). `udp` We will test a UDP port at your host specified in the url parameter (port and required_keyword
     * are required). `smtp` We will check for a SMTP server at the host specified in the url parameter (port is required, and
     * can be one of 25, 465, 587, or a combination of those ports separated by comma). `pop` We will check for a POP3 server
     * at the host specified in the url parameter (port is required, and can be 110, 995, or both). `imap` We will check for an
     * IMAP server at the host specified in the url parameter (port is required, and can be 143, 993, or both). `dns` We will
     * check for a DNS server at the host specified in the url parameter (request_body is required, and should contain the
     * domain to query the DNS server with). `playwright` We will run the scenario defined by playwright_script, identified in
     * the UI by scenario_name
     */
    public readonly monitorType!: pulumi.Output<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    public readonly paused!: pulumi.Output<boolean>;
    /**
     * The time when this monitor was paused.
     */
    public /*out*/ readonly pausedAt!: pulumi.Output<string>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    public readonly playwrightScript!: pulumi.Output<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    public readonly policyId!: pulumi.Output<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop,
     * and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    public readonly port!: pulumi.Output<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    public readonly pronounceableName!: pulumi.Output<string>;
    /**
     * Should we send a push notification to the on-call person?
     */
    public readonly push!: pulumi.Output<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    public readonly recoveryPeriod!: pulumi.Output<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    public readonly regions!: pulumi.Output<string[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    public readonly rememberCookies!: pulumi.Output<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server
     * with).
     */
    public readonly requestBody!: pulumi.Output<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    public readonly requestHeaders!: pulumi.Output<{[key: string]: string}[]>;
    /**
     * How long to wait before timing out the request? In seconds.
     */
    public readonly requestTimeout!: pulumi.Output<number>;
    /**
     * Required if monitor_type is set to keyword or udp. We will create a new incident if this keyword is missing on your
     * page.
     */
    public readonly requiredKeyword!: pulumi.Output<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI.
     */
    public readonly scenarioName!: pulumi.Output<string>;
    /**
     * Should we send an SMS to the on-call person?
     */
    public readonly sms!: pulumi.Output<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    public readonly sslExpiration!: pulumi.Output<number>;
    /**
     * The status of this website check.
     */
    public /*out*/ readonly status!: pulumi.Output<string>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    public readonly teamName!: pulumi.Output<string | undefined>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team.
     * In seconds.
     */
    public readonly teamWait!: pulumi.Output<number>;
    /**
     * The time when this monitor was updated.
     */
    public /*out*/ readonly updatedAt!: pulumi.Output<string>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below).
     */
    public readonly url!: pulumi.Output<string>;
    /**
     * Should we verify SSL certificate validity?
     */
    public readonly verifySsl!: pulumi.Output<boolean>;

    /**
     * Create a Monitor resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: MonitorArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: MonitorArgs | MonitorState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as MonitorState | undefined;
            resourceInputs["authPassword"] = state ? state.authPassword : undefined;
            resourceInputs["authUsername"] = state ? state.authUsername : undefined;
            resourceInputs["call"] = state ? state.call : undefined;
            resourceInputs["checkFrequency"] = state ? state.checkFrequency : undefined;
            resourceInputs["confirmationPeriod"] = state ? state.confirmationPeriod : undefined;
            resourceInputs["createdAt"] = state ? state.createdAt : undefined;
            resourceInputs["domainExpiration"] = state ? state.domainExpiration : undefined;
            resourceInputs["email"] = state ? state.email : undefined;
            resourceInputs["expectedStatusCodes"] = state ? state.expectedStatusCodes : undefined;
            resourceInputs["followRedirects"] = state ? state.followRedirects : undefined;
            resourceInputs["httpMethod"] = state ? state.httpMethod : undefined;
            resourceInputs["ipVersion"] = state ? state.ipVersion : undefined;
            resourceInputs["lastCheckedAt"] = state ? state.lastCheckedAt : undefined;
            resourceInputs["maintenanceDays"] = state ? state.maintenanceDays : undefined;
            resourceInputs["maintenanceFrom"] = state ? state.maintenanceFrom : undefined;
            resourceInputs["maintenanceTimezone"] = state ? state.maintenanceTimezone : undefined;
            resourceInputs["maintenanceTo"] = state ? state.maintenanceTo : undefined;
            resourceInputs["monitorGroupId"] = state ? state.monitorGroupId : undefined;
            resourceInputs["monitorType"] = state ? state.monitorType : undefined;
            resourceInputs["paused"] = state ? state.paused : undefined;
            resourceInputs["pausedAt"] = state ? state.pausedAt : undefined;
            resourceInputs["playwrightScript"] = state ? state.playwrightScript : undefined;
            resourceInputs["policyId"] = state ? state.policyId : undefined;
            resourceInputs["port"] = state ? state.port : undefined;
            resourceInputs["pronounceableName"] = state ? state.pronounceableName : undefined;
            resourceInputs["push"] = state ? state.push : undefined;
            resourceInputs["recoveryPeriod"] = state ? state.recoveryPeriod : undefined;
            resourceInputs["regions"] = state ? state.regions : undefined;
            resourceInputs["rememberCookies"] = state ? state.rememberCookies : undefined;
            resourceInputs["requestBody"] = state ? state.requestBody : undefined;
            resourceInputs["requestHeaders"] = state ? state.requestHeaders : undefined;
            resourceInputs["requestTimeout"] = state ? state.requestTimeout : undefined;
            resourceInputs["requiredKeyword"] = state ? state.requiredKeyword : undefined;
            resourceInputs["scenarioName"] = state ? state.scenarioName : undefined;
            resourceInputs["sms"] = state ? state.sms : undefined;
            resourceInputs["sslExpiration"] = state ? state.sslExpiration : undefined;
            resourceInputs["status"] = state ? state.status : undefined;
            resourceInputs["teamName"] = state ? state.teamName : undefined;
            resourceInputs["teamWait"] = state ? state.teamWait : undefined;
            resourceInputs["updatedAt"] = state ? state.updatedAt : undefined;
            resourceInputs["url"] = state ? state.url : undefined;
            resourceInputs["verifySsl"] = state ? state.verifySsl : undefined;
        } else {
            const args = argsOrState as MonitorArgs | undefined;
            if ((!args || args.monitorType === undefined) && !opts.urn) {
                throw new Error("Missing required property 'monitorType'");
            }
            if ((!args || args.url === undefined) && !opts.urn) {
                throw new Error("Missing required property 'url'");
            }
            resourceInputs["authPassword"] = args?.authPassword ? pulumi.secret(args.authPassword) : undefined;
            resourceInputs["authUsername"] = args?.authUsername ? pulumi.secret(args.authUsername) : undefined;
            resourceInputs["call"] = args ? args.call : undefined;
            resourceInputs["checkFrequency"] = args ? args.checkFrequency : undefined;
            resourceInputs["confirmationPeriod"] = args ? args.confirmationPeriod : undefined;
            resourceInputs["domainExpiration"] = args ? args.domainExpiration : undefined;
            resourceInputs["email"] = args ? args.email : undefined;
            resourceInputs["expectedStatusCodes"] = args ? args.expectedStatusCodes : undefined;
            resourceInputs["followRedirects"] = args ? args.followRedirects : undefined;
            resourceInputs["httpMethod"] = args ? args.httpMethod : undefined;
            resourceInputs["ipVersion"] = args ? args.ipVersion : undefined;
            resourceInputs["maintenanceDays"] = args ? args.maintenanceDays : undefined;
            resourceInputs["maintenanceFrom"] = args ? args.maintenanceFrom : undefined;
            resourceInputs["maintenanceTimezone"] = args ? args.maintenanceTimezone : undefined;
            resourceInputs["maintenanceTo"] = args ? args.maintenanceTo : undefined;
            resourceInputs["monitorGroupId"] = args ? args.monitorGroupId : undefined;
            resourceInputs["monitorType"] = args ? args.monitorType : undefined;
            resourceInputs["paused"] = args ? args.paused : undefined;
            resourceInputs["playwrightScript"] = args ? args.playwrightScript : undefined;
            resourceInputs["policyId"] = args ? args.policyId : undefined;
            resourceInputs["port"] = args ? args.port : undefined;
            resourceInputs["pronounceableName"] = args ? args.pronounceableName : undefined;
            resourceInputs["push"] = args ? args.push : undefined;
            resourceInputs["recoveryPeriod"] = args ? args.recoveryPeriod : undefined;
            resourceInputs["regions"] = args ? args.regions : undefined;
            resourceInputs["rememberCookies"] = args ? args.rememberCookies : undefined;
            resourceInputs["requestBody"] = args ? args.requestBody : undefined;
            resourceInputs["requestHeaders"] = args ? args.requestHeaders : undefined;
            resourceInputs["requestTimeout"] = args ? args.requestTimeout : undefined;
            resourceInputs["requiredKeyword"] = args ? args.requiredKeyword : undefined;
            resourceInputs["scenarioName"] = args ? args.scenarioName : undefined;
            resourceInputs["sms"] = args ? args.sms : undefined;
            resourceInputs["sslExpiration"] = args ? args.sslExpiration : undefined;
            resourceInputs["teamName"] = args ? args.teamName : undefined;
            resourceInputs["teamWait"] = args ? args.teamWait : undefined;
            resourceInputs["url"] = args ? args.url : undefined;
            resourceInputs["verifySsl"] = args ? args.verifySsl : undefined;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["lastCheckedAt"] = undefined /*out*/;
            resourceInputs["pausedAt"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["authPassword", "authUsername"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Monitor.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Monitor resources.
 */
export interface MonitorState {
    /**
     * Basic HTTP authentication password to include with the request.
     */
    authPassword?: pulumi.Input<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    authUsername?: pulumi.Input<string>;
    /**
     * Should we call the on-call person?
     */
    call?: pulumi.Input<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    checkFrequency?: pulumi.Input<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    confirmationPeriod?: pulumi.Input<number>;
    /**
     * The time when this monitor was created.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    domainExpiration?: pulumi.Input<number>;
    /**
     * Should we send an email to the on-call person?
     */
    email?: pulumi.Input<boolean>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from
     * the server is not in the list of expected status codes.
     */
    expectedStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    httpMethod?: pulumi.Input<string>;
    /**
     * Valid values: `ipv4` Use IPv4 only, `ipv6` Use IPv6 only.
     */
    ipVersion?: pulumi.Input<string>;
    /**
     * When the website was last checked.
     */
    lastCheckedAt?: pulumi.Input<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed
     * values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    maintenanceDays?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    maintenanceFrom?: pulumi.Input<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails
     * TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    maintenanceTimezone?: pulumi.Input<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    maintenanceTo?: pulumi.Input<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    monitorGroupId?: pulumi.Input<number>;
    /**
     * Valid values: `status` We will check your website for 2XX HTTP status code. `expected_status_code` We will check if your
     * website returned one of the values in expected_status_codes. `keyword` We will check if your website contains the
     * required_keyword. `keyword_absence` We will check if your website doesn't contain the required_keyword. `ping` We will
     * ping your host specified in the url parameter. `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required). `udp` We will test a UDP port at your host specified in the url parameter (port and required_keyword
     * are required). `smtp` We will check for a SMTP server at the host specified in the url parameter (port is required, and
     * can be one of 25, 465, 587, or a combination of those ports separated by comma). `pop` We will check for a POP3 server
     * at the host specified in the url parameter (port is required, and can be 110, 995, or both). `imap` We will check for an
     * IMAP server at the host specified in the url parameter (port is required, and can be 143, 993, or both). `dns` We will
     * check for a DNS server at the host specified in the url parameter (request_body is required, and should contain the
     * domain to query the DNS server with). `playwright` We will run the scenario defined by playwright_script, identified in
     * the UI by scenario_name
     */
    monitorType?: pulumi.Input<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    paused?: pulumi.Input<boolean>;
    /**
     * The time when this monitor was paused.
     */
    pausedAt?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    playwrightScript?: pulumi.Input<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop,
     * and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    port?: pulumi.Input<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    pronounceableName?: pulumi.Input<string>;
    /**
     * Should we send a push notification to the on-call person?
     */
    push?: pulumi.Input<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    recoveryPeriod?: pulumi.Input<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    regions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    rememberCookies?: pulumi.Input<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server
     * with).
     */
    requestBody?: pulumi.Input<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    requestHeaders?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
    /**
     * How long to wait before timing out the request? In seconds.
     */
    requestTimeout?: pulumi.Input<number>;
    /**
     * Required if monitor_type is set to keyword or udp. We will create a new incident if this keyword is missing on your
     * page.
     */
    requiredKeyword?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI.
     */
    scenarioName?: pulumi.Input<string>;
    /**
     * Should we send an SMS to the on-call person?
     */
    sms?: pulumi.Input<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    sslExpiration?: pulumi.Input<number>;
    /**
     * The status of this website check.
     */
    status?: pulumi.Input<string>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    teamName?: pulumi.Input<string>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team.
     * In seconds.
     */
    teamWait?: pulumi.Input<number>;
    /**
     * The time when this monitor was updated.
     */
    updatedAt?: pulumi.Input<string>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below).
     */
    url?: pulumi.Input<string>;
    /**
     * Should we verify SSL certificate validity?
     */
    verifySsl?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Monitor resource.
 */
export interface MonitorArgs {
    /**
     * Basic HTTP authentication password to include with the request.
     */
    authPassword?: pulumi.Input<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    authUsername?: pulumi.Input<string>;
    /**
     * Should we call the on-call person?
     */
    call?: pulumi.Input<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    checkFrequency?: pulumi.Input<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    confirmationPeriod?: pulumi.Input<number>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    domainExpiration?: pulumi.Input<number>;
    /**
     * Should we send an email to the on-call person?
     */
    email?: pulumi.Input<boolean>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from
     * the server is not in the list of expected status codes.
     */
    expectedStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    httpMethod?: pulumi.Input<string>;
    /**
     * Valid values: `ipv4` Use IPv4 only, `ipv6` Use IPv6 only.
     */
    ipVersion?: pulumi.Input<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed
     * values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    maintenanceDays?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    maintenanceFrom?: pulumi.Input<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails
     * TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    maintenanceTimezone?: pulumi.Input<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    maintenanceTo?: pulumi.Input<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    monitorGroupId?: pulumi.Input<number>;
    /**
     * Valid values: `status` We will check your website for 2XX HTTP status code. `expected_status_code` We will check if your
     * website returned one of the values in expected_status_codes. `keyword` We will check if your website contains the
     * required_keyword. `keyword_absence` We will check if your website doesn't contain the required_keyword. `ping` We will
     * ping your host specified in the url parameter. `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required). `udp` We will test a UDP port at your host specified in the url parameter (port and required_keyword
     * are required). `smtp` We will check for a SMTP server at the host specified in the url parameter (port is required, and
     * can be one of 25, 465, 587, or a combination of those ports separated by comma). `pop` We will check for a POP3 server
     * at the host specified in the url parameter (port is required, and can be 110, 995, or both). `imap` We will check for an
     * IMAP server at the host specified in the url parameter (port is required, and can be 143, 993, or both). `dns` We will
     * check for a DNS server at the host specified in the url parameter (request_body is required, and should contain the
     * domain to query the DNS server with). `playwright` We will run the scenario defined by playwright_script, identified in
     * the UI by scenario_name
     */
    monitorType: pulumi.Input<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    paused?: pulumi.Input<boolean>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    playwrightScript?: pulumi.Input<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop,
     * and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    port?: pulumi.Input<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    pronounceableName?: pulumi.Input<string>;
    /**
     * Should we send a push notification to the on-call person?
     */
    push?: pulumi.Input<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    recoveryPeriod?: pulumi.Input<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    regions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    rememberCookies?: pulumi.Input<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server
     * with).
     */
    requestBody?: pulumi.Input<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    requestHeaders?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
    /**
     * How long to wait before timing out the request? In seconds.
     */
    requestTimeout?: pulumi.Input<number>;
    /**
     * Required if monitor_type is set to keyword or udp. We will create a new incident if this keyword is missing on your
     * page.
     */
    requiredKeyword?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI.
     */
    scenarioName?: pulumi.Input<string>;
    /**
     * Should we send an SMS to the on-call person?
     */
    sms?: pulumi.Input<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60.
     */
    sslExpiration?: pulumi.Input<number>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    teamName?: pulumi.Input<string>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team.
     * In seconds.
     */
    teamWait?: pulumi.Input<number>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below).
     */
    url: pulumi.Input<string>;
    /**
     * Should we verify SSL certificate validity?
     */
    verifySsl?: pulumi.Input<boolean>;
}
