// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export function getApplicationInstance(args: GetApplicationInstanceArgs, opts?: pulumi.InvokeOptions): Promise<GetApplicationInstanceResult> {

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("zedcloud:index/getApplicationInstance:getApplicationInstance", {
        "activate": args.activate,
        "appId": args.appId,
        "appPolicyId": args.appPolicyId,
        "appType": args.appType,
        "clusterId": args.clusterId,
        "collectStatsIpAddr": args.collectStatsIpAddr,
        "cryptoKey": args.cryptoKey,
        "customConfigs": args.customConfigs,
        "description": args.description,
        "deviceId": args.deviceId,
        "drives": args.drives,
        "encryptedSecrets": args.encryptedSecrets,
        "interfaces": args.interfaces,
        "isSecretUpdated": args.isSecretUpdated,
        "logs": args.logs,
        "manifestInfos": args.manifestInfos,
        "name": args.name,
        "projectId": args.projectId,
        "purges": args.purges,
        "refreshes": args.refreshes,
        "remoteConsole": args.remoteConsole,
        "restarts": args.restarts,
        "revisions": args.revisions,
        "startDelayInSeconds": args.startDelayInSeconds,
        "tags": args.tags,
        "title": args.title,
        "userData": args.userData,
        "vminfos": args.vminfos,
    }, opts, utilities.getPackage());
}

/**
 * A collection of arguments for invoking getApplicationInstance.
 */
export interface GetApplicationInstanceArgs {
    activate?: boolean;
    appId: string;
    appPolicyId?: string;
    appType?: string;
    clusterId?: string;
    collectStatsIpAddr?: string;
    cryptoKey?: string;
    customConfigs?: inputs.GetApplicationInstanceCustomConfig[];
    description?: string;
    deviceId: string;
    drives?: inputs.GetApplicationInstanceDrife[];
    encryptedSecrets?: {[key: string]: string};
    interfaces?: inputs.GetApplicationInstanceInterface[];
    isSecretUpdated?: boolean;
    logs?: inputs.GetApplicationInstanceLog[];
    manifestInfos?: inputs.GetApplicationInstanceManifestInfo[];
    name: string;
    projectId?: string;
    purges?: inputs.GetApplicationInstancePurge[];
    refreshes?: inputs.GetApplicationInstanceRefresh[];
    remoteConsole?: boolean;
    restarts?: inputs.GetApplicationInstanceRestart[];
    revisions?: inputs.GetApplicationInstanceRevision[];
    startDelayInSeconds?: number;
    tags?: {[key: string]: string};
    title: string;
    userData?: string;
    vminfos?: inputs.GetApplicationInstanceVminfo[];
}

/**
 * A collection of values returned by getApplicationInstance.
 */
export interface GetApplicationInstanceResult {
    readonly activate?: boolean;
    readonly appId: string;
    readonly appPolicyId?: string;
    readonly appType?: string;
    readonly bundleversion: string;
    readonly clusterId?: string;
    readonly collectStatsIpAddr?: string;
    readonly cryptoKey: string;
    readonly customConfigs?: outputs.GetApplicationInstanceCustomConfig[];
    readonly deploymentType: string;
    readonly description?: string;
    readonly deviceId: string;
    readonly drives?: outputs.GetApplicationInstanceDrife[];
    readonly encryptedSecrets: {[key: string]: string};
    readonly id: string;
    readonly interfaces?: outputs.GetApplicationInstanceInterface[];
    readonly isSecretUpdated?: boolean;
    readonly logs?: outputs.GetApplicationInstanceLog[];
    readonly manifestInfos?: outputs.GetApplicationInstanceManifestInfo[];
    readonly name: string;
    readonly projectId: string;
    readonly purges?: outputs.GetApplicationInstancePurge[];
    readonly refreshes?: outputs.GetApplicationInstanceRefresh[];
    readonly remoteConsole?: boolean;
    readonly restarts?: outputs.GetApplicationInstanceRestart[];
    readonly revisions?: outputs.GetApplicationInstanceRevision[];
    readonly startDelayInSeconds?: number;
    readonly tags?: {[key: string]: string};
    readonly title: string;
    readonly userData?: string;
    readonly userDefinedVersion: string;
    readonly vminfos?: outputs.GetApplicationInstanceVminfo[];
}
export function getApplicationInstanceOutput(args: GetApplicationInstanceOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetApplicationInstanceResult> {
    return pulumi.output(args).apply((a: any) => getApplicationInstance(a, opts))
}

/**
 * A collection of arguments for invoking getApplicationInstance.
 */
export interface GetApplicationInstanceOutputArgs {
    activate?: pulumi.Input<boolean>;
    appId: pulumi.Input<string>;
    appPolicyId?: pulumi.Input<string>;
    appType?: pulumi.Input<string>;
    clusterId?: pulumi.Input<string>;
    collectStatsIpAddr?: pulumi.Input<string>;
    cryptoKey?: pulumi.Input<string>;
    customConfigs?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceCustomConfigArgs>[]>;
    description?: pulumi.Input<string>;
    deviceId: pulumi.Input<string>;
    drives?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceDrifeArgs>[]>;
    encryptedSecrets?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    interfaces?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceInterfaceArgs>[]>;
    isSecretUpdated?: pulumi.Input<boolean>;
    logs?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceLogArgs>[]>;
    manifestInfos?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceManifestInfoArgs>[]>;
    name: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    purges?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstancePurgeArgs>[]>;
    refreshes?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceRefreshArgs>[]>;
    remoteConsole?: pulumi.Input<boolean>;
    restarts?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceRestartArgs>[]>;
    revisions?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceRevisionArgs>[]>;
    startDelayInSeconds?: pulumi.Input<number>;
    tags?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    title: pulumi.Input<string>;
    userData?: pulumi.Input<string>;
    vminfos?: pulumi.Input<pulumi.Input<inputs.GetApplicationInstanceVminfoArgs>[]>;
}
