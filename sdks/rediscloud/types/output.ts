// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AclRoleRule {
    /**
     * A set of databases to whom this rule applies within the role
     */
    databases: outputs.AclRoleRuleDatabase[];
    /**
     * The name of the rule
     */
    name: string;
}

export interface AclRoleRuleDatabase {
    /**
     * The database (id)
     */
    database: number;
    /**
     * For ActiveActive databases only
     */
    regions?: string[];
    /**
     * The subscription (id) to which the database belongs
     */
    subscription: number;
}

export interface AclRoleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AclRuleTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface AclUserTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveActiveSubscriptionCreationPlan {
    /**
     * Maximum memory usage for each database
     */
    memoryLimitInGb: number;
    /**
     * Modules that will be used by the databases in this subscription.
     */
    modules?: string[];
    /**
     * The planned number of databases
     */
    quantity: number;
    /**
     * Cloud networking details, per region (multiple regions for Active-Active cluster)
     */
    regions: outputs.ActiveActiveSubscriptionCreationPlanRegion[];
}

export interface ActiveActiveSubscriptionCreationPlanRegion {
    /**
     * Deployment CIDR mask
     */
    networkingDeploymentCidr: string;
    /**
     * Write operations per second for creation plan databases
     */
    readOperationsPerSecond: number;
    /**
     * Deployment region as defined by cloud provider
     */
    region: string;
    /**
     * Write operations per second for creation plan databases
     */
    writeOperationsPerSecond: number;
}

export interface ActiveActiveSubscriptionDatabaseGlobalAlert {
    /**
     * Alert name
     */
    name: string;
    /**
     * Alert value
     */
    value: number;
}

export interface ActiveActiveSubscriptionDatabaseLatestImportStatus {
    errors: outputs.ActiveActiveSubscriptionDatabaseLatestImportStatusError[];
    responses: outputs.ActiveActiveSubscriptionDatabaseLatestImportStatusResponse[];
}

export interface ActiveActiveSubscriptionDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface ActiveActiveSubscriptionDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.ActiveActiveSubscriptionDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface ActiveActiveSubscriptionDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegion {
    /**
     * Details about the last backups that took place across all regions for this active-active database
     */
    latestBackupStatuses: outputs.ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatus[];
    /**
     * Region name
     */
    name: string;
    /**
     * Set of alerts to enable on the database
     */
    overrideGlobalAlerts?: outputs.ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert[];
    /**
     * Rate of database data persistence (in persistent storage)
     */
    overrideGlobalDataPersistence?: string;
    /**
     * Password used to access the database. If left empty, the password will be generated automatically
     */
    overrideGlobalPassword?: string;
    /**
     * Set of CIDR addresses to allow access to the database
     */
    overrideGlobalSourceIps?: string[];
    /**
     * An object that specifies the backup options for the database in this region
     */
    remoteBackup?: outputs.ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackup;
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatus {
    errors: outputs.ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatusError[];
    responses: outputs.ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatusResponse[];
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegionLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegionOverrideGlobalAlert {
    /**
     * Alert name
     */
    name: string;
    /**
     * Alert value
     */
    value: number;
}

export interface ActiveActiveSubscriptionDatabaseOverrideRegionRemoteBackup {
    /**
     * Defines the frequency of the automatic backup
     */
    interval: string;
    /**
     * Defines a URI representing the backup storage location
     */
    storagePath: string;
    /**
     * Defines the provider of the storage location
     */
    storageType: string;
    /**
     * Defines the hour automatic backups are made - only applicable when interval is `every-12-hours` or `every-24-hours`
     */
    timeUtc?: string;
}

export interface ActiveActiveSubscriptionDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveActiveSubscriptionMaintenanceWindows {
    /**
     * Either automatic (Redis specified) or manual (User specified)
     */
    mode: string;
    /**
     * A list of maintenance windows for manual-mode
     */
    windows?: outputs.ActiveActiveSubscriptionMaintenanceWindowsWindow[];
}

export interface ActiveActiveSubscriptionMaintenanceWindowsWindow {
    /**
     * A list of days on which the window is open ('Monday', 'Tuesday' etc)
     */
    days: string[];
    /**
     * How long maintenance may take
     */
    durationInHours: number;
    /**
     * What hour in the day (0-23) may maintenance start
     */
    startHour: number;
}

export interface ActiveActiveSubscriptionPeeringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface ActiveActiveSubscriptionPricing {
    databaseName: string;
    priceCurrency: string;
    pricePerUnit: number;
    pricePeriod: string;
    quantity: number;
    quantityMeasurement: string;
    region: string;
    type: string;
    typeDetails: string;
}

export interface ActiveActiveSubscriptionRegionsRegion {
    /**
     * The database resource
     */
    databases: outputs.ActiveActiveSubscriptionRegionsRegionDatabase[];
    /**
     * The initial RESP version for all databases provisioned under this region.
     */
    localRespVersion?: string;
    /**
     * Deployment CIDR mask
     */
    networkingDeploymentCidr: string;
    /**
     * Defines whether the regions should be re-created
     */
    recreateRegion?: boolean;
    /**
     * Deployment region as defined by cloud provider
     */
    region: string;
    /**
     * The region id
     */
    regionId: number;
    /**
     * Identifier of the VPC to be peered
     */
    vpcId: string;
}

export interface ActiveActiveSubscriptionRegionsRegionDatabase {
    /**
     * A numeric id for the database
     */
    databaseId: number;
    /**
     * A meaningful name to identify the database
     */
    databaseName: string;
    /**
     * Details about the last backup that took place for this database
     */
    latestBackupStatuses: outputs.ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatus[];
    /**
     * Write operations per second for creation plan databases
     */
    localReadOperationsPerSecond: number;
    /**
     * Write operations per second for creation plan databases
     */
    localWriteOperationsPerSecond: number;
}

export interface ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatus {
    errors: outputs.ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatusError[];
    responses: outputs.ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatusResponse[];
}

export interface ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface ActiveActiveSubscriptionRegionsRegionDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface ActiveActiveSubscriptionRegionsTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveActiveSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface ActiveActiveTransitGatewayAttachmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface CloudAccountTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EssentialsDatabaseAlert {
    /**
     * Alert name
     */
    name: string;
    /**
     * Alert value
     */
    value: number;
}

export interface EssentialsDatabaseLatestBackupStatus {
    errors: outputs.EssentialsDatabaseLatestBackupStatusError[];
    responses: outputs.EssentialsDatabaseLatestBackupStatusResponse[];
}

export interface EssentialsDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface EssentialsDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface EssentialsDatabaseLatestImportStatus {
    errors: outputs.EssentialsDatabaseLatestImportStatusError[];
    responses: outputs.EssentialsDatabaseLatestImportStatusResponse[];
}

export interface EssentialsDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface EssentialsDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.EssentialsDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface EssentialsDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface EssentialsDatabaseModule {
    name: string;
}

export interface EssentialsDatabaseReplica {
    /**
     * A source database to replicate here
     */
    syncSources: outputs.EssentialsDatabaseReplicaSyncSource[];
}

export interface EssentialsDatabaseReplicaSyncSource {
    /**
     * Defines if encryption should be used to connect to the sync source. If not provided and if the source is a Redis Cloud instance, it will automatically detect if the source uses encryption
     */
    encryption?: boolean;
    /**
     * A Redis URI (sample format: 'redis://user:password@host:port)'. If the URI provided is Redis Cloud instance, only host and port should be provided (using the format: ['redis://endpoint1:6379', 'redis://endpoint2:6380'])
     */
    endpoint: string;
    /**
     * TLS/SSL certificate chain of the sync source. If left null and if the source is a Redis Cloud instance, it will automatically detect the certificate to use
     */
    serverCert?: string;
}

export interface EssentialsDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface EssentialsSubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface GetAclRoleRule {
    databases: outputs.GetAclRoleRuleDatabase[];
    name: string;
}

export interface GetAclRoleRuleDatabase {
    database: number;
    regions: string[];
    subscription: number;
}

export interface GetActiveActiveSubscriptionDatabaseLatestBackupStatus {
    errors: outputs.GetActiveActiveSubscriptionDatabaseLatestBackupStatusError[];
    region: string;
    responses: outputs.GetActiveActiveSubscriptionDatabaseLatestBackupStatusResponse[];
}

export interface GetActiveActiveSubscriptionDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetActiveActiveSubscriptionDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface GetActiveActiveSubscriptionDatabaseLatestImportStatus {
    errors: outputs.GetActiveActiveSubscriptionDatabaseLatestImportStatusError[];
    responses: outputs.GetActiveActiveSubscriptionDatabaseLatestImportStatusResponse[];
}

export interface GetActiveActiveSubscriptionDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetActiveActiveSubscriptionDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.GetActiveActiveSubscriptionDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface GetActiveActiveSubscriptionDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface GetActiveActiveSubscriptionMaintenanceWindow {
    mode: string;
    windows: outputs.GetActiveActiveSubscriptionMaintenanceWindowWindow[];
}

export interface GetActiveActiveSubscriptionMaintenanceWindowWindow {
    days: string[];
    durationInHours: number;
    startHour: number;
}

export interface GetActiveActiveSubscriptionPricing {
    databaseName: string;
    priceCurrency: string;
    pricePerUnit: number;
    pricePeriod: string;
    quantity: number;
    quantityMeasurement: string;
    region: string;
    type: string;
    typeDetails: string;
}

export interface GetDataPersistenceDataPersistence {
    description: string;
    name: string;
}

export interface GetDatabaseAlert {
    name: string;
    value: number;
}

export interface GetDatabaseLatestBackupStatus {
    errors: outputs.GetDatabaseLatestBackupStatusError[];
    responses: outputs.GetDatabaseLatestBackupStatusResponse[];
}

export interface GetDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface GetDatabaseLatestImportStatus {
    errors: outputs.GetDatabaseLatestImportStatusError[];
    responses: outputs.GetDatabaseLatestImportStatusResponse[];
}

export interface GetDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.GetDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface GetDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface GetDatabaseModule {
    name: string;
}

export interface GetDatabaseModulesModule {
    description: string;
    name: string;
}

export interface GetEssentialsDatabaseAlert {
    name: string;
    value: number;
}

export interface GetEssentialsDatabaseLatestBackupStatus {
    errors: outputs.GetEssentialsDatabaseLatestBackupStatusError[];
    responses: outputs.GetEssentialsDatabaseLatestBackupStatusResponse[];
}

export interface GetEssentialsDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetEssentialsDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface GetEssentialsDatabaseLatestImportStatus {
    errors: outputs.GetEssentialsDatabaseLatestImportStatusError[];
    responses: outputs.GetEssentialsDatabaseLatestImportStatusResponse[];
}

export interface GetEssentialsDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface GetEssentialsDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.GetEssentialsDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface GetEssentialsDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface GetEssentialsDatabaseModule {
    name: string;
}

export interface GetEssentialsDatabaseReplica {
    syncSources: outputs.GetEssentialsDatabaseReplicaSyncSource[];
}

export interface GetEssentialsDatabaseReplicaSyncSource {
    encryption: boolean;
    endpoint: string;
    serverCert: string;
}

export interface GetRegionsRegion {
    name: string;
    providerName: string;
}

export interface GetSubscriptionCloudProvider {
    cloudAccountId: string;
    provider: string;
    regions: outputs.GetSubscriptionCloudProviderRegion[];
}

export interface GetSubscriptionCloudProviderRegion {
    multipleAvailabilityZones: boolean;
    networkingVpcId: string;
    networks: outputs.GetSubscriptionCloudProviderRegionNetwork[];
    preferredAvailabilityZones: string[];
    region: string;
}

export interface GetSubscriptionCloudProviderRegionNetwork {
    networkingDeploymentCidr: string;
    networkingSubnetId: string;
    networkingVpcId: string;
}

export interface GetSubscriptionMaintenanceWindow {
    mode: string;
    windows: outputs.GetSubscriptionMaintenanceWindowWindow[];
}

export interface GetSubscriptionMaintenanceWindowWindow {
    days: string[];
    durationInHours: number;
    startHour: number;
}

export interface GetSubscriptionPeeringsPeering {
    awsAccountId: string;
    awsPeeringId: string;
    gcpNetworkName: string;
    gcpPeeringId: string;
    gcpProjectId: string;
    gcpRedisNetworkName: string;
    gcpRedisProjectId: string;
    peeringId: number;
    providerName: string;
    region: string;
    status: string;
    vpcCidr: string;
    vpcId: string;
}

export interface GetSubscriptionPricing {
    databaseName: string;
    priceCurrency: string;
    pricePerUnit: number;
    pricePeriod: string;
    quantity: number;
    quantityMeasurement: string;
    region: string;
    type: string;
    typeDetails: string;
}

export interface SubscriptionAllowlist {
    /**
     * Set of CIDR ranges that are allowed to access the databases associated with this subscription
     */
    cidrs?: string[];
    /**
     * Set of security groups that are allowed to access the databases associated with this subscription
     */
    securityGroupIds: string[];
}

export interface SubscriptionCloudProvider {
    /**
     * Cloud account identifier. Default: Redis Labs internal cloud account (using Cloud Account Id = 1 implies using Redis Labs internal cloud account). Note that a GCP subscription can be created only with Redis Labs internal cloud account
     */
    cloudAccountId?: string;
    /**
     * The cloud provider to use with the subscription, (either `AWS` or `GCP`)
     */
    provider?: string;
    /**
     * Cloud networking details, per region (single region or multiple regions for Active-Active cluster only)
     */
    regions: outputs.SubscriptionCloudProviderRegion[];
}

export interface SubscriptionCloudProviderRegion {
    /**
     * Support deployment on multiple availability zones within the selected region
     */
    multipleAvailabilityZones?: boolean;
    /**
     * Deployment CIDR mask
     */
    networkingDeploymentCidr: string;
    /**
     * Either an existing VPC Id (already exists in the specific region) or create a new VPC (if no VPC is specified)
     */
    networkingVpcId?: string;
    /**
     * List of networks used
     */
    networks: outputs.SubscriptionCloudProviderRegionNetwork[];
    /**
     * List of availability zones used
     */
    preferredAvailabilityZones: string[];
    /**
     * Deployment region as defined by cloud provider
     */
    region: string;
}

export interface SubscriptionCloudProviderRegionNetwork {
    networkingDeploymentCidr: string;
    networkingSubnetId: string;
    networkingVpcId: string;
}

export interface SubscriptionCreationPlan {
    /**
     * Relevant only to ram-and-flash clusters. Estimated average size (measured in bytes) of the items stored in the database
     */
    averageItemSizeInBytes: number;
    /**
     * Maximum memory usage for each database
     */
    memoryLimitInGb: number;
    /**
     * Modules that will be used by the databases in this subscription.
     */
    modules: string[];
    /**
     * The planned number of databases
     */
    quantity: number;
    /**
     * Databases replication
     */
    replication: boolean;
    /**
     * Support Redis open-source (OSS) Cluster API
     */
    supportOssClusterApi?: boolean;
    /**
     * Throughput measurement method, (either ‘number-of-shards’ or ‘operations-per-second’)
     */
    throughputMeasurementBy: string;
    /**
     * Throughput value (as applies to selected measurement method)
     */
    throughputMeasurementValue: number;
}

export interface SubscriptionDatabaseAlert {
    /**
     * Alert name
     */
    name: string;
    /**
     * Alert value
     */
    value: number;
}

export interface SubscriptionDatabaseLatestBackupStatus {
    errors: outputs.SubscriptionDatabaseLatestBackupStatusError[];
    responses: outputs.SubscriptionDatabaseLatestBackupStatusResponse[];
}

export interface SubscriptionDatabaseLatestBackupStatusError {
    description: string;
    status: string;
    type: string;
}

export interface SubscriptionDatabaseLatestBackupStatusResponse {
    failureReason: string;
    lastBackupTime: string;
    status: string;
}

export interface SubscriptionDatabaseLatestImportStatus {
    errors: outputs.SubscriptionDatabaseLatestImportStatusError[];
    responses: outputs.SubscriptionDatabaseLatestImportStatusResponse[];
}

export interface SubscriptionDatabaseLatestImportStatusError {
    description: string;
    status: string;
    type: string;
}

export interface SubscriptionDatabaseLatestImportStatusResponse {
    failureReason: string;
    failureReasonParams: outputs.SubscriptionDatabaseLatestImportStatusResponseFailureReasonParam[];
    lastImportTime: string;
    status: string;
}

export interface SubscriptionDatabaseLatestImportStatusResponseFailureReasonParam {
    key: string;
    value: string;
}

export interface SubscriptionDatabaseModule {
    name: string;
}

export interface SubscriptionDatabaseRemoteBackup {
    /**
     * Defines the frequency of the automatic backup
     */
    interval: string;
    /**
     * Defines a URI representing the backup storage location
     */
    storagePath: string;
    /**
     * Defines the provider of the storage location
     */
    storageType: string;
    /**
     * Defines the hour automatic backups are made - only applicable when interval is `every-12-hours` or `every-24-hours`
     */
    timeUtc?: string;
}

export interface SubscriptionDatabaseTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface SubscriptionMaintenanceWindows {
    /**
     * Either automatic (Redis specified) or manual (User specified)
     */
    mode: string;
    /**
     * A list of maintenance windows for manual-mode
     */
    windows?: outputs.SubscriptionMaintenanceWindowsWindow[];
}

export interface SubscriptionMaintenanceWindowsWindow {
    /**
     * A list of days on which the window is open ('Monday', 'Tuesday' etc)
     */
    days: string[];
    /**
     * How long maintenance may take
     */
    durationInHours: number;
    /**
     * What hour in the day (0-23) may maintenance start
     */
    startHour: number;
}

export interface SubscriptionPeeringTimeouts {
    create?: string;
    delete?: string;
    read?: string;
}

export interface SubscriptionPricing {
    databaseName: string;
    priceCurrency: string;
    pricePerUnit: number;
    pricePeriod: string;
    quantity: number;
    quantityMeasurement: string;
    region: string;
    type: string;
    typeDetails: string;
}

export interface SubscriptionTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

export interface TransitGatewayAttachmentTimeouts {
    create?: string;
    delete?: string;
    read?: string;
    update?: string;
}

