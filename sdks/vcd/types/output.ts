// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CatalogAccessControlSharedWith {
    /**
     * The access level for the org, user, or group to which we are sharing. One of [ReadOnly, Change, FullControl] for users and groups, but just ReadOnly for Organizations
     */
    accessLevel: string;
    /**
     * ID of the group to which we are sharing. Required if user_id or org_id is not set
     */
    groupId?: string;
    /**
     * ID of the Org to which we are sharing. Required if user_id or group_id is not set
     */
    orgId?: string;
    /**
     * Name of the subject (org, group, or user) with which we are sharing
     */
    subjectName: string;
    /**
     * ID of the user to which we are sharing. Required if group_id or org_id is not set
     */
    userId?: string;
}

export interface CatalogItemMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface CatalogMediaMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface CatalogMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface CatalogVappTemplateCaptureVapp {
    /**
     * Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
     */
    copyTpmOnInstantiate?: boolean;
    /**
     * Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
     */
    customizeOnInstantiate?: boolean;
    /**
     * An existing catalog item ID to overwrite
     */
    overwriteCatalogItemId?: string;
    /**
     * Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
     */
    sourceId?: string;
}

export interface CatalogVappTemplateLease {
    /**
     * How long the vApp template is available before being automatically deleted or marked as expired. 0 means never expires (or expires at the maximum limit provided by the parent Org)
     */
    storageLeaseInSec: number;
}

export interface CatalogVappTemplateMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface CseKubernetesClusterControlPlane {
    /**
     * Disk size, in Gibibytes (Gi), for the control plane nodes. Must be at least 20
     */
    diskSizeGi?: number;
    /**
     * IP for the control plane. It will be automatically assigned during cluster creation if left empty
     */
    ip: string;
    /**
     * The number of nodes that the control plane has. Must be an odd number and higher than 0
     */
    machineCount?: number;
    /**
     * VM Placement policy for the control plane nodes
     */
    placementPolicyId?: string;
    /**
     * VM Sizing policy for the control plane nodes
     */
    sizingPolicyId?: string;
    /**
     * Storage profile for the control plane nodes
     */
    storageProfileId?: string;
}

export interface CseKubernetesClusterDefaultStorageClass {
    /**
     * Filesystem of the storage class, can be either 'ext4' or 'xfs'
     */
    filesystem: string;
    /**
     * Name to give to this storage class
     */
    name: string;
    /**
     * Reclaim policy. Possible values are: `delete` deletes the volume when the `PersistentVolumeClaim` is deleted; `retain` does not delete, and the volume can be manually reclaimed
     */
    reclaimPolicy: string;
    /**
     * ID of the storage profile to use for the storage class
     */
    storageProfileId: string;
}

export interface CseKubernetesClusterEvent {
    details: string;
    name: string;
    occurredAt: string;
    resourceId: string;
    type: string;
}

export interface CseKubernetesClusterWorkerPool {
    /**
     * Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
     */
    autoscalerMaxReplicas?: number;
    /**
     * Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
     */
    autoscalerMinReplicas?: number;
    /**
     * Disk size, in Gibibytes (Gi), for this worker pool
     */
    diskSizeGi?: number;
    /**
     * The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
     */
    machineCount?: number;
    /**
     * The name of this worker pool. Must be unique
     */
    name: string;
    /**
     * VM Placement policy for this worker pool
     */
    placementPolicyId?: string;
    /**
     * VM Sizing policy for this worker pool
     */
    sizingPolicyId?: string;
    /**
     * Storage profile for this worker pool
     */
    storageProfileId?: string;
    /**
     * vGPU policy for this worker pool
     */
    vgpuPolicyId?: string;
}

export interface DseRegistryConfigurationContainerRegistry {
    /**
     * Registry description
     */
    description: string;
    /**
     * Registry host
     */
    host: string;
    /**
     * Password for registry user
     */
    password?: string;
    /**
     * Username for registry access
     */
    username?: string;
}

export interface EdgegatewayExternalNetwork {
    /**
     * Enable rate limiting
     */
    enableRateLimit?: boolean;
    /**
     * Incoming rate limit (Mbps)
     */
    incomingRateLimit?: number;
    /**
     * External network name
     */
    name: string;
    /**
     * Outgoing rate limit (Mbps)
     */
    outgoingRateLimit?: number;
    subnets?: outputs.EdgegatewayExternalNetworkSubnet[];
}

export interface EdgegatewayExternalNetworkSubnet {
    /**
     * Gateway address for a subnet
     */
    gateway: string;
    /**
     * IP address on the edge gateway - will be auto-assigned if not defined
     */
    ipAddress?: string;
    /**
     * Netmask address for a subnet
     */
    netmask: string;
    /**
     * Define zero or more blocks to sub-allocate pools on the edge gateway
     */
    suballocatePools?: outputs.EdgegatewayExternalNetworkSubnetSuballocatePool[];
    /**
     * Defines if this subnet should be used as default gateway for edge
     */
    useForDefaultRoute?: boolean;
}

export interface EdgegatewayExternalNetworkSubnetSuballocatePool {
    endAddress: string;
    startAddress: string;
}

export interface EdgegatewayVpnLocalSubnet {
    localSubnetGateway: string;
    localSubnetMask: string;
    localSubnetName: string;
}

export interface EdgegatewayVpnPeerSubnet {
    peerSubnetGateway: string;
    peerSubnetMask: string;
    peerSubnetName: string;
}

export interface ExternalNetworkIpScope {
    /**
     * Primary DNS server
     */
    dns1?: string;
    /**
     * Secondary DNS server
     */
    dns2?: string;
    /**
     * DNS suffix
     */
    dnsSuffix?: string;
    /**
     * Gateway of the network
     */
    gateway: string;
    /**
     * Network mask
     */
    netmask: string;
    /**
     * IP ranges used for static pool allocation in the network
     */
    staticIpPools?: outputs.ExternalNetworkIpScopeStaticIpPool[];
}

export interface ExternalNetworkIpScopeStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface ExternalNetworkV2IpScope {
    /**
     * Primary DNS server
     */
    dns1?: string;
    /**
     * Secondary DNS server
     */
    dns2?: string;
    /**
     * DNS suffix
     */
    dnsSuffix?: string;
    /**
     * If subnet is enabled
     */
    enabled?: boolean;
    /**
     * Gateway of the network
     */
    gateway: string;
    /**
     * Network mask
     */
    prefixLength: number;
    /**
     * IP ranges used for static pool allocation in the network
     */
    staticIpPools?: outputs.ExternalNetworkV2IpScopeStaticIpPool[];
}

export interface ExternalNetworkV2IpScopeStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface ExternalNetworkV2NsxtNetwork {
    /**
     * ID of NSX-T manager
     */
    nsxtManagerId: string;
    /**
     * Name of NSX-T segment (for NSX-T segment backed external network)
     */
    nsxtSegmentName?: string;
    /**
     * ID of NSX-T Tier-0 router (for T0 gateway backed external network)
     */
    nsxtTier0RouterId?: string;
}

export interface ExternalNetworkV2VsphereNetwork {
    /**
     * The name of the port group
     */
    portgroupId: string;
    /**
     * The vCenter server name
     */
    vcenterId: string;
}

export interface ExternalNetworkVsphereNetwork {
    /**
     * The name of the port group
     */
    name: string;
    /**
     * The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
     */
    type: string;
    /**
     * The vCenter server name
     */
    vcenter: string;
}

export interface GetCatalogFilter {
    /**
     * Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
     */
    date?: string;
    /**
     * Retrieves the oldest item
     */
    earliest?: boolean;
    /**
     * Retrieves the newest item
     */
    latest?: boolean;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetCatalogFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetCatalogFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetCatalogItemFilter {
    /**
     * Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
     */
    date?: string;
    /**
     * Retrieves the oldest item
     */
    earliest?: boolean;
    /**
     * Retrieves the newest item
     */
    latest?: boolean;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetCatalogItemFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetCatalogItemFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetCatalogItemMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetCatalogMediaFilter {
    /**
     * Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
     */
    date?: string;
    /**
     * Retrieves the oldest item
     */
    earliest?: boolean;
    /**
     * Retrieves the newest item
     */
    latest?: boolean;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetCatalogMediaFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetCatalogMediaFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetCatalogMediaMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetCatalogMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetCatalogVappTemplateFilter {
    /**
     * Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
     */
    date?: string;
    /**
     * Retrieves the oldest item
     */
    earliest?: boolean;
    /**
     * Retrieves the newest item
     */
    latest?: boolean;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetCatalogVappTemplateFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetCatalogVappTemplateFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetCatalogVappTemplateLease {
    storageLeaseInSec: number;
}

export interface GetCatalogVappTemplateMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetCseKubernetesClusterControlPlane {
    diskSizeGi: number;
    ip: string;
    machineCount: number;
    placementPolicyId: string;
    sizingPolicyId: string;
    storageProfileId: string;
}

export interface GetCseKubernetesClusterDefaultStorageClass {
    filesystem: string;
    name: string;
    reclaimPolicy: string;
    storageProfileId: string;
}

export interface GetCseKubernetesClusterEvent {
    details: string;
    name: string;
    occurredAt: string;
    resourceId: string;
    type: string;
}

export interface GetCseKubernetesClusterWorkerPool {
    autoscalerMaxReplicas: number;
    autoscalerMinReplicas: number;
    diskSizeGi: number;
    machineCount: number;
    name: string;
    placementPolicyId: string;
    sizingPolicyId: string;
    storageProfileId: string;
    vgpuPolicyId: string;
}

export interface GetDseRegistryConfigurationContainerRegistry {
    description: string;
    host: string;
    password: string;
    username: string;
}

export interface GetEdgegatewayExternalNetwork {
    enableRateLimit: boolean;
    incomingRateLimit: number;
    name: string;
    outgoingRateLimit: number;
    subnets: outputs.GetEdgegatewayExternalNetworkSubnet[];
}

export interface GetEdgegatewayExternalNetworkSubnet {
    gateway: string;
    ipAddress: string;
    netmask: string;
    suballocatePools: outputs.GetEdgegatewayExternalNetworkSubnetSuballocatePool[];
    useForDefaultRoute: boolean;
}

export interface GetEdgegatewayExternalNetworkSubnetSuballocatePool {
    endAddress: string;
    startAddress: string;
}

export interface GetEdgegatewayFilter {
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetExternalNetworkIpScope {
    dns1: string;
    dns2: string;
    dnsSuffix: string;
    gateway: string;
    netmask: string;
    staticIpPools: outputs.GetExternalNetworkIpScopeStaticIpPool[];
}

export interface GetExternalNetworkIpScopeStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetExternalNetworkV2IpScope {
    dns1: string;
    dns2: string;
    dnsSuffix: string;
    enabled: boolean;
    gateway: string;
    prefixLength: number;
    staticIpPools: outputs.GetExternalNetworkV2IpScopeStaticIpPool[];
}

export interface GetExternalNetworkV2IpScopeStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetExternalNetworkV2NsxtNetwork {
    nsxtManagerId: string;
    nsxtSegmentName: string;
    nsxtTier0RouterId: string;
}

export interface GetExternalNetworkV2VsphereNetwork {
    portgroupId: string;
    vcenterId: string;
}

export interface GetExternalNetworkVsphereNetwork {
    name: string;
    type: string;
    vcenter: string;
}

export interface GetIndependentDiskMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetIpSpaceCustomQuotaIpPrefixQuota {
    prefixLength: string;
    quota: string;
}

export interface GetIpSpaceIpPrefix {
    defaultQuota: string;
    prefixes: outputs.GetIpSpaceIpPrefixPrefix[];
}

export interface GetIpSpaceIpPrefixPrefix {
    firstIp: string;
    id: string;
    prefixCount: string;
    prefixLength: string;
}

export interface GetIpSpaceIpRange {
    endAddress: string;
    id: string;
    startAddress: string;
}

export interface GetLbServerPoolMember {
    condition: string;
    id: string;
    ipAddress: string;
    maxConnections: number;
    minConnections: number;
    monitorPort: number;
    name: string;
    port: number;
    weight: number;
}

export interface GetNetworkDirectFilter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetNetworkDirectFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNetworkDirectFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetNetworkDirectMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetNetworkIsolatedDhcpPool {
    defaultLeaseTime: number;
    endAddress: string;
    maxLeaseTime: number;
    startAddress: string;
}

export interface GetNetworkIsolatedFilter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetNetworkIsolatedFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNetworkIsolatedFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetNetworkIsolatedMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetNetworkIsolatedStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNetworkIsolatedV2Filter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNetworkIsolatedV2MetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetNetworkIsolatedV2SecondaryStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNetworkIsolatedV2StaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNetworkPoolBacking {
    distributedSwitches: outputs.GetNetworkPoolBackingDistributedSwitch[];
    portGroups: outputs.GetNetworkPoolBackingPortGroup[];
    rangeIds: outputs.GetNetworkPoolBackingRangeId[];
    transportZones: outputs.GetNetworkPoolBackingTransportZone[];
}

export interface GetNetworkPoolBackingDistributedSwitch {
    id: string;
    name: string;
    type: string;
}

export interface GetNetworkPoolBackingPortGroup {
    id: string;
    name: string;
    type: string;
}

export interface GetNetworkPoolBackingRangeId {
    endId: number;
    startId: number;
}

export interface GetNetworkPoolBackingTransportZone {
    id: string;
    name: string;
    type: string;
}

export interface GetNetworkRoutedDhcpPool {
    defaultLeaseTime: number;
    endAddress: string;
    maxLeaseTime: number;
    startAddress: string;
}

export interface GetNetworkRoutedFilter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetNetworkRoutedFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNetworkRoutedFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetNetworkRoutedMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetNetworkRoutedStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNetworkRoutedV2Filter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNetworkRoutedV2MetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetNetworkRoutedV2SecondaryStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNetworkRoutedV2StaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNsxtAlbPoolHealthMonitor {
    name: string;
    systemDefined: boolean;
    type: string;
}

export interface GetNsxtAlbPoolMember {
    detailedHealthMessage: string;
    enabled: boolean;
    healthStatus: string;
    ipAddress: string;
    markedDownBies: string[];
    port: number;
    ratio: number;
}

export interface GetNsxtAlbPoolPersistenceProfile {
    name: string;
    type: string;
    value: string;
}

export interface GetNsxtAlbVirtualServiceServicePort {
    endPort: number;
    sslEnabled: boolean;
    startPort: number;
    type: string;
}

export interface GetNsxtAppPortProfileAppPort {
    ports: string[];
    protocol: string;
}

export interface GetNsxtDistributedFirewallRule {
    action: string;
    appPortProfileIds: string[];
    comment: string;
    description: string;
    destinationGroupsExcluded: boolean;
    destinationIds: string[];
    direction: string;
    enabled: boolean;
    id: string;
    ipProtocol: string;
    logging: boolean;
    name: string;
    networkContextProfileIds: string[];
    sourceGroupsExcluded: boolean;
    sourceIds: string[];
}

export interface GetNsxtDynamicSecurityGroupCriteria {
    rules: outputs.GetNsxtDynamicSecurityGroupCriteriaRule[];
}

export interface GetNsxtDynamicSecurityGroupCriteriaRule {
    operator: string;
    type: string;
    value: string;
}

export interface GetNsxtDynamicSecurityGroupMemberVm {
    vappId: string;
    vappName: string;
    vmId: string;
    vmName: string;
}

export interface GetNsxtEdgegatewayBgpIpPrefixListIpPrefix {
    action: string;
    greaterThanOrEqualTo: number;
    lessThanOrEqualTo: number;
    network: string;
}

export interface GetNsxtEdgegatewayDnsConditionalForwarderZone {
    domainNames: string[];
    id: string;
    name: string;
    upstreamServers: string[];
}

export interface GetNsxtEdgegatewayDnsDefaultForwarderZone {
    id: string;
    name: string;
    upstreamServers: string[];
}

export interface GetNsxtEdgegatewayExternalNetwork {
    allocatedIpCount: number;
    externalNetworkId: string;
    gateway: string;
    prefixLength: number;
    primaryIp: string;
}

export interface GetNsxtEdgegatewayL2VpnTunnelStretchedNetwork {
    networkId: string;
    tunnelId: number;
}

export interface GetNsxtEdgegatewayStaticRouteNextHop {
    adminDistance: number;
    ipAddress: string;
    scopes: outputs.GetNsxtEdgegatewayStaticRouteNextHopScope[];
}

export interface GetNsxtEdgegatewayStaticRouteNextHopScope {
    id: string;
    name: string;
    type: string;
}

export interface GetNsxtEdgegatewaySubnet {
    allocatedIps: outputs.GetNsxtEdgegatewaySubnetAllocatedIp[];
    gateway: string;
    prefixLength: number;
    primaryIp: string;
}

export interface GetNsxtEdgegatewaySubnetAllocatedIp {
    endAddress: string;
    startAddress: string;
}

export interface GetNsxtEdgegatewaySubnetWithIpCount {
    allocatedIpCount: number;
    gateway: string;
    prefixLength: number;
    primaryIp: string;
}

export interface GetNsxtEdgegatewaySubnetWithTotalIpCount {
    gateway: string;
    prefixLength: number;
    primaryIp: string;
}

export interface GetNsxtFirewallRule {
    action: string;
    appPortProfileIds: string[];
    destinationIds: string[];
    direction: string;
    enabled: boolean;
    id: string;
    ipProtocol: string;
    logging: boolean;
    name: string;
    sourceIds: string[];
}

export interface GetNsxtIpsecVpnTunnelSecurityProfileCustomization {
    dpdProbeInternal: number;
    ikeDhGroups: string[];
    ikeDigestAlgorithms: string[];
    ikeEncryptionAlgorithms: string[];
    ikeSaLifetime: number;
    ikeVersion: string;
    tunnelDfPolicy: string;
    tunnelDhGroups: string[];
    tunnelDigestAlgorithms: string[];
    tunnelEncryptionAlgorithms: string[];
    tunnelPfsEnabled: boolean;
    tunnelSaLifetime: number;
}

export interface GetNsxtNetworkDhcpBindingDhcpV4Config {
    gatewayIpAddress: string;
    hostname: string;
}

export interface GetNsxtNetworkDhcpBindingDhcpV6Config {
    dnsServers: string[];
    sntpServers: string[];
}

export interface GetNsxtNetworkDhcpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNsxtNetworkImportedFilter {
    /**
     * Search by IP. The value can be a regular expression
     */
    ip?: string;
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetNsxtNetworkImportedSecondaryStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNsxtNetworkImportedStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetNsxtSecurityGroupMemberVm {
    vappId: string;
    vappName: string;
    vmId: string;
    vmName: string;
}

export interface GetNsxvApplicationFinderObject {
    name: string;
    type: string;
    value: string;
}

export interface GetNsxvApplicationGroupApplication {
    name: string;
    value: string;
}

export interface GetNsxvDhcpRelayRelayAgent {
    gatewayIpAddress: string;
    networkName: string;
}

export interface GetNsxvDistributedFirewallRule {
    action: string;
    applications: outputs.GetNsxvDistributedFirewallRuleApplication[];
    appliedTos: outputs.GetNsxvDistributedFirewallRuleAppliedTo[];
    destinations: outputs.GetNsxvDistributedFirewallRuleDestination[];
    direction: string;
    enabled: boolean;
    excludeDestination: boolean;
    excludeSource: boolean;
    id: number;
    logged: boolean;
    name: string;
    packetType: string;
    sources: outputs.GetNsxvDistributedFirewallRuleSource[];
}

export interface GetNsxvDistributedFirewallRuleApplication {
    destinationPort: string;
    name: string;
    protocol: string;
    sourcePort: string;
    type: string;
    value: string;
}

export interface GetNsxvDistributedFirewallRuleAppliedTo {
    name: string;
    type: string;
    value: string;
}

export interface GetNsxvDistributedFirewallRuleDestination {
    name: string;
    type: string;
    value: string;
}

export interface GetNsxvDistributedFirewallRuleSource {
    name: string;
    type: string;
    value: string;
}

export interface GetNsxvFirewallRuleDestination {
    exclude: boolean;
    gatewayInterfaces: string[];
    ipAddresses: string[];
    ipSets: string[];
    orgNetworks: string[];
    vmIds: string[];
}

export interface GetNsxvFirewallRuleService {
    port: string;
    protocol: string;
    sourcePort: string;
}

export interface GetNsxvFirewallRuleSource {
    exclude: boolean;
    gatewayInterfaces: string[];
    ipAddresses: string[];
    ipSets: string[];
    orgNetworks: string[];
    vmIds: string[];
}

export interface GetOrgLdapCustomSetting {
    authenticationMethod: string;
    baseDistinguishedName: string;
    connectorType: string;
    groupAttributes: outputs.GetOrgLdapCustomSettingGroupAttribute[];
    isSsl: boolean;
    password: string;
    port: number;
    server: string;
    userAttributes: outputs.GetOrgLdapCustomSettingUserAttribute[];
    username: string;
}

export interface GetOrgLdapCustomSettingGroupAttribute {
    groupBackLinkIdentifier: string;
    groupMembershipIdentifier: string;
    membership: string;
    name: string;
    objectClass: string;
    uniqueIdentifier: string;
}

export interface GetOrgLdapCustomSettingUserAttribute {
    displayName: string;
    email: string;
    givenName: string;
    groupBackLinkIdentifier: string;
    groupMembershipIdentifier: string;
    objectClass: string;
    surname: string;
    telephone: string;
    uniqueIdentifier: string;
    username: string;
}

export interface GetOrgMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetOrgOidcClaimsMapping {
    email: string;
    firstName: string;
    fullName: string;
    groups: string;
    lastName: string;
    roles: string;
    subject: string;
}

export interface GetOrgOidcKey {
    algorithm: string;
    certificate: string;
    expirationDate: string;
    id: string;
}

export interface GetOrgVappLease {
    deleteOnStorageLeaseExpiration: boolean;
    maximumRuntimeLeaseInSec: number;
    maximumStorageLeaseInSec: number;
    powerOffOnRuntimeLeaseExpiration: boolean;
}

export interface GetOrgVappTemplateLease {
    deleteOnStorageLeaseExpiration: boolean;
    maximumStorageLeaseInSec: number;
}

export interface GetOrgVdcComputeCapacity {
    cpus: outputs.GetOrgVdcComputeCapacityCpus[];
    memories: outputs.GetOrgVdcComputeCapacityMemory[];
}

export interface GetOrgVdcComputeCapacityCpus {
    allocated: number;
    limit: number;
    reserved: number;
    used: number;
}

export interface GetOrgVdcComputeCapacityMemory {
    allocated: number;
    limit: number;
    reserved: number;
    used: number;
}

export interface GetOrgVdcMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetOrgVdcStorageProfile {
    default: boolean;
    enabled: boolean;
    limit: number;
    name: string;
    storageUsedInMb: number;
}

export interface GetOrgVdcTemplateComputeConfiguration {
    cpuAllocated: number;
    cpuGuaranteed: number;
    cpuLimit: number;
    cpuSpeed: number;
    elasticity: boolean;
    includeVmMemoryOverhead: boolean;
    memoryAllocated: number;
    memoryGuaranteed: number;
    memoryLimit: number;
}

export interface GetOrgVdcTemplateEdgeGateway {
    description: string;
    ipAllocationCount: number;
    name: string;
    routedNetworkDescription: string;
    routedNetworkGatewayCidr: string;
    routedNetworkName: string;
    staticIpPools: outputs.GetOrgVdcTemplateEdgeGatewayStaticIpPool[];
}

export interface GetOrgVdcTemplateEdgeGatewayStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetOrgVdcTemplateProviderVdc {
    externalNetworkId: string;
    gatewayEdgeClusterId: string;
    id: string;
    servicesEdgeClusterId: string;
}

export interface GetOrgVdcTemplateStorageProfile {
    default: boolean;
    limit: number;
    name: string;
}

export interface GetProviderVdcComputeCapacity {
    cpus: outputs.GetProviderVdcComputeCapacityCpus[];
    isElastic: boolean;
    isHa: boolean;
    memories: outputs.GetProviderVdcComputeCapacityMemory[];
}

export interface GetProviderVdcComputeCapacityCpus {
    allocation: number;
    overhead: number;
    reserved: number;
    total: number;
    units: string;
    used: number;
}

export interface GetProviderVdcComputeCapacityMemory {
    allocation: number;
    overhead: number;
    reserved: number;
    total: number;
    units: string;
    used: number;
}

export interface GetProviderVdcMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetRdeMetadataEntry {
    domain: string;
    id: string;
    key: string;
    namespace: string;
    persistent: boolean;
    readonly: boolean;
    type: string;
    value: string;
}

export interface GetRdeTypeHook {
    behaviorId: string;
    event: string;
}

export interface GetResourceSchemaAttribute {
    computed: boolean;
    description: string;
    name: string;
    optional: boolean;
    required: boolean;
    sensitive: boolean;
    type: string;
}

export interface GetResourceSchemaBlockAttribute {
    attributes: outputs.GetResourceSchemaBlockAttributeAttribute[];
    name: string;
    nestingMode: string;
}

export interface GetResourceSchemaBlockAttributeAttribute {
    computed: boolean;
    description: string;
    name: string;
    optional: boolean;
    required: boolean;
    sensitive: boolean;
    type: string;
}

export interface GetRightImpliedRight {
    id: string;
    name: string;
}

export interface GetSolutionLandingZoneCatalog {
    capabilities: string[];
    id: string;
    name: string;
}

export interface GetSolutionLandingZoneVdc {
    capabilities: string[];
    computePolicies: outputs.GetSolutionLandingZoneVdcComputePolicy[];
    id: string;
    isDefault: boolean;
    name: string;
    orgVdcNetworks: outputs.GetSolutionLandingZoneVdcOrgVdcNetwork[];
    storagePolicies: outputs.GetSolutionLandingZoneVdcStoragePolicy[];
}

export interface GetSolutionLandingZoneVdcComputePolicy {
    capabilities: string[];
    id: string;
    isDefault: boolean;
    name: string;
}

export interface GetSolutionLandingZoneVdcOrgVdcNetwork {
    capabilities: string[];
    id: string;
    isDefault: boolean;
    name: string;
}

export interface GetSolutionLandingZoneVdcStoragePolicy {
    capabilities: string[];
    id: string;
    isDefault: boolean;
    name: string;
}

export interface GetStorageProfileIopsSetting {
    defaultDiskIops: number;
    diskIopsPerGbMax: number;
    iopsLimit: number;
    iopsLimitingEnabled: boolean;
    maximumDiskIops: number;
}

export interface GetStorageProfileMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetSubscribedCatalogFilter {
    /**
     * Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
     */
    date?: string;
    /**
     * Retrieves the oldest item
     */
    earliest?: boolean;
    /**
     * Retrieves the newest item
     */
    latest?: boolean;
    /**
     * metadata filter
     */
    metadatas?: outputs.GetSubscribedCatalogFilterMetadata[];
    /**
     * Search by name with a regular expression
     */
    nameRegex?: string;
}

export interface GetSubscribedCatalogFilterMetadata {
    /**
     * True if is a metadata@SYSTEM key
     */
    isSystem?: boolean;
    /**
     * Metadata key (field name)
     */
    key: string;
    /**
     * Type of metadata value (needed only if "use_api_search" is true)
     */
    type?: string;
    /**
     * If true, will search the vCD using native metadata query (without regular expressions)
     */
    useApiSearch?: boolean;
    /**
     * Metadata value (can be a regular expression if "use_api_search" is false)
     */
    value: string;
}

export interface GetVappLease {
    runtimeLeaseInSec: number;
    storageLeaseInSec: number;
}

export interface GetVappMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetVappNetworkDhcpPool {
    defaultLeaseTime: number;
    enabled: boolean;
    endAddress: string;
    maxLeaseTime: number;
    startAddress: string;
}

export interface GetVappNetworkStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface GetVappVmBootOption {
    bootDelay: number;
    bootRetryDelay: number;
    bootRetryEnabled: boolean;
    efiSecureBoot: boolean;
    enterBiosSetupOnNextBoot: boolean;
}

export interface GetVappVmCustomization {
    adminPassword: string;
    allowLocalAdminPassword: boolean;
    autoGeneratePassword: boolean;
    changeSid: boolean;
    enabled: boolean;
    force: boolean;
    initscript: string;
    joinDomain: boolean;
    joinDomainAccountOu: string;
    joinDomainName: string;
    joinDomainPassword: string;
    joinDomainUser: string;
    joinOrgDomain: boolean;
    mustChangePasswordOnFirstLogin: boolean;
    numberOfAutoLogons: number;
}

export interface GetVappVmDisk {
    busNumber: string;
    name: string;
    sizeInMb: number;
    unitNumber: string;
}

export interface GetVappVmExtraConfig {
    key: string;
    required: boolean;
    value: string;
}

export interface GetVappVmInternalDisk {
    busNumber: number;
    busType: string;
    diskId: string;
    iops: number;
    sizeInMb: number;
    storageProfile: string;
    thinProvisioned: boolean;
    unitNumber: number;
}

export interface GetVappVmMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetVappVmNetwork {
    adapterType: string;
    connected: boolean;
    ip: string;
    ipAllocationMode: string;
    isPrimary: boolean;
    mac: string;
    name: string;
    type: string;
}

export interface GetVdcGroupParticipatingOrgVdc {
    faultDomainTag: string;
    isRemoteOrg: boolean;
    networkProviderScope: string;
    orgId: string;
    orgName: string;
    siteId: string;
    siteName: string;
    status: string;
    vdcId: string;
    vdcName: string;
}

export interface GetVmBootOption {
    bootDelay: number;
    bootRetryDelay: number;
    bootRetryEnabled: boolean;
    efiSecureBoot: boolean;
    enterBiosSetupOnNextBoot: boolean;
}

export interface GetVmCustomization {
    adminPassword: string;
    allowLocalAdminPassword: boolean;
    autoGeneratePassword: boolean;
    changeSid: boolean;
    enabled: boolean;
    force: boolean;
    initscript: string;
    joinDomain: boolean;
    joinDomainAccountOu: string;
    joinDomainName: string;
    joinDomainPassword: string;
    joinDomainUser: string;
    joinOrgDomain: boolean;
    mustChangePasswordOnFirstLogin: boolean;
    numberOfAutoLogons: number;
}

export interface GetVmDisk {
    busNumber: string;
    name: string;
    sizeInMb: number;
    unitNumber: string;
}

export interface GetVmExtraConfig {
    key: string;
    required: boolean;
    value: string;
}

export interface GetVmInternalDisk {
    busNumber: number;
    busType: string;
    diskId: string;
    iops: number;
    sizeInMb: number;
    storageProfile: string;
    thinProvisioned: boolean;
    unitNumber: number;
}

export interface GetVmMetadataEntry {
    isSystem: boolean;
    key: string;
    type: string;
    userAccess: string;
    value: string;
}

export interface GetVmNetwork {
    adapterType: string;
    connected: boolean;
    ip: string;
    ipAllocationMode: string;
    isPrimary: boolean;
    mac: string;
    name: string;
    type: string;
}

export interface GetVmSizingPolicyCpus {
    coresPerSocket: string;
    count: string;
    limitInMhz: string;
    reservationGuarantee: string;
    shares: string;
    speedInMhz: string;
}

export interface GetVmSizingPolicyMemory {
    limitInMb: string;
    reservationGuarantee: string;
    shares: string;
    sizeInMb: string;
}

export interface GetVmVgpuPolicyCpus {
    coresPerSocket: string;
    count: string;
    limitInMhz: string;
    reservationGuarantee: string;
    shares: string;
    speedInMhz: string;
}

export interface GetVmVgpuPolicyMemory {
    limitInMb: string;
    reservationGuarantee: string;
    shares: string;
    sizeInMb: string;
}

export interface GetVmVgpuPolicyProviderVdcScope {
    clusterNames: string[];
    providerVdcId: string;
    vmGroupId: string;
}

export interface GetVmVgpuPolicyVgpuProfile {
    count: number;
    id: string;
}

export interface IndependentDiskMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface IpSpaceCustomQuotaIpPrefixQuota {
    /**
     * Prefix length
     */
    prefixLength: string;
    /**
     * IP Prefix Quota
     */
    quota: string;
}

export interface IpSpaceIpPrefix {
    /**
     * Floating IP quota
     */
    defaultQuota?: string;
    /**
     * One or more prefixes
     */
    prefixes: outputs.IpSpaceIpPrefixPrefix[];
}

export interface IpSpaceIpPrefixPrefix {
    /**
     * First IP
     */
    firstIp: string;
    /**
     * ID of IP Prefix
     */
    id: string;
    /**
     * Number of prefixes to define
     */
    prefixCount: string;
    /**
     * Prefix length
     */
    prefixLength: string;
}

export interface IpSpaceIpRange {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * ID of IP Range
     */
    id: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface LbServerPoolMember {
    /**
     * Defines member state. One of enabled, drain, disabled.
     */
    condition: string;
    /**
     * Pool member id (formatted as member-xx, where xx is a number)
     */
    id: string;
    /**
     * IP address of member in server pool
     */
    ipAddress: string;
    /**
     * The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
     */
    maxConnections?: number;
    /**
     * Minimum number of concurrent connections a member must always accept
     */
    minConnections?: number;
    /**
     * Port at which the member is to receive health monitor requests. Can be the same as port
     */
    monitorPort: number;
    /**
     * Name of pool member
     */
    name: string;
    /**
     * Port at which the member is to receive traffic from the load balancer
     */
    port: number;
    /**
     * Proportion of traffic this member is to handle. Must be an integer in the range 1-256
     */
    weight: number;
}

export interface NetworkDirectMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface NetworkIsolatedDhcpPool {
    /**
     * The default DHCP lease time to use
     */
    defaultLeaseTime?: number;
    /**
     * The final address in the IP Range
     */
    endAddress: string;
    /**
     * The maximum DHCP lease time to use
     */
    maxLeaseTime?: number;
    /**
     * The first address in the IP Range
     */
    startAddress: string;
}

export interface NetworkIsolatedMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface NetworkIsolatedStaticIpPool {
    /**
     * The final address in the IP Range
     */
    endAddress: string;
    /**
     * The first address in the IP Range
     */
    startAddress: string;
}

export interface NetworkIsolatedV2MetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface NetworkIsolatedV2SecondaryStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NetworkIsolatedV2StaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NetworkPoolBacking {
    /**
     * Backing distributed switches
     */
    distributedSwitch?: outputs.NetworkPoolBackingDistributedSwitch;
    /**
     * Backing port groups
     */
    portGroups?: outputs.NetworkPoolBackingPortGroup[];
    /**
     * Distributed Switch ID ranges (used with VLAN)
     */
    rangeIds?: outputs.NetworkPoolBackingRangeId[];
    /**
     * Transport Zone Backing
     */
    transportZone?: outputs.NetworkPoolBackingTransportZone;
}

export interface NetworkPoolBackingDistributedSwitch {
    /**
     * Backing ID
     */
    id: string;
    /**
     * Backing name
     */
    name: string;
    /**
     * Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
     */
    type: string;
}

export interface NetworkPoolBackingPortGroup {
    /**
     * Backing ID
     */
    id: string;
    /**
     * Backing name
     */
    name: string;
    /**
     * Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
     */
    type: string;
}

export interface NetworkPoolBackingRangeId {
    /**
     * End of the IDs range
     */
    endId: number;
    /**
     * Start of the IDs range
     */
    startId: number;
}

export interface NetworkPoolBackingTransportZone {
    /**
     * Backing ID
     */
    id: string;
    /**
     * Backing name
     */
    name: string;
    /**
     * Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
     */
    type: string;
}

export interface NetworkRoutedDhcpPool {
    /**
     * The default DHCP lease time to use
     */
    defaultLeaseTime: number;
    /**
     * The final address in the IP Range
     */
    endAddress: string;
    /**
     * The maximum DHCP lease time to use
     */
    maxLeaseTime?: number;
    /**
     * The first address in the IP Range
     */
    startAddress: string;
}

export interface NetworkRoutedMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface NetworkRoutedStaticIpPool {
    /**
     * The final address in the IP Range
     */
    endAddress: string;
    /**
     * The first address in the IP Range
     */
    startAddress: string;
}

export interface NetworkRoutedV2MetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface NetworkRoutedV2SecondaryStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NetworkRoutedV2StaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NsxtAlbPoolHealthMonitor {
    name: string;
    systemDefined: boolean;
    /**
     * Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
     */
    type: string;
}

export interface NsxtAlbPoolMember {
    /**
     * Detailed health message
     */
    detailedHealthMessage: string;
    /**
     * Defines if pool member is accepts traffic (default 'true')
     */
    enabled?: boolean;
    /**
     * Health status
     */
    healthStatus: string;
    /**
     * IP address of pool member
     */
    ipAddress: string;
    /**
     * Marked down by provides a set of health monitors that marked the service down
     */
    markedDownBies: string[];
    /**
     * Member port
     */
    port?: number;
    /**
     * Ratio of selecting eligible servers in the pool
     */
    ratio?: number;
}

export interface NsxtAlbPoolPersistenceProfile {
    /**
     * System generated name of persistence profile
     */
    name: string;
    /**
     * Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
     */
    type: string;
    /**
     * Value of attribute based on persistence type
     */
    value?: string;
}

export interface NsxtAlbVirtualServiceServicePort {
    /**
     * Last port in the range
     */
    endPort?: number;
    /**
     * Defines if certificate should be used
     */
    sslEnabled?: boolean;
    /**
     * Starting port in the range
     */
    startPort: number;
    /**
     * One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
     */
    type: string;
}

export interface NsxtAppPortProfileAppPort {
    /**
     * Set of ports or ranges
     */
    ports?: string[];
    protocol: string;
}

export interface NsxtDistributedFirewallRule {
    /**
     * Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
     */
    action: string;
    /**
     * A set of Application Port Profile IDs. Leaving it empty means 'Any'
     */
    appPortProfileIds?: string[];
    /**
     * Comment that is shown next to rule in UI (VCD 10.3.2+)
     */
    comment?: string;
    /**
     * Description is not shown in UI
     */
    description?: string;
    /**
     * Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
     */
    destinationGroupsExcluded?: boolean;
    /**
     * A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
     */
    destinationIds?: string[];
    /**
     * Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
     */
    direction?: string;
    /**
     * Defined if Firewall Rule is active
     */
    enabled?: boolean;
    /**
     * Firewall Rule ID
     */
    id: string;
    /**
     * Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
     */
    ipProtocol?: string;
    /**
     * Defines if matching traffic should be logged
     */
    logging?: boolean;
    /**
     * Firewall Rule name
     */
    name: string;
    /**
     * A set of Network Context Profile IDs. Leaving it empty means 'Any'
     */
    networkContextProfileIds?: string[];
    /**
     * Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
     */
    sourceGroupsExcluded?: boolean;
    /**
     * A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
     */
    sourceIds?: string[];
}

export interface NsxtDynamicSecurityGroupCriteria {
    /**
     * Up to 4 rules can be used to define single criteria (VCD 10.2, 10.3)
     */
    rules?: outputs.NsxtDynamicSecurityGroupCriteriaRule[];
}

export interface NsxtDynamicSecurityGroupCriteriaRule {
    /**
     * Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
     */
    operator: string;
    /**
     * Type of object matching 'VM_TAG' or 'VM_NAME'
     */
    type: string;
    /**
     * Filter value
     */
    value: string;
}

export interface NsxtDynamicSecurityGroupMemberVm {
    vappId: string;
    vappName: string;
    vmId: string;
    vmName: string;
}

export interface NsxtEdgegatewayBgpIpPrefixListIpPrefix {
    /**
     * Action 'PERMIT' or 'DENY'
     */
    action: string;
    /**
     * Greater than or equal to subnet mask
     */
    greaterThanOrEqualTo?: number;
    /**
     * Less than or equal to subnet mask
     */
    lessThanOrEqualTo?: number;
    /**
     * Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
     */
    network: string;
}

export interface NsxtEdgegatewayDnsConditionalForwarderZone {
    /**
     * Set of domain names on which conditional forwarding is based.
     */
    domainNames: string[];
    /**
     * Unique ID of the forwarder zone.
     */
    id: string;
    /**
     * Name of the forwarder zone.
     */
    name: string;
    /**
     * Servers to which DNS requests should be forwarded to.
     */
    upstreamServers: string[];
}

export interface NsxtEdgegatewayDnsDefaultForwarderZone {
    /**
     * Unique ID of the forwarder zone.
     */
    id: string;
    /**
     * Name of the forwarder zone.
     */
    name: string;
    /**
     * Servers to which DNS requests should be forwarded to.
     */
    upstreamServers: string[];
}

export interface NsxtEdgegatewayExternalNetwork {
    /**
     * Number of allocated IPs
     */
    allocatedIpCount: number;
    /**
     * NSX-T Segment backed External Network ID
     */
    externalNetworkId: string;
    /**
     * Gateway IP Address
     */
    gateway: string;
    /**
     * Prefix length for a subnet (e.g. 24)
     */
    prefixLength: number;
    /**
     * Primary IP address for the Edge Gateway - will be auto-assigned if not defined
     */
    primaryIp: string;
}

export interface NsxtEdgegatewayL2VpnTunnelStretchedNetwork {
    /**
     * ID of the Org VDC network
     */
    networkId: string;
    /**
     * Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
     */
    tunnelId: number;
}

export interface NsxtEdgegatewayStaticRouteNextHop {
    /**
     * Admin distance of next hop
     */
    adminDistance: number;
    /**
     * IP Address of next hop
     */
    ipAddress: string;
    scope?: outputs.NsxtEdgegatewayStaticRouteNextHopScope;
}

export interface NsxtEdgegatewayStaticRouteNextHopScope {
    /**
     * ID of Scope element
     */
    id: string;
    /**
     * Name of Scope element
     */
    name: string;
    /**
     * Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
     */
    type: string;
}

export interface NsxtEdgegatewaySubnet {
    /**
     * Define one or more blocks to sub-allocate pools on the edge gateway
     */
    allocatedIps?: outputs.NsxtEdgegatewaySubnetAllocatedIp[];
    /**
     * Gateway address for a subnet
     */
    gateway: string;
    /**
     * Prefix length for a subnet (e.g. 24)
     */
    prefixLength: number;
    /**
     * Primary IP address for the edge gateway - will be auto-assigned if not defined
     */
    primaryIp?: string;
}

export interface NsxtEdgegatewaySubnetAllocatedIp {
    endAddress: string;
    startAddress: string;
}

export interface NsxtEdgegatewaySubnetWithIpCount {
    /**
     * Number of IP addresses to allocate
     */
    allocatedIpCount: number;
    /**
     * Gateway address for a subnet
     */
    gateway: string;
    /**
     * Prefix length for a subnet (e.g. 24)
     */
    prefixLength: number;
    /**
     * Primary IP address for the edge gateway - will be auto-assigned if not defined
     */
    primaryIp: string;
}

export interface NsxtEdgegatewaySubnetWithTotalIpCount {
    /**
     * Gateway address for a subnet
     */
    gateway: string;
    /**
     * Prefix length for a subnet (e.g. 24)
     */
    prefixLength: number;
    /**
     * Primary IP address for the edge gateway - will be auto-assigned if not defined
     */
    primaryIp: string;
}

export interface NsxtFirewallRule {
    /**
     * Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
     */
    action: string;
    /**
     * A set of Application Port Profile IDs. Leaving it empty means 'Any'
     */
    appPortProfileIds?: string[];
    /**
     * A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
     */
    destinationIds?: string[];
    /**
     * Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
     */
    direction: string;
    /**
     * Defined if Firewall Rule is active
     */
    enabled?: boolean;
    /**
     * Firewall Rule ID
     */
    id: string;
    /**
     * Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
     */
    ipProtocol: string;
    /**
     * Defines if matching traffic should be logged
     */
    logging?: boolean;
    /**
     * Firewall Rule name
     */
    name: string;
    /**
     * A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
     */
    sourceIds?: string[];
}

export interface NsxtIpsecVpnTunnelSecurityProfileCustomization {
    /**
     * Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
     */
    dpdProbeInternal?: number;
    /**
     * Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
     */
    ikeDhGroups: string[];
    /**
     * Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
     */
    ikeDigestAlgorithms?: string[];
    /**
     * Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
     */
    ikeEncryptionAlgorithms: string[];
    /**
     * Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
     */
    ikeSaLifetime?: number;
    /**
     * IKE version one of IKE_V1, IKE_V2, IKE_FLEX
     */
    ikeVersion: string;
    /**
     * Policy for handling defragmentation bit. One of COPY, CLEAR
     */
    tunnelDfPolicy?: string;
    /**
     * Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
     */
    tunnelDhGroups: string[];
    /**
     * Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
     */
    tunnelDigestAlgorithms?: string[];
    /**
     * Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
     */
    tunnelEncryptionAlgorithms: string[];
    /**
     * Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
     */
    tunnelPfsEnabled?: boolean;
    /**
     * Security Association life time (in seconds)
     */
    tunnelSaLifetime?: number;
}

export interface NsxtNetworkDhcpBindingDhcpV4Config {
    /**
     * IPv4 gateway address
     */
    gatewayIpAddress?: string;
    /**
     * Hostname for the DHCP client
     */
    hostname?: string;
}

export interface NsxtNetworkDhcpBindingDhcpV6Config {
    /**
     * Set of domain names
     */
    domainNames?: string[];
    /**
     * Set of SNTP servers
     */
    sntpServers?: string[];
}

export interface NsxtNetworkDhcpPool {
    /**
     * End address of DHCP pool IP range
     */
    endAddress: string;
    /**
     * Start address of DHCP pool IP range
     */
    startAddress: string;
}

export interface NsxtNetworkImportedSecondaryStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NsxtNetworkImportedStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface NsxtSecurityGroupMemberVm {
    vappId: string;
    vappName: string;
    vmId: string;
    vmName: string;
}

export interface NsxvDhcpRelayRelayAgent {
    /**
     * Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
     */
    gatewayIpAddress: string;
    /**
     * Org network which is to be used for relaying DHCP message to specified servers
     */
    networkName: string;
}

export interface NsxvDistributedFirewallRule {
    /**
     * Action of the rule (allow, deny)
     */
    action: string;
    /**
     * Application definitions for this rule. An empty value means 'any'
     */
    applications?: outputs.NsxvDistributedFirewallRuleApplication[];
    /**
     * List of elements to which this rule applies
     */
    appliedTos: outputs.NsxvDistributedFirewallRuleAppliedTo[];
    /**
     * List of destination traffic for this rule. An empty value means 'any'
     */
    destinations?: outputs.NsxvDistributedFirewallRuleDestination[];
    /**
     * Direction of the rule (in, out, inout)
     */
    direction: string;
    /**
     * Whether the rule is enabled
     */
    enabled?: boolean;
    /**
     * If true, the content of the destination elements is reversed
     */
    excludeDestination?: boolean;
    /**
     * If true, the content of the source elements is reversed
     */
    excludeSource?: boolean;
    /**
     * Firewall Rule ID
     */
    id: number;
    /**
     * Whether the rule traffic is logged
     */
    logged?: boolean;
    /**
     * Firewall Rule name
     */
    name?: string;
    /**
     * Packet type of the rule (any, ipv4, ipv6)
     */
    packetType?: string;
    /**
     * List of source traffic for this rule. An empty value means 'any'
     */
    sources?: outputs.NsxvDistributedFirewallRuleSource[];
}

export interface NsxvDistributedFirewallRuleApplication {
    /**
     * Destination port for this application. Leaving it empty means 'any' port
     */
    destinationPort?: string;
    /**
     * Name of application (Application, ApplicationGroup)
     */
    name?: string;
    /**
     * Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
     */
    protocol?: string;
    /**
     * Source port for this application. Leaving it empty means 'any' port
     */
    sourcePort?: string;
    /**
     * Type of application
     */
    type?: string;
    /**
     * Value of the application
     */
    value?: string;
}

export interface NsxvDistributedFirewallRuleAppliedTo {
    /**
     * Name of the applied-to entity
     */
    name: string;
    /**
     * Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
     */
    type: string;
    /**
     * Value of the applied-to entity
     */
    value: string;
}

export interface NsxvDistributedFirewallRuleDestination {
    /**
     * Name of the destination entity
     */
    name: string;
    /**
     * Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
     */
    type: string;
    /**
     * Value of the destination entity
     */
    value: string;
}

export interface NsxvDistributedFirewallRuleSource {
    /**
     * Name of the source entity
     */
    name: string;
    /**
     * Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
     */
    type: string;
    /**
     * Value of the source entity
     */
    value: string;
}

export interface NsxvFirewallRuleDestination {
    /**
     * Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
     */
    exclude?: boolean;
    /**
     * 'vse', 'internal', 'external' or network name
     */
    gatewayInterfaces?: string[];
    /**
     * IP address, CIDR, an IP range, or the keyword 'any'
     */
    ipAddresses?: string[];
    /**
     * Set of IP set names
     */
    ipSets?: string[];
    /**
     * Set of org network names
     */
    orgNetworks?: string[];
    /**
     * Set of VM IDs
     */
    vmIds?: string[];
}

export interface NsxvFirewallRuleService {
    port: string;
    protocol: string;
    sourcePort: string;
}

export interface NsxvFirewallRuleSource {
    /**
     * Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
     */
    exclude?: boolean;
    /**
     * 'vse', 'internal', 'external' or network name
     */
    gatewayInterfaces?: string[];
    /**
     * IP address, CIDR, an IP range, or the keyword 'any'
     */
    ipAddresses?: string[];
    /**
     * Set of IP set names
     */
    ipSets?: string[];
    /**
     * Set of org network names
     */
    orgNetworks?: string[];
    /**
     * Set of VM IDs
     */
    vmIds?: string[];
}

export interface OrgLdapCustomSettings {
    /**
     * authentication method: one of SIMPLE, MD5DIGEST, NTLM
     */
    authenticationMethod: string;
    /**
     * LDAP search base
     */
    baseDistinguishedName?: string;
    /**
     * type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
     */
    connectorType: string;
    /**
     * Group settings when `ldap_mode` is CUSTOM
     */
    groupAttributes: outputs.OrgLdapCustomSettingsGroupAttributes;
    /**
     * True if the LDAP service requires an SSL connection
     */
    isSsl?: boolean;
    /**
     * Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
     */
    password?: string;
    /**
     * Port number for LDAP service
     */
    port: number;
    /**
     * host name or IP of the LDAP server
     */
    server: string;
    /**
     * User settings when `ldap_mode` is CUSTOM
     */
    userAttributes: outputs.OrgLdapCustomSettingsUserAttributes;
    /**
     * Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
     */
    username?: string;
}

export interface OrgLdapCustomSettingsGroupAttributes {
    /**
     * LDAP group attribute used to identify a group member
     */
    groupBackLinkIdentifier?: string;
    /**
     * LDAP attribute that identifies a group as a member of another group. For example, dn
     */
    groupMembershipIdentifier: string;
    /**
     * LDAP attribute to use when getting the members of a group. For example, member
     */
    membership: string;
    /**
     * LDAP attribute to use for the group name. For example, cn
     */
    name: string;
    /**
     * LDAP objectClass of which imported groups are members. For example, group
     */
    objectClass: string;
    /**
     * LDAP attribute to use as the unique identifier for a group. For example, objectGuid
     */
    uniqueIdentifier: string;
}

export interface OrgLdapCustomSettingsUserAttributes {
    /**
     * LDAP attribute to use for the user's full name. For example, displayName
     */
    displayName: string;
    /**
     * LDAP attribute to use for the user's email address. For example, mail
     */
    email: string;
    /**
     * LDAP attribute to use for the user's given name. For example, givenName
     */
    givenName: string;
    /**
     * LDAP attribute that returns the identifiers of all the groups of which the user is a member
     */
    groupBackLinkIdentifier?: string;
    /**
     * LDAP attribute that identifies a user as a member of a group. For example, dn
     */
    groupMembershipIdentifier: string;
    /**
     * LDAP objectClass of which imported users are members. For example, user or person
     */
    objectClass: string;
    /**
     * LDAP attribute to use for the user's surname. For example, sn
     */
    surname: string;
    /**
     * LDAP attribute to use for the user's telephone number. For example, telephoneNumber
     */
    telephone: string;
    /**
     * LDAP attribute to use as the unique identifier for a user. For example, objectGuid
     */
    uniqueIdentifier: string;
    /**
     * LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
     */
    username: string;
}

export interface OrgMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface OrgOidcClaimsMapping {
    /**
     * Email claim mapping
     */
    email: string;
    /**
     * First name claim mapping
     */
    firstName: string;
    /**
     * Full name claim mapping
     */
    fullName: string;
    /**
     * Groups claim mapping
     */
    groups: string;
    /**
     * Last name claim mapping
     */
    lastName: string;
    /**
     * Roles claim mapping
     */
    roles: string;
    /**
     * Subject claim mapping
     */
    subject: string;
}

export interface OrgOidcKey {
    /**
     * Algorithm of the key, either RSA or EC
     */
    algorithm: string;
    /**
     * The certificate contents
     */
    certificate: string;
    /**
     * Expiration date for the certificate
     */
    expirationDate?: string;
    /**
     * ID of the key
     */
    id: string;
}

export interface OrgVappLease {
    /**
     * If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
     */
    deleteOnStorageLeaseExpiration: boolean;
    /**
     * How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
     */
    maximumRuntimeLeaseInSec: number;
    /**
     * How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
     */
    maximumStorageLeaseInSec: number;
    /**
     * When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
     */
    powerOffOnRuntimeLeaseExpiration: boolean;
}

export interface OrgVappTemplateLease {
    /**
     * If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
     */
    deleteOnStorageLeaseExpiration: boolean;
    /**
     * How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
     */
    maximumStorageLeaseInSec: number;
}

export interface OrgVdcAccessControlSharedWith {
    /**
     * The access level for the user or group to which we are sharing. (Only ReadOnly is available)
     */
    accessLevel: string;
    /**
     * ID of the group to which we are sharing. Required if user_id is not set
     */
    groupId?: string;
    /**
     * Name of the subject (group or user) with which we are sharing
     */
    subjectName: string;
    /**
     * ID of the user to which we are sharing. Required if group_id is not set
     */
    userId?: string;
}

export interface OrgVdcComputeCapacity {
    cpu: outputs.OrgVdcComputeCapacityCpu;
    memory: outputs.OrgVdcComputeCapacityMemory;
}

export interface OrgVdcComputeCapacityCpu {
    /**
     * Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
     */
    allocated: number;
    /**
     * Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
     */
    limit: number;
    reserved: number;
    used: number;
}

export interface OrgVdcComputeCapacityMemory {
    /**
     * Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
     */
    allocated: number;
    /**
     * Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
     */
    limit: number;
    reserved: number;
    used: number;
}

export interface OrgVdcMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface OrgVdcStorageProfile {
    /**
     * True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
     */
    default: boolean;
    /**
     * True if this storage profile is enabled for use in the VDC.
     */
    enabled?: boolean;
    /**
     * Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
     */
    limit: number;
    /**
     * Name of Provider VDC storage profile.
     */
    name: string;
    /**
     * Storage used in MB
     */
    storageUsedInMb: number;
}

export interface OrgVdcTemplateComputeConfiguration {
    /**
     * AllocationPool, ReservationPool, Flex: The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
     */
    cpuAllocated?: number;
    /**
     * AllocationVApp, AllocationPool, Flex: The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
     */
    cpuGuaranteed?: number;
    /**
     * AllocationVApp, ReservationPool, Flex: The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
     */
    cpuLimit: number;
    /**
     * AllocationVApp, AllocationPool, Flex: Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
     */
    cpuSpeed?: number;
    /**
     * Flex only: True if compute capacity can grow or shrink based on demand
     */
    elasticity: boolean;
    /**
     * Flex only: True if the instantiated VDC includes memory overhead into its accounting for admission control
     */
    includeVmMemoryOverhead: boolean;
    /**
     * AllocationPool, ReservationPool, Flex: The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
     */
    memoryAllocated?: number;
    /**
     * AllocationVApp, AllocationPool, Flex: The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
     */
    memoryGuaranteed?: number;
    /**
     * AllocationVApp, ReservationPool, Flex: The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
     */
    memoryLimit?: number;
}

export interface OrgVdcTemplateEdgeGateway {
    /**
     * Description of the Edge Gateway
     */
    description?: string;
    /**
     * Allocated IPs for the Edge Gateway
     */
    ipAllocationCount?: number;
    /**
     * Name of the Edge Gateway
     */
    name: string;
    /**
     * Description of the routed network to create with the Edge Gateway
     */
    routedNetworkDescription?: string;
    /**
     * CIDR of the Edge Gateway for the created routed network
     */
    routedNetworkGatewayCidr: string;
    /**
     * Name of the routed network to create with the Edge Gateway
     */
    routedNetworkName: string;
    /**
     * IP ranges used for the network created with the Edge Gateway. Only required if the 'edge_gateway' block is used
     */
    staticIpPool?: outputs.OrgVdcTemplateEdgeGatewayStaticIpPool;
}

export interface OrgVdcTemplateEdgeGatewayStaticIpPool {
    /**
     * End address of the IP range
     */
    endAddress: string;
    /**
     * Start address of the IP range
     */
    startAddress: string;
}

export interface OrgVdcTemplateProviderVdc {
    /**
     * ID of the External network that the VDCs instantiated from this template will use
     */
    externalNetworkId: string;
    /**
     * ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway
     */
    gatewayEdgeClusterId?: string;
    /**
     * ID of Provider VDC
     */
    id: string;
    /**
     * ID of the Edge Cluster that the VDCs instantiated from this template will use for services
     */
    servicesEdgeClusterId?: string;
}

export interface OrgVdcTemplateStorageProfile {
    /**
     * True if this is default storage profile for the VDCs instantiated from this template
     */
    default: boolean;
    /**
     * Storage limit for the VDCs instantiated from this template, in Megabytes. 0 means unlimited
     */
    limit: number;
    /**
     * Name of Provider VDC storage profile to use for the VDCs instantiated from this template
     */
    name: string;
}

export interface ProviderVdcComputeCapacity {
    cpus: outputs.ProviderVdcComputeCapacityCpus[];
    isElastic: boolean;
    isHa: boolean;
    memories: outputs.ProviderVdcComputeCapacityMemory[];
}

export interface ProviderVdcComputeCapacityCpus {
    allocation: number;
    overhead: number;
    reserved: number;
    total: number;
    units: string;
    used: number;
}

export interface ProviderVdcComputeCapacityMemory {
    allocation: number;
    overhead: number;
    reserved: number;
    total: number;
    units: string;
    used: number;
}

export interface ProviderVdcMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry
     */
    key: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry
     */
    value: string;
}

export interface RdeMetadataEntry {
    /**
     * Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
     */
    domain?: string;
    /**
     * ID of the metadata entry
     */
    id: string;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key: string;
    /**
     * Namespace of the metadata entry
     */
    namespace?: string;
    /**
     * Persistent metadata entries can be copied over on some entity operation
     */
    persistent?: boolean;
    /**
     * True if the metadata entry is read only
     */
    readonly?: boolean;
    /**
     * Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
     */
    type?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value: string;
}

export interface RdeTypeHook {
    /**
     * Existing Behavior that will be automatically invoked when the RDE of this RDE Type triggers the event
     */
    behaviorId: string;
    /**
     * Event that will invoke the Behavior, one of PostCreate, PostUpdate, PreDelete, PostDelete
     */
    event: string;
}

export interface SolutionLandingZoneCatalog {
    /**
     * Capability set for catalog
     */
    capabilities?: string[];
    /**
     * ID of catalog
     */
    id: string;
    /**
     * Catalog Name
     */
    name: string;
}

export interface SolutionLandingZoneVdc {
    /**
     * Capability set for VDC
     */
    capabilities?: string[];
    /**
     * Structure for Compute Policy
     */
    computePolicies: outputs.SolutionLandingZoneVdcComputePolicy[];
    /**
     * ID of VDC
     */
    id: string;
    /**
     * Defines if the entity should be considered as default
     */
    isDefault: boolean;
    /**
     * VDC Name
     */
    name: string;
    /**
     * Structure for Org VDC Network
     */
    orgVdcNetworks: outputs.SolutionLandingZoneVdcOrgVdcNetwork[];
    /**
     * Structure for Storage Policy
     */
    storagePolicies: outputs.SolutionLandingZoneVdcStoragePolicy[];
}

export interface SolutionLandingZoneVdcComputePolicy {
    /**
     * Set of capabilities for Compute Policy
     */
    capabilities?: string[];
    /**
     * ID of Compute Policy
     */
    id: string;
    /**
     * Boolean value that marks if this Compute Policy should be default
     */
    isDefault?: boolean;
    /**
     * Name of Compute Policy
     */
    name: string;
}

export interface SolutionLandingZoneVdcOrgVdcNetwork {
    /**
     * Set of capabilities for Org VDC Network
     */
    capabilities?: string[];
    /**
     * ID of Org VDC Network
     */
    id: string;
    /**
     * Boolean value that marks if this Org VDC Network should be default
     */
    isDefault?: boolean;
    /**
     * Name of Org VDC Network
     */
    name: string;
}

export interface SolutionLandingZoneVdcStoragePolicy {
    /**
     * Set of capabilities for Storage Policy
     */
    capabilities?: string[];
    /**
     * ID of Storage Policy
     */
    id: string;
    /**
     * Boolean value that marks if this Storage Policy should be default
     */
    isDefault?: boolean;
    /**
     * Name of Storage Policy
     */
    name: string;
}

export interface VappAccessControlSharedWith {
    /**
     * The access level for the user or group to which we are sharing. (One of ReadOnly, Change, FullControl)
     */
    accessLevel: string;
    /**
     * ID of the group to which we are sharing. Required if user_id is not set
     */
    groupId?: string;
    /**
     * Name of the subject (group or user) with which we are sharing
     */
    subjectName: string;
    /**
     * ID of the user to which we are sharing. Required if group_id is not set
     */
    userId?: string;
}

export interface VappFirewallRulesRule {
    /**
     * Destination IP address to which the rule applies. A value of `Any` matches any IP address.
     */
    destinationIp?: string;
    /**
     * Destination port to which this rule applies.
     */
    destinationPort?: string;
    /**
     * Destination VM identifier
     */
    destinationVmId?: string;
    /**
     * The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
     */
    destinationVmIpType?: string;
    /**
     * Destination VM NIC ID to which this rule applies.
     */
    destinationVmNicId?: number;
    /**
     * 'true' value will enable rule logging. Default is false
     */
    enableLogging?: boolean;
    /**
     * 'true' value will enable firewall rule
     */
    enabled?: boolean;
    /**
     * Rule name
     */
    name?: string;
    /**
     * One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
     */
    policy?: string;
    /**
     * Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
     */
    protocol?: string;
    /**
     * Source IP address to which the rule applies. A value of `Any` matches any IP address.
     */
    sourceIp?: string;
    /**
     * Source port to which this rule applies.
     */
    sourcePort?: string;
    /**
     * Source VM identifier
     */
    sourceVmId?: string;
    /**
     * The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
     */
    sourceVmIpType?: string;
    /**
     * Source VM NIC ID to which this rule applies.
     */
    sourceVmNicId?: number;
}

export interface VappLease {
    /**
     * How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires
     */
    runtimeLeaseInSec: number;
    /**
     * How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires
     */
    storageLeaseInSec: number;
}

export interface VappMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface VappNatRulesRule {
    /**
     * External IP address to forward to or External IP address to map to VM
     */
    externalIp: string;
    /**
     * External port to forward.
     */
    externalPort?: number;
    /**
     * Internal port to forward.
     */
    forwardToPort?: number;
    /**
     * ID of the rule. Can be used to track syslog messages.
     */
    id: string;
    /**
     * Mapping mode. One of: `automatic`, `manual`
     */
    mappingMode?: string;
    /**
     * Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
     */
    protocol?: string;
    /**
     * VM to which this rule applies.
     */
    vmId: string;
    /**
     * VM NIC ID to which this rule applies.
     */
    vmNicId: number;
}

export interface VappNetworkDhcpPool {
    defaultLeaseTime?: number;
    enabled?: boolean;
    endAddress?: string;
    maxLeaseTime?: number;
    startAddress: string;
}

export interface VappNetworkStaticIpPool {
    endAddress: string;
    startAddress: string;
}

export interface VappStaticRoutingRule {
    /**
     * Name for the static route.
     */
    name: string;
    /**
     * network specification in CIDR.
     */
    networkCidr: string;
    /**
     * IP Address of Next Hop router/gateway.
     */
    nextHopIp: string;
}

export interface VappVmBootOptions {
    /**
     * Number of milliseconds to wait between powering-on and booting the VM
     */
    bootDelay: number;
    /**
     * Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
     */
    bootRetryDelay: number;
    /**
     * If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
     */
    bootRetryEnabled: boolean;
    /**
     * If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
     */
    efiSecureBoot: boolean;
    enterBiosSetupOnNextBoot?: boolean;
}

export interface VappVmCustomization {
    /**
     * Manually specify admin password
     */
    adminPassword: string;
    /**
     * Allow local administrator password
     */
    allowLocalAdminPassword: boolean;
    /**
     * Auto generate password
     */
    autoGeneratePassword: boolean;
    /**
     * 'true' value will change SID. Applicable only for Windows VMs
     */
    changeSid: boolean;
    /**
     * 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
     */
    enabled: boolean;
    /**
     * 'true' value will cause the VM to reboot on every 'apply' operation
     */
    force?: boolean;
    /**
     * Script to run on initial boot or with customization.force=true set
     */
    initscript: string;
    /**
     * Enable this VM to join a domain
     */
    joinDomain: boolean;
    /**
     * Account organizational unit for domain name join
     */
    joinDomainAccountOu: string;
    /**
     * Custom domain name for join
     */
    joinDomainName: string;
    /**
     * Password for custom domain name join
     */
    joinDomainPassword: string;
    /**
     * Username for custom domain name join
     */
    joinDomainUser: string;
    /**
     * Use organization's domain for joining
     */
    joinOrgDomain: boolean;
    /**
     * Require Administrator to change password on first login
     */
    mustChangePasswordOnFirstLogin: boolean;
    /**
     * Number of times to log on automatically. '0' - disabled.
     */
    numberOfAutoLogons: number;
}

export interface VappVmDisk {
    /**
     * Bus number on which to place the disk controller
     */
    busNumber: string;
    /**
     * Independent disk name
     */
    name: string;
    /**
     * The size of the disk in MB.
     */
    sizeInMb: number;
    /**
     * Unit number (slot) on the bus specified by BusNumber
     */
    unitNumber: string;
}

export interface VappVmExtraConfig {
    key: string;
    required: boolean;
    value: string;
}

export interface VappVmInternalDisk {
    busNumber: number;
    busType: string;
    diskId: string;
    iops: number;
    sizeInMb: number;
    storageProfile: string;
    thinProvisioned: boolean;
    unitNumber: number;
}

export interface VappVmMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface VappVmNetwork {
    /**
     * Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
     */
    adapterType: string;
    /**
     * It defines if NIC is connected or not.
     */
    connected?: boolean;
    /**
     * IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
     */
    ip: string;
    /**
     * IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
     */
    ipAllocationMode?: string;
    /**
     * Set to true if network interface should be primary. First network card in the list will be primary by default
     */
    isPrimary: boolean;
    /**
     * Mac address of network interface
     */
    mac: string;
    /**
     * Name of the network this VM should connect to. Always required except for `type` `NONE`
     */
    name?: string;
    /**
     * Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
     */
    type: string;
}

export interface VappVmOverrideTemplateDisk {
    /**
     * The number of the SCSI or IDE controller itself.
     */
    busNumber: number;
    /**
     * The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
     */
    busType: string;
    /**
     * Specifies the IOPS for the disk. Default is 0.
     */
    iops?: number;
    /**
     * The size of the disk in MB.
     */
    sizeInMb: number;
    /**
     * Storage profile to override the VM default one
     */
    storageProfile?: string;
    /**
     * The device number on the SCSI or IDE controller of the disk.
     */
    unitNumber: number;
}

export interface VappVmSetExtraConfig {
    /**
     * The key of the extra configuration item
     */
    key: string;
    /**
     * The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
     */
    value: string;
}

export interface VdcGroupParticipatingOrgVdc {
    faultDomainTag: string;
    isRemoteOrg: boolean;
    networkProviderScope: string;
    orgId: string;
    orgName: string;
    siteId: string;
    siteName: string;
    status: string;
    vdcId: string;
    vdcName: string;
}

export interface VmBootOptions {
    /**
     * Number of milliseconds to wait between powering-on and booting the VM
     */
    bootDelay: number;
    /**
     * Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
     */
    bootRetryDelay: number;
    /**
     * If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
     */
    bootRetryEnabled: boolean;
    /**
     * If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
     */
    efiSecureBoot: boolean;
    enterBiosSetupOnNextBoot?: boolean;
}

export interface VmCustomization {
    /**
     * Manually specify admin password
     */
    adminPassword: string;
    /**
     * Allow local administrator password
     */
    allowLocalAdminPassword: boolean;
    /**
     * Auto generate password
     */
    autoGeneratePassword: boolean;
    /**
     * 'true' value will change SID. Applicable only for Windows VMs
     */
    changeSid: boolean;
    /**
     * 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
     */
    enabled: boolean;
    /**
     * 'true' value will cause the VM to reboot on every 'apply' operation
     */
    force?: boolean;
    /**
     * Script to run on initial boot or with customization.force=true set
     */
    initscript: string;
    /**
     * Enable this VM to join a domain
     */
    joinDomain: boolean;
    /**
     * Account organizational unit for domain name join
     */
    joinDomainAccountOu: string;
    /**
     * Custom domain name for join
     */
    joinDomainName: string;
    /**
     * Password for custom domain name join
     */
    joinDomainPassword: string;
    /**
     * Username for custom domain name join
     */
    joinDomainUser: string;
    /**
     * Use organization's domain for joining
     */
    joinOrgDomain: boolean;
    /**
     * Require Administrator to change password on first login
     */
    mustChangePasswordOnFirstLogin: boolean;
    /**
     * Number of times to log on automatically. '0' - disabled.
     */
    numberOfAutoLogons: number;
}

export interface VmDisk {
    /**
     * Bus number on which to place the disk controller
     */
    busNumber: string;
    /**
     * Independent disk name
     */
    name: string;
    /**
     * The size of the disk in MB.
     */
    sizeInMb: number;
    /**
     * Unit number (slot) on the bus specified by BusNumber
     */
    unitNumber: string;
}

export interface VmExtraConfig {
    key: string;
    required: boolean;
    value: string;
}

export interface VmInternalDisk {
    busNumber: number;
    busType: string;
    diskId: string;
    iops: number;
    sizeInMb: number;
    storageProfile: string;
    thinProvisioned: boolean;
    unitNumber: number;
}

export interface VmMetadataEntry {
    /**
     * Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
     */
    isSystem?: boolean;
    /**
     * Key of this metadata entry. Required if the metadata entry is not empty
     */
    key?: string;
    /**
     * Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
     */
    type?: string;
    /**
     * User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
     */
    userAccess?: string;
    /**
     * Value of this metadata entry. Required if the metadata entry is not empty
     */
    value?: string;
}

export interface VmNetwork {
    /**
     * Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
     */
    adapterType: string;
    /**
     * It defines if NIC is connected or not.
     */
    connected?: boolean;
    /**
     * IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
     */
    ip: string;
    /**
     * IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
     */
    ipAllocationMode?: string;
    /**
     * Set to true if network interface should be primary. First network card in the list will be primary by default
     */
    isPrimary: boolean;
    /**
     * Mac address of network interface
     */
    mac: string;
    /**
     * Name of the network this VM should connect to. Always required except for `type` `NONE`
     */
    name?: string;
    /**
     * Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
     */
    type: string;
}

export interface VmOverrideTemplateDisk {
    /**
     * The number of the SCSI or IDE controller itself.
     */
    busNumber: number;
    /**
     * The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
     */
    busType: string;
    /**
     * Specifies the IOPS for the disk. Default is 0.
     */
    iops?: number;
    /**
     * The size of the disk in MB.
     */
    sizeInMb: number;
    /**
     * Storage profile to override the VM default one
     */
    storageProfile?: string;
    /**
     * The device number on the SCSI or IDE controller of the disk.
     */
    unitNumber: number;
}

export interface VmSetExtraConfig {
    /**
     * The key of the extra configuration item
     */
    key: string;
    /**
     * The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
     */
    value: string;
}

export interface VmSizingPolicyCpu {
    /**
     * The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
     */
    coresPerSocket?: string;
    /**
     * Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
     */
    count?: string;
    /**
     * Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
     */
    limitInMhz?: string;
    /**
     * Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
     */
    reservationGuarantee?: string;
    /**
     * Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
     */
    shares?: string;
    /**
     * Defines the vCPU speed of a core in MHz.
     */
    speedInMhz?: string;
}

export interface VmSizingPolicyMemory {
    /**
     * Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
     */
    limitInMb?: string;
    /**
     * Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
     */
    reservationGuarantee?: string;
    /**
     * Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
     */
    shares?: string;
    /**
     * Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
     */
    sizeInMb?: string;
}

export interface VmVgpuPolicyCpu {
    /**
     * The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
     */
    coresPerSocket?: string;
    /**
     * Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
     */
    count?: string;
    /**
     * Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
     */
    limitInMhz?: string;
    /**
     * Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
     */
    reservationGuarantee?: string;
    /**
     * Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
     */
    shares?: string;
    /**
     * Defines the vCPU speed of a core in MHz.
     */
    speedInMhz?: string;
}

export interface VmVgpuPolicyMemory {
    /**
     * Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
     */
    limitInMb?: string;
    /**
     * Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
     */
    reservationGuarantee?: string;
    /**
     * Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
     */
    shares?: string;
    /**
     * Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
     */
    sizeInMb?: string;
}

export interface VmVgpuPolicyProviderVdcScope {
    /**
     * Set of cluster names within the provider virtual data center.
     */
    clusterNames?: string[];
    /**
     * Identifier for the provider virtual data center.
     */
    providerVdcId: string;
    /**
     * Optional identifier for a VM group within the provider VDC scope.
     */
    vmGroupId?: string;
}

export interface VmVgpuPolicyVgpuProfile {
    /**
     * Specifies the number of vGPU profiles. Must be at least 1.
     */
    count: number;
    /**
     * The identifier of the vGPU profile.
     */
    id: string;
}

export namespace config {
    export interface IgnoreMetadataChanges {
        conflictAction?: string;
        /**
         * Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required
         */
        keyRegex?: string;
        /**
         * Ignores metadata from the specific entity in VCD named like this argument
         */
        resourceName?: string;
        /**
         * Ignores metadata from the specific resource type
         */
        resourceType?: string;
        /**
         * Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required
         */
        valueRegex?: string;
    }

}
