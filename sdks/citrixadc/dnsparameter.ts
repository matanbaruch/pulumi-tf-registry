// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Dnsparameter extends pulumi.CustomResource {
    /**
     * Get an existing Dnsparameter resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DnsparameterState, opts?: pulumi.CustomResourceOptions): Dnsparameter {
        return new Dnsparameter(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'citrixadc:index/dnsparameter:Dnsparameter';

    /**
     * Returns true if the given object is an instance of Dnsparameter.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Dnsparameter {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Dnsparameter.__pulumiType;
    }

    public readonly cacheecszeroprefix!: pulumi.Output<string>;
    public readonly cachehitbypass!: pulumi.Output<string>;
    public readonly cachenoexpire!: pulumi.Output<string>;
    public readonly cacherecords!: pulumi.Output<string>;
    public readonly dns64timeout!: pulumi.Output<number>;
    public readonly dnsrootreferral!: pulumi.Output<string>;
    public readonly dnssec!: pulumi.Output<string>;
    public readonly ecsmaxsubnets!: pulumi.Output<number>;
    public readonly maxcachesize!: pulumi.Output<number>;
    public readonly maxnegativecachesize!: pulumi.Output<number>;
    public readonly maxnegcachettl!: pulumi.Output<number>;
    public readonly maxpipeline!: pulumi.Output<number>;
    public readonly maxttl!: pulumi.Output<number>;
    public readonly maxudppacketsize!: pulumi.Output<number>;
    public readonly minttl!: pulumi.Output<number>;
    public readonly namelookuppriority!: pulumi.Output<string>;
    public readonly nxdomainratelimitthreshold!: pulumi.Output<number>;
    public readonly recursion!: pulumi.Output<string>;
    public readonly resolutionorder!: pulumi.Output<string>;
    public readonly retries!: pulumi.Output<number>;
    public readonly splitpktqueryprocessing!: pulumi.Output<string>;

    /**
     * Create a Dnsparameter resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: DnsparameterArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DnsparameterArgs | DnsparameterState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DnsparameterState | undefined;
            resourceInputs["cacheecszeroprefix"] = state ? state.cacheecszeroprefix : undefined;
            resourceInputs["cachehitbypass"] = state ? state.cachehitbypass : undefined;
            resourceInputs["cachenoexpire"] = state ? state.cachenoexpire : undefined;
            resourceInputs["cacherecords"] = state ? state.cacherecords : undefined;
            resourceInputs["dns64timeout"] = state ? state.dns64timeout : undefined;
            resourceInputs["dnsrootreferral"] = state ? state.dnsrootreferral : undefined;
            resourceInputs["dnssec"] = state ? state.dnssec : undefined;
            resourceInputs["ecsmaxsubnets"] = state ? state.ecsmaxsubnets : undefined;
            resourceInputs["maxcachesize"] = state ? state.maxcachesize : undefined;
            resourceInputs["maxnegativecachesize"] = state ? state.maxnegativecachesize : undefined;
            resourceInputs["maxnegcachettl"] = state ? state.maxnegcachettl : undefined;
            resourceInputs["maxpipeline"] = state ? state.maxpipeline : undefined;
            resourceInputs["maxttl"] = state ? state.maxttl : undefined;
            resourceInputs["maxudppacketsize"] = state ? state.maxudppacketsize : undefined;
            resourceInputs["minttl"] = state ? state.minttl : undefined;
            resourceInputs["namelookuppriority"] = state ? state.namelookuppriority : undefined;
            resourceInputs["nxdomainratelimitthreshold"] = state ? state.nxdomainratelimitthreshold : undefined;
            resourceInputs["recursion"] = state ? state.recursion : undefined;
            resourceInputs["resolutionorder"] = state ? state.resolutionorder : undefined;
            resourceInputs["retries"] = state ? state.retries : undefined;
            resourceInputs["splitpktqueryprocessing"] = state ? state.splitpktqueryprocessing : undefined;
        } else {
            const args = argsOrState as DnsparameterArgs | undefined;
            resourceInputs["cacheecszeroprefix"] = args ? args.cacheecszeroprefix : undefined;
            resourceInputs["cachehitbypass"] = args ? args.cachehitbypass : undefined;
            resourceInputs["cachenoexpire"] = args ? args.cachenoexpire : undefined;
            resourceInputs["cacherecords"] = args ? args.cacherecords : undefined;
            resourceInputs["dns64timeout"] = args ? args.dns64timeout : undefined;
            resourceInputs["dnsrootreferral"] = args ? args.dnsrootreferral : undefined;
            resourceInputs["dnssec"] = args ? args.dnssec : undefined;
            resourceInputs["ecsmaxsubnets"] = args ? args.ecsmaxsubnets : undefined;
            resourceInputs["maxcachesize"] = args ? args.maxcachesize : undefined;
            resourceInputs["maxnegativecachesize"] = args ? args.maxnegativecachesize : undefined;
            resourceInputs["maxnegcachettl"] = args ? args.maxnegcachettl : undefined;
            resourceInputs["maxpipeline"] = args ? args.maxpipeline : undefined;
            resourceInputs["maxttl"] = args ? args.maxttl : undefined;
            resourceInputs["maxudppacketsize"] = args ? args.maxudppacketsize : undefined;
            resourceInputs["minttl"] = args ? args.minttl : undefined;
            resourceInputs["namelookuppriority"] = args ? args.namelookuppriority : undefined;
            resourceInputs["nxdomainratelimitthreshold"] = args ? args.nxdomainratelimitthreshold : undefined;
            resourceInputs["recursion"] = args ? args.recursion : undefined;
            resourceInputs["resolutionorder"] = args ? args.resolutionorder : undefined;
            resourceInputs["retries"] = args ? args.retries : undefined;
            resourceInputs["splitpktqueryprocessing"] = args ? args.splitpktqueryprocessing : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Dnsparameter.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Dnsparameter resources.
 */
export interface DnsparameterState {
    cacheecszeroprefix?: pulumi.Input<string>;
    cachehitbypass?: pulumi.Input<string>;
    cachenoexpire?: pulumi.Input<string>;
    cacherecords?: pulumi.Input<string>;
    dns64timeout?: pulumi.Input<number>;
    dnsrootreferral?: pulumi.Input<string>;
    dnssec?: pulumi.Input<string>;
    ecsmaxsubnets?: pulumi.Input<number>;
    maxcachesize?: pulumi.Input<number>;
    maxnegativecachesize?: pulumi.Input<number>;
    maxnegcachettl?: pulumi.Input<number>;
    maxpipeline?: pulumi.Input<number>;
    maxttl?: pulumi.Input<number>;
    maxudppacketsize?: pulumi.Input<number>;
    minttl?: pulumi.Input<number>;
    namelookuppriority?: pulumi.Input<string>;
    nxdomainratelimitthreshold?: pulumi.Input<number>;
    recursion?: pulumi.Input<string>;
    resolutionorder?: pulumi.Input<string>;
    retries?: pulumi.Input<number>;
    splitpktqueryprocessing?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Dnsparameter resource.
 */
export interface DnsparameterArgs {
    cacheecszeroprefix?: pulumi.Input<string>;
    cachehitbypass?: pulumi.Input<string>;
    cachenoexpire?: pulumi.Input<string>;
    cacherecords?: pulumi.Input<string>;
    dns64timeout?: pulumi.Input<number>;
    dnsrootreferral?: pulumi.Input<string>;
    dnssec?: pulumi.Input<string>;
    ecsmaxsubnets?: pulumi.Input<number>;
    maxcachesize?: pulumi.Input<number>;
    maxnegativecachesize?: pulumi.Input<number>;
    maxnegcachettl?: pulumi.Input<number>;
    maxpipeline?: pulumi.Input<number>;
    maxttl?: pulumi.Input<number>;
    maxudppacketsize?: pulumi.Input<number>;
    minttl?: pulumi.Input<number>;
    namelookuppriority?: pulumi.Input<string>;
    nxdomainratelimitthreshold?: pulumi.Input<number>;
    recursion?: pulumi.Input<string>;
    resolutionorder?: pulumi.Input<string>;
    retries?: pulumi.Input<number>;
    splitpktqueryprocessing?: pulumi.Input<string>;
}
