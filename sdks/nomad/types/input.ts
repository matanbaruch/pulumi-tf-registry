// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AclAuthMethodConfig {
    /**
     * A list of allowed values that can be used for the redirect URI.
     */
    allowedRedirectUris?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of auth claims that are valid for login.
     */
    boundAudiences?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The value against which to match the iss claim in a JWT.
     */
    boundIssuers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Mappings of claims (key) that will be copied to a metadata field (value).
     */
    claimMappings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Duration of leeway when validating all claims in the form of a time duration such as "5m" or "1h".
     */
    clockSkewLeeway?: pulumi.Input<string>;
    /**
     * PEM encoded CA certs for use by the TLS client used to talk with the OIDC Discovery URL.
     */
    discoveryCaPems?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Duration of leeway when validating expiration of a JWT in the form of a time duration such as "5m" or "1h".
     */
    expirationLeeway?: pulumi.Input<string>;
    /**
     * PEM encoded CA cert for use by the TLS client used to talk with the JWKS server.
     */
    jwksCaCert?: pulumi.Input<string>;
    /**
     * JSON Web Key Sets url for authenticating signatures.
     */
    jwksUrl?: pulumi.Input<string>;
    /**
     * List of PEM-encoded public keys to use to authenticate signatures locally.
     */
    jwtValidationPubKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Mappings of list claims (key) that will be copied to a metadata field (value).
     */
    listClaimMappings?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Duration of leeway when validating not before values of a token in the form of a time duration such as "5m" or "1h".
     */
    notBeforeLeeway?: pulumi.Input<string>;
    /**
     * The OAuth Client ID configured with the OIDC provider.
     */
    oidcClientId?: pulumi.Input<string>;
    /**
     * The OAuth Client Secret configured with the OIDC provider.
     */
    oidcClientSecret?: pulumi.Input<string>;
    /**
     * Nomad will not make a request to the identity provider to get OIDC UserInfo.
     */
    oidcDisableUserinfo?: pulumi.Input<boolean>;
    /**
     * The OIDC Discovery URL, without any .well-known component (base path).
     */
    oidcDiscoveryUrl?: pulumi.Input<string>;
    /**
     * List of OIDC scopes.
     */
    oidcScopes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of supported signing algorithms.
     */
    signingAlgs?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface AclPolicyJobAcl {
    /**
     * Group
     */
    group?: pulumi.Input<string>;
    /**
     * Job
     */
    jobId: pulumi.Input<string>;
    /**
     * Namespace
     */
    namespace?: pulumi.Input<string>;
    /**
     * Task
     */
    task?: pulumi.Input<string>;
}

export interface AclRolePolicy {
    /**
     * The name of the ACL policy to link.
     */
    name: pulumi.Input<string>;
}

export interface AclTokenRole {
    /**
     * The ID of the ACL role to link.
     */
    id: pulumi.Input<string>;
    /**
     * The name of the ACL role linked.
     */
    name?: pulumi.Input<string>;
}

export interface CsiVolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: pulumi.Input<string>;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: pulumi.Input<string>;
}

export interface CsiVolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: pulumi.Input<string>;
    /**
     * The flags passed to mount.
     */
    mountFlags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CsiVolumeRegistrationCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: pulumi.Input<string>;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: pulumi.Input<string>;
}

export interface CsiVolumeRegistrationMountOptions {
    /**
     * The file system type.
     */
    fsType?: pulumi.Input<string>;
    /**
     * The flags passed to mount.
     */
    mountFlags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CsiVolumeRegistrationTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface CsiVolumeRegistrationTopology {
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface CsiVolumeRegistrationTopologyRequest {
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: pulumi.Input<inputs.CsiVolumeRegistrationTopologyRequestRequired>;
}

export interface CsiVolumeRegistrationTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.CsiVolumeRegistrationTopologyRequestRequiredTopology>[]>;
}

export interface CsiVolumeRegistrationTopologyRequestRequiredTopology {
    /**
     * Define attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface CsiVolumeTimeouts {
    create?: pulumi.Input<string>;
    delete?: pulumi.Input<string>;
}

export interface CsiVolumeTopology {
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface CsiVolumeTopologyRequest {
    /**
     * Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.
     */
    preferred?: pulumi.Input<inputs.CsiVolumeTopologyRequestPreferred>;
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: pulumi.Input<inputs.CsiVolumeTopologyRequestRequired>;
}

export interface CsiVolumeTopologyRequestPreferred {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.CsiVolumeTopologyRequestPreferredTopology>[]>;
}

export interface CsiVolumeTopologyRequestPreferredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface CsiVolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.CsiVolumeTopologyRequestRequiredTopology>[]>;
}

export interface CsiVolumeTopologyRequestRequiredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ExternalVolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: pulumi.Input<string>;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: pulumi.Input<string>;
}

export interface ExternalVolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: pulumi.Input<string>;
    /**
     * The flags passed to mount.
     */
    mountFlags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ExternalVolumeTopology {
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ExternalVolumeTopologyRequest {
    /**
     * Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.
     */
    preferred?: pulumi.Input<inputs.ExternalVolumeTopologyRequestPreferred>;
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: pulumi.Input<inputs.ExternalVolumeTopologyRequestRequired>;
}

export interface ExternalVolumeTopologyRequestPreferred {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.ExternalVolumeTopologyRequestPreferredTopology>[]>;
}

export interface ExternalVolumeTopologyRequestPreferredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface ExternalVolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.ExternalVolumeTopologyRequestRequiredTopology>[]>;
}

export interface ExternalVolumeTopologyRequestRequiredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface JobHcl2 {
    /**
     * If true, HCL2 file system functions will be enabled when parsing the `jobspec`.
     */
    allowFs?: pulumi.Input<boolean>;
    /**
     * If true, the `jobspec` will be parsed as HCL2 instead of HCL.
     *
     * @deprecated Deprecated
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Additional variables to use when templating the job with HCL2
     */
    vars?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface JobTaskGroup {
    count: pulumi.Input<number>;
    meta: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
    tasks: pulumi.Input<pulumi.Input<inputs.JobTaskGroupTask>[]>;
    volumes: pulumi.Input<pulumi.Input<inputs.JobTaskGroupVolume>[]>;
}

export interface JobTaskGroupTask {
    driver: pulumi.Input<string>;
    meta: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    name: pulumi.Input<string>;
    volumeMounts: pulumi.Input<pulumi.Input<inputs.JobTaskGroupTaskVolumeMount>[]>;
}

export interface JobTaskGroupTaskVolumeMount {
    destination: pulumi.Input<string>;
    readOnly: pulumi.Input<boolean>;
    volume: pulumi.Input<string>;
}

export interface JobTaskGroupVolume {
    name: pulumi.Input<string>;
    readOnly: pulumi.Input<boolean>;
    source: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface JobTimeouts {
    create?: pulumi.Input<string>;
    update?: pulumi.Input<string>;
}

export interface NamespaceCapabilities {
    /**
     * Disabled task drivers for the namespace.
     */
    disabledTaskDrivers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enabled task drivers for the namespace.
     */
    enabledTaskDrivers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface NamespaceNodePoolConfig {
    /**
     * The list of node pools allowed to be used in this namespace. Cannot be used with denied.
     */
    alloweds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The node pool to use when none are specified in the job.
     */
    default?: pulumi.Input<string>;
    /**
     * The list of node pools not allowed to be used in this namespace. Cannot be used with allowed.
     */
    denieds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface NodePoolSchedulerConfig {
    /**
     * If true, the node pool will have memory oversubscription enabled.
     */
    memoryOversubscription?: pulumi.Input<string>;
    /**
     * The scheduler algorithm to use in the node pool.
     */
    schedulerAlgorithm?: pulumi.Input<string>;
}

export interface ProviderHeader {
    /**
     * The header name
     */
    name: pulumi.Input<string>;
    /**
     * The header value
     */
    value: pulumi.Input<string>;
}

export interface QuotaSpecificationLimit {
    /**
     * Region in which this limit has affect.
     */
    region: pulumi.Input<string>;
    /**
     * The limit applied to this region.
     */
    regionLimit: pulumi.Input<inputs.QuotaSpecificationLimitRegionLimit>;
}

export interface QuotaSpecificationLimitRegionLimit {
    cpu?: pulumi.Input<number>;
    memoryMb?: pulumi.Input<number>;
}

export interface VolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: pulumi.Input<string>;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: pulumi.Input<string>;
}

export interface VolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: pulumi.Input<string>;
    /**
     * The flags passed to mount.
     */
    mountFlags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface VolumeTopology {
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}

export interface VolumeTopologyRequest {
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: pulumi.Input<inputs.VolumeTopologyRequestRequired>;
}

export interface VolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: pulumi.Input<pulumi.Input<inputs.VolumeTopologyRequestRequiredTopology>[]>;
}

export interface VolumeTopologyRequestRequiredTopology {
    /**
     * Define attributes for the topology request.
     */
    segments: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
}
export namespace config {
}
