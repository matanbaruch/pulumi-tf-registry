// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AclAuthMethodConfig {
    /**
     * A list of allowed values that can be used for the redirect URI.
     */
    allowedRedirectUris?: string[];
    /**
     * List of auth claims that are valid for login.
     */
    boundAudiences?: string[];
    /**
     * The value against which to match the iss claim in a JWT.
     */
    boundIssuers?: string[];
    /**
     * Mappings of claims (key) that will be copied to a metadata field (value).
     */
    claimMappings?: {[key: string]: string};
    /**
     * Duration of leeway when validating all claims in the form of a time duration such as "5m" or "1h".
     */
    clockSkewLeeway?: string;
    /**
     * PEM encoded CA certs for use by the TLS client used to talk with the OIDC Discovery URL.
     */
    discoveryCaPems?: string[];
    /**
     * Duration of leeway when validating expiration of a JWT in the form of a time duration such as "5m" or "1h".
     */
    expirationLeeway?: string;
    /**
     * PEM encoded CA cert for use by the TLS client used to talk with the JWKS server.
     */
    jwksCaCert?: string;
    /**
     * JSON Web Key Sets url for authenticating signatures.
     */
    jwksUrl?: string;
    /**
     * List of PEM-encoded public keys to use to authenticate signatures locally.
     */
    jwtValidationPubKeys?: string[];
    /**
     * Mappings of list claims (key) that will be copied to a metadata field (value).
     */
    listClaimMappings?: {[key: string]: string};
    /**
     * Duration of leeway when validating not before values of a token in the form of a time duration such as "5m" or "1h".
     */
    notBeforeLeeway?: string;
    /**
     * The OAuth Client ID configured with the OIDC provider.
     */
    oidcClientId?: string;
    /**
     * The OAuth Client Secret configured with the OIDC provider.
     */
    oidcClientSecret?: string;
    /**
     * Nomad will not make a request to the identity provider to get OIDC UserInfo.
     */
    oidcDisableUserinfo?: boolean;
    /**
     * The OIDC Discovery URL, without any .well-known component (base path).
     */
    oidcDiscoveryUrl?: string;
    /**
     * List of OIDC scopes.
     */
    oidcScopes?: string[];
    /**
     * A list of supported signing algorithms.
     */
    signingAlgs?: string[];
}

export interface AclPolicyJobAcl {
    /**
     * Group
     */
    group?: string;
    /**
     * Job
     */
    jobId: string;
    /**
     * Namespace
     */
    namespace?: string;
    /**
     * Task
     */
    task?: string;
}

export interface AclRolePolicy {
    /**
     * The name of the ACL policy to link.
     */
    name: string;
}

export interface AclTokenRole {
    /**
     * The ID of the ACL role to link.
     */
    id: string;
    /**
     * The name of the ACL role linked.
     */
    name: string;
}

export interface CsiVolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: string;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: string;
}

export interface CsiVolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: string;
    /**
     * The flags passed to mount.
     */
    mountFlags?: string[];
}

export interface CsiVolumeRegistrationCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: string;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: string;
}

export interface CsiVolumeRegistrationMountOptions {
    /**
     * The file system type.
     */
    fsType?: string;
    /**
     * The flags passed to mount.
     */
    mountFlags?: string[];
}

export interface CsiVolumeRegistrationTimeouts {
    create?: string;
    delete?: string;
}

export interface CsiVolumeRegistrationTopology {
    segments: {[key: string]: string};
}

export interface CsiVolumeRegistrationTopologyRequest {
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: outputs.CsiVolumeRegistrationTopologyRequestRequired;
}

export interface CsiVolumeRegistrationTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.CsiVolumeRegistrationTopologyRequestRequiredTopology[];
}

export interface CsiVolumeRegistrationTopologyRequestRequiredTopology {
    /**
     * Define attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export interface CsiVolumeTimeouts {
    create?: string;
    delete?: string;
}

export interface CsiVolumeTopology {
    segments: {[key: string]: string};
}

export interface CsiVolumeTopologyRequest {
    /**
     * Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.
     */
    preferred?: outputs.CsiVolumeTopologyRequestPreferred;
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: outputs.CsiVolumeTopologyRequestRequired;
}

export interface CsiVolumeTopologyRequestPreferred {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.CsiVolumeTopologyRequestPreferredTopology[];
}

export interface CsiVolumeTopologyRequestPreferredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export interface CsiVolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.CsiVolumeTopologyRequestRequiredTopology[];
}

export interface CsiVolumeTopologyRequestRequiredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export interface ExternalVolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: string;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: string;
}

export interface ExternalVolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: string;
    /**
     * The flags passed to mount.
     */
    mountFlags?: string[];
}

export interface ExternalVolumeTopology {
    segments: {[key: string]: string};
}

export interface ExternalVolumeTopologyRequest {
    /**
     * Preferred topologies indicate that the volume should be created in a location accessible from some of the listed topologies.
     */
    preferred?: outputs.ExternalVolumeTopologyRequestPreferred;
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: outputs.ExternalVolumeTopologyRequestRequired;
}

export interface ExternalVolumeTopologyRequestPreferred {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.ExternalVolumeTopologyRequestPreferredTopology[];
}

export interface ExternalVolumeTopologyRequestPreferredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export interface ExternalVolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.ExternalVolumeTopologyRequestRequiredTopology[];
}

export interface ExternalVolumeTopologyRequestRequiredTopology {
    /**
     * Define the attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export interface GetAclPoliciesPolicy {
    description: string;
    name: string;
}

export interface GetAclRolePolicy {
    name: string;
}

export interface GetAclRolesAclRole {
    description: string;
    id: string;
    name: string;
    policies: outputs.GetAclRolesAclRolePolicy[];
}

export interface GetAclRolesAclRolePolicy {
    name: string;
}

export interface GetAclTokenRole {
    id: string;
    name: string;
}

export interface GetAclTokensAclToken {
    accessorId: string;
    createTime: string;
    expirationTime: string;
    global: boolean;
    name: string;
    policies: string[];
    roles: outputs.GetAclTokensAclTokenRole[];
    type: string;
}

export interface GetAclTokensAclTokenRole {
    id: string;
    name: string;
}

export interface GetAllocationsAllocation {
    clientStatus: string;
    createIndex: number;
    createTime: number;
    desiredStatus: string;
    evalId: string;
    followupEvalId: string;
    id: string;
    jobId: string;
    jobType: string;
    jobVersion: number;
    modifyIndex: number;
    modifyTime: number;
    name: string;
    namespace: string;
    nextAllocation: string;
    nodeId: string;
    nodeName: string;
    preemptedByAllocation: string;
    taskGroup: string;
}

export interface GetJobConstraint {
    ltarget: string;
    operand: string;
    rtarget: string;
}

export interface GetJobPeriodicConfig {
    enabled: boolean;
    prohibitOverlap: boolean;
    spec: string;
    specType: string;
    timezone: string;
}

export interface GetJobTaskGroup {
    count: number;
    meta: {[key: string]: string};
    name: string;
    tasks: outputs.GetJobTaskGroupTask[];
    volumes: outputs.GetJobTaskGroupVolume[];
}

export interface GetJobTaskGroupTask {
    driver: string;
    meta: {[key: string]: string};
    name: string;
    volumeMounts: outputs.GetJobTaskGroupTaskVolumeMount[];
}

export interface GetJobTaskGroupTaskVolumeMount {
    destination: string;
    readOnly: boolean;
    volume: string;
}

export interface GetJobTaskGroupVolume {
    name: string;
    readOnly: boolean;
    source: string;
    type: string;
}

export interface GetJwksKey {
    algorithm: string;
    exponent: string;
    keyId: string;
    keyType: string;
    keyUse: string;
    modulus: string;
}

export interface GetNamespaceCapability {
    disabledTaskDrivers: string[];
    enabledTaskDrivers: string[];
}

export interface GetNamespaceNodePoolConfig {
    alloweds: string[];
    default: string;
    denieds: string[];
}

export interface GetNodePoolSchedulerConfig {
    memoryOversubscription: string;
    schedulerAlgorithm: string;
}

export interface GetNodePoolsNodePool {
    description: string;
    meta: {[key: string]: string};
    name: string;
    schedulerConfigs: outputs.GetNodePoolsNodePoolSchedulerConfig[];
}

export interface GetNodePoolsNodePoolSchedulerConfig {
    memoryOversubscription: string;
    schedulerAlgorithm: string;
}

export interface GetPluginNode {
    healthy: boolean;
    healthyDescription: string;
    name: string;
}

export interface GetScalingPoliciesPolicy {
    enabled: boolean;
    id: string;
    target: {[key: string]: string};
    type: string;
}

export interface JobHcl2 {
    /**
     * If true, HCL2 file system functions will be enabled when parsing the `jobspec`.
     */
    allowFs?: boolean;
    /**
     * If true, the `jobspec` will be parsed as HCL2 instead of HCL.
     *
     * @deprecated Deprecated
     */
    enabled?: boolean;
    /**
     * Additional variables to use when templating the job with HCL2
     */
    vars?: {[key: string]: string};
}

export interface JobTaskGroup {
    count: number;
    meta: {[key: string]: string};
    name: string;
    tasks: outputs.JobTaskGroupTask[];
    volumes: outputs.JobTaskGroupVolume[];
}

export interface JobTaskGroupTask {
    driver: string;
    meta: {[key: string]: string};
    name: string;
    volumeMounts: outputs.JobTaskGroupTaskVolumeMount[];
}

export interface JobTaskGroupTaskVolumeMount {
    destination: string;
    readOnly: boolean;
    volume: string;
}

export interface JobTaskGroupVolume {
    name: string;
    readOnly: boolean;
    source: string;
    type: string;
}

export interface JobTimeouts {
    create?: string;
    update?: string;
}

export interface NamespaceCapabilities {
    /**
     * Disabled task drivers for the namespace.
     */
    disabledTaskDrivers?: string[];
    /**
     * Enabled task drivers for the namespace.
     */
    enabledTaskDrivers?: string[];
}

export interface NamespaceNodePoolConfig {
    /**
     * The list of node pools allowed to be used in this namespace. Cannot be used with denied.
     */
    alloweds?: string[];
    /**
     * The node pool to use when none are specified in the job.
     */
    default: string;
    /**
     * The list of node pools not allowed to be used in this namespace. Cannot be used with allowed.
     */
    denieds?: string[];
}

export interface NodePoolSchedulerConfig {
    /**
     * If true, the node pool will have memory oversubscription enabled.
     */
    memoryOversubscription?: string;
    /**
     * The scheduler algorithm to use in the node pool.
     */
    schedulerAlgorithm?: string;
}

export interface QuotaSpecificationLimit {
    /**
     * Region in which this limit has affect.
     */
    region: string;
    /**
     * The limit applied to this region.
     */
    regionLimit: outputs.QuotaSpecificationLimitRegionLimit;
}

export interface QuotaSpecificationLimitRegionLimit {
    cpu?: number;
    memoryMb?: number;
}

export interface VolumeCapability {
    /**
     * Defines whether a volume should be available concurrently.
     */
    accessMode: string;
    /**
     * The storage API that will be used by the volume.
     */
    attachmentMode: string;
}

export interface VolumeMountOptions {
    /**
     * The file system type.
     */
    fsType?: string;
    /**
     * The flags passed to mount.
     */
    mountFlags?: string[];
}

export interface VolumeTopology {
    segments: {[key: string]: string};
}

export interface VolumeTopologyRequest {
    /**
     * Required topologies indicate that the volume must be created in a location accessible from all the listed topologies.
     */
    required?: outputs.VolumeTopologyRequestRequired;
}

export interface VolumeTopologyRequestRequired {
    /**
     * Defines the location for the volume.
     */
    topologies: outputs.VolumeTopologyRequestRequiredTopology[];
}

export interface VolumeTopologyRequestRequiredTopology {
    /**
     * Define attributes for the topology request.
     */
    segments: {[key: string]: string};
}

export namespace config {
    export interface Headers {
        /**
         * The header name
         */
        name: string;
        /**
         * The header value
         */
        value: string;
    }

}
