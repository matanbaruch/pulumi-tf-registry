// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccountAttachmentTimeouts {
    default?: string;
}

export interface AccountService {
    /**
     * Unique human-readable name of the Service.
     */
    name: string;
    /**
     * The Service's suspended state.
     */
    suspended?: boolean;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    token: string;
}

export interface AccountTimeouts {
    default?: string;
}

export interface AccountUser {
    /**
     * The User's email address. Must be unique.
     */
    email: string;
    /**
     * External ID is an alternative unique ID this user is represented by within an external service.
     */
    externalId?: string;
    /**
     * The User's first name.
     */
    firstName: string;
    /**
     * The User's last name.
     */
    lastName: string;
    /**
     * Managed By is a read only field for what service manages this user, e.g. StrongDM, Okta, Azure.
     */
    managedBy: string;
    /**
     * PermissionLevel is the user's permission level e.g. admin, DBA, user.
     */
    permissionLevel: string;
    /**
     * Suspended is a read only field for the User's suspended state.
     */
    suspended: boolean;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ApprovalWorkflowApproverTimeouts {
    default?: string;
}

export interface ApprovalWorkflowStepTimeouts {
    default?: string;
}

export interface ApprovalWorkflowTimeouts {
    default?: string;
}

export interface GetAccountAccount {
    services: outputs.GetAccountAccountService[];
    tokens: outputs.GetAccountAccountToken[];
    users: outputs.GetAccountAccountUser[];
}

export interface GetAccountAccountService {
    id: string;
    name: string;
    suspended: boolean;
    tags: {[key: string]: string};
}

export interface GetAccountAccountToken {
    accountType: string;
    deadline: string;
    duration: string;
    id: string;
    name: string;
    permissions: string[];
    rekeyed: string;
    suspended: boolean;
    tags: {[key: string]: string};
}

export interface GetAccountAccountUser {
    email: string;
    externalId: string;
    firstName: string;
    id: string;
    lastName: string;
    managedBy: string;
    permissionLevel: string;
    suspended: boolean;
    tags: {[key: string]: string};
}

export interface GetAccountAttachmentAccountAttachment {
    accountId: string;
    id: string;
    roleId: string;
}

export interface GetAccountAttachmentTimeouts {
    default?: string;
}

export interface GetAccountTimeouts {
    default?: string;
}

export interface GetApprovalWorkflowApprovalWorkflow {
    approvalMode: string;
    description: string;
    id: string;
    name: string;
}

export interface GetApprovalWorkflowApproverApprovalWorkflowApprover {
    accountId: string;
    approvalFlowId: string;
    approvalStepId: string;
    id: string;
    roleId: string;
}

export interface GetApprovalWorkflowApproverTimeouts {
    default?: string;
}

export interface GetApprovalWorkflowStepApprovalWorkflowStep {
    approvalFlowId: string;
    id: string;
}

export interface GetApprovalWorkflowStepTimeouts {
    default?: string;
}

export interface GetApprovalWorkflowTimeouts {
    default?: string;
}

export interface GetIdentityAliasIdentityAlias {
    accountId: string;
    id: string;
    identitySetId: string;
    username: string;
}

export interface GetIdentityAliasTimeouts {
    default?: string;
}

export interface GetIdentitySetIdentitySet {
    id: string;
    name: string;
}

export interface GetIdentitySetTimeouts {
    default?: string;
}

export interface GetNodeNode {
    gateways: outputs.GetNodeNodeGateway[];
    relays: outputs.GetNodeNodeRelay[];
}

export interface GetNodeNodeGateway {
    bindAddress: string;
    device: string;
    gatewayFilter: string;
    id: string;
    listenAddress: string;
    location: string;
    maintenanceWindows: outputs.GetNodeNodeGatewayMaintenanceWindow[];
    name: string;
    tags: {[key: string]: string};
    version: string;
}

export interface GetNodeNodeGatewayMaintenanceWindow {
    cronSchedule: string;
    requireIdleness: boolean;
}

export interface GetNodeNodeRelay {
    device: string;
    gatewayFilter: string;
    id: string;
    location: string;
    maintenanceWindows: outputs.GetNodeNodeRelayMaintenanceWindow[];
    name: string;
    tags: {[key: string]: string};
    version: string;
}

export interface GetNodeNodeRelayMaintenanceWindow {
    cronSchedule: string;
    requireIdleness: boolean;
}

export interface GetNodeTimeouts {
    default?: string;
}

export interface GetPeeringGroupNodePeeringGroupNode {
    groupId: string;
    id: string;
    nodeId: string;
}

export interface GetPeeringGroupNodeTimeouts {
    default?: string;
}

export interface GetPeeringGroupPeerPeeringGroupPeer {
    groupId: string;
    id: string;
    peersWithGroupId: string;
}

export interface GetPeeringGroupPeerTimeouts {
    default?: string;
}

export interface GetPeeringGroupPeeringGroup {
    id: string;
    name: string;
}

export interface GetPeeringGroupResourcePeeringGroupResource {
    groupId: string;
    id: string;
    resourceId: string;
}

export interface GetPeeringGroupResourceTimeouts {
    default?: string;
}

export interface GetPeeringGroupTimeouts {
    default?: string;
}

export interface GetPolicyPolicy {
    description: string;
    id: string;
    name: string;
    policy: string;
}

export interface GetPolicyTimeouts {
    default?: string;
}

export interface GetRemoteIdentityGroupRemoteIdentityGroup {
    id: string;
    name: string;
}

export interface GetRemoteIdentityGroupTimeouts {
    default?: string;
}

export interface GetRemoteIdentityRemoteIdentity {
    accountId: string;
    id: string;
    remoteIdentityGroupId: string;
    username: string;
}

export interface GetRemoteIdentityTimeouts {
    default?: string;
}

export interface GetResourceResource {
    aks: outputs.GetResourceResourceAk[];
    aksBasicAuths: outputs.GetResourceResourceAksBasicAuth[];
    aksServiceAccountUserImpersonations: outputs.GetResourceResourceAksServiceAccountUserImpersonation[];
    aksServiceAccounts: outputs.GetResourceResourceAksServiceAccount[];
    aksUserImpersonations: outputs.GetResourceResourceAksUserImpersonation[];
    amazonEks: outputs.GetResourceResourceAmazonEk[];
    amazonEksInstanceProfileUserImpersonations: outputs.GetResourceResourceAmazonEksInstanceProfileUserImpersonation[];
    amazonEksInstanceProfiles: outputs.GetResourceResourceAmazonEksInstanceProfile[];
    amazonEksUserImpersonations: outputs.GetResourceResourceAmazonEksUserImpersonation[];
    amazonEs: outputs.GetResourceResourceAmazonE[];
    amazonmqAmqp091s: outputs.GetResourceResourceAmazonmqAmqp091[];
    athenas: outputs.GetResourceResourceAthena[];
    auroraMysqls: outputs.GetResourceResourceAuroraMysql[];
    auroraPostgres: outputs.GetResourceResourceAuroraPostgre[];
    auroraPostgresIams: outputs.GetResourceResourceAuroraPostgresIam[];
    aws: outputs.GetResourceResourceAw[];
    awsConsoleStaticKeyPairs: outputs.GetResourceResourceAwsConsoleStaticKeyPair[];
    awsConsoles: outputs.GetResourceResourceAwsConsole[];
    azureCertificates: outputs.GetResourceResourceAzureCertificate[];
    azureMysqls: outputs.GetResourceResourceAzureMysql[];
    azurePostgres: outputs.GetResourceResourceAzurePostgre[];
    azurePostgresManagedIdentities: outputs.GetResourceResourceAzurePostgresManagedIdentity[];
    azures: outputs.GetResourceResourceAzure[];
    bigQueries: outputs.GetResourceResourceBigQuery[];
    cassandras: outputs.GetResourceResourceCassandra[];
    cituses: outputs.GetResourceResourceCitus[];
    clustrixes: outputs.GetResourceResourceClustrix[];
    cockroaches: outputs.GetResourceResourceCockroach[];
    db2Is: outputs.GetResourceResourceDb2I[];
    db2Luws: outputs.GetResourceResourceDb2Luw[];
    documentDbHosts: outputs.GetResourceResourceDocumentDbHost[];
    documentDbReplicaSets: outputs.GetResourceResourceDocumentDbReplicaSet[];
    druids: outputs.GetResourceResourceDruid[];
    dynamoDbs: outputs.GetResourceResourceDynamoDb[];
    elasticacheRedis: outputs.GetResourceResourceElasticacheRedi[];
    elastics: outputs.GetResourceResourceElastic[];
    gcps: outputs.GetResourceResourceGcp[];
    googleGkeUserImpersonations: outputs.GetResourceResourceGoogleGkeUserImpersonation[];
    googleGkes: outputs.GetResourceResourceGoogleGke[];
    greenplums: outputs.GetResourceResourceGreenplum[];
    httpAuths: outputs.GetResourceResourceHttpAuth[];
    httpBasicAuths: outputs.GetResourceResourceHttpBasicAuth[];
    httpNoAuths: outputs.GetResourceResourceHttpNoAuth[];
    kubernetes: outputs.GetResourceResourceKubernete[];
    kubernetesBasicAuths: outputs.GetResourceResourceKubernetesBasicAuth[];
    kubernetesServiceAccountUserImpersonations: outputs.GetResourceResourceKubernetesServiceAccountUserImpersonation[];
    kubernetesServiceAccounts: outputs.GetResourceResourceKubernetesServiceAccount[];
    kubernetesUserImpersonations: outputs.GetResourceResourceKubernetesUserImpersonation[];
    marias: outputs.GetResourceResourceMaria[];
    memcacheds: outputs.GetResourceResourceMemcached[];
    memsqls: outputs.GetResourceResourceMemsql[];
    mongoHosts: outputs.GetResourceResourceMongoHost[];
    mongoLegacyHosts: outputs.GetResourceResourceMongoLegacyHost[];
    mongoLegacyReplicasets: outputs.GetResourceResourceMongoLegacyReplicaset[];
    mongoReplicaSets: outputs.GetResourceResourceMongoReplicaSet[];
    mongoShardedClusters: outputs.GetResourceResourceMongoShardedCluster[];
    mtlsMysqls: outputs.GetResourceResourceMtlsMysql[];
    mtlsPostgres: outputs.GetResourceResourceMtlsPostgre[];
    mysqls: outputs.GetResourceResourceMysql[];
    neptuneIams: outputs.GetResourceResourceNeptuneIam[];
    neptunes: outputs.GetResourceResourceNeptune[];
    oracles: outputs.GetResourceResourceOracle[];
    postgres: outputs.GetResourceResourcePostgre[];
    prestos: outputs.GetResourceResourcePresto[];
    rabbitmqAmqp091s: outputs.GetResourceResourceRabbitmqAmqp091[];
    rawTcps: outputs.GetResourceResourceRawTcp[];
    rdpCerts: outputs.GetResourceResourceRdpCert[];
    rdps: outputs.GetResourceResourceRdp[];
    rdsPostgresIams: outputs.GetResourceResourceRdsPostgresIam[];
    redis: outputs.GetResourceResourceRedi[];
    redshifts: outputs.GetResourceResourceRedshift[];
    singleStores: outputs.GetResourceResourceSingleStore[];
    snowflakes: outputs.GetResourceResourceSnowflake[];
    snowsights: outputs.GetResourceResourceSnowsight[];
    sqlServerAzureAds: outputs.GetResourceResourceSqlServerAzureAd[];
    sqlServerKerberosAds: outputs.GetResourceResourceSqlServerKerberosAd[];
    sqlServers: outputs.GetResourceResourceSqlServer[];
    sshCerts: outputs.GetResourceResourceSshCert[];
    sshCustomerKeys: outputs.GetResourceResourceSshCustomerKey[];
    sshPasswords: outputs.GetResourceResourceSshPassword[];
    sshes: outputs.GetResourceResourceSsh[];
    sybaseIqs: outputs.GetResourceResourceSybaseIq[];
    sybases: outputs.GetResourceResourceSybase[];
    teradatas: outputs.GetResourceResourceTeradata[];
    trinos: outputs.GetResourceResourceTrino[];
}

export interface GetResourceResourceAk {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAksBasicAuth {
    bindInterface: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceAksServiceAccount {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    token: string;
}

export interface GetResourceResourceAksServiceAccountUserImpersonation {
    bindInterface: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    token: string;
}

export interface GetResourceResourceAksUserImpersonation {
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonE {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    endpoint: string;
    id: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonEk {
    accessKey: string;
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    certificateAuthority: string;
    clusterName: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonEksInstanceProfile {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    certificateAuthority: string;
    clusterName: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonEksInstanceProfileUserImpersonation {
    bindInterface: string;
    certificateAuthority: string;
    clusterName: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonEksUserImpersonation {
    accessKey: string;
    bindInterface: string;
    certificateAuthority: string;
    clusterName: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAmazonmqAmqp091 {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceAthena {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    id: string;
    name: string;
    output: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAuroraMysql {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceAuroraPostgre {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceAuroraPostgresIam {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    port: number;
    portOverride: number;
    region: string;
    roleAssumptionArn: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceAw {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    healthcheckRegion: string;
    id: string;
    name: string;
    portOverride: number;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAwsConsole {
    bindInterface: string;
    egressFilter: string;
    enableEnvVariables: boolean;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretStoreId: string;
    sessionExpiry: number;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAwsConsoleStaticKeyPair {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    sessionExpiry: number;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceAzure {
    appId: string;
    bindInterface: string;
    egressFilter: string;
    id: string;
    name: string;
    password: string;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tenantId: string;
}

export interface GetResourceResourceAzureCertificate {
    appId: string;
    bindInterface: string;
    clientCertificate: string;
    egressFilter: string;
    id: string;
    name: string;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tenantId: string;
}

export interface GetResourceResourceAzureMysql {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceAzurePostgre {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceAzurePostgresManagedIdentity {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceBigQuery {
    bindInterface: string;
    egressFilter: string;
    endpoint: string;
    id: string;
    name: string;
    portOverride: number;
    privateKey: string;
    project: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceCassandra {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceCitus {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceClustrix {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceCockroach {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceDb2I {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceDb2Luw {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceDocumentDbHost {
    authDatabase: string;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceDocumentDbReplicaSet {
    authDatabase: string;
    bindInterface: string;
    connectToReplica: boolean;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    portOverride: number;
    replicaSet: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceDruid {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceDynamoDb {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    endpoint: string;
    id: string;
    name: string;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceElastic {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceElasticacheRedi {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceGcp {
    bindInterface: string;
    egressFilter: string;
    id: string;
    keyfile: string;
    name: string;
    portOverride: number;
    scopes: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceGoogleGke {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    certificateAuthority: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    portOverride: number;
    secretStoreId: string;
    serviceAccountKey: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceGoogleGkeUserImpersonation {
    bindInterface: string;
    certificateAuthority: string;
    egressFilter: string;
    endpoint: string;
    healthcheckNamespace: string;
    id: string;
    name: string;
    portOverride: number;
    secretStoreId: string;
    serviceAccountKey: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceGreenplum {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceHttpAuth {
    authHeader: string;
    bindInterface: string;
    defaultPath: string;
    egressFilter: string;
    headersBlacklist: string;
    healthcheckPath: string;
    hostOverride: string;
    id: string;
    name: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    url: string;
}

export interface GetResourceResourceHttpBasicAuth {
    bindInterface: string;
    defaultPath: string;
    egressFilter: string;
    headersBlacklist: string;
    healthcheckPath: string;
    hostOverride: string;
    id: string;
    name: string;
    password: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    url: string;
    username: string;
}

export interface GetResourceResourceHttpNoAuth {
    bindInterface: string;
    defaultPath: string;
    egressFilter: string;
    headersBlacklist: string;
    healthcheckPath: string;
    hostOverride: string;
    id: string;
    name: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    url: string;
}

export interface GetResourceResourceKubernete {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceKubernetesBasicAuth {
    bindInterface: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceKubernetesServiceAccount {
    allowResourceRoleBypass: boolean;
    bindInterface: string;
    discoveryEnabled: boolean;
    discoveryUsername: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    token: string;
}

export interface GetResourceResourceKubernetesServiceAccountUserImpersonation {
    bindInterface: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    token: string;
}

export interface GetResourceResourceKubernetesUserImpersonation {
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    egressFilter: string;
    healthcheckNamespace: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceMaria {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceMemcached {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceMemsql {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceMongoHost {
    authDatabase: string;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceMongoLegacyHost {
    authDatabase: string;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceMongoLegacyReplicaset {
    authDatabase: string;
    bindInterface: string;
    connectToReplica: boolean;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    replicaSet: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceMongoReplicaSet {
    authDatabase: string;
    bindInterface: string;
    connectToReplica: boolean;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    replicaSet: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceMongoShardedCluster {
    authDatabase: string;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceMtlsMysql {
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    serverName: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceMtlsPostgre {
    bindInterface: string;
    certificateAuthority: string;
    clientCertificate: string;
    clientKey: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    serverName: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceMysql {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceNeptune {
    bindInterface: string;
    egressFilter: string;
    endpoint: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceNeptuneIam {
    accessKey: string;
    bindInterface: string;
    egressFilter: string;
    endpoint: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    region: string;
    roleArn: string;
    roleExternalId: string;
    secretAccessKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceOracle {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourcePostgre {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourcePresto {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceRabbitmqAmqp091 {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceRawTcp {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceRdp {
    bindInterface: string;
    downgradeNlaConnections: boolean;
    egressFilter: string;
    hostname: string;
    id: string;
    lockRequired: boolean;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceRdpCert {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    name: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceRdsPostgresIam {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    port: number;
    portOverride: number;
    region: string;
    roleAssumptionArn: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceRedi {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tlsRequired: boolean;
    username: string;
}

export interface GetResourceResourceRedshift {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSingleStore {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    requireNativeAuth: boolean;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    useAzureSingleServerUsernames: boolean;
    username: string;
}

export interface GetResourceResourceSnowflake {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    portOverride: number;
    schema: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSnowsight {
    bindInterface: string;
    egressFilter: string;
    healthcheckUsername: string;
    id: string;
    name: string;
    portOverride: number;
    samlMetadata: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
}

export interface GetResourceResourceSqlServer {
    allowDeprecatedEncryption: boolean;
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    password: string;
    port: number;
    portOverride: number;
    schema: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSqlServerAzureAd {
    allowDeprecatedEncryption: boolean;
    bindInterface: string;
    clientId: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    overrideDatabase: boolean;
    port: number;
    portOverride: number;
    schema: string;
    secret: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    tenantId: string;
}

export interface GetResourceResourceSqlServerKerberosAd {
    allowDeprecatedEncryption: boolean;
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    keytab: string;
    krbConfig: string;
    name: string;
    overrideDatabase: boolean;
    port: number;
    portOverride: number;
    realm: string;
    schema: string;
    secretStoreId: string;
    serverSpn: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSsh {
    allowDeprecatedKeyExchanges: boolean;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    keyType: string;
    name: string;
    port: number;
    portForwarding: boolean;
    portOverride: number;
    publicKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSshCert {
    allowDeprecatedKeyExchanges: boolean;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    identityAliasHealthcheckUsername: string;
    identitySetId: string;
    keyType: string;
    name: string;
    port: number;
    portForwarding: boolean;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSshCustomerKey {
    allowDeprecatedKeyExchanges: boolean;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    port: number;
    portForwarding: boolean;
    portOverride: number;
    privateKey: string;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSshPassword {
    allowDeprecatedKeyExchanges: boolean;
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portForwarding: boolean;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSybase {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceSybaseIq {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceTeradata {
    bindInterface: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceResourceTrino {
    bindInterface: string;
    database: string;
    egressFilter: string;
    hostname: string;
    id: string;
    name: string;
    password: string;
    port: number;
    portOverride: number;
    secretStoreId: string;
    subdomain: string;
    tags: {[key: string]: string};
    username: string;
}

export interface GetResourceTimeouts {
    default?: string;
}

export interface GetRoleRole {
    accessRules: string;
    id: string;
    managedBy: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetRoleTimeouts {
    default?: string;
}

export interface GetSecretStoreSecretStore {
    activeDirectoryStores: outputs.GetSecretStoreSecretStoreActiveDirectoryStore[];
    aws: outputs.GetSecretStoreSecretStoreAw[];
    awsCertX509s: outputs.GetSecretStoreSecretStoreAwsCertX509[];
    azureStores: outputs.GetSecretStoreSecretStoreAzureStore[];
    cyberarkConjurs: outputs.GetSecretStoreSecretStoreCyberarkConjur[];
    cyberarkPamExperimentals: outputs.GetSecretStoreSecretStoreCyberarkPamExperimental[];
    cyberarkPams: outputs.GetSecretStoreSecretStoreCyberarkPam[];
    delineaStores: outputs.GetSecretStoreSecretStoreDelineaStore[];
    gcpCertX509Stores: outputs.GetSecretStoreSecretStoreGcpCertX509Store[];
    gcpStores: outputs.GetSecretStoreSecretStoreGcpStore[];
    keyfactorSshStores: outputs.GetSecretStoreSecretStoreKeyfactorSshStore[];
    keyfactorX509Stores: outputs.GetSecretStoreSecretStoreKeyfactorX509Store[];
    vaultApproleCertSshes: outputs.GetSecretStoreSecretStoreVaultApproleCertSsh[];
    vaultApproleCertX509s: outputs.GetSecretStoreSecretStoreVaultApproleCertX509[];
    vaultApproles: outputs.GetSecretStoreSecretStoreVaultApprole[];
    vaultAwsEc2s: outputs.GetSecretStoreSecretStoreVaultAwsEc2[];
    vaultAwsIams: outputs.GetSecretStoreSecretStoreVaultAwsIam[];
    vaultTls: outputs.GetSecretStoreSecretStoreVaultTl[];
    vaultTlsCertSshes: outputs.GetSecretStoreSecretStoreVaultTlsCertSsh[];
    vaultTlsCertX509s: outputs.GetSecretStoreSecretStoreVaultTlsCertX509[];
    vaultTokenCertSshes: outputs.GetSecretStoreSecretStoreVaultTokenCertSsh[];
    vaultTokenCertX509s: outputs.GetSecretStoreSecretStoreVaultTokenCertX509[];
    vaultTokens: outputs.GetSecretStoreSecretStoreVaultToken[];
}

export interface GetSecretStoreSecretStoreActiveDirectoryStore {
    id: string;
    name: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreAw {
    id: string;
    name: string;
    region: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreAwsCertX509 {
    caArn: string;
    certificateTemplateArn: string;
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    region: string;
    signingAlgo: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreAzureStore {
    id: string;
    name: string;
    tags: {[key: string]: string};
    vaultUri: string;
}

export interface GetSecretStoreSecretStoreCyberarkConjur {
    appUrl: string;
    id: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreCyberarkPam {
    appUrl: string;
    id: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreCyberarkPamExperimental {
    appUrl: string;
    id: string;
    name: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreDelineaStore {
    id: string;
    name: string;
    serverUrl: string;
    tags: {[key: string]: string};
    tenantName: string;
}

export interface GetSecretStoreSecretStoreGcpCertX509Store {
    caId: string;
    caPoolId: string;
    id: string;
    issuedCertTtlMinutes: number;
    location: string;
    name: string;
    projectId: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreGcpStore {
    id: string;
    name: string;
    projectId: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreKeyfactorSshStore {
    caFilePath: string;
    certificateFilePath: string;
    defaultCertificateAuthorityName: string;
    defaultCertificateProfileName: string;
    defaultEndEntityProfileName: string;
    enrollmentCodeEnvVar: string;
    enrollmentUsernameEnvVar: string;
    id: string;
    keyFilePath: string;
    name: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreKeyfactorX509Store {
    caFilePath: string;
    certificateFilePath: string;
    defaultCertificateAuthorityName: string;
    defaultCertificateProfileName: string;
    defaultEndEntityProfileName: string;
    enrollmentCodeEnvVar: string;
    enrollmentUsernameEnvVar: string;
    id: string;
    keyFilePath: string;
    name: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultApprole {
    id: string;
    name: string;
    namespace: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultApproleCertSsh {
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    serverAddress: string;
    signingRole: string;
    sshMountPoint: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultApproleCertX509 {
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    pkiMountPoint: string;
    serverAddress: string;
    signingRole: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultAwsEc2 {
    id: string;
    name: string;
    namespace: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultAwsIam {
    id: string;
    name: string;
    namespace: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultTl {
    caCertPath: string;
    clientCertPath: string;
    clientKeyPath: string;
    id: string;
    name: string;
    namespace: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultTlsCertSsh {
    caCertPath: string;
    clientCertPath: string;
    clientKeyPath: string;
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    serverAddress: string;
    signingRole: string;
    sshMountPoint: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultTlsCertX509 {
    caCertPath: string;
    clientCertPath: string;
    clientKeyPath: string;
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    pkiMountPoint: string;
    serverAddress: string;
    signingRole: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultToken {
    id: string;
    name: string;
    namespace: string;
    serverAddress: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultTokenCertSsh {
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    serverAddress: string;
    signingRole: string;
    sshMountPoint: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreSecretStoreVaultTokenCertX509 {
    id: string;
    issuedCertTtlMinutes: number;
    name: string;
    namespace: string;
    pkiMountPoint: string;
    serverAddress: string;
    signingRole: string;
    tags: {[key: string]: string};
}

export interface GetSecretStoreTimeouts {
    default?: string;
}

export interface GetSshCaPubkeyTimeouts {
    default?: string;
}

export interface GetWorkflowApproverTimeouts {
    default?: string;
}

export interface GetWorkflowApproverWorkflowApprover {
    accountId: string;
    id: string;
    roleId: string;
    workflowId: string;
}

export interface GetWorkflowRoleTimeouts {
    default?: string;
}

export interface GetWorkflowRoleWorkflowRole {
    id: string;
    roleId: string;
    workflowId: string;
}

export interface GetWorkflowTimeouts {
    default?: string;
}

export interface GetWorkflowWorkflow {
    accessRules: string;
    approvalFlowId: string;
    autoGrant: boolean;
    description: string;
    enabled: boolean;
    id: string;
    name: string;
    weight: number;
}

export interface IdentityAliasTimeouts {
    default?: string;
}

export interface IdentitySetTimeouts {
    default?: string;
}

export interface NodeGateway {
    /**
     * The hostname/port tuple which the gateway daemon will bind to. If not provided on create, set to "0.0.0.0:listen_address_port".
     */
    bindAddress: string;
    /**
     * Device is a read only device name uploaded by the gateway process when it comes online.
     */
    device: string;
    /**
     * GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
     */
    gatewayFilter?: string;
    /**
     * The public hostname/port tuple at which the gateway will be accessible to clients.
     */
    listenAddress: string;
    /**
     * Location is a read only network location uploaded by the gateway process when it comes online.
     */
    location: string;
    /**
     * Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
     */
    maintenanceWindows?: outputs.NodeGatewayMaintenanceWindow[];
    /**
     * Unique human-readable name of the Gateway. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    token: string;
    /**
     * Version is a read only sdm binary version uploaded by the gateway process when it comes online.
     */
    version: string;
}

export interface NodeGatewayMaintenanceWindow {
    cronSchedule: string;
    requireIdleness: boolean;
}

export interface NodeRelay {
    /**
     * Device is a read only device name uploaded by the gateway process when it comes online.
     */
    device: string;
    /**
     * GatewayFilter can be used to restrict the peering between relays and gateways. Deprecated.
     */
    gatewayFilter?: string;
    /**
     * Location is a read only network location uploaded by the gateway process when it comes online.
     */
    location: string;
    /**
     * Maintenance Windows define when this node is allowed to restart. If a node is requested to restart, it will check each window to determine if any of them permit it to restart, and if any do, it will. This check is repeated per window until the restart is successfully completed.  If not set here, may be set on the command line or via an environment variable on the process itself; any server setting will take precedence over local settings. This setting is ineffective for nodes below version 38.44.0.  If this setting is not applied via this remote configuration or via local configuration, the default setting is used: always allow restarts if serving no connections, and allow a restart even if serving connections between 7-8 UTC, any day.
     */
    maintenanceWindows?: outputs.NodeRelayMaintenanceWindow[];
    /**
     * Unique human-readable name of the Relay. Node names must include only letters, numbers, and hyphens (no spaces, underscores, or other special characters). Generated if not provided on create.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    token: string;
    /**
     * Version is a read only sdm binary version uploaded by the gateway process when it comes online.
     */
    version: string;
}

export interface NodeRelayMaintenanceWindow {
    cronSchedule: string;
    requireIdleness: boolean;
}

export interface NodeTimeouts {
    default?: string;
}

export interface PeeringGroupNodeTimeouts {
    default?: string;
}

export interface PeeringGroupPeerTimeouts {
    default?: string;
}

export interface PeeringGroupResourceTimeouts {
    default?: string;
}

export interface PeeringGroupTimeouts {
    default?: string;
}

export interface PolicyTimeouts {
    default?: string;
}

export interface RemoteIdentityTimeouts {
    default?: string;
}

export interface ResourceAks {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAksBasicAuth {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAksServiceAccount {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The API token to authenticate with.
     */
    token?: string;
}

export interface ResourceAksServiceAccountUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The API token to authenticate with.
     */
    token?: string;
}

export interface ResourceAksUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonEks {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The name of the cluster to connect to.
     */
    clusterName: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonEksInstanceProfile {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The name of the cluster to connect to.
     */
    clusterName: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonEksInstanceProfileUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The name of the cluster to connect to.
     */
    clusterName: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonEksUserImpersonation {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The name of the cluster to connect to.
     */
    clusterName: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonEs {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial e.g. search-?.region.es.amazonaws.com"
     */
    endpoint?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAmazonmqAmqp091 {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAthena {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The AWS S3 output location.
     */
    output: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to e.g. us-east-1.
     */
    region?: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAuroraMysql {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAuroraPostgres {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAuroraPostgresIam {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to.
     */
    region: string;
    /**
     * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
     */
    roleAssumptionArn?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAws {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The AWS region healthcheck requests should attempt to connect to.
     */
    healthcheckRegion: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAwsConsole {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * If true, prefer environment variables to authenticate connection even if EC2 roles are configured.
     */
    enableEnvVariables?: boolean;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * The length of time in seconds AWS console sessions will live before needing to reauthenticate.
     */
    sessionExpiry?: number;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAwsConsoleStaticKeyPair {
    /**
     * The Access Key ID to authenticate with.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to authenticate with.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * The length of time in seconds AWS console sessions will live before needing to reauthenticate.
     */
    sessionExpiry?: number;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceAzure {
    /**
     * The application ID to authenticate with.
     */
    appId?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The tenant ID to authenticate to.
     */
    tenantId?: string;
}

export interface ResourceAzureCertificate {
    /**
     * The application ID to authenticate with.
     */
    appId?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The service Principal certificate file, both private and public key included.
     */
    clientCertificate?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The tenant ID to authenticate to.
     */
    tenantId?: string;
}

export interface ResourceAzureMysql {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceAzurePostgres {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with. For Azure Postgres, this also will include the hostname of the target server for Azure Single Server compatibility. For Flexible servers, use the normal Postgres type.
     */
    username?: string;
}

export interface ResourceAzurePostgresManagedIdentity {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceBigQuery {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The JSON Private key to authenticate with.
     */
    privateKey?: string;
    /**
     * The project to connect to.
     */
    project: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceCassandra {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceCitus {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceClustrix {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceCockroach {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDb2I {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDb2Luw {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDocumentDbHost {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDocumentDbReplicaSet {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Set to connect to a replica instead of the primary node.
     */
    connectToReplica?: boolean;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Hostname must contain the hostname/port pairs of all instances in the replica set separated by commas.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The name of the mongo replicaset.
     */
    replicaSet: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDruid {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceDynamoDb {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial e.g. dynamodb.region.amazonaws.com
     */
    endpoint: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The region to authenticate requests against e.g. us-east-1
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceElastic {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceElasticacheRedis {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceGcp {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The service account keyfile to authenticate with.
     */
    keyfile?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Space separated scopes that this login should assume into when authenticating.
     */
    scopes: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceGoogleGke {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * The service account key to authenticate with.
     */
    serviceAccountKey?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceGoogleGkeUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The endpoint to dial.
     */
    endpoint: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * The service account key to authenticate with.
     */
    serviceAccountKey?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceGreenplum {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceHttpAuth {
    /**
     * The content to set as the authorization header.
     */
    authHeader?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Automatically redirect to this path upon connecting.
     */
    defaultPath?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Header names (e.g. Authorization), to omit from logs.
     */
    headersBlacklist?: string;
    /**
     * This path will be used to check the health of your site.
     */
    healthcheckPath: string;
    /**
     * The host header will be overwritten with this field if provided.
     */
    hostOverride?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The base address of your website without the path.
     */
    url: string;
}

export interface ResourceHttpBasicAuth {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Automatically redirect to this path upon connecting.
     */
    defaultPath?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Header names (e.g. Authorization), to omit from logs.
     */
    headersBlacklist?: string;
    /**
     * This path will be used to check the health of your site.
     */
    healthcheckPath: string;
    /**
     * The host header will be overwritten with this field if provided.
     */
    hostOverride?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The base address of your website without the path.
     */
    url: string;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceHttpNoAuth {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Automatically redirect to this path upon connecting.
     */
    defaultPath?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * Header names (e.g. Authorization), to omit from logs.
     */
    headersBlacklist?: string;
    /**
     * This path will be used to check the health of your site.
     */
    healthcheckPath: string;
    /**
     * The host header will be overwritten with this field if provided.
     */
    hostOverride?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The base address of your website without the path.
     */
    url: string;
}

export interface ResourceKubernetes {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceKubernetesBasicAuth {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceKubernetesServiceAccount {
    /**
     * If true, allows users to fallback to the existing authentication mode (Leased Credential or Identity Set) when a resource role is not provided.
     */
    allowResourceRoleBypass?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * If true, configures discovery of a cluster to be run from a node.
     */
    discoveryEnabled?: boolean;
    /**
     * If a cluster is configured for user impersonation, this is the user to impersonate when running discovery.
     */
    discoveryUsername?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The API token to authenticate with.
     */
    token?: string;
}

export interface ResourceKubernetesServiceAccountUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The API token to authenticate with.
     */
    token?: string;
}

export interface ResourceKubernetesUserImpersonation {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The path used to check the health of your connection.  Defaults to `default`.  This field is required, and is only marked as optional for backwards compatibility.
     */
    healthcheckNamespace: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceMaria {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMemcached {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceMemsql {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMongoHost {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMongoLegacyHost {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMongoLegacyReplicaset {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Set to connect to a replica instead of the primary node.
     */
    connectToReplica?: boolean;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The name of the mongo replicaset.
     */
    replicaSet: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMongoReplicaSet {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * Set to connect to a replica instead of the primary node.
     */
    connectToReplica?: boolean;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The name of the mongo replicaset.
     */
    replicaSet: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMongoShardedCluster {
    /**
     * The authentication database to use.
     */
    authDatabase: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMtlsMysql {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Server name for TLS verification (unverified by StrongDM if empty)
     */
    serverName?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMtlsPostgres {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The CA to authenticate TLS connections with.
     */
    certificateAuthority?: string;
    /**
     * The certificate to authenticate TLS connections with.
     */
    clientCertificate?: string;
    /**
     * The key to authenticate TLS connections with.
     */
    clientKey?: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Server name for TLS verification (unverified by StrongDM if empty)
     */
    serverName?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceMysql {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceNeptune {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
     */
    endpoint: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceNeptuneIam {
    /**
     * The Access Key ID to use to authenticate.
     */
    accessKey?: string;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The neptune endpoint to connect to as in endpoint.region.neptune.amazonaws.com
     */
    endpoint: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to.
     */
    region: string;
    /**
     * The role to assume after logging in.
     */
    roleArn?: string;
    /**
     * The external ID to associate with assume role requests. Does nothing if a role ARN is not provided.
     */
    roleExternalId?: string;
    /**
     * The Secret Access Key to use to authenticate.
     */
    secretAccessKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceOracle {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourcePostgres {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourcePresto {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRabbitmqAmqp091 {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRawTcp {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceRdp {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * When set, network level authentication will not be used. May resolve unexpected authentication errors to older servers. When set, healthchecks cannot detect if a provided username / password pair is correct.
     */
    downgradeNlaConnections?: boolean;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * When set, require a resource lock to access the resource to ensure it can only be used by one user at a time.
     */
    lockRequired?: boolean;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRdpCert {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRdsPostgresIam {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The AWS region to connect to.
     */
    region: string;
    /**
     * If provided, the gateway/relay will try to assume this role instead of the underlying compute's role.
     */
    roleAssumptionArn?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRedis {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If set, TLS must be used to connect to this resource.
     */
    tlsRequired?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceRedshift {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSingleStore {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks. Does not affect client requests.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * Whether native auth (mysql_native_password) is used for all connections (for backwards compatibility)
     */
    requireNativeAuth?: boolean;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * If true, appends the hostname to the username when hitting a database.azure.com address
     */
    useAzureSingleServerUsernames?: boolean;
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSnowflake {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The schema to provide on authentication.
     */
    schema?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSnowsight {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The StrongDM user email to use for healthchecks.
     */
    healthcheckUsername: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The Metadata for your snowflake IDP integration
     */
    samlMetadata?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface ResourceSqlServer {
    /**
     * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
     */
    allowDeprecatedEncryption?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks, and used for clients if Override Default Database is true.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The Schema to use to direct initial requests.
     */
    schema?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSqlServerAzureAd {
    /**
     * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
     */
    allowDeprecatedEncryption?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The Azure AD application (client) ID with which to authenticate.
     */
    clientId?: string;
    /**
     * The database for healthchecks, and used for clients if Override Default Database is true.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The Schema to use to direct initial requests.
     */
    schema?: string;
    /**
     * The Azure AD client secret (application password) with which to authenticate.
     */
    secret?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The Azure AD directory (tenant) ID with which to authenticate.
     */
    tenantId?: string;
}

export interface ResourceSqlServerKerberosAd {
    /**
     * Whether to allow deprecated encryption protocols to be used for this resource. For example, TLS 1.0.
     */
    allowDeprecatedEncryption?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The database for healthchecks, and used for clients if Override Default Database is true.
     */
    database?: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The keytab file in base64 format containing an entry with the principal name (username@realm) and key version number with which to authenticate.
     */
    keytab?: string;
    /**
     * The Kerberos 5 configuration file (krb5.conf) specifying the Active Directory server (KDC) for the configured realm.
     */
    krbConfig?: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * If set, the database configured cannot be changed by users. This setting is not recommended for most use cases, as some clients will insist their database has changed when it has not, leading to user confusion.
     */
    overrideDatabase?: boolean;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The Active Directory domain (realm) to which the configured username belongs.
     */
    realm?: string;
    /**
     * The Schema to use to direct initial requests.
     */
    schema?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * The Service Principal Name of the Microsoft SQL Server instance in Active Directory.
     */
    serverSpn?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSsh {
    /**
     * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
     */
    allowDeprecatedKeyExchanges?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The key type to use e.g. rsa-2048 or ed25519
     */
    keyType: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * Whether port forwarding is allowed through this server.
     */
    portForwarding?: boolean;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The public key to append to a server's authorized keys. This will be generated after resource creation.
     */
    publicKey: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSshCert {
    /**
     * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
     */
    allowDeprecatedKeyExchanges?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * The username to use for healthchecks, when clients otherwise connect with their own identity alias username.
     */
    identityAliasHealthcheckUsername?: string;
    /**
     * The ID of the identity set to use for identity connections.
     */
    identitySetId?: string;
    /**
     * The key type to use e.g. rsa-2048 or ed25519
     */
    keyType: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * Whether port forwarding is allowed through this server.
     */
    portForwarding?: boolean;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSshCustomerKey {
    /**
     * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
     */
    allowDeprecatedKeyExchanges?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * Whether port forwarding is allowed through this server.
     */
    portForwarding?: boolean;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * The private key used to authenticate with the server.
     */
    privateKey?: string;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSshPassword {
    /**
     * Whether deprecated, insecure key exchanges are allowed for use to connect to the target ssh server.
     */
    allowDeprecatedKeyExchanges?: boolean;
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port: number;
    /**
     * Whether port forwarding is allowed through this server.
     */
    portForwarding?: boolean;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSybase {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceSybaseIq {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceTeradata {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface ResourceTimeouts {
    default?: string;
}

export interface ResourceTrino {
    /**
     * The bind interface is the IP address to which the port override of a resource is bound (for example, 127.0.0.1). It is automatically generated if not provided.
     */
    bindInterface: string;
    /**
     * The initial database to connect to. This setting does not by itself prevent switching to another database after connecting.
     */
    database: string;
    /**
     * A filter applied to the routing logic to pin datasource to nodes.
     */
    egressFilter?: string;
    /**
     * The host to dial to initiate a connection from the egress node to this resource.
     */
    hostname: string;
    /**
     * Unique human-readable name of the Resource.
     */
    name: string;
    /**
     * The password to authenticate with.
     */
    password?: string;
    /**
     * The port to dial to initiate a connection from the egress node to this resource.
     */
    port?: number;
    /**
     * The local port used by clients to connect to this resource.
     */
    portOverride: number;
    /**
     * ID of the secret store containing credentials for this resource, if any.
     */
    secretStoreId?: string;
    /**
     * Subdomain is the local DNS address.  (e.g. app-prod1 turns into app-prod1.your-org-name.sdm.network)
     */
    subdomain: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The username to authenticate with.
     */
    username?: string;
}

export interface RoleTimeouts {
    default?: string;
}

export interface SecretStoreActiveDirectoryStore {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * Hostname of server that is hosting NDES (Network Device Enrollment Services). Often this is the same host as Active Directory Certificate Services
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreAws {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The AWS region to target e.g. us-east-1
     */
    region: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreAwsCertX509 {
    /**
     * The ARN of the CA in AWS Private CA
     */
    caArn: string;
    /**
     * The ARN of the AWS certificate template for requested certificates. Must allow SAN, key usage, and ext key usage passthrough from CSR
     */
    certificateTemplateArn: string;
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The AWS region to target e.g. us-east-1
     */
    region: string;
    /**
     * The specified signing algorithm family (RSA or ECDSA) must match the algorithm family of the CA's secret key. e.g. SHA256WITHRSA
     */
    signingAlgo: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreAzureStore {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The URI of the key vault to target e.g. https://myvault.vault.azure.net
     */
    vaultUri: string;
}

export interface SecretStoreCyberarkConjur {
    /**
     * The URL of the Cyberark instance
     */
    appUrl: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreCyberarkPam {
    /**
     * The URL of the Cyberark instance
     */
    appUrl: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreCyberarkPamExperimental {
    /**
     * The URL of the Cyberark instance
     */
    appUrl: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreDelineaStore {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The URL of the Delinea instance
     */
    serverUrl?: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
    /**
     * The tenant name to target
     */
    tenantName?: string;
}

export interface SecretStoreGcpCertX509Store {
    /**
     * The ID of the target CA
     */
    caId?: string;
    /**
     * The ID of the target CA pool
     */
    caPoolId: string;
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * The Region for the CA in GCP format e.g. us-west1
     */
    location: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The GCP project ID to target.
     */
    projectId: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreGcpStore {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The GCP project ID to target.
     */
    projectId: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreKeyfactorSshStore {
    /**
     * Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
     */
    caFilePath?: string;
    /**
     * Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
     */
    certificateFilePath: string;
    /**
     * Name of EJBCA certificate authority that will enroll CSR.
     */
    defaultCertificateAuthorityName: string;
    /**
     * Certificate profile name that EJBCA will enroll the CSR with.
     */
    defaultCertificateProfileName: string;
    /**
     * End entity profile that EJBCA will enroll the CSR with.
     */
    defaultEndEntityProfileName: string;
    /**
     * code used by EJBCA during enrollment. May be left blank if no code is required.
     */
    enrollmentCodeEnvVar?: string;
    /**
     * username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
     */
    enrollmentUsernameEnvVar?: string;
    /**
     * Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
     */
    keyFilePath?: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * the host of the Key Factor CA
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreKeyfactorX509Store {
    /**
     * Path to the root CA that signed the certificate passed to the client for HTTPS connection. This is not required if the CA is trusted by the host operating system. This should be a PEM formatted certificate, and doesn't necessarily have to be the CA that signed CertificateFile.
     */
    caFilePath?: string;
    /**
     * Path to client certificate in PEM format. This certificate must contain a client certificate that is recognized by the EJBCA instance represented by Hostname. This PEM file may also contain the private key associated with the certificate, but KeyFile can also be set to configure the private key.
     */
    certificateFilePath: string;
    /**
     * Name of EJBCA certificate authority that will enroll CSR.
     */
    defaultCertificateAuthorityName: string;
    /**
     * Certificate profile name that EJBCA will enroll the CSR with.
     */
    defaultCertificateProfileName: string;
    /**
     * End entity profile that EJBCA will enroll the CSR with.
     */
    defaultEndEntityProfileName: string;
    /**
     * code used by EJBCA during enrollment. May be left blank if no code is required.
     */
    enrollmentCodeEnvVar?: string;
    /**
     * username that used by the EJBCA during enrollment. This can be left out.  If so, the username must be auto-generated on the Keyfactor side.
     */
    enrollmentUsernameEnvVar?: string;
    /**
     * Path to private key in PEM format. This file should contain the private key associated with the client certificate configured in CertificateFile.
     */
    keyFilePath?: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * the host of the Key Factor CA
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreTimeouts {
    default?: string;
}

export interface SecretStoreVaultApprole {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultApproleCertSsh {
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * The mount point of the SSH engine configured with the desired CA
     */
    sshMountPoint: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultApproleCertX509 {
    /**
     * The lifetime of certificates issued by this CA in minutes. Recommended value is 5.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The mount point of the PKI engine configured with the desired CA
     */
    pkiMountPoint: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultAwsEc2 {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultAwsIam {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultTls {
    /**
     * A path to a CA file accessible by a Node
     */
    caCertPath?: string;
    /**
     * A path to a client certificate file accessible by a Node
     */
    clientCertPath: string;
    /**
     * A path to a client key file accessible by a Node
     */
    clientKeyPath: string;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultTlsCertSsh {
    /**
     * A path to a CA file accessible by a Node
     */
    caCertPath?: string;
    /**
     * A path to a client certificate file accessible by a Node
     */
    clientCertPath: string;
    /**
     * A path to a client key file accessible by a Node
     */
    clientKeyPath: string;
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * The mount point of the SSH engine configured with the desired CA
     */
    sshMountPoint: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultTlsCertX509 {
    /**
     * A path to a CA file accessible by a Node
     */
    caCertPath?: string;
    /**
     * A path to a client certificate file accessible by a Node
     */
    clientCertPath: string;
    /**
     * A path to a client key file accessible by a Node
     */
    clientKeyPath: string;
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The mount point of the PKI engine configured with the desired CA
     */
    pkiMountPoint: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultToken {
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultTokenCertSsh {
    /**
     * The lifetime of certificates issued by this CA in minutes. Recommended value is 5.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * The mount point of the SSH engine configured with the desired CA
     */
    sshMountPoint: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface SecretStoreVaultTokenCertX509 {
    /**
     * The lifetime of certificates issued by this CA represented in minutes.
     */
    issuedCertTtlMinutes: number;
    /**
     * Unique human-readable name of the SecretStore.
     */
    name: string;
    /**
     * The namespace to make requests within
     */
    namespace?: string;
    /**
     * The mount point of the PKI engine configured with the desired CA
     */
    pkiMountPoint: string;
    /**
     * The URL of the Vault to target
     */
    serverAddress: string;
    /**
     * The signing role to be used for signing certificates
     */
    signingRole: string;
    /**
     * Tags is a map of key, value pairs.
     */
    tags?: {[key: string]: string};
}

export interface WorkflowApproverTimeouts {
    default?: string;
}

export interface WorkflowRoleTimeouts {
    default?: string;
}

export interface WorkflowTimeouts {
    default?: string;
}

