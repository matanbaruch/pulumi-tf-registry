// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Consumer extends pulumi.CustomResource {
    /**
     * Get an existing Consumer resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ConsumerState, opts?: pulumi.CustomResourceOptions): Consumer {
        return new Consumer(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'jetstream:index/consumer:Consumer';

    /**
     * Returns true if the given object is an instance of Consumer.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Consumer {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Consumer.__pulumiType;
    }

    /**
     * The delivery acknowledgement policy to apply to the Consumer
     */
    public readonly ackPolicy!: pulumi.Output<string | undefined>;
    /**
     * Number of seconds to wait for acknowledgement
     */
    public readonly ackWait!: pulumi.Output<number | undefined>;
    /**
     * List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
     */
    public readonly backoffs!: pulumi.Output<number[] | undefined>;
    /**
     * Starts at the first available message in the Stream
     */
    public readonly deliverAll!: pulumi.Output<boolean | undefined>;
    /**
     * Starts at the latest available message in the Stream
     */
    public readonly deliverLast!: pulumi.Output<boolean | undefined>;
    /**
     * Starts with the last message for each subject matched by filter
     */
    public readonly deliverLastPerSubject!: pulumi.Output<boolean | undefined>;
    /**
     * Starts with the next available message in the Stream
     */
    public readonly deliverNew!: pulumi.Output<boolean | undefined>;
    /**
     * When set Push consumers will only deliver messages to subscriptions with this group set
     */
    public readonly deliveryGroup!: pulumi.Output<string | undefined>;
    /**
     * The subject where a Push-based consumer will deliver messages
     */
    public readonly deliverySubject!: pulumi.Output<string | undefined>;
    /**
     * Contains additional information about this consumer
     */
    public readonly description!: pulumi.Output<string | undefined>;
    /**
     * The durable name of the Consumer
     */
    public readonly durableName!: pulumi.Output<string>;
    /**
     * Only receive a subset of messages from the Stream based on the subject they entered the Stream on
     */
    public readonly filterSubject!: pulumi.Output<string | undefined>;
    /**
     * Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to
     * filter_subject and works with nats-server v2.10 or better
     */
    public readonly filterSubjects!: pulumi.Output<string[] | undefined>;
    /**
     * Enable flow control for push consumers
     */
    public readonly flowControl!: pulumi.Output<boolean | undefined>;
    /**
     * When true no message bodies will be delivered only headers
     */
    public readonly headersOnly!: pulumi.Output<boolean | undefined>;
    /**
     * Enable heartbeat messages for push consumers, duration specified in seconds
     */
    public readonly heartbeat!: pulumi.Output<number | undefined>;
    /**
     * Removes the consumer after a idle period, specified as a duration in seconds
     */
    public readonly inactiveThreshold!: pulumi.Output<number | undefined>;
    /**
     * Maximum pending Acks before consumers are paused
     */
    public readonly maxAckPending!: pulumi.Output<number | undefined>;
    /**
     * Limits Pull Batch sizes to this maximum
     */
    public readonly maxBatch!: pulumi.Output<number | undefined>;
    /**
     * The maximum bytes value that maybe set when dong a pull on a Pull Consumer
     */
    public readonly maxBytes!: pulumi.Output<number | undefined>;
    /**
     * Maximum deliveries to attempt for each message
     */
    public readonly maxDelivery!: pulumi.Output<number | undefined>;
    /**
     * Limits the Pull Expires duration to this maximum in seconds
     */
    public readonly maxExpires!: pulumi.Output<number | undefined>;
    /**
     * The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
     */
    public readonly maxWaiting!: pulumi.Output<number | undefined>;
    /**
     * Force the consumer state to be kept in memory rather than inherit the setting from the stream
     */
    public readonly memory!: pulumi.Output<boolean | undefined>;
    /**
     * Free form metadata about the consumer
     */
    public readonly metadata!: pulumi.Output<{[key: string]: string} | undefined>;
    /**
     * The rate limit for delivering messages to push consumers, expressed in bits per second
     */
    public readonly ratelimit!: pulumi.Output<number | undefined>;
    /**
     * The rate at which messages will be replayed from the stream
     */
    public readonly replayPolicy!: pulumi.Output<string | undefined>;
    /**
     * How many replicas of the data to keep in a clustered environment
     */
    public readonly replicas!: pulumi.Output<number | undefined>;
    /**
     * The percentage of acknowledgements that will be sampled for observability purposes
     */
    public readonly sampleFreq!: pulumi.Output<number | undefined>;
    /**
     * The timestamp of the first message that will be delivered by this Consumer
     */
    public readonly startTime!: pulumi.Output<string | undefined>;
    /**
     * The name of the Stream that this consumer consumes
     */
    public readonly streamId!: pulumi.Output<string>;
    /**
     * The Stream Sequence that will be the first message delivered by this Consumer
     */
    public readonly streamSequence!: pulumi.Output<number | undefined>;

    /**
     * Create a Consumer resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ConsumerArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ConsumerArgs | ConsumerState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ConsumerState | undefined;
            resourceInputs["ackPolicy"] = state ? state.ackPolicy : undefined;
            resourceInputs["ackWait"] = state ? state.ackWait : undefined;
            resourceInputs["backoffs"] = state ? state.backoffs : undefined;
            resourceInputs["deliverAll"] = state ? state.deliverAll : undefined;
            resourceInputs["deliverLast"] = state ? state.deliverLast : undefined;
            resourceInputs["deliverLastPerSubject"] = state ? state.deliverLastPerSubject : undefined;
            resourceInputs["deliverNew"] = state ? state.deliverNew : undefined;
            resourceInputs["deliveryGroup"] = state ? state.deliveryGroup : undefined;
            resourceInputs["deliverySubject"] = state ? state.deliverySubject : undefined;
            resourceInputs["description"] = state ? state.description : undefined;
            resourceInputs["durableName"] = state ? state.durableName : undefined;
            resourceInputs["filterSubject"] = state ? state.filterSubject : undefined;
            resourceInputs["filterSubjects"] = state ? state.filterSubjects : undefined;
            resourceInputs["flowControl"] = state ? state.flowControl : undefined;
            resourceInputs["headersOnly"] = state ? state.headersOnly : undefined;
            resourceInputs["heartbeat"] = state ? state.heartbeat : undefined;
            resourceInputs["inactiveThreshold"] = state ? state.inactiveThreshold : undefined;
            resourceInputs["maxAckPending"] = state ? state.maxAckPending : undefined;
            resourceInputs["maxBatch"] = state ? state.maxBatch : undefined;
            resourceInputs["maxBytes"] = state ? state.maxBytes : undefined;
            resourceInputs["maxDelivery"] = state ? state.maxDelivery : undefined;
            resourceInputs["maxExpires"] = state ? state.maxExpires : undefined;
            resourceInputs["maxWaiting"] = state ? state.maxWaiting : undefined;
            resourceInputs["memory"] = state ? state.memory : undefined;
            resourceInputs["metadata"] = state ? state.metadata : undefined;
            resourceInputs["ratelimit"] = state ? state.ratelimit : undefined;
            resourceInputs["replayPolicy"] = state ? state.replayPolicy : undefined;
            resourceInputs["replicas"] = state ? state.replicas : undefined;
            resourceInputs["sampleFreq"] = state ? state.sampleFreq : undefined;
            resourceInputs["startTime"] = state ? state.startTime : undefined;
            resourceInputs["streamId"] = state ? state.streamId : undefined;
            resourceInputs["streamSequence"] = state ? state.streamSequence : undefined;
        } else {
            const args = argsOrState as ConsumerArgs | undefined;
            if ((!args || args.durableName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'durableName'");
            }
            if ((!args || args.streamId === undefined) && !opts.urn) {
                throw new Error("Missing required property 'streamId'");
            }
            resourceInputs["ackPolicy"] = args ? args.ackPolicy : undefined;
            resourceInputs["ackWait"] = args ? args.ackWait : undefined;
            resourceInputs["backoffs"] = args ? args.backoffs : undefined;
            resourceInputs["deliverAll"] = args ? args.deliverAll : undefined;
            resourceInputs["deliverLast"] = args ? args.deliverLast : undefined;
            resourceInputs["deliverLastPerSubject"] = args ? args.deliverLastPerSubject : undefined;
            resourceInputs["deliverNew"] = args ? args.deliverNew : undefined;
            resourceInputs["deliveryGroup"] = args ? args.deliveryGroup : undefined;
            resourceInputs["deliverySubject"] = args ? args.deliverySubject : undefined;
            resourceInputs["description"] = args ? args.description : undefined;
            resourceInputs["durableName"] = args ? args.durableName : undefined;
            resourceInputs["filterSubject"] = args ? args.filterSubject : undefined;
            resourceInputs["filterSubjects"] = args ? args.filterSubjects : undefined;
            resourceInputs["flowControl"] = args ? args.flowControl : undefined;
            resourceInputs["headersOnly"] = args ? args.headersOnly : undefined;
            resourceInputs["heartbeat"] = args ? args.heartbeat : undefined;
            resourceInputs["inactiveThreshold"] = args ? args.inactiveThreshold : undefined;
            resourceInputs["maxAckPending"] = args ? args.maxAckPending : undefined;
            resourceInputs["maxBatch"] = args ? args.maxBatch : undefined;
            resourceInputs["maxBytes"] = args ? args.maxBytes : undefined;
            resourceInputs["maxDelivery"] = args ? args.maxDelivery : undefined;
            resourceInputs["maxExpires"] = args ? args.maxExpires : undefined;
            resourceInputs["maxWaiting"] = args ? args.maxWaiting : undefined;
            resourceInputs["memory"] = args ? args.memory : undefined;
            resourceInputs["metadata"] = args ? args.metadata : undefined;
            resourceInputs["ratelimit"] = args ? args.ratelimit : undefined;
            resourceInputs["replayPolicy"] = args ? args.replayPolicy : undefined;
            resourceInputs["replicas"] = args ? args.replicas : undefined;
            resourceInputs["sampleFreq"] = args ? args.sampleFreq : undefined;
            resourceInputs["startTime"] = args ? args.startTime : undefined;
            resourceInputs["streamId"] = args ? args.streamId : undefined;
            resourceInputs["streamSequence"] = args ? args.streamSequence : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Consumer.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Consumer resources.
 */
export interface ConsumerState {
    /**
     * The delivery acknowledgement policy to apply to the Consumer
     */
    ackPolicy?: pulumi.Input<string>;
    /**
     * Number of seconds to wait for acknowledgement
     */
    ackWait?: pulumi.Input<number>;
    /**
     * List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
     */
    backoffs?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Starts at the first available message in the Stream
     */
    deliverAll?: pulumi.Input<boolean>;
    /**
     * Starts at the latest available message in the Stream
     */
    deliverLast?: pulumi.Input<boolean>;
    /**
     * Starts with the last message for each subject matched by filter
     */
    deliverLastPerSubject?: pulumi.Input<boolean>;
    /**
     * Starts with the next available message in the Stream
     */
    deliverNew?: pulumi.Input<boolean>;
    /**
     * When set Push consumers will only deliver messages to subscriptions with this group set
     */
    deliveryGroup?: pulumi.Input<string>;
    /**
     * The subject where a Push-based consumer will deliver messages
     */
    deliverySubject?: pulumi.Input<string>;
    /**
     * Contains additional information about this consumer
     */
    description?: pulumi.Input<string>;
    /**
     * The durable name of the Consumer
     */
    durableName?: pulumi.Input<string>;
    /**
     * Only receive a subset of messages from the Stream based on the subject they entered the Stream on
     */
    filterSubject?: pulumi.Input<string>;
    /**
     * Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to
     * filter_subject and works with nats-server v2.10 or better
     */
    filterSubjects?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enable flow control for push consumers
     */
    flowControl?: pulumi.Input<boolean>;
    /**
     * When true no message bodies will be delivered only headers
     */
    headersOnly?: pulumi.Input<boolean>;
    /**
     * Enable heartbeat messages for push consumers, duration specified in seconds
     */
    heartbeat?: pulumi.Input<number>;
    /**
     * Removes the consumer after a idle period, specified as a duration in seconds
     */
    inactiveThreshold?: pulumi.Input<number>;
    /**
     * Maximum pending Acks before consumers are paused
     */
    maxAckPending?: pulumi.Input<number>;
    /**
     * Limits Pull Batch sizes to this maximum
     */
    maxBatch?: pulumi.Input<number>;
    /**
     * The maximum bytes value that maybe set when dong a pull on a Pull Consumer
     */
    maxBytes?: pulumi.Input<number>;
    /**
     * Maximum deliveries to attempt for each message
     */
    maxDelivery?: pulumi.Input<number>;
    /**
     * Limits the Pull Expires duration to this maximum in seconds
     */
    maxExpires?: pulumi.Input<number>;
    /**
     * The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
     */
    maxWaiting?: pulumi.Input<number>;
    /**
     * Force the consumer state to be kept in memory rather than inherit the setting from the stream
     */
    memory?: pulumi.Input<boolean>;
    /**
     * Free form metadata about the consumer
     */
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The rate limit for delivering messages to push consumers, expressed in bits per second
     */
    ratelimit?: pulumi.Input<number>;
    /**
     * The rate at which messages will be replayed from the stream
     */
    replayPolicy?: pulumi.Input<string>;
    /**
     * How many replicas of the data to keep in a clustered environment
     */
    replicas?: pulumi.Input<number>;
    /**
     * The percentage of acknowledgements that will be sampled for observability purposes
     */
    sampleFreq?: pulumi.Input<number>;
    /**
     * The timestamp of the first message that will be delivered by this Consumer
     */
    startTime?: pulumi.Input<string>;
    /**
     * The name of the Stream that this consumer consumes
     */
    streamId?: pulumi.Input<string>;
    /**
     * The Stream Sequence that will be the first message delivered by this Consumer
     */
    streamSequence?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a Consumer resource.
 */
export interface ConsumerArgs {
    /**
     * The delivery acknowledgement policy to apply to the Consumer
     */
    ackPolicy?: pulumi.Input<string>;
    /**
     * Number of seconds to wait for acknowledgement
     */
    ackWait?: pulumi.Input<number>;
    /**
     * List of durations in Go format that represents a retry time scale for NaK'd messages. A list of durations in seconds.
     */
    backoffs?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Starts at the first available message in the Stream
     */
    deliverAll?: pulumi.Input<boolean>;
    /**
     * Starts at the latest available message in the Stream
     */
    deliverLast?: pulumi.Input<boolean>;
    /**
     * Starts with the last message for each subject matched by filter
     */
    deliverLastPerSubject?: pulumi.Input<boolean>;
    /**
     * Starts with the next available message in the Stream
     */
    deliverNew?: pulumi.Input<boolean>;
    /**
     * When set Push consumers will only deliver messages to subscriptions with this group set
     */
    deliveryGroup?: pulumi.Input<string>;
    /**
     * The subject where a Push-based consumer will deliver messages
     */
    deliverySubject?: pulumi.Input<string>;
    /**
     * Contains additional information about this consumer
     */
    description?: pulumi.Input<string>;
    /**
     * The durable name of the Consumer
     */
    durableName: pulumi.Input<string>;
    /**
     * Only receive a subset of messages from the Stream based on the subject they entered the Stream on
     */
    filterSubject?: pulumi.Input<string>;
    /**
     * Only receive a subset of messages from the stream baseed on the subjects they entered the Streeam on, exlusive to
     * filter_subject and works with nats-server v2.10 or better
     */
    filterSubjects?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Enable flow control for push consumers
     */
    flowControl?: pulumi.Input<boolean>;
    /**
     * When true no message bodies will be delivered only headers
     */
    headersOnly?: pulumi.Input<boolean>;
    /**
     * Enable heartbeat messages for push consumers, duration specified in seconds
     */
    heartbeat?: pulumi.Input<number>;
    /**
     * Removes the consumer after a idle period, specified as a duration in seconds
     */
    inactiveThreshold?: pulumi.Input<number>;
    /**
     * Maximum pending Acks before consumers are paused
     */
    maxAckPending?: pulumi.Input<number>;
    /**
     * Limits Pull Batch sizes to this maximum
     */
    maxBatch?: pulumi.Input<number>;
    /**
     * The maximum bytes value that maybe set when dong a pull on a Pull Consumer
     */
    maxBytes?: pulumi.Input<number>;
    /**
     * Maximum deliveries to attempt for each message
     */
    maxDelivery?: pulumi.Input<number>;
    /**
     * Limits the Pull Expires duration to this maximum in seconds
     */
    maxExpires?: pulumi.Input<number>;
    /**
     * The number of pulls that can be outstanding on a pull consumer, pulls received after this is reached are ignored
     */
    maxWaiting?: pulumi.Input<number>;
    /**
     * Force the consumer state to be kept in memory rather than inherit the setting from the stream
     */
    memory?: pulumi.Input<boolean>;
    /**
     * Free form metadata about the consumer
     */
    metadata?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The rate limit for delivering messages to push consumers, expressed in bits per second
     */
    ratelimit?: pulumi.Input<number>;
    /**
     * The rate at which messages will be replayed from the stream
     */
    replayPolicy?: pulumi.Input<string>;
    /**
     * How many replicas of the data to keep in a clustered environment
     */
    replicas?: pulumi.Input<number>;
    /**
     * The percentage of acknowledgements that will be sampled for observability purposes
     */
    sampleFreq?: pulumi.Input<number>;
    /**
     * The timestamp of the first message that will be delivered by this Consumer
     */
    startTime?: pulumi.Input<string>;
    /**
     * The name of the Stream that this consumer consumes
     */
    streamId: pulumi.Input<string>;
    /**
     * The Stream Sequence that will be the first message delivered by this Consumer
     */
    streamSequence?: pulumi.Input<number>;
}
