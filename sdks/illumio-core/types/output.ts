// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ContainerClusterError {
    auditEvent: {[key: string]: string};
    duplicateIds: string[];
    errorType: string;
}

export interface ContainerClusterNode {
    podSubnet: string;
}

export interface ContainerClusterWorkloadProfileAssignLabel {
    /**
     * URI of the assigned label
     */
    href: string;
}

export interface ContainerClusterWorkloadProfileLabel {
    /**
     * The label href to set. Single element list
     */
    assignment?: outputs.ContainerClusterWorkloadProfileLabelAssignment;
    /**
     * Key of the Label. The value must be a string between 1 and 64 characters long
     */
    key: string;
    /**
     * The list of allowed label hrefs
     */
    restrictions?: outputs.ContainerClusterWorkloadProfileLabelRestriction[];
}

export interface ContainerClusterWorkloadProfileLabelAssignment {
    /**
     * URI of label
     */
    href: string;
    /**
     * Name of label
     */
    value: string;
}

export interface ContainerClusterWorkloadProfileLabelRestriction {
    /**
     * URI of label
     */
    href: string;
    /**
     * Name of label
     */
    value: string;
}

export interface EnforcementBoundaryConsumer {
    /**
     * actors for consumers parameter. Allowed values is "ams"
     */
    actors?: string;
    /**
     * Href of IP List
     */
    ipList?: outputs.EnforcementBoundaryConsumerIpList;
    /**
     * Href of Label
     */
    label?: outputs.EnforcementBoundaryConsumerLabel;
    /**
     * Href of Label Group
     */
    labelGroup?: outputs.EnforcementBoundaryConsumerLabelGroup;
}

export interface EnforcementBoundaryConsumerIpList {
    /**
     * URI of IP List
     */
    href: string;
}

export interface EnforcementBoundaryConsumerLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface EnforcementBoundaryConsumerLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface EnforcementBoundaryIngressService {
    /**
     * URI of Service
     */
    href?: string;
    /**
     * Port number used with protocol or starting port when specifying a range. Allowed range is 0-65535
     */
    port?: string;
    /**
     * Protocol number. Allowed values are 6 (TCP) and 17 (UDP)
     */
    proto?: string;
    /**
     * Upper end of port range. Allowed range is 0-65535
     */
    toPort?: string;
}

export interface EnforcementBoundaryProvider {
    /**
     * actors for providers. Valid value is "ams"
     */
    actors?: string;
    /**
     * Href of IP List
     */
    ipList?: outputs.EnforcementBoundaryProviderIpList;
    /**
     * Href of Label
     */
    label?: outputs.EnforcementBoundaryProviderLabel;
    /**
     * Href of Label Group
     */
    labelGroup?: outputs.EnforcementBoundaryProviderLabelGroup;
}

export interface EnforcementBoundaryProviderIpList {
    /**
     * URI of IP List
     */
    href: string;
}

export interface EnforcementBoundaryProviderLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface EnforcementBoundaryProviderLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface FirewallSettingsBlockedConnectionRejectScope {
    /**
     * Href of Label Group
     */
    labelGroups?: outputs.FirewallSettingsBlockedConnectionRejectScopeLabelGroup[];
    /**
     * Href of Label
     */
    labels?: outputs.FirewallSettingsBlockedConnectionRejectScopeLabel[];
}

export interface FirewallSettingsBlockedConnectionRejectScopeLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface FirewallSettingsBlockedConnectionRejectScopeLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface FirewallSettingsContainersInheritHostPolicyScope {
    /**
     * Href of Label Group
     */
    labelGroups?: outputs.FirewallSettingsContainersInheritHostPolicyScopeLabelGroup[];
    /**
     * Href of Label
     */
    labels?: outputs.FirewallSettingsContainersInheritHostPolicyScopeLabel[];
}

export interface FirewallSettingsContainersInheritHostPolicyScopeLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface FirewallSettingsContainersInheritHostPolicyScopeLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface FirewallSettingsFirewallCoexistence {
    /**
     * Whether Illumio is primary firewall or not
     */
    illumioPrimary: boolean;
    /**
     * List of Href of label
     */
    scopes: outputs.FirewallSettingsFirewallCoexistenceScope[];
    /**
     * Match criteria to select workload(s). Allowed values are "enforced" and "illuminated"
     */
    workloadMode?: string;
}

export interface FirewallSettingsFirewallCoexistenceScope {
    /**
     * Href of Label
     */
    href: string;
}

export interface FirewallSettingsLoopbackInterfacesInPolicyScope {
    /**
     * Href of Label Group
     */
    labelGroups?: outputs.FirewallSettingsLoopbackInterfacesInPolicyScopeLabelGroup[];
    /**
     * Href of Label
     */
    labels?: outputs.FirewallSettingsLoopbackInterfacesInPolicyScopeLabel[];
}

export interface FirewallSettingsLoopbackInterfacesInPolicyScopeLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface FirewallSettingsLoopbackInterfacesInPolicyScopeLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface FirewallSettingsStaticPolicyScope {
    /**
     * Href of Label Group
     */
    labelGroups?: outputs.FirewallSettingsStaticPolicyScopeLabelGroup[];
    /**
     * Href of Label
     */
    labels?: outputs.FirewallSettingsStaticPolicyScopeLabel[];
}

export interface FirewallSettingsStaticPolicyScopeLabel {
    /**
     * URI of Label
     */
    href: string;
}

export interface FirewallSettingsStaticPolicyScopeLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface GetContainerClusterError {
    auditEvent: {[key: string]: string};
    duplicateIds: string[];
    errorType: string;
}

export interface GetContainerClusterNode {
    podSubnet: string;
}

export interface GetContainerClusterServiceBackendsItem {
    createdAt: string;
    kind: string;
    name: string;
    namespace: string;
    updatedAt: string;
    virtualServices: outputs.GetContainerClusterServiceBackendsItemVirtualService[];
}

export interface GetContainerClusterServiceBackendsItemVirtualService {
    href: string;
    name: string;
}

export interface GetContainerClusterWorkloadProfileAssignLabel {
    href: string;
}

export interface GetContainerClusterWorkloadProfileLabel {
    assignments: outputs.GetContainerClusterWorkloadProfileLabelAssignment[];
    key: string;
    restrictions: outputs.GetContainerClusterWorkloadProfileLabelRestriction[];
}

export interface GetContainerClusterWorkloadProfileLabelAssignment {
    href: string;
    value: string;
}

export interface GetContainerClusterWorkloadProfileLabelRestriction {
    href: string;
    value: string;
}

export interface GetContainerClusterWorkloadProfilesItem {
    assignLabels: outputs.GetContainerClusterWorkloadProfilesItemAssignLabel[];
    createdAt: string;
    createdBy: {[key: string]: string};
    description: string;
    enforcementMode: string;
    href: string;
    labels: outputs.GetContainerClusterWorkloadProfilesItemLabel[];
    linked: boolean;
    managed: boolean;
    name: string;
    namespace: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    visibilityLevel: string;
}

export interface GetContainerClusterWorkloadProfilesItemAssignLabel {
    href: string;
}

export interface GetContainerClusterWorkloadProfilesItemLabel {
    assignments: outputs.GetContainerClusterWorkloadProfilesItemLabelAssignment[];
    key: string;
    restrictions: outputs.GetContainerClusterWorkloadProfilesItemLabelRestriction[];
}

export interface GetContainerClusterWorkloadProfilesItemLabelAssignment {
    href: string;
    value: string;
}

export interface GetContainerClusterWorkloadProfilesItemLabelRestriction {
    href: string;
    value: string;
}

export interface GetContainerClustersItem {
    caps: string[];
    containerClusterId: string;
    containerRuntime: string;
    description: string;
    errors: outputs.GetContainerClustersItemError[];
    href: string;
    kubelinkVersion: string;
    lastConnected: string;
    managerType: string;
    name: string;
    nodes: outputs.GetContainerClustersItemNode[];
    online: boolean;
    pceFqdn: string;
}

export interface GetContainerClustersItemError {
    auditEvent: {[key: string]: string};
    duplicateIds: string[];
    errorType: string;
}

export interface GetContainerClustersItemNode {
    podSubnet: string;
}

export interface GetEnforcementBoundariesItem {
    caps: string[];
    consumers: outputs.GetEnforcementBoundariesItemConsumer[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    enabled: boolean;
    href: string;
    ingressServices: outputs.GetEnforcementBoundariesItemIngressService[];
    name: string;
    providers: outputs.GetEnforcementBoundariesItemProvider[];
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetEnforcementBoundariesItemConsumer {
    actors: string;
    ipLists: outputs.GetEnforcementBoundariesItemConsumerIpList[];
    labelGroups: outputs.GetEnforcementBoundariesItemConsumerLabelGroup[];
    labels: outputs.GetEnforcementBoundariesItemConsumerLabel[];
}

export interface GetEnforcementBoundariesItemConsumerIpList {
    href: string;
}

export interface GetEnforcementBoundariesItemConsumerLabel {
    href: string;
}

export interface GetEnforcementBoundariesItemConsumerLabelGroup {
    href: string;
}

export interface GetEnforcementBoundariesItemIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetEnforcementBoundariesItemProvider {
    actors: string;
    ipLists: outputs.GetEnforcementBoundariesItemProviderIpList[];
    labelGroups: outputs.GetEnforcementBoundariesItemProviderLabelGroup[];
    labels: outputs.GetEnforcementBoundariesItemProviderLabel[];
}

export interface GetEnforcementBoundariesItemProviderIpList {
    href: string;
}

export interface GetEnforcementBoundariesItemProviderLabel {
    href: string;
}

export interface GetEnforcementBoundariesItemProviderLabelGroup {
    href: string;
}

export interface GetEnforcementBoundaryConsumer {
    actors: string;
    ipLists: outputs.GetEnforcementBoundaryConsumerIpList[];
    labelGroups: outputs.GetEnforcementBoundaryConsumerLabelGroup[];
    labels: outputs.GetEnforcementBoundaryConsumerLabel[];
}

export interface GetEnforcementBoundaryConsumerIpList {
    href: string;
}

export interface GetEnforcementBoundaryConsumerLabel {
    href: string;
}

export interface GetEnforcementBoundaryConsumerLabelGroup {
    href: string;
}

export interface GetEnforcementBoundaryIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetEnforcementBoundaryProvider {
    /**
     * actors for providers
     */
    actors: string;
    /**
     * Href of IP List
     */
    ipLists: outputs.GetEnforcementBoundaryProviderIpList[];
    /**
     * Href of Label Group
     */
    labelGroups: outputs.GetEnforcementBoundaryProviderLabelGroup[];
    /**
     * Href of Label
     */
    labels: outputs.GetEnforcementBoundaryProviderLabel[];
}

export interface GetEnforcementBoundaryProviderIpList {
    href: string;
}

export interface GetEnforcementBoundaryProviderLabel {
    href: string;
}

export interface GetEnforcementBoundaryProviderLabelGroup {
    href: string;
}

export interface GetFirewallSettingsBlockedConnectionRejectScope {
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
}

export interface GetFirewallSettingsContainersInheritHostPolicyScope {
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
}

export interface GetFirewallSettingsFirewallCoexistence {
    illumioPrimary: boolean;
    scopes: outputs.GetFirewallSettingsFirewallCoexistenceScope[];
    workloadMode: string;
}

export interface GetFirewallSettingsFirewallCoexistenceScope {
    href: string;
}

export interface GetFirewallSettingsLoopbackInterfacesInPolicyScope {
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
}

export interface GetFirewallSettingsStaticPolicyScope {
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
}

export interface GetIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetIpListsItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetIpListsItemFqdn[];
    href: string;
    ipRanges: outputs.GetIpListsItemIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetIpListsItemFqdn {
    description: string;
    fqdn: string;
}

export interface GetIpListsItemIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetLabelGroupLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetLabelGroupSubGroup {
    href: string;
    name: string;
}

export interface GetLabelGroupsItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    key: string;
    labels: outputs.GetLabelGroupsItemLabel[];
    name: string;
    subGroups: outputs.GetLabelGroupsItemSubGroup[];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetLabelGroupsItemLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetLabelGroupsItemSubGroup {
    href: string;
    name: string;
}

export interface GetLabelTypeDisplayInfo {
    backgroundColor: string;
    displayNamePlural: string;
    foregroundColor: string;
    icon: string;
    initial: string;
    sortOrdinal: string;
}

export interface GetLabelTypesItem {
    caps: string[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deleted: boolean;
    deletedAt: string;
    deletedBy: {[key: string]: string};
    displayInfos: outputs.GetLabelTypesItemDisplayInfo[];
    displayName: string;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    key: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    usage: {[key: string]: boolean};
}

export interface GetLabelTypesItemDisplayInfo {
    backgroundColor: string;
    displayNamePlural: string;
    foregroundColor: string;
    icon: string;
    initial: string;
    sortOrdinal: string;
}

export interface GetLabelsItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    deleted: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    key: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    value: string;
}

export interface GetPairingProfileLabel {
    href: string;
}

export interface GetPairingProfilesItem {
    agentSoftwareRelease: string;
    allowedUsesPerKey: string;
    appLabelLock: boolean;
    caps: string[];
    createdAt: string;
    createdBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    enforcementMode: string;
    enforcementModeLock: boolean;
    envLabelLock: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    isDefault: boolean;
    keyLifespan: string;
    labels: outputs.GetPairingProfilesItemLabel[];
    lastPairingAt: string;
    locLabelLock: boolean;
    logTraffic: boolean;
    logTrafficLock: boolean;
    name: string;
    roleLabelLock: boolean;
    status: string;
    statusLock: boolean;
    totalUseCount: number;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    visibilityLevel: string;
    visibilityLevelLock: boolean;
}

export interface GetPairingProfilesItemLabel {
    href: string;
}

export interface GetRuleSetIpTablesRule {
    actors: outputs.GetRuleSetIpTablesRuleActor[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    href: string;
    ipVersion: string;
    statements: outputs.GetRuleSetIpTablesRuleStatement[];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetIpTablesRuleActor {
    actors: string;
    labelGroups: string[];
    labels: outputs.GetRuleSetIpTablesRuleActorLabel[];
    workloads: string[];
}

export interface GetRuleSetIpTablesRuleActorLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetIpTablesRuleStatement {
    chainName: string;
    parameters: string;
    tableName: string;
}

export interface GetRuleSetRule {
    consumers: outputs.GetRuleSetRuleConsumer[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    ingressServices: outputs.GetRuleSetRuleIngressService[];
    machineAuth: boolean;
    providers: outputs.GetRuleSetRuleProvider[];
    resolveLabelsAs: outputs.GetRuleSetRuleResolveLabelsA[];
    ruleSetHref: string;
    secConnect: boolean;
    stateless: boolean;
    unscopedConsumers: boolean;
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    useWorkloadSubnets: string[];
}

export interface GetRuleSetRuleConsumer {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetRuleSetRuleConsumerIpList[];
    labelGroups: outputs.GetRuleSetRuleConsumerLabelGroup[];
    labels: outputs.GetRuleSetRuleConsumerLabel[];
    virtualServices: outputs.GetRuleSetRuleConsumerVirtualService[];
    workloads: outputs.GetRuleSetRuleConsumerWorkload[];
}

export interface GetRuleSetRuleConsumerIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetRuleSetRuleConsumerIpListFqdn[];
    href: string;
    ipRanges: outputs.GetRuleSetRuleConsumerIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetRuleConsumerIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetRuleSetRuleConsumerIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetRuleSetRuleConsumerLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetRuleConsumerLabelGroup {
    href: string;
}

export interface GetRuleSetRuleConsumerVirtualService {
    href: string;
}

export interface GetRuleSetRuleConsumerWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetRuleSetRuleIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetRuleSetRuleProvider {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetRuleSetRuleProviderIpList[];
    labelGroups: outputs.GetRuleSetRuleProviderLabelGroup[];
    labels: outputs.GetRuleSetRuleProviderLabel[];
    virtualServers: outputs.GetRuleSetRuleProviderVirtualServer[];
    virtualServices: outputs.GetRuleSetRuleProviderVirtualService[];
    workloads: outputs.GetRuleSetRuleProviderWorkload[];
}

export interface GetRuleSetRuleProviderIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetRuleSetRuleProviderIpListFqdn[];
    href: string;
    ipRanges: outputs.GetRuleSetRuleProviderIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetRuleProviderIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetRuleSetRuleProviderIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetRuleSetRuleProviderLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetRuleProviderLabelGroup {
    href: string;
}

export interface GetRuleSetRuleProviderVirtualServer {
    href: string;
}

export interface GetRuleSetRuleProviderVirtualService {
    href: string;
    name: string;
}

export interface GetRuleSetRuleProviderWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetRuleSetRuleResolveLabelsA {
    consumers: string[];
    providers: string[];
}

export interface GetRuleSetScope {
    exclusion: boolean;
    labelGroups: outputs.GetRuleSetScopeLabelGroup[];
    labels: outputs.GetRuleSetScopeLabel[];
}

export interface GetRuleSetScopeLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetScopeLabelGroup {
    href: string;
    key: string;
    name: string;
}

export interface GetRuleSetsItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    ipTablesRules: outputs.GetRuleSetsItemIpTablesRule[];
    name: string;
    rules: outputs.GetRuleSetsItemRule[];
    scopes: outputs.GetRuleSetsItemScope[][];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetsItemIpTablesRule {
    actors: outputs.GetRuleSetsItemIpTablesRuleActor[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    href: string;
    ipVersion: string;
    statements: outputs.GetRuleSetsItemIpTablesRuleStatement[];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetsItemIpTablesRuleActor {
    actors: string;
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
    workload: {[key: string]: string};
}

export interface GetRuleSetsItemIpTablesRuleStatement {
    chainName: string;
    parameters: string;
    tableName: string;
}

export interface GetRuleSetsItemRule {
    consumers: outputs.GetRuleSetsItemRuleConsumer[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    ingressServices: outputs.GetRuleSetsItemRuleIngressService[];
    machineAuth: boolean;
    providers: outputs.GetRuleSetsItemRuleProvider[];
    resolveLabelsAs: outputs.GetRuleSetsItemRuleResolveLabelsA[];
    ruleSetHref: string;
    secConnect: boolean;
    stateless: boolean;
    unscopedConsumers: boolean;
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    useWorkloadSubnets: string[];
}

export interface GetRuleSetsItemRuleConsumer {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetRuleSetsItemRuleConsumerIpList[];
    labelGroups: outputs.GetRuleSetsItemRuleConsumerLabelGroup[];
    labels: outputs.GetRuleSetsItemRuleConsumerLabel[];
    virtualServices: outputs.GetRuleSetsItemRuleConsumerVirtualService[];
    workloads: outputs.GetRuleSetsItemRuleConsumerWorkload[];
}

export interface GetRuleSetsItemRuleConsumerIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetRuleSetsItemRuleConsumerIpListFqdn[];
    href: string;
    ipRanges: outputs.GetRuleSetsItemRuleConsumerIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetsItemRuleConsumerIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetRuleSetsItemRuleConsumerIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetRuleSetsItemRuleConsumerLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetsItemRuleConsumerLabelGroup {
    href: string;
}

export interface GetRuleSetsItemRuleConsumerVirtualService {
    href: string;
}

export interface GetRuleSetsItemRuleConsumerWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetRuleSetsItemRuleIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetRuleSetsItemRuleProvider {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetRuleSetsItemRuleProviderIpList[];
    labelGroups: outputs.GetRuleSetsItemRuleProviderLabelGroup[];
    labels: outputs.GetRuleSetsItemRuleProviderLabel[];
    virtualServers: outputs.GetRuleSetsItemRuleProviderVirtualServer[];
    virtualServices: outputs.GetRuleSetsItemRuleProviderVirtualService[];
    workloads: outputs.GetRuleSetsItemRuleProviderWorkload[];
}

export interface GetRuleSetsItemRuleProviderIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetRuleSetsItemRuleProviderIpListFqdn[];
    href: string;
    ipRanges: outputs.GetRuleSetsItemRuleProviderIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetRuleSetsItemRuleProviderIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetRuleSetsItemRuleProviderIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetRuleSetsItemRuleProviderLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetRuleSetsItemRuleProviderLabelGroup {
    href: string;
}

export interface GetRuleSetsItemRuleProviderVirtualServer {
    href: string;
}

export interface GetRuleSetsItemRuleProviderVirtualService {
    href: string;
    name: string;
}

export interface GetRuleSetsItemRuleProviderWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetRuleSetsItemRuleResolveLabelsA {
    consumers: string[];
    providers: string[];
}

export interface GetRuleSetsItemScope {
    label: {[key: string]: string};
    labelGroup: {[key: string]: string};
}

export interface GetSecurityRuleConsumer {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetSecurityRuleConsumerIpList[];
    labelGroups: outputs.GetSecurityRuleConsumerLabelGroup[];
    labels: outputs.GetSecurityRuleConsumerLabel[];
    virtualServices: outputs.GetSecurityRuleConsumerVirtualService[];
    workloads: outputs.GetSecurityRuleConsumerWorkload[];
}

export interface GetSecurityRuleConsumerIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetSecurityRuleConsumerIpListFqdn[];
    href: string;
    ipRanges: outputs.GetSecurityRuleConsumerIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetSecurityRuleConsumerIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetSecurityRuleConsumerIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetSecurityRuleConsumerLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetSecurityRuleConsumerLabelGroup {
    href: string;
}

export interface GetSecurityRuleConsumerVirtualService {
    href: string;
}

export interface GetSecurityRuleConsumerWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetSecurityRuleIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetSecurityRuleProvider {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetSecurityRuleProviderIpList[];
    labelGroups: outputs.GetSecurityRuleProviderLabelGroup[];
    labels: outputs.GetSecurityRuleProviderLabel[];
    virtualServers: outputs.GetSecurityRuleProviderVirtualServer[];
    virtualServices: outputs.GetSecurityRuleProviderVirtualService[];
    workloads: outputs.GetSecurityRuleProviderWorkload[];
}

export interface GetSecurityRuleProviderIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetSecurityRuleProviderIpListFqdn[];
    href: string;
    ipRanges: outputs.GetSecurityRuleProviderIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetSecurityRuleProviderIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetSecurityRuleProviderIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetSecurityRuleProviderLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetSecurityRuleProviderLabelGroup {
    href: string;
}

export interface GetSecurityRuleProviderVirtualServer {
    href: string;
}

export interface GetSecurityRuleProviderVirtualService {
    href: string;
    name: string;
}

export interface GetSecurityRuleProviderWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetSecurityRuleResolveLabelsA {
    consumers: string[];
    providers: string[];
}

export interface GetSecurityRulesItem {
    consumers: outputs.GetSecurityRulesItemConsumer[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    enabled: boolean;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    ingressServices: outputs.GetSecurityRulesItemIngressService[];
    machineAuth: boolean;
    providers: outputs.GetSecurityRulesItemProvider[];
    resolveLabelsAs: outputs.GetSecurityRulesItemResolveLabelsA[];
    ruleSetHref: string;
    secConnect: boolean;
    stateless: boolean;
    unscopedConsumers: boolean;
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    useWorkloadSubnets: string[];
}

export interface GetSecurityRulesItemConsumer {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetSecurityRulesItemConsumerIpList[];
    labelGroups: outputs.GetSecurityRulesItemConsumerLabelGroup[];
    labels: outputs.GetSecurityRulesItemConsumerLabel[];
    virtualServices: outputs.GetSecurityRulesItemConsumerVirtualService[];
    workloads: outputs.GetSecurityRulesItemConsumerWorkload[];
}

export interface GetSecurityRulesItemConsumerIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetSecurityRulesItemConsumerIpListFqdn[];
    href: string;
    ipRanges: outputs.GetSecurityRulesItemConsumerIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetSecurityRulesItemConsumerIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetSecurityRulesItemConsumerIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetSecurityRulesItemConsumerLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetSecurityRulesItemConsumerLabelGroup {
    href: string;
}

export interface GetSecurityRulesItemConsumerVirtualService {
    href: string;
}

export interface GetSecurityRulesItemConsumerWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetSecurityRulesItemIngressService {
    href: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetSecurityRulesItemProvider {
    actors: string;
    exclusion: boolean;
    ipLists: outputs.GetSecurityRulesItemProviderIpList[];
    labelGroups: outputs.GetSecurityRulesItemProviderLabelGroup[];
    labels: outputs.GetSecurityRulesItemProviderLabel[];
    virtualServers: outputs.GetSecurityRulesItemProviderVirtualServer[];
    virtualServices: outputs.GetSecurityRulesItemProviderVirtualService[];
    workloads: outputs.GetSecurityRulesItemProviderWorkload[];
}

export interface GetSecurityRulesItemProviderIpList {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    fqdns: outputs.GetSecurityRulesItemProviderIpListFqdn[];
    href: string;
    ipRanges: outputs.GetSecurityRulesItemProviderIpListIpRange[];
    name: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetSecurityRulesItemProviderIpListFqdn {
    description: string;
    fqdn: string;
}

export interface GetSecurityRulesItemProviderIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface GetSecurityRulesItemProviderLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetSecurityRulesItemProviderLabelGroup {
    href: string;
}

export interface GetSecurityRulesItemProviderVirtualServer {
    href: string;
}

export interface GetSecurityRulesItemProviderVirtualService {
    href: string;
    name: string;
}

export interface GetSecurityRulesItemProviderWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetSecurityRulesItemResolveLabelsA {
    consumers: string[];
    providers: string[];
}

export interface GetServiceBindingContainerWorkload {
    href: string;
}

export interface GetServiceBindingPortOverride {
    newPort: number;
    newToPort: number;
    port: number;
    proto: number;
}

export interface GetServiceBindingVirtualService {
    href: string;
}

export interface GetServiceBindingWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetServiceBindingsItem {
    boundService: {[key: string]: string};
    containerWorkload: {[key: string]: string};
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    portOverrides: outputs.GetServiceBindingsItemPortOverride[];
    virtualService: {[key: string]: string};
    workloads: outputs.GetServiceBindingsItemWorkload[];
}

export interface GetServiceBindingsItemPortOverride {
    newPort: number;
    newToPort: number;
    port: number;
    proto: number;
}

export interface GetServiceBindingsItemWorkload {
    deleted: boolean;
    hostname: string;
    href: string;
    name: string;
}

export interface GetServiceServicePort {
    icmpCode: string;
    icmpType: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetServiceWindowsEgressService {
    processName: string;
    serviceName: string;
}

export interface GetServiceWindowsService {
    icmpCode: string;
    icmpType: string;
    port: string;
    processName: string;
    proto: string;
    serviceName: string;
    toPort: string;
}

export interface GetServicesItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    descriptionUrl: string;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    name: string;
    processName: string;
    servicePorts: outputs.GetServicesItemServicePort[];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    windowsEgressServices: outputs.GetServicesItemWindowsEgressService[];
    windowsServices: outputs.GetServicesItemWindowsService[];
}

export interface GetServicesItemServicePort {
    icmpCode: string;
    icmpType: string;
    port: string;
    proto: string;
    toPort: string;
}

export interface GetServicesItemWindowsEgressService {
    processName: string;
    serviceName: string;
}

export interface GetServicesItemWindowsService {
    icmpCode: string;
    icmpType: string;
    port: string;
    processName: string;
    proto: string;
    serviceName: string;
    toPort: string;
}

export interface GetSyslogDestinationAuditEventLogger {
    configurationEventIncluded: boolean;
    minSeverity: string;
    systemEventIncluded: boolean;
}

export interface GetSyslogDestinationNodeStatusLogger {
    nodeStatusIncluded: boolean;
}

export interface GetSyslogDestinationRemoteSyslog {
    address: string;
    port: number;
    protocol: number;
    tlsCaBundle: string;
    tlsEnabled: boolean;
    tlsVerifyCert: boolean;
}

export interface GetSyslogDestinationTrafficEventLogger {
    trafficFlowAllowedEventIncluded: boolean;
    trafficFlowBlockedEventIncluded: boolean;
    trafficFlowPotentiallyBlockedEventIncluded: boolean;
}

export interface GetSyslogDestinationsItem {
    auditEventLoggers: outputs.GetSyslogDestinationsItemAuditEventLogger[];
    description: string;
    href: string;
    nodeStatusLoggers: outputs.GetSyslogDestinationsItemNodeStatusLogger[];
    pceScopes: string[];
    remoteSyslogs: outputs.GetSyslogDestinationsItemRemoteSyslog[];
    trafficEventLoggers: outputs.GetSyslogDestinationsItemTrafficEventLogger[];
    type: string;
}

export interface GetSyslogDestinationsItemAuditEventLogger {
    configurationEventIncluded: boolean;
    minSeverity: string;
    systemEventIncluded: boolean;
}

export interface GetSyslogDestinationsItemNodeStatusLogger {
    nodeStatusIncluded: boolean;
}

export interface GetSyslogDestinationsItemRemoteSyslog {
    address: string;
    port: number;
    protocol: number;
    tlsCaBundle: string;
    tlsEnabled: boolean;
    tlsVerifyCert: boolean;
}

export interface GetSyslogDestinationsItemTrafficEventLogger {
    trafficFlowAllowedEventIncluded: boolean;
    trafficFlowBlockedEventIncluded: boolean;
    trafficFlowPotentiallyBlockedEventIncluded: boolean;
}

export interface GetTrafficCollectorSettingsListItem {
    action: string;
    href: string;
    targets: outputs.GetTrafficCollectorSettingsListItemTarget[];
    transmission: string;
}

export interface GetTrafficCollectorSettingsListItemTarget {
    dstIp: string;
    dstPort: number;
    proto: number;
}

export interface GetTrafficCollectorSettingsTarget {
    dstIp: string;
    dstPort: number;
    proto: number;
}

export interface GetVenCondition {
    firstReportedTimestamp: string;
    latestEvents: outputs.GetVenConditionLatestEvent[];
}

export interface GetVenConditionLatestEvent {
    href: string;
    infos: outputs.GetVenConditionLatestEventInfo[];
    notificationType: string;
    severity: string;
    timestamp: string;
}

export interface GetVenConditionLatestEventInfo {
    agent: {[key: string]: string};
}

export interface GetVenContainerCluster {
    href: string;
    name: string;
}

export interface GetVenInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    href: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetVenLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVenSecureConnect {
    matchingIssuerName: string;
}

export interface GetVenWorkload {
    enforcementMode: string;
    hostname: string;
    href: string;
    interfaces: outputs.GetVenWorkloadInterface[];
    labels: outputs.GetVenWorkloadLabel[];
    mode: string;
    name: string;
    online: boolean;
    osDetail: string;
    osId: string;
    publicIp: string;
    securityPolicyAppliedAt: string;
    securityPolicyReceivedAt: string;
    visibilityLevel: string;
}

export interface GetVenWorkloadInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetVenWorkloadLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVensItem {
    activationType: string;
    activePceFqdn: string;
    caps: string[];
    conditions: outputs.GetVensItemCondition[];
    containerClusters: outputs.GetVensItemContainerCluster[];
    createdAt: string;
    createdBy: {[key: string]: string};
    description: string;
    hostname: string;
    href: string;
    interfaces: outputs.GetVensItemInterface[];
    labels: outputs.GetVensItemLabel[];
    lastGoodbyeAt: string;
    lastHeartbeatAt: string;
    name: string;
    osDetail: string;
    osId: string;
    osPlatform: string;
    secureConnects: outputs.GetVensItemSecureConnect[];
    status: string;
    targetPceFqdn: string;
    uid: string;
    unpairAllowed: boolean;
    updatedAt: string;
    updatedBy: {[key: string]: string};
    version: string;
    workloads: outputs.GetVensItemWorkload[];
}

export interface GetVensItemCondition {
    firstReportedTimestamp: string;
    latestEvents: outputs.GetVensItemConditionLatestEvent[];
}

export interface GetVensItemConditionLatestEvent {
    href: string;
    infos: outputs.GetVensItemConditionLatestEventInfo[];
    notificationType: string;
    severity: string;
    timestamp: string;
}

export interface GetVensItemConditionLatestEventInfo {
    agent: {[key: string]: string};
}

export interface GetVensItemContainerCluster {
    href: string;
    name: string;
}

export interface GetVensItemInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    href: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetVensItemLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVensItemSecureConnect {
    matchingIssuerName: string;
}

export interface GetVensItemWorkload {
    enforcementMode: string;
    hostname: string;
    href: string;
    interfaces: outputs.GetVensItemWorkloadInterface[];
    labels: outputs.GetVensItemWorkloadLabel[];
    mode: string;
    name: string;
    online: boolean;
    osDetail: string;
    osId: string;
    publicIp: string;
    securityPolicyAppliedAt: string;
    securityPolicyReceivedAt: string;
    visibilityLevel: string;
}

export interface GetVensItemWorkloadInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetVensItemWorkloadLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVirtualServiceLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVirtualServiceService {
    href: string;
}

export interface GetVirtualServiceServiceAddress {
    description: string;
    fqdn: string;
    ip: string;
    network: {[key: string]: string};
    port: string;
}

export interface GetVirtualServiceServicePort {
    port: string;
    proto: string;
    toPort: string;
}

export interface GetVirtualServicesItem {
    applyTo: string;
    caps: string[];
    createdAt: string;
    createdBy: {[key: string]: string};
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    externalDataReference: string;
    externalDataSet: string;
    href: string;
    ipOverrides: string[];
    labels: outputs.GetVirtualServicesItemLabel[];
    name: string;
    pceFqdn: string;
    serviceAddresses: outputs.GetVirtualServicesItemServiceAddress[];
    servicePorts: outputs.GetVirtualServicesItemServicePort[];
    services: outputs.GetVirtualServicesItemService[];
    updateType: string;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetVirtualServicesItemLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetVirtualServicesItemService {
    href: string;
}

export interface GetVirtualServicesItemServiceAddress {
    description: string;
    fqdn: string;
    ip: string;
    network: {[key: string]: string};
    port: number;
}

export interface GetVirtualServicesItemServicePort {
    port: number;
    proto: number;
    toPort: number;
}

export interface GetVulnerabilitiesItem {
    createdAt: string;
    createdBy: {[key: string]: string};
    cveIds: string[];
    description: string;
    href: string;
    name: string;
    score: number;
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetVulnerabilityReportsItem {
    authoritative: boolean;
    createdAt: string;
    createdBy: {[key: string]: string};
    exportedAt: string;
    href: string;
    name: string;
    numVulnerabilities: number;
    reportType: string;
    scannedIps: string[];
    updatedAt: string;
    updatedBy: {[key: string]: string};
}

export interface GetWorkloadContainerCluster {
    href: string;
    name: string;
}

export interface GetWorkloadDetectedVulnerability {
    ipAddress: string;
    port: number;
    portExposure: number;
    portWideExposures: outputs.GetWorkloadDetectedVulnerabilityPortWideExposure[];
    proto: number;
    vulnerabilities: outputs.GetWorkloadDetectedVulnerabilityVulnerability[];
    vulnerabilityReports: outputs.GetWorkloadDetectedVulnerabilityVulnerabilityReport[];
    workloads: outputs.GetWorkloadDetectedVulnerabilityWorkload[];
}

export interface GetWorkloadDetectedVulnerabilityPortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface GetWorkloadDetectedVulnerabilityVulnerability {
    href: string;
    name: string;
    score: number;
}

export interface GetWorkloadDetectedVulnerabilityVulnerabilityReport {
    href: string;
}

export interface GetWorkloadDetectedVulnerabilityWorkload {
    href: string;
}

export interface GetWorkloadFirewallCoexistence {
    illumioPrimary: boolean;
}

export interface GetWorkloadInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetWorkloadInterfacesItem {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    href: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetWorkloadLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetWorkloadSelectivelyEnforcedService {
    href: string;
    port: number;
    proto: number;
    toPort: number;
}

export interface GetWorkloadService {
    createdAt: string;
    openServicePorts: outputs.GetWorkloadServiceOpenServicePort[];
    uptimeSeconds: number;
}

export interface GetWorkloadServiceOpenServicePort {
    address: string;
    package: string;
    port: number;
    processName: string;
    protocol: number;
    user: string;
    winServiceName: string;
}

export interface GetWorkloadSettingsWorkloadDisconnectedTimeoutSecond {
    scopes: outputs.GetWorkloadSettingsWorkloadDisconnectedTimeoutSecondScope[];
    value: number;
    venType: string;
}

export interface GetWorkloadSettingsWorkloadDisconnectedTimeoutSecondScope {
    href: string;
}

export interface GetWorkloadSettingsWorkloadGoodbyeTimeoutSecond {
    scopes: outputs.GetWorkloadSettingsWorkloadGoodbyeTimeoutSecondScope[];
    value: number;
    venType: string;
}

export interface GetWorkloadSettingsWorkloadGoodbyeTimeoutSecondScope {
    href: string;
}

export interface GetWorkloadVulnerabilitiesSummary {
    maxVulnerabilityScore: number;
    numVulnerabilities: number;
    vulnerabilityExposureScore: number;
    vulnerabilityScore: number;
    vulnerablePortExposure: number;
    vulnerablePortWideExposures: outputs.GetWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure[];
}

export interface GetWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface GetWorkloadsItem {
    agentToPceCertificateAuthenticationId: string;
    blockedConnectionAction: string;
    caps: string[];
    containerClusters: outputs.GetWorkloadsItemContainerCluster[];
    containersInheritHostPolicy: boolean;
    createdAt: string;
    createdBy: {[key: string]: string};
    dataCenter: string;
    dataCenterZone: string;
    deleted: boolean;
    deletedAt: string;
    deletedBy: {[key: string]: string};
    description: string;
    detectedVulnerabilities: outputs.GetWorkloadsItemDetectedVulnerability[];
    distinguishedName: string;
    enforcementMode: string;
    externalDataReference: string;
    externalDataSet: string;
    firewallCoexistences: outputs.GetWorkloadsItemFirewallCoexistence[];
    hostname: string;
    href: string;
    ignoredInterfaceNames: string[];
    ikeAuthenticationCertificate: {[key: string]: string};
    interfaces: outputs.GetWorkloadsItemInterface[];
    labels: outputs.GetWorkloadsItemLabel[];
    name: string;
    online: boolean;
    osDetail: string;
    osId: string;
    publicIp: string;
    selectivelyEnforcedServices: outputs.GetWorkloadsItemSelectivelyEnforcedService[];
    servicePrincipalName: string;
    serviceProvider: string;
    services: outputs.GetWorkloadsItemService[];
    updatedAt: string;
    updatedBy: {[key: string]: string};
    ven: {[key: string]: string};
    visibilityLevel: string;
    vulnerabilitiesSummaries: outputs.GetWorkloadsItemVulnerabilitiesSummary[];
}

export interface GetWorkloadsItemContainerCluster {
    href: string;
    name: string;
}

export interface GetWorkloadsItemDetectedVulnerability {
    ipAddress: string;
    port: number;
    portExposure: number;
    portWideExposures: outputs.GetWorkloadsItemDetectedVulnerabilityPortWideExposure[];
    proto: number;
    vulnerabilities: outputs.GetWorkloadsItemDetectedVulnerabilityVulnerability[];
    vulnerabilityReports: outputs.GetWorkloadsItemDetectedVulnerabilityVulnerabilityReport[];
    workloads: outputs.GetWorkloadsItemDetectedVulnerabilityWorkload[];
}

export interface GetWorkloadsItemDetectedVulnerabilityPortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface GetWorkloadsItemDetectedVulnerabilityVulnerability {
    href: string;
    name: string;
    score: number;
}

export interface GetWorkloadsItemDetectedVulnerabilityVulnerabilityReport {
    href: string;
}

export interface GetWorkloadsItemDetectedVulnerabilityWorkload {
    href: string;
}

export interface GetWorkloadsItemFirewallCoexistence {
    illumioPrimary: boolean;
}

export interface GetWorkloadsItemInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface GetWorkloadsItemLabel {
    href: string;
    key: string;
    value: string;
}

export interface GetWorkloadsItemSelectivelyEnforcedService {
    href: string;
    port: number;
    proto: number;
    toPort: number;
}

export interface GetWorkloadsItemService {
    createdAt: string;
    openServicePorts: outputs.GetWorkloadsItemServiceOpenServicePort[];
    uptimeSeconds: number;
}

export interface GetWorkloadsItemServiceOpenServicePort {
    address: string;
    package: string;
    port: number;
    processName: string;
    protocol: number;
    user: string;
    winServiceName: string;
}

export interface GetWorkloadsItemVulnerabilitiesSummary {
    maxVulnerabilityScore: number;
    numVulnerabilities: number;
    vulnerabilityExposureScore: number;
    vulnerabilityScore: number;
    vulnerablePortExposure: number;
    vulnerablePortWideExposures: outputs.GetWorkloadsItemVulnerabilitiesSummaryVulnerablePortWideExposure[];
}

export interface GetWorkloadsItemVulnerabilitiesSummaryVulnerablePortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface IpListFqdn {
    /**
     * Description of FQDN
     */
    description?: string;
    /**
     * Fully Qualified Domain Name for IP List. Supported formats are hostname, IP, and URI
     */
    fqdn: string;
}

export interface IpListIpRange {
    /**
     * Description of IP Range
     */
    description?: string;
    /**
     * Whether this IP address is an exclusion. Exclusions must be a strict subset of inclusive IP addresses
     */
    exclusion?: boolean;
    /**
     * IP address or a low end of IP range. Might be specified with CIDR notation. The IP given should be in CIDR format example "0.0.0.0/0"
     */
    fromIp: string;
    /**
     * High end of an IP range
     */
    toIp?: string;
}

export interface LabelGroupLabel {
    /**
     * URI of label
     */
    href: string;
    /**
     * Key in key-value pair
     */
    key: string;
    /**
     * Value in key-value pair
     */
    value: string;
}

export interface LabelGroupSubGroup {
    /**
     * URI of label group
     */
    href: string;
    /**
     * Key in key-value pair
     */
    name: string;
}

export interface LabelTypeDisplayInfo {
    /**
     * Background color in hexadecimal for UI display
     */
    backgroundColor?: string;
    /**
     * Optional pluralized form of the display name for the label type
     */
    displayNamePlural?: string;
    /**
     * Foreground color in hexadecimal for UI display
     */
    foregroundColor?: string;
    /**
     * Icon for use in the UI display
     */
    icon?: string;
    /**
     * 1-2 initial characters for use in the UI display. Defaults to the first letter of the label type's display_name
     */
    initial?: string;
    /**
     * Optional user provided sort order for label type
     */
    sortOrdinal?: string;
}

export interface ManagedWorkloadContainerCluster {
    href: string;
    name: string;
}

export interface ManagedWorkloadDetectedVulnerability {
    ipAddress: string;
    port: number;
    portExposure: number;
    portWideExposures: outputs.ManagedWorkloadDetectedVulnerabilityPortWideExposure[];
    proto: number;
    vulnerabilities: outputs.ManagedWorkloadDetectedVulnerabilityVulnerability[];
    vulnerabilityReports: outputs.ManagedWorkloadDetectedVulnerabilityVulnerabilityReport[];
    workloads: outputs.ManagedWorkloadDetectedVulnerabilityWorkload[];
}

export interface ManagedWorkloadDetectedVulnerabilityPortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface ManagedWorkloadDetectedVulnerabilityVulnerability {
    href: string;
    name: string;
    score: number;
}

export interface ManagedWorkloadDetectedVulnerabilityVulnerabilityReport {
    href: string;
}

export interface ManagedWorkloadDetectedVulnerabilityWorkload {
    href: string;
}

export interface ManagedWorkloadFirewallCoexistence {
    illumioPrimary: boolean;
}

export interface ManagedWorkloadInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface ManagedWorkloadLabel {
    /**
     * URI of label
     */
    href: string;
}

export interface ManagedWorkloadSelectivelyEnforcedService {
    href: string;
    port: number;
    proto: number;
    toPort: number;
}

export interface ManagedWorkloadService {
    createdAt: string;
    openServicePorts: outputs.ManagedWorkloadServiceOpenServicePort[];
    uptimeSeconds: number;
}

export interface ManagedWorkloadServiceOpenServicePort {
    address: string;
    package: string;
    port: number;
    processName: string;
    protocol: number;
    user: string;
    winServiceName: string;
}

export interface ManagedWorkloadVulnerabilitiesSummary {
    maxVulnerabilityScore: number;
    numVulnerabilities: number;
    vulnerabilityExposureScore: number;
    vulnerabilityScore: number;
    vulnerablePortExposure: number;
    vulnerablePortWideExposures: outputs.ManagedWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure[];
}

export interface ManagedWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface PairingKeysActivationToken {
    activationToken: string;
    nonce: string;
}

export interface PairingProfileLabel {
    /**
     * Label URI
     */
    href: string;
}

export interface RuleSetIpTablesRule {
    /**
     * actors for IP Table Rule
     */
    actors: outputs.RuleSetIpTablesRuleActor[];
    /**
     * Timestamp when this IP Table Rule was first created
     */
    createdAt: string;
    /**
     * User who created this IP Table Rule
     */
    createdBy: {[key: string]: string};
    /**
     * Timestamp when this IP Table Rule was deleted
     */
    deletedAt: string;
    /**
     * User who deleted this IP Table Rule
     */
    deletedBy: {[key: string]: string};
    /**
     * Description of the IP Tables Rules
     */
    description?: string;
    /**
     * Enabled flag. Determines whether this IP Tables Rule is enabled or not
     */
    enabled: boolean;
    /**
     * URI of the Ip Tables Rules
     */
    href: string;
    /**
     * IP version for the rules to be applied to. Allowed values are "4" and "6"
     */
    ipVersion: string;
    /**
     * statements for this IP Tables Rule
     */
    statements: outputs.RuleSetIpTablesRuleStatement[];
    /**
     * Type of update for IP Table Rule
     */
    updateType: string;
    /**
     * Timestamp when this IP Table Rule was last updated
     */
    updatedAt: string;
    /**
     * User who last updated this IP Table Rule
     */
    updatedBy: {[key: string]: string};
}

export interface RuleSetIpTablesRuleActor {
    /**
     * Set this if rule actors are all workloads. Allowed value is "ams"
     */
    actors?: string;
    /**
     * Href of Label
     */
    label?: outputs.RuleSetIpTablesRuleActorLabel;
    /**
     * Href of Label Group
     */
    labelGroup?: outputs.RuleSetIpTablesRuleActorLabelGroup;
    /**
     * Href of Workload
     */
    workload?: outputs.RuleSetIpTablesRuleActorWorkload;
}

export interface RuleSetIpTablesRuleActorLabel {
    /**
     * Label URI
     */
    href: string;
    /**
     * Label key
     */
    key: string;
    /**
     * Label value
     */
    value: string;
}

export interface RuleSetIpTablesRuleActorLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface RuleSetIpTablesRuleActorWorkload {
    /**
     * URI of Workload
     */
    href: string;
}

export interface RuleSetIpTablesRuleStatement {
    /**
     * Chain name for statement. Allowed values are "PREROUTING", "INPUT" and "OUTPUT"
     */
    chainName: string;
    /**
     * Parameters of statements
     */
    parameters: string;
    /**
     * Name of the table. Allowed values are "nat", "mangle" and "filter"
     */
    tableName: string;
}

export interface RuleSetScope {
    /**
     * Boolean to specify whether or not the scope is an exclusion
     */
    exclusion?: boolean;
    /**
     * Href of Label Group
     */
    labelGroups?: outputs.RuleSetScopeLabelGroup[];
    /**
     * Href of Label
     */
    labels?: outputs.RuleSetScopeLabel[];
}

export interface RuleSetScopeLabel {
    /**
     * Label URI
     */
    href: string;
    /**
     * Label key
     */
    key: string;
    /**
     * Label value
     */
    value: string;
}

export interface RuleSetScopeLabelGroup {
    /**
     * Label Group URI
     */
    href: string;
    /**
     * Label Group key
     */
    key: string;
    /**
     * Label Group name
     */
    name: string;
}

export interface SecurityRuleConsumer {
    /**
     * Consumer workloads filter. Allowed values are "ams" and "container_host"
     */
    actors?: string;
    /**
     * Boolean to specify whether or not the actor is an exclusion - only for labels and label groups. Requires PCE v22.5+
     */
    exclusion?: boolean;
    /**
     * IP List consumer filter
     */
    ipList?: outputs.SecurityRuleConsumerIpList;
    /**
     * Label consumer filter
     */
    label?: outputs.SecurityRuleConsumerLabel;
    /**
     * Label Group consumer filter
     */
    labelGroup?: outputs.SecurityRuleConsumerLabelGroup;
    /**
     * Virtual Service consumer filter
     */
    virtualService?: outputs.SecurityRuleConsumerVirtualService;
    /**
     * Workload consumer filter
     */
    workload?: outputs.SecurityRuleConsumerWorkload;
}

export interface SecurityRuleConsumerIpList {
    /**
     * Timestamp when this IP List was first created
     */
    createdAt: string;
    /**
     * User who created this IP List
     */
    createdBy: {[key: string]: string};
    /**
     * Timestamp when this IP List was deleted
     */
    deletedAt: string;
    /**
     * User who deleted this IP List
     */
    deletedBy: {[key: string]: string};
    /**
     * Description of the IP List
     */
    description: string;
    /**
     * A unique identifier within the external data source
     */
    externalDataReference: string;
    /**
     * The data source from which a resource originates
     */
    externalDataSet: string;
    /**
     * Collection of Fully Qualified Domain Names
     */
    fqdns: outputs.SecurityRuleConsumerIpListFqdn[];
    /**
     * URI of this IP List
     */
    href: string;
    /**
     * IP addresses or ranges
     */
    ipRanges: outputs.SecurityRuleConsumerIpListIpRange[];
    /**
     * Name of the IP List
     */
    name: string;
    /**
     * Timestamp when this IP List was last updated
     */
    updatedAt: string;
    /**
     * User who last updated this IP List
     */
    updatedBy: {[key: string]: string};
}

export interface SecurityRuleConsumerIpListFqdn {
    description: string;
    fqdn: string;
}

export interface SecurityRuleConsumerIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface SecurityRuleConsumerLabel {
    /**
     * Label URI
     */
    href: string;
    /**
     * Label key
     */
    key: string;
    /**
     * Label value
     */
    value: string;
}

export interface SecurityRuleConsumerLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface SecurityRuleConsumerVirtualService {
    /**
     * URI of Virtual Service
     */
    href: string;
}

export interface SecurityRuleConsumerWorkload {
    /**
     * Whether the workload has been deleted in the PCE
     */
    deleted: boolean;
    /**
     * Workload hostname
     */
    hostname: string;
    /**
     * Workload URI
     */
    href: string;
    /**
     * Workload name
     */
    name: string;
}

export interface SecurityRuleIngressService {
    /**
     * URI of Service
     */
    href?: string;
    /**
     * Port number used with protocol or starting port when specifying a range. Allowed range is 0-65535
     */
    port?: string;
    /**
     * Protocol number. Allowed values are 6 (TCP) and 17 (UDP)
     */
    proto?: string;
    /**
     * Upper end of port range. Allowed range is 0-65535
     */
    toPort?: string;
}

export interface SecurityRuleProvider {
    /**
     * All workloads provider filter. If specified, must have value "ams"
     */
    actors?: string;
    /**
     * Boolean to specify whether or not the actor is an exclusion - only for labels and label groups. Requires PCE v22.5+
     */
    exclusion?: boolean;
    /**
     * IP List provider filter
     */
    ipList?: outputs.SecurityRuleProviderIpList;
    /**
     * Label provider filter
     */
    label?: outputs.SecurityRuleProviderLabel;
    /**
     * Label Group provider filter
     */
    labelGroup?: outputs.SecurityRuleProviderLabelGroup;
    /**
     * Virtual Server provider filter
     */
    virtualServer?: outputs.SecurityRuleProviderVirtualServer;
    /**
     * Virtual Service provider filter
     */
    virtualService?: outputs.SecurityRuleProviderVirtualService;
    /**
     * Workload provider filter
     */
    workload?: outputs.SecurityRuleProviderWorkload;
}

export interface SecurityRuleProviderIpList {
    /**
     * Timestamp when this IP List was first created
     */
    createdAt: string;
    /**
     * User who created this IP List
     */
    createdBy: {[key: string]: string};
    /**
     * Timestamp when this IP List was deleted
     */
    deletedAt: string;
    /**
     * User who deleted this IP List
     */
    deletedBy: {[key: string]: string};
    /**
     * Description of the IP List
     */
    description: string;
    /**
     * A unique identifier within the external data source
     */
    externalDataReference: string;
    /**
     * The data source from which a resource originates
     */
    externalDataSet: string;
    /**
     * Collection of Fully Qualified Domain Names
     */
    fqdns: outputs.SecurityRuleProviderIpListFqdn[];
    /**
     * URI of this IP List
     */
    href: string;
    /**
     * IP addresses or ranges
     */
    ipRanges: outputs.SecurityRuleProviderIpListIpRange[];
    /**
     * Name of the IP List
     */
    name: string;
    /**
     * Timestamp when this IP List was last updated
     */
    updatedAt: string;
    /**
     * User who last updated this IP List
     */
    updatedBy: {[key: string]: string};
}

export interface SecurityRuleProviderIpListFqdn {
    description: string;
    fqdn: string;
}

export interface SecurityRuleProviderIpListIpRange {
    description: string;
    exclusion: boolean;
    fromIp: string;
    toIp: string;
}

export interface SecurityRuleProviderLabel {
    /**
     * Label URI
     */
    href: string;
    /**
     * Label key
     */
    key: string;
    /**
     * Label value
     */
    value: string;
}

export interface SecurityRuleProviderLabelGroup {
    /**
     * URI of Label Group
     */
    href: string;
}

export interface SecurityRuleProviderVirtualServer {
    /**
     * URI of Virtual Server
     */
    href: string;
}

export interface SecurityRuleProviderVirtualService {
    /**
     * Virtual Service URI
     */
    href: string;
    /**
     * Virtual Service name
     */
    name: string;
}

export interface SecurityRuleProviderWorkload {
    /**
     * Whether the workload has been deleted in the PCE
     */
    deleted: boolean;
    /**
     * Workload hostname
     */
    hostname: string;
    /**
     * Workload URI
     */
    href: string;
    /**
     * Workload name
     */
    name: string;
}

export interface SecurityRuleResolveLabelsAs {
    /**
     * consumers for resolve_labels_as. Allowed values are "workloads", "virtual_services"
     */
    consumers: string[];
    /**
     * providers for resolve_labels_as. Allowed values are "workloads", "virtual_services"
     */
    providers: string[];
}

export interface ServiceBindingContainerWorkload {
    /**
     * Container Workload URI
     */
    href: string;
}

export interface ServiceBindingPortOverride {
    /**
     * Overriding port number (or starting point when specifying a range). Allowed range is 0 - 65535
     */
    newPort: number;
    /**
     * Overriding port range ending port. Allowed range is 0 - 65535
     */
    newToPort?: number;
    /**
     * Port Number in the original service which to override (integer 0-65535). Starting port when specifying a range
     */
    port?: number;
    /**
     * Transport protocol in the original service which to override. Allowed values are 6 (TCP) and 17 (UDP)
     */
    proto?: number;
}

export interface ServiceBindingVirtualService {
    /**
     * Virtual Service URI
     */
    href: string;
}

export interface ServiceBindingWorkload {
    /**
     * Determines whether the workload is deleted
     */
    deleted: boolean;
    /**
     * Workload Hostname
     */
    hostname: string;
    /**
     * Workload URI
     */
    href: string;
    /**
     * Workload Name
     */
    name: string;
}

export interface ServiceServicePort {
    /**
     * ICMP Code. Allowed when proto is 1 (ICMP) or 58 (ICMPv6). Allowed range is 0 - 15
     */
    icmpCode?: string;
    /**
     * ICMP Type. Allowed when proto is 1 (ICMP) or 58 (ICMPv6). Allowed range is 0 - 255
     */
    icmpType?: string;
    /**
     * Port Number. Also, the starting port when specifying a range. Allowed when value of proto is 6 or 17. Allowed range is 0 - 65535
     */
    port?: string;
    /**
     * Transport protocol. IANA protocol numbers between 0-255 are permitted, and -1 represents all services
     */
    proto: string;
    /**
     * High end of port range if specifying a range. Allowed range is 0 - 65535
     */
    toPort?: string;
}

export interface ServiceWindowsEgressService {
    /**
     * Name of running process
     */
    processName?: string;
    /**
     * Name of Windows Service
     */
    serviceName?: string;
}

export interface ServiceWindowsService {
    /**
     * ICMP Code. Allowed when proto is 1 (ICMP) or 58 (ICMPv6). Allowed range 0 - 15
     */
    icmpCode?: string;
    /**
     * ICMP Type. Allowed when proto is 1 (ICMP) or 58 (ICMPv6). Allowed range is 0 - 255
     */
    icmpType?: string;
    /**
     * Port Number. Also, the starting port when specifying a range. Allowed when value of proto is 6 or 17. Allowed range is 0 - 65535
     */
    port?: string;
    /**
     * Name of running process
     */
    processName?: string;
    /**
     * Transport protocol. IANA protocol numbers between 0-255 are permitted, and -1 represents all services.
     */
    proto?: string;
    /**
     * Name of Windows Service
     */
    serviceName?: string;
    /**
     * High end of port range if specifying a range. Allowed range is 0 - 65535
     */
    toPort?: string;
}

export interface SyslogDestinationAuditEventLogger {
    /**
     * Configuration (Northbound) auditable events
     */
    configurationEventIncluded: boolean;
    /**
     * Minimum severity level of audit event messages. Allowed values are "error", "warning" and "informational"
     */
    minSeverity: string;
    /**
     * System (PCE) auditable events
     */
    systemEventIncluded: boolean;
}

export interface SyslogDestinationNodeStatusLogger {
    /**
     * Syslog messages regarding status of the nodes
     */
    nodeStatusIncluded: boolean;
}

export interface SyslogDestinationRemoteSyslog {
    /**
     * The remote syslog IP or DNS address
     */
    address: string;
    /**
     * The remote syslog port
     */
    port: number;
    /**
     * The protocol for streaming syslog messages. Allowed values are 6 and 17
     */
    protocol: number;
    /**
     * Trustee CA bundle
     */
    tlsCaBundle?: string;
    /**
     * To enable TLS
     */
    tlsEnabled: boolean;
    /**
     * Perform TLS verification
     */
    tlsVerifyCert: boolean;
}

export interface SyslogDestinationTrafficEventLogger {
    /**
     * Set to enable traffic flow events
     */
    trafficFlowAllowedEventIncluded: boolean;
    /**
     * Set to enable traffic flow events
     */
    trafficFlowBlockedEventIncluded: boolean;
    /**
     * Set to enable traffic flow events
     */
    trafficFlowPotentiallyBlockedEventIncluded: boolean;
}

export interface TrafficCollectorSettingsTarget {
    /**
     * single IP address or CIDR. Default value: "0.0.0.0/0"
     */
    dstIp?: string;
    /**
     * destination port for target. Allowed range is -1 to 65535. Default value: -1
     */
    dstPort?: number;
    /**
     * protocol for target. Allowed values are 6 (TCP), 17 (UDP), 1 (ICMP) and 58 (ICMPv6)
     */
    proto: number;
}

export interface UnmanagedWorkloadContainerCluster {
    href: string;
    name: string;
}

export interface UnmanagedWorkloadDetectedVulnerability {
    ipAddress: string;
    port: number;
    portExposure: number;
    portWideExposures: outputs.UnmanagedWorkloadDetectedVulnerabilityPortWideExposure[];
    proto: number;
    vulnerabilities: outputs.UnmanagedWorkloadDetectedVulnerabilityVulnerability[];
    vulnerabilityReports: outputs.UnmanagedWorkloadDetectedVulnerabilityVulnerabilityReport[];
    workloads: outputs.UnmanagedWorkloadDetectedVulnerabilityWorkload[];
}

export interface UnmanagedWorkloadDetectedVulnerabilityPortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface UnmanagedWorkloadDetectedVulnerabilityVulnerability {
    href: string;
    name: string;
    score: number;
}

export interface UnmanagedWorkloadDetectedVulnerabilityVulnerabilityReport {
    href: string;
}

export interface UnmanagedWorkloadDetectedVulnerabilityWorkload {
    href: string;
}

export interface UnmanagedWorkloadFirewallCoexistence {
    illumioPrimary: boolean;
}

export interface UnmanagedWorkloadInterface {
    /**
     * Interface IP address. Must be in IPv4 or IPv6 format
     */
    address: string;
    /**
     * Interface CIDR block bits
     */
    cidrBlock?: number;
    /**
     * Interface Default Gateway IP address. Must be in IPv4 or IPv6 format
     */
    defaultGatewayAddress?: string;
    /**
     * User-friendly interface name. Can be up to 255 characters
     */
    friendlyName?: string;
    /**
     * Interface link state. Allowed values are "up", "down", and "unknown"
     */
    linkState?: string;
    /**
     * Whether or not the interface represents a loopback address on the workload
     */
    loopback: boolean;
    /**
     * Interface name. Can be up to 255 characters
     */
    name: string;
    /**
     * Interface Network HREFs
     */
    network: {[key: string]: string};
    /**
     * Interface Network Detection Mode
     */
    networkDetectionMode: string;
}

export interface UnmanagedWorkloadLabel {
    /**
     * URI of label
     */
    href: string;
    /**
     * Workload Label key
     */
    key: string;
    /**
     * Workload Label value
     */
    value: string;
}

export interface UnmanagedWorkloadSelectivelyEnforcedService {
    href: string;
    port: number;
    proto: number;
    toPort: number;
}

export interface UnmanagedWorkloadService {
    createdAt: string;
    openServicePorts: outputs.UnmanagedWorkloadServiceOpenServicePort[];
    uptimeSeconds: number;
}

export interface UnmanagedWorkloadServiceOpenServicePort {
    address: string;
    package: string;
    port: number;
    processName: string;
    protocol: number;
    user: string;
    winServiceName: string;
}

export interface UnmanagedWorkloadVulnerabilitiesSummary {
    maxVulnerabilityScore: number;
    numVulnerabilities: number;
    vulnerabilityExposureScore: number;
    vulnerabilityScore: number;
    vulnerablePortExposure: number;
    vulnerablePortWideExposures: outputs.UnmanagedWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure[];
}

export interface UnmanagedWorkloadVulnerabilitiesSummaryVulnerablePortWideExposure {
    any: boolean;
    ipList: boolean;
}

export interface VenCondition {
    firstReportedTimestamp: string;
    latestEvents: outputs.VenConditionLatestEvent[];
}

export interface VenConditionLatestEvent {
    href: string;
    infos: outputs.VenConditionLatestEventInfo[];
    notificationType: string;
    severity: string;
    timestamp: string;
}

export interface VenConditionLatestEventInfo {
    agent: {[key: string]: string};
}

export interface VenContainerCluster {
    href: string;
    name: string;
}

export interface VenInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    href: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface VenLabel {
    href: string;
    key: string;
    value: string;
}

export interface VenSecureConnect {
    matchingIssuerName: string;
}

export interface VenWorkload {
    enforcementMode: string;
    hostname: string;
    href: string;
    interfaces: outputs.VenWorkloadInterface[];
    labels: outputs.VenWorkloadLabel[];
    mode: string;
    name: string;
    online: boolean;
    osDetail: string;
    osId: string;
    publicIp: string;
    securityPolicyAppliedAt: string;
    securityPolicyReceivedAt: string;
    visibilityLevel: string;
}

export interface VenWorkloadInterface {
    address: string;
    cidrBlock: number;
    defaultGatewayAddress: string;
    friendlyName: string;
    linkState: string;
    loopback: boolean;
    name: string;
    network: {[key: string]: string};
    networkDetectionMode: string;
}

export interface VenWorkloadLabel {
    href: string;
    key: string;
    value: string;
}

export interface VirtualServiceLabel {
    /**
     * URI of label
     */
    href: string;
    /**
     * Key in key-value pair
     */
    key: string;
    /**
     * Value in key-value pair
     */
    value: string;
}

export interface VirtualServiceService {
    /**
     * URI of associated service
     */
    href: string;
}

export interface VirtualServiceServiceAddress {
    /**
     * Description for given fqdn
     */
    description?: string;
    /**
     * FQDN to assign to the virtual service.  Allowed formats: hostname, IP, or URI
     */
    fqdn?: string;
    /**
     * IP address to assign to the virtual service
     */
    ip?: string;
    /**
     * Network URI for this IP address
     */
    network?: outputs.VirtualServiceServiceAddressNetwork;
    /**
     * Port number of the service. Allowed range is -1 - 65535
     */
    port?: string;
}

export interface VirtualServiceServiceAddressNetwork {
    /**
     * URI of associated service
     */
    href: string;
}

export interface VirtualServiceServicePort {
    /**
     * Port Number. Also, the starting port when specifying a range. Allowed range is -1 - 65535
     */
    port?: string;
    /**
     * Transport protocol. Allowed values are 6 (TCP) and 17 (UDP)
     */
    proto: string;
    /**
     * High end of port range inclusive if specifying a range. Allowed range is 0 - 65535
     */
    toPort?: string;
}

export interface VulnerabilitiesVulnerability {
    /**
     * The cve_ids for the vulnerability
     */
    cveIds?: string[];
    /**
     * An arbitrary field to store some details of the vulnerability class
     */
    description?: string;
    /**
     * The title/name of the vulnerability
     */
    name: string;
    /**
     * reference id of vulnerability
     */
    referenceId: string;
    /**
     * The normalized score of the vulnerability within the range of 0 to 100. CVSS Score can be used here with a 10x multiplier
     */
    score: number;
}

export interface VulnerabilityReportDetectedVulnerability {
    /**
     * external data reference json string for vulnerability
     */
    externalDataReference?: string;
    /**
     * The IP address of the host where the vulnerability is found. IPv4 or IPv6
     */
    ipAddress: string;
    /**
     * The port that is associated with the vulnerability
     */
    port?: string;
    /**
     * The protocol that is associated with the vulnerability
     */
    proto?: string;
    /**
     * Detected vulnerability state. Allowed values are "active", and "fixed". Default value: "active"
     */
    state?: string;
    /**
     * The Href of the vulnerability class to which this vulnerability belongs
     */
    vulnerability: outputs.VulnerabilityReportDetectedVulnerabilityVulnerability;
    /**
     * The Href of the workload to which this vulnerability belongs
     */
    workload: outputs.VulnerabilityReportDetectedVulnerabilityWorkload;
}

export interface VulnerabilityReportDetectedVulnerabilityVulnerability {
    /**
     * URI of Vulnerability
     */
    href: string;
}

export interface VulnerabilityReportDetectedVulnerabilityWorkload {
    /**
     * URI of Workload
     */
    href: string;
}

export interface WorkloadSettingsWorkloadDisconnectedTimeoutSecond {
    /**
     * Assigned labels for Workload Disconnected Timeout Seconds
     */
    scopes?: outputs.WorkloadSettingsWorkloadDisconnectedTimeoutSecondScope[];
    /**
     * Property value associated with the scope. Allowed range is 300 - 2147483647 or -1
     */
    value: number;
    /**
     * The VEN type that this property is applicable to. Must be "server" or "endpoint". An empty or missing value will default to "server" on the PCE
     */
    venType: string;
}

export interface WorkloadSettingsWorkloadDisconnectedTimeoutSecondScope {
    /**
     * Label URI
     */
    href?: string;
}

export interface WorkloadSettingsWorkloadGoodbyeTimeoutSecond {
    /**
     * Assigned labels for Workload Goodbye Timeout Seconds
     */
    scopes?: outputs.WorkloadSettingsWorkloadGoodbyeTimeoutSecondScope[];
    /**
     * Property value associated with the scope. Allowed range is 300 - 2147483647 or -1
     */
    value: number;
    /**
     * The VEN type that this property is applicable to. Must be "server" or "endpoint". An empty or missing value will default to "server" on the PCE
     */
    venType: string;
}

export interface WorkloadSettingsWorkloadGoodbyeTimeoutSecondScope {
    /**
     * Label URI
     */
    href?: string;
}

