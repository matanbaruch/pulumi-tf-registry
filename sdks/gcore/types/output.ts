// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AiClusterInterface {
    /**
     * Network ID
     */
    networkId: string;
    /**
     * Network ID the subnet belongs to. Port will be plugged in this network
     */
    portId?: string;
    /**
     * Port is assigned to IP address from the subnet
     */
    subnetId?: string;
    /**
     * Network type
     */
    type?: string;
}

export interface AiClusterPoplarServer {
    addresses: outputs.AiClusterPoplarServerAddress[];
    creatorTaskId: string;
    flavor: {[key: string]: string};
    flavorId: string;
    instanceCreated: string;
    instanceDescription: string;
    instanceId: string;
    instanceName: string;
    metadata: {[key: string]: string};
    securityGroups: outputs.AiClusterPoplarServerSecurityGroup[];
    status: string;
    taskId: string;
    taskState: string;
    vmState: string;
    volumes: outputs.AiClusterPoplarServerVolume[];
}

export interface AiClusterPoplarServerAddress {
    addresses: outputs.AiClusterPoplarServerAddressAddress[];
    networkName: string;
}

export interface AiClusterPoplarServerAddressAddress {
    addr: string;
    type: string;
}

export interface AiClusterPoplarServerSecurityGroup {
    name: string;
}

export interface AiClusterPoplarServerVolume {
    deleteOnTermination: boolean;
    id: string;
}

export interface AiClusterSecurityGroup {
    /**
     * Security group ID
     */
    id: string;
}

export interface AiClusterVolume {
    /**
     * Attachment list
     */
    attachments?: outputs.AiClusterVolumeAttachment[];
    /**
     * Datetime when the volume was created
     */
    createdAt: string;
    /**
     * Task that created this entity
     */
    creatorTaskId: string;
    /**
     * Volume ID. Mandatory if volume is pre-existing volume
     */
    imageId?: string;
    /**
     * Volume name
     */
    name: string;
    /**
     * Volume size, GiB
     */
    size: number;
    /**
     * Currently available only value
     */
    source: string;
    /**
     * Volume status
     */
    status: string;
    /**
     * Datetime when the volume was last updated
     */
    updatedAt: string;
    /**
     * Volume ID
     */
    volumeId: string;
    /**
     * Image information for volumes that were created from image
     */
    volumeImageMetadata: {[key: string]: string};
    /**
     * Volume type
     */
    volumeType: string;
}

export interface AiClusterVolumeAttachment {
    /**
     * Attachment creation datetime
     */
    attachedAt: string;
    /**
     * ID of attachment object
     */
    attachmentId: string;
    /**
     * Block device name in guest
     */
    device: string;
    /**
     * Instance name (if attached and server name is known)
     */
    instanceName: string;
    /**
     * Instance ID
     */
    serverId: string;
    /**
     * Volume ID
     */
    volumeId: string;
}

export interface BaremetalAddress {
    nets: outputs.BaremetalAddressNet[];
}

export interface BaremetalAddressNet {
    addr: string;
    type: string;
}

export interface BaremetalInterface {
    existingFipId?: string;
    fipSource?: string;
    ipAddress: string;
    /**
     * If not set will be calculated after creation. Trunk interface always attached first. Can't detach interface if is_parent true. Fields affect only on creation
     */
    isParent: boolean;
    /**
     * required if type is 'subnet' or 'any_subnet'
     */
    networkId: string;
    /**
     * Order of attaching interface. Trunk interface always attached first, fields affect only on creation
     */
    order?: number;
    /**
     * required if type is  'reserved_fixed_ip'
     */
    portId: string;
    /**
     * required if type is 'subnet'
     */
    subnetId: string;
    /**
     * Available value is 'subnet', 'any_subnet', 'external', 'reserved_fixed_ip'
     */
    type: string;
}

export interface BaremetalMetadata {
    key: string;
    value: string;
}

export interface BaremetalTimeouts {
    create?: string;
}

export interface CdnOrigingroupOrigin {
    /**
     * true — The option is active. The origin will not be used until one of active origins become unavailable. false — The option is disabled.
     */
    backup: boolean;
    /**
     * The setting allows to enable or disable an Origin source in the Origins group
     */
    enabled: boolean;
    /**
     * IP address or Domain name of your origin and the port if custom
     */
    source: string;
}

export interface CdnResourceOptions {
    /**
     * Specify allowed HTTP methods.
     */
    allowedHttpMethods?: outputs.CdnResourceOptionsAllowedHttpMethods;
    /**
     * Brotli compression option allows to compress content with brotli on the CDN's end. CDN servers will request only uncompressed content from the origin.
     */
    brotliCompression?: outputs.CdnResourceOptionsBrotliCompression;
    /**
     * Specify the cache expiration time for customers' browsers in seconds.
     */
    browserCacheSettings?: outputs.CdnResourceOptionsBrowserCacheSettings;
    /**
     * Legacy option. Use the response_headers_hiding_policy option instead.
     */
    cacheHttpHeaders?: outputs.CdnResourceOptionsCacheHttpHeaders;
    /**
     * CORS header support option adds the Access-Control-Allow-Origin header to responses from CDN servers.
     */
    cors?: outputs.CdnResourceOptionsCors;
    /**
     * Country access policy enables control access to content for specified countries.
     */
    countryAcl?: outputs.CdnResourceOptionsCountryAcl;
    /**
     * Option enables browser caching. When enabled, content caching is completely disabled.
     */
    disableCache?: outputs.CdnResourceOptionsDisableCache;
    /**
     * The option allows getting 206 responses regardless settings of an origin source. Enabled by default.
     */
    disableProxyForceRanges?: outputs.CdnResourceOptionsDisableProxyForceRanges;
    /**
     * The cache expiration time for CDN servers.
     */
    edgeCacheSettings?: outputs.CdnResourceOptionsEdgeCacheSettings;
    /**
     * Allows to configure FastEdge app to be called on different request/response phases.
     */
    fastedge?: outputs.CdnResourceOptionsFastedge;
    /**
     * Option allows to enable fetch compressed. CDN request and cache already compressed content. Your server should support compression. CDN servers will not ungzip your content even if a user's browser doesn't accept compression (nowadays almost all browsers support it).
     */
    fetchCompressed?: outputs.CdnResourceOptionsFetchCompressed;
    /**
     * Enable redirection from origin. If the origin server returns a redirect, the option allows the CDN to pull the requested content from the origin server that was returned in the redirect.
     */
    followOriginRedirect?: outputs.CdnResourceOptionsFollowOriginRedirect;
    /**
     * Allows to apply custom HTTP code to the CDN content. Specify HTTP-code you need and text or URL if you are going to set up redirect.
     */
    forceReturn?: outputs.CdnResourceOptionsForceReturn;
    /**
     * When a CDN requests content from an origin server, the option allows to forward the Host header used in the request made to a CDN.
     */
    forwardHostHeader?: outputs.CdnResourceOptionsForwardHostHeader;
    /**
     * GZip compression option allows to compress content with gzip on the CDN`s end. CDN servers will request only uncompressed content from the origin.
     */
    gzipOn?: outputs.CdnResourceOptionsGzipOn;
    /**
     * Option allows to set Host header that CDN servers use when request content from an origin server. Your server must be able to process requests with the chosen header. If the option is NULL, Host Header value is taken from the parent CDN resource's value.
     */
    hostHeader?: outputs.CdnResourceOptionsHostHeader;
    /**
     * Use HTTP/3 protocol for content delivery if supported by the end users browser.
     */
    http3Enabled?: outputs.CdnResourceOptionsHttp3Enabled;
    /**
     * By default, files pulled from an origin source with cookies are not cached in a CDN. Enable this option to cache such objects.
     */
    ignoreCookie?: outputs.CdnResourceOptionsIgnoreCookie;
    /**
     * Ignore query string option determines how files with different query strings will be cached: either as one object (option is enabled) or as different objects (option is disabled).
     */
    ignoreQueryString?: outputs.CdnResourceOptionsIgnoreQueryString;
    /**
     * Image stack option allows transforming JPG and PNG images (such as resizing or cropping) and automatically converting them to WebP or AVIF format. It is a paid option.
     */
    imageStack?: outputs.CdnResourceOptionsImageStack;
    /**
     * IP access policy option allows to control access to the CDN Resource content for specific IP addresses.
     */
    ipAddressAcl?: outputs.CdnResourceOptionsIpAddressAcl;
    /**
     * The option allows to control the download speed per connection.
     */
    limitBandwidth?: outputs.CdnResourceOptionsLimitBandwidth;
    /**
     * Allows caching for GET, HEAD and POST requests.
     */
    proxyCacheMethodsSet?: outputs.CdnResourceOptionsProxyCacheMethodsSet;
    /**
     * The time limit for establishing a connection with the origin.
     */
    proxyConnectTimeout?: outputs.CdnResourceOptionsProxyConnectTimeout;
    /**
     * The time limit for receiving a partial response from the origin. If no response is received within this time, the connection will be closed.
     */
    proxyReadTimeout?: outputs.CdnResourceOptionsProxyReadTimeout;
    /**
     * Specify list of query strings. Files with those query strings will be cached as one object.
     */
    queryParamsBlacklist?: outputs.CdnResourceOptionsQueryParamsBlacklist;
    /**
     * Specify list of query strings. Files with those query strings will be cached as different objects.
     */
    queryParamsWhitelist?: outputs.CdnResourceOptionsQueryParamsWhitelist;
    /**
     * When enabled, HTTP requests are redirected to HTTPS.
     */
    redirectHttpToHttps?: outputs.CdnResourceOptionsRedirectHttpToHttps;
    /**
     * When enabled, HTTPS requests are redirected to HTTP.
     */
    redirectHttpsToHttp?: outputs.CdnResourceOptionsRedirectHttpsToHttp;
    /**
     * Referrer access policy option allows to control access to the CDN Resource content for specified domain names.
     */
    referrerAcl?: outputs.CdnResourceOptionsReferrerAcl;
    /**
     * It allows to limit the amount of HTTP requests
     */
    requestLimiter?: outputs.CdnResourceOptionsRequestLimiter;
    /**
     * Define HTTP headers (specified at an origin server) that a CDN server hides from the response.
     */
    responseHeadersHidingPolicy?: outputs.CdnResourceOptionsResponseHeadersHidingPolicy;
    /**
     * Rewrite option changes and redirects the requests from the CDN to the origin. It operates according to the Nginx configuration.
     */
    rewrite?: outputs.CdnResourceOptionsRewrite;
    /**
     * The option allows configuring an access with tokenized URLs. It makes impossible to access content without a valid (unexpired) hash key. When enabled, you need to specify a key that you use to generate a token.
     */
    secureKey?: outputs.CdnResourceOptionsSecureKey;
    /**
     * When enabled, files larger than 10 MB are requested and cached in parts (no larger than 10 MB each). It reduces time to first byte. The origin must support HTTP Range requests.
     */
    slice?: outputs.CdnResourceOptionsSlice;
    /**
     * Specify the SNI (Server Name Indication). SNI (Server Name Indication) is generally only required if your origin is using shared hosting or does not have a dedicated IP address. If the origin server presents multiple certificates, SNI allows the origin server to know which certificate to use for the connection. The option works only if originProtocol parameter is HTTPS or MATCH.
     */
    sni?: outputs.CdnResourceOptionsSni;
    /**
     * The list of errors which Always Online option is applied for.
     */
    stale?: outputs.CdnResourceOptionsStale;
    /**
     * Legacy option. Use the static_response_headers option instead.
     */
    staticHeaders?: outputs.CdnResourceOptionsStaticHeaders;
    /**
     * Specify custom HTTP Headers for a CDN server to add to request.
     */
    staticRequestHeaders?: outputs.CdnResourceOptionsStaticRequestHeaders;
    /**
     * Specify custom HTTP Headers that a CDN server adds to a response.
     */
    staticResponseHeaders?: outputs.CdnResourceOptionsStaticResponseHeaders;
    /**
     * The option specifies a list of allowed SSL/TLS protocol versions. The list cannot be empty. By default, the option is disabled (all protocols versions are allowed).
     */
    tlsVersions?: outputs.CdnResourceOptionsTlsVersions;
    /**
     * The option allows choosing a Let's Encrypt certificate chain. The specified chain will be used during the next Let's Encrypt certificate issue or renewal.
     */
    useDefaultLeChain?: outputs.CdnResourceOptionsUseDefaultLeChain;
    /**
     * The option allows choosing the RSA Let's Encrypt certificate type for the resource.
     */
    useRsaLeCert?: outputs.CdnResourceOptionsUseRsaLeCert;
    /**
     * User agents policy option allows to control access to the content for specified user-agent.
     */
    userAgentAcl?: outputs.CdnResourceOptionsUserAgentAcl;
    /**
     * Option allows to enable Basic WAF to protect you against the most common threats.
     */
    waf?: outputs.CdnResourceOptionsWaf;
    /**
     * WebSockets option allows WebSockets connections to an origin server.
     */
    websockets?: outputs.CdnResourceOptionsWebsockets;
}

export interface CdnResourceOptionsAllowedHttpMethods {
    enabled?: boolean;
    /**
     * Available methods: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS.
     */
    values: string[];
}

export interface CdnResourceOptionsBrotliCompression {
    enabled?: boolean;
    /**
     * Specify the content-type for each type of content you wish to have compressed.
     */
    values: string[];
}

export interface CdnResourceOptionsBrowserCacheSettings {
    enabled?: boolean;
    /**
     * Use '0s' to disable caching. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308.
     */
    value?: string;
}

export interface CdnResourceOptionsCacheHttpHeaders {
    enabled?: boolean;
    /**
     * List HTTP Headers that must be included in the response.
     */
    values: string[];
}

export interface CdnResourceOptionsCors {
    /**
     * Specify if the Access-Control-Allow-Origin header should be added to a response from CDN regardless of response code.
     */
    always: boolean;
    enabled?: boolean;
    /**
     * Specify a value of the Access-Control-Allow-Origin header. Possible values: '*', '$http_origin', 'example.com'.
     */
    values: string[];
}

export interface CdnResourceOptionsCountryAcl {
    enabled?: boolean;
    /**
     * List of countries according to ISO-3166-1.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnResourceOptionsDisableCache {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsDisableProxyForceRanges {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsEdgeCacheSettings {
    /**
     * Specify caching time in seconds ('0s', '600s' for example) for a response with specific response code ('304', '404' for example). Use 'any' to specify caching time for all response codes. Use '0s' to disable caching for a specific response code. These settings have a higher priority than the value field.
     */
    customValues: {[key: string]: string};
    /**
     * Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308, if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
     */
    default?: string;
    enabled?: boolean;
    /**
     * Specify caching time for the response with codes 200, 206, 301, 302. Responses with codes 4xx, 5xx will not be cached. Use '0s' to disable caching. Use custom_values field to specify a custom caching time for a response with specific codes.
     */
    value?: string;
}

export interface CdnResourceOptionsFastedge {
    enabled?: boolean;
    /**
     * Allows to configure FastEdge application that will be called to handle request headers as soon as CDN receives incoming HTTP request.
     */
    onRequestHeaders: outputs.CdnResourceOptionsFastedgeOnRequestHeaders;
}

export interface CdnResourceOptionsFastedgeOnRequestHeaders {
    /**
     * The ID of the application in FastEdge.
     */
    appId: string;
    /**
     * Determines if the FastEdge application should be called whenever HTTP request headers are received.
     */
    enabled?: boolean;
    /**
     * Determines if the request execution should be interrupted when an error occurs.
     */
    interruptOnError?: boolean;
}

export interface CdnResourceOptionsFetchCompressed {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsFollowOriginRedirect {
    /**
     * Specify the redirect status code that the origin server returns. Possible values: 301, 302, 303, 307, 308.
     */
    codes: number[];
    enabled?: boolean;
}

export interface CdnResourceOptionsForceReturn {
    /**
     * Response text or URL if you're going to set up redirection. Max length = 100.
     */
    body?: string;
    /**
     * HTTP response status code. Available codes: 100 <= value <= 599. Reserved codes: 408, 444, 477, 494, 495, 496, 497, 499
     */
    code: number;
    enabled?: boolean;
}

export interface CdnResourceOptionsForwardHostHeader {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsGzipOn {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsHostHeader {
    enabled?: boolean;
    value: string;
}

export interface CdnResourceOptionsHttp3Enabled {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsIgnoreCookie {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsIgnoreQueryString {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsImageStack {
    /**
     * If enabled, JPG and PNG images automatically convert to AVIF format when supported by the end users browser.
     */
    avifEnabled: boolean;
    enabled?: boolean;
    /**
     * Represents compression without quality loss for PNG format.
     */
    pngLossless: boolean;
    /**
     * Quality settings for JPG and PNG images. Specify a value from 1 to 100. The higher the value, the better the image quality and the larger the file size after conversion.
     */
    quality: number;
    /**
     * If enabled, JPG and PNG images automatically convert to WebP format when supported by the end users browser.
     */
    webpEnabled: boolean;
}

export interface CdnResourceOptionsIpAddressAcl {
    enabled?: boolean;
    /**
     * Specify list of IP address with a subnet mask.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnResourceOptionsLimitBandwidth {
    /**
     * Amount of downloaded data after which the user will be rate limited.
     */
    buffer: number;
    enabled?: boolean;
    /**
     * The way of controlling the download speed per each connection. Possible values are: static, dynamic.
     */
    limitType: string;
    /**
     * Maximum download speed per connection. Must be greater than 0.
     */
    speed: number;
}

export interface CdnResourceOptionsProxyCacheMethodsSet {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsProxyConnectTimeout {
    enabled?: boolean;
    /**
     * Specify time in seconds ('1s', '30s' for example).
     */
    value: string;
}

export interface CdnResourceOptionsProxyReadTimeout {
    enabled?: boolean;
    /**
     * Specify time in seconds ('1s', '30s' for example).
     */
    value: string;
}

export interface CdnResourceOptionsQueryParamsBlacklist {
    enabled?: boolean;
    values: string[];
}

export interface CdnResourceOptionsQueryParamsWhitelist {
    enabled?: boolean;
    values: string[];
}

export interface CdnResourceOptionsRedirectHttpToHttps {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsRedirectHttpsToHttp {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsReferrerAcl {
    enabled?: boolean;
    /**
     * Specify list of domain names or wildcard domains (without http:// or https://). For example, example.com or *.example.com.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnResourceOptionsRequestLimiter {
    burst: number;
    delay?: number;
    enabled?: boolean;
    rate: number;
    rateUnit?: string;
}

export interface CdnResourceOptionsResponseHeadersHidingPolicy {
    enabled?: boolean;
    /**
     * List of HTTP headers. The following required headers cannot be hidden from response: Connection, Content-Length, Content-Type, Date, Server.
     */
    excepteds: string[];
    /**
     * Specify a mode of hiding HTTP headers from the response. Possible values are: hide, show.
     */
    mode: string;
}

export interface CdnResourceOptionsRewrite {
    /**
     * The pattern for Rewrite. At least one group should be specified. For Example: /rewrite_from/(.*) /rewrite_to/$1
     */
    body: string;
    enabled?: boolean;
    /**
     * Define flag for the Rewrite option. Possible values: last, break, redirect, permanent.
     */
    flag?: string;
}

export interface CdnResourceOptionsSecureKey {
    enabled?: boolean;
    /**
     * A key generated on your side that will be used for URL signing.
     */
    key: string;
    /**
     * Specify the type of URL Signing. It can be either 0 or 2. Type 0 - includes end user's IP to secure token generation. Type 2 - excludes end user's IP from secure token generation.
     */
    type: number;
}

export interface CdnResourceOptionsSlice {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsSni {
    /**
     * Custom SNI hostname. Required if sni_type is set to 'custom'.
     */
    customHostname?: string;
    enabled?: boolean;
    /**
     * Specify SNI type. Possible values: dynamic, custom. dynamic - SNI hostname depends on the hostHeader and the forward_host_header options. custom - custom SNI hostname.
     */
    sniType?: string;
}

export interface CdnResourceOptionsStale {
    enabled?: boolean;
    /**
     * Possible values: error, http_403, http_404, http_429, http_500, http_502, http_503, http_504, invalid_header, timeout, updating.
     */
    values: string[];
}

export interface CdnResourceOptionsStaticHeaders {
    enabled?: boolean;
    value: {[key: string]: string};
}

export interface CdnResourceOptionsStaticRequestHeaders {
    enabled?: boolean;
    /**
     * Header name is restricted to 255 symbols and can contain latin letters (A-Z, a-z), numbers (0-9), dashes, and underscores. Header value is restricted to 512 symbols and can contain latin letters (a-z), numbers (0-9), spaces, underscores and symbols (-/.:). Space can be used only between words.
     */
    value: {[key: string]: string};
}

export interface CdnResourceOptionsStaticResponseHeaders {
    enabled?: boolean;
    values: outputs.CdnResourceOptionsStaticResponseHeadersValue[];
}

export interface CdnResourceOptionsStaticResponseHeadersValue {
    /**
     * Specifies if the header will be added to a response from CDN regardless of response code.
     */
    always: boolean;
    /**
     * Header name.
     */
    name: string;
    /**
     * Header value.
     */
    values: string[];
}

export interface CdnResourceOptionsTlsVersions {
    enabled?: boolean;
    /**
     * Possible values (case sensitive): SSLv3, TLSv1, TLSv1.1, TLSv1.2, TLSv1.3.
     */
    values: string[];
}

export interface CdnResourceOptionsUseDefaultLeChain {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsUseRsaLeCert {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsUserAgentAcl {
    enabled?: boolean;
    /**
     * List of User-Agents. Use "" to allow/deny access when the User-Agent header is empty.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnResourceOptionsWaf {
    enabled?: boolean;
    value: boolean;
}

export interface CdnResourceOptionsWebsockets {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptions {
    /**
     * Specify allowed HTTP methods.
     */
    allowedHttpMethods?: outputs.CdnRuleOptionsAllowedHttpMethods;
    /**
     * Brotli compression option allows to compress content with brotli on the CDN's end. CDN servers will request only uncompressed content from the origin.
     */
    brotliCompression?: outputs.CdnRuleOptionsBrotliCompression;
    /**
     * Specify the cache expiration time for customers' browsers in seconds.
     */
    browserCacheSettings?: outputs.CdnRuleOptionsBrowserCacheSettings;
    /**
     * Legacy option. Use the response_headers_hiding_policy option instead.
     */
    cacheHttpHeaders?: outputs.CdnRuleOptionsCacheHttpHeaders;
    /**
     * CORS header support option adds the Access-Control-Allow-Origin header to responses from CDN servers.
     */
    cors?: outputs.CdnRuleOptionsCors;
    /**
     * Country access policy enables control access to content for specified countries.
     */
    countryAcl?: outputs.CdnRuleOptionsCountryAcl;
    /**
     * Option enables browser caching. When enabled, content caching is completely disabled.
     */
    disableCache?: outputs.CdnRuleOptionsDisableCache;
    /**
     * The option allows getting 206 responses regardless settings of an origin source. Enabled by default.
     */
    disableProxyForceRanges?: outputs.CdnRuleOptionsDisableProxyForceRanges;
    /**
     * The cache expiration time for CDN servers.
     */
    edgeCacheSettings?: outputs.CdnRuleOptionsEdgeCacheSettings;
    /**
     * Allows to configure FastEdge app to be called on different request/response phases.
     */
    fastedge?: outputs.CdnRuleOptionsFastedge;
    /**
     * Option allows to enable fetch compressed. CDN request and cache already compressed content. Your server should support compression. CDN servers will not ungzip your content even if a user's browser doesn't accept compression (nowadays almost all browsers support it).
     */
    fetchCompressed?: outputs.CdnRuleOptionsFetchCompressed;
    /**
     * Enable redirection from origin. If the origin server returns a redirect, the option allows the CDN to pull the requested content from the origin server that was returned in the redirect.
     */
    followOriginRedirect?: outputs.CdnRuleOptionsFollowOriginRedirect;
    /**
     * Allows to apply custom HTTP code to the CDN content. Specify HTTP-code you need and text or URL if you are going to set up redirect.
     */
    forceReturn?: outputs.CdnRuleOptionsForceReturn;
    /**
     * When a CDN requests content from an origin server, the option allows to forward the Host header used in the request made to a CDN.
     */
    forwardHostHeader?: outputs.CdnRuleOptionsForwardHostHeader;
    /**
     * GZip compression option allows to compress content with gzip on the CDN`s end. CDN servers will request only uncompressed content from the origin.
     */
    gzipOn?: outputs.CdnRuleOptionsGzipOn;
    /**
     * Option allows to set Host header that CDN servers use when request content from an origin server. Your server must be able to process requests with the chosen header. If the option is NULL, Host Header value is taken from the parent CDN resource's value.
     */
    hostHeader?: outputs.CdnRuleOptionsHostHeader;
    /**
     * By default, files pulled from an origin source with cookies are not cached in a CDN. Enable this option to cache such objects.
     */
    ignoreCookie?: outputs.CdnRuleOptionsIgnoreCookie;
    /**
     * Ignore query string option determines how files with different query strings will be cached: either as one object (option is enabled) or as different objects (option is disabled).
     */
    ignoreQueryString?: outputs.CdnRuleOptionsIgnoreQueryString;
    /**
     * Image stack option allows transforming JPG and PNG images (such as resizing or cropping) and automatically converting them to WebP or AVIF format. It is a paid option.
     */
    imageStack?: outputs.CdnRuleOptionsImageStack;
    /**
     * IP access policy option allows to control access to the CDN Resource content for specific IP addresses.
     */
    ipAddressAcl?: outputs.CdnRuleOptionsIpAddressAcl;
    /**
     * The option allows to control the download speed per connection.
     */
    limitBandwidth?: outputs.CdnRuleOptionsLimitBandwidth;
    /**
     * Allows caching for GET, HEAD and POST requests.
     */
    proxyCacheMethodsSet?: outputs.CdnRuleOptionsProxyCacheMethodsSet;
    /**
     * The time limit for establishing a connection with the origin.
     */
    proxyConnectTimeout?: outputs.CdnRuleOptionsProxyConnectTimeout;
    /**
     * The time limit for receiving a partial response from the origin. If no response is received within this time, the connection will be closed.
     */
    proxyReadTimeout?: outputs.CdnRuleOptionsProxyReadTimeout;
    /**
     * Specify list of query strings. Files with those query strings will be cached as one object.
     */
    queryParamsBlacklist?: outputs.CdnRuleOptionsQueryParamsBlacklist;
    /**
     * Specify list of query strings. Files with those query strings will be cached as different objects.
     */
    queryParamsWhitelist?: outputs.CdnRuleOptionsQueryParamsWhitelist;
    /**
     * When enabled, HTTP requests are redirected to HTTPS.
     */
    redirectHttpToHttps?: outputs.CdnRuleOptionsRedirectHttpToHttps;
    /**
     * When enabled, HTTPS requests are redirected to HTTP.
     */
    redirectHttpsToHttp?: outputs.CdnRuleOptionsRedirectHttpsToHttp;
    /**
     * Referrer access policy option allows to control access to the CDN Resource content for specified domain names.
     */
    referrerAcl?: outputs.CdnRuleOptionsReferrerAcl;
    /**
     * It allows to limit the amount of HTTP requests
     */
    requestLimiter?: outputs.CdnRuleOptionsRequestLimiter;
    /**
     * Define HTTP headers (specified at an origin server) that a CDN server hides from the response.
     */
    responseHeadersHidingPolicy?: outputs.CdnRuleOptionsResponseHeadersHidingPolicy;
    /**
     * Rewrite option changes and redirects the requests from the CDN to the origin. It operates according to the Nginx configuration.
     */
    rewrite?: outputs.CdnRuleOptionsRewrite;
    /**
     * The option allows configuring an access with tokenized URLs. It makes impossible to access content without a valid (unexpired) hash key. When enabled, you need to specify a key that you use to generate a token.
     */
    secureKey?: outputs.CdnRuleOptionsSecureKey;
    /**
     * When enabled, files larger than 10 MB are requested and cached in parts (no larger than 10 MB each). It reduces time to first byte. The origin must support HTTP Range requests.
     */
    slice?: outputs.CdnRuleOptionsSlice;
    /**
     * Specify the SNI (Server Name Indication). SNI (Server Name Indication) is generally only required if your origin is using shared hosting or does not have a dedicated IP address. If the origin server presents multiple certificates, SNI allows the origin server to know which certificate to use for the connection. The option works only if originProtocol parameter is HTTPS or MATCH.
     */
    sni?: outputs.CdnRuleOptionsSni;
    /**
     * The list of errors which Always Online option is applied for.
     */
    stale?: outputs.CdnRuleOptionsStale;
    /**
     * Legacy option. Use the static_response_headers option instead.
     */
    staticHeaders?: outputs.CdnRuleOptionsStaticHeaders;
    /**
     * Specify custom HTTP Headers for a CDN server to add to request.
     */
    staticRequestHeaders?: outputs.CdnRuleOptionsStaticRequestHeaders;
    /**
     * Specify custom HTTP Headers that a CDN server adds to a response.
     */
    staticResponseHeaders?: outputs.CdnRuleOptionsStaticResponseHeaders;
    /**
     * User agents policy option allows to control access to the content for specified user-agent.
     */
    userAgentAcl?: outputs.CdnRuleOptionsUserAgentAcl;
    /**
     * Option allows to enable Basic WAF to protect you against the most common threats.
     */
    waf?: outputs.CdnRuleOptionsWaf;
    /**
     * WebSockets option allows WebSockets connections to an origin server.
     */
    websockets?: outputs.CdnRuleOptionsWebsockets;
}

export interface CdnRuleOptionsAllowedHttpMethods {
    enabled?: boolean;
    /**
     * Available methods: GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS.
     */
    values: string[];
}

export interface CdnRuleOptionsBrotliCompression {
    enabled?: boolean;
    /**
     * Specify the content-type for each type of content you wish to have compressed.
     */
    values: string[];
}

export interface CdnRuleOptionsBrowserCacheSettings {
    enabled?: boolean;
    /**
     * Use '0s' to disable caching. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308.
     */
    value?: string;
}

export interface CdnRuleOptionsCacheHttpHeaders {
    enabled?: boolean;
    /**
     * List HTTP Headers that must be included in the response.
     */
    values: string[];
}

export interface CdnRuleOptionsCors {
    /**
     * Specify if the Access-Control-Allow-Origin header should be added to a response from CDN regardless of response code.
     */
    always: boolean;
    enabled?: boolean;
    /**
     * Specify a value of the Access-Control-Allow-Origin header. Possible values: '*', '$http_origin', 'example.com'.
     */
    values: string[];
}

export interface CdnRuleOptionsCountryAcl {
    enabled?: boolean;
    /**
     * List of countries according to ISO-3166-1.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnRuleOptionsDisableCache {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsDisableProxyForceRanges {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsEdgeCacheSettings {
    /**
     * Specify caching time in seconds ('0s', '600s' for example) for a response with specific response code ('304', '404' for example). Use 'any' to specify caching time for all response codes. Use '0s' to disable caching for a specific response code. These settings have a higher priority than the value field.
     */
    customValues: {[key: string]: string};
    /**
     * Content will be cached according to origin cache settings. The value applies for a response with codes 200, 201, 204, 206, 301, 302, 303, 304, 307, 308, if an origin server does not have caching HTTP headers. Responses with other codes will not be cached.
     */
    default?: string;
    enabled?: boolean;
    /**
     * Specify caching time for the response with codes 200, 206, 301, 302. Responses with codes 4xx, 5xx will not be cached. Use '0s' to disable caching. Use custom_values field to specify a custom caching time for a response with specific codes.
     */
    value?: string;
}

export interface CdnRuleOptionsFastedge {
    enabled?: boolean;
    /**
     * Allows to configure FastEdge application that will be called to handle request headers as soon as CDN receives incoming HTTP request.
     */
    onRequestHeaders: outputs.CdnRuleOptionsFastedgeOnRequestHeaders;
}

export interface CdnRuleOptionsFastedgeOnRequestHeaders {
    /**
     * The ID of the application in FastEdge.
     */
    appId: string;
    /**
     * Determines if the FastEdge application should be called whenever HTTP request headers are received.
     */
    enabled?: boolean;
    /**
     * Determines if the request execution should be interrupted when an error occurs.
     */
    interruptOnError?: boolean;
}

export interface CdnRuleOptionsFetchCompressed {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsFollowOriginRedirect {
    /**
     * Specify the redirect status code that the origin server returns. Possible values: 301, 302, 303, 307, 308.
     */
    codes: number[];
    enabled?: boolean;
}

export interface CdnRuleOptionsForceReturn {
    /**
     * Response text or URL if you're going to set up redirection. Max length = 100.
     */
    body?: string;
    /**
     * HTTP response status code. Available codes: 100 <= value <= 599. Reserved codes: 408, 444, 477, 494, 495, 496, 497, 499
     */
    code: number;
    enabled?: boolean;
}

export interface CdnRuleOptionsForwardHostHeader {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsGzipOn {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsHostHeader {
    enabled?: boolean;
    value: string;
}

export interface CdnRuleOptionsIgnoreCookie {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsIgnoreQueryString {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsImageStack {
    /**
     * If enabled, JPG and PNG images automatically convert to AVIF format when supported by the end users browser.
     */
    avifEnabled: boolean;
    enabled?: boolean;
    /**
     * Represents compression without quality loss for PNG format.
     */
    pngLossless: boolean;
    /**
     * Quality settings for JPG and PNG images. Specify a value from 1 to 100. The higher the value, the better the image quality and the larger the file size after conversion.
     */
    quality: number;
    /**
     * If enabled, JPG and PNG images automatically convert to WebP format when supported by the end users browser.
     */
    webpEnabled: boolean;
}

export interface CdnRuleOptionsIpAddressAcl {
    enabled?: boolean;
    /**
     * Specify list of IP address with a subnet mask.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnRuleOptionsLimitBandwidth {
    /**
     * Amount of downloaded data after which the user will be rate limited.
     */
    buffer: number;
    enabled?: boolean;
    /**
     * The way of controlling the download speed per each connection. Possible values are: static, dynamic.
     */
    limitType: string;
    /**
     * Maximum download speed per connection. Must be greater than 0.
     */
    speed: number;
}

export interface CdnRuleOptionsProxyCacheMethodsSet {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsProxyConnectTimeout {
    enabled?: boolean;
    /**
     * Specify time in seconds ('1s', '30s' for example).
     */
    value: string;
}

export interface CdnRuleOptionsProxyReadTimeout {
    enabled?: boolean;
    /**
     * Specify time in seconds ('1s', '30s' for example).
     */
    value: string;
}

export interface CdnRuleOptionsQueryParamsBlacklist {
    enabled?: boolean;
    values: string[];
}

export interface CdnRuleOptionsQueryParamsWhitelist {
    enabled?: boolean;
    values: string[];
}

export interface CdnRuleOptionsRedirectHttpToHttps {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsRedirectHttpsToHttp {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsReferrerAcl {
    enabled?: boolean;
    /**
     * Specify list of domain names or wildcard domains (without http:// or https://). For example, example.com or *.example.com.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnRuleOptionsRequestLimiter {
    burst: number;
    delay?: number;
    enabled?: boolean;
    rate: number;
    rateUnit?: string;
}

export interface CdnRuleOptionsResponseHeadersHidingPolicy {
    enabled?: boolean;
    /**
     * List of HTTP headers. The following required headers cannot be hidden from response: Connection, Content-Length, Content-Type, Date, Server.
     */
    excepteds: string[];
    /**
     * Specify a mode of hiding HTTP headers from the response. Possible values are: hide, show.
     */
    mode: string;
}

export interface CdnRuleOptionsRewrite {
    /**
     * The pattern for Rewrite. At least one group should be specified. For Example: /rewrite_from/(.*) /rewrite_to/$1
     */
    body: string;
    enabled?: boolean;
    /**
     * Define flag for the Rewrite option. Possible values: last, break, redirect, permanent.
     */
    flag?: string;
}

export interface CdnRuleOptionsSecureKey {
    enabled?: boolean;
    /**
     * A key generated on your side that will be used for URL signing.
     */
    key: string;
    /**
     * Specify the type of URL Signing. It can be either 0 or 2. Type 0 - includes end user's IP to secure token generation. Type 2 - excludes end user's IP from secure token generation.
     */
    type: number;
}

export interface CdnRuleOptionsSlice {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsSni {
    /**
     * Custom SNI hostname. Required if sni_type is set to 'custom'.
     */
    customHostname?: string;
    enabled?: boolean;
    /**
     * Specify SNI type. Possible values: dynamic, custom. dynamic - SNI hostname depends on the hostHeader and the forward_host_header options. custom - custom SNI hostname.
     */
    sniType?: string;
}

export interface CdnRuleOptionsStale {
    enabled?: boolean;
    /**
     * Possible values: error, http_403, http_404, http_429, http_500, http_502, http_503, http_504, invalid_header, timeout, updating.
     */
    values: string[];
}

export interface CdnRuleOptionsStaticHeaders {
    enabled?: boolean;
    value: {[key: string]: string};
}

export interface CdnRuleOptionsStaticRequestHeaders {
    enabled?: boolean;
    /**
     * Header name is restricted to 255 symbols and can contain latin letters (A-Z, a-z), numbers (0-9), dashes, and underscores. Header value is restricted to 512 symbols and can contain latin letters (a-z), numbers (0-9), spaces, underscores and symbols (-/.:). Space can be used only between words.
     */
    value: {[key: string]: string};
}

export interface CdnRuleOptionsStaticResponseHeaders {
    enabled?: boolean;
    values: outputs.CdnRuleOptionsStaticResponseHeadersValue[];
}

export interface CdnRuleOptionsStaticResponseHeadersValue {
    /**
     * Specifies if the header will be added to a response from CDN regardless of response code.
     */
    always: boolean;
    /**
     * Header name.
     */
    name: string;
    /**
     * Header value.
     */
    values: string[];
}

export interface CdnRuleOptionsUserAgentAcl {
    enabled?: boolean;
    /**
     * List of User-Agents. Use "" to allow/deny access when the User-Agent header is empty.
     */
    exceptedValues: string[];
    /**
     * Possible values: allow, deny.
     */
    policyType: string;
}

export interface CdnRuleOptionsWaf {
    enabled?: boolean;
    value: boolean;
}

export interface CdnRuleOptionsWebsockets {
    enabled?: boolean;
    value: boolean;
}

export interface DdosProtectionField {
    baseField: number;
    default: string;
    /**
     * Field description
     */
    description: string;
    fieldType: string;
    /**
     * Complex value. Only one of 'value' or 'field_value' must be specified.
     */
    fieldValue?: string;
    id: number;
    name: string;
    required: boolean;
    /**
     * Json schema to validate field_values
     */
    validationSchema: string;
    /**
     * Basic type value. Only one of 'value' or 'field_value' must be specified.
     */
    value?: string;
}

export interface DdosProtectionProtocol {
    port: string;
    protocols: string[];
}

export interface DnsZoneRecordFilter {
    /**
     * A DNS Zone Record filter option that describe how many records will be percolated.
     */
    limit?: number;
    /**
     * A DNS Zone Record filter option that describe possibility to return answers if no records were percolated through filter.
     */
    strict?: boolean;
    /**
     * A DNS Zone Record filter option that describe a name of filter.
     */
    type: string;
}

export interface DnsZoneRecordMeta {
    /**
     * Geodns link (domain, or cl-) of DNS Zone RRSet resource.
     */
    geodnsLink: string;
    /**
     * Failover meta (eg. {"frequency": 60,"host": "www.gcore.com","http_status_code": null,"method": "GET","port": 80,"protocol": "HTTP","regexp": "","timeout": 10,"tls": false,"url": "/"}).
     */
    healthchecks?: outputs.DnsZoneRecordMetaHealthcheck[];
}

export interface DnsZoneRecordMetaHealthcheck {
    /**
     * Command to send if protocol=TCP/UDP, maximum length: 255.
     */
    command?: string;
    /**
     * Frequency in seconds (10-3600).
     */
    frequency: number;
    /**
     * Request host/virtualhost to send if protocol=HTTP, must be empty for non-HTTP
     */
    host?: string;
    /**
     * Expected status code if protocol=HTTP, must be empty for non-HTTP.
     */
    httpStatusCode?: number;
    /**
     * HTTP Method required if protocol=HTTP, must be empty for non-HTTP.
     */
    method?: string;
    /**
     * Port to check (1-65535).
     */
    port?: number;
    /**
     * Protocol, possible value: HTTP, TCP, UDP, ICMP.
     */
    protocol: string;
    /**
     * HTTP body or response payload to check if protocol<>ICMP, must be empty for ICMP.
     */
    regexp?: string;
    /**
     * Timeout in seconds (1-10).
     */
    timeout: number;
    /**
     * TLS/HTTPS enabled if protocol=HTTP, must be empty for non-HTTP.
     */
    tls?: boolean;
    /**
     * URL path to check required if protocol=HTTP, must be empty for non-HTTP.
     */
    url?: string;
}

export interface DnsZoneRecordResourceRecord {
    /**
     * A content of DNS Zone Record resource. (TXT: 'anyString', MX: '50 mail.company.io.', CAA: '0 issue "company.org; account=12345"')
     */
    content: string;
    /**
     * Manage of public appearing of DNS Zone Record resource.
     */
    enabled?: boolean;
    meta?: outputs.DnsZoneRecordResourceRecordMeta;
}

export interface DnsZoneRecordResourceRecordMeta {
    /**
     * An asn meta (eg. 12345) of DNS Zone Record resource.
     */
    asns?: number[];
    /**
     * Set as backup record
     */
    backup?: boolean;
    /**
     * Continents meta (eg. Asia) of DNS Zone Record resource.
     */
    continents?: string[];
    /**
     * Countries ISO codes meta (eg. us) of DNS Zone Record resource.
     */
    countries?: string[];
    /**
     * Fallback meta equals true marks records which are used as a default answer (when nothing was selected by specified meta fields).
     */
    default?: boolean;
    /**
     * Computed UUID of failover healtcheck property
     */
    failover: {[key: string]: string};
    /**
     * Set as fallback record
     */
    fallback?: boolean;
    /**
     * An ip meta (eg. 127.0.0.0) of DNS Zone Record resource.
     */
    ips?: string[];
    /**
     * A latlong meta (eg. 27.988056, 86.925278) of DNS Zone Record resource.
     */
    latlongs?: number[];
    /**
     * A notes meta (eg. Miami DC) of DNS Zone Record resource.
     */
    notes?: string;
    /**
     * A weight for this record
     */
    weight?: number;
}

export interface DnsZoneRecordTimeouts {
    create?: string;
    delete?: string;
}

export interface DnsZoneTimeouts {
    create?: string;
    delete?: string;
}

export interface FaasKeyFunction {
    name: string;
    namespace: string;
}

export interface FloatingipMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetAiClusterInterface {
    networkId: string;
    portId: string;
    subnetId: string;
    type: string;
}

export interface GetAiClusterPoplarServer {
    addresses: outputs.GetAiClusterPoplarServerAddress[];
    creatorTaskId: string;
    flavor: {[key: string]: string};
    flavorId: string;
    instanceCreated: string;
    instanceDescription: string;
    instanceId: string;
    instanceName: string;
    metadata: {[key: string]: string};
    securityGroups: outputs.GetAiClusterPoplarServerSecurityGroup[];
    status: string;
    taskId: string;
    taskState: string;
    vmState: string;
    volumes: outputs.GetAiClusterPoplarServerVolume[];
}

export interface GetAiClusterPoplarServerAddress {
    addresses: outputs.GetAiClusterPoplarServerAddressAddress[];
    networkName: string;
}

export interface GetAiClusterPoplarServerAddressAddress {
    addr: string;
    type: string;
}

export interface GetAiClusterPoplarServerSecurityGroup {
    name: string;
}

export interface GetAiClusterPoplarServerVolume {
    deleteOnTermination: boolean;
    id: string;
}

export interface GetAiClusterSecurityGroup {
    id: string;
}

export interface GetAiClusterVolume {
    attachments: outputs.GetAiClusterVolumeAttachment[];
    createdAt: string;
    creatorTaskId: string;
    imageId: string;
    name: string;
    size: number;
    source: string;
    status: string;
    updatedAt: string;
    volumeId: string;
    volumeImageMetadata: {[key: string]: string};
    volumeType: string;
}

export interface GetAiClusterVolumeAttachment {
    attachedAt: string;
    attachmentId: string;
    device: string;
    instanceName: string;
    serverId: string;
    volumeId: string;
}

export interface GetDdosProfileTemplateField {
    default: string;
    description: string;
    fieldType: string;
    id: number;
    name: string;
    required: boolean;
    validationSchema: string;
}

export interface GetFaasKeyFunction {
    name: string;
    namespace: string;
}

export interface GetFloatingipMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetImageMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetInstanceAddress {
    nets: outputs.GetInstanceAddressNet[];
}

export interface GetInstanceAddressNet {
    addr: string;
    type: string;
}

export interface GetInstanceInterface {
    ipAddress: string;
    networkId: string;
    portId: string;
    subnetId: string;
}

export interface GetInstanceMetadata {
    key: string;
    value: string;
}

export interface GetInstanceSecurityGroup {
    name: string;
}

export interface GetInstanceVolume {
    deleteOnTermination: boolean;
    volumeId: string;
}

export interface GetK8sv2Authentication {
    oidcs: outputs.GetK8sv2AuthenticationOidc[];
}

export interface GetK8sv2AuthenticationOidc {
    clientId: string;
    groupsClaim: string;
    groupsPrefix: string;
    issuerUrl: string;
    requiredClaims: {[key: string]: string};
    signingAlgs: string[];
    usernameClaim: string;
    usernamePrefix: string;
}

export interface GetK8sv2Cni {
    cilia: outputs.GetK8sv2CniCilium[];
    provider: string;
}

export interface GetK8sv2CniCilium {
    encryption: boolean;
    hubbleRelay: boolean;
    hubbleUi: boolean;
    lbAcceleration: boolean;
    lbMode: string;
    maskSize: number;
    maskSizeV6: number;
    tunnel: string;
}

export interface GetK8sv2Pool {
    autoHealingEnabled: boolean;
    bootVolumeSize: number;
    bootVolumeType: string;
    createdAt: string;
    crioConfig: {[key: string]: string};
    flavorId: string;
    isPublicIpv4: boolean;
    kubeletConfig: {[key: string]: string};
    labels: {[key: string]: string};
    maxNodeCount: number;
    minNodeCount: number;
    name: string;
    nodeCount: number;
    servergroupId: string;
    servergroupName: string;
    servergroupPolicy: string;
    status: string;
    taints: {[key: string]: string};
}

export interface GetLblistenerUserList {
    /**
     * Encrypted password (hash) to auth via Basic Authentication
     */
    encryptedPassword: string;
    /**
     * Username to auth via Basic Authentication
     */
    username: string;
}

export interface GetLbpoolHealthMonitor {
    delay: number;
    expectedCodes: string;
    httpMethod: string;
    id: string;
    maxRetries: number;
    maxRetriesDown: number;
    timeout: number;
    type: string;
    urlPath: string;
}

export interface GetLbpoolSessionPersistence {
    cookieName: string;
    persistenceGranularity: string;
    persistenceTimeout: number;
    type: string;
}

export interface GetLoadbalancerListener {
    id: string;
    name: string;
    protocol: string;
    protocolPort: number;
}

export interface GetLoadbalancerMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetLoadbalancerv2MetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetLoadbalancerv2VrrpIp {
    ipAddress: string;
    subnetId: string;
}

export interface GetNetworkMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetReservedfixedipAllowedAddressPair {
    ipAddress: string;
    macAddress: string;
}

export interface GetRouterExternalGatewayInfo {
    enableSnat: boolean;
    externalFixedIps: outputs.GetRouterExternalGatewayInfoExternalFixedIp[];
    networkId: string;
}

export interface GetRouterExternalGatewayInfoExternalFixedIp {
    ipAddress: string;
    subnetId: string;
}

export interface GetRouterInterface {
    ipAddress: string;
    macAddress: string;
    networkId: string;
    portId: string;
    subnetId: string;
    type: string;
}

export interface GetRouterRoute {
    destination: string;
    nexthop: string;
}

export interface GetSecuritygroupMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetSecuritygroupSecurityGroupRule {
    createdAt: string;
    description: string;
    direction: string;
    ethertype: string;
    id: string;
    portRangeMax: number;
    portRangeMin: number;
    protocol: string;
    remoteIpPrefix: string;
    updatedAt: string;
}

export interface GetServergroupInstance {
    instanceId: string;
    instanceName: string;
}

export interface GetSubnetHostRoute {
    destination: string;
    nexthop: string;
}

export interface GetSubnetMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface GetVolumeMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface InstanceAddress {
    nets: outputs.InstanceAddressNet[];
}

export interface InstanceAddressNet {
    addr: string;
    type: string;
}

export interface InstanceConfiguration {
    key: string;
    value: string;
}

export interface InstanceInterface {
    existingFipId?: string;
    fipSource?: string;
    ipAddress: string;
    /**
     * required if type is 'subnet' or 'any_subnet'
     */
    networkId: string;
    /**
     * Order of attaching interface
     */
    order?: number;
    /**
     * required if type is  'reserved_fixed_ip'
     */
    portId: string;
    /**
     * list of security group IDs
     */
    securityGroups?: string[];
    /**
     * required if type is 'subnet'
     */
    subnetId: string;
    /**
     * Available value is 'subnet', 'any_subnet', 'external', 'reserved_fixed_ip'
     */
    type?: string;
}

export interface InstanceMetadata {
    key: string;
    value: string;
}

export interface InstanceSecurityGroup {
    id: string;
    name: string;
}

export interface InstanceVolume {
    attachmentTag?: string;
    /**
     * If boot_index==0 volumes can not detached
     */
    bootIndex?: number;
    deleteOnTermination: boolean;
    id: string;
    imageId?: string;
    name?: string;
    size: number;
    /**
     * Currently available only 'existing-volume' value
     */
    source: string;
    typeName?: string;
    volumeId?: string;
}

export interface K8sv2Authentication {
    /**
     * OpenID Connect configuration settings.
     */
    oidc?: outputs.K8sv2AuthenticationOidc;
}

export interface K8sv2AuthenticationOidc {
    /**
     * A client id that all tokens must be issued for.
     */
    clientId: string;
    /**
     * JWT claim to use as the user's group.
     */
    groupsClaim: string;
    /**
     * Prefix prepended to group claims to prevent clashes with existing names.
     */
    groupsPrefix: string;
    /**
     * URL of the provider that allows the API server to discover public signing keys. Only URLs that use the https:// scheme are accepted.
     */
    issuerUrl: string;
    /**
     * A map describing required claims in the ID Token. Each claim is verified to be present in the ID Token with a matching value.
     */
    requiredClaims: {[key: string]: string};
    /**
     * Accepted signing algorithms. Supported values are: RS256, RS384, RS512, ES256, ES384, ES512, PS256, PS384, PS512.
     */
    signingAlgs: string[];
    /**
     * JWT claim to use as the user name. When not specified, the `sub` claim will be used.
     */
    usernameClaim: string;
    /**
     * Prefix prepended to username claims to prevent clashes with existing names.
     */
    usernamePrefix: string;
}

export interface K8sv2Cni {
    /**
     * Cilium CNI configuration.
     */
    cilium?: outputs.K8sv2CniCilium;
    /**
     * CNI provider to use when creating the cluster. Supported values are: calico, cilium. The default value is calico.
     */
    provider?: string;
}

export interface K8sv2CniCilium {
    /**
     * Enables transparent network encryption. The default value is false.
     */
    encryption: boolean;
    /**
     * Enables Hubble Relay. The default value is false.
     */
    hubbleRelay: boolean;
    /**
     * Enables Hubble UI. Requires `hubble_relay=true`. The default value is false.
     */
    hubbleUi: boolean;
    /**
     * Enables load balancer acceleration via XDP. The default value is false.
     */
    lbAcceleration: boolean;
    /**
     * The operation mode of load balancing for remote backends. Supported values are snat, dsr, hybrid. The default value is snat.
     */
    lbMode: string;
    /**
     * Specifies the size allocated from pods_ip_pool CIDR to node.ipam.podCIDRs. The default value is 24.
     */
    maskSize: number;
    /**
     * Specifies the size allocated from pods_ipv6_pool CIDR to node.ipam.podCIDRs. The default value is 120.
     */
    maskSizeV6: number;
    /**
     * Tunneling protocol to use in tunneling mode and for ad-hoc tunnels. The default value is geneve.
     */
    tunnel: string;
}

export interface K8sv2Pool {
    /**
     * Enable/disable auto healing of cluster pool nodes.
     */
    autoHealingEnabled: boolean;
    /**
     * Cluster pool boot volume size. Must be set only for VM pools. Changing the value of this attribute will trigger recreation of the cluster pool.
     */
    bootVolumeSize: number;
    /**
     * Cluster pool boot volume type. Must be set only for VM pools. Available values are 'standard', 'ssd_hiiops', 'cold', 'ultra'. Changing the value of this attribute will trigger recreation of the cluster pool.
     */
    bootVolumeType: string;
    /**
     * Cluster pool creation date.
     */
    createdAt: string;
    /**
     * Crio configuration for pool nodes. Keys and values are expected to follow the crio option format.
     */
    crioConfig: {[key: string]: string};
    /**
     * Cluster pool node flavor ID. Changing the value of this attribute will trigger recreation of the cluster pool.
     */
    flavorId: string;
    /**
     * Assign public IPv4 address to nodes in this pool. Changing the value of this attribute will trigger recreation of the cluster pool.
     */
    isPublicIpv4: boolean;
    /**
     * Kubelet configuration for pool nodes. Keys and values are expected to follow the kubelet configuration file format.
     */
    kubeletConfig: {[key: string]: string};
    /**
     * Labels applied to the cluster pool nodes.
     */
    labels: {[key: string]: string};
    /**
     * Maximum number of nodes in the cluster pool.
     */
    maxNodeCount: number;
    /**
     * Minimum number of nodes in the cluster pool.
     */
    minNodeCount: number;
    /**
     * Cluster pool name. Changing the value of this attribute will trigger recreation of the cluster pool.
     */
    name: string;
    /**
     * Current node count in the cluster pool.
     */
    nodeCount: number;
    /**
     * Server group id
     */
    servergroupId: string;
    /**
     * Server group name
     */
    servergroupName: string;
    /**
     * Server group policy: anti-affinity, soft-anti-affinity or affinity
     */
    servergroupPolicy?: string;
    /**
     * Cluster pool status.
     */
    status: string;
    /**
     * Taints applied to the cluster pool nodes.
     */
    taints: {[key: string]: string};
}

export interface K8sv2Timeouts {
    create?: string;
    update?: string;
}

export interface LblistenerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LblistenerUserList {
    /**
     * Encrypted password (hash) to auth via Basic Authentication
     */
    encryptedPassword: string;
    /**
     * Username to auth via Basic Authentication
     */
    username: string;
}

export interface LbmemberTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LbpoolHealthMonitor {
    /**
     * The time, in seconds, between sending probes to members.
     */
    delay: number;
    /**
     * The list of HTTP status codes expected in response from the member to declare it healthy.
     */
    expectedCodes: string;
    /**
     * The HTTP method that the health monitor uses for requests.
     */
    httpMethod: string;
    /**
     * Health Monitor ID.
     */
    id: string;
    /**
     * The number of successful checks before changing the operating status of the member to ONLINE.
     */
    maxRetries: number;
    /**
     * The number of allowed check failures before changing the operating status of the member to ERROR.
     */
    maxRetriesDown: number;
    /**
     * The maximum time, in seconds, that a monitor waits to connect before it times out.
     */
    timeout: number;
    /**
     * Available values is 'HTTP', 'HTTPS', 'PING', 'TCP', 'TLS-HELLO', 'UDP-CONNECT
     */
    type: string;
    /**
     * The HTTP URL path of the request sent by the monitor to test the health of a backend member.
     */
    urlPath: string;
}

export interface LbpoolSessionPersistence {
    /**
     * The name of the application cookie to use for session persistence.
     */
    cookieName: string;
    /**
     * The netmask used to determine SCTP or UDP SOURCE_IP session persistence.
     */
    persistenceGranularity: string;
    /**
     * The timeout, in seconds, after which a SCTP or UDP flow may be rescheduled to a different member.
     */
    persistenceTimeout: number;
    /**
     * One of: 'APP_COOKIE' (an application supplied cookie), 'HTTP_COOKIE' (a cookie created by the load balancer), 'SOURCE_IP' (the source IP address).
     */
    type: string;
}

export interface LbpoolTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LifecyclepolicySchedule {
    /**
     * Use for taking actions at specified moments of time. Exactly one of interval and cron blocks should be provided
     */
    cron?: outputs.LifecyclepolicyScheduleCron;
    id: string;
    /**
     * Use for taking actions with equal time intervals between them. Exactly one of interval and cron blocks should be provided
     */
    interval?: outputs.LifecyclepolicyScheduleInterval;
    /**
     * Maximum number of stored resources
     */
    maxQuantity: number;
    /**
     * Used to name snapshots. {volume_id} is substituted with volume.id on creation
     */
    resourceNameTemplate?: string;
    /**
     * If it is set, new resource will be deleted after time
     */
    retentionTime?: outputs.LifecyclepolicyScheduleRetentionTime;
    type: string;
}

export interface LifecyclepolicyScheduleCron {
    /**
     * Either single asterisk or comma-separated list of integers (1-31)
     */
    day?: string;
    /**
     * Either single asterisk or comma-separated list of integers (0-6)
     */
    dayOfWeek?: string;
    /**
     * Either single asterisk or comma-separated list of integers (0-23)
     */
    hour?: string;
    /**
     * Either single asterisk or comma-separated list of integers (0-59)
     */
    minute?: string;
    /**
     * Either single asterisk or comma-separated list of integers (1-12)
     */
    month?: string;
    timezone?: string;
    /**
     * Either single asterisk or comma-separated list of integers (1-53)
     */
    week?: string;
}

export interface LifecyclepolicyScheduleInterval {
    /**
     * Number of days to wait between actions
     */
    days?: number;
    /**
     * Number of hours to wait between actions
     */
    hours?: number;
    /**
     * Number of minutes to wait between actions
     */
    minutes?: number;
    /**
     * Number of weeks to wait between actions
     */
    weeks?: number;
}

export interface LifecyclepolicyScheduleRetentionTime {
    /**
     * Number of days to wait before deleting snapshot
     */
    days?: number;
    /**
     * Number of hours to wait before deleting snapshot
     */
    hours?: number;
    /**
     * Number of minutes to wait before deleting snapshot
     */
    minutes?: number;
    /**
     * Number of weeks to wait before deleting snapshot
     */
    weeks?: number;
}

export interface LifecyclepolicyVolume {
    id: string;
    name: string;
}

export interface LoadbalancerListener {
    certificate?: string;
    certificateChain?: string;
    id: string;
    insertXForwarded?: boolean;
    name: string;
    privateKey?: string;
    /**
     * Available values are 'HTTP', 'HTTPS', 'TCP', 'UDP'
     */
    protocol: string;
    protocolPort: number;
    secretId?: string;
    sniSecretIds?: string[];
}

export interface LoadbalancerMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface LoadbalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Loadbalancerv2MetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface Loadbalancerv2Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NetworkMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface ReservedfixedipAllowedAddressPair {
    /**
     * IPv4 or IPv6 address.
     */
    ipAddress?: string;
    /**
     * MAC address.
     */
    macAddress?: string;
}

export interface RouterExternalGatewayInfo {
    enableSnat: boolean;
    externalFixedIps: outputs.RouterExternalGatewayInfoExternalFixedIp[];
    /**
     * Id of the external network
     */
    networkId: string;
    /**
     * Must be 'manual' or 'default'
     */
    type: string;
}

export interface RouterExternalGatewayInfoExternalFixedIp {
    ipAddress: string;
    subnetId: string;
}

export interface RouterInterface {
    ipAddress: string;
    macAddress: string;
    networkId: string;
    portId: string;
    /**
     * Subnet for router interface must have a gateway IP
     */
    subnetId: string;
    /**
     * must be 'subnet'
     */
    type: string;
}

export interface RouterRoute {
    destination: string;
    /**
     * IPv4 address to forward traffic to if it's destination IP matches 'destination' CIDR
     */
    nexthop: string;
}

export interface SecuritygroupMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface SecuritygroupSecurityGroupRule {
    createdAt: string;
    description?: string;
    /**
     * Available value is 'ingress', 'egress'
     */
    direction: string;
    /**
     * Available value is 'IPv4', 'IPv6'
     */
    ethertype: string;
    id: string;
    portRangeMax?: number;
    portRangeMin?: number;
    /**
     * Available value is udp,tcp,any,ipv6-icmp,ipv6-route,ipv6-opts,ipv6-nonxt,ipv6-frag,ipv6-encap,icmp,ah,dccp,egp,esp,gre,igmp,ospf,pgm,rsvp,sctp,udplite,vrrp,51,50,112,0,4,ipip,ipencap
     */
    protocol: string;
    remoteIpPrefix?: string;
    updatedAt: string;
}

export interface ServergroupInstance {
    instanceId: string;
    instanceName: string;
}

export interface SubnetHostRoute {
    /**
     * Classless Inter-Domain Routing, can be IPv4 or IPv6.
     */
    destination: string;
    /**
     * IPv4 address to forward traffic to if it's destination IP matches 'destination' CIDR
     */
    nexthop: string;
}

export interface SubnetMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

export interface SubnetTimeouts {
    create?: string;
    delete?: string;
}

export interface VolumeMetadataReadOnly {
    key: string;
    readOnly: boolean;
    value: string;
}

