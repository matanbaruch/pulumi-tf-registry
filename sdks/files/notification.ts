// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Notification extends pulumi.CustomResource {
    /**
     * Get an existing Notification resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: NotificationState, opts?: pulumi.CustomResourceOptions): Notification {
        return new Notification(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'files:index/notification:Notification';

    /**
     * Returns true if the given object is an instance of Notification.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Notification {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Notification.__pulumiType;
    }

    /**
     * ID of Group to receive notifications
     */
    public readonly groupId!: pulumi.Output<number>;
    /**
     * Group name, if a Group ID is set
     */
    public /*out*/ readonly groupName!: pulumi.Output<string>;
    /**
     * Custom message to include in notification emails
     */
    public readonly message!: pulumi.Output<string>;
    /**
     * Trigger on files copied to this path?
     */
    public readonly notifyOnCopy!: pulumi.Output<boolean>;
    /**
     * Trigger on files deleted in this path?
     */
    public readonly notifyOnDelete!: pulumi.Output<boolean>;
    /**
     * Trigger on files downloaded in this path?
     */
    public readonly notifyOnDownload!: pulumi.Output<boolean>;
    /**
     * Trigger on files moved to this path?
     */
    public readonly notifyOnMove!: pulumi.Output<boolean>;
    /**
     * Trigger on files created/uploaded/updated/changed in this path?
     */
    public readonly notifyOnUpload!: pulumi.Output<boolean>;
    /**
     * If true, will send notifications about a user's own activity to that user. If false, only activity performed by other
     * users (or anonymous users) will be sent in notifications.
     */
    public readonly notifyUserActions!: pulumi.Output<boolean>;
    /**
     * Folder path to notify on. This must be slash-delimited, but it must neither start nor end with a slash. Maximum of 5000
     * characters.
     */
    public readonly path!: pulumi.Output<string>;
    /**
     * Apply notification recursively? This will enable notifications for each subfolder.
     */
    public readonly recursive!: pulumi.Output<boolean>;
    /**
     * The time interval that notifications are aggregated to
     */
    public readonly sendInterval!: pulumi.Output<string>;
    /**
     * If true, it means that the recipient at this user's email address has manually unsubscribed from all emails, or had
     * their email "hard bounce", which means that we are unable to send mail to this user's current email address.
     * Notifications will resume if the user changes their email address.
     */
    public /*out*/ readonly suppressedEmail!: pulumi.Output<boolean>;
    /**
     * Notify when actions are performed by a share recipient?
     */
    public readonly triggerByShareRecipients!: pulumi.Output<boolean>;
    /**
     * Array of filenames (possibly with wildcards) to scope trigger
     */
    public readonly triggeringFilenames!: pulumi.Output<string[]>;
    /**
     * If set, will only notify on actions made by a member of one of the specified groups
     */
    public readonly triggeringGroupIds!: pulumi.Output<number[]>;
    /**
     * If set, will onlynotify on actions made one of the specified users
     */
    public readonly triggeringUserIds!: pulumi.Output<number[]>;
    /**
     * Is the user unsubscribed from this notification?
     */
    public /*out*/ readonly unsubscribed!: pulumi.Output<boolean>;
    /**
     * The reason that the user unsubscribed
     */
    public /*out*/ readonly unsubscribedReason!: pulumi.Output<string>;
    /**
     * Notification user ID
     */
    public readonly userId!: pulumi.Output<number>;
    /**
     * Notification username
     */
    public readonly username!: pulumi.Output<string>;

    /**
     * Create a Notification resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args?: NotificationArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: NotificationArgs | NotificationState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as NotificationState | undefined;
            resourceInputs["groupId"] = state ? state.groupId : undefined;
            resourceInputs["groupName"] = state ? state.groupName : undefined;
            resourceInputs["message"] = state ? state.message : undefined;
            resourceInputs["notifyOnCopy"] = state ? state.notifyOnCopy : undefined;
            resourceInputs["notifyOnDelete"] = state ? state.notifyOnDelete : undefined;
            resourceInputs["notifyOnDownload"] = state ? state.notifyOnDownload : undefined;
            resourceInputs["notifyOnMove"] = state ? state.notifyOnMove : undefined;
            resourceInputs["notifyOnUpload"] = state ? state.notifyOnUpload : undefined;
            resourceInputs["notifyUserActions"] = state ? state.notifyUserActions : undefined;
            resourceInputs["path"] = state ? state.path : undefined;
            resourceInputs["recursive"] = state ? state.recursive : undefined;
            resourceInputs["sendInterval"] = state ? state.sendInterval : undefined;
            resourceInputs["suppressedEmail"] = state ? state.suppressedEmail : undefined;
            resourceInputs["triggerByShareRecipients"] = state ? state.triggerByShareRecipients : undefined;
            resourceInputs["triggeringFilenames"] = state ? state.triggeringFilenames : undefined;
            resourceInputs["triggeringGroupIds"] = state ? state.triggeringGroupIds : undefined;
            resourceInputs["triggeringUserIds"] = state ? state.triggeringUserIds : undefined;
            resourceInputs["unsubscribed"] = state ? state.unsubscribed : undefined;
            resourceInputs["unsubscribedReason"] = state ? state.unsubscribedReason : undefined;
            resourceInputs["userId"] = state ? state.userId : undefined;
            resourceInputs["username"] = state ? state.username : undefined;
        } else {
            const args = argsOrState as NotificationArgs | undefined;
            resourceInputs["groupId"] = args ? args.groupId : undefined;
            resourceInputs["message"] = args ? args.message : undefined;
            resourceInputs["notifyOnCopy"] = args ? args.notifyOnCopy : undefined;
            resourceInputs["notifyOnDelete"] = args ? args.notifyOnDelete : undefined;
            resourceInputs["notifyOnDownload"] = args ? args.notifyOnDownload : undefined;
            resourceInputs["notifyOnMove"] = args ? args.notifyOnMove : undefined;
            resourceInputs["notifyOnUpload"] = args ? args.notifyOnUpload : undefined;
            resourceInputs["notifyUserActions"] = args ? args.notifyUserActions : undefined;
            resourceInputs["path"] = args ? args.path : undefined;
            resourceInputs["recursive"] = args ? args.recursive : undefined;
            resourceInputs["sendInterval"] = args ? args.sendInterval : undefined;
            resourceInputs["triggerByShareRecipients"] = args ? args.triggerByShareRecipients : undefined;
            resourceInputs["triggeringFilenames"] = args ? args.triggeringFilenames : undefined;
            resourceInputs["triggeringGroupIds"] = args ? args.triggeringGroupIds : undefined;
            resourceInputs["triggeringUserIds"] = args ? args.triggeringUserIds : undefined;
            resourceInputs["userId"] = args ? args.userId : undefined;
            resourceInputs["username"] = args ? args.username : undefined;
            resourceInputs["groupName"] = undefined /*out*/;
            resourceInputs["suppressedEmail"] = undefined /*out*/;
            resourceInputs["unsubscribed"] = undefined /*out*/;
            resourceInputs["unsubscribedReason"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Notification.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Notification resources.
 */
export interface NotificationState {
    /**
     * ID of Group to receive notifications
     */
    groupId?: pulumi.Input<number>;
    /**
     * Group name, if a Group ID is set
     */
    groupName?: pulumi.Input<string>;
    /**
     * Custom message to include in notification emails
     */
    message?: pulumi.Input<string>;
    /**
     * Trigger on files copied to this path?
     */
    notifyOnCopy?: pulumi.Input<boolean>;
    /**
     * Trigger on files deleted in this path?
     */
    notifyOnDelete?: pulumi.Input<boolean>;
    /**
     * Trigger on files downloaded in this path?
     */
    notifyOnDownload?: pulumi.Input<boolean>;
    /**
     * Trigger on files moved to this path?
     */
    notifyOnMove?: pulumi.Input<boolean>;
    /**
     * Trigger on files created/uploaded/updated/changed in this path?
     */
    notifyOnUpload?: pulumi.Input<boolean>;
    /**
     * If true, will send notifications about a user's own activity to that user. If false, only activity performed by other
     * users (or anonymous users) will be sent in notifications.
     */
    notifyUserActions?: pulumi.Input<boolean>;
    /**
     * Folder path to notify on. This must be slash-delimited, but it must neither start nor end with a slash. Maximum of 5000
     * characters.
     */
    path?: pulumi.Input<string>;
    /**
     * Apply notification recursively? This will enable notifications for each subfolder.
     */
    recursive?: pulumi.Input<boolean>;
    /**
     * The time interval that notifications are aggregated to
     */
    sendInterval?: pulumi.Input<string>;
    /**
     * If true, it means that the recipient at this user's email address has manually unsubscribed from all emails, or had
     * their email "hard bounce", which means that we are unable to send mail to this user's current email address.
     * Notifications will resume if the user changes their email address.
     */
    suppressedEmail?: pulumi.Input<boolean>;
    /**
     * Notify when actions are performed by a share recipient?
     */
    triggerByShareRecipients?: pulumi.Input<boolean>;
    /**
     * Array of filenames (possibly with wildcards) to scope trigger
     */
    triggeringFilenames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If set, will only notify on actions made by a member of one of the specified groups
     */
    triggeringGroupIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * If set, will onlynotify on actions made one of the specified users
     */
    triggeringUserIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Is the user unsubscribed from this notification?
     */
    unsubscribed?: pulumi.Input<boolean>;
    /**
     * The reason that the user unsubscribed
     */
    unsubscribedReason?: pulumi.Input<string>;
    /**
     * Notification user ID
     */
    userId?: pulumi.Input<number>;
    /**
     * Notification username
     */
    username?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Notification resource.
 */
export interface NotificationArgs {
    /**
     * ID of Group to receive notifications
     */
    groupId?: pulumi.Input<number>;
    /**
     * Custom message to include in notification emails
     */
    message?: pulumi.Input<string>;
    /**
     * Trigger on files copied to this path?
     */
    notifyOnCopy?: pulumi.Input<boolean>;
    /**
     * Trigger on files deleted in this path?
     */
    notifyOnDelete?: pulumi.Input<boolean>;
    /**
     * Trigger on files downloaded in this path?
     */
    notifyOnDownload?: pulumi.Input<boolean>;
    /**
     * Trigger on files moved to this path?
     */
    notifyOnMove?: pulumi.Input<boolean>;
    /**
     * Trigger on files created/uploaded/updated/changed in this path?
     */
    notifyOnUpload?: pulumi.Input<boolean>;
    /**
     * If true, will send notifications about a user's own activity to that user. If false, only activity performed by other
     * users (or anonymous users) will be sent in notifications.
     */
    notifyUserActions?: pulumi.Input<boolean>;
    /**
     * Folder path to notify on. This must be slash-delimited, but it must neither start nor end with a slash. Maximum of 5000
     * characters.
     */
    path?: pulumi.Input<string>;
    /**
     * Apply notification recursively? This will enable notifications for each subfolder.
     */
    recursive?: pulumi.Input<boolean>;
    /**
     * The time interval that notifications are aggregated to
     */
    sendInterval?: pulumi.Input<string>;
    /**
     * Notify when actions are performed by a share recipient?
     */
    triggerByShareRecipients?: pulumi.Input<boolean>;
    /**
     * Array of filenames (possibly with wildcards) to scope trigger
     */
    triggeringFilenames?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If set, will only notify on actions made by a member of one of the specified groups
     */
    triggeringGroupIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * If set, will onlynotify on actions made one of the specified users
     */
    triggeringUserIds?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Notification user ID
     */
    userId?: pulumi.Input<number>;
    /**
     * Notification username
     */
    username?: pulumi.Input<string>;
}
