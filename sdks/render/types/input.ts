// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BackgroundWorkerAutoscaling {
    criteria: pulumi.Input<inputs.BackgroundWorkerAutoscalingCriteria>;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * The maximum number of instances for the service
     */
    max: pulumi.Input<number>;
    /**
     * The minimum number of instances for the service
     */
    min: pulumi.Input<number>;
}

export interface BackgroundWorkerAutoscalingCriteria {
    cpu?: pulumi.Input<inputs.BackgroundWorkerAutoscalingCriteriaCpu>;
    memory?: pulumi.Input<inputs.BackgroundWorkerAutoscalingCriteriaMemory>;
}

export interface BackgroundWorkerAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface BackgroundWorkerAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface BackgroundWorkerDisk {
    /**
     * Unique identifier for the disk
     */
    id?: pulumi.Input<string>;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: pulumi.Input<string>;
    /**
     * Name of the disk
     */
    name: pulumi.Input<string>;
    /**
     * Size of the disk in GB
     */
    sizeGb: pulumi.Input<number>;
}

export interface BackgroundWorkerEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface BackgroundWorkerNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend?: pulumi.Input<string>;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled?: pulumi.Input<string>;
}

export interface BackgroundWorkerRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: pulumi.Input<inputs.BackgroundWorkerRuntimeSourceDocker>;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: pulumi.Input<inputs.BackgroundWorkerRuntimeSourceImage>;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: pulumi.Input<inputs.BackgroundWorkerRuntimeSourceNativeRuntime>;
}

export interface BackgroundWorkerRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.BackgroundWorkerRuntimeSourceDockerBuildFilter>;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context?: pulumi.Input<string>;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath?: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
}

export interface BackgroundWorkerRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface BackgroundWorkerRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest?: pulumi.Input<string>;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag?: pulumi.Input<string>;
}

export interface BackgroundWorkerRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Command to build the service
     */
    buildCommand: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.BackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: pulumi.Input<string>;
}

export interface BackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface BackgroundWorkerSecretFiles {
    /**
     * The content of the secret file.
     */
    content: pulumi.Input<string>;
}

export interface CronJobEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface CronJobNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend?: pulumi.Input<string>;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled?: pulumi.Input<string>;
}

export interface CronJobRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: pulumi.Input<inputs.CronJobRuntimeSourceDocker>;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: pulumi.Input<inputs.CronJobRuntimeSourceImage>;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: pulumi.Input<inputs.CronJobRuntimeSourceNativeRuntime>;
}

export interface CronJobRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.CronJobRuntimeSourceDockerBuildFilter>;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context?: pulumi.Input<string>;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath?: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
}

export interface CronJobRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CronJobRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest?: pulumi.Input<string>;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag?: pulumi.Input<string>;
}

export interface CronJobRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Command to build the service
     */
    buildCommand: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.CronJobRuntimeSourceNativeRuntimeBuildFilter>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: pulumi.Input<string>;
}

export interface CronJobRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface CronJobSecretFiles {
    /**
     * The content of the secret file.
     */
    content: pulumi.Input<string>;
}

export interface EnvGroupEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface EnvGroupSecretFiles {
    /**
     * The content of the secret file.
     */
    content: pulumi.Input<string>;
}

export interface GetStaticSiteCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name?: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: string;
}

export interface GetStaticSiteCustomDomainArgs {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: pulumi.Input<string>;
    /**
     * Unique identifier for the custom domain
     */
    id: pulumi.Input<string>;
    /**
     * DNS record of the custom domain
     */
    name?: pulumi.Input<string>;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: pulumi.Input<string>;
}

export interface GetWebServiceCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name?: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: string;
}

export interface GetWebServiceCustomDomainArgs {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: pulumi.Input<string>;
    /**
     * Unique identifier for the custom domain
     */
    id: pulumi.Input<string>;
    /**
     * DNS record of the custom domain
     */
    name?: pulumi.Input<string>;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: pulumi.Input<string>;
}

export interface PostgresConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the database from outside of Render.
     */
    externalConnectionString?: pulumi.Input<string>;
    /**
     * Connection string for internal access. Use this to connect to the database from within the same Render region.
     */
    internalConnectionString?: pulumi.Input<string>;
    /**
     * Password for the postgres user.
     */
    password?: pulumi.Input<string>;
    /**
     * Command to connect to the database using the `psql` command line tool.
     */
    psqlCommand?: pulumi.Input<string>;
}

export interface PostgresIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: pulumi.Input<string>;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: pulumi.Input<string>;
}

export interface PostgresReadReplica {
    /**
     * ID of the read replica.
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the read replica.
     */
    name: pulumi.Input<string>;
}

export interface PrivateServiceAutoscaling {
    criteria: pulumi.Input<inputs.PrivateServiceAutoscalingCriteria>;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * The maximum number of instances for the service
     */
    max: pulumi.Input<number>;
    /**
     * The minimum number of instances for the service
     */
    min: pulumi.Input<number>;
}

export interface PrivateServiceAutoscalingCriteria {
    cpu?: pulumi.Input<inputs.PrivateServiceAutoscalingCriteriaCpu>;
    memory?: pulumi.Input<inputs.PrivateServiceAutoscalingCriteriaMemory>;
}

export interface PrivateServiceAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface PrivateServiceAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface PrivateServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id?: pulumi.Input<string>;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: pulumi.Input<string>;
    /**
     * Name of the disk
     */
    name: pulumi.Input<string>;
    /**
     * Size of the disk in GB
     */
    sizeGb: pulumi.Input<number>;
}

export interface PrivateServiceEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface PrivateServiceNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend?: pulumi.Input<string>;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled?: pulumi.Input<string>;
}

export interface PrivateServiceRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: pulumi.Input<inputs.PrivateServiceRuntimeSourceDocker>;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: pulumi.Input<inputs.PrivateServiceRuntimeSourceImage>;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: pulumi.Input<inputs.PrivateServiceRuntimeSourceNativeRuntime>;
}

export interface PrivateServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.PrivateServiceRuntimeSourceDockerBuildFilter>;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context?: pulumi.Input<string>;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath?: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
}

export interface PrivateServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PrivateServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest?: pulumi.Input<string>;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag?: pulumi.Input<string>;
}

export interface PrivateServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Command to build the service
     */
    buildCommand: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.PrivateServiceRuntimeSourceNativeRuntimeBuildFilter>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: pulumi.Input<string>;
}

export interface PrivateServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PrivateServiceSecretFiles {
    /**
     * The content of the secret file.
     */
    content: pulumi.Input<string>;
}

export interface ProjectEnvironments {
    /**
     * Unique identifier of the environment
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the environment
     */
    name: pulumi.Input<string>;
    /**
     * Protected environment status. One of `protected`, `unprotected`
     */
    protectedStatus: pulumi.Input<string>;
}

export interface RedisConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the redis from outside of Render.
     */
    externalConnectionString?: pulumi.Input<string>;
    /**
     * Connection string for internal access. Use this to connect to the redis from within the same Render region.
     */
    internalConnectionString?: pulumi.Input<string>;
    /**
     * Command to connect to the redis using the redis command line tool.
     */
    redisCliCommand?: pulumi.Input<string>;
}

export interface RedisIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: pulumi.Input<string>;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: pulumi.Input<string>;
}

export interface StaticSiteBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface StaticSiteCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: pulumi.Input<string>;
    /**
     * Unique identifier for the custom domain
     */
    id?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain
     */
    name: pulumi.Input<string>;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: pulumi.Input<string>;
}

export interface StaticSiteEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface StaticSiteHeader {
    /**
     * Name of the header
     */
    name: pulumi.Input<string>;
    /**
     * Request paths to apply the header
     */
    path: pulumi.Input<string>;
    /**
     * Value of the header
     */
    value: pulumi.Input<string>;
}

export interface StaticSiteNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend?: pulumi.Input<string>;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled?: pulumi.Input<string>;
}

export interface StaticSiteRoute {
    /**
     * Destination path to route to.
     */
    destination: pulumi.Input<string>;
    /**
     * Source path to match.
     */
    source: pulumi.Input<string>;
    /**
     * Type of route. Either redirect or rewrite.
     */
    type: pulumi.Input<string>;
}

export interface WebServiceAutoscaling {
    criteria: pulumi.Input<inputs.WebServiceAutoscalingCriteria>;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * The maximum number of instances for the service
     */
    max: pulumi.Input<number>;
    /**
     * The minimum number of instances for the service
     */
    min: pulumi.Input<number>;
}

export interface WebServiceAutoscalingCriteria {
    cpu?: pulumi.Input<inputs.WebServiceAutoscalingCriteriaCpu>;
    memory?: pulumi.Input<inputs.WebServiceAutoscalingCriteriaMemory>;
}

export interface WebServiceAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface WebServiceAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: pulumi.Input<number>;
}

export interface WebServiceCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType?: pulumi.Input<string>;
    /**
     * Unique identifier for the custom domain
     */
    id?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain
     */
    name: pulumi.Input<string>;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix?: pulumi.Input<string>;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName?: pulumi.Input<string>;
}

export interface WebServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id?: pulumi.Input<string>;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: pulumi.Input<string>;
    /**
     * Name of the disk
     */
    name: pulumi.Input<string>;
    /**
     * Size of the disk in GB
     */
    sizeGb: pulumi.Input<number>;
}

export interface WebServiceEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue?: pulumi.Input<boolean>;
    value?: pulumi.Input<string>;
}

export interface WebServiceNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend?: pulumi.Input<string>;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled?: pulumi.Input<string>;
}

export interface WebServiceRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: pulumi.Input<inputs.WebServiceRuntimeSourceDocker>;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: pulumi.Input<inputs.WebServiceRuntimeSourceImage>;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: pulumi.Input<inputs.WebServiceRuntimeSourceNativeRuntime>;
}

export interface WebServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.WebServiceRuntimeSourceDockerBuildFilter>;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context?: pulumi.Input<string>;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath?: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
}

export interface WebServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface WebServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest?: pulumi.Input<string>;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: pulumi.Input<string>;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: pulumi.Input<string>;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag?: pulumi.Input<string>;
}

export interface WebServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy?: pulumi.Input<boolean>;
    /**
     * Branch of the git repository to build.
     */
    branch: pulumi.Input<string>;
    /**
     * Command to build the service
     */
    buildCommand: pulumi.Input<string>;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: pulumi.Input<inputs.WebServiceRuntimeSourceNativeRuntimeBuildFilter>;
    /**
     * URL of the git repository to build.
     */
    repoUrl: pulumi.Input<string>;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: pulumi.Input<string>;
}

export interface WebServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface WebServiceSecretFiles {
    /**
     * The content of the secret file.
     */
    content: pulumi.Input<string>;
}
