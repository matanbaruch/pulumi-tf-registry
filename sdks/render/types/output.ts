// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface BackgroundWorkerAutoscaling {
    criteria: outputs.BackgroundWorkerAutoscalingCriteria;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface BackgroundWorkerAutoscalingCriteria {
    cpu: outputs.BackgroundWorkerAutoscalingCriteriaCpu;
    memory: outputs.BackgroundWorkerAutoscalingCriteriaMemory;
}

export interface BackgroundWorkerAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface BackgroundWorkerAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface BackgroundWorkerDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface BackgroundWorkerEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface BackgroundWorkerNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled: string;
}

export interface BackgroundWorkerRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: outputs.BackgroundWorkerRuntimeSourceDocker;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: outputs.BackgroundWorkerRuntimeSourceImage;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: outputs.BackgroundWorkerRuntimeSourceNativeRuntime;
}

export interface BackgroundWorkerRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.BackgroundWorkerRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
}

export interface BackgroundWorkerRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface BackgroundWorkerRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface BackgroundWorkerRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.BackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: string;
}

export interface BackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface BackgroundWorkerSecretFiles {
    /**
     * The content of the secret file.
     */
    content: string;
}

export interface CronJobEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface CronJobNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled: string;
}

export interface CronJobRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: outputs.CronJobRuntimeSourceDocker;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: outputs.CronJobRuntimeSourceImage;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: outputs.CronJobRuntimeSourceNativeRuntime;
}

export interface CronJobRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.CronJobRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
}

export interface CronJobRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface CronJobRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface CronJobRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.CronJobRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: string;
}

export interface CronJobRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface CronJobSecretFiles {
    /**
     * The content of the secret file.
     */
    content: string;
}

export interface EnvGroupEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface EnvGroupSecretFiles {
    /**
     * The content of the secret file.
     */
    content: string;
}

export interface GetBackgroundWorkerAutoscaling {
    criteria: outputs.GetBackgroundWorkerAutoscalingCriteria;
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface GetBackgroundWorkerAutoscalingCriteria {
    cpu: outputs.GetBackgroundWorkerAutoscalingCriteriaCpu;
    memory: outputs.GetBackgroundWorkerAutoscalingCriteriaMemory;
}

export interface GetBackgroundWorkerAutoscalingCriteriaCpu {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetBackgroundWorkerAutoscalingCriteriaMemory {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetBackgroundWorkerDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface GetBackgroundWorkerEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetBackgroundWorkerNotificationOverride {
    /**
     * The types of notifications to send.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent.
     */
    previewNotificationsEnabled: string;
}

export interface GetBackgroundWorkerRuntimeSource {
    /**
     * Details for building and deploying a Dockerfile.
     */
    docker: outputs.GetBackgroundWorkerRuntimeSourceDocker;
    image: outputs.GetBackgroundWorkerRuntimeSourceImage;
    nativeRuntime: outputs.GetBackgroundWorkerRuntimeSourceNativeRuntime;
}

export interface GetBackgroundWorkerRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetBackgroundWorkerRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
}

export interface GetBackgroundWorkerRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetBackgroundWorkerRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface GetBackgroundWorkerRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetBackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
    /**
     * Runtime of the service to use.
     */
    runtime: string;
}

export interface GetBackgroundWorkerRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetBackgroundWorkerSecretFiles {
    content: string;
}

export interface GetCronJobEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetCronJobNotificationOverride {
    /**
     * The types of notifications to send.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent.
     */
    previewNotificationsEnabled: string;
}

export interface GetCronJobRuntimeSource {
    /**
     * Details for building and deploying a Dockerfile.
     */
    docker: outputs.GetCronJobRuntimeSourceDocker;
    image: outputs.GetCronJobRuntimeSourceImage;
    nativeRuntime: outputs.GetCronJobRuntimeSourceNativeRuntime;
}

export interface GetCronJobRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetCronJobRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
}

export interface GetCronJobRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetCronJobRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface GetCronJobRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetCronJobRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
    /**
     * Runtime of the service to use.
     */
    runtime: string;
}

export interface GetCronJobRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetCronJobSecretFiles {
    content: string;
}

export interface GetEnvGroupEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetEnvGroupSecretFiles {
    content: string;
}

export interface GetPostgresConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the database from outside of Render.
     */
    externalConnectionString: string;
    /**
     * Connection string for internal access. Use this to connect to the database from within the same Render region.
     */
    internalConnectionString: string;
    /**
     * Password for the postgres user.
     */
    password: string;
    /**
     * Command to connect to the database using the `psql` command line tool.
     */
    psqlCommand: string;
}

export interface GetPostgresIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: string;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: string;
}

export interface GetPostgresReadReplica {
    /**
     * ID of the read replica.
     */
    id: string;
    /**
     * Name of the read replica.
     */
    name: string;
}

export interface GetPrivateServiceAutoscaling {
    criteria: outputs.GetPrivateServiceAutoscalingCriteria;
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface GetPrivateServiceAutoscalingCriteria {
    cpu: outputs.GetPrivateServiceAutoscalingCriteriaCpu;
    memory: outputs.GetPrivateServiceAutoscalingCriteriaMemory;
}

export interface GetPrivateServiceAutoscalingCriteriaCpu {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetPrivateServiceAutoscalingCriteriaMemory {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetPrivateServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface GetPrivateServiceEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetPrivateServiceNotificationOverride {
    /**
     * The types of notifications to send.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent.
     */
    previewNotificationsEnabled: string;
}

export interface GetPrivateServiceRuntimeSource {
    /**
     * Details for building and deploying a Dockerfile.
     */
    docker: outputs.GetPrivateServiceRuntimeSourceDocker;
    image: outputs.GetPrivateServiceRuntimeSourceImage;
    nativeRuntime: outputs.GetPrivateServiceRuntimeSourceNativeRuntime;
}

export interface GetPrivateServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetPrivateServiceRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
}

export interface GetPrivateServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetPrivateServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface GetPrivateServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetPrivateServiceRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
    /**
     * Runtime of the service to use.
     */
    runtime: string;
}

export interface GetPrivateServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetPrivateServiceSecretFiles {
    content: string;
}

export interface GetProjectEnvironments {
    /**
     * Unique identifier for the environment
     */
    id: string;
    /**
     * Name of the environment
     */
    name: string;
    /**
     * Protected environment
     */
    protectedStatus: string;
}

export interface GetRedisConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the redis from outside of Render.
     */
    externalConnectionString: string;
    /**
     * Connection string for internal access. Use this to connect to the redis from within the same Render region.
     */
    internalConnectionString: string;
    /**
     * Command to connect to the redis using the redis command line tool.
     */
    redisCliCommand: string;
}

export interface GetRedisIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: string;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: string;
}

export interface GetStaticSiteBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetStaticSiteCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName: string;
}

export interface GetStaticSiteEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetStaticSiteHeader {
    /**
     * Name of the header
     */
    name: string;
    /**
     * Request paths to apply the header
     */
    path: string;
    /**
     * Value of the header
     */
    value: string;
}

export interface GetStaticSiteNotificationOverride {
    /**
     * The types of notifications to send.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent.
     */
    previewNotificationsEnabled: string;
}

export interface GetStaticSiteRoute {
    /**
     * Destination path to route to.
     */
    destination: string;
    /**
     * Source path to match.
     */
    source: string;
    /**
     * Type of route. Either redirect or rewrite.
     */
    type: string;
}

export interface GetWebServiceAutoscaling {
    criteria: outputs.GetWebServiceAutoscalingCriteria;
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface GetWebServiceAutoscalingCriteria {
    cpu: outputs.GetWebServiceAutoscalingCriteriaCpu;
    memory: outputs.GetWebServiceAutoscalingCriteriaMemory;
}

export interface GetWebServiceAutoscalingCriteriaCpu {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetWebServiceAutoscalingCriteriaMemory {
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface GetWebServiceCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName: string;
}

export interface GetWebServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface GetWebServiceEnvVars {
    generateValue: boolean;
    value: string;
}

export interface GetWebServiceNotificationOverride {
    /**
     * The types of notifications to send.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent.
     */
    previewNotificationsEnabled: string;
}

export interface GetWebServiceRuntimeSource {
    /**
     * Details for building and deploying a Dockerfile.
     */
    docker: outputs.GetWebServiceRuntimeSourceDocker;
    image: outputs.GetWebServiceRuntimeSourceImage;
    nativeRuntime: outputs.GetWebServiceRuntimeSourceNativeRuntime;
}

export interface GetWebServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetWebServiceRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
}

export interface GetWebServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetWebServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface GetWebServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch to build
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Filter for files and paths to monitor for automatic deploys. Filter paths are absolute. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter: outputs.GetWebServiceRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the repository to build
     */
    repoUrl: string;
    /**
     * Runtime of the service to use.
     */
    runtime: string;
}

export interface GetWebServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths: string[];
}

export interface GetWebServiceSecretFiles {
    content: string;
}

export interface PostgresConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the database from outside of Render.
     */
    externalConnectionString: string;
    /**
     * Connection string for internal access. Use this to connect to the database from within the same Render region.
     */
    internalConnectionString: string;
    /**
     * Password for the postgres user.
     */
    password: string;
    /**
     * Command to connect to the database using the `psql` command line tool.
     */
    psqlCommand: string;
}

export interface PostgresIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: string;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: string;
}

export interface PostgresReadReplica {
    /**
     * ID of the read replica.
     */
    id: string;
    /**
     * Name of the read replica.
     */
    name: string;
}

export interface PrivateServiceAutoscaling {
    criteria: outputs.PrivateServiceAutoscalingCriteria;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface PrivateServiceAutoscalingCriteria {
    cpu: outputs.PrivateServiceAutoscalingCriteriaCpu;
    memory: outputs.PrivateServiceAutoscalingCriteriaMemory;
}

export interface PrivateServiceAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface PrivateServiceAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface PrivateServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface PrivateServiceEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface PrivateServiceNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled: string;
}

export interface PrivateServiceRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: outputs.PrivateServiceRuntimeSourceDocker;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: outputs.PrivateServiceRuntimeSourceImage;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: outputs.PrivateServiceRuntimeSourceNativeRuntime;
}

export interface PrivateServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.PrivateServiceRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
}

export interface PrivateServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface PrivateServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface PrivateServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.PrivateServiceRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: string;
}

export interface PrivateServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface PrivateServiceSecretFiles {
    /**
     * The content of the secret file.
     */
    content: string;
}

export interface ProjectEnvironments {
    /**
     * Unique identifier of the environment
     */
    id: string;
    /**
     * Name of the environment
     */
    name: string;
    /**
     * Protected environment status. One of `protected`, `unprotected`
     */
    protectedStatus: string;
}

export interface RedisConnectionInfo {
    /**
     * Connection string for external access. Use this to connect to the redis from outside of Render.
     */
    externalConnectionString: string;
    /**
     * Connection string for internal access. Use this to connect to the redis from within the same Render region.
     */
    internalConnectionString: string;
    /**
     * Command to connect to the redis using the redis command line tool.
     */
    redisCliCommand: string;
}

export interface RedisIpAllowList {
    /**
     * CIDR block that is allowed to connect to the Redis instance. (0.0.0.0/0 to allow traffic from all IPs)
     */
    cidrBlock: string;
    /**
     * Description of the IP address or range. This is used to help identify the IP address or range in the list.
     */
    description: string;
}

export interface StaticSiteBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface StaticSiteCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName: string;
}

export interface StaticSiteEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface StaticSiteHeader {
    /**
     * Name of the header
     */
    name: string;
    /**
     * Request paths to apply the header
     */
    path: string;
    /**
     * Value of the header
     */
    value: string;
}

export interface StaticSiteNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled: string;
}

export interface StaticSiteRoute {
    /**
     * Destination path to route to.
     */
    destination: string;
    /**
     * Source path to match.
     */
    source: string;
    /**
     * Type of route. Either redirect or rewrite.
     */
    type: string;
}

export interface WebServiceAutoscaling {
    criteria: outputs.WebServiceAutoscalingCriteria;
    /**
     * Whether autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * The maximum number of instances for the service
     */
    max: number;
    /**
     * The minimum number of instances for the service
     */
    min: number;
}

export interface WebServiceAutoscalingCriteria {
    cpu: outputs.WebServiceAutoscalingCriteriaCpu;
    memory: outputs.WebServiceAutoscalingCriteriaMemory;
}

export interface WebServiceAutoscalingCriteriaCpu {
    /**
     * Whether CPU-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface WebServiceAutoscalingCriteriaMemory {
    /**
     * Whether memory-based autoscaling is enabled for the service
     */
    enabled: boolean;
    /**
     * Determines when your service will be scaled. If the average resource utilization is significantly above/below the target, we will increase/decrease the number of instances.
     */
    percentage: number;
}

export interface WebServiceCustomDomain {
    /**
     * Type of the custom domain. Either apex or subdomain
     */
    domainType: string;
    /**
     * Unique identifier for the custom domain
     */
    id: string;
    /**
     * DNS record of the custom domain
     */
    name: string;
    /**
     * Public suffix of the custom domain
     */
    publicSuffix: string;
    /**
     * DNS record of the custom domain to redirect to
     */
    redirectForName: string;
}

export interface WebServiceDisk {
    /**
     * Unique identifier for the disk
     */
    id: string;
    /**
     * Absolute path to mount the disk.
     */
    mountPath: string;
    /**
     * Name of the disk
     */
    name: string;
    /**
     * Size of the disk in GB
     */
    sizeGb: number;
}

export interface WebServiceEnvVars {
    /**
     * If true, Render will generate the variable value.
     */
    generateValue: boolean;
    value: string;
}

export interface WebServiceNotificationOverride {
    /**
     * The types of notifications to send. Must be one of `default`, `all`, `failure`, or `none`.
     */
    notificationsToSend: string;
    /**
     * Whether notifications for previews of this service are sent. Must be one of `all`, `failure`, or `none`.
     */
    previewNotificationsEnabled: string;
}

export interface WebServiceRuntimeSource {
    /**
     * Details for building and deploying a service [using a Dockerfile](https://docs.render.com/docker).
     */
    docker?: outputs.WebServiceRuntimeSourceDocker;
    /**
     * Details for deploying a service using a [Docker image from a registry](https://docs.render.com/deploy-an-image).
     */
    image?: outputs.WebServiceRuntimeSourceImage;
    /**
     * Details for building and deploying a service using one of Render's [native runtimes](https://docs.render.com/native-runtimes).
     */
    nativeRuntime?: outputs.WebServiceRuntimeSourceNativeRuntime;
}

export interface WebServiceRuntimeSourceDocker {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.WebServiceRuntimeSourceDockerBuildFilter;
    /**
     * [Docker build context directory.](https://docs.docker.com/reference/dockerfile/#usage) This is relative to your repository root. Defaults to the root.
     */
    context: string;
    /**
     * Path to your Dockerfile relative to the repository root. This is not relative to your Docker build context. Example: `./subdir/Dockerfile.`
     */
    dockerfilePath: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
}

export interface WebServiceRuntimeSourceDockerBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface WebServiceRuntimeSourceImage {
    /**
     * Digest of the Docker image to deploy. Mutually exclusive with tag.
     */
    digest: string;
    /**
     * URL of the Docker image to deploy.
     */
    imageUrl: string;
    /**
     * ID of the registry credential to use when pulling the image.
     */
    registryCredentialId?: string;
    /**
     * Tag of the Docker image to deploy. Mutually exclusive with digest.
     */
    tag: string;
}

export interface WebServiceRuntimeSourceNativeRuntime {
    /**
     * [Automatic deploy](https://docs.render.com/deploys#automatic-git-deploys) on every push to your repository, or changes to your service settings or environment.
     */
    autoDeploy: boolean;
    /**
     * Branch of the git repository to build.
     */
    branch: string;
    /**
     * Command to build the service
     */
    buildCommand: string;
    /**
     * Apply [build filters](https://docs.render.com/monorepo-support#build-filters) to configure which changes in your git repository trigger automatic deploys. If you've defined a root directory, you can still define paths outside of the root directory.
     */
    buildFilter?: outputs.WebServiceRuntimeSourceNativeRuntimeBuildFilter;
    /**
     * URL of the git repository to build.
     */
    repoUrl: string;
    /**
     * Runtime of the service to use. Must be one of `elixir`, `go`, `node`, `python`, `ruby`, `rust`.
     */
    runtime: string;
}

export interface WebServiceRuntimeSourceNativeRuntimeBuildFilter {
    /**
     * Changes that match these paths will not trigger a new build.
     */
    ignoredPaths?: string[];
    /**
     * Changes that match these paths will trigger a new build.
     */
    paths?: string[];
}

export interface WebServiceSecretFiles {
    /**
     * The content of the secret file.
     */
    content: string;
}

