// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ArchiveShareTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ArchiveTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AutoBackupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AutoScaleCpuThresholdScaling {
    /**
     * Threshold for average CPU utilization to scale down/in
     */
    down: number;
    /**
     * Server name prefix to be monitored
     */
    serverPrefix: string;
    /**
     * Threshold for average CPU utilization to scale up/out
     */
    up: number;
}

export interface AutoScaleRouterThresholdScaling {
    /**
     * This must be one of [`in`/`out`]
     */
    direction: string;
    /**
     * Mbps
     */
    mbps: number;
    /**
     * Router name prefix to be monitored
     */
    routerPrefix: string;
}

export interface AutoScaleScheduleScaling {
    /**
     * This must be one of [`up`/`down`]
     */
    action: string;
    /**
     * A list of weekdays to backed up. The values in the list must be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`]
     */
    daysOfWeeks: string[];
    /**
     * Hour to be triggered
     */
    hour: number;
    /**
     * Minute to be triggered. This must be one of [`0`/`15`/`30`/`45`]
     */
    minute: number;
}

export interface AutoScaleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BridgeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CdromTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CertificateAuthorityClient {
    /**
     * The body of the CA's certificate in PEM format
     */
    certificate: string;
    /**
     * Input for issuing a certificate
     */
    csr?: string;
    /**
     * Input for issuing a certificate
     */
    email?: string;
    /**
     * Flag to suspend/hold the certificate
     */
    hold?: boolean;
    /**
     * The id of the certificate
     */
    id: string;
    /**
     * Current state of the certificate
     */
    issueState: string;
    /**
     * The date on which the certificate validity period ends, in RFC3339 format
     */
    notAfter: string;
    /**
     * The date on which the certificate validity period begins, in RFC3339 format
     */
    notBefore: string;
    /**
     * Input for issuing a certificate
     */
    publicKey?: string;
    /**
     * The body of the CA's certificate in PEM format
     */
    serialNumber: string;
    subject: outputs.CertificateAuthorityClientSubject;
    /**
     * The URL for issuing the certificate
     */
    url: string;
    /**
     * The number of hours after initial issuing that the certificate will become invalid
     */
    validityPeriodHours: number;
}

export interface CertificateAuthorityClientSubject {
    commonName: string;
    country: string;
    organization: string;
    organizationUnits?: string[];
}

export interface CertificateAuthorityServer {
    /**
     * The body of the CA's certificate in PEM format
     */
    certificate: string;
    /**
     * Input for issuing a certificate
     */
    csr?: string;
    /**
     * Flag to suspend/hold the certificate
     */
    hold?: boolean;
    /**
     * The id of the certificate
     */
    id: string;
    /**
     * Current state of the certificate
     */
    issueState: string;
    /**
     * The date on which the certificate validity period ends, in RFC3339 format
     */
    notAfter: string;
    /**
     * The date on which the certificate validity period begins, in RFC3339 format
     */
    notBefore: string;
    /**
     * Input for issuing a certificate
     */
    publicKey?: string;
    /**
     * The body of the CA's certificate in PEM format
     */
    serialNumber: string;
    subject: outputs.CertificateAuthorityServerSubject;
    subjectAlternativeNames?: string[];
    /**
     * The number of hours after initial issuing that the certificate will become invalid
     */
    validityPeriodHours: number;
}

export interface CertificateAuthorityServerSubject {
    commonName: string;
    country: string;
    organization: string;
    organizationUnits?: string[];
}

export interface CertificateAuthoritySubject {
    commonName: string;
    country: string;
    organization: string;
    organizationUnits?: string[];
}

export interface CertificateAuthorityTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryUser {
    /**
     * The user name used to authenticate remote access
     */
    name: string;
    /**
     * The password used to authenticate remote access
     */
    password: string;
    /**
     * The level of access that allow to the user. This must be one of [`all`/`readwrite`/`readonly`]
     */
    permission: string;
}

export interface DatabaseBackup {
    /**
     * The time to take backup. This must be formatted with `HH:mm`
     */
    time?: string;
    /**
     * A list of weekdays to backed up. The values in the list must be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`]
     */
    weekdays?: string[];
}

export interface DatabaseNetworkInterface {
    /**
     * The IP address of the gateway used by Database
     */
    gateway: string;
    /**
     * The IP address to assign to the Database
     */
    ipAddress: string;
    /**
     * The bit length of the subnet to assign to the Database. This must be in the range [`8`-`29`]
     */
    netmask: number;
    /**
     * The number of the listening port. This must be in the range [`1024`-`65535`]
     */
    port?: number;
    /**
     * The range of source IP addresses that allow to access to the Database via network
     */
    sourceRanges?: string[];
    /**
     * The id of the switch to which the Database connects
     */
    switchId: string;
}

export interface DatabaseReadReplicaNetworkInterface {
    /**
     * The IP address of the gateway used by read-replica database. If `gateway` isn't specified, it will be set to the same value of the master database
     */
    gateway: string;
    /**
     * The IP address to assign to the read-replica database
     */
    ipAddress: string;
    /**
     * The bit length of the subnet to assign to the read-replica database. This must be in the range [`8`-`29`]. If `netmask` isn't specified, it will be set to the same value of the master database
     */
    netmask: number;
    /**
     * The range of source IP addresses that allow to access to the read-replica database via network
     */
    sourceRanges?: string[];
    /**
     * The id of the switch to which the read-replica database connects. If `switch_id` isn't specified, it will be set to the same value of the master database
     */
    switchId: string;
}

export interface DatabaseReadReplicaTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DatabaseTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DiskTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DnsRecord {
    /**
     * The name of the DNS Record. The length of this value must be in the range [`1`-`64`]
     */
    name: string;
    /**
     * The number of port. This must be in the range [`1`-`65535`]
     */
    port?: number;
    /**
     * The priority of target DNS Record. This must be in the range [`0`-`65535`]
     */
    priority?: number;
    /**
     * The number of the TTL
     */
    ttl?: number;
    /**
     * The type of DNS Record. This must be one of [`A`/`AAAA`/`ALIAS`/`CNAME`/`NS`/`MX`/`TXT`/`SRV`/`CAA`/`HTTPS`/`SVCB`/`PTR`]
     */
    type: string;
    /**
     * The value of the DNS Record
     */
    value: string;
    /**
     * The weight of target DNS Record. This must be in the range [`0`-`65535`]
     */
    weight?: number;
}

export interface DnsRecordTimeouts {
    create?: string;
    delete?: string;
}

export interface DnsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnhancedDbTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EsmeTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetArchiveFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetArchiveFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetArchiveFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetAutoScaleCpuThresholdScaling {
    down: number;
    serverPrefix: string;
    up: number;
}

export interface GetAutoScaleFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetAutoScaleFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetAutoScaleFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetAutoScaleRouterThresholdScaling {
    direction: string;
    mbps: number;
    routerPrefix: string;
}

export interface GetAutoScaleScheduleScaling {
    action: string;
    daysOfWeeks: string[];
    hour: number;
    minute: number;
}

export interface GetBridgeFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetBridgeFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
}

export interface GetBridgeFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetCdromFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetCdromFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetCdromFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetCertificateAuthorityClient {
    certificate: string;
    hold: boolean;
    id: string;
    issueState: string;
    notAfter: string;
    notBefore: string;
    serialNumber: string;
    subjectString: string;
    url: string;
}

export interface GetCertificateAuthorityFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetCertificateAuthorityFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetCertificateAuthorityFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetCertificateAuthorityServer {
    certificate: string;
    hold: boolean;
    id: string;
    issueState: string;
    notAfter: string;
    notBefore: string;
    serialNumber: string;
    subjectAlternativeNames: string[];
    subjectString: string;
}

export interface GetContainerRegistryFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetContainerRegistryFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetContainerRegistryFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetContainerRegistryUser {
    name: string;
    permission: string;
}

export interface GetDatabaseBackup {
    time: string;
    weekdays: string[];
}

export interface GetDatabaseFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetDatabaseFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetDatabaseFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetDatabaseNetworkInterface {
    gateway: string;
    ipAddress: string;
    netmask: number;
    port: number;
    sourceRanges: string[];
    switchId: string;
}

export interface GetDiskFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetDiskFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetDiskFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetDnsFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetDnsFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetDnsFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetDnsRecord {
    name: string;
    port: number;
    priority: number;
    ttl: number;
    type: string;
    value: string;
    weight: number;
}

export interface GetEnhancedDbFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetEnhancedDbFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetEnhancedDbFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetEsmeFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetEsmeFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetEsmeFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetGslbFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetGslbFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetGslbFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetGslbHealthCheck {
    delayLoop: number;
    hostHeader: string;
    path: string;
    port: number;
    protocol: string;
    status: string;
}

export interface GetGslbServer {
    enabled: boolean;
    ipAddress: string;
    weight: number;
}

export interface GetIconFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetIconFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetIconFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetInternetFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetInternetFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetInternetFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetLoadBalancerFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetLoadBalancerFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetLoadBalancerFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetLoadBalancerNetworkInterface {
    gateway: string;
    ipAddresses: string[];
    netmask: number;
    switchId: string;
    vrid: number;
}

export interface GetLoadBalancerVip {
    delayLoop: number;
    description: string;
    port: number;
    servers: outputs.GetLoadBalancerVipServer[];
    sorryServer: string;
    vip: string;
}

export interface GetLoadBalancerVipServer {
    enabled: boolean;
    ipAddress: string;
    path: string;
    protocol: string;
    status: string;
}

export interface GetLocalRouterFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetLocalRouterFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetLocalRouterFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetLocalRouterNetworkInterface {
    ipAddresses: string[];
    netmask: number;
    vip: string;
    vrid: number;
}

export interface GetLocalRouterPeer {
    description: string;
    enabled: boolean;
    peerId: string;
    secretKey: string;
}

export interface GetLocalRouterStaticRoute {
    nextHop: string;
    prefix: string;
}

export interface GetLocalRouterSwitch {
    category: string;
    code: string;
    zoneId: string;
}

export interface GetNfsFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetNfsFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetNfsFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetNfsNetworkInterface {
    gateway: string;
    ipAddress: string;
    netmask: number;
    switchId: string;
}

export interface GetNoteFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetNoteFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetNoteFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetPacketFilterExpression {
    allow: boolean;
    description: string;
    destinationPort: string;
    protocol: string;
    sourceNetwork: string;
    sourcePort: string;
}

export interface GetPacketFilterFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetPacketFilterFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
}

export interface GetPacketFilterFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetPrivateHostFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetPrivateHostFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetPrivateHostFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetProxylbBindPort {
    port: number;
    proxyMode: string;
    redirectToHttps: boolean;
    responseHeaders: outputs.GetProxylbBindPortResponseHeader[];
    sslPolicy: string;
    supportHttp2: boolean;
}

export interface GetProxylbBindPortResponseHeader {
    header: string;
    value: string;
}

export interface GetProxylbCertificate {
    additionalCertificates: outputs.GetProxylbCertificateAdditionalCertificate[];
    commonName: string;
    intermediateCert: string;
    privateKey: string;
    serverCert: string;
    subjectAltNames: string;
}

export interface GetProxylbCertificateAdditionalCertificate {
    intermediateCert: string;
    privateKey: string;
    serverCert: string;
}

export interface GetProxylbFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetProxylbFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetProxylbFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetProxylbHealthCheck {
    delayLoop: number;
    hostHeader: string;
    path: string;
    port: number;
    protocol: string;
}

export interface GetProxylbRule {
    action: string;
    fixedContentType: string;
    fixedMessageBody: string;
    fixedStatusCode: string;
    group: string;
    host: string;
    path: string;
    redirectLocation: string;
    redirectStatusCode: string;
    requestHeaderName: string;
    requestHeaderValue: string;
    requestHeaderValueIgnoreCase: boolean;
    requestHeaderValueNotMatch: boolean;
    sourceIps: string;
}

export interface GetProxylbServer {
    enabled: boolean;
    group: string;
    ipAddress: string;
    port: number;
}

export interface GetProxylbSorryServer {
    ipAddress: string;
    port: number;
}

export interface GetProxylbSyslog {
    port: number;
    server: string;
}

export interface GetServerFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetServerFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetServerFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetServerNetworkInterface {
    macAddress: string;
    packetFilterId: string;
    upstream: string;
    userIpAddress: string;
}

export interface GetSimpleMonitorFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetSimpleMonitorFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetSimpleMonitorFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetSimpleMonitorHealthCheck {
    community: string;
    containsString: string;
    excepctedData: string;
    ftps: string;
    hostHeader: string;
    http2: boolean;
    oid: string;
    password: string;
    path: string;
    port: number;
    protocol: string;
    qname: string;
    remainingDays: number;
    sni: boolean;
    snmpVersion: string;
    status: number;
    username: string;
    verifySni: boolean;
}

export interface GetSshKeyFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetSshKeyFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
}

export interface GetSshKeyFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetSwitchFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetSwitchFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetSwitchFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetVpcRouterDhcpServer {
    dnsServers: string[];
    interfaceIndex: number;
    rangeStart: string;
    rangeStop: string;
}

export interface GetVpcRouterDhcpStaticMapping {
    ipAddress: string;
    macAddress: string;
}

export interface GetVpcRouterDnsForwarding {
    dnsServers: string[];
    interfaceIndex: number;
}

export interface GetVpcRouterFilter {
    /**
     * One or more name/values pairs used for filtering. There are several valid keys, for a full reference, check out finding section in the [SakuraCloud API reference](https://developer.sakura.ad.jp/cloud/api/1.1/)
     */
    conditions?: outputs.GetVpcRouterFilterCondition[];
    /**
     * The resource id on SakuraCloud used for filtering
     */
    id?: string;
    /**
     * The resource names on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    names?: string[];
    /**
     * The resource tags on SakuraCloud used for filtering. If multiple values ​​are specified, they combined as AND condition
     */
    tags?: string[];
}

export interface GetVpcRouterFilterCondition {
    /**
     * The name of the target field. This value is case-sensitive
     */
    name: string;
    /**
     * The filtering operator. This must be one of following:  
     * `partial_match_and`/`exact_match_or`
     */
    operator?: string;
    /**
     * The values of the condition. If multiple values ​​are specified, they combined as AND condition
     */
    values: string[];
}

export interface GetVpcRouterFirewall {
    direction: string;
    expressions: outputs.GetVpcRouterFirewallExpression[];
    interfaceIndex: number;
}

export interface GetVpcRouterFirewallExpression {
    allow: boolean;
    description: string;
    destinationNetwork: string;
    destinationPort: string;
    logging: boolean;
    protocol: string;
    sourceNetwork: string;
    sourcePort: string;
}

export interface GetVpcRouterL2tp {
    preSharedSecret: string;
    rangeStart: string;
    rangeStop: string;
}

export interface GetVpcRouterPortForwarding {
    description: string;
    privateIp: string;
    privatePort: number;
    protocol: string;
    publicPort: number;
}

export interface GetVpcRouterPptp {
    rangeStart: string;
    rangeStop: string;
}

export interface GetVpcRouterPrivateNetworkInterface {
    index: number;
    ipAddresses: string[];
    netmask: number;
    switchId: string;
    vip: string;
}

export interface GetVpcRouterPublicNetworkInterface {
    aliases: string[];
    ipAddresses: string[];
    switchId: string;
    vip: string;
    vrid: number;
}

export interface GetVpcRouterScheduledMaintenance {
    dayOfWeek: string;
    hour: number;
}

export interface GetVpcRouterSiteToSiteVpn {
    localPrefixes: string[];
    peer: string;
    preSharedSecret: string;
    remoteId: string;
    routes: string[];
}

export interface GetVpcRouterSiteToSiteVpnParameter {
    dhGroup: string;
    encryptionAlgo: string;
    esps: outputs.GetVpcRouterSiteToSiteVpnParameterEsp[];
    hashAlgo: string;
    ikes: outputs.GetVpcRouterSiteToSiteVpnParameterIke[];
}

export interface GetVpcRouterSiteToSiteVpnParameterEsp {
    lifetime: number;
}

export interface GetVpcRouterSiteToSiteVpnParameterIke {
    dpds: outputs.GetVpcRouterSiteToSiteVpnParameterIkeDpd[];
    lifetime: number;
}

export interface GetVpcRouterSiteToSiteVpnParameterIkeDpd {
    interval: number;
    timeout: number;
}

export interface GetVpcRouterStaticNat {
    description: string;
    privateIp: string;
    publicIp: string;
}

export interface GetVpcRouterStaticRoute {
    nextHop: string;
    prefix: string;
}

export interface GetVpcRouterUser {
    name: string;
    password: string;
}

export interface GetVpcRouterWireGuard {
    ipAddress: string;
    peers: outputs.GetVpcRouterWireGuardPeer[];
    publicKey: string;
}

export interface GetVpcRouterWireGuardPeer {
    ipAddress: string;
    name: string;
    publicKey: string;
}

export interface GslbHealthCheck {
    /**
     * The interval in seconds between checks. This must be in the range [`10`-`60`]
     */
    delayLoop?: number;
    /**
     * The value of host header send when checking by HTTP/HTTPS
     */
    hostHeader?: string;
    /**
     * The path used when checking by HTTP/HTTPS
     */
    path?: string;
    /**
     * The port number used when checking by TCP
     */
    port?: number;
    /**
     * The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`]
     */
    protocol: string;
    /**
     * The response-code to expect when checking by HTTP/HTTPS
     */
    status?: string;
}

export interface GslbServer {
    /**
     * The flag to enable as destination of load balancing
     */
    enabled?: boolean;
    /**
     * The IP address of the server
     */
    ipAddress: string;
    /**
     * The weight used when weighted load balancing is enabled. This must be in the range [`1`-`10000`]
     */
    weight?: number;
}

export interface GslbTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface IconTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface InternetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface Ipv4PtrTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LoadBalancerNetworkInterface {
    /**
     * The IP address of the gateway used by LoadBalancer
     */
    gateway?: string;
    /**
     * A list of IP address to assign to the LoadBalancer.
     */
    ipAddresses: string[];
    /**
     * The bit length of the subnet assigned to the LoadBalancer. This must be in the range [`8`-`29`]
     */
    netmask: number;
    /**
     * The id of the switch to which the LoadBalancer connects
     */
    switchId: string;
    /**
     * The Virtual Router Identifier
     */
    vrid: number;
}

export interface LoadBalancerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface LoadBalancerVip {
    /**
     * The interval in seconds between checks. This must be in the range [`10`-`2147483647`]
     */
    delayLoop?: number;
    /**
     * The description of the VIP. The length of this value must be in the range [`1`-`512`]
     */
    description?: string;
    /**
     * The target port number for load-balancing. This must be in the range [`1`-`65535`]
     */
    port: number;
    servers?: outputs.LoadBalancerVipServer[];
    /**
     * The IP address of the SorryServer. This will be used when all servers under this VIP are down
     */
    sorryServer?: string;
    /**
     * The virtual IP address
     */
    vip: string;
}

export interface LoadBalancerVipServer {
    /**
     * The flag to enable as destination of load balancing
     */
    enabled?: boolean;
    /**
     * The IP address of the destination server
     */
    ipAddress: string;
    /**
     * The path used when checking by HTTP/HTTPS
     */
    path?: string;
    /**
     * The protocol used for health checks. This must be one of [`http`/`https`/`tcp`/`ping`]
     */
    protocol: string;
    /**
     * The response code to expect when checking by HTTP/HTTPS
     */
    status?: string;
}

export interface LocalRouterNetworkInterface {
    /**
     * A list of IP address to assign to the LocalRouter.
     */
    ipAddresses: string[];
    /**
     * The bit length of the subnet assigned to the LocalRouter. This must be in the range [`8`-`29`]
     */
    netmask: number;
    /**
     * The virtual IP address
     */
    vip: string;
    /**
     * The Virtual Router Identifier
     */
    vrid: number;
}

export interface LocalRouterPeer {
    /**
     * The description of the LocalRouter. The length of this value must be in the range [`1`-`512`]
     */
    description?: string;
    /**
     * The flag to enable the LocalRouter
     */
    enabled?: boolean;
    /**
     * The ID of the peer LocalRouter
     */
    peerId: string;
    /**
     * The secret key of the peer LocalRouter
     */
    secretKey: string;
}

export interface LocalRouterStaticRoute {
    /**
     * The IP address of the next hop
     */
    nextHop: string;
    /**
     * The CIDR block of destination
     */
    prefix: string;
}

export interface LocalRouterSwitch {
    /**
     * The category name of connected services (e.g. `cloud`, `vps`)
     */
    category?: string;
    /**
     * The resource ID of the Switch
     */
    code: string;
    /**
     * The id of the Zone
     */
    zoneId: string;
}

export interface LocalRouterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MobileGatewayPrivateNetworkInterface {
    /**
     * The IP address to assign to the MobileGateway
     */
    ipAddress: string;
    /**
     * The bit length of the subnet to assign to the MobileGateway. This must be in the range [`8`-`29`]
     */
    netmask: number;
    /**
     * The id of the switch to which the MobileGateway connects
     */
    switchId: string;
}

export interface MobileGatewaySim {
    /**
     * The IP address to assign to the SIM
     */
    ipAddress: string;
    /**
     * The id of the Switch connected to the MobileGateway
     */
    simId: string;
}

export interface MobileGatewaySimRoute {
    /**
     * The destination network prefix used by the sim routing. This must be specified by CIDR block formatted string
     */
    prefix: string;
    /**
     * The id of the routing destination SIM
     */
    simId: string;
}

export interface MobileGatewayStaticRoute {
    /**
     * The IP address of next hop
     */
    nextHop: string;
    /**
     * The destination network prefix used by static routing. This must be specified by CIDR block formatted string
     */
    prefix: string;
}

export interface MobileGatewayTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MobileGatewayTrafficControl {
    /**
     * The flag to enable the traffic shaping
     */
    autoTrafficShaping?: boolean;
    /**
     * The bandwidth allowed when the traffic shaping is enabled
     */
    bandWidthLimit?: number;
    /**
     * The flag to enable email notification when the traffic shaping is enabled
     */
    enableEmail?: boolean;
    /**
     * The flag to enable slack notification when the traffic shaping is enabled
     */
    enableSlack?: boolean;
    /**
     * The threshold of monthly traffic usage to enable to the traffic shaping
     */
    quota: number;
    /**
     * The webhook URL used when sends notification. It will only used when `enable_slack` is set `true`
     */
    slackWebhook?: string;
}

export interface NfsNetworkInterface {
    /**
     * The IP address of the gateway used by NFS
     */
    gateway?: string;
    /**
     * The IP address to assign to the NFS
     */
    ipAddress: string;
    /**
     * The bit length of the subnet to assign to the NFS. This must be in the range [`8`-`29`]
     */
    netmask: number;
    /**
     * The id of the switch to which the NFS connects
     */
    switchId: string;
}

export interface NfsTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NoteTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PacketFilterExpression {
    /**
     * The flag to allow the packet through the filter
     */
    allow?: boolean;
    /**
     * The description of the expression
     */
    description?: string;
    /**
     * A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`)
     */
    destinationPort?: string;
    /**
     * The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`]
     */
    protocol: string;
    /**
     * A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`)
     */
    sourceNetwork?: string;
    /**
     * A source port number or port range used for filtering (e.g. `1024`, `1024-2048`)
     */
    sourcePort?: string;
}

export interface PacketFilterRulesExpression {
    /**
     * The flag to allow the packet through the filter
     */
    allow?: boolean;
    /**
     * The description of the expression
     */
    description?: string;
    /**
     * A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`)
     */
    destinationPort?: string;
    /**
     * The protocol used for filtering. This must be one of [`http`/`https`/`tcp`/`udp`/`icmp`/`fragment`/`ip`]
     */
    protocol: string;
    /**
     * A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`)
     */
    sourceNetwork?: string;
    /**
     * A source port number or port range used for filtering (e.g. `1024`, `1024-2048`)
     */
    sourcePort?: string;
}

export interface PacketFilterRulesTimeouts {
    create?: string;
    delete?: string;
}

export interface PacketFilterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PrivateHostTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProxylbAcmeCertificate {
    additionalCertificates: outputs.ProxylbAcmeCertificateAdditionalCertificate[];
    commonName: string;
    intermediateCert: string;
    privateKey: string;
    serverCert: string;
    subjectAltNames: string;
}

export interface ProxylbAcmeCertificateAdditionalCertificate {
    intermediateCert: string;
    privateKey: string;
    serverCert: string;
}

export interface ProxylbAcmeTimeouts {
    create?: string;
    delete?: string;
}

export interface ProxylbBindPort {
    /**
     * The number of listening port
     */
    port?: number;
    /**
     * The proxy mode. This must be one of [`http`/`https`/`tcp`]
     */
    proxyMode: string;
    /**
     * The flag to enable redirection from http to https. This flag is used only when `proxy_mode` is `http`
     */
    redirectToHttps?: boolean;
    responseHeaders?: outputs.ProxylbBindPortResponseHeader[];
    /**
     * The ssl policy. This must be one of [`TLS-1-2-2019-04`/`TLS-1-2-2021-06`/`TLS-1-3-2021-06`]
     */
    sslPolicy?: string;
    /**
     * The flag to enable HTTP/2. This flag is used only when `proxy_mode` is `https`
     */
    supportHttp2?: boolean;
}

export interface ProxylbBindPortResponseHeader {
    /**
     * The field name of HTTP header added to response by the ProxyLB
     */
    header: string;
    /**
     * The field value of HTTP header added to response by the ProxyLB
     */
    value: string;
}

export interface ProxylbCertificate {
    additionalCertificates?: outputs.ProxylbCertificateAdditionalCertificate[];
    /**
     * The common name of the certificate
     */
    commonName: string;
    /**
     * The intermediate certificate for a server
     */
    intermediateCert: string;
    /**
     * The private key for a server
     */
    privateKey: string;
    /**
     * The certificate for a server
     */
    serverCert: string;
    /**
     * The subject alternative names of the certificate
     */
    subjectAltNames: string;
}

export interface ProxylbCertificateAdditionalCertificate {
    /**
     * The intermediate certificate for a server
     */
    intermediateCert?: string;
    /**
     * The private key for a server
     */
    privateKey: string;
    /**
     * The certificate for a server
     */
    serverCert: string;
}

export interface ProxylbHealthCheck {
    /**
     * The interval in seconds between checks. This must be in the range [`10`-`60`]
     */
    delayLoop?: number;
    /**
     * The value of host header send when checking by HTTP
     */
    hostHeader?: string;
    /**
     * The path used when checking by HTTP
     */
    path?: string;
    /**
     * The port number used when checking by TCP
     */
    port?: number;
    /**
     * The protocol used for health checks. This must be one of [`http`/`tcp`]
     */
    protocol: string;
}

export interface ProxylbRule {
    /**
     * The type of action to be performed when requests matches the rule. This must be one of [`forward`/`redirect`/`fixed`]
     */
    action?: string;
    /**
     * Content-Type header value for fixed response sent when requests matches the rule. This must be one of [`text/plain`/`text/html`/`application/javascript`/`application/json`]
     */
    fixedContentType?: string;
    /**
     * Content body for fixed response sent when requests matches the rule
     */
    fixedMessageBody?: string;
    /**
     * HTTP status code for fixed response sent when requests matches the rule. This must be one of [`200`/`403`/`503`]
     */
    fixedStatusCode?: string;
    /**
     * The name of load balancing group. When proxyLB received request which matched to `host` and `path`, proxyLB forwards the request to servers that having same group name. The length of this value must be in the range [`1`-`10`]
     */
    group?: string;
    /**
     * The value of HTTP host header that is used as condition of rule-based balancing
     */
    host?: string;
    /**
     * The request path that is used as condition of rule-based balancing
     */
    path?: string;
    /**
     * The URL to redirect to when the request matches the rule. see https://manual.sakura.ad.jp/cloud/appliance/enhanced-lb/#enhanced-lb-rule for details
     */
    redirectLocation?: string;
    /**
     * HTTP status code for redirects sent when requests matches the rule. This must be one of [`301`/`302`]
     */
    redirectStatusCode?: string;
    /**
     * The header name that the client will send when making a request
     */
    requestHeaderName?: string;
    /**
     * The condition for the value of the request header specified by the request header name
     */
    requestHeaderValue?: string;
    /**
     * Boolean value representing whether the request header value ignores case
     */
    requestHeaderValueIgnoreCase?: boolean;
    /**
     * Boolean value representing whether to apply the rules when the request header value conditions are met or when the conditions do not match
     */
    requestHeaderValueNotMatch?: boolean;
    /**
     * IP address or CIDR block to which the rule will be applied. Multiple values can be specified by separating them with a space or comma
     */
    sourceIps?: string;
}

export interface ProxylbServer {
    /**
     * The flag to enable as destination of load balancing
     */
    enabled?: boolean;
    /**
     * The name of load balancing group. This is used when using rule-based load balancing. The length of this value must be in the range [`1`-`10`]
     */
    group?: string;
    /**
     * The IP address of the destination server
     */
    ipAddress: string;
    /**
     * The port number of the destination server. This must be in the range [`1`-`65535`]
     */
    port: number;
}

export interface ProxylbSorryServer {
    /**
     * The IP address of the SorryServer. This will be used when all servers are down
     */
    ipAddress: string;
    /**
     * The port number of the SorryServer. This will be used when all servers are down
     */
    port?: number;
}

export interface ProxylbSyslog {
    /**
     * The number of syslog port
     */
    port: number;
    /**
     * The address of syslog server
     */
    server?: string;
}

export interface ProxylbTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ServerDiskEditParameter {
    /**
     * The flag to change partition uuid
     */
    changePartitionUuid?: boolean;
    /**
     * The flag to disable password authentication
     */
    disablePwAuth?: boolean;
    /**
     * The flag to enable DHCP client
     */
    enableDhcp?: boolean;
    /**
     * The gateway address used by the Server
     */
    gateway?: string;
    /**
     * The hostname of the Server. The length of this value must be in the range [`1`-`64`]
     */
    hostname?: string;
    /**
     * The IP address to assign to the Server
     */
    ipAddress?: string;
    /**
     * The bit length of the subnet to assign to the Server
     */
    netmask?: number;
    /**
     * A list of the Note id
     *
     * @deprecated Deprecated
     */
    noteIds?: string[];
    /**
     * A list of the Note/StartupScript
     */
    notes?: outputs.ServerDiskEditParameterNote[];
    /**
     * The password of default user. The length of this value must be in the range [`8`-`64`]
     */
    password?: string;
    /**
     * A list of the SSHKey id
     */
    sshKeyIds?: string[];
    /**
     * A list of the SSHKey text
     */
    sshKeys?: string[];
}

export interface ServerDiskEditParameterNote {
    /**
     * The id of the API key to be injected into note when editing the disk
     */
    apiKeyId?: string;
    /**
     * The id of the note
     */
    id: string;
    /**
     * The value of the variable that be injected into note when editing the disk
     */
    variables?: {[key: string]: string};
}

export interface ServerNetworkInterface {
    /**
     * The MAC address
     */
    macAddress: string;
    /**
     * The id of the packet filter to attach to the network interface
     */
    packetFilterId?: string;
    /**
     * The upstream type or upstream switch id. This must be one of [`shared`/`disconnect`/`<switch id>`]
     */
    upstream: string;
    /**
     * The IP address for only display. This value doesn't affect actual NIC settings
     */
    userIpAddress: string;
}

export interface ServerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SimTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SimpleMonitorHealthCheck {
    /**
     * The SNMP community string used when checking by SNMP
     */
    community?: string;
    /**
     * The string that should be included in the response body when checking for HTTP/HTTPS
     */
    containsString?: string;
    /**
     * The expected value used when checking by DNS
     */
    excepctedData?: string;
    /**
     * The methods of invoking security for monitoring with FTPS. This must be one of [``/`implicit`/`explicit`]
     */
    ftps?: string;
    /**
     * The value of host header send when checking by HTTP/HTTPS
     */
    hostHeader?: string;
    /**
     * The flag to enable HTTP/2 when checking by HTTPS
     */
    http2?: boolean;
    /**
     * The SNMP OID used when checking by SNMP
     */
    oid?: string;
    /**
     * The password for basic auth used when checking by HTTP/HTTPS
     */
    password?: string;
    /**
     * The path used when checking by HTTP/HTTPS
     */
    path?: string;
    /**
     * The target port number
     */
    port: number;
    /**
     * The protocol used for health checks. This must be one of [`http`/`https`/`ping`/`tcp`/`dns`/`ssh`/`smtp`/`pop3`/`snmp`/`sslcertificate`/`ftp`]
     */
    protocol: string;
    /**
     * The FQDN used when checking by DNS
     */
    qname?: string;
    /**
     * The number of remaining days until certificate expiration used when checking SSL certificates. This must be in the range [`1`-`9999`]
     */
    remainingDays?: number;
    /**
     * The flag to enable SNI when checking by HTTP/HTTPS
     */
    sni?: boolean;
    /**
     * The SNMP version used when checking by SNMP. This must be one of `1`/`2c`
     */
    snmpVersion?: string;
    /**
     * The response-code to expect when checking by HTTP/HTTPS
     */
    status?: number;
    /**
     * The user name for basic auth used when checking by HTTP/HTTPS
     */
    username?: string;
    /**
     * The flag to enable hostname verification for SNI
     */
    verifySni?: boolean;
}

export interface SimpleMonitorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SshKeyGenTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SshKeyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SubnetTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SwitchTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcRouterDhcpServer {
    /**
     * A list of IP address of DNS server to assign to DHCP client
     */
    dnsServers?: string[];
    /**
     * The index of the network interface on which to enable the DHCP service. This must be in the range [`1`-`7`]
     */
    interfaceIndex: number;
    /**
     * The start value of IP address range to assign to DHCP client
     */
    rangeStart: string;
    /**
     * The end value of IP address range to assign to DHCP client
     */
    rangeStop: string;
}

export interface VpcRouterDhcpStaticMapping {
    /**
     * The static IP address to assign to DHCP client
     */
    ipAddress: string;
    /**
     * The source MAC address of static mapping
     */
    macAddress: string;
}

export interface VpcRouterDnsForwarding {
    /**
     * A list of IP address of DNS server to forward to
     */
    dnsServers?: string[];
    /**
     * The index of the network interface on which to enable the DNS forwarding service. This must be in the range [`1`-`7`]
     */
    interfaceIndex: number;
}

export interface VpcRouterFirewall {
    /**
     * The direction to apply the firewall. This must be one of [`send`/`receive`]
     */
    direction: string;
    expressions: outputs.VpcRouterFirewallExpression[];
    /**
     * The index of the network interface on which to enable filtering. This must be in the range [`0`-`7`]
     */
    interfaceIndex?: number;
}

export interface VpcRouterFirewallExpression {
    /**
     * The flag to allow the packet through the filter
     */
    allow: boolean;
    /**
     * The description of the expression. The length of this value must be in the range [`0`-`512`]
     */
    description?: string;
    /**
     * A destination IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`)
     */
    destinationNetwork?: string;
    /**
     * A destination port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`
     */
    destinationPort?: string;
    /**
     * The flag to enable packet logging when matching the expression
     */
    logging?: boolean;
    /**
     * The protocol used for filtering. This must be one of [`tcp`/`udp`/`icmp`/`ip`]
     */
    protocol: string;
    /**
     * A source IP address or CIDR block used for filtering (e.g. `192.0.2.1`, `192.0.2.0/24`)
     */
    sourceNetwork?: string;
    /**
     * A source port number or port range used for filtering (e.g. `1024`, `1024-2048`). This is only used when `protocol` is `tcp` or `udp`
     */
    sourcePort?: string;
}

export interface VpcRouterL2tp {
    /**
     * The pre shared secret for L2TP/IPsec
     */
    preSharedSecret: string;
    /**
     * The start value of IP address range to assign to L2TP/IPsec client
     */
    rangeStart: string;
    /**
     * The end value of IP address range to assign to L2TP/IPsec client
     */
    rangeStop: string;
}

export interface VpcRouterPortForwarding {
    /**
     * The description of the port forwarding. The length of this value must be in the range [`0`-`512`]
     */
    description?: string;
    /**
     * The destination ip address of the port forwarding
     */
    privateIp: string;
    /**
     * The destination port number of the port forwarding. This will be a port number on a private network
     */
    privatePort: number;
    /**
     * The protocol used for port forwarding. This must be one of [`tcp`/`udp`]
     */
    protocol: string;
    /**
     * The source port number of the port forwarding. This must be a port number on a public network
     */
    publicPort: number;
}

export interface VpcRouterPptp {
    /**
     * The start value of IP address range to assign to PPTP client
     */
    rangeStart: string;
    /**
     * The end value of IP address range to assign to PPTP client
     */
    rangeStop: string;
}

export interface VpcRouterPrivateNetworkInterface {
    /**
     * The index of the network interface. This must be in the range [`1`-`7`]
     */
    index: number;
    /**
     * A list of ip address to assign to the network interface. This is required only one value when `plan` is `standard`, two values otherwise
     */
    ipAddresses: string[];
    /**
     * The bit length of the subnet to assign to the network interface
     */
    netmask: number;
    /**
     * The id of the connected switch
     */
    switchId: string;
    /**
     * The virtual IP address to assign to the network interface. This is only required when `plan` is not `standard`
     */
    vip?: string;
}

export interface VpcRouterPublicNetworkInterface {
    /**
     * A list of ip alias to assign to the VPC Router. This can only be specified if `plan` is not `standard`
     */
    aliases?: string[];
    /**
     * The list of the IP address to assign to the VPC Router. This is required only one value when `plan` is `standard`, two values otherwise
     */
    ipAddresses?: string[];
    /**
     * The id of the switch to connect. This is only required when when `plan` is not `standard`
     */
    switchId?: string;
    /**
     * The virtual IP address of the VPC Router. This is only required when `plan` is not `standard`
     */
    vip?: string;
    /**
     * The Virtual Router Identifier. This is only required when `plan` is not `standard`
     */
    vrid?: number;
}

export interface VpcRouterScheduledMaintenance {
    /**
     * The value must be in [`sun`/`mon`/`tue`/`wed`/`thu`/`fri`/`sat`]
     */
    dayOfWeek?: string;
    /**
     * The time to start maintenance
     */
    hour?: number;
}

export interface VpcRouterSiteToSiteVpn {
    /**
     * A list of CIDR block of the network under the VPC Router
     */
    localPrefixes: string[];
    /**
     * The IP address of the opposing appliance connected to the VPC Router
     */
    peer: string;
    /**
     * The pre shared secret for the VPN. The length of this value must be in the range [`0`-`40`]
     */
    preSharedSecret: string;
    /**
     * The id of the opposing appliance connected to the VPC Router. This is typically set same as value of `peer`
     */
    remoteId: string;
    /**
     * A list of CIDR block of VPN connected networks
     */
    routes: string[];
}

export interface VpcRouterSiteToSiteVpnParameter {
    /**
     * This must be one of [`modp1024`/`modp2048`/`modp3072`/`modp4096`]
     */
    dhGroup: string;
    /**
     * This must be one of [`aes128`/`aes256`]
     */
    encryptionAlgo: string;
    esp?: outputs.VpcRouterSiteToSiteVpnParameterEsp;
    /**
     * This must be one of [`sha1`/`sha256`]
     */
    hashAlgo: string;
    ike?: outputs.VpcRouterSiteToSiteVpnParameterIke;
}

export interface VpcRouterSiteToSiteVpnParameterEsp {
    /**
     * Default: 1800
     */
    lifetime: number;
}

export interface VpcRouterSiteToSiteVpnParameterIke {
    dpd?: outputs.VpcRouterSiteToSiteVpnParameterIkeDpd;
    /**
     * Lifetime of IKE SA. Default: 28800
     */
    lifetime: number;
}

export interface VpcRouterSiteToSiteVpnParameterIkeDpd {
    /**
     * Default: 15
     */
    interval: number;
    /**
     * Default: 30
     */
    timeout: number;
}

export interface VpcRouterStaticNat {
    /**
     * The description of the static nat. The length of this value must be in the range [`0`-`512`]
     */
    description?: string;
    /**
     * The private IP address used for the static NAT
     */
    privateIp: string;
    /**
     * The public IP address used for the static NAT
     */
    publicIp: string;
}

export interface VpcRouterStaticRoute {
    /**
     * The IP address of the next hop
     */
    nextHop: string;
    /**
     * The CIDR block of destination
     */
    prefix: string;
}

export interface VpcRouterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface VpcRouterUser {
    /**
     * The user name used to authenticate remote access
     */
    name: string;
    /**
     * The password used to authenticate remote access
     */
    password: string;
}

export interface VpcRouterWireGuard {
    /**
     * The IP address for WireGuard server. This must be formatted with xxx.xxx.xxx.xxx/nn
     */
    ipAddress: string;
    peers?: outputs.VpcRouterWireGuardPeer[];
    /**
     * the public key of the WireGuard server
     */
    publicKey: string;
}

export interface VpcRouterWireGuardPeer {
    /**
     * The IP address for peer
     */
    ipAddress: string;
    /**
     * the of the peer
     */
    name: string;
    /**
     * the public key of the WireGuard client
     */
    publicKey: string;
}

