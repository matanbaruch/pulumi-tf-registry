// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApikeyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AddonMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.AddonMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.AddonMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface AddonMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AddonMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AddonSpec {
    /**
     * artifact specification of the addon
     */
    artifact?: outputs.AddonSpecArtifact;
    /**
     * namespace of the addon
     */
    namespace?: string;
    /**
     * sharing specification of the addon
     */
    sharing?: outputs.AddonSpecSharing;
    /**
     * version of the addon
     */
    version?: string;
}

export interface AddonSpecArtifact {
    artifact?: outputs.AddonSpecArtifactArtifact;
    options?: outputs.AddonSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface AddonSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.AddonSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.AddonSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.AddonSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.AddonSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.AddonSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.AddonSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.AddonSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.AddonSpecArtifactArtifactValuesRef;
}

export interface AddonSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.AddonSpecArtifactArtifactValuesRefValuesPath[];
}

export interface AddonSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.AddonSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.AddonSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface AddonSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface AddonSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface AddonSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.AddonSpecSharingProject[];
}

export interface AddonSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface AddonTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AgentMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.AgentMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.AgentMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface AgentMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AgentMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AgentSpec {
    /**
     * flag to indicate if the agent is active
     */
    active?: boolean;
    /**
     * metadata of cluster metadata
     */
    cluster?: outputs.AgentSpecCluster;
    /**
     * agent sharing configuration
     */
    sharing?: outputs.AgentSpecSharing;
    /**
     * type of agent
     */
    type?: string;
    /**
     * version of agent
     */
    version?: string;
}

export interface AgentSpecCluster {
    /**
     * name of the cluster
     */
    name?: string;
}

export interface AgentSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.AgentSpecSharingProject[];
}

export interface AgentSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface AgentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AksClusterMetadata {
    /**
     * labels for the cluster
     */
    labels?: {[key: string]: string};
    /**
     * AKS Cluster name
     */
    name: string;
    /**
     * Project for the cluster
     */
    project: string;
}

export interface AksClusterSpec {
    /**
     * Blueprint to be associated with the cluster. Default will be default-aks
     */
    blueprint?: string;
    /**
     * Blueprint version to be associated with the cluster. Default will be the latest version
     */
    blueprintversion?: string;
    /**
     * Cloud credentials provider used to create and manage the cluster.
     */
    cloudprovider: string;
    /**
     * AKS specific cluster configuration
     */
    clusterConfigs: outputs.AksClusterSpecClusterConfig[];
    /**
     * blueprint sharing configuration
     */
    sharing?: outputs.AksClusterSpecSharing;
    /**
     * Configure tolerations and nodeSelector for Rafay system components.
     */
    systemComponentsPlacement?: outputs.AksClusterSpecSystemComponentsPlacement;
    /**
     * AKS Cluster type
     */
    type: string;
}

export interface AksClusterSpecClusterConfig {
    /**
     * apiversion
     */
    apiversion: string;
    /**
     * kind
     */
    kind?: string;
    /**
     * AKS specific cluster configuration metadata
     */
    metadatas: outputs.AksClusterSpecClusterConfigMetadata[];
    /**
     * AKS specific cluster configuration spec
     */
    specs: outputs.AksClusterSpecClusterConfigSpec[];
}

export interface AksClusterSpecClusterConfigMetadata {
    /**
     * AKS cluster name
     */
    name: string;
}

export interface AksClusterSpecClusterConfigSpec {
    /**
     * The AKS managed cluster
     */
    managedClusters?: outputs.AksClusterSpecClusterConfigSpecManagedCluster[];
    /**
     * The Aks Node Pool
     */
    nodePools: outputs.AksClusterSpecClusterConfigSpecNodePool[];
    /**
     * Resource Group for the cluster
     */
    resourceGroupName: string;
    /**
     * The AKS subscription id
     */
    subscriptionId?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedCluster {
    /**
     * Additional metadata associated with the managed cluster.
     */
    additionalMetadatas?: outputs.AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadata[];
    /**
     * Azure resource managed cluster api version.
     */
    apiversion: string;
    /**
     * The AKS managed cluster extended location
     */
    extendedLocations?: outputs.AksClusterSpecClusterConfigSpecManagedClusterExtendedLocation[];
    /**
     * The AKS managed cluster extended location
     */
    identities?: outputs.AksClusterSpecClusterConfigSpecManagedClusterIdentity[];
    /**
     * AKS cluster location
     */
    location: string;
    /**
     * Properties of the managed cluster.
     */
    properties: outputs.AksClusterSpecClusterConfigSpecManagedClusterProperty[];
    /**
     * The SKU of a Managed Cluster.
     */
    skus?: outputs.AksClusterSpecClusterConfigSpecManagedClusterSkus[];
    /**
     * Resource tags
     */
    tags?: {[key: string]: string};
    /**
     * Type
     */
    type?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadata {
    /**
     * Profile for Azure Container Registry configuration
     */
    acrProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfile[];
    /**
     * If not specified, defaults to the resource group of the managed cluster. Valid only if the Log analytics workspace is specified.
     */
    omsWorkspaceLocation?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfile {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * The list of Azure Container Registry Profiles
     */
    registries?: outputs.AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry[];
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName: string;
    /**
     * The location of the Azure Container Registry resource.
     */
    resourceGroupName?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterExtendedLocation {
    /**
     * The AKS managed cluster extended location name
     */
    name?: string;
    /**
     * The AKS managed cluster extended location type
     */
    type?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterIdentity {
    /**
     * Identity type for the AKS cluster. For more information see use managed identities in AKS. Valid values are SystemAssigned, UserAssigned, None.
     */
    type?: string;
    /**
     * Arm Resource Ids
     */
    userAssignedIdentities?: {[key: string]: string};
}

export interface AksClusterSpecClusterConfigSpecManagedClusterProperty {
    /**
     * The AKS managed cluster AAD Profile
     */
    aadProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAadProfile[];
    /**
     * The AKS managed cluster addon profiles
     */
    addonProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfile[];
    /**
     * The AKS managed cluster api server access profile
     */
    apiServerAccessProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyApiServerAccessProfile[];
    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     */
    autoScalerProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAutoScalerProfile[];
    /**
     * The AKS managed cluster autoupgrade profile
     */
    autoUpgradeProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAutoUpgradeProfile[];
    /**
     * The AKS managed cluster addon profiles
     */
    disableLocalAccounts?: boolean;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}
     */
    diskEncryptionSetId?: string;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    dnsPrefix?: string;
    /**
     * (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020.
     */
    enablePodSecurityPolicy?: boolean;
    /**
     * Whether to enable Kubernetes Role-Based Access Control.
     */
    enableRbac?: boolean;
    /**
     * This cannot be updated once the Managed Cluster has been created
     */
    fqdnSubdomain?: string;
    /**
     * Cluster HTTP proxy configuration.
     */
    httpProxyConfigs?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyHttpProxyConfig[];
    /**
     * Identities associated with the cluster
     */
    identityProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfile[];
    /**
     * Kubernetes version
     */
    kubernetesVersion: string;
    /**
     * Profile for Linux VMs in the container service cluster.
     */
    linuxProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfile[];
    /**
     * Profile of network configuration.
     */
    networkProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfile[];
    /**
     * The name of the resource group containing agent pool nodes.
     */
    nodeResourceGroup?: string;
    /**
     * Aspect of pod identity integration.
     */
    podIdentityProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfile[];
    /**
     * Cluster Power State
     */
    powerStates?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPowerState[];
    /**
     * Private link resources associated with the cluster.
     */
    privateLinkResources?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPrivateLinkResource[];
    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     */
    servicePrincipalProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyServicePrincipalProfile[];
    /**
     * Profile for Windows VMs in the managed cluster.
     */
    windowsProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyWindowsProfile[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAadProfile {
    /**
     * The AKS managed cluster aad profile admin group object ids
     */
    adminGroupObjectIds?: string[];
    /**
     * The AKS managed cluster aad profile client app id
     */
    clientAppId?: string;
    /**
     * Whether or not to enable azure rbac for kubernetes authorization
     */
    enableAzureRbac?: boolean;
    /**
     * Whether or not to enable managed aad
     */
    managed?: boolean;
    /**
     * The server AAD application ID.
     */
    serverAppId?: string;
    /**
     * The AKS managed cluster aad profile server app secret
     */
    serverAppSecret?: string;
    /**
     * The AKS managed cluster tenant id
     */
    tenantId?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfile {
    /**
     * Azure Keyvault Secrets Provider for AKS
     */
    azureKeyvaultSecretsProviders?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProvider[];
    /**
     * Config for Azure Policy in Addon Profile
     */
    azurePolicies?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzurePolicy[];
    /**
     * Config for HTTP Application Routing Addon Profile
     */
    httpApplicationRoutings?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileHttpApplicationRouting[];
    /**
     * Azure Ingress Application Gateway Addon for AKS
     */
    ingressApplicationGateways?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGateway[];
    /**
     * Config for OMS Agent in Addon Profile
     */
    omsAgents?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgent[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProvider {
    /**
     * Config Azure Key Vault Secrets Provider in Addon Profile
     */
    configs?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProviderConfig[];
    /**
     * Whether to enable Azure Key Vault Secrets Provider in Addon Profile
     */
    enabled?: boolean;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProviderConfig {
    /**
     * Whether to enable Secret Rotation
     */
    enableSecretRotation: string;
    /**
     * Interval to poll for secret rotation
     */
    rotationPollInterval: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzurePolicy {
    /**
     * Config for HTTP Application Routing or Azure Policy in Addon Profile
     */
    config?: string;
    /**
     * Whether to enable HTTP Application Routing or Azure Policy in Addon Profile
     */
    enabled?: boolean;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileHttpApplicationRouting {
    /**
     * Config for HTTP Application Routing or Azure Policy in Addon Profile
     */
    config?: string;
    /**
     * Whether to enable HTTP Application Routing or Azure Policy in Addon Profile
     */
    enabled?: boolean;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGateway {
    /**
     * Config for Ingress Application Gateway in Addon Profile
     */
    configs?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGatewayConfig[];
    /**
     * Whether to enable Ingress Application Gateway in Addon Profile
     */
    enabled?: boolean;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGatewayConfig {
    /**
     * Resource Id of an existing Application Gateway to use with AGIC.
     */
    applicationGatewayId?: string;
    /**
     * Name of the application gateway to create/use in the node resource group.
     */
    applicationGatewayName?: string;
    /**
     * Subnet CIDR to use for a new subnet created to deploy the Application Gateway.
     */
    subnetCidr?: string;
    /**
     * Resource Id of an existing Subnet used to deploy the Application Gateway.
     */
    subnetId?: string;
    /**
     * Specify the namespace, which AGIC should watch. This could be a single string value, or a comma-separated list of namespaces.
     */
    watchNamespace?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgent {
    /**
     * Config for OMS Agent in Addon Profile
     */
    configs?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgentConfig[];
    /**
     * Whether to enable OMS Agent in Addon Profile
     */
    enabled?: boolean;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgentConfig {
    /**
     * ID of the log analytics workspace
     */
    logAnalyticsWorkspaceResourceId: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyApiServerAccessProfile {
    /**
     * The AKS managed cluster properties server access profile server access profile
     */
    authorizedIprRanges?: string[];
    /**
     * Enable private cluster
     */
    enablePrivateCluster?: boolean;
    /**
     * Whether or not to create additional public fqdn for private cluster
     */
    enablePrivateClusterPublicFqdn?: boolean;
    /**
     * The AKS managed cluster properties private dns zone
     */
    privateDnsZone?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAutoScalerProfile {
    /**
     * Valid values are true or false
     */
    balanceSimilarNodeGroups?: string;
    /**
     * Valid values are least-waste, most-pods, priority, random
     */
    expander?: string;
    /**
     * Max empty bulk delete
     */
    maxEmptyBulkDelete?: string;
    /**
     * Max graceful termination sec
     */
    maxGracefulTerminationSec?: string;
    /**
     * Values must be an integer followed by an m. No unit of time other than minutes (m) is supported
     */
    maxNodeProvisionTime?: string;
    /**
     * The maximum is 100 and the minimum is 0
     */
    maxTotalUnreadyPercentage?: string;
    /**
     * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age.
     */
    newPodScaleUpDelay?: string;
    /**
     * This must be an integer.
     */
    okTotalUnreadyCount?: string;
    /**
     * Values must be an integer followed by an m. No unit of time other than minutes (m) is supported
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * The default is the scan-interval. Values must be an integer followed by an m
     */
    scaleDownDelayAfterDelete?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownDelayAfterFailure?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownUnneededTime?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownUnreadyTime?: string;
    /**
     * The scale down utilization threshold
     */
    scaleDownUtilizationThreshold?: string;
    /**
     * The default is 10. Values must be an integer number of seconds
     */
    scanInterval?: string;
    /**
     * Skip nodes with local storage
     */
    skipNodesWithLocalStorage?: string;
    /**
     * Skip nodes with system pods
     */
    skipNodesWithSystemPods?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyAutoUpgradeProfile {
    /**
     * Valid values are rapid, stable, patch, node-image, none
     */
    upgradeChannel?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyHttpProxyConfig {
    /**
     * The HTTP proxy server endpoint to use.
     */
    httpProxy?: string;
    /**
     * The HTTPs proxy server endpoint to use.
     */
    httpsProxy?: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfile {
    /**
     * Kubelet Identity for managed cluster identity profile
     */
    kubeletIdentities: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfileKubeletIdentity[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfileKubeletIdentity {
    /**
     * value must be ARM resource ID in the form: /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<identity-name>
     */
    resourceId: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfile {
    /**
     * The administrator username to use for Linux VMs.
     */
    adminUsername: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * SSH configuration for Linux-based VMs running on Azure.
     */
    sshes: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSsh[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSsh {
    /**
     * The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
     */
    publicKeys: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSshPublicKeys;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSshPublicKeys {
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
     */
    keyData?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfile {
    /**
     * An IP address assigned to the Kubernetes DNS service.
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network.
     */
    dockerBridgeCidr?: string;
    /**
     * Profile of the managed cluster load balancer.
     */
    loadBalancerProfiles?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfile[];
    /**
     * Valid values are standard, basic.
     */
    loadBalancerSku?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure.
     */
    networkMode?: string;
    /**
     * Network plugin used for building the Kubernetes network. Valid values are azure, kubenet.
     */
    networkPlugin?: string;
    /**
     * Network plugin mode used for building the Azure CNI. Valid values are 'overlay'
     */
    networkPluginMode?: string;
    /**
     * Network policy used for building the Kubernetes network. Valid values are calico, azure.
     */
    networkPolicy?: string;
    /**
     * This can only be set at cluster creation time and cannot be changed later. Valid values are loadBalancer, userDefinedRouting.
     */
    outboundType?: string;
    /**
     * A CIDR notation IP range from which to assign pod IPs when kubenet is used.
     */
    podCidr?: string;
    /**
     * A CIDR notation IP range from which to assign service cluster IPs.
     */
    serviceCidr?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfile {
    /**
     * The desired number of allocated SNAT ports per VM.
     */
    allocatedOutboundPorts?: number;
    /**
     * The effective outbound IP resources of the cluster load balancer.
     */
    effectiveOutboundIps?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileEffectiveOutboundIp[];
    /**
     * Desired outbound flow idle timeout in minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    managedOutboundIps?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileManagedOutboundIp[];
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    outboundIpPrefixes?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefix[];
    /**
     * Desired outbound IP resources for the cluster load balancer.
     */
    outboundIps?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIp[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileEffectiveOutboundIp {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileManagedOutboundIp {
    /**
     * The desired number of outbound IPs created/managed by Azure for the cluster load balancer.
     */
    count?: number;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIp {
    /**
     * A list of public IP resources.
     */
    publicIps?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPublicIp[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefix {
    /**
     * A list of public IP prefix resources.
     */
    publicIpPrefixes?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefixPublicIpPrefix[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefixPublicIpPrefix {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPublicIp {
    /**
     * The fully qualified Azure resource id
     */
    id?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfile {
    /**
     * Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
     */
    allowNetworkPluginKubenet?: boolean;
    /**
     * Whether the pod identity addon is enabled.
     */
    enabled?: boolean;
    /**
     * The pod identities to use in the cluster.
     */
    userAssignedIdentities?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentity[];
    /**
     * The pod identity exceptions to allow.
     */
    userAssignedIdentityExceptions?: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityException[];
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentity {
    /**
     * The binding selector to use for the AzureIdentityBinding resource.
     */
    bindingSelector?: string;
    /**
     * Details about a user assigned identity.
     */
    identities: outputs.AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityIdentity[];
    /**
     * The name of the pod identity.
     */
    name: string;
    /**
     * The namespace of the pod identity.
     */
    namespace: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityException {
    /**
     * The name of the pod identity.
     */
    name: string;
    /**
     * The namespace of the pod identity.
     */
    namespace: string;
    /**
     * The pod labels to match.
     */
    podLabels: {[key: string]: string};
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityIdentity {
    /**
     * The client ID of the user assigned identity.
     */
    clientId?: string;
    /**
     * The object ID of the user assigned identity.
     */
    objectId?: string;
    /**
     * The resource ID of the user assigned identity.
     */
    resourceId?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPowerState {
    /**
     * Whether the cluster is running or stopped
     */
    code?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyPrivateLinkResource {
    /**
     * The group ID of the resource.
     */
    groupId?: string;
    /**
     * The ID of the private link resource.
     */
    id?: string;
    /**
     * The name of the private link resource.
     */
    name?: string;
    /**
     * The RequiredMembers of the resource
     */
    requiredMembers?: string[];
    /**
     * The resource type.
     */
    type?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyServicePrincipalProfile {
    /**
     * FORMATTED:The ID for the service principal. If specified, must be set to `[parameters('servicePrincipalClientId')]`. This would be set to the cloud credential's client ID during cluster deployment.
     */
    clientId: string;
    /**
     * The secret password associated with the service principal in plain text.
     */
    secret?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterPropertyWindowsProfile {
    /**
     * Specifies the name of the administrator account.
     */
    adminUsername: string;
    /**
     * Enable CSI proxy
     */
    enableCsiProxy?: boolean;
    /**
     * The license type to use for Windows VMs.
     */
    licenseType?: string;
}

export interface AksClusterSpecClusterConfigSpecManagedClusterSkus {
    /**
     * The name of a managed cluster SKU.
     */
    name?: string;
    /**
     * Valid values are Paid, Free.
     */
    tier?: string;
}

export interface AksClusterSpecClusterConfigSpecNodePool {
    /**
     * The AKS node pool api version
     */
    apiversion: string;
    /**
     * AKS cluster location
     */
    location: string;
    /**
     * The AKS node pool name
     */
    name: string;
    /**
     * The AKS managed cluster
     */
    properties: outputs.AksClusterSpecClusterConfigSpecNodePoolProperty[];
    /**
     * The AKS node pool type
     */
    type?: string;
}

export interface AksClusterSpecClusterConfigSpecNodePoolProperty {
    /**
     * The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is VirtualMachineScaleSets.
     */
    availabilityZones?: string[];
    /**
     * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
     */
    count?: number;
    /**
     * Whether to enable auto-scaler
     */
    enableAutoScaling?: boolean;
    /**
     * This is only supported on certain VM sizes and in certain Azure regions.
     */
    enableEncryptionAtHost?: boolean;
    /**
     * See Add a FIPS-enabled node pool for more details.
     */
    enableFips?: boolean;
    /**
     * Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see assigning a public IP per node. The default is false.
     */
    enableNodePublicIp?: boolean;
    /**
     * Whether to enable UltraSSD
     */
    enableUltraSsd?: boolean;
    /**
     * GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
     */
    gpuInstanceProfile?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    kubeletConfigs?: outputs.AksClusterSpecClusterConfigSpecNodePoolPropertyKubeletConfig[];
    /**
     * Valid values are OS, Temporary.
     */
    kubeletDiskType?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    linuxOsConfigs?: outputs.AksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfig[];
    /**
     * The maximum number of nodes for auto-scaling.
     */
    maxCount?: number;
    /**
     * The maximum number of pods that can run on a node.
     */
    maxPods?: number;
    /**
     * The minimum number of nodes for auto-scaling
     */
    minCount?: number;
    /**
     * The mode for a node pool which defines a node pool's primary function. If set as 'System', AKS prefers system pods scheduling to node pools with mode System. Accepted values: System, User
     */
    mode?: string;
    /**
     * Valid values are System, User.
     */
    nodeLabels?: {[key: string]: string};
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
     */
    nodePublicIpPrefixId?: string;
    /**
     * The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
     */
    nodeTaints?: string[];
    /**
     * The AKS node pool Kubernetes version
     */
    orchestratorVersion?: string;
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool.
     */
    osDiskSizeGb?: number;
    /**
     * Valid values are Managed, Ephemeral.
     */
    osDiskType?: string;
    /**
     * Valid values are Ubuntu, CBLMariner.
     */
    osSku?: string;
    /**
     * Valid values are Linux, Windows.
     */
    osType?: string;
    /**
     * If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    podSubnetId?: string;
    /**
     * The ID for Proximity Placement Group.
     */
    proximityPlacementGroupId?: string;
    /**
     * This cannot be specified unless the scaleSetPriority is Spot
     */
    scaleSetEvictionPolicy?: string;
    /**
     * The Virtual Machine Scale Set priority.
     */
    scaleSetPriority?: string;
    /**
     * Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see spot VMs pricing
     */
    spotMaxPrice?: number;
    /**
     * The tags to be persisted on the agent pool virtual machine scale set.
     */
    tags?: {[key: string]: string};
    /**
     * Valid values are VirtualMachineScaleSets, AvailabilitySet.
     */
    type?: string;
    /**
     * Settings for upgrading an agentpool
     */
    upgradeSettings?: outputs.AksClusterSpecClusterConfigSpecNodePoolPropertyUpgradeSetting[];
    /**
     * The AKS node pool VM size
     */
    vmSize?: string;
    /**
     * If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes.
     */
    vnetSubnetId?: string;
}

export interface AksClusterSpecClusterConfigSpecNodePoolPropertyKubeletConfig {
    /**
     * Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in *).
     */
    allowedUnsafeSysctls?: string[];
    /**
     * The maximum number of container log files that can be present for a container. The number must be ≥ 2.
     */
    containerLogMaxFiles?: number;
    /**
     * The maximum size (e.g. 10Mi) of container log file before it is rotated.
     */
    containerLogMaxSizeMb?: number;
    /**
     * The default is true.
     */
    cpuCfsQuota?: boolean;
    /**
     * Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix.
     */
    cpuCfsQuotaPeriod?: string;
    /**
     * See Kubernetes CPU management policies for more information
     */
    cpuManagerPolicy?: string;
    /**
     * If set to true it will make the Kubelet fail to start if swap is enabled on the node.
     */
    failSwapOn?: boolean;
    /**
     * To disable image garbage collection, set to 100. The default is 85%
     */
    imageGcHighThreshold?: number;
    /**
     * This cannot be set higher than imageGcHighThreshold. The default is 80%
     */
    imageGcLowThreshold?: number;
    /**
     * The maximum number of processes per pod.
     */
    podMaxPids?: number;
    /**
     * Allowed values are none, best-effort, restricted, and single-numa-node.
     */
    topologyManagerPolicy?: string;
}

export interface AksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfig {
    /**
     * The size in MB of a swap file that will be created on each node.
     */
    swapFileSizeMb?: number;
    /**
     * Sysctl settings for Linux agent nodes.
     */
    sysctls?: outputs.AksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfigSysctl[];
    /**
     * Valid values are always, defer, defer+madvise, madvise and never.
     */
    transparentHugePageDefrag?: string;
    /**
     * Valid values are always, madvise, and never.
     */
    transparentHugePageEnabled?: string;
}

export interface AksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfigSysctl {
    /**
     * Sysctl setting fs.aio-max-nr.
     */
    fsAioMaxNr?: number;
    /**
     * Sysctl setting fs.file-max.
     */
    fsFileMax?: number;
    /**
     * Sysctl setting fs.inotify.max_user_watches.
     */
    fsInotifyMaxUserWatches?: number;
    /**
     * Sysctl setting fs.nr_open.
     */
    fsNrOpen?: number;
    /**
     * Sysctl setting kernel.threads-max.
     */
    kernelThreadsMax?: number;
    /**
     * Sysctl setting net.core.netdev_max_backlog.
     */
    netCoreNetdevMaxBacklog?: number;
    /**
     * Sysctl setting net.core.optmem_max.
     */
    netCoreOptmemMax?: number;
    /**
     * Sysctl setting net.core.rmem_default.
     */
    netCoreRmemDefault?: number;
    /**
     * Sysctl setting net.core.rmem_max.
     */
    netCoreRmemMax?: number;
    /**
     * Sysctl setting net.core.somaxconn.
     */
    netCoreSomaxconn?: number;
    /**
     * Sysctl setting net.core.wmem_default.
     */
    netCoreWmemDefault?: number;
    /**
     * Sysctl setting net.core.wmem_max.
     */
    netCoreWmemMax?: number;
    /**
     * Sysctl setting net.ipv4.ip_local_port_range.
     */
    netIpv4IpLocalPortRange?: string;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh1.
     */
    netIpv4NeighDefaultGcThresh1?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh2.
     */
    netIpv4NeighDefaultGcThresh2?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh3.
     */
    netIpv4NeighDefaultGcThresh3?: number;
    /**
     * Sysctl setting net.ipv4.tcp_fin_timeout.
     */
    netIpv4TcpFinTimeout?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_probes.
     */
    netIpv4TcpKeepaliveProbes?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_time.
     */
    netIpv4TcpKeepaliveTime?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_syn_backlog.
     */
    netIpv4TcpMaxSynBacklog?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_tw_buckets.
     */
    netIpv4TcpMaxTwBuckets?: number;
    /**
     * Sysctl setting net.ipv4.tcp_tw_reuse.
     */
    netIpv4TcpTwReuse?: boolean;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_intvl.
     */
    netIpv4TcpkeepaliveIntvl?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_buckets.
     */
    netNetfilterNfConntrackBuckets?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_max.
     */
    netNetfilterNfConntrackMax?: number;
    /**
     * Sysctl setting vm.max_map_count.
     */
    vmMaxMapCount?: number;
    /**
     * Sysctl setting vm.swappiness.
     */
    vmSwappiness?: number;
    /**
     * Sysctl setting vm.vfs_cache_pressure.
     */
    vmVfsCachePressure?: number;
}

export interface AksClusterSpecClusterConfigSpecNodePoolPropertyUpgradeSetting {
    /**
     * This can either be set to an integer (e.g. 5) or a percentage (e.g. 50%)
     */
    maxSurge?: string;
}

export interface AksClusterSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.AksClusterSpecSharingProject[];
}

export interface AksClusterSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface AksClusterSpecSystemComponentsPlacement {
    /**
     * Allows users to override the default behaviour of DaemonSet for specific nodes, enabling the addition of additional tolerations for Daemonsets to match the taints available on the nodes.
     */
    daemonsetOverrides?: outputs.AksClusterSpecSystemComponentsPlacementDaemonsetOverride[];
    /**
     * Key-Value pairs insuring pods to be scheduled on desired nodes.
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Enables the kuberenetes scheduler to schedule pods with matching taints.
     */
    tolerations?: outputs.AksClusterSpecSystemComponentsPlacementToleration[];
}

export interface AksClusterSpecSystemComponentsPlacementDaemonsetOverride {
    /**
     * enables node selection
     */
    nodeSelectionEnabled?: boolean;
    /**
     * Additional tolerations for Daemonsets to match the taints available on the nodes
     */
    tolerations?: outputs.AksClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration[];
}

export interface AksClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface AksClusterSpecSystemComponentsPlacementToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface AksClusterSpecTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AksClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AksClusterV3Metadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.AksClusterV3MetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.AksClusterV3MetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface AksClusterV3MetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AksClusterV3MetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AksClusterV3Spec {
    /**
     * The blueprint to be used for this cluster. Use this for GKE/EKSABM/MKS cluster type
     */
    blueprint?: outputs.AksClusterV3SpecBlueprint;
    /**
     * The blueprint configuration to be used for this cluster. For EKS/AKS cluster types use this. But in future this will be deprecated in favor of blueprint
     */
    blueprintConfig?: outputs.AksClusterV3SpecBlueprintConfig;
    /**
     * The credentials to be used to interact with the cloud infrastructure
     */
    cloudCredentials?: string;
    config?: outputs.AksClusterV3SpecConfig;
    /**
     * Role ARN of the cross account support
     */
    crossAccountRoleArn?: string;
    /**
     * Configuration for drift handling
     */
    drift?: outputs.AksClusterV3SpecDrift;
    /**
     * The gateway details to be relayed commands for cluster operations. Use this for EKSABM cluster type
     */
    gateway?: outputs.AksClusterV3SpecGateway;
    /**
     * The proxy to be used for this cluster. Use this for GKE/MKS cluster type
     */
    proxy?: outputs.AksClusterV3SpecProxy;
    /**
     * The proxy configuration to be used for this cluster. For EKS/AKS cluster types use this. This will be deprecated in favor of proxy
     */
    proxyConfig?: outputs.AksClusterV3SpecProxyConfig;
    /**
     * Sharing spec to be used for sharing the cluster with projects
     */
    sharing?: outputs.AksClusterV3SpecSharing;
    /**
     * The system components for the placements of the workloads
     */
    systemComponentsPlacement?: outputs.AksClusterV3SpecSystemComponentsPlacement;
    /**
     * The type of the cluster this spec corresponds to
     */
    type?: string;
}

export interface AksClusterV3SpecBlueprint {
    name?: string;
    version?: string;
}

export interface AksClusterV3SpecBlueprintConfig {
    name?: string;
    version?: string;
}

export interface AksClusterV3SpecConfig {
    apiVersion?: string;
    /**
     * Control plane configuration for the cluster
     */
    controlPlane?: outputs.AksClusterV3SpecConfigControlPlane;
    /**
     * The IP address used for the control plane endpoint
     */
    controlPlaneEndpointIp?: string;
    /**
     * Kubernetes version of ControlPlane
     */
    controlPlaneVersion?: string;
    /**
     * The vSphere data center where the cluster nodes will be launched
     */
    dataCenter?: string;
    /**
     * The vSphere storage in the selected data center to launch the cluster nodes
     */
    dataStore?: string;
    /**
     * EKSA cluster configuration
     */
    eksaClusterConfig?: outputs.AksClusterV3SpecConfigEksaClusterConfig;
    /**
     * EksaBm Project name.
     */
    eksabmProject?: string;
    /**
     * GKE cluster additional features configuration.
     */
    features?: outputs.AksClusterV3SpecConfigFeatures;
    /**
     * GCP Project name.
     */
    gcpProject?: string;
    kind?: string;
    /**
     * kubernetes provider of the cluster
     */
    kubernetesProvider?: string;
    /**
     * GKE cluster location configuration.
     */
    location?: outputs.AksClusterV3SpecConfigLocation;
    /**
     * MachineHealthCheck configuration for the cluster
     */
    machineHealthChecks?: outputs.AksClusterV3SpecConfigMachineHealthCheck[];
    metadata?: outputs.AksClusterV3SpecConfigMetadata;
    /**
     * GKE cluster Network configuration.
     */
    network?: outputs.AksClusterV3SpecConfigNetwork;
    /**
     * GKE cluster node pool configuration.
     */
    nodePools?: outputs.AksClusterV3SpecConfigNodePool[];
    /**
     * Commands will be executed every time Cluster nodes come up. Example: Node Creation, Node Restart.
     */
    preBootstrapCommands?: string[];
    /**
     * provisioning environment for the cluster
     */
    provisionEnvironment?: string;
    /**
     * Proxy configuration for the cluster
     */
    proxy?: outputs.AksClusterV3SpecConfigProxy;
    raw?: string;
    /**
     * The vSphere resource pool where the cluster nodes will be launched
     */
    resourcePool?: string;
    /**
     * GKE cluster Network configuration.
     */
    security?: outputs.AksClusterV3SpecConfigSecurity;
    spec?: outputs.AksClusterV3SpecConfigSpec;
    /**
     * EKSA data center where cluster will be launched
     */
    tinkerbellDatacenterConfig?: outputs.AksClusterV3SpecConfigTinkerbellDatacenterConfig;
    /**
     * EKSA hardware configuration that will serve as nodes for the cluster
     */
    tinkerbellHardwareConfigs?: outputs.AksClusterV3SpecConfigTinkerbellHardwareConfig[];
    /**
     * EKSA machine configuration to associate control-plane/worker-node-group with users and template
     */
    tinkerbellMachineConfigs?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfig[];
    /**
     * EKSA template details that will be run as workflow for the node provisioning
     */
    tinkerbellTemplateConfigs?: outputs.AksClusterV3SpecConfigTinkerbellTemplateConfig[];
    /**
     * The certificate thumbprint for the vCenter server
     */
    vCenterCaTlsThumbprint?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmFolder?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmTemplate?: string;
    /**
     * Network configuration for the cluster
     */
    vsphereNetwork?: outputs.AksClusterV3SpecConfigVsphereNetwork;
    /**
     * Nodepools configuration for the cluster
     */
    vsphereNodePools?: outputs.AksClusterV3SpecConfigVsphereNodePool[];
    /**
     * Worker nodes configuration for the cluster
     */
    workerNodes?: outputs.AksClusterV3SpecConfigWorkerNodes;
}

export interface AksClusterV3SpecConfigControlPlane {
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * kubeadmconfig spec to run on the control plane nodes
     */
    kubeadmConfigSpec?: outputs.AksClusterV3SpecConfigControlPlaneKubeadmConfigSpec;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
}

export interface AksClusterV3SpecConfigControlPlaneKubeadmConfigSpec {
    /**
     * Files to be added to the kubeadm config
     */
    files?: outputs.AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFile[];
    /**
     * Prekubeadmcommands to run on the nodepools
     */
    preKubeadmCommands?: string[];
}

export interface AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFile {
    /**
     * Append to the file
     */
    append?: boolean;
    /**
     * Content of the file
     */
    content?: string;
    /**
     * ContentFrom
     */
    contentFrom?: outputs.AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFrom;
    /**
     * Encoding of the file
     */
    encoding?: string;
    /**
     * Owner of the file
     */
    owner?: string;
    /**
     * Path of the file
     */
    path?: string;
    /**
     * Permissions of the file
     */
    permissions?: string;
}

export interface AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFrom {
    /**
     * Secret
     */
    secret?: outputs.AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFromSecret;
}

export interface AksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFromSecret {
    /**
     * Key
     */
    key?: string;
    /**
     * Name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfig {
    /**
     * Api version of EKSA cluster resource
     */
    apiVersion?: string;
    /**
     * Kind of EKSA cluster resource
     */
    kind?: string;
    /**
     * Metadata associated with the EKSA cluster configuration
     */
    metadata?: outputs.AksClusterV3SpecConfigEksaClusterConfigMetadata;
    /**
     * Specifications of EKSA cluster configuration
     */
    spec?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpec;
}

export interface AksClusterV3SpecConfigEksaClusterConfigMetadata {
    /**
     * EKSA Cluster Annotations
     */
    annotations?: {[key: string]: string};
    /**
     * EKSA Cluster Labels
     */
    labels?: {[key: string]: string};
    /**
     * EKSA Cluster Name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpec {
    /**
     * Configuration specific to network of cluster
     */
    clusterNetwork?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetwork;
    /**
     * Specific control plane configuration for your Kubernetes cluster
     */
    controlPlaneConfiguration?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfiguration;
    /**
     * Refers to the kubernetes object with tinkerbell specific configuration
     */
    dataCenterRef?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecDataCenterRef;
    /**
     * The Kubernetes version you want to use for your cluster
     */
    kubernetesVersion?: string;
    /**
     * details of management cluster
     */
    managementCluster?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecManagementCluster;
    /**
     * This takes in a list of node groups that you can define for your workers
     */
    workerNodeGroupConfigurations?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfiguration[];
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetwork {
    /**
     * CNI plugin to be installed in the cluster. The only supported value at the moment is cilium
     */
    cniConfig?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfig;
    /**
     * Node configurations
     */
    nodes?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkNodes;
    /**
     * Pod configurations
     */
    pods?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkPods;
    /**
     * Configuration specific to setup a proxy of cluster network
     */
    proxy?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkProxy;
    /**
     * Service configurations
     */
    services?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkServices;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfig {
    /**
     * Cilium configuration
     */
    cilium?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigCilium;
    /**
     * Kindnetd configuration
     */
    kindnetd?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigKindnetd;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigCilium {
    /**
     * PolicyEnforcementMode
     */
    policyEnforcementMode?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigKindnetd {
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkNodes {
    /**
     * CidrMaskSize
     */
    cidrMaskSize?: number;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkPods {
    /**
     * Subnet used by pods in CIDR notation
     */
    cidrBlocks?: string[];
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkProxy {
    /**
     * AllowInsecureBootstrap
     */
    allowInsecureBootstrap?: boolean;
    /**
     * BootStrapCA
     */
    bootStrapCa?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * HttpProxy
     */
    httpProxy?: string;
    /**
     * HttpsProxy
     */
    httpsProxy?: string;
    /**
     * NoProxy
     */
    noProxy?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkServices {
    /**
     * Subnet used by pods in CIDR notation
     */
    cidrBlocks?: string[];
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfiguration {
    /**
     * Number of control plane nodes
     */
    count?: number;
    /**
     * Control plane endpoint details
     */
    endpoint?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationEndpoint;
    /**
     * A list of labels to apply to the control plane nodes of the cluster. This is in addition to the labels that EKS Anywhere will add by default
     */
    labels?: {[key: string]: string};
    /**
     * Refers to the Kubernetes object with Tinkerbell-specific configuration for your nodes
     */
    machineGroupRef?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationMachineGroupRef;
    /**
     * Rollout strategy for cp nodes in case of upgrade operation - currently being set to defaults
     */
    rolloutStrategy?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategy;
    /**
     * A list of taints to apply to the control plane nodes of the cluster
     */
    taints?: {[key: string]: string};
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationEndpoint {
    /**
     * A unique IP you want to use for the control plane in your EKS Anywhere cluster. Choose an IP in your network range that does not conflict with other machines.
     */
    host?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationMachineGroupRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategy {
    /**
     * Configurations related to rolling update.
     */
    rollingUpdate?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategyRollingUpdate;
    /**
     * Rollout strategy type - Default: 'RollingUpdate'.
     */
    type?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategyRollingUpdate {
    /**
     * Maximum number of machines that can be scheduled above the desired number of machines - Default: 1.
     */
    maxSurge?: number;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecDataCenterRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecManagementCluster {
    /**
     * Identifies the name of the management cluster.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfiguration {
    /**
     * Number of worker nodes
     */
    count?: number;
    /**
     * A list of labels to apply to the nodes in the worker node group. This is in addition to the labels that EKS Anywhere will add by default.
     */
    labels?: {[key: string]: string};
    /**
     * Refers to the Kubernetes object with Tinkerbell-specific configuration for your nodes
     */
    machineGroupRef?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationMachineGroupRef;
    /**
     * Worker node group's name
     */
    name?: string;
    /**
     * Rollout strategy for worker node group nodes in case of upgrade operation - currently being set to defaults
     */
    rolloutStrategy?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategy;
    /**
     * A list of taints to apply to the nodes in the worker node group. At least one node group must not have NoSchedule or NoExecute taints applied to it.
     */
    taints?: {[key: string]: string};
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationMachineGroupRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategy {
    /**
     * Configurations related to rolling update.
     */
    rollingUpdate?: outputs.AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategyRollingUpdate;
    /**
     * Rollout strategy type - Default: 'RollingUpdate'.
     */
    type?: string;
}

export interface AksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategyRollingUpdate {
    /**
     * Maximum number of machines that can be scheduled above the desired number of machines - Default: 1.
     */
    maxSurge?: number;
    /**
     * Maximum number of machines that can be unavailable during the upgrade - Default: 0.
     */
    maxUnavailable?: number;
}

export interface AksClusterV3SpecConfigFeatures {
    /**
     * List of components for cloud logging
     */
    cloudLoggingComponents?: string[];
    /**
     * List of components for cloud monitoring
     */
    cloudMonitoringComponents?: string[];
    /**
     * Application Manager is a GKE controller for managing the lifecycle of applications. It enables application delivery and updates following Kubernetes and GitOps best practices
     */
    enableApplicationManagerBeta?: boolean;
    /**
     * Backup for GKE allows you to back up and restore GKE workloads. There is no cost for enabling this feature, but you are charged for backups based on the size of the data and the number of pods you protect
     */
    enableBackupForGke?: boolean;
    /**
     * Logging collects logs emitted by your applications and by GKE infrastructure
     */
    enableCloudLogging?: boolean;
    /**
     * Monitoring collects metrics emitted by your applications and by GKE infrastructure
     */
    enableCloudMonitoring?: boolean;
    /**
     * Enable to automatically deploy and manage the Compute Engine Persistent Disk CSI Driver. This feature is an alternative to using the gcePersistentDisk in-tree volume plugin
     */
    enableComputeEnginePersistentDiskCsiDriver?: boolean;
    /**
     * Enable to automatically deploy and manage the Filestore CSI Driver
     */
    enableFilestoreCsiDriver?: boolean;
    /**
     * Image streaming allows your workloads to initialize without waiting for the entire image to download
     */
    enableImageStreaming?: boolean;
    /**
     * This option deploys managed collectors for Prometheus metrics within this cluster. These collectors must be configured using PodMonitoring resources. To enable Managed Service for Prometheus here, you'll need. Cluster version of 1.21.4-gke.300 or greater
     */
    enableManagedServicePrometheus?: boolean;
}

export interface AksClusterV3SpecConfigLocation {
    config?: outputs.AksClusterV3SpecConfigLocationConfig;
    /**
     * For Zonal cluster increase availability by selecting more than one zone. For Regional cluster By default, Kubernetes Engine runs nodes of a regional cluster across three zones within a region. Select this option if you want to manually specify the zones in which this cluster's nodes run. All zones must be within the same region.
     */
    defaultNodeLocations?: outputs.AksClusterV3SpecConfigLocationDefaultNodeLocations;
    /**
     * GKE Cluster location can be either zonal or regional
     */
    type?: string;
}

export interface AksClusterV3SpecConfigLocationConfig {
    /**
     * Regional location in which the cluster's control plane and nodes are located
     */
    region?: string;
    /**
     * Zone in the region where bootstrap VM is created for cluster provisioning
     */
    zone?: string;
}

export interface AksClusterV3SpecConfigLocationDefaultNodeLocations {
    /**
     * Enable providing default node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Increase availability by providing more than one zone. The same number of nodes will be deployed to each zone in the list.
     */
    zones?: string[];
}

export interface AksClusterV3SpecConfigMachineHealthCheck {
    /**
     * Machines selected by selector are not healthy.
     */
    maxUnHealthy?: string;
    /**
     * Name of the MachineHealthCheck
     */
    name?: string;
    /**
     * Machines older than this duration without a node will be considered to have failed and will be remediated.
     */
    nodeStartupTimeout?: string;
    /**
     * Kubeadmcontrolplane remediation strategy
     */
    remediationStrategy?: outputs.AksClusterV3SpecConfigMachineHealthCheckRemediationStrategy;
    /**
     * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider
     */
    remediationTemplate?: outputs.AksClusterV3SpecConfigMachineHealthCheckRemediationTemplate;
    /**
     * Label selector to match machines whose health will be exercised
     */
    selector?: outputs.AksClusterV3SpecConfigMachineHealthCheckSelector;
    /**
     * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy
     */
    unhealthyConditions?: outputs.AksClusterV3SpecConfigMachineHealthCheckUnhealthyCondition[];
    /**
     * UnhealthyRange specifies the range of machine health check failures that will be tolerated
     */
    unhealthyRange?: string;
}

export interface AksClusterV3SpecConfigMachineHealthCheckRemediationStrategy {
    /**
     * MaxRetry is the maximum number of remediation attempts.
     */
    maxRetry?: number;
    /**
     * MinHealthyPeriod is the minimum time to wait before remediation is attempted.
     */
    minHealthyPeriod?: string;
    /**
     * RetryPeriod is the time to wait between remediation attempts.
     */
    retryPeriod?: string;
}

export interface AksClusterV3SpecConfigMachineHealthCheckRemediationTemplate {
    /**
     * APIVersion defines the versioned schema of this representation of an object.
     */
    apiVersion?: string;
    /**
     * FieldPath is the path of the field to select in the specified API version.
     */
    fieldPath?: string;
    /**
     * Kind is a string value representing the REST resource this object represents.
     */
    kind?: string;
    /**
     * Name of the referent.
     */
    name?: string;
    /**
     * Namespace of the referent.
     */
    namespace?: string;
    /**
     * ResourceVersion is an opaque identifier that is used to distinguish between multiple versions of a same resource.
     */
    resourceVersion?: string;
    /**
     * UID is a unique id generated by the server on successful creation of a resource and is not propagated to the client.
     */
    uId?: string;
}

export interface AksClusterV3SpecConfigMachineHealthCheckSelector {
    /**
     * MatchExpressions is a list of label selector requirements.
     */
    matchExpressions?: outputs.AksClusterV3SpecConfigMachineHealthCheckSelectorMatchExpression[];
    /**
     * MatchLabels is a map of {key,value} pairs.
     */
    matchLabels?: {[key: string]: string};
}

export interface AksClusterV3SpecConfigMachineHealthCheckSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values.
     */
    operator?: string;
    /**
     * Values is an array of string values.
     */
    values?: string[];
}

export interface AksClusterV3SpecConfigMachineHealthCheckUnhealthyCondition {
    /**
     * Status indicates the state of the condition.
     */
    status?: string;
    /**
     * Timeout for the condition.
     */
    timeout?: string;
    /**
     * Type of the condition.
     */
    type?: string;
}

export interface AksClusterV3SpecConfigMetadata {
    name?: string;
}

export interface AksClusterV3SpecConfigNetwork {
    /**
     * NetworkAccess config for describing access configurations for the cluster's workload
     */
    access?: outputs.AksClusterV3SpecConfigNetworkAccess;
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    controlPlaneAuthorizedNetwork?: outputs.AksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetwork;
    /**
     * Dataplane V2 is optimized for Kubernetes networking kwhich is implemented using eBPF. Possible values: ADVANCED_DATAPATH.
     */
    dataPlaneV2?: string;
    /**
     * Dataplane V2 metrics brings better insight into the traffic between your Kubernetes workloads. Understand how your services communicate, identify issues with the network health, verify Kubernetes policies and more.
     */
    enableDataPlaneV2Metrics?: boolean;
    /**
     * Dataplane V2 observability provides Managed Hubble CLI solution that lets you observe network flows between your Kubernetes workloads in real time.
     */
    enableDataPlaneV2Observability?: boolean;
    /**
     * This feature uses alias IP and provides a more secure integration with Google Cloud Platform services
     */
    enableVpcNativetraffic?: boolean;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * Name of the network that the cluster is in. It determines which other Compute Engine resource it is able to communicate with
     */
    name?: string;
    /**
     * The Kubernetes Network Policy API allows the cluster administrator to specify what pods are allowed to communicate with each other. Possible values: CALICO
     */
    networkPolicy?: string;
    /**
     * Configuration for NetworkPolicy. This only tracks whether the addon is enabled or not on the Master,it does not track whether network policy is enabled for the nodes.
     */
    networkPolicyConfig?: boolean;
    /**
     * All pods in the cluster are assigned an IP address from this range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    podAddressRange?: string;
    /**
     * Cluster pods are assigned an IP from the selected node subnet's secondary CIDR address range.
     */
    podSecondaryRangeName?: string;
    /**
     * Cluster services will be assigned an IP address from this IP address range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    serviceAddressRange?: string;
    /**
     * Cluster services are assigned an IP from the selected node subnetes secondary CIDR address range.
     */
    serviceSecondaryRangeName?: string;
    /**
     * Subnetwork to which the Kubernetes cluster will belong. When VPC native is enabled, the subnetwork must contain at least two secondary ranges which are not used by other Kubernetes clusters. Subnet is permanent.
     */
    subnetName?: string;
}

export interface AksClusterV3SpecConfigNetworkAccess {
    config?: outputs.AksClusterV3SpecConfigNetworkAccessConfig;
    /**
     * Choose the type of network you want to allow to access your cluster's workloads. private or public
     */
    type?: string;
}

export interface AksClusterV3SpecConfigNetworkAccessConfig {
    /**
     * Control plane IP range is for the control plane VPC. The control plane range must not overlap with any subnet in your cluster's VPC. The control plane and your cluster use VPC peering to communicate privately
     */
    controlPlaneIpRange?: string;
    /**
     * To use Privately Used Public IPs (PUPI) ranges, the default source NAT used for IP masquerading needs to be disabled
     */
    disableSnat?: boolean;
    /**
     * Disabling this option locks down external access to the cluster control plane. There is still an external IP address used by Google for cluster management purposes, but the IP address is not accessible to anyone
     */
    enableAccessControlPlaneExternalIp?: boolean;
    /**
     * With control plane global access, you can access the control plane's private endpoint from any GCP region or on-premises environment no matter what the private cluster's region is
     */
    enableAccessControlPlaneGlobal?: boolean;
    /**
     * Use FirewallRule config to specify additional firewall rules. Only Private clusters are supported.By default, tcp:9443 and tcp:22281 are opened for private cluster.
     */
    firewallRules?: outputs.AksClusterV3SpecConfigNetworkAccessConfigFirewallRule[];
}

export interface AksClusterV3SpecConfigNetworkAccessConfigFirewallRule {
    action?: string;
    description?: string;
    destinationRanges?: string[];
    direction?: string;
    name?: string;
    network?: string;
    priority?: number;
    rules?: outputs.AksClusterV3SpecConfigNetworkAccessConfigFirewallRuleRule[];
    sourceRanges?: string[];
    targetTags?: string[];
}

export interface AksClusterV3SpecConfigNetworkAccessConfigFirewallRuleRule {
    ports?: string[];
    protocol?: string;
}

export interface AksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetwork {
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    authorizedNetworks?: outputs.AksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork[];
    /**
     * Enable Control Plane Authorized Network. Configure the Networks now or later.
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork {
    /**
     * CIDR Example: 198.51.100.0/24
     */
    cidr?: string;
    /**
     * Name of the Authorized Network Example: Corporate Office
     */
    name?: string;
}

export interface AksClusterV3SpecConfigNodePool {
    /**
     * Cluster autoscaler automatically creates or deletes nodes based on workload needs
     */
    autoScaling?: outputs.AksClusterV3SpecConfigNodePoolAutoScaling;
    /**
     * Choose the machine configuration that will best fit the resource needs of your cluster
     */
    machineConfig?: outputs.AksClusterV3SpecConfigNodePoolMachineConfig;
    /**
     * Node management configuration
     */
    management?: outputs.AksClusterV3SpecConfigNodePoolManagement;
    /**
     * Node metadata settings will be used when new nodes are created using this node pool
     */
    metadata?: outputs.AksClusterV3SpecConfigNodePoolMetadata;
    /**
     * Node pool names must start with a lowercase letter followed by up to 39 lowercase letters, numbers, or hyphens. They can't end with a hyphen. You cannot change the node pool's name once it's created
     */
    name?: string;
    /**
     * Node networking settings will be used when new nodes are created using this node pool
     */
    networking?: outputs.AksClusterV3SpecConfigNodePoolNetworking;
    /**
     * Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    nodeLocations?: outputs.AksClusterV3SpecConfigNodePoolNodeLocations;
    /**
     * Specify Node k8s version
     */
    nodeVersion?: string;
    /**
     * Node security settings will be used when new nodes are created using this node pool
     */
    security?: outputs.AksClusterV3SpecConfigNodePoolSecurity;
    /**
     * Pod address range limits the maximum size of the cluster
     */
    size?: number;
    /**
     * Node pool upgrade options
     */
    upgradeSettings?: outputs.AksClusterV3SpecConfigNodePoolUpgradeSettings;
}

export interface AksClusterV3SpecConfigNodePoolAutoScaling {
    /**
     * Maximum number of nodes (per zone)
     */
    maxNodes?: number;
    /**
     * Minimum number of nodes (per zone)
     */
    minNodes?: number;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfig {
    /**
     * Add accelerators to the node pool
     */
    accelerators?: outputs.AksClusterV3SpecConfigNodePoolMachineConfigAccelerator[];
    /**
     * Select Boot disk size. Boot disk size is permanent
     */
    bootDiskSize?: number;
    /**
     * Select Boot disk type. Storage space is less expensive for a standard persistent disk. An SSD persistent disk is better for random IOPS or for streaming throughput with low latency
     */
    bootDiskType?: string;
    /**
     * Choose which operating system image you want to run on each node of this cluster
     */
    imageType?: string;
    /**
     * Choose the machine type that will best fit the resource needs of your cluster
     */
    machineType?: string;
    /**
     * Zonal compute reservation to this node pool
     */
    reservationAffinity?: outputs.AksClusterV3SpecConfigNodePoolMachineConfigReservationAffinity;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfigAccelerator {
    /**
     * GPU Sharing allows you to share a single GPU device with multipe containers
     */
    acceleratorSharing?: outputs.AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing;
    /**
     * Number of GPUs
     */
    count?: number;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    gpuDriverInstallation?: outputs.AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation;
    /**
     * Size of partitions to create on the GPU. Valid values are described in the guide - https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning
     */
    gpuPartitionSize?: string;
    /**
     * GPU Type
     */
    type?: string;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing {
    /**
     * The max number of clients that can share a physical GPU device
     */
    maxSharedClients?: number;
    /**
     * The strategy to use for sharing GPUs . Example: Time-Sharing
     */
    strategy?: string;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation {
    config?: outputs.AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    type?: string;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig {
    /**
     * The version of the GPU driver to install
     */
    version?: string;
}

export interface AksClusterV3SpecConfigNodePoolMachineConfigReservationAffinity {
    /**
     * Type of reservation consumption.
     */
    consumeReservationType?: string;
    /**
     * The name of the Reservation to be consumed. Only mandatory when consumeReservationType is set to specific
     */
    reservationName?: string;
}

export interface AksClusterV3SpecConfigNodePoolManagement {
    /**
     * Whether the nodes will be automatically upgraded
     */
    autoUpgrade?: boolean;
}

export interface AksClusterV3SpecConfigNodePoolMetadata {
    /**
     * Metadata to be stored in the instance
     */
    gceInstanceMetadatas?: outputs.AksClusterV3SpecConfigNodePoolMetadataGceInstanceMetadata[];
    /**
     * Use Kubernetes labels to control how workloads are scheduled to your nodes. Labels are applied to all nodes in this node pool and cannot be changed once the cluster is created
     */
    kubernetesLabels?: outputs.AksClusterV3SpecConfigNodePoolMetadataKubernetesLabel[];
    /**
     * A node taint lets you mark a node so that the scheduler avoids or prevents using it for certain Pods. Node taints can be used with tolerations to ensure that Pods aren't scheduled onto inappropriate nodes
     */
    nodeTaints?: outputs.AksClusterV3SpecConfigNodePoolMetadataNodeTaint[];
}

export interface AksClusterV3SpecConfigNodePoolMetadataGceInstanceMetadata {
    /**
     * Key for this metadata
     */
    key?: string;
    /**
     * Value for this metadata
     */
    value?: string;
}

export interface AksClusterV3SpecConfigNodePoolMetadataKubernetesLabel {
    /**
     * Key for this kubernetes label
     */
    key?: string;
    /**
     * Value for this kubernetes lable
     */
    value?: string;
}

export interface AksClusterV3SpecConfigNodePoolMetadataNodeTaint {
    /**
     * Available effects are NoSchedule, PreferNoSchedule, NoExecute
     */
    effect?: string;
    /**
     * Key for this Taint effect
     */
    key?: string;
    /**
     * Value for this Taint effect
     */
    value?: string;
}

export interface AksClusterV3SpecConfigNodePoolNetworking {
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    networkTags?: string[];
}

export interface AksClusterV3SpecConfigNodePoolNodeLocations {
    /**
     * Enable providing node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    zones?: string[];
}

export interface AksClusterV3SpecConfigNodePoolSecurity {
    /**
     * Integrity monitoring lets you monitor and verify the runtime boot integrity of your shielded nodes using Cloud Monitoring
     */
    enableIntegrityMonitoring?: boolean;
    /**
     * Secure boot helps protect your nodes against boot-level and kernel-level malware and rootkits
     */
    enableSecureBoot?: boolean;
}

export interface AksClusterV3SpecConfigNodePoolUpgradeSettings {
    config?: outputs.AksClusterV3SpecConfigNodePoolUpgradeSettingsConfig;
    /**
     * Update strategy of the node pool. Possible values are SURGE and BLUE_GREEN
     */
    strategy?: string;
}

export interface AksClusterV3SpecConfigNodePoolUpgradeSettingsConfig {
    /**
     * Number of blue nodes to drain in a batch.
     */
    batchNodeCount?: number;
    /**
     * Soak time after each batch gets drained.
     */
    batchSoakDuration?: string;
    /**
     * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be simultaneously unavailable during the upgrade process.
     */
    maxUnavailable?: number;
    /**
     * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.
     */
    nodePoolSoakDuration?: string;
}

export interface AksClusterV3SpecConfigProxy {
    /**
     * AllowInsecureBootstrap
     */
    allowInsecureBootstrap?: boolean;
    /**
     * BootStrapCA
     */
    bootstrapCa?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * HttpProxy
     */
    httpProxy?: string;
    /**
     * HttpsProxy
     */
    httpsProxy?: string;
    /**
     * NoProxy
     */
    noProxy?: string;
    /**
     * ProxyAuth
     */
    proxyAuth?: string;
}

export interface AksClusterV3SpecConfigSecurity {
    /**
     * Google Groups for RBAC allows you to grant roles to all members of a Google Workspace group
     */
    enableGoogleGroupsForRbac?: boolean;
    /**
     * Enable legacy authorization to support in-cluster permissions for existing clusters or workflows. Prevents full RBAC support
     */
    enableLegacyAuthorization?: boolean;
    /**
     * Workload Identity lets you connect securely to Google APIs from Kubernetes Engine workloads
     */
    enableWorkloadIdentity?: boolean;
    /**
     * Clients use this base64-encoded public certificate to authenticate to the cluster endpoint. Certificates don’t rotate automatically and are difficult to revoke
     */
    issueClientCertificate?: boolean;
    /**
     * Provide the security groups here
     */
    securityGroup?: string;
}

export interface AksClusterV3SpecConfigSpec {
    managedCluster?: outputs.AksClusterV3SpecConfigSpecManagedCluster;
    nodePools?: outputs.AksClusterV3SpecConfigSpecNodePool[];
    resourceGroupName?: string;
    subscriptionId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedCluster {
    /**
     * Additional metadata associated with the managed cluster.
     */
    additionalMetadata?: outputs.AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadata;
    apiVersion?: string;
    extendedLocation?: outputs.AksClusterV3SpecConfigSpecManagedClusterExtendedLocation;
    /**
     * Identity for the managed cluster.
     */
    identity?: outputs.AksClusterV3SpecConfigSpecManagedClusterIdentity;
    /**
     * The geo-location where the resource lives
     */
    location?: string;
    /**
     * Properties of the managed cluster.
     */
    properties?: outputs.AksClusterV3SpecConfigSpecManagedClusterProperties;
    /**
     * The SKU of a Managed Cluster.
     */
    sku?: outputs.AksClusterV3SpecConfigSpecManagedClusterSku;
    /**
     * Resource tags.
     */
    tags?: {[key: string]: string};
    /**
     * Azure Resource Type
     */
    type?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadata {
    /**
     * Profile for Azure Container Registry configuration
     */
    acrProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfile;
    /**
     * If not specified, defaults to the resource group of the managed cluster. Valid only if the Log analytics workspace is specified.
     */
    omsWorkspaceLocation?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfile {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * The list of Azure Container Registry profiles.
     */
    registries?: outputs.AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry[];
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterExtendedLocation {
    /**
     * The name of the extended location.
     */
    name?: string;
    /**
     * The type of the extended location.
     */
    type?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterIdentity {
    /**
     * For more information see use managed identities in AKS. Valid values are SystemAssigned, UserAssigned, None.
     */
    type?: string;
    /**
     * The keys must be ARM resource IDs in the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
     */
    userAssignedIdentities?: {[key: string]: string};
}

export interface AksClusterV3SpecConfigSpecManagedClusterProperties {
    /**
     * For more details see https://docs.microsoft.com/azure/aks/managed-aad
     */
    aadProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAadProfile;
    /**
     * The profile of managed cluster add-on.
     */
    addonProfiles?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfiles;
    /**
     * Access profile for managed cluster API server.
     */
    apiServerAccessProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesApiServerAccessProfile;
    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     */
    autoScalerProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAutoScalerProfile;
    /**
     * Auto upgrade profile for a managed cluster.
     */
    autoUpgradeProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAutoUpgradeProfile;
    /**
     * If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see disable local accounts.
     */
    disableLocalAccounts?: boolean;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}
     */
    diskEncryptionSetId?: string;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    dnsPrefix?: string;
    /**
     * (DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy.
     */
    enablePodSecurityPolicy?: boolean;
    /**
     * Whether to enable Kubernetes Role-Based Access Control.
     */
    enableRbac?: boolean;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    fqdnSubdomain?: string;
    /**
     * Cluster HTTP proxy configuration.
     */
    httpProxyConfig?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesHttpProxyConfig;
    /**
     * Identities associated with the cluster.
     */
    identityProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfile;
    /**
     * Both patch version (e.g. 1.20.13) and (e.g. 1.20) are supported. When is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same once it has been created (e.g. 1.14.x > 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x > 1.15.x or 1.15.x > 1.16.x are allowed, however 1.14.x > 1.16.x is not allowed. See upgrading an AKS cluster for more details.
     */
    kubernetesVersion?: string;
    /**
     * Profile for Linux VMs in the container service cluster.
     */
    linuxProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfile;
    /**
     * Profile of network configuration.
     */
    networkProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfile;
    /**
     * The name of the resource group containing agent pool nodes.
     */
    nodeResourceGroup?: string;
    /**
     * See use https://learn.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity for more details on pod identity integration.
     */
    podIdentityProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfile;
    /**
     * See use https://learn.microsoft.com/en-us/azure/aks/start-stop-cluster?tabs=azure-cli for more details on cluster power state and its operations
     */
    powerState?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPowerState;
    /**
     * Private link resources associated with the cluster.
     */
    privateLinkResources?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPrivateLinkResource[];
    /**
     * Allow or deny public network access for AKS. Valid values are Enabled, Disabled.
     */
    publicNetworkAccess?: string;
    /**
     * Security profile for the container service cluster.
     */
    securityProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfile;
    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     */
    servicePrincipalProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesServicePrincipalProfile;
    /**
     * Storage profile for the container service cluster.
     */
    storageProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfile;
    /**
     * Profile for Windows VMs in the managed cluster.
     */
    windowsProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfile;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAadProfile {
    /**
     * The list of AAD group object IDs that will have admin role of the cluster.
     */
    adminGroupObjectIds?: string[];
    /**
     * The client AAD application ID.
     */
    clientAppId?: string;
    /**
     * Whether to enable Azure RBAC for Kubernetes authorization.
     */
    enableAzureRbac?: boolean;
    /**
     * Whether to enable managed AAD.
     */
    managed?: boolean;
    /**
     * The server AAD application ID.
     */
    serverAppId?: string;
    /**
     * The server AAD application secret.
     */
    serverAppSecret?: string;
    /**
     * The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
     */
    tenantId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfiles {
    azureKeyvaultSecretsProvider?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProvider;
    azurePolicy?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzurePolicy;
    httpApplicationRouting?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesHttpApplicationRouting;
    ingressApplicationGateway?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGateway;
    omsAgent?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgent;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProvider {
    config?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProviderConfig;
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProviderConfig {
    enableSecretRotation?: string;
    rotationPollInterval?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzurePolicy {
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesHttpApplicationRouting {
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGateway {
    config?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGatewayConfig;
    /**
     * whether addon profile is enabled
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGatewayConfig {
    applicationGatewayId?: string;
    applicationGatewayName?: string;
    subnetCidr?: string;
    subnetId?: string;
    watchNamespace?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgent {
    config?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgentConfig;
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgentConfig {
    logAnalyticsWorkspaceResourceId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesApiServerAccessProfile {
    /**
     * IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see API server authorized IP ranges.
     */
    authorizedIpRanges?: string[];
    /**
     * Whether to disable run command for the cluster or not.
     */
    disableRunCommand?: boolean;
    /**
     * For more details, see https://learn.microsoft.com/en-us/azure/aks/private-clusters
     */
    enablePrivateCluster?: boolean;
    /**
     * Whether to create additional public FQDN for private cluster or not.
     */
    enablePrivateClusterPublicFqdn?: boolean;
    /**
     * The default is System. For more details see configure private DNS zone. Allowed values are system and none.
     */
    privateDnsZone?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAutoScalerProfile {
    /**
     * Valid values are true and false
     */
    balanceSimilarNodeGroups?: string;
    /**
     * If not specified, the default is random. See https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders for more information. Valid values are least-waste, most-pods, priority, random.
     */
    expander?: string;
    /**
     * The default is 10.
     */
    maxEmptyBulkDelete?: string;
    /**
     * The default is 600.
     */
    maxGracefulTerminationSec?: string;
    /**
     * The default is 15m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    maxNodeProvisionTime?: string;
    /**
     * The default is 45. The maximum is 100 and the minimum is 0.
     */
    maxTotalUnreadyPercentage?: string;
    /**
     * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is 0s. Values must be an integer followed by a unit (s for seconds, m for minutes, h for hours, etc).
     */
    newPodScaleUpDelay?: string;
    /**
     * This must be an integer. The default is 3.
     */
    okTotalUnreadyCount?: string;
    /**
     * The default is 10m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * The default is the scan-interval. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterDelete?: string;
    /**
     * The default is 3m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterFailure?: string;
    /**
     * The default is 10m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownUnneededTime?: string;
    /**
     * The default is 20m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownUnreadyTime?: string;
    /**
     * The default is 0.5.
     */
    scaleDownUtilizationThreshold?: string;
    /**
     * The default is 10. Values must be an integer number of seconds.
     */
    scanInterval?: string;
    /**
     * The default is true.
     */
    skipNodesWithLocalStorage?: string;
    /**
     * The default is true.
     */
    skipNodesWithSystemPods?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesAutoUpgradeProfile {
    /**
     * For more information see https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster?tabs=azure-cli#set-auto-upgrade-channel. Valid values are rapid, stable, patch, node-image, none.
     */
    upgradeChannel?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesHttpProxyConfig {
    /**
     * The HTTP proxy server endpoint to use.
     */
    httpProxy?: string;
    /**
     * The HTTPS proxy server endpoint to use.
     */
    httpsProxy?: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfile {
    /**
     * Kubelet Identity for managed cluster identity profile
     */
    kubeletIdentity?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfileKubeletIdentity;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfileKubeletIdentity {
    /**
     * value must be ARM resource ID in the form: /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<identity-name>
     */
    resourceId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfile {
    /**
     * The administrator username to use for Linux VMs.
     */
    adminUsername?: string;
    /**
     * SSH configuration for Linux-based VMs running on Azure.
     */
    ssh?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSsh;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSsh {
    /**
     * The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
     */
    publicKeys?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSshPublicKey[];
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSshPublicKey {
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
     */
    keyData?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfile {
    /**
     * An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
     */
    dockerBridgeCidr?: string;
    /**
     * IP families are used to determine single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values are IPv4 and IPv6.
     */
    ipFamilies?: string[];
    /**
     * Profile of the managed cluster load balancer.
     */
    loadBalancerProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfile;
    /**
     * The default is standard. See Azure Load Balancer SKUs for more information about the differences between load balancer SKUs. Valid values are standard, basic.
     */
    loadBalancerSku?: string;
    /**
     * Profile of the managed cluster NAT gateway.
     */
    natGatewayProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfile;
    /**
     * Valid values are cilium
     */
    networkDataplane?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are transparent, bridge.
     */
    networkMode?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are transparent, bridge.
     */
    networkPlugin?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are overlay.
     */
    networkPluginMode?: string;
    /**
     * Network policy used for building the Kubernetes network. Valid values are calico, azure.
     */
    networkPolicy?: string;
    /**
     * This can only be set at cluster creation time and cannot be changed later. For more information see egress outbound type. Valid values are loadBalancer, userDefinedRouting, managedNATGateway, userAssignedNATGateway.
     */
    outboundType?: string;
    /**
     * A CIDR notation IP range from which to assign pod IPs when kubenet is used.
     */
    podCidr?: string;
    /**
     * One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
     */
    podCidrs?: string[];
    /**
     * A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
     */
    serviceCidr?: string;
    /**
     * One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must not overlap with any Subnet IP ranges.
     */
    serviceCidrs?: string[];
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfile {
    /**
     * The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
     */
    allocatedOutboundPorts?: number;
    /**
     * The effective outbound IP resources of the cluster load balancer.
     */
    effectiveOutboundIPs?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileEffectiveOutboundIP[];
    /**
     * Enable multiple standard load balancers per AKS cluster or not.
     */
    enableMultipleStandardLoadBalancers?: boolean;
    /**
     * Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    managedOutboundIPs?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileManagedOutboundIPs;
    /**
     * Desired outbound IP resources for the cluster load balancer.
     */
    outboundIPs?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPs;
    /**
     * Desired outbound IP Prefix resources for the cluster load balancer.
     */
    outboundIpPrefixes?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixes;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileEffectiveOutboundIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileManagedOutboundIPs {
    /**
     * The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1.
     */
    count?: number;
    /**
     * The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
     */
    countIPv6?: number;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPs {
    /**
     * A list of public IP resources.
     */
    publicIPs?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPsPublicIP[];
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPsPublicIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixes {
    /**
     * A list of public IP prefix resources.
     */
    publicIpPrefixes?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixesPublicIpPrefix[];
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixesPublicIpPrefix {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfile {
    /**
     * The effective outbound IP resources of the cluster NAT gateway.
     */
    effectiveOutboundIPs?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileEffectiveOutboundIP[];
    /**
     * Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 4 minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Profile of the managed outbound IP resources of the managed cluster.
     */
    managedOutboundIpProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileManagedOutboundIpProfile;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileEffectiveOutboundIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileManagedOutboundIpProfile {
    /**
     * The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16 (inclusive). The default value is 1.
     */
    count?: number;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfile {
    /**
     * Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See https://learn.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities for more information.
     */
    allowNetworkPluginKubenet?: boolean;
    /**
     * Whether the pod identity addon is enabled.
     */
    enabled?: boolean;
    /**
     * The pod identities to use in the cluster.
     */
    userAssignedIdentities?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentity[];
    /**
     * The pod identity exceptions to allow.
     */
    userAssignedIdentityExceptions?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityException[];
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentity {
    /**
     * The binding selector to use for the AzureIdentityBinding resource.
     */
    bindingSelector?: string;
    /**
     * Details about a user assigned identity.
     */
    identity?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityIdentity;
    /**
     * The name of the pod identity.
     */
    name?: string;
    /**
     * The namespace of the pod identity.
     */
    namespace?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityException {
    /**
     * The name of the pod identity exception.
     */
    name?: string;
    /**
     * The namespace of the pod identity exception.
     */
    namespace?: string;
    /**
     * The pod labels to match.
     */
    podLabels?: {[key: string]: string};
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityIdentity {
    /**
     * The client ID of the user assigned identity.
     */
    clientId?: string;
    /**
     * The object ID of the user assigned identity.
     */
    objectId?: string;
    /**
     * The resource ID of the user assigned identity.
     */
    resourceId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPowerState {
    /**
     * Tells whether the cluster is Running or Stopped.
     */
    code?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesPrivateLinkResource {
    /**
     * The group ID of the resource.
     */
    groupId?: string;
    /**
     * The ID of the private link resource.
     */
    id?: string;
    /**
     * The name of the private link resource.
     */
    name?: string;
    /**
     * The RequiredMembers of the resource
     */
    requiredMembers?: string[];
    /**
     * The resource type.
     */
    type?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfile {
    /**
     * Azure Key Vault key management service settings for the security profile.
     */
    azureKeyVaultKms?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileAzureKeyVaultKms;
    /**
     * Microsoft Defender settings for the security profile.
     */
    defender?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefender;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileAzureKeyVaultKms {
    /**
     * Whether to enable Azure Key Vault key management service. The default is false.
     */
    enabled?: boolean;
    /**
     * Identifier of Azure Key Vault key. See key identifier format for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.
     */
    keyId?: string;
    /**
     * Network access of key vault. The possible values are Public and Private. Public means the key vault allows public access from all networks. Private means the key vault disables public access and enables private link. The default value is Public.
     */
    keyVaultNetworkAccess?: string;
    /**
     * Resource ID of key vault. When keyVaultNetworkAccess is Private, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is Public, leave the field empty.
     */
    keyVaultResourceId?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefender {
    /**
     * Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.
     */
    logAnalyticsWorkspaceResourceId?: string;
    /**
     * Microsoft Defender settings for the security profile threat detection.
     */
    securityMonitoring?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefenderSecurityMonitoring;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefenderSecurityMonitoring {
    /**
     * Whether to enable Defender threat detection
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesServicePrincipalProfile {
    /**
     * The ID for the service principal. If specified, must be set to [parameters('servicePrincipalClientId')]. This would be set to the cloud credential's client ID during cluster deployment.
     */
    clientId?: string;
    /**
     * The secret password associated with the service principal. If specified, must be set to [parameters('servicePrincipalClientSecret')]. This would be set to the cloud credential's client secret during cluster deployment.
     */
    secret?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfile {
    /**
     * AzureDisk CSI Driver settings for the storage profile.
     */
    diskCsiDriver?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileDiskCsiDriver;
    /**
     * AzureFile CSI Driver settings for the storage profile.
     */
    fileCsiDriver?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileFileCsiDriver;
    /**
     * Snapshot Controller settings for the storage profile.
     */
    snapshotController?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileSnapshotController;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileDiskCsiDriver {
    /**
     * Whether to enable AzureDisk CSI Driver. The default value is true.
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileFileCsiDriver {
    /**
     * Whether to enable AzureFile CSI Driver. The default value is true.
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileSnapshotController {
    /**
     * Whether to enable Snapshot Controller. The default value is true.
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfile {
    /**
     * Specifies the name of the administrator account, Restriction: Cannot end in '.', Minimum-length: 1 character, Max-length: 20 characters
     */
    adminUsername?: string;
    /**
     * For more details on CSI proxy, see the CSI proxy GitHub repo.
     */
    enableCsiProxy?: boolean;
    /**
     * Windows gMSA Profile in the managed cluster.
     */
    gmsaProfile?: outputs.AksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfileGmsaProfile;
    /**
     * The license type to use for Windows VMs. See Azure Hybrid User Benefits for more details. Valid values are None, Windows_Server.
     */
    licenseType?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfileGmsaProfile {
    /**
     * Specifies the DNS server for Windows gMSA. Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
     */
    dnsServer?: string;
    /**
     * Specifies whether to enable Windows gMSA in the managed cluster.
     */
    enabled?: boolean;
    /**
     * Specifies the root domain name for Windows gMSA. Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
     */
    rootDomainName?: string;
}

export interface AksClusterV3SpecConfigSpecManagedClusterSku {
    /**
     * The name of a managed cluster SKU.
     */
    name?: string;
    /**
     * If not specified, the default is Free. See uptime SLA for more details. Valid values are Paid, Free.
     */
    tier?: string;
}

export interface AksClusterV3SpecConfigSpecNodePool {
    /**
     * Azure Api Version
     */
    apiVersion?: string;
    /**
     * The geo-location where the resource lives
     */
    location?: string;
    /**
     * The name of the agent pool.
     */
    name?: string;
    /**
     * Properties for the container service agent pool profile.
     */
    properties?: outputs.AksClusterV3SpecConfigSpecNodePoolProperties;
    /**
     * Nodepool azure resource type
     */
    type?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolProperties {
    /**
     * The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is VirtualMachineScaleSets.
     */
    availabilityZones?: string[];
    /**
     * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
     */
    count?: number;
    /**
     * Data used when creating a target resource from a source resource.
     */
    creationData?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesCreationData;
    /**
     * Whether to enable auto-scaler
     */
    enableAutoScaling?: boolean;
    /**
     * This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption
     */
    enableEncryptionAtHost?: boolean;
    /**
     * See Add a FIPS-enabled node pool for more details.
     */
    enableFips?: boolean;
    /**
     * Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see assigning a public IP per node. The default is false.
     */
    enableNodePublicIp?: boolean;
    /**
     * Whether to enable UltraSSD
     */
    enableUltraSsd?: boolean;
    /**
     * GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU. Valid values are MIG1g, MIG2g, MIG3g, MIG4g, MIG7g.
     */
    gpuInstanceProfile?: string;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see Azure dedicated hosts.
     */
    hostGroupId?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    kubeletConfig?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesKubeletConfig;
    /**
     * Valid values are OS, Temporary.
     */
    kubeletDiskType?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    linuxOsConfig?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfig;
    /**
     * The maximum number of nodes for auto-scaling
     */
    maxCount?: number;
    /**
     * The maximum number of pods that can run on a node.
     */
    maxPods?: number;
    /**
     * The minimum number of nodes for auto-scaling
     */
    minCount?: number;
    /**
     * Valid values are System, User.
     */
    mode?: string;
    /**
     * The node labels to be persisted across all nodes in agent pool.
     */
    nodeLabels?: {[key: string]: string};
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
     */
    nodePublicIpPrefixId?: string;
    /**
     * The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
     */
    nodeTaints?: string[];
    /**
     * Both patch version (e.g. 1.20.13) and (e.g. 1.20) are supported. When is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same once it has been created (e.g. 1.14.x > 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see upgrading a node pool.
     */
    orchestratorVersion?: string;
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
     */
    osDiskSizeGb?: number;
    /**
     * Valid values are Managed, Ephemeral.
     */
    osDiskType?: string;
    /**
     * Valid values are Ubuntu, CBLMariner, Windows2019, Windows2022.
     */
    osSku?: string;
    /**
     * Valid values are Linux, Windows.
     */
    osType?: string;
    /**
     * If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    podSubnetId?: string;
    /**
     * Describes the Power State of the cluster
     */
    powerState?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesPowerState;
    /**
     * The ID for Proximity Placement Group.
     */
    proximityPlacementGroupId?: string;
    /**
     * This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete. Valid values are Delete, Deallocate.
     */
    scaleDownMode?: string;
    /**
     * This cannot be specified unless the scaleSetPriority is Spot. If not specified, the default is Delete. Valid values are Delete, Deallocate.
     */
    scaleSetEvictionPolicy?: string;
    /**
     * The Virtual Machine Scale Set priority. If not specified, the default is Regular. Valid values are Spot, Regular.
     */
    scaleSetPriority?: string;
    /**
     * Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see spot VMs pricing
     */
    spotMaxPrice?: number;
    /**
     * The tags to be persisted on the agent pool virtual machine scale set.
     */
    tags?: {[key: string]: string};
    /**
     * Valid values are VirtualMachineScaleSets, AvailabilitySet.
     */
    type?: string;
    /**
     * Settings for upgrading an agentpool
     */
    upgradeSettings?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesUpgradeSettings;
    /**
     * VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions
     */
    vmSize?: string;
    /**
     * If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    vnetSubnetId?: string;
    /**
     * Valid values are OCIContainer, WasmWasi.
     */
    workloadRuntime?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesCreationData {
    /**
     * This is the ARM ID of the source object to be used to create the target object.
     */
    sourceResourceId?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesKubeletConfig {
    /**
     * Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in *).
     */
    allowedUnsafeSysctls?: string[];
    /**
     * The maximum number of container log files that can be present for a container. The number must be ≥ 2.
     */
    containerLogMaxFiles?: number;
    /**
     * The maximum size (e.g. 10Mi) of container log file before it is rotated.
     */
    containerLogMaxSizeMb?: number;
    /**
     * The default is true.
     */
    cpuCfsQuota?: boolean;
    /**
     * The default is 100ms. Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: 300ms, 2h45m. Supported units are ns, us, ms, s, m, and h.
     */
    cpuCfsQuotaPeriod?: string;
    /**
     * The default is none. See Kubernetes CPU management policies for more information. Allowed values are none and static.
     */
    cpuManagerPolicy?: string;
    /**
     * If set to true it will make the Kubelet fail to start if swap is enabled on the node.
     */
    failSwapOn?: boolean;
    /**
     * To disable image garbage collection, set to 100. The default is 85%
     */
    imageGcHighThreshold?: number;
    /**
     * This cannot be set higher than imageGcHighThreshold. The default is 80%
     */
    imageGcLowThreshold?: number;
    /**
     * The maximum number of processes per pod.
     */
    podMaxPids?: number;
    /**
     * For more information see Kubernetes Topology Manager. The default is none. Allowed values are none, best-effort, restricted, and single-numa-node.
     */
    topologyManagerPolicy?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfig {
    /**
     * The size in MB of a swap file that will be created on each node.
     */
    swapFileSizeMb?: number;
    /**
     * Sysctl settings for Linux agent nodes.
     */
    sysctls?: outputs.AksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfigSysctls;
    /**
     * Valid values are always, defer, defer+madvise, madvise and never. The default is madvise. For more information see Transparent Hugepages.
     */
    transparentHugePageDefrag?: string;
    /**
     * Valid values are always, madvise, and never. The default is always. For more information see Transparent Hugepages.
     */
    transparentHugePageEnabled?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfigSysctls {
    /**
     * Sysctl setting fs.aio-max-nr.
     */
    fsAioMaxNr?: number;
    /**
     * Sysctl setting fs.file-max.
     */
    fsFileMax?: number;
    /**
     * Sysctl setting fs.inotify.max_user_watches.
     */
    fsInotifyMaxUserWatches?: number;
    /**
     * Sysctl setting fs.nr_open.
     */
    fsNrOpen?: number;
    /**
     * Sysctl setting kernel.threads-max.
     */
    kernelThreadsMax?: number;
    /**
     * Sysctl setting net.core.netdev_max_backlog.
     */
    netCoreNetdevMaxBacklog?: number;
    /**
     * Sysctl setting net.core.optmem_max.
     */
    netCoreOptmemMax?: number;
    /**
     * Sysctl setting net.core.rmem_default.
     */
    netCoreRmemDefault?: number;
    /**
     * Sysctl setting net.core.rmem_max.
     */
    netCoreRmemMax?: number;
    /**
     * Sysctl setting net.core.somaxconn.
     */
    netCoreSomaxconn?: number;
    /**
     * Sysctl setting net.core.wmem_default.
     */
    netCoreWmemDefault?: number;
    /**
     * Sysctl setting net.core.wmem_max.
     */
    netCoreWmemMax?: number;
    /**
     * Sysctl setting net.ipv4.ip_local_port_range.
     */
    netIpv4IpLocalPortRange?: string;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh1.
     */
    netIpv4NeighDefaultGcThresh1?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh2.
     */
    netIpv4NeighDefaultGcThresh2?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh3.
     */
    netIpv4NeighDefaultGcThresh3?: number;
    /**
     * Sysctl setting net.ipv4.tcp_fin_timeout.
     */
    netIpv4TcpFinTimeout?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_probes.
     */
    netIpv4TcpKeepaliveProbes?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_time.
     */
    netIpv4TcpKeepaliveTime?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_syn_backlog.
     */
    netIpv4TcpMaxSynBacklog?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_tw_buckets.
     */
    netIpv4TcpMaxTwBuckets?: number;
    /**
     * Sysctl setting net.ipv4.tcp_tw_reuse.
     */
    netIpv4TcpTwReuse?: boolean;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_intvl.
     */
    netIpv4TcpkeepaliveIntvl?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_buckets.
     */
    netNetfilterNfConntrackBuckets?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_max.
     */
    netNetfilterNfConntrackMax?: number;
    /**
     * Sysctl setting vm.max_map_count.
     */
    vmMaxMapCount?: number;
    /**
     * Sysctl setting vm.swappiness.
     */
    vmSwappiness?: number;
    /**
     * Sysctl setting vm.vfs_cache_pressure.
     */
    vmVfsCachePressure?: number;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesPowerState {
    /**
     * Tells whether the cluster is Running or Stopped.
     */
    code?: string;
}

export interface AksClusterV3SpecConfigSpecNodePoolPropertiesUpgradeSettings {
    /**
     * This can either be set to an integer (e.g. 5) or a percentage (e.g. 50%). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 1. For more information, including best practices, see: https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade
     */
    maxSurge?: string;
}

export interface AksClusterV3SpecConfigTinkerbellDatacenterConfig {
    /**
     * APIVersion of TinkerbellDatacenterConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell datacenter configuration
     */
    metaData?: outputs.AksClusterV3SpecConfigTinkerbellDatacenterConfigMetaData;
    /**
     * Specifications of Tinkerbell datacenter configuration
     */
    spec?: outputs.AksClusterV3SpecConfigTinkerbellDatacenterConfigSpec;
}

export interface AksClusterV3SpecConfigTinkerbellDatacenterConfigMetaData {
    /**
     * Tinkerbell datacenter configuration's name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigTinkerbellDatacenterConfigSpec {
    /**
     * Optional field to replace the HookOS image.
     */
    hookImagesUrlPath?: string;
    /**
     * Optional field to replace the default Bottlerocket operating system. EKS Anywhere can only auto-import Bottlerocket. In order to use Ubuntu or Redhat, self-hosting is required.
     */
    osImageUrl?: string;
    /**
     * Required field to identify the IP address of the Tinkerbell service. This IP address must be a unique IP in the network range that does not conflict with other IPs. Once the Tinkerbell services move from the Admin machine to run on the target cluster, this IP address makes it possible for the stack to be used for future provisioning needs. When separate management and workload clusters are supported in Bare Metal, the IP address becomes a necessity.
     */
    tinkerbellIp?: string;
}

export interface AksClusterV3SpecConfigTinkerbellHardwareConfig {
    /**
     * The IP address assigned to the BMC interface on the machine.
     */
    bmcIp?: string;
    /**
     * The password associated with the bmc_username assigned to the BMC interface on the machine.
     */
    bmcPassword?: string;
    /**
     * The username assigned to the BMC interface on the machine.
     */
    bmcUserName?: string;
    /**
     * The device name of the disk on which the operating system will be installed.
     */
    disk?: string;
    /**
     * IP address of the interface that provides access (the gateway) to the Internet.
     */
    gateway?: string;
    /**
     * The hostname assigned to the machine.
     */
    hostname?: string;
    /**
     * The IP address providing access to the host computer.
     */
    ipAddress?: string;
    /**
     * The optional labels field can consist of a key/value pair to use in conjunction with the hardwareSelector field when you set up your Bare Metal configuration. The key/value pair is connected with an equal (=) sign.
     */
    labels?: string;
    /**
     * The MAC address of the network interface card (NIC) that provides access to the host computer.
     */
    mac?: string;
    /**
     * The IP address of the server that you want to provide DNS service to the cluster.
     */
    nameservers?: string;
    /**
     * The netmask associated with the ip_address value. In the example above, a /23 subnet mask is used, allowing you to use up to 510 IP addresses in that range.
     */
    netmask?: string;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfig {
    /**
     * APIVersion of TinkerbellMachineConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell machine configuration
     */
    metaData?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigMetaData;
    /**
     * Specifications of Tinkerbell machine configuration
     */
    spec?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpec;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigMetaData {
    /**
     * Tinkerbell machine configuration's name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpec {
    /**
     * Use fields under hardwareSelector to add key/value pair labels to match particular machines that you identified in tinkerbell machine configuration.
     */
    hardwareSelector?: {[key: string]: string};
    /**
     * Optional host os configurations for the EKSA kubernetes nodes.
     */
    hostOsConfiguration?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfiguration;
    /**
     * Operating system on the machine. For example, bottlerocket or ubuntu.
     */
    osFamily?: string;
    /**
     * Identifies the template that defines the actions that will be applied to the tinkerbell machine configuration.
     */
    templateRef?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecTemplateRef;
    /**
     * The name of the user you want to configure to access your virtual machines through SSH.
     */
    users?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecUser[];
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfiguration {
    /**
     * BottlerocketConfiguration.
     */
    bottlerocketConfiguration?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationBottlerocketConfiguration;
    /**
     * CertBundles.
     */
    certBundles?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationCertBundle[];
    /**
     * NTPConfiguration.
     */
    ntpConfiguration?: outputs.AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationNtpConfiguration;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationBottlerocketConfiguration {
    /**
     * Boot.
     */
    boot?: string;
    /**
     * Kernel.
     */
    kernel?: string;
    /**
     * Kubernetes.
     */
    kubernetes?: string;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationCertBundle {
    /**
     * Refers to the content of cert key in pem format.
     */
    data?: string;
    /**
     * Refers to the name of cert bundle.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationNtpConfiguration {
    /**
     * Servers.
     */
    servers?: string[];
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecTemplateRef {
    /**
     * Refers to the kind of template resource.
     */
    kind?: string;
    /**
     * Refers to the name of template resource.
     */
    name?: string;
}

export interface AksClusterV3SpecConfigTinkerbellMachineConfigSpecUser {
    /**
     * Refers to the name of user.
     */
    name?: string;
    /**
     * Public key required to ssh into the admin/cp/dp nodes.
     */
    sshAuthorizedKeys?: string[];
}

export interface AksClusterV3SpecConfigTinkerbellTemplateConfig {
    /**
     * APIVersion of TinkerbellTemplateConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell template configuration
     */
    metaData?: outputs.AksClusterV3SpecConfigTinkerbellTemplateConfigMetaData;
    /**
     * Refer https://anywhere.eks.amazonaws.com/docs/getting-started/baremetal/bare-spec/#tinkerbelltemplateconfig-fields
     */
    spec?: string;
}

export interface AksClusterV3SpecConfigTinkerbellTemplateConfigMetaData {
    /**
     * tinkerbell template configuration's name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigVsphereNetwork {
    /**
     * CNI configuration
     */
    cni?: outputs.AksClusterV3SpecConfigVsphereNetworkCni;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    devices?: outputs.AksClusterV3SpecConfigVsphereNetworkDevice[];
    /**
     * The pod CIDR blocks for the cluster nodes
     */
    podCidrBlocks?: string[];
}

export interface AksClusterV3SpecConfigVsphereNetworkCni {
    /**
     * CNI name
     */
    name?: string;
    /**
     * CNI version
     */
    version?: string;
}

export interface AksClusterV3SpecConfigVsphereNetworkDevice {
    /**
     * Enable DHCP for the network
     */
    dhcp?: boolean;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    networkName?: string;
}

export interface AksClusterV3SpecConfigVsphereNodePool {
    /**
     * The vSphere data center where the cluster nodes will be launched
     */
    dataCenter?: string;
    /**
     * The vSphere storage in the selected data center to launch the cluster nodes
     */
    dataStore?: string;
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * kubeadmconfig spec to run on the control plane nodes
     */
    kubeadmConfigSpec?: outputs.AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpec;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Nodepool name
     */
    name?: string;
    /**
     * Network configuration for the cluster
     */
    network?: outputs.AksClusterV3SpecConfigVsphereNodePoolNetwork;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * The Operating System of the nodes
     */
    os?: string;
    /**
     * The vSphere resource pool in the selected data center to launch the cluster nodes
     */
    resourcePool?: string;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmTemplate?: string;
}

export interface AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpec {
    /**
     * Files to be added to the kubeadm config
     */
    files?: outputs.AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFile[];
    /**
     * Prekubeadmcommands to run on the nodepools
     */
    preKubeadmCommands?: string[];
}

export interface AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFile {
    /**
     * Append to the file
     */
    append?: boolean;
    /**
     * Content of the file
     */
    content?: string;
    /**
     * ContentFrom
     */
    contentFrom?: outputs.AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFrom;
    /**
     * Encoding of the file
     */
    encoding?: string;
    /**
     * Owner of the file
     */
    owner?: string;
    /**
     * Path of the file
     */
    path?: string;
    /**
     * Permissions of the file
     */
    permissions?: string;
}

export interface AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFrom {
    /**
     * Secret
     */
    secret?: outputs.AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFromSecret;
}

export interface AksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFromSecret {
    /**
     * Key
     */
    key?: string;
    /**
     * Name
     */
    name?: string;
}

export interface AksClusterV3SpecConfigVsphereNodePoolNetwork {
    /**
     * CNI configuration
     */
    cni?: outputs.AksClusterV3SpecConfigVsphereNodePoolNetworkCni;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    devices?: outputs.AksClusterV3SpecConfigVsphereNodePoolNetworkDevice[];
    /**
     * The pod CIDR blocks for the cluster nodes
     */
    podCidrBlocks?: string[];
}

export interface AksClusterV3SpecConfigVsphereNodePoolNetworkCni {
    /**
     * CNI name
     */
    name?: string;
    /**
     * CNI version
     */
    version?: string;
}

export interface AksClusterV3SpecConfigVsphereNodePoolNetworkDevice {
    /**
     * Enable DHCP for the network
     */
    dhcp?: boolean;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    networkName?: string;
}

export interface AksClusterV3SpecConfigWorkerNodes {
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
}

export interface AksClusterV3SpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface AksClusterV3SpecGateway {
    id?: string;
    name?: string;
}

export interface AksClusterV3SpecProxy {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface AksClusterV3SpecProxyConfig {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface AksClusterV3SpecSharing {
    enabled?: boolean;
    projects?: outputs.AksClusterV3SpecSharingProject[];
}

export interface AksClusterV3SpecSharingProject {
    name?: string;
}

export interface AksClusterV3SpecSystemComponentsPlacement {
    daemonSetOverride?: outputs.AksClusterV3SpecSystemComponentsPlacementDaemonSetOverride;
    nodeSelector?: {[key: string]: string};
    tolerations?: outputs.AksClusterV3SpecSystemComponentsPlacementToleration[];
}

export interface AksClusterV3SpecSystemComponentsPlacementDaemonSetOverride {
    nodeSelectionEnabled?: boolean;
    tolerations?: outputs.AksClusterV3SpecSystemComponentsPlacementDaemonSetOverrideToleration[];
}

export interface AksClusterV3SpecSystemComponentsPlacementDaemonSetOverrideToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface AksClusterV3SpecSystemComponentsPlacementToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface AksClusterV3Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface AlertconfigMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.AlertconfigMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.AlertconfigMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface AlertconfigMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AlertconfigMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface AlertconfigSpec {
    /**
     * List of the alerts to be subscribed
     */
    alerts?: outputs.AlertconfigSpecAlerts;
    /**
     * List of the emails to be subscribed
     */
    emails?: string[];
}

export interface AlertconfigSpecAlerts {
    agentHealth?: boolean;
    cluster?: boolean;
    node?: boolean;
    pod?: boolean;
    pvc?: boolean;
}

export interface AlertconfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface BlueprintMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.BlueprintMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.BlueprintMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface BlueprintMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface BlueprintMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface BlueprintSpec {
    /**
     * blueprint base
     */
    base?: outputs.BlueprintSpecBase;
    /**
     * Criticality of addon components
     */
    componentsCriticalities?: outputs.BlueprintSpecComponentsCriticality[];
    /**
     * cost profile details
     */
    costProfile?: outputs.BlueprintSpecCostProfile;
    /**
     * custom addon configuration
     */
    customAddons?: outputs.BlueprintSpecCustomAddon[];
    /**
     * default addon configuration
     */
    defaultAddons?: outputs.BlueprintSpecDefaultAddons;
    /**
     * blueprint drift configuration
     */
    drift?: outputs.BlueprintSpecDrift;
    /**
     * webhook config details
     */
    driftWebhook?: outputs.BlueprintSpecDriftWebhook;
    /**
     * namespace config
     */
    namespaceConfig?: outputs.BlueprintSpecNamespaceConfig;
    /**
     * network policy and version details
     */
    networkPolicy?: outputs.BlueprintSpecNetworkPolicy;
    /**
     * opa policy and version details
     */
    opaPolicy?: outputs.BlueprintSpecOpaPolicy;
    /**
     * blueprint placement
     */
    placement?: outputs.BlueprintSpecPlacement;
    /**
     * private  kubernetes API proxy networks
     */
    privateKubeApiProxies?: outputs.BlueprintSpecPrivateKubeApiProxy[];
    /**
     * blueprint PSP configuration
     */
    psp?: outputs.BlueprintSpecPsp;
    /**
     * service mesh profile and policies details
     */
    serviceMesh?: outputs.BlueprintSpecServiceMesh;
    /**
     * blueprint sharing configuration
     */
    sharing?: outputs.BlueprintSpecSharing;
    /**
     * Blueprint Type
     */
    type?: string;
    /**
     * version of the blueprint
     */
    version?: string;
}

export interface BlueprintSpecBase {
    /**
     * name of the blueprint base
     */
    name?: string;
    /**
     * version of the blueprint base
     */
    version?: string;
}

export interface BlueprintSpecComponentsCriticality {
    /**
     * Component Type of the blueprint list resource
     */
    componentType?: string;
    /**
     * Dependent resources
     */
    dependsOns?: string[];
    /**
     * Check for Global resource
     */
    isGlobal?: boolean;
    /**
     * API Version of the blueprint list resource
     */
    name?: string;
    /**
     * Published Generation of the blueprint list resource
     */
    publishedGeneration?: string;
    /**
     * Revision of the blueprint list resource
     */
    revision?: string;
    /**
     * Selector of the blueprint list resource
     */
    selector?: string;
    /**
     * Version of the blueprint list resource
     */
    version?: string;
    /**
     * Workload ID of the blueprint list resource
     */
    workloadId?: string;
}

export interface BlueprintSpecCostProfile {
    /**
     * name of the cost profile
     */
    name?: string;
    /**
     * version of the cost profile
     */
    version?: string;
}

export interface BlueprintSpecCustomAddon {
    /**
     * other addons current addons depends on
     */
    dependsOns?: string[];
    /**
     * name of the blueprint addon
     */
    name?: string;
    /**
     * version of the blueprint addon
     */
    version?: string;
}

export interface BlueprintSpecDefaultAddons {
    /**
     * Secret Store CSI Driver Customization details
     */
    csiSecretStoreConfig?: outputs.BlueprintSpecDefaultAddonsCsiSecretStoreConfig;
    /**
     * enable csi secret store
     */
    enableCsiSecretStore?: boolean;
    /**
     * enable default ingress
     */
    enableIngress?: boolean;
    /**
     * enable default logging
     */
    enableLogging?: boolean;
    /**
     * enable default monitoring
     */
    enableMonitoring?: boolean;
    /**
     * enable rook ceph storage
     */
    enableRookCeph?: boolean;
    /**
     * enable virtual machine workloads
     */
    enableVm?: boolean;
    /**
     * default monitoring configuration
     */
    monitoring?: outputs.BlueprintSpecDefaultAddonsMonitoring;
}

export interface BlueprintSpecDefaultAddonsCsiSecretStoreConfig {
    enableSecretRotation?: boolean;
    providers?: outputs.BlueprintSpecDefaultAddonsCsiSecretStoreConfigProviders;
    rotationPollInterval?: string;
    syncSecrets?: boolean;
}

export interface BlueprintSpecDefaultAddonsCsiSecretStoreConfigProviders {
    aws?: boolean;
    vault?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoring {
    /**
     * Helm Exporter Configuration
     */
    helmExporter?: outputs.BlueprintSpecDefaultAddonsMonitoringHelmExporter;
    /**
     * Kubernetes State Metrics Configuration
     */
    kubeStateMetrics?: outputs.BlueprintSpecDefaultAddonsMonitoringKubeStateMetrics;
    /**
     * Metrics Server Configuration
     */
    metricsServer?: outputs.BlueprintSpecDefaultAddonsMonitoringMetricsServer;
    /**
     * Node Exporter Configuration
     */
    nodeExporter?: outputs.BlueprintSpecDefaultAddonsMonitoringNodeExporter;
    /**
     * Prometheus Adapter Configuration
     */
    prometheusAdapter?: outputs.BlueprintSpecDefaultAddonsMonitoringPrometheusAdapter;
    /**
     * Prometheus Resources
     */
    resources?: outputs.BlueprintSpecDefaultAddonsMonitoringResources;
}

export interface BlueprintSpecDefaultAddonsMonitoringHelmExporter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.BlueprintSpecDefaultAddonsMonitoringHelmExporterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoringHelmExporterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface BlueprintSpecDefaultAddonsMonitoringKubeStateMetrics {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.BlueprintSpecDefaultAddonsMonitoringKubeStateMetricsDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoringKubeStateMetricsDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface BlueprintSpecDefaultAddonsMonitoringMetricsServer {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.BlueprintSpecDefaultAddonsMonitoringMetricsServerDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoringMetricsServerDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface BlueprintSpecDefaultAddonsMonitoringNodeExporter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.BlueprintSpecDefaultAddonsMonitoringNodeExporterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoringNodeExporterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface BlueprintSpecDefaultAddonsMonitoringPrometheusAdapter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.BlueprintSpecDefaultAddonsMonitoringPrometheusAdapterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface BlueprintSpecDefaultAddonsMonitoringPrometheusAdapterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface BlueprintSpecDefaultAddonsMonitoringResources {
    /**
     * limits for the resources
     */
    limits?: outputs.BlueprintSpecDefaultAddonsMonitoringResourcesLimits;
}

export interface BlueprintSpecDefaultAddonsMonitoringResourcesLimits {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface BlueprintSpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface BlueprintSpecDriftWebhook {
    /**
     * enable drift
     */
    enabled?: boolean;
}

export interface BlueprintSpecNamespaceConfig {
    /**
     * flag to enable namespace sync
     */
    enableSync?: boolean;
    /**
     * Synchronizing type as managed or unmanaged namespace
     */
    syncType?: string;
}

export interface BlueprintSpecNetworkPolicy {
    /**
     * name and version of cluster network policy
     */
    policies?: outputs.BlueprintSpecNetworkPolicyPolicy[];
    /**
     * name and version of network profile
     */
    profile?: outputs.BlueprintSpecNetworkPolicyProfile;
}

export interface BlueprintSpecNetworkPolicyPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface BlueprintSpecNetworkPolicyProfile {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface BlueprintSpecOpaPolicy {
    /**
     * policy configuration
     */
    opaPolicies?: outputs.BlueprintSpecOpaPolicyOpaPolicy[];
    /**
     * profile configuration
     */
    profile?: outputs.BlueprintSpecOpaPolicyProfile;
}

export interface BlueprintSpecOpaPolicyOpaPolicy {
    /**
     * name of the opa policy
     */
    name?: string;
    /**
     * version of the opa policy
     */
    version?: string;
}

export interface BlueprintSpecOpaPolicyProfile {
    /**
     * name of the opa profile
     */
    name?: string;
    /**
     * version of the opa profile
     */
    version?: string;
}

export interface BlueprintSpecPlacement {
    /**
     * Bool value of autoPublish
     */
    autoPublish?: boolean;
    /**
     * Array of Fleet value
     */
    fleetValues?: string[];
}

export interface BlueprintSpecPrivateKubeApiProxy {
    /**
     * name of the kubernetes proxy network
     */
    name?: string;
}

export interface BlueprintSpecPsp {
    /**
     * flag to specify if PSP is enabled for blueprint
     */
    enabled?: boolean;
    /**
     * names of the PSPs to be added for the blueprint
     */
    names?: string[];
    /**
     * scope of the PSP for the blueprint
     */
    scope?: string;
}

export interface BlueprintSpecServiceMesh {
    /**
     * name and version of cluster mesh policy
     */
    policies?: outputs.BlueprintSpecServiceMeshPolicy[];
    /**
     * name and version of service mesh profile
     */
    profile?: outputs.BlueprintSpecServiceMeshProfile;
}

export interface BlueprintSpecServiceMeshPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface BlueprintSpecServiceMeshProfile {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface BlueprintSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.BlueprintSpecSharingProject[];
}

export interface BlueprintSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface BlueprintTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CatalogMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.CatalogMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.CatalogMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface CatalogMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CatalogMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CatalogSpec {
    /**
     * flag to indicate if the catalog is synced periodically
     */
    autoSync?: boolean;
    /**
     * icon url of catalog
     */
    iconUrl?: string;
    /**
     * catalog helm repository name
     */
    repository?: string;
    /**
     * catalog sharing configuration
     */
    sharing?: outputs.CatalogSpecSharing;
    /**
     * type of catalog
     */
    type?: string;
}

export interface CatalogSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.CatalogSpecSharingProject[];
}

export interface CatalogSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface CatalogTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ChargebackCommonServicesPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ChargebackCommonServicesPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ChargebackCommonServicesPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ChargebackCommonServicesPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackCommonServicesPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackCommonServicesPolicySpec {
    /**
     * Cluster Labels for which the policy is being defined
     */
    clusterLabels?: outputs.ChargebackCommonServicesPolicySpecClusterLabel[];
    /**
     * Cluster Names for which the policy is being defined
     */
    clusters?: string[];
    /**
     * Namespace Labels for the namespaces that are common services
     */
    commonServicesNamespaceLabels?: outputs.ChargebackCommonServicesPolicySpecCommonServicesNamespaceLabel[];
    /**
     * Namespaces that are common services
     */
    commonServicesNamespaces?: string[];
    /**
     * Project for which the policy is being defined for
     */
    policyProject?: string;
    /**
     * Cluster Selection based on clusterLabels or clusterNames
     */
    selectionType?: string;
}

export interface ChargebackCommonServicesPolicySpecClusterLabel {
    /**
     * key
     */
    key?: string;
    /**
     * cluster
     */
    value?: string;
}

export interface ChargebackCommonServicesPolicySpecCommonServicesNamespaceLabel {
    /**
     * key
     */
    key?: string;
    /**
     * cluster
     */
    value?: string;
}

export interface ChargebackCommonServicesPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ChargebackGroupMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ChargebackGroupMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ChargebackGroupMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ChargebackGroupMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackGroupMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackGroupReportMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ChargebackGroupReportMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ChargebackGroupReportMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ChargebackGroupReportMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackGroupReportMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackGroupReportSpec {
    /**
     * endDate
     */
    endDate?: outputs.ChargebackGroupReportSpecEndDate;
    /**
     * groupName
     */
    groupName?: string;
    /**
     * reportLocation
     */
    reportLocation?: string;
    /**
     * reportUrl
     */
    reportUrl?: string;
    /**
     * startDate
     */
    startDate?: outputs.ChargebackGroupReportSpecStartDate;
    /**
     * urlExpiry
     */
    urlExpiry?: string;
}

export interface ChargebackGroupReportSpecEndDate {
    nanos?: number;
    seconds?: number;
}

export interface ChargebackGroupReportSpecStartDate {
    nanos?: number;
    seconds?: number;
}

export interface ChargebackGroupReportTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ChargebackGroupSpec {
    /**
     * aggregate
     */
    aggregate?: outputs.ChargebackGroupSpecAggregate;
    /**
     * exclusions
     */
    exclusions?: outputs.ChargebackGroupSpecExclusion[];
    /**
     * inclusions
     */
    inclusions?: outputs.ChargebackGroupSpecInclusion[];
    /**
     * type
     */
    type?: string;
}

export interface ChargebackGroupSpecAggregate {
    /**
     * cluster
     */
    cluster?: boolean;
    /**
     * label
     */
    labels?: string[];
    /**
     * namespace
     */
    namespace?: boolean;
    /**
     * namespace label
     */
    namespaceLabels?: string[];
    /**
     * project
     */
    project?: boolean;
}

export interface ChargebackGroupSpecExclusion {
    /**
     * cluster
     */
    cluster?: string;
    /**
     * clusterName
     */
    clusterName?: string;
    /**
     * label
     */
    labels?: string[];
    /**
     * namespace
     */
    namespace?: string;
    /**
     * project
     */
    project?: string;
    /**
     * projectName
     */
    projectName?: string;
}

export interface ChargebackGroupSpecInclusion {
    /**
     * cluster
     */
    cluster?: string;
    /**
     * clusterName
     */
    clusterName?: string;
    /**
     * label
     */
    labels?: string[];
    /**
     * namespace
     */
    namespace?: string;
    /**
     * project
     */
    project?: string;
    /**
     * projectName
     */
    projectName?: string;
}

export interface ChargebackGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ChargebackShareMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ChargebackShareMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ChargebackShareMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ChargebackShareMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackShareMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ChargebackShareSpec {
    /**
     * shareCommonServicesCost
     */
    shareCommonServicesCost?: boolean;
    /**
     * shareControlPlaneCost
     */
    shareControlPlaneCost?: boolean;
    /**
     * shareType
     */
    shareType?: string;
    /**
     * shareUnallocatedCost
     */
    shareUnallocatedCost?: boolean;
}

export interface ChargebackShareTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudCredentialTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CloudCredentialsV3Metadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.CloudCredentialsV3MetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.CloudCredentialsV3MetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface CloudCredentialsV3MetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CloudCredentialsV3MetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CloudCredentialsV3Spec {
    credentials?: outputs.CloudCredentialsV3SpecCredentials;
    /**
     * Provider of Credential Access
     */
    provider?: string;
    secret?: outputs.CloudCredentialsV3SpecSecret;
    /**
     * sharing specification of the Credentials
     */
    sharing?: outputs.CloudCredentialsV3SpecSharing;
    /**
     * Type of Credentials Access
     */
    type?: string;
}

export interface CloudCredentialsV3SpecCredentials {
    accessId?: string;
    accountId?: string;
    /**
     * Rafay agents
     */
    agents?: outputs.CloudCredentialsV3SpecCredentialsAgent[];
    arn?: string;
    clientId?: string;
    clientSecret?: string;
    externalId?: string;
    /**
     * Blob content of GCP Credentials Access JSON file
     */
    file?: string;
    gatewayId?: string;
    passphrase?: string;
    password?: string;
    port?: string;
    privateKey?: string;
    secretKey?: string;
    sessionToken?: string;
    subscriptionId?: string;
    tenantId?: string;
    /**
     * Type of AWS Credentials Access
     */
    type?: string;
    username?: string;
    vsphereServer?: string;
}

export interface CloudCredentialsV3SpecCredentialsAgent {
    /**
     * name of the agent
     */
    name?: string;
    /**
     * Project where agent is created
     */
    project?: string;
}

export interface CloudCredentialsV3SpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.CloudCredentialsV3SpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface CloudCredentialsV3SpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.CloudCredentialsV3SpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface CloudCredentialsV3SpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface CloudCredentialsV3SpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.CloudCredentialsV3SpecSharingProject[];
}

export interface CloudCredentialsV3SpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface CloudCredentialsV3Timeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterMeshPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ClusterMeshPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ClusterMeshPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ClusterMeshPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterMeshPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterMeshPolicySpec {
    /**
     * Group of cluster policy rules
     */
    rules?: outputs.ClusterMeshPolicySpecRule[];
    /**
     * cluster policy sharing configuration
     */
    sharing?: outputs.ClusterMeshPolicySpecSharing;
    /**
     * version of the cluster policy
     */
    version?: string;
}

export interface ClusterMeshPolicySpecRule {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ClusterMeshPolicySpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ClusterMeshPolicySpecSharingProject[];
}

export interface ClusterMeshPolicySpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ClusterMeshPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterMeshRuleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ClusterMeshRuleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ClusterMeshRuleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ClusterMeshRuleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterMeshRuleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterMeshRuleSpec {
    /**
     * cluster mesh rule artifact specification
     */
    artifact?: outputs.ClusterMeshRuleSpecArtifact;
    /**
     * cluster mesh rule sharing configuration
     */
    sharing?: outputs.ClusterMeshRuleSpecSharing;
    /**
     * version of the cluster mesh rule
     */
    version?: string;
}

export interface ClusterMeshRuleSpecArtifact {
    artifact?: outputs.ClusterMeshRuleSpecArtifactArtifact;
    options?: outputs.ClusterMeshRuleSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.ClusterMeshRuleSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.ClusterMeshRuleSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.ClusterMeshRuleSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.ClusterMeshRuleSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.ClusterMeshRuleSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.ClusterMeshRuleSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesRef;
}

export interface ClusterMeshRuleSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPath[];
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterMeshRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterMeshRuleSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface ClusterMeshRuleSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ClusterMeshRuleSpecSharingProject[];
}

export interface ClusterMeshRuleSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ClusterMeshRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterNetworkPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ClusterNetworkPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ClusterNetworkPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ClusterNetworkPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterNetworkPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterNetworkPolicyRuleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ClusterNetworkPolicyRuleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ClusterNetworkPolicyRuleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ClusterNetworkPolicyRuleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterNetworkPolicyRuleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ClusterNetworkPolicyRuleSpec {
    /**
     * cluster network rule artifact specification
     */
    artifact?: outputs.ClusterNetworkPolicyRuleSpecArtifact;
    /**
     * cluster policy rule sharing configuration
     */
    sharing?: outputs.ClusterNetworkPolicyRuleSpecSharing;
    /**
     * version of the cluster policy rule
     */
    version?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifact {
    artifact?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifact;
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRef;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPath[];
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ClusterNetworkPolicyRuleSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface ClusterNetworkPolicyRuleSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ClusterNetworkPolicyRuleSpecSharingProject[];
}

export interface ClusterNetworkPolicyRuleSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ClusterNetworkPolicyRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterNetworkPolicySpec {
    /**
     * Group of cluster policy rules
     */
    rules?: outputs.ClusterNetworkPolicySpecRule[];
    /**
     * cluster policy sharing configuration
     */
    sharing?: outputs.ClusterNetworkPolicySpecSharing;
    /**
     * version of the cluster policy
     */
    version?: string;
}

export interface ClusterNetworkPolicySpecRule {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ClusterNetworkPolicySpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ClusterNetworkPolicySpecSharingProject[];
}

export interface ClusterNetworkPolicySpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ClusterNetworkPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterOverrideMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * description of the resource
     */
    description?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ClusterOverrideSpec {
    /**
     * Override Type YAML or HELM
     */
    artifactType?: string;
    /**
     * placement specification of the override resource
     */
    clusterPlacement?: outputs.ClusterOverrideSpecClusterPlacement;
    /**
     * cluster selector
     */
    clusterSelector?: string;
    /**
     * override value
     */
    overrideValues?: string;
    /**
     * resource selector
     */
    resourceSelector?: string;
    /**
     * override type, accepted values are *ClusterOverrideTypeoverride*, *ClusterOverrideTypeAddon*, *ClusterOverrideTypeNamespace*, *ClusterOverrideTypeBlueprint*
     */
    type?: string;
    /**
     * value repo ref
     */
    valueRepoRef?: string;
    /**
     * repo information override values
     */
    valuesRepoArtifactMeta?: outputs.ClusterOverrideSpecValuesRepoArtifactMeta;
}

export interface ClusterOverrideSpecClusterPlacement {
    /**
     * list of labels for placement
     */
    clusterLabels?: outputs.ClusterOverrideSpecClusterPlacementClusterLabel[];
    /**
     * Kubernetes style label selector
     */
    clusterSelector?: string;
    /**
     * node grouping keys
     */
    nodeGroupingKeys?: string[];
    /**
     * placement type, value ClusterSelector
     */
    placementType?: string;
}

export interface ClusterOverrideSpecClusterPlacementClusterLabel {
    /**
     * Key of the placement label
     */
    key?: string;
    /**
     * Value of the placement label
     */
    value?: string;
}

export interface ClusterOverrideSpecValuesRepoArtifactMeta {
    /**
     * git options
     */
    gitOptions?: outputs.ClusterOverrideSpecValuesRepoArtifactMetaGitOption[];
    /**
     * helm options
     */
    helmOptions?: outputs.ClusterOverrideSpecValuesRepoArtifactMetaHelmOption[];
    /**
     * timeouts
     */
    timeouts?: number;
}

export interface ClusterOverrideSpecValuesRepoArtifactMetaGitOption {
    /**
     * repository revision
     */
    repoArtifactFiles?: outputs.ClusterOverrideSpecValuesRepoArtifactMetaGitOptionRepoArtifactFile[];
    /**
     * repository revision
     */
    revision?: string;
}

export interface ClusterOverrideSpecValuesRepoArtifactMetaGitOptionRepoArtifactFile {
    /**
     * file type
     */
    fileType?: string;
    /**
     * name
     */
    name?: string;
    /**
     * file path
     */
    relativePath?: string;
}

export interface ClusterOverrideSpecValuesRepoArtifactMetaHelmOption {
    /**
     * chart name
     */
    chartName?: string;
    /**
     * tag for chart
     */
    tag?: string;
}

export interface ClusterOverrideTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ClusterSharingSharing {
    /**
     * flag to specify if shared to all projects
     */
    all?: boolean;
    /**
     * list of projects this cluster is shared to
     */
    projects?: outputs.ClusterSharingSharingProject[];
}

export interface ClusterSharingSharingProject {
    /**
     * id of the project
     */
    id: string;
    /**
     * name of the project
     */
    name?: string;
}

export interface ClusterSharingTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ConfigContextMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ConfigContextMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ConfigContextMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ConfigContextMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ConfigContextMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ConfigContextSpec {
    /**
     * Environment variables data
     */
    envs?: outputs.ConfigContextSpecEnv[];
    /**
     * File path information
     */
    files?: outputs.ConfigContextSpecFile[];
    /**
     * Config Context secrets
     */
    secret?: outputs.ConfigContextSpecSecret;
    /**
     * Defines if this is shared with other projects
     */
    sharing?: outputs.ConfigContextSpecSharing;
    /**
     * Variables data for config context
     */
    variables?: outputs.ConfigContextSpecVariable[];
}

export interface ConfigContextSpecEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ConfigContextSpecEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ConfigContextSpecEnvOptions {
    description?: string;
    override?: outputs.ConfigContextSpecEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ConfigContextSpecEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ConfigContextSpecFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ConfigContextSpecFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ConfigContextSpecFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ConfigContextSpecFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ConfigContextSpecFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ConfigContextSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ConfigContextSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ConfigContextSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ConfigContextSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ConfigContextSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ConfigContextSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ConfigContextSpecSharingProject[];
}

export interface ConfigContextSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ConfigContextSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ConfigContextSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ConfigContextSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ConfigContextSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ConfigContextSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ConfigContextTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ContainerRegistryMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ContainerRegistryMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ContainerRegistryMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ContainerRegistryMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ContainerRegistryMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ContainerRegistrySpec {
    credentials?: outputs.ContainerRegistrySpecCredentials;
    /**
     * Container Registry endpoint
     */
    endpoint?: string;
    /**
     * container registry provider
     */
    provider?: string;
    /**
     * Container Registry secrets
     */
    secret?: outputs.ContainerRegistrySpecSecret;
}

export interface ContainerRegistrySpecCredentials {
    accessKeyId?: string;
    accessSecretKey?: string;
    jsonKeyData?: string;
    password?: string;
    region?: string;
    servicePrincipalId?: string;
    servicePrincipalPassword?: string;
    username?: string;
}

export interface ContainerRegistrySpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ContainerRegistrySpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ContainerRegistrySpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ContainerRegistrySpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ContainerRegistrySpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ContainerRegistryTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CostProfileMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.CostProfileMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.CostProfileMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface CostProfileMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CostProfileMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CostProfileSpec {
    /**
     * Parameters for profile installation
     */
    installationParams?: outputs.CostProfileSpecInstallationParams;
    /**
     * provider type
     */
    providerType?: string;
    /**
     * profile sharing configuration
     */
    sharing?: outputs.CostProfileSpecSharing;
    /**
     * version of the profile
     */
    version?: string;
}

export interface CostProfileSpecInstallationParams {
    /**
     * aws cost profile params. aws specific params
     */
    aws?: outputs.CostProfileSpecInstallationParamsAws;
    /**
     * azure cost profile params. azure specific params
     */
    azure?: outputs.CostProfileSpecInstallationParamsAzure;
    /**
     * Other provider cost profile params. custom on_prem params
     */
    other?: outputs.CostProfileSpecInstallationParamsOther;
}

export interface CostProfileSpecInstallationParamsAws {
    /**
     * Aws Credentials to fetch cost data
     */
    awsCredentials?: outputs.CostProfileSpecInstallationParamsAwsAwsCredentials;
    /**
     * Aws Cur Integration params
     */
    curIntegration?: outputs.CostProfileSpecInstallationParamsAwsCurIntegration;
    /**
     * Aws Spot Integration params
     */
    spotIntegration?: outputs.CostProfileSpecInstallationParamsAwsSpotIntegration;
}

export interface CostProfileSpecInstallationParamsAwsAwsCredentials {
    /**
     * Aws Service Key Name
     */
    awsServiceKeyName?: string;
    /**
     * Aws Service Key Secret
     */
    awsServiceKeySecret?: string;
    /**
     * cloud credentials id
     */
    cloudCredentialsName?: string;
    /**
     * Aws role arn
     */
    roleArn?: string;
}

export interface CostProfileSpecInstallationParamsAwsCurIntegration {
    /**
     * Aws Athena Bucket Name
     */
    athenaBucketName?: string;
    /**
     * Aws Athena Database
     */
    athenaDatabase?: string;
    /**
     * Aws Athena Region
     */
    athenaRegion?: string;
    /**
     * Aws Athena Table Name
     */
    athenaTable?: string;
    /**
     * Aws Account ID
     */
    awsAccountId?: string;
    /**
     * Master Payer Arn
     */
    masterPayerArn?: string;
}

export interface CostProfileSpecInstallationParamsAwsSpotIntegration {
    /**
     * Aws Account ID
     */
    awsAccountId?: string;
    /**
     * Aws Spot Data Bucket
     */
    awsSpotDataBucket?: string;
    /**
     * Aws Spot Data Prefix
     */
    awsSpotDataPrefix?: string;
    /**
     * Aws Spot Data Region
     */
    awsSpotDataRegion?: string;
    /**
     * Aws Spot Label
     */
    spotLabel?: string;
    /**
     * Aws Spot Label Value
     */
    spotLabelValue?: string;
}

export interface CostProfileSpecInstallationParamsAzure {
    /**
     * custom pricing params
     */
    customPricing?: outputs.CostProfileSpecInstallationParamsAzureCustomPricing;
    /**
     * gpu estimates
     */
    gpuEstimates?: outputs.CostProfileSpecInstallationParamsAzureGpuEstimates;
}

export interface CostProfileSpecInstallationParamsAzureCustomPricing {
    /**
     * Azure Client ID
     */
    azureClientId?: string;
    /**
     * Azure Client Secret
     */
    azureClientSecret?: string;
    /**
     * Azure Subscription ID
     */
    azureSubscriptionId?: string;
    /**
     * Azure Tenant ID
     */
    azureTenantId?: string;
    /**
     * Billing Account ID
     */
    billingAccountId?: string;
    /**
     * cloud credentials id
     */
    cloudCredentialsName?: string;
    /**
     * Offer ID
     */
    offerId?: string;
    /**
     * Spot Instance
     */
    spotInstance?: outputs.CostProfileSpecInstallationParamsAzureCustomPricingSpotInstance;
}

export interface CostProfileSpecInstallationParamsAzureCustomPricingSpotInstance {
    /**
     * spot Lable
     */
    spotLabel?: string;
    /**
     * spot Label Value
     */
    spotLabelValue?: string;
}

export interface CostProfileSpecInstallationParamsAzureGpuEstimates {
    /**
     * gpu Lable
     */
    gpuLabel?: string;
    /**
     * gpu Label Value
     */
    gpuLabelValue?: string;
}

export interface CostProfileSpecInstallationParamsOther {
    /**
     * The cost of cpu per hour
     */
    cpu?: string;
    /**
     * The cost of gpu per hour
     */
    gpu?: string;
    /**
     * The cost of memory per hour
     */
    memory?: string;
}

export interface CostProfileSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.CostProfileSpecSharingProject[];
}

export interface CostProfileSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface CostProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface CustomroleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.CustomroleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.CustomroleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface CustomroleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CustomroleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface CustomroleSpec {
    /**
     * list of abac policy associated with custom role
     */
    abacPolicyLists?: outputs.CustomroleSpecAbacPolicyList[];
    /**
     * Base Role Name
     */
    baseRole?: string;
    /**
     * list of ztka policy associated with custom role
     */
    ztkaPolicyLists?: outputs.CustomroleSpecZtkaPolicyList[];
}

export interface CustomroleSpecAbacPolicyList {
    /**
     * Name of policy
     */
    name?: string;
    /**
     * version of policy
     */
    version?: string;
}

export interface CustomroleSpecZtkaPolicyList {
    /**
     * Name of policy
     */
    name?: string;
    /**
     * version of policy
     */
    version?: string;
}

export interface CustomroleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DownloadKubeconfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface DriverMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.DriverMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.DriverMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface DriverMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface DriverMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface DriverSpec {
    /**
     * Driver configuration
     */
    config?: outputs.DriverSpecConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.DriverSpecInput[];
    /**
     * Specify the output data
     */
    outputs?: outputs.DriverSpecOutputs;
    /**
     * Driver secrets
     */
    secret?: outputs.DriverSpecSecret;
    /**
     * Sharing with other projects
     */
    sharing?: outputs.DriverSpecSharing;
}

export interface DriverSpecConfig {
    /**
     * Specify the container driver config
     */
    container?: outputs.DriverSpecConfigContainer;
    /**
     * Specify the http driver config
     */
    http?: outputs.DriverSpecConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.DriverSpecConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of driver
     */
    type?: string;
}

export interface DriverSpecConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.DriverSpecConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.DriverSpecConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.DriverSpecConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.DriverSpecConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.DriverSpecConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface DriverSpecConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface DriverSpecConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface DriverSpecConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.DriverSpecConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.DriverSpecConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.DriverSpecConfigContainerKubeOptionsToleration[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface DriverSpecConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface DriverSpecConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.DriverSpecConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.DriverSpecConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface DriverSpecConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface DriverSpecConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface DriverSpecConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface DriverSpecConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.DriverSpecConfigContainerVolumeUsePvc;
}

export interface DriverSpecConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.DriverSpecConfigContainerVolumeOptionsUsePvc;
}

export interface DriverSpecConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface DriverSpecConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface DriverSpecConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface DriverSpecConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface DriverSpecInput {
    /**
     * Context data of the config context
     */
    data?: outputs.DriverSpecInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface DriverSpecInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.DriverSpecInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.DriverSpecInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.DriverSpecInputDataVariable[];
}

export interface DriverSpecInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.DriverSpecInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface DriverSpecInputDataEnvOptions {
    description?: string;
    override?: outputs.DriverSpecInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface DriverSpecInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface DriverSpecInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.DriverSpecInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface DriverSpecInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.DriverSpecInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface DriverSpecInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface DriverSpecInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.DriverSpecInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface DriverSpecInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.DriverSpecInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface DriverSpecInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface DriverSpecOutputs {
    fields?: {[key: string]: string};
}

export interface DriverSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.DriverSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface DriverSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.DriverSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface DriverSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface DriverSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.DriverSpecSharingProject[];
}

export interface DriverSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface DriverTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EksClusterCluster {
    /**
     * The type of resource. Supported value is `Cluster`.
     */
    kind?: string;
    /**
     * Contains data that helps uniquely identify the resource.
     */
    metadata: outputs.EksClusterClusterMetadata;
    /**
     * The specification associated with the cluster, including cluster networking options.
     */
    spec: outputs.EksClusterClusterSpec;
}

export interface EksClusterClusterConfig {
    /**
     * holds the EKS addon configuration
     */
    addons?: outputs.EksClusterClusterConfigAddon[];
    /**
     * apiversion
     */
    apiversion?: string;
    /**
     * availability zones of a cluster
     */
    availabilityZones?: string[];
    /**
     * holds all CloudWatch attributes of a cluster
     */
    cloudWatches?: outputs.EksClusterClusterConfigCloudWatch[];
    /**
     * defines the settings used to schedule workload onto Fargate.
     */
    fargateProfiles?: outputs.EksClusterClusterConfigFargateProfile[];
    /**
     * holds all IAM attributes of a cluster
     */
    iams?: outputs.EksClusterClusterConfigIam[];
    /**
     * maps IAM user/roles to kubenetes RBAC groups
     */
    identityMappings?: outputs.EksClusterClusterConfigIdentityMapping[];
    /**
     * holds an identity provider configuration.
     */
    identityProviders?: outputs.EksClusterClusterConfigIdentityProvider[];
    /**
     * kind
     */
    kind?: string;
    /**
     * contains cluster networking options
     */
    kubernetesNetworkConfigs?: outputs.EksClusterClusterConfigKubernetesNetworkConfig[];
    /**
     * holds all nodegroup attributes of a cluster.
     */
    managedNodegroups?: outputs.EksClusterClusterConfigManagedNodegroup[];
    /**
     * contains cluster networking options
     */
    metadatas: outputs.EksClusterClusterConfigMetadata[];
    /**
     * holds all nodegroup attributes of a cluster.
     */
    nodeGroups?: outputs.EksClusterClusterConfigNodeGroup[];
    /**
     * allows configuring a fully-private cluster in which no node has outbound internet access, and private access to AWS services is enabled via VPC endpoints
     */
    privateClusters?: outputs.EksClusterClusterConfigPrivateCluster[];
    /**
     * defines the configuration for KMS encryption provider
     */
    secretsEncryptions?: outputs.EksClusterClusterConfigSecretsEncryption[];
    /**
     * holds global subnet and all child subnets
     */
    vpcs?: outputs.EksClusterClusterConfigVpc[];
}

export interface EksClusterClusterConfigAddon {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.EksClusterClusterConfigAddonAttachPolicy[];
    /**
     * list of ARNs of the IAM policies to attach
     */
    attachPolicyArns?: string[];
    /**
     * holds a policy document to attach to this addon in json string format
     */
    attachPolicyV2?: string;
    /**
     * configuration values for the addon
     */
    configurationValues?: string;
    /**
     * EKS addon name
     */
    name: string;
    /**
     * ARN of the permissions boundary to associate
     */
    permissionsBoundary?: string;
    /**
     * service account role ARN
     */
    serviceAccountRoleArn?: string;
    /**
     * The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.
     */
    tags?: {[key: string]: string};
    /**
     * EKS addon version
     */
    version?: string;
    /**
     * for attaching common IAM policies
     */
    wellKnownPolicies?: outputs.EksClusterClusterConfigAddonWellKnownPolicy[];
}

export interface EksClusterClusterConfigAddonAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.EksClusterClusterConfigAddonAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface EksClusterClusterConfigAddonAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface EksClusterClusterConfigAddonWellKnownPolicy {
    /**
     * service account annotations
     */
    autoScaler?: boolean;
    /**
     * adds policies for using the aws-load-balancer-controller.
     */
    awsLoadBalancerController?: boolean;
    /**
     * adds cert-manager policies.
     */
    certManager?: boolean;
    /**
     * adds cert-manager policies.
     */
    ebsCsiController?: boolean;
    /**
     * adds policies for using the ebs-csi-controller.
     */
    efsCsiController?: boolean;
    /**
     * adds external-dns policies for Amazon Route 53.
     */
    externalDns?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access.
     */
    imageBuilder?: boolean;
}

export interface EksClusterClusterConfigCloudWatch {
    /**
     * container config parameters related to cluster logging
     */
    clusterLoggings?: outputs.EksClusterClusterConfigCloudWatchClusterLogging[];
}

export interface EksClusterClusterConfigCloudWatchClusterLogging {
    /**
     * Types of logging to enable. Valid entries are: 'api', 'audit', 'authenticator', 'controllerManager', 'scheduler', 'all', '*'.
     */
    enableTypes?: string[];
    /**
     * The number of days you want to retain log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.
     */
    logRetentionInDays?: number;
}

export interface EksClusterClusterConfigFargateProfile {
    /**
     * name of the fargate profile
     */
    name?: string;
    /**
     * IAM role's ARN to use to run pods onto Fargate.
     */
    podExecutionRoleArn?: string;
    /**
     * define the rules to select workload to schedule onto Fargate.
     */
    selectors?: outputs.EksClusterClusterConfigFargateProfileSelector[];
    /**
     * The current status of the Fargate profile.
     */
    status?: string;
    /**
     * define the rules to select workload to schedule onto Fargate.
     */
    subnets?: string[];
    /**
     * Used to tag the AWS resources
     */
    tags?: {[key: string]: string};
}

export interface EksClusterClusterConfigFargateProfileSelector {
    /**
     * Kubernetes label selectors to use to select workload.
     */
    labels?: {[key: string]: string};
    /**
     * Kubernetes namespace from which to select workload.
     */
    namespace?: string;
}

export interface EksClusterClusterConfigIam {
    /**
     * role used by pods to access AWS APIs. This role is added to the Kubernetes RBAC for authorization.
     */
    fargatePodExecutionRoleArn?: string;
    /**
     * permissions boundary for the fargate pod execution role.
     */
    fargatePodExecutionRolePermissionsBoundary?: string;
    /**
     * service accounts to create in the cluster.
     */
    serviceAccounts?: outputs.EksClusterClusterConfigIamServiceAccount[];
    /**
     * service role ARN of the cluster
     */
    serviceRoleArn?: string;
    /**
     * permissions boundary for all identity-based entities created by the vendor.
     */
    serviceRolePermissionBoundary?: string;
    /**
     * attaches the IAM policy necessary to run the VPC controller in the control plane
     */
    vpcResourceControllerPolicy?: boolean;
    /**
     * enables the IAM OIDC provider as well as IRSA for the Amazon CNI plugin
     */
    withOidc?: boolean;
}

export interface EksClusterClusterConfigIamServiceAccount {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicy?: string;
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    attachPolicyArns?: string[];
    /**
     * ARN of the role to attach to the service account
     */
    attachRoleArn?: string;
    /**
     * metadata for service accounts
     */
    metadatas?: outputs.EksClusterClusterConfigIamServiceAccountMetadata[];
    /**
     * ARN of the permissions boundary to associate with the service account
     */
    permissionsBoundary?: string;
    /**
     * Specific role name instead of the Cloudformation-generated role name
     */
    roleName?: string;
    /**
     * Specify if only the IAM Service Account role should be created without creating/annotating the service account
     */
    roleOnly?: boolean;
    /**
     * holds status of the IAM service account
     */
    statuses?: outputs.EksClusterClusterConfigIamServiceAccountStatus[];
    /**
     * AWS tags for the service account
     */
    tags?: {[key: string]: string};
    /**
     * for attaching common IAM policies
     */
    wellKnownPolicies?: outputs.EksClusterClusterConfigIamServiceAccountWellKnownPolicy[];
}

export interface EksClusterClusterConfigIamServiceAccountMetadata {
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    annotations?: {[key: string]: string};
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    labels?: {[key: string]: string};
    /**
     * service account name
     */
    name?: string;
    /**
     * service account namespace
     */
    namespace?: string;
}

export interface EksClusterClusterConfigIamServiceAccountStatus {
    /**
     * role ARN associated with the service account.
     */
    roleArn?: string;
}

export interface EksClusterClusterConfigIamServiceAccountWellKnownPolicy {
    /**
     * service account annotations
     */
    autoScaler?: boolean;
    /**
     * adds policies for using the aws-load-balancer-controller.
     */
    awsLoadBalancerController?: boolean;
    /**
     * adds cert-manager policies.
     */
    certManager?: boolean;
    /**
     * adds cert-manager policies.
     */
    ebsCsiController?: boolean;
    /**
     * adds policies for using the ebs-csi-controller.
     */
    efsCsiController?: boolean;
    /**
     * adds external-dns policies for Amazon Route 53.
     */
    externalDns?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access.
     */
    imageBuilder?: boolean;
}

export interface EksClusterClusterConfigIdentityMapping {
    /**
     * List of IAM accounts to map
     */
    accounts?: string[];
    /**
     * List of ARN objects
     */
    arns?: outputs.EksClusterClusterConfigIdentityMappingArn[];
}

export interface EksClusterClusterConfigIdentityMappingArn {
    /**
     * ARN of user/role to be mapped
     */
    arn?: string;
    /**
     * List of kubernetes groups to be mapped to
     */
    groups?: string[];
    /**
     * The username to be used by kubernetes
     */
    username?: string;
}

export interface EksClusterClusterConfigIdentityProvider {
    /**
     * Valid variants are: 'oidc': OIDC identity provider
     */
    type?: string;
}

export interface EksClusterClusterConfigKubernetesNetworkConfig {
    /**
     * Valid variants are: 'IPv4' defines an IP family of v4 to be used when creating a new VPC and cluster., 'IPv6' defines an IP family of v6 to be used when creating a new VPC and cluster..
     */
    ipFamily?: string;
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    serviceIpv4Cidr?: string;
}

export interface EksClusterClusterConfigManagedNodegroup {
    /**
     * Specify custom AMIs, auto-ssm, auto, or static
     */
    ami?: string;
    /**
     * Valid variants are: 'AmazonLinux2'.
     */
    amiFamily?: string;
    /**
     * See relevant AWS docs
     */
    asgSuspendProcesses?: string[];
    /**
     * Limit nodes to specific AZs
     */
    availabilityZones?: string[];
    /**
     * specifies settings for Bottlerocket nodes
     */
    bottleRockets?: outputs.EksClusterClusterConfigManagedNodegroupBottleRocket[];
    /**
     * desired capacity of instances in the nodegroup
     */
    desiredCapacity?: number;
    /**
     * requires requests to the metadata service to use IMDSv2 tokens
     */
    disableImdsv1?: boolean;
    /**
     * blocks all IMDS requests from non host networking pods
     */
    disablePodsImds?: boolean;
    /**
     * enables EBS optimization
     */
    ebsOptimized?: boolean;
    /**
     * creates the maximum allowed number of EFA-enabled network cards on nodes in this group.
     */
    efaEnabled?: boolean;
    /**
     * Enable EC2 detailed monitoring
     */
    enableDetailedMonitoring?: boolean;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iams?: outputs.EksClusterClusterConfigManagedNodegroupIam[];
    /**
     * for instances in the nodegroup
     */
    instanceName?: string;
    /**
     * for instances in the nodegroup
     */
    instancePrefix?: string;
    /**
     * specifies options for EC2 instance selector
     */
    instanceSelectors?: outputs.EksClusterClusterConfigManagedNodegroupInstanceSelector[];
    /**
     * type of instances in the nodegroup
     */
    instanceType?: string;
    /**
     * specifies a list of instance types
     */
    instanceTypes?: string[];
    /**
     * labels on nodes in the nodegroup
     */
    labels?: {[key: string]: string};
    /**
     * used by the scaling config, see cloudformation docs
     */
    launchTemplates?: outputs.EksClusterClusterConfigManagedNodegroupLaunchTemplate[];
    /**
     * Maximum pods per node
     */
    maxPodsPerNode?: number;
    /**
     * maximum size of instances in the nodegroup
     */
    maxSize?: number;
    /**
     * minimum size of instances in the nodegroup
     */
    minSize?: number;
    /**
     * name of the node group
     */
    name: string;
    /**
     * Override the vendor's bootstrapping script
     */
    overrideBootstrapCommand?: string;
    /**
     * specifies the placement group in which nodes should be spawned
     */
    placements?: outputs.EksClusterClusterConfigManagedNodegroupPlacement[];
    /**
     * executed before bootstrapping instances to the cluster
     */
    preBootstrapCommands?: string[];
    /**
     * Enable private networking for nodegroup
     */
    privateNetworking?: boolean;
    /**
     * controls security groups for this nodegroup
     */
    securityGroups?: outputs.EksClusterClusterConfigManagedNodegroupSecurityGroup[];
    /**
     * create a spot nodegroup
     */
    spot?: boolean;
    /**
     * configures ssh access for this nodegroup
     */
    sshes?: outputs.EksClusterClusterConfigManagedNodegroupSsh[];
    /**
     * Limit nodes to specific subnets
     */
    subnets?: string[];
    /**
     * Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed)
     */
    tags?: {[key: string]: string};
    /**
     * taints to apply to the nodegroup
     */
    taints?: outputs.EksClusterClusterConfigManagedNodegroupTaint[];
    /**
     * used by the scaling config, see cloudformation docs
     */
    updateConfigs?: outputs.EksClusterClusterConfigManagedNodegroupUpdateConfig[];
    /**
     * Kuberenetes version for the nodegroup
     */
    version?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeEncrypted?: boolean;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeIops?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeKmsKeyId?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeName?: string;
    /**
     * in gigabytes
     */
    volumeSize?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeThroughput?: number;
    /**
     * Valid variants are: 'gp2' is General Purpose SSD, 'gp3' is General Purpose SSD which can be optimised for high throughput (default), 'io1' is Provisioned IOPS SSD, 'sc1' is Cold HDD, 'st1' is Throughput Optimized HDD.
     */
    volumeType?: string;
}

export interface EksClusterClusterConfigManagedNodegroupBottleRocket {
    /**
     * Enable admin container
     */
    enableAdminContainer?: boolean;
    /**
     * contains any bottlerocket settings
     */
    settings?: string;
}

export interface EksClusterClusterConfigManagedNodegroupIam {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.EksClusterClusterConfigManagedNodegroupIamAttachPolicy[];
    /**
     * attach polciy ARN
     */
    attachPolicyArns?: string[];
    /**
     * attach policy in json string format
     */
    attachPolicyV2?: string;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iamNodeGroupWithAddonPolicies?: outputs.EksClusterClusterConfigManagedNodegroupIamIamNodeGroupWithAddonPolicy[];
    /**
     * instance profile ARN
     */
    instanceProfileArn?: string;
    /**
     * instance role ARN
     */
    instanceRoleArn?: string;
    /**
     * instance role Name
     */
    instanceRoleName?: string;
    /**
     * instance role permissions boundary
     */
    instanceRolePermissionBoundary?: string;
}

export interface EksClusterClusterConfigManagedNodegroupIamAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.EksClusterClusterConfigManagedNodegroupIamAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface EksClusterClusterConfigManagedNodegroupIamAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface EksClusterClusterConfigManagedNodegroupIamIamNodeGroupWithAddonPolicy {
    /**
     * enables access to ALB Ingress controller
     */
    albIngress?: boolean;
    /**
     * enables full access to AppMesh
     */
    appMesh?: boolean;
    /**
     * enables full access to AppMesh Preview
     */
    appMeshReview?: boolean;
    /**
     * enables IAM policy for cluster-autoscaler
     */
    autoScaler?: boolean;
    /**
     * enables the ability to add records to Route 53 in order to solve the DNS01 challenge.
     */
    certManager?: boolean;
    /**
     * enables access to cloud watch
     */
    cloudWatch?: boolean;
    /**
     * enables the new EBS CSI (Elastic Block Store Container Storage Interface) driver
     */
    ebs?: boolean;
    /**
     * enables full access to EFS
     */
    efs?: boolean;
    /**
     * adds the external-dns project policies for Amazon Route 53
     */
    externalDns?: boolean;
    /**
     * enables full access to FSX
     */
    fsx?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access. This is useful for building, for example, a CI server that needs to push images to ECR
     */
    imageBuilder?: boolean;
    /**
     * enables access to XRay
     */
    xray?: boolean;
}

export interface EksClusterClusterConfigManagedNodegroupInstanceSelector {
    /**
     * CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'
     */
    cpuArchitecture?: string;
    /**
     * specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.
     */
    gpus?: number;
    /**
     * specifies the memory The unit defaults to GiB
     */
    memory?: string;
    /**
     * specifies the number of vCPUs
     */
    vcpus?: number;
}

export interface EksClusterClusterConfigManagedNodegroupLaunchTemplate {
    /**
     * key of taint
     */
    id?: string;
    /**
     * value of taint
     */
    version?: string;
}

export interface EksClusterClusterConfigManagedNodegroupPlacement {
    /**
     * placement group name
     */
    group?: string;
}

export interface EksClusterClusterConfigManagedNodegroupSecurityGroup {
    /**
     * attaches additional security groups to the nodegroup
     */
    attachIds?: string[];
    /**
     * attach a security group local to this nodegroup Not supported for managed nodegroups
     */
    withLocal?: boolean;
    /**
     * attach the security group shared among all nodegroups in the cluster
     */
    withShared?: boolean;
}

export interface EksClusterClusterConfigManagedNodegroupSsh {
    /**
     * If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured
     */
    allow?: boolean;
    /**
     * Enables the ability to SSH onto nodes using SSM
     */
    enableSsm?: boolean;
    /**
     * Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKey?: string;
    /**
     * Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKeyName?: string;
    /**
     * source securitgy group IDs
     */
    sourceSecurityGroupIds?: string[];
}

export interface EksClusterClusterConfigManagedNodegroupTaint {
    /**
     * effect of taint
     */
    effect?: string;
    /**
     * key of taint
     */
    key?: string;
    /**
     * value of taint
     */
    value?: string;
}

export interface EksClusterClusterConfigManagedNodegroupUpdateConfig {
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as number)
     */
    maxUnavailable?: number;
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as percentage)
     */
    maxUnavailablePercentage?: number;
}

export interface EksClusterClusterConfigMetadata {
    /**
     * arbitrary metadata ignored by the vendor
     */
    annotations?: {[key: string]: string};
    /**
     * EKS Cluster name
     */
    name: string;
    /**
     * the AWS region hosting this cluster
     */
    region: string;
    /**
     * used to tag AWS resources created by the vendor
     */
    tags?: {[key: string]: string};
    /**
     * Valid variants are: '1.16', '1.17', '1.18', '1.19', '1.20' (default), '1.21'.
     */
    version?: string;
}

export interface EksClusterClusterConfigNodeGroup {
    /**
     * Specify custom AMIs, auto-ssm, auto, or static
     */
    ami?: string;
    /**
     * Valid variants are: 'AmazonLinux2' (default), 'Ubuntu2004', 'Ubuntu1804', 'Bottlerocket', 'WindowsServer2019CoreContainer', 'WindowsServer2019FullContainer', 'WindowsServer2004CoreContainer'.
     */
    amiFamily?: string;
    /**
     * used by the scaling config, see cloudformation docs
     */
    asgMetricsCollections?: outputs.EksClusterClusterConfigNodeGroupAsgMetricsCollection[];
    /**
     * See relevant AWS docs
     */
    asgSuspendProcesses?: string[];
    /**
     * Limit nodes to specific AZs
     */
    availabilityZones?: string[];
    /**
     * specifies settings for Bottlerocket nodes
     */
    bottleRockets?: outputs.EksClusterClusterConfigNodeGroupBottleRocket[];
    /**
     * Associate load balancers with auto scaling group
     */
    classicLoadBalancerNames?: string[];
    /**
     * Custom address used for DNS lookups
     */
    clusterDns?: string;
    /**
     * configures T3 Unlimited, valid only for T-type instances
     */
    cpuCredits?: string;
    /**
     * Desired capacity of instances in the nodegroup
     */
    desiredCapacity?: number;
    /**
     * requires requests to the metadata service to use IMDSv2 tokens
     */
    disableImdsv1?: boolean;
    /**
     * blocks all IMDS requests from non host networking pods
     */
    disablePodsImds?: boolean;
    /**
     * enables EBS optimization
     */
    ebsOptimized?: boolean;
    /**
     * creates the maximum allowed number of EFA-enabled network cards on nodes in this group.
     */
    efaEnabled?: boolean;
    /**
     * Enable EC2 detailed monitoring
     */
    enableDetailedMonitoring?: boolean;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iams?: outputs.EksClusterClusterConfigNodeGroupIam[];
    /**
     * for instances in the nodegroup
     */
    instanceName?: string;
    /**
     * for instances in the nodegroup
     */
    instancePrefix?: string;
    /**
     * specifies options for EC2 instance selector
     */
    instanceSelectors?: outputs.EksClusterClusterConfigNodeGroupInstanceSelector[];
    /**
     * type of instances in the nodegroup
     */
    instanceType?: string;
    /**
     * holds the configuration for spot instances
     */
    instancesDistributions?: outputs.EksClusterClusterConfigNodeGroupInstancesDistribution[];
    /**
     * Custom address used for DNS lookups
     */
    kubeletExtraConfigs?: outputs.EksClusterClusterConfigNodeGroupKubeletExtraConfig[];
    /**
     * labels on nodes in the nodegroup
     */
    labels?: {[key: string]: string};
    /**
     * Maximum pods per node
     */
    maxPodsPerNode?: number;
    /**
     * Maximum size of instances in the nodegroup
     */
    maxSize?: number;
    /**
     * Minimum size of instances in the nodegroup
     */
    minSize?: number;
    /**
     * name of the node group
     */
    name?: string;
    /**
     * Override the vendor's bootstrapping script
     */
    overrideBootstrapCommand?: string;
    /**
     * specifies the placement group in which nodes should be spawned
     */
    placements?: outputs.EksClusterClusterConfigNodeGroupPlacement[];
    /**
     * executed before bootstrapping instances to the cluster
     */
    preBootstrapCommands?: string[];
    /**
     * Enable private networking for nodegroup
     */
    privateNetworking?: boolean;
    /**
     * controls security groups for this nodegroup
     */
    securityGroups?: outputs.EksClusterClusterConfigNodeGroupSecurityGroup[];
    /**
     * configures ssh access for this nodegroup
     */
    sshes?: outputs.EksClusterClusterConfigNodeGroupSsh[];
    /**
     * Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes)
     */
    subnetCidr?: string;
    /**
     * Limit nodes to specific subnets
     */
    subnets?: string[];
    /**
     * Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed)
     */
    tags?: {[key: string]: string};
    /**
     * taints to apply to the nodegroup
     */
    taints?: outputs.EksClusterClusterConfigNodeGroupTaint[];
    /**
     * Associate target group with auto scaling group
     */
    targetGroupArns?: string[];
    /**
     * used by the scaling config, see cloudformation docs
     */
    updateConfigs?: outputs.EksClusterClusterConfigNodeGroupUpdateConfig[];
    /**
     * Kuberenetes version for the nodegroup
     */
    version?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeEncrypted?: boolean;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeIops?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeKmsKeyId?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeName?: string;
    /**
     * volume size in gigabytes
     */
    volumeSize?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeThroughput?: number;
    /**
     * Valid variants are: 'gp2' is General Purpose SSD, 'gp3' is General Purpose SSD which can be optimised for high throughput (default), 'io1' is Provisioned IOPS SSD, 'sc1' is Cold HDD, 'st1' is Throughput Optimized HDD.
     */
    volumeType?: string;
}

export interface EksClusterClusterConfigNodeGroupAsgMetricsCollection {
    /**
     * of metrics collected
     */
    granularity?: string;
    /**
     * specifies a list of metrics
     */
    metrics?: string[];
}

export interface EksClusterClusterConfigNodeGroupBottleRocket {
    /**
     * Enable admin container
     */
    enableAdminContainer?: boolean;
    /**
     * contains any bottlerocket settings
     */
    settings?: string;
}

export interface EksClusterClusterConfigNodeGroupIam {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.EksClusterClusterConfigNodeGroupIamAttachPolicy[];
    /**
     * attach polciy ARN
     */
    attachPolicyArns?: string[];
    /**
     * attach policy in json string format
     */
    attachPolicyV2?: string;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iamNodeGroupWithAddonPolicies?: outputs.EksClusterClusterConfigNodeGroupIamIamNodeGroupWithAddonPolicy[];
    /**
     * instance profile ARN
     */
    instanceProfileArn?: string;
    /**
     * instance role ARN
     */
    instanceRoleArn?: string;
    /**
     * instance role Name
     */
    instanceRoleName?: string;
    /**
     * instance role permissions boundary
     */
    instanceRolePermissionBoundary?: string;
}

export interface EksClusterClusterConfigNodeGroupIamAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.EksClusterClusterConfigNodeGroupIamAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface EksClusterClusterConfigNodeGroupIamAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface EksClusterClusterConfigNodeGroupIamIamNodeGroupWithAddonPolicy {
    /**
     * enables access to ALB Ingress controller
     */
    albIngress?: boolean;
    /**
     * enables full access to AppMesh
     */
    appMesh?: boolean;
    /**
     * enables full access to AppMesh Preview
     */
    appMeshReview?: boolean;
    /**
     * enables IAM policy for cluster-autoscaler
     */
    autoScaler?: boolean;
    /**
     * enables the ability to add records to Route 53 in order to solve the DNS01 challenge.
     */
    certManager?: boolean;
    /**
     * enables access to cloud watch
     */
    cloudWatch?: boolean;
    /**
     * enables the new EBS CSI (Elastic Block Store Container Storage Interface) driver
     */
    ebs?: boolean;
    /**
     * enables full access to EFS
     */
    efs?: boolean;
    /**
     * adds the external-dns project policies for Amazon Route 53
     */
    externalDns?: boolean;
    /**
     * enables full access to FSX
     */
    fsx?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access. This is useful for building, for example, a CI server that needs to push images to ECR
     */
    imageBuilder?: boolean;
    /**
     * enables access to XRay
     */
    xray?: boolean;
}

export interface EksClusterClusterConfigNodeGroupInstanceSelector {
    /**
     * CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'
     */
    cpuArchitecture?: string;
    /**
     * specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.
     */
    gpus?: number;
    /**
     * specifies the memory The unit defaults to GiB
     */
    memory?: string;
    /**
     * specifies the number of vCPUs
     */
    vcpus?: number;
}

export interface EksClusterClusterConfigNodeGroupInstancesDistribution {
    /**
     * Enable capacity rebalancing for spot instances
     */
    capacityRebalance?: boolean;
    /**
     * Enable admin container
     */
    instanceTypes?: string[];
    /**
     * Maximum bid price in USD
     */
    maxPrice?: number;
    /**
     * base number of on-demand instances (non-negative)
     */
    onDemandBaseCapacity?: number;
    /**
     * Range [0-100]
     */
    onDemandPercentageAboveBaseCapacity?: number;
    /**
     * allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price
     */
    spotAllocationStrategy?: string;
    /**
     * Range [0-20]
     */
    spotInstancePools?: number;
}

export interface EksClusterClusterConfigNodeGroupKubeletExtraConfig {
    evictionHard?: {[key: string]: string};
    featureGates?: {[key: string]: string};
    kubeReserved?: {[key: string]: string};
    kubeReservedCgroup?: string;
    systemReserved?: {[key: string]: string};
}

export interface EksClusterClusterConfigNodeGroupPlacement {
    /**
     * placement group name
     */
    group?: string;
}

export interface EksClusterClusterConfigNodeGroupSecurityGroup {
    /**
     * attaches additional security groups to the nodegroup
     */
    attachIds?: string[];
    /**
     * attach a security group local to this nodegroup Not supported for managed nodegroups
     */
    withLocal?: boolean;
    /**
     * attach the security group shared among all nodegroups in the cluster
     */
    withShared?: boolean;
}

export interface EksClusterClusterConfigNodeGroupSsh {
    /**
     * If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured
     */
    allow?: boolean;
    /**
     * Enables the ability to SSH onto nodes using SSM
     */
    enableSsm?: boolean;
    /**
     * Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKey?: string;
    /**
     * Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKeyName?: string;
    /**
     * source securitgy group IDs
     */
    sourceSecurityGroupIds?: string[];
}

export interface EksClusterClusterConfigNodeGroupTaint {
    /**
     * effect of taint
     */
    effect?: string;
    /**
     * key of taint
     */
    key?: string;
    /**
     * value of taint
     */
    value?: string;
}

export interface EksClusterClusterConfigNodeGroupUpdateConfig {
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as number)
     */
    maxUnavaliable?: number;
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as percentage)
     */
    maxUnavaliablePercetage?: number;
}

export interface EksClusterClusterConfigPrivateCluster {
    /**
     * specifies additional endpoint services that must be enabled for private access. Valid entries are: 'cloudformation', 'autoscaling', 'logs'
     */
    additionalEndpointServices?: string[];
    /**
     * enables creation of a fully-private cluster
     */
    enabled?: boolean;
    /**
     * skips the creation process for endpoints completely. This is only used in case of an already provided VPC and if the user decided to set it to true.
     */
    skipEndpointCreation?: boolean;
}

export interface EksClusterClusterConfigSecretsEncryption {
    /**
     * Flag to encrypt existing secrets. Default is true
     */
    encryptExistingSecrets?: boolean;
    /**
     * KMS key ARN
     */
    keyArn?: string;
}

export interface EksClusterClusterConfigVpc {
    /**
     * AutoAllocateIPV6 requests an IPv6 CIDR block with /56 prefix for the VPC
     */
    autoAllocateIpv6?: boolean;
    /**
     * AWS VPC ID.
     */
    cidr?: string;
    /**
     * Manage access to the Kubernetes API server endpoints.
     */
    clusterEndpoints?: outputs.EksClusterClusterConfigVpcClusterEndpoint[];
    /**
     * for additional CIDR associations, e.g. a CIDR for private subnets or any ad-hoc subnets
     */
    extraCidrs?: string[];
    /**
     * for additional CIDR associations, e.g. a CIDR for private subnets or any ad-hoc subnets
     */
    extraIpv6Cidrs?: string[];
    /**
     * AWS VPC ID.
     */
    id?: string;
    /**
     * n/a
     */
    ipv6Cidr?: string;
    /**
     * n/a
     */
    ipv6Pool?: string;
    /**
     * Automatically add security group rules to and from the default cluster security group and the shared node security group. This allows unmanaged nodes to communicate with the control plane and managed nodes. This option cannot be disabled when using vendor created security groups.
     */
    manageSharedNodeSecurityGroupRules?: boolean;
    /**
     * NAT config
     */
    nats?: outputs.EksClusterClusterConfigVpcNat[];
    /**
     * which CIDR blocks to allow access to public k8s API endpoint
     */
    publicAccessCidrs?: string[];
    /**
     * (aka the ControlPlaneSecurityGroup) for communication between control plane and nodes
     */
    securityGroup?: string;
    /**
     * for pre-defined shared node SG
     */
    sharedNodeSecurityGroup?: string;
    /**
     * keyed by AZ for convenience.
     */
    subnets?: outputs.EksClusterClusterConfigVpcSubnet[];
}

export interface EksClusterClusterConfigVpcClusterEndpoint {
    /**
     * enable private access to the Kubernetes API server endpoints.
     */
    privateAccess?: boolean;
    /**
     * enable public access to the Kubernetes API server endpoints.
     */
    publicAccess?: boolean;
}

export interface EksClusterClusterConfigVpcNat {
    /**
     * Valid variants are: 'HighlyAvailable' configures a highly available NAT gateway, 'Single' configures a single NAT gateway (default), 'Disable' disables NAT.
     */
    gateway?: string;
}

export interface EksClusterClusterConfigVpcSubnet {
    /**
     * holds subnet to AZ mappings. If the key is an AZ, that also becomes the name of the subnet otherwise use the key to refer to this subnet.
     */
    privates?: outputs.EksClusterClusterConfigVpcSubnetPrivate[];
    /**
     * holds subnet to AZ mappings. If the key is an AZ, that also becomes the name of the subnet otherwise use the key to refer to this subnet.
     */
    publics?: outputs.EksClusterClusterConfigVpcSubnetPublic[];
}

export interface EksClusterClusterConfigVpcSubnetPrivate {
    /**
     * dont know what this is, not in docs
     */
    az?: string;
    /**
     * dont know what this is, not in docs
     */
    cidr?: string;
    /**
     * id of subnet
     */
    id?: string;
    /**
     * name of subnet
     */
    name?: string;
}

export interface EksClusterClusterConfigVpcSubnetPublic {
    /**
     * dont know what this is, not in docs
     */
    az?: string;
    /**
     * dont know what this is, not in docs
     */
    cidr?: string;
    /**
     * id of subnet
     */
    id?: string;
    /**
     * name of subnet
     */
    name?: string;
}

export interface EksClusterClusterMetadata {
    /**
     * The labels for the cluster in Rafay console.
     */
    labels?: {[key: string]: string};
    /**
     * The name of the EKS cluster in Rafay console. This must be unique in your organization.
     */
    name: string;
    /**
     * The name of the Rafay project the cluster will be created in.
     */
    project: string;
}

export interface EksClusterClusterSpec {
    /**
     * The blueprint associated with the cluster. A blueprint defines the configuration and policy. Use blueprints to help standardize cluster configurations.
     */
    blueprint?: string;
    /**
     * The blueprint version associated with the cluster.
     */
    blueprintVersion?: string;
    /**
     * The cloud credentials provider used to create and manage the cluster.
     */
    cloudProvider: string;
    /**
     * The container network interface (CNI) parameters.
     */
    cniParams?: outputs.EksClusterClusterSpecCniParams;
    /**
     * The container network interface (CNI) provider used to specify different network connectivity options for the cluster.
     */
    cniProvider?: string;
    /**
     * Role ARN of the linked account
     */
    crossAccountRoleArn?: string;
    /**
     * The proxy configuration for the cluster. Use this if the infrastructure uses an outbound proxy.
     */
    proxyConfig?: {[key: string]: string};
    /**
     * The sharing configuration for the resource. A cluster can be shared with one or more projects. Note: If the resource is not shared, set enabled = false.
     */
    sharing?: outputs.EksClusterClusterSpecSharing;
    /**
     * Configure tolerations and nodeSelector for Rafay system components.
     */
    systemComponentsPlacement?: outputs.EksClusterClusterSpecSystemComponentsPlacement;
    /**
     * The cluster type. Supported value is `eks`.
     */
    type?: string;
}

export interface EksClusterClusterSpecCniParams {
    /**
     * Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.
     */
    customCniCidr?: string;
    /**
     * The custom container network interface custom resource definition specification. One or more of these blocks should be specified if you choose to use your existing VPC and subnets while creating the EKS cluster.
     */
    customCniCrdSpecs?: outputs.EksClusterClusterSpecCniParamsCustomCniCrdSpec[];
}

export interface EksClusterClusterSpecCniParamsCustomCniCrdSpec {
    /**
     * The custom CNI configuration for this AZ.
     */
    cniSpec?: outputs.EksClusterClusterSpecCniParamsCustomCniCrdSpecCniSpec;
    /**
     * The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.
     */
    name: string;
}

export interface EksClusterClusterSpecCniParamsCustomCniCrdSpecCniSpec {
    /**
     * The security groups associated with secondary ENIs for AWS EC2 nodes.
     */
    securityGroups?: string[];
    /**
     * The subnet associated with secondary ENIs for AWS EC2 nodes.
     */
    subnet?: string;
}

export interface EksClusterClusterSpecSharing {
    /**
     * Enable sharing for this resource.
     */
    enabled?: boolean;
    /**
     * The list of projects this resource is shared with. Note: Required when project sharing is enabled.
     */
    projects?: outputs.EksClusterClusterSpecSharingProject[];
}

export interface EksClusterClusterSpecSharingProject {
    /**
     * The name of the project to share the resource.
     */
    name: string;
}

export interface EksClusterClusterSpecSystemComponentsPlacement {
    /**
     * Allows users to override the default behaviour of DaemonSet for specific nodes, enabling the addition of additional tolerations for Daemonsets to match the taints available on the nodes.
     */
    daemonsetOverrides?: outputs.EksClusterClusterSpecSystemComponentsPlacementDaemonsetOverride[];
    /**
     * Key-Value pairs insuring pods to be scheduled on desired nodes.
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Enables the kuberenetes scheduler to schedule pods with matching taints.
     */
    tolerations?: outputs.EksClusterClusterSpecSystemComponentsPlacementToleration[];
}

export interface EksClusterClusterSpecSystemComponentsPlacementDaemonsetOverride {
    /**
     * enables node selection
     */
    nodeSelectionEnabled?: boolean;
    /**
     * Additional tolerations for Daemonsets to match the taints available on the nodes
     */
    tolerations?: outputs.EksClusterClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration[];
}

export interface EksClusterClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface EksClusterClusterSpecSystemComponentsPlacementToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface EksClusterSpecTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EksClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnvironmentMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.EnvironmentMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.EnvironmentMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface EnvironmentMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface EnvironmentMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface EnvironmentSpec {
    /**
     * Agents that are eligible to process the environment
     */
    agents?: outputs.EnvironmentSpecAgent[];
    /**
     * Environment variables to be set for the environment
     */
    envVars?: outputs.EnvironmentSpecEnvVar[];
    /**
     * Files to be set for the environment
     */
    files?: outputs.EnvironmentSpecFile[];
    /**
     * Environment secrets
     */
    secret?: outputs.EnvironmentSpecSecret;
    /**
     * Defines if this is shared with other projects
     */
    sharing?: outputs.EnvironmentSpecSharing;
    /**
     * Environment resource template
     */
    template?: outputs.EnvironmentSpecTemplate;
    /**
     * Variables data for environment to be created
     */
    variables?: outputs.EnvironmentSpecVariable[];
}

export interface EnvironmentSpecAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecEnvVar {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecEnvVarOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecEnvVarOptions {
    description?: string;
    override?: outputs.EnvironmentSpecEnvVarOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecEnvVarOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.EnvironmentSpecSharingProject[];
}

export interface EnvironmentSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface EnvironmentSpecTemplate {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Specification of the environment template resource
     */
    spec?: outputs.EnvironmentSpecTemplateSpec;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version, possible values are `draft`, `disabled` and `active`
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpec {
    /**
     * Agent override
     */
    agentOverride?: outputs.EnvironmentSpecTemplateSpecAgentOverride;
    /**
     * Agents that are eligible to process the template
     */
    agents?: outputs.EnvironmentSpecTemplateSpecAgent[];
    /**
     * Reference to config context data associated with environment templates
     */
    contexts?: outputs.EnvironmentSpecTemplateSpecContext[];
    /**
     * Specify lifecycle hook actions
     */
    hooks?: outputs.EnvironmentSpecTemplateSpecHooks;
    /**
     * Icon URL for the template
     */
    iconUrl?: string;
    /**
     * Readme for the template
     */
    readme?: string;
    /**
     * Specify all the environment resources to be included in environment
     */
    resources?: outputs.EnvironmentSpecTemplateSpecResource[];
    /**
     * Environment Template secrets
     */
    secret?: outputs.EnvironmentSpecTemplateSpecSecret;
    /**
     * Sharing options with other projects
     */
    sharing?: outputs.EnvironmentSpecTemplateSpecSharing;
    /**
     * Environment variables, file data and other variables
     */
    variables?: outputs.EnvironmentSpecTemplateSpecVariable[];
    /**
     * Environment template version
     */
    version?: string;
    /**
     * Represents the current state of template version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecAgentOverride {
    /**
     * Determines whether the agent override is required / mandatory
     */
    required?: boolean;
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedAgents?: string[];
    /**
     * agent override type
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecContext {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentSpecTemplateSpecContextData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecContextData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentSpecTemplateSpecContextDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentSpecTemplateSpecContextDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentSpecTemplateSpecContextDataVariable[];
}

export interface EnvironmentSpecTemplateSpecContextDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecContextDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecTemplateSpecContextDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentSpecTemplateSpecContextDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecContextDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecContextDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecContextDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecContextDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecContextDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecContextDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecContextDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecContextDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecContextDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecContextDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecContextDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooks {
    /**
     * On completion environment hook
     */
    onCompletions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletion[];
    /**
     * On failure environment hook
     */
    onFailures?: outputs.EnvironmentSpecTemplateSpecHooksOnFailure[];
    /**
     * On initialize environment hook
     */
    onInits?: outputs.EnvironmentSpecTemplateSpecHooksOnInit[];
    /**
     * On success environment hook
     */
    onSuccesses?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccess[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletion {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInput[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariable[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsScript;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalEmail {
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest {
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsApprovalJira {
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsNotification {
}

export interface EnvironmentSpecTemplateSpecHooksOnCompletionOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailure {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInput[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariable[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsScript;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalEmail {
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest {
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsApprovalJira {
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsNotification {
}

export interface EnvironmentSpecTemplateSpecHooksOnFailureOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInit {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentSpecTemplateSpecHooksOnInitAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInput[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariable[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsScript;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalEmail {
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest {
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsApprovalJira {
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsNotification {
}

export interface EnvironmentSpecTemplateSpecHooksOnInitOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccess {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInput[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariable[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsScript;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalEmail {
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest {
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsApprovalJira {
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsNotification {
}

export interface EnvironmentSpecTemplateSpecHooksOnSuccessOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentSpecTemplateSpecResource {
    /**
     * Specify the environment resource reference that it depends on
     */
    dependsOns?: outputs.EnvironmentSpecTemplateSpecResourceDependsOn[];
    /**
     * Specify the environment resource kind
     */
    kind?: string;
    /**
     * Specify the environment resource name
     */
    name?: string;
    /**
     * Specify the environment resource options
     */
    resourceOptions?: outputs.EnvironmentSpecTemplateSpecResourceResourceOptions;
    /**
     * Specify the environment resource type
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecResourceDependsOn {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentSpecTemplateSpecResourceResourceOptions {
    /**
     * Specify if the resource is dedicated to workloads/apps
     */
    dedicated?: boolean;
    /**
     * Specify the resource version, if blank will use the latest
     */
    version?: string;
}

export interface EnvironmentSpecTemplateSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentSpecTemplateSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentSpecTemplateSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentSpecTemplateSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.EnvironmentSpecTemplateSpecSharingProject[];
}

export interface EnvironmentSpecTemplateSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface EnvironmentSpecTemplateSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecTemplateSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecTemplateSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecTemplateSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecTemplateSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.EnvironmentTemplateMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.EnvironmentTemplateMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface EnvironmentTemplateMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface EnvironmentTemplateMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface EnvironmentTemplateSpec {
    /**
     * Agent override
     */
    agentOverride?: outputs.EnvironmentTemplateSpecAgentOverride;
    /**
     * Agents that are eligible to process the template
     */
    agents?: outputs.EnvironmentTemplateSpecAgent[];
    /**
     * Reference to config context data associated with environment templates
     */
    contexts?: outputs.EnvironmentTemplateSpecContext[];
    /**
     * Specify lifecycle hook actions
     */
    hooks?: outputs.EnvironmentTemplateSpecHooks;
    /**
     * Icon URL for the template
     */
    iconUrl?: string;
    /**
     * Readme for the template
     */
    readme?: string;
    /**
     * Specify all the environment resources to be included in environment
     */
    resources?: outputs.EnvironmentTemplateSpecResource[];
    /**
     * Environment Template secrets
     */
    secret?: outputs.EnvironmentTemplateSpecSecret;
    /**
     * Sharing options with other projects
     */
    sharing?: outputs.EnvironmentTemplateSpecSharing;
    /**
     * Environment variables, file data and other variables
     */
    variables?: outputs.EnvironmentTemplateSpecVariable[];
    /**
     * Environment template version
     */
    version?: string;
    /**
     * Represents the current state of template version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecAgentOverride {
    /**
     * Determines whether the agent override is required / mandatory
     */
    required?: boolean;
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedAgents?: string[];
    /**
     * agent override type
     */
    type?: string;
}

export interface EnvironmentTemplateSpecContext {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentTemplateSpecContextData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentTemplateSpecContextData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentTemplateSpecContextDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentTemplateSpecContextDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentTemplateSpecContextDataVariable[];
}

export interface EnvironmentTemplateSpecContextDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentTemplateSpecContextDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentTemplateSpecContextDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentTemplateSpecContextDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecContextDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecContextDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecContextDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecContextDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecContextDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecContextDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecContextDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecContextDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecContextDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecContextDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecContextDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooks {
    /**
     * On completion environment hook
     */
    onCompletions?: outputs.EnvironmentTemplateSpecHooksOnCompletion[];
    /**
     * On failure environment hook
     */
    onFailures?: outputs.EnvironmentTemplateSpecHooksOnFailure[];
    /**
     * On initialize environment hook
     */
    onInits?: outputs.EnvironmentTemplateSpecHooksOnInit[];
    /**
     * On success environment hook
     */
    onSuccesses?: outputs.EnvironmentTemplateSpecHooksOnSuccess[];
}

export interface EnvironmentTemplateSpecHooksOnCompletion {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentTemplateSpecHooksOnCompletionAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInput[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariable[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsScript;
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalEmail {
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest {
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsApprovalJira {
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsNotification {
}

export interface EnvironmentTemplateSpecHooksOnCompletionOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailure {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentTemplateSpecHooksOnFailureAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentTemplateSpecHooksOnFailureDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnFailureOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInput[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariable[];
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsScript;
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentTemplateSpecHooksOnFailureOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsApprovalEmail {
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest {
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsApprovalJira {
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsNotification {
}

export interface EnvironmentTemplateSpecHooksOnFailureOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnInit {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentTemplateSpecHooksOnInitAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentTemplateSpecHooksOnInitDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnInitOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnInitDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInput[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariable[];
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsScript;
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentTemplateSpecHooksOnInitOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsApprovalEmail {
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest {
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsApprovalJira {
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsNotification {
}

export interface EnvironmentTemplateSpecHooksOnInitOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccess {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.EnvironmentTemplateSpecHooksOnSuccessAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInput[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariable[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsScript;
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalEmail {
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest {
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalInternal {
    emails?: string[];
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsApprovalJira {
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsNotification {
}

export interface EnvironmentTemplateSpecHooksOnSuccessOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface EnvironmentTemplateSpecResource {
    /**
     * Specify the environment resource reference that it depends on
     */
    dependsOns?: outputs.EnvironmentTemplateSpecResourceDependsOn[];
    /**
     * Specify the environment resource kind
     */
    kind?: string;
    /**
     * Specify the environment resource name
     */
    name?: string;
    /**
     * Specify the environment resource options
     */
    resourceOptions?: outputs.EnvironmentTemplateSpecResourceResourceOptions;
    /**
     * Specify the environment resource type
     */
    type?: string;
}

export interface EnvironmentTemplateSpecResourceDependsOn {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface EnvironmentTemplateSpecResourceResourceOptions {
    /**
     * Specify if the resource is dedicated to workloads/apps
     */
    dedicated?: boolean;
    /**
     * Specify the resource version, if blank will use the latest
     */
    version?: string;
}

export interface EnvironmentTemplateSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.EnvironmentTemplateSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.EnvironmentTemplateSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface EnvironmentTemplateSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.EnvironmentTemplateSpecSharingProject[];
}

export interface EnvironmentTemplateSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface EnvironmentTemplateSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.EnvironmentTemplateSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface EnvironmentTemplateSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.EnvironmentTemplateSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface EnvironmentTemplateSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface EnvironmentTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface EnvironmentTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface FleetplanMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.FleetplanMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.FleetplanMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface FleetplanMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface FleetplanMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface FleetplanSpec {
    agents?: outputs.FleetplanSpecAgent[];
    fleet?: outputs.FleetplanSpecFleet;
    operationWorkflow?: outputs.FleetplanSpecOperationWorkflow;
}

export interface FleetplanSpecAgent {
    name?: string;
}

export interface FleetplanSpecFleet {
    kind?: string;
    labels?: {[key: string]: string};
    projects?: outputs.FleetplanSpecFleetProject[];
}

export interface FleetplanSpecFleetProject {
    name?: string;
}

export interface FleetplanSpecOperationWorkflow {
    operations?: outputs.FleetplanSpecOperationWorkflowOperation[];
}

export interface FleetplanSpecOperationWorkflowOperation {
    action?: outputs.FleetplanSpecOperationWorkflowOperationAction;
    name?: string;
    posthooks?: outputs.FleetplanSpecOperationWorkflowOperationPosthook[];
    prehooks?: outputs.FleetplanSpecOperationWorkflowOperationPrehook[];
}

export interface FleetplanSpecOperationWorkflowOperationAction {
    blueprintUpdateConfig?: outputs.FleetplanSpecOperationWorkflowOperationActionBlueprintUpdateConfig;
    continueOnFailure?: boolean;
    controlPlaneUpgradeConfig?: outputs.FleetplanSpecOperationWorkflowOperationActionControlPlaneUpgradeConfig;
    description?: string;
    name?: string;
    nodeGroupsAndControlPlaneUpgradeConfig?: outputs.FleetplanSpecOperationWorkflowOperationActionNodeGroupsAndControlPlaneUpgradeConfig;
    nodeGroupsUpgradeConfig?: outputs.FleetplanSpecOperationWorkflowOperationActionNodeGroupsUpgradeConfig;
    patchConfigs?: outputs.FleetplanSpecOperationWorkflowOperationActionPatchConfig[];
    type?: string;
}

export interface FleetplanSpecOperationWorkflowOperationActionBlueprintUpdateConfig {
    name?: string;
    version?: string;
}

export interface FleetplanSpecOperationWorkflowOperationActionControlPlaneUpgradeConfig {
    version?: string;
}

export interface FleetplanSpecOperationWorkflowOperationActionNodeGroupsAndControlPlaneUpgradeConfig {
    version?: string;
}

export interface FleetplanSpecOperationWorkflowOperationActionNodeGroupsUpgradeConfig {
    names?: string[];
    version?: string;
}

export interface FleetplanSpecOperationWorkflowOperationActionPatchConfig {
    op?: string;
    path?: string;
    value?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPosthook {
    containerConfig?: outputs.FleetplanSpecOperationWorkflowOperationPosthookContainerConfig;
    continueOnFailure?: boolean;
    description?: string;
    httpConfig?: outputs.FleetplanSpecOperationWorkflowOperationPosthookHttpConfig;
    injects?: string[];
    name?: string;
    successCondition?: string;
    timeoutSeconds?: number;
}

export interface FleetplanSpecOperationWorkflowOperationPosthookContainerConfig {
    arguments?: string[];
    commands?: string[];
    cpuLimitMilli?: string;
    env?: {[key: string]: string};
    image?: string;
    memoryLimitMb?: string;
    runner?: outputs.FleetplanSpecOperationWorkflowOperationPosthookContainerConfigRunner;
    workingDirPath?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPosthookContainerConfigRunner {
    nodeSelector?: {[key: string]: string};
    type?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPosthookHttpConfig {
    body?: string;
    endpoint?: string;
    headers?: {[key: string]: string};
    method?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPrehook {
    containerConfig?: outputs.FleetplanSpecOperationWorkflowOperationPrehookContainerConfig;
    continueOnFailure?: boolean;
    description?: string;
    httpConfig?: outputs.FleetplanSpecOperationWorkflowOperationPrehookHttpConfig;
    injects?: string[];
    name?: string;
    successCondition?: string;
    timeoutSeconds?: number;
}

export interface FleetplanSpecOperationWorkflowOperationPrehookContainerConfig {
    arguments?: string[];
    commands?: string[];
    cpuLimitMilli?: string;
    env?: {[key: string]: string};
    image?: string;
    memoryLimitMb?: string;
    runner?: outputs.FleetplanSpecOperationWorkflowOperationPrehookContainerConfigRunner;
    workingDirPath?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPrehookContainerConfigRunner {
    nodeSelector?: {[key: string]: string};
    type?: string;
}

export interface FleetplanSpecOperationWorkflowOperationPrehookHttpConfig {
    body?: string;
    endpoint?: string;
    headers?: {[key: string]: string};
    method?: string;
}

export interface FleetplanTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GetAddonMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetAddonMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetAddonMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetAddonMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetAddonMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetAddonSpec {
    /**
     * artifact specification of the addon
     */
    artifact?: outputs.GetAddonSpecArtifact;
    /**
     * namespace of the addon
     */
    namespace?: string;
    /**
     * sharing specification of the addon
     */
    sharing?: outputs.GetAddonSpecSharing;
    /**
     * version of the addon
     */
    version?: string;
}

export interface GetAddonSpecArtifact {
    artifact?: outputs.GetAddonSpecArtifactArtifact;
    options?: outputs.GetAddonSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.GetAddonSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.GetAddonSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.GetAddonSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.GetAddonSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.GetAddonSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.GetAddonSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.GetAddonSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.GetAddonSpecArtifactArtifactValuesRef;
}

export interface GetAddonSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.GetAddonSpecArtifactArtifactValuesRefValuesPath[];
}

export interface GetAddonSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetAddonSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetAddonSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetAddonSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetAddonSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface GetAddonSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.GetAddonSpecSharingProject[];
}

export interface GetAddonSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface GetAddonTimeouts {
    read?: string;
}

export interface GetAksClusterMetadata {
    /**
     * labels for the cluster
     */
    labels?: {[key: string]: string};
    /**
     * AKS Cluster name
     */
    name: string;
    /**
     * Project for the cluster
     */
    project: string;
}

export interface GetAksClusterSpec {
    /**
     * Blueprint to be associated with the cluster. Default will be default-aks
     */
    blueprint?: string;
    /**
     * Blueprint version to be associated with the cluster. Default will be the latest version
     */
    blueprintversion?: string;
    /**
     * Cloud credentials provider used to create and manage the cluster.
     */
    cloudprovider: string;
    /**
     * AKS specific cluster configuration
     */
    clusterConfigs: outputs.GetAksClusterSpecClusterConfig[];
    /**
     * blueprint sharing configuration
     */
    sharing?: outputs.GetAksClusterSpecSharing;
    /**
     * Configure tolerations and nodeSelector for Rafay system components.
     */
    systemComponentsPlacement?: outputs.GetAksClusterSpecSystemComponentsPlacement;
    /**
     * AKS Cluster type
     */
    type: string;
}

export interface GetAksClusterSpecClusterConfig {
    /**
     * apiversion
     */
    apiversion: string;
    /**
     * kind
     */
    kind?: string;
    /**
     * AKS specific cluster configuration metadata
     */
    metadatas: outputs.GetAksClusterSpecClusterConfigMetadata[];
    /**
     * AKS specific cluster configuration spec
     */
    specs: outputs.GetAksClusterSpecClusterConfigSpec[];
}

export interface GetAksClusterSpecClusterConfigMetadata {
    /**
     * AKS cluster name
     */
    name: string;
}

export interface GetAksClusterSpecClusterConfigSpec {
    /**
     * The AKS managed cluster
     */
    managedClusters?: outputs.GetAksClusterSpecClusterConfigSpecManagedCluster[];
    /**
     * The Aks Node Pool
     */
    nodePools: outputs.GetAksClusterSpecClusterConfigSpecNodePool[];
    /**
     * Resource Group for the cluster
     */
    resourceGroupName: string;
    /**
     * The AKS subscription id
     */
    subscriptionId?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedCluster {
    /**
     * Additional metadata associated with the managed cluster.
     */
    additionalMetadatas?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadata[];
    /**
     * Azure resource managed cluster api version.
     */
    apiversion: string;
    /**
     * The AKS managed cluster extended location
     */
    extendedLocations?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterExtendedLocation[];
    /**
     * The AKS managed cluster extended location
     */
    identities?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterIdentity[];
    /**
     * AKS cluster location
     */
    location: string;
    /**
     * Properties of the managed cluster.
     */
    properties: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterProperty[];
    /**
     * The SKU of a Managed Cluster.
     */
    skus?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterSkus[];
    /**
     * Resource tags
     */
    tags?: {[key: string]: string};
    /**
     * Type
     */
    type?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadata {
    /**
     * Profile for Azure Container Registry configuration
     */
    acrProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfile[];
    /**
     * If not specified, defaults to the resource group of the managed cluster. Valid only if the Log analytics workspace is specified.
     */
    omsWorkspaceLocation?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfile {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * The list of Azure Container Registry Profiles
     */
    registries?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry[];
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName: string;
    /**
     * The location of the Azure Container Registry resource.
     */
    resourceGroupName?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterExtendedLocation {
    /**
     * The AKS managed cluster extended location name
     */
    name?: string;
    /**
     * The AKS managed cluster extended location type
     */
    type?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterIdentity {
    /**
     * Identity type for the AKS cluster. For more information see use managed identities in AKS. Valid values are SystemAssigned, UserAssigned, None.
     */
    type?: string;
    /**
     * Arm Resource Ids
     */
    userAssignedIdentities?: {[key: string]: string};
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterProperty {
    /**
     * The AKS managed cluster AAD Profile
     */
    aadProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAadProfile[];
    /**
     * The AKS managed cluster addon profiles
     */
    addonProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfile[];
    /**
     * The AKS managed cluster api server access profile
     */
    apiServerAccessProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyApiServerAccessProfile[];
    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     */
    autoScalerProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAutoScalerProfile[];
    /**
     * The AKS managed cluster autoupgrade profile
     */
    autoUpgradeProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAutoUpgradeProfile[];
    /**
     * The AKS managed cluster addon profiles
     */
    disableLocalAccounts?: boolean;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}
     */
    diskEncryptionSetId?: string;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    dnsPrefix?: string;
    /**
     * (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020.
     */
    enablePodSecurityPolicy?: boolean;
    /**
     * Whether to enable Kubernetes Role-Based Access Control.
     */
    enableRbac?: boolean;
    /**
     * This cannot be updated once the Managed Cluster has been created
     */
    fqdnSubdomain?: string;
    /**
     * Cluster HTTP proxy configuration.
     */
    httpProxyConfigs?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyHttpProxyConfig[];
    /**
     * Identities associated with the cluster
     */
    identityProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfile[];
    /**
     * Kubernetes version
     */
    kubernetesVersion: string;
    /**
     * Profile for Linux VMs in the container service cluster.
     */
    linuxProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfile[];
    /**
     * Profile of network configuration.
     */
    networkProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfile[];
    /**
     * The name of the resource group containing agent pool nodes.
     */
    nodeResourceGroup?: string;
    /**
     * Aspect of pod identity integration.
     */
    podIdentityProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfile[];
    /**
     * Cluster Power State
     */
    powerStates?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPowerState[];
    /**
     * Private link resources associated with the cluster.
     */
    privateLinkResources?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPrivateLinkResource[];
    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     */
    servicePrincipalProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyServicePrincipalProfile[];
    /**
     * Profile for Windows VMs in the managed cluster.
     */
    windowsProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyWindowsProfile[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAadProfile {
    /**
     * The AKS managed cluster aad profile admin group object ids
     */
    adminGroupObjectIds?: string[];
    /**
     * The AKS managed cluster aad profile client app id
     */
    clientAppId?: string;
    /**
     * Whether or not to enable azure rbac for kubernetes authorization
     */
    enableAzureRbac?: boolean;
    /**
     * Whether or not to enable managed aad
     */
    managed?: boolean;
    /**
     * The server AAD application ID.
     */
    serverAppId?: string;
    /**
     * The AKS managed cluster aad profile server app secret
     */
    serverAppSecret?: string;
    /**
     * The AKS managed cluster tenant id
     */
    tenantId?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfile {
    /**
     * Azure Keyvault Secrets Provider for AKS
     */
    azureKeyvaultSecretsProviders?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProvider[];
    /**
     * Config for Azure Policy in Addon Profile
     */
    azurePolicies?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzurePolicy[];
    /**
     * Config for HTTP Application Routing Addon Profile
     */
    httpApplicationRoutings?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileHttpApplicationRouting[];
    /**
     * Azure Ingress Application Gateway Addon for AKS
     */
    ingressApplicationGateways?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGateway[];
    /**
     * Config for OMS Agent in Addon Profile
     */
    omsAgents?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgent[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProvider {
    /**
     * Config Azure Key Vault Secrets Provider in Addon Profile
     */
    configs?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProviderConfig[];
    /**
     * Whether to enable Azure Key Vault Secrets Provider in Addon Profile
     */
    enabled?: boolean;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzureKeyvaultSecretsProviderConfig {
    /**
     * Whether to enable Secret Rotation
     */
    enableSecretRotation: string;
    /**
     * Interval to poll for secret rotation
     */
    rotationPollInterval: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileAzurePolicy {
    /**
     * Config for HTTP Application Routing or Azure Policy in Addon Profile
     */
    config?: string;
    /**
     * Whether to enable HTTP Application Routing or Azure Policy in Addon Profile
     */
    enabled?: boolean;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileHttpApplicationRouting {
    /**
     * Config for HTTP Application Routing or Azure Policy in Addon Profile
     */
    config?: string;
    /**
     * Whether to enable HTTP Application Routing or Azure Policy in Addon Profile
     */
    enabled?: boolean;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGateway {
    /**
     * Config for Ingress Application Gateway in Addon Profile
     */
    configs?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGatewayConfig[];
    /**
     * Whether to enable Ingress Application Gateway in Addon Profile
     */
    enabled?: boolean;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileIngressApplicationGatewayConfig {
    /**
     * Resource Id of an existing Application Gateway to use with AGIC.
     */
    applicationGatewayId?: string;
    /**
     * Name of the application gateway to create/use in the node resource group.
     */
    applicationGatewayName?: string;
    /**
     * Subnet CIDR to use for a new subnet created to deploy the Application Gateway.
     */
    subnetCidr?: string;
    /**
     * Resource Id of an existing Subnet used to deploy the Application Gateway.
     */
    subnetId?: string;
    /**
     * Specify the namespace, which AGIC should watch. This could be a single string value, or a comma-separated list of namespaces.
     */
    watchNamespace?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgent {
    /**
     * Config for OMS Agent in Addon Profile
     */
    configs?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgentConfig[];
    /**
     * Whether to enable OMS Agent in Addon Profile
     */
    enabled?: boolean;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAddonProfileOmsAgentConfig {
    /**
     * ID of the log analytics workspace
     */
    logAnalyticsWorkspaceResourceId: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyApiServerAccessProfile {
    /**
     * The AKS managed cluster properties server access profile server access profile
     */
    authorizedIprRanges?: string[];
    /**
     * Enable private cluster
     */
    enablePrivateCluster?: boolean;
    /**
     * Whether or not to create additional public fqdn for private cluster
     */
    enablePrivateClusterPublicFqdn?: boolean;
    /**
     * The AKS managed cluster properties private dns zone
     */
    privateDnsZone?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAutoScalerProfile {
    /**
     * Valid values are true or false
     */
    balanceSimilarNodeGroups?: string;
    /**
     * Valid values are least-waste, most-pods, priority, random
     */
    expander?: string;
    /**
     * Max empty bulk delete
     */
    maxEmptyBulkDelete?: string;
    /**
     * Max graceful termination sec
     */
    maxGracefulTerminationSec?: string;
    /**
     * Values must be an integer followed by an m. No unit of time other than minutes (m) is supported
     */
    maxNodeProvisionTime?: string;
    /**
     * The maximum is 100 and the minimum is 0
     */
    maxTotalUnreadyPercentage?: string;
    /**
     * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age.
     */
    newPodScaleUpDelay?: string;
    /**
     * This must be an integer.
     */
    okTotalUnreadyCount?: string;
    /**
     * Values must be an integer followed by an m. No unit of time other than minutes (m) is supported
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * The default is the scan-interval. Values must be an integer followed by an m
     */
    scaleDownDelayAfterDelete?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownDelayAfterFailure?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownUnneededTime?: string;
    /**
     * Values must be an integer followed by an m
     */
    scaleDownUnreadyTime?: string;
    /**
     * The scale down utilization threshold
     */
    scaleDownUtilizationThreshold?: string;
    /**
     * The default is 10. Values must be an integer number of seconds
     */
    scanInterval?: string;
    /**
     * Skip nodes with local storage
     */
    skipNodesWithLocalStorage?: string;
    /**
     * Skip nodes with system pods
     */
    skipNodesWithSystemPods?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyAutoUpgradeProfile {
    /**
     * Valid values are rapid, stable, patch, node-image, none
     */
    upgradeChannel?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyHttpProxyConfig {
    /**
     * The HTTP proxy server endpoint to use.
     */
    httpProxy?: string;
    /**
     * The HTTPs proxy server endpoint to use.
     */
    httpsProxy?: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfile {
    /**
     * Kubelet Identity for managed cluster identity profile
     */
    kubeletIdentities: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfileKubeletIdentity[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyIdentityProfileKubeletIdentity {
    /**
     * value must be ARM resource ID in the form: /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<identity-name>
     */
    resourceId: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfile {
    /**
     * The administrator username to use for Linux VMs.
     */
    adminUsername: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * SSH configuration for Linux-based VMs running on Azure.
     */
    sshes: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSsh[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSsh {
    /**
     * The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
     */
    publicKeys: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSshPublicKeys;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyLinuxProfileSshPublicKeys {
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
     */
    keyData?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfile {
    /**
     * An IP address assigned to the Kubernetes DNS service.
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network.
     */
    dockerBridgeCidr?: string;
    /**
     * Profile of the managed cluster load balancer.
     */
    loadBalancerProfiles?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfile[];
    /**
     * Valid values are standard, basic.
     */
    loadBalancerSku?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure.
     */
    networkMode?: string;
    /**
     * Network plugin used for building the Kubernetes network. Valid values are azure, kubenet.
     */
    networkPlugin?: string;
    /**
     * Network plugin mode used for building the Azure CNI. Valid values are 'overlay'
     */
    networkPluginMode?: string;
    /**
     * Network policy used for building the Kubernetes network. Valid values are calico, azure.
     */
    networkPolicy?: string;
    /**
     * This can only be set at cluster creation time and cannot be changed later. Valid values are loadBalancer, userDefinedRouting.
     */
    outboundType?: string;
    /**
     * A CIDR notation IP range from which to assign pod IPs when kubenet is used.
     */
    podCidr?: string;
    /**
     * A CIDR notation IP range from which to assign service cluster IPs.
     */
    serviceCidr?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfile {
    /**
     * The desired number of allocated SNAT ports per VM.
     */
    allocatedOutboundPorts?: number;
    /**
     * The effective outbound IP resources of the cluster load balancer.
     */
    effectiveOutboundIps?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileEffectiveOutboundIp[];
    /**
     * Desired outbound flow idle timeout in minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    managedOutboundIps?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileManagedOutboundIp[];
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    outboundIpPrefixes?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefix[];
    /**
     * Desired outbound IP resources for the cluster load balancer.
     */
    outboundIps?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIp[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileEffectiveOutboundIp {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileManagedOutboundIp {
    /**
     * The desired number of outbound IPs created/managed by Azure for the cluster load balancer.
     */
    count?: number;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIp {
    /**
     * A list of public IP resources.
     */
    publicIps?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPublicIp[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefix {
    /**
     * A list of public IP prefix resources.
     */
    publicIpPrefixes?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefixPublicIpPrefix[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPrefixPublicIpPrefix {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyNetworkProfileLoadBalancerProfileOutboundIpPublicIp {
    /**
     * The fully qualified Azure resource id
     */
    id?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfile {
    /**
     * Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
     */
    allowNetworkPluginKubenet?: boolean;
    /**
     * Whether the pod identity addon is enabled.
     */
    enabled?: boolean;
    /**
     * The pod identities to use in the cluster.
     */
    userAssignedIdentities?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentity[];
    /**
     * The pod identity exceptions to allow.
     */
    userAssignedIdentityExceptions?: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityException[];
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentity {
    /**
     * The binding selector to use for the AzureIdentityBinding resource.
     */
    bindingSelector?: string;
    /**
     * Details about a user assigned identity.
     */
    identities: outputs.GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityIdentity[];
    /**
     * The name of the pod identity.
     */
    name: string;
    /**
     * The namespace of the pod identity.
     */
    namespace: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityException {
    /**
     * The name of the pod identity.
     */
    name: string;
    /**
     * The namespace of the pod identity.
     */
    namespace: string;
    /**
     * The pod labels to match.
     */
    podLabels: {[key: string]: string};
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPodIdentityProfileUserAssignedIdentityIdentity {
    /**
     * The client ID of the user assigned identity.
     */
    clientId?: string;
    /**
     * The object ID of the user assigned identity.
     */
    objectId?: string;
    /**
     * The resource ID of the user assigned identity.
     */
    resourceId?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPowerState {
    /**
     * Whether the cluster is running or stopped
     */
    code?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyPrivateLinkResource {
    /**
     * The group ID of the resource.
     */
    groupId?: string;
    /**
     * The ID of the private link resource.
     */
    id?: string;
    /**
     * The name of the private link resource.
     */
    name?: string;
    /**
     * The RequiredMembers of the resource
     */
    requiredMembers?: string[];
    /**
     * The resource type.
     */
    type?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyServicePrincipalProfile {
    /**
     * FORMATTED:The ID for the service principal. If specified, must be set to `[parameters('servicePrincipalClientId')]`. This would be set to the cloud credential's client ID during cluster deployment.
     */
    clientId: string;
    /**
     * The secret password associated with the service principal in plain text.
     */
    secret?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterPropertyWindowsProfile {
    /**
     * Specifies the name of the administrator account.
     */
    adminUsername: string;
    /**
     * Enable CSI proxy
     */
    enableCsiProxy?: boolean;
    /**
     * The license type to use for Windows VMs.
     */
    licenseType?: string;
}

export interface GetAksClusterSpecClusterConfigSpecManagedClusterSkus {
    /**
     * The name of a managed cluster SKU.
     */
    name?: string;
    /**
     * Valid values are Paid, Free.
     */
    tier?: string;
}

export interface GetAksClusterSpecClusterConfigSpecNodePool {
    /**
     * The AKS node pool api version
     */
    apiversion: string;
    /**
     * AKS cluster location
     */
    location: string;
    /**
     * The AKS node pool name
     */
    name: string;
    /**
     * The AKS managed cluster
     */
    properties: outputs.GetAksClusterSpecClusterConfigSpecNodePoolProperty[];
    /**
     * The AKS node pool type
     */
    type?: string;
}

export interface GetAksClusterSpecClusterConfigSpecNodePoolProperty {
    /**
     * The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is VirtualMachineScaleSets.
     */
    availabilityZones?: string[];
    /**
     * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
     */
    count?: number;
    /**
     * Whether to enable auto-scaler
     */
    enableAutoScaling?: boolean;
    /**
     * This is only supported on certain VM sizes and in certain Azure regions.
     */
    enableEncryptionAtHost?: boolean;
    /**
     * See Add a FIPS-enabled node pool for more details.
     */
    enableFips?: boolean;
    /**
     * Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see assigning a public IP per node. The default is false.
     */
    enableNodePublicIp?: boolean;
    /**
     * Whether to enable UltraSSD
     */
    enableUltraSsd?: boolean;
    /**
     * GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
     */
    gpuInstanceProfile?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    kubeletConfigs?: outputs.GetAksClusterSpecClusterConfigSpecNodePoolPropertyKubeletConfig[];
    /**
     * Valid values are OS, Temporary.
     */
    kubeletDiskType?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    linuxOsConfigs?: outputs.GetAksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfig[];
    /**
     * The maximum number of nodes for auto-scaling.
     */
    maxCount?: number;
    /**
     * The maximum number of pods that can run on a node.
     */
    maxPods?: number;
    /**
     * The minimum number of nodes for auto-scaling
     */
    minCount?: number;
    /**
     * The mode for a node pool which defines a node pool's primary function. If set as 'System', AKS prefers system pods scheduling to node pools with mode System. Accepted values: System, User
     */
    mode?: string;
    /**
     * Valid values are System, User.
     */
    nodeLabels?: {[key: string]: string};
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
     */
    nodePublicIpPrefixId?: string;
    /**
     * The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
     */
    nodeTaints?: string[];
    /**
     * The AKS node pool Kubernetes version
     */
    orchestratorVersion?: string;
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool.
     */
    osDiskSizeGb?: number;
    /**
     * Valid values are Managed, Ephemeral.
     */
    osDiskType?: string;
    /**
     * Valid values are Ubuntu, CBLMariner.
     */
    osSku?: string;
    /**
     * Valid values are Linux, Windows.
     */
    osType?: string;
    /**
     * If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    podSubnetId?: string;
    /**
     * The ID for Proximity Placement Group.
     */
    proximityPlacementGroupId?: string;
    /**
     * This cannot be specified unless the scaleSetPriority is Spot
     */
    scaleSetEvictionPolicy?: string;
    /**
     * The Virtual Machine Scale Set priority.
     */
    scaleSetPriority?: string;
    /**
     * Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see spot VMs pricing
     */
    spotMaxPrice?: number;
    /**
     * The tags to be persisted on the agent pool virtual machine scale set.
     */
    tags?: {[key: string]: string};
    /**
     * Valid values are VirtualMachineScaleSets, AvailabilitySet.
     */
    type?: string;
    /**
     * Settings for upgrading an agentpool
     */
    upgradeSettings?: outputs.GetAksClusterSpecClusterConfigSpecNodePoolPropertyUpgradeSetting[];
    /**
     * The AKS node pool VM size
     */
    vmSize?: string;
    /**
     * If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes.
     */
    vnetSubnetId?: string;
}

export interface GetAksClusterSpecClusterConfigSpecNodePoolPropertyKubeletConfig {
    /**
     * Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in *).
     */
    allowedUnsafeSysctls?: string[];
    /**
     * The maximum number of container log files that can be present for a container. The number must be ≥ 2.
     */
    containerLogMaxFiles?: number;
    /**
     * The maximum size (e.g. 10Mi) of container log file before it is rotated.
     */
    containerLogMaxSizeMb?: number;
    /**
     * The default is true.
     */
    cpuCfsQuota?: boolean;
    /**
     * Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix.
     */
    cpuCfsQuotaPeriod?: string;
    /**
     * See Kubernetes CPU management policies for more information
     */
    cpuManagerPolicy?: string;
    /**
     * If set to true it will make the Kubelet fail to start if swap is enabled on the node.
     */
    failSwapOn?: boolean;
    /**
     * To disable image garbage collection, set to 100. The default is 85%
     */
    imageGcHighThreshold?: number;
    /**
     * This cannot be set higher than imageGcHighThreshold. The default is 80%
     */
    imageGcLowThreshold?: number;
    /**
     * The maximum number of processes per pod.
     */
    podMaxPids?: number;
    /**
     * Allowed values are none, best-effort, restricted, and single-numa-node.
     */
    topologyManagerPolicy?: string;
}

export interface GetAksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfig {
    /**
     * The size in MB of a swap file that will be created on each node.
     */
    swapFileSizeMb?: number;
    /**
     * Sysctl settings for Linux agent nodes.
     */
    sysctls?: outputs.GetAksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfigSysctl[];
    /**
     * Valid values are always, defer, defer+madvise, madvise and never.
     */
    transparentHugePageDefrag?: string;
    /**
     * Valid values are always, madvise, and never.
     */
    transparentHugePageEnabled?: string;
}

export interface GetAksClusterSpecClusterConfigSpecNodePoolPropertyLinuxOsConfigSysctl {
    /**
     * Sysctl setting fs.aio-max-nr.
     */
    fsAioMaxNr?: number;
    /**
     * Sysctl setting fs.file-max.
     */
    fsFileMax?: number;
    /**
     * Sysctl setting fs.inotify.max_user_watches.
     */
    fsInotifyMaxUserWatches?: number;
    /**
     * Sysctl setting fs.nr_open.
     */
    fsNrOpen?: number;
    /**
     * Sysctl setting kernel.threads-max.
     */
    kernelThreadsMax?: number;
    /**
     * Sysctl setting net.core.netdev_max_backlog.
     */
    netCoreNetdevMaxBacklog?: number;
    /**
     * Sysctl setting net.core.optmem_max.
     */
    netCoreOptmemMax?: number;
    /**
     * Sysctl setting net.core.rmem_default.
     */
    netCoreRmemDefault?: number;
    /**
     * Sysctl setting net.core.rmem_max.
     */
    netCoreRmemMax?: number;
    /**
     * Sysctl setting net.core.somaxconn.
     */
    netCoreSomaxconn?: number;
    /**
     * Sysctl setting net.core.wmem_default.
     */
    netCoreWmemDefault?: number;
    /**
     * Sysctl setting net.core.wmem_max.
     */
    netCoreWmemMax?: number;
    /**
     * Sysctl setting net.ipv4.ip_local_port_range.
     */
    netIpv4IpLocalPortRange?: string;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh1.
     */
    netIpv4NeighDefaultGcThresh1?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh2.
     */
    netIpv4NeighDefaultGcThresh2?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh3.
     */
    netIpv4NeighDefaultGcThresh3?: number;
    /**
     * Sysctl setting net.ipv4.tcp_fin_timeout.
     */
    netIpv4TcpFinTimeout?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_probes.
     */
    netIpv4TcpKeepaliveProbes?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_time.
     */
    netIpv4TcpKeepaliveTime?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_syn_backlog.
     */
    netIpv4TcpMaxSynBacklog?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_tw_buckets.
     */
    netIpv4TcpMaxTwBuckets?: number;
    /**
     * Sysctl setting net.ipv4.tcp_tw_reuse.
     */
    netIpv4TcpTwReuse?: boolean;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_intvl.
     */
    netIpv4TcpkeepaliveIntvl?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_buckets.
     */
    netNetfilterNfConntrackBuckets?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_max.
     */
    netNetfilterNfConntrackMax?: number;
    /**
     * Sysctl setting vm.max_map_count.
     */
    vmMaxMapCount?: number;
    /**
     * Sysctl setting vm.swappiness.
     */
    vmSwappiness?: number;
    /**
     * Sysctl setting vm.vfs_cache_pressure.
     */
    vmVfsCachePressure?: number;
}

export interface GetAksClusterSpecClusterConfigSpecNodePoolPropertyUpgradeSetting {
    /**
     * This can either be set to an integer (e.g. 5) or a percentage (e.g. 50%)
     */
    maxSurge?: string;
}

export interface GetAksClusterSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.GetAksClusterSpecSharingProject[];
}

export interface GetAksClusterSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface GetAksClusterSpecSystemComponentsPlacement {
    /**
     * Allows users to override the default behaviour of DaemonSet for specific nodes, enabling the addition of additional tolerations for Daemonsets to match the taints available on the nodes.
     */
    daemonsetOverrides?: outputs.GetAksClusterSpecSystemComponentsPlacementDaemonsetOverride[];
    /**
     * Key-Value pairs insuring pods to be scheduled on desired nodes.
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Enables the kuberenetes scheduler to schedule pods with matching taints.
     */
    tolerations?: outputs.GetAksClusterSpecSystemComponentsPlacementToleration[];
}

export interface GetAksClusterSpecSystemComponentsPlacementDaemonsetOverride {
    /**
     * enables node selection
     */
    nodeSelectionEnabled?: boolean;
    /**
     * Additional tolerations for Daemonsets to match the taints available on the nodes
     */
    tolerations?: outputs.GetAksClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration[];
}

export interface GetAksClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface GetAksClusterSpecSystemComponentsPlacementToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface GetAksClusterTimeouts {
    read?: string;
}

export interface GetAksClusterV3Metadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetAksClusterV3MetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetAksClusterV3MetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetAksClusterV3MetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetAksClusterV3MetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetAksClusterV3Spec {
    /**
     * The blueprint to be used for this cluster. Use this for GKE/EKSABM/MKS cluster type
     */
    blueprint?: outputs.GetAksClusterV3SpecBlueprint;
    /**
     * The blueprint configuration to be used for this cluster. For EKS/AKS cluster types use this. But in future this will be deprecated in favor of blueprint
     */
    blueprintConfig?: outputs.GetAksClusterV3SpecBlueprintConfig;
    /**
     * The credentials to be used to interact with the cloud infrastructure
     */
    cloudCredentials?: string;
    config?: outputs.GetAksClusterV3SpecConfig;
    /**
     * Role ARN of the cross account support
     */
    crossAccountRoleArn?: string;
    /**
     * Configuration for drift handling
     */
    drift?: outputs.GetAksClusterV3SpecDrift;
    /**
     * The gateway details to be relayed commands for cluster operations. Use this for EKSABM cluster type
     */
    gateway?: outputs.GetAksClusterV3SpecGateway;
    /**
     * The proxy to be used for this cluster. Use this for GKE/MKS cluster type
     */
    proxy?: outputs.GetAksClusterV3SpecProxy;
    /**
     * The proxy configuration to be used for this cluster. For EKS/AKS cluster types use this. This will be deprecated in favor of proxy
     */
    proxyConfig?: outputs.GetAksClusterV3SpecProxyConfig;
    /**
     * Sharing spec to be used for sharing the cluster with projects
     */
    sharing?: outputs.GetAksClusterV3SpecSharing;
    /**
     * The system components for the placements of the workloads
     */
    systemComponentsPlacement?: outputs.GetAksClusterV3SpecSystemComponentsPlacement;
    /**
     * The type of the cluster this spec corresponds to
     */
    type?: string;
}

export interface GetAksClusterV3SpecBlueprint {
    name?: string;
    version?: string;
}

export interface GetAksClusterV3SpecBlueprintConfig {
    name?: string;
    version?: string;
}

export interface GetAksClusterV3SpecConfig {
    apiVersion?: string;
    /**
     * Control plane configuration for the cluster
     */
    controlPlane?: outputs.GetAksClusterV3SpecConfigControlPlane;
    /**
     * The IP address used for the control plane endpoint
     */
    controlPlaneEndpointIp?: string;
    /**
     * Kubernetes version of ControlPlane
     */
    controlPlaneVersion?: string;
    /**
     * The vSphere data center where the cluster nodes will be launched
     */
    dataCenter?: string;
    /**
     * The vSphere storage in the selected data center to launch the cluster nodes
     */
    dataStore?: string;
    /**
     * EKSA cluster configuration
     */
    eksaClusterConfig?: outputs.GetAksClusterV3SpecConfigEksaClusterConfig;
    /**
     * EksaBm Project name.
     */
    eksabmProject?: string;
    /**
     * GKE cluster additional features configuration.
     */
    features?: outputs.GetAksClusterV3SpecConfigFeatures;
    /**
     * GCP Project name.
     */
    gcpProject?: string;
    kind?: string;
    /**
     * kubernetes provider of the cluster
     */
    kubernetesProvider?: string;
    /**
     * GKE cluster location configuration.
     */
    location?: outputs.GetAksClusterV3SpecConfigLocation;
    /**
     * MachineHealthCheck configuration for the cluster
     */
    machineHealthChecks?: outputs.GetAksClusterV3SpecConfigMachineHealthCheck[];
    metadata?: outputs.GetAksClusterV3SpecConfigMetadata;
    /**
     * GKE cluster Network configuration.
     */
    network?: outputs.GetAksClusterV3SpecConfigNetwork;
    /**
     * GKE cluster node pool configuration.
     */
    nodePools?: outputs.GetAksClusterV3SpecConfigNodePool[];
    /**
     * Commands will be executed every time Cluster nodes come up. Example: Node Creation, Node Restart.
     */
    preBootstrapCommands?: string[];
    /**
     * provisioning environment for the cluster
     */
    provisionEnvironment?: string;
    /**
     * Proxy configuration for the cluster
     */
    proxy?: outputs.GetAksClusterV3SpecConfigProxy;
    raw?: string;
    /**
     * The vSphere resource pool where the cluster nodes will be launched
     */
    resourcePool?: string;
    /**
     * GKE cluster Network configuration.
     */
    security?: outputs.GetAksClusterV3SpecConfigSecurity;
    spec?: outputs.GetAksClusterV3SpecConfigSpec;
    /**
     * EKSA data center where cluster will be launched
     */
    tinkerbellDatacenterConfig?: outputs.GetAksClusterV3SpecConfigTinkerbellDatacenterConfig;
    /**
     * EKSA hardware configuration that will serve as nodes for the cluster
     */
    tinkerbellHardwareConfigs?: outputs.GetAksClusterV3SpecConfigTinkerbellHardwareConfig[];
    /**
     * EKSA machine configuration to associate control-plane/worker-node-group with users and template
     */
    tinkerbellMachineConfigs?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfig[];
    /**
     * EKSA template details that will be run as workflow for the node provisioning
     */
    tinkerbellTemplateConfigs?: outputs.GetAksClusterV3SpecConfigTinkerbellTemplateConfig[];
    /**
     * The certificate thumbprint for the vCenter server
     */
    vCenterCaTlsThumbprint?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmFolder?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmTemplate?: string;
    /**
     * Network configuration for the cluster
     */
    vsphereNetwork?: outputs.GetAksClusterV3SpecConfigVsphereNetwork;
    /**
     * Nodepools configuration for the cluster
     */
    vsphereNodePools?: outputs.GetAksClusterV3SpecConfigVsphereNodePool[];
    /**
     * Worker nodes configuration for the cluster
     */
    workerNodes?: outputs.GetAksClusterV3SpecConfigWorkerNodes;
}

export interface GetAksClusterV3SpecConfigControlPlane {
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * kubeadmconfig spec to run on the control plane nodes
     */
    kubeadmConfigSpec?: outputs.GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpec;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
}

export interface GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpec {
    /**
     * Files to be added to the kubeadm config
     */
    files?: outputs.GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFile[];
    /**
     * Prekubeadmcommands to run on the nodepools
     */
    preKubeadmCommands?: string[];
}

export interface GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFile {
    /**
     * Append to the file
     */
    append?: boolean;
    /**
     * Content of the file
     */
    content?: string;
    /**
     * ContentFrom
     */
    contentFrom?: outputs.GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFrom;
    /**
     * Encoding of the file
     */
    encoding?: string;
    /**
     * Owner of the file
     */
    owner?: string;
    /**
     * Path of the file
     */
    path?: string;
    /**
     * Permissions of the file
     */
    permissions?: string;
}

export interface GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFrom {
    /**
     * Secret
     */
    secret?: outputs.GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFromSecret;
}

export interface GetAksClusterV3SpecConfigControlPlaneKubeadmConfigSpecFileContentFromSecret {
    /**
     * Key
     */
    key?: string;
    /**
     * Name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfig {
    /**
     * Api version of EKSA cluster resource
     */
    apiVersion?: string;
    /**
     * Kind of EKSA cluster resource
     */
    kind?: string;
    /**
     * Metadata associated with the EKSA cluster configuration
     */
    metadata?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigMetadata;
    /**
     * Specifications of EKSA cluster configuration
     */
    spec?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpec;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigMetadata {
    /**
     * EKSA Cluster Annotations
     */
    annotations?: {[key: string]: string};
    /**
     * EKSA Cluster Labels
     */
    labels?: {[key: string]: string};
    /**
     * EKSA Cluster Name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpec {
    /**
     * Configuration specific to network of cluster
     */
    clusterNetwork?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetwork;
    /**
     * Specific control plane configuration for your Kubernetes cluster
     */
    controlPlaneConfiguration?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfiguration;
    /**
     * Refers to the kubernetes object with tinkerbell specific configuration
     */
    dataCenterRef?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecDataCenterRef;
    /**
     * The Kubernetes version you want to use for your cluster
     */
    kubernetesVersion?: string;
    /**
     * details of management cluster
     */
    managementCluster?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecManagementCluster;
    /**
     * This takes in a list of node groups that you can define for your workers
     */
    workerNodeGroupConfigurations?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfiguration[];
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetwork {
    /**
     * CNI plugin to be installed in the cluster. The only supported value at the moment is cilium
     */
    cniConfig?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfig;
    /**
     * Node configurations
     */
    nodes?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkNodes;
    /**
     * Pod configurations
     */
    pods?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkPods;
    /**
     * Configuration specific to setup a proxy of cluster network
     */
    proxy?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkProxy;
    /**
     * Service configurations
     */
    services?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkServices;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfig {
    /**
     * Cilium configuration
     */
    cilium?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigCilium;
    /**
     * Kindnetd configuration
     */
    kindnetd?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigKindnetd;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigCilium {
    /**
     * PolicyEnforcementMode
     */
    policyEnforcementMode?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkCniConfigKindnetd {
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkNodes {
    /**
     * CidrMaskSize
     */
    cidrMaskSize?: number;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkPods {
    /**
     * Subnet used by pods in CIDR notation
     */
    cidrBlocks?: string[];
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkProxy {
    /**
     * AllowInsecureBootstrap
     */
    allowInsecureBootstrap?: boolean;
    /**
     * BootStrapCA
     */
    bootStrapCa?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * HttpProxy
     */
    httpProxy?: string;
    /**
     * HttpsProxy
     */
    httpsProxy?: string;
    /**
     * NoProxy
     */
    noProxy?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecClusterNetworkServices {
    /**
     * Subnet used by pods in CIDR notation
     */
    cidrBlocks?: string[];
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfiguration {
    /**
     * Number of control plane nodes
     */
    count?: number;
    /**
     * Control plane endpoint details
     */
    endpoint?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationEndpoint;
    /**
     * A list of labels to apply to the control plane nodes of the cluster. This is in addition to the labels that EKS Anywhere will add by default
     */
    labels?: {[key: string]: string};
    /**
     * Refers to the Kubernetes object with Tinkerbell-specific configuration for your nodes
     */
    machineGroupRef?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationMachineGroupRef;
    /**
     * Rollout strategy for cp nodes in case of upgrade operation - currently being set to defaults
     */
    rolloutStrategy?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategy;
    /**
     * A list of taints to apply to the control plane nodes of the cluster
     */
    taints?: {[key: string]: string};
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationEndpoint {
    /**
     * A unique IP you want to use for the control plane in your EKS Anywhere cluster. Choose an IP in your network range that does not conflict with other machines.
     */
    host?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationMachineGroupRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategy {
    /**
     * Configurations related to rolling update.
     */
    rollingUpdate?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategyRollingUpdate;
    /**
     * Rollout strategy type - Default: 'RollingUpdate'.
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecControlPlaneConfigurationRolloutStrategyRollingUpdate {
    /**
     * Maximum number of machines that can be scheduled above the desired number of machines - Default: 1.
     */
    maxSurge?: number;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecDataCenterRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecManagementCluster {
    /**
     * Identifies the name of the management cluster.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfiguration {
    /**
     * Number of worker nodes
     */
    count?: number;
    /**
     * A list of labels to apply to the nodes in the worker node group. This is in addition to the labels that EKS Anywhere will add by default.
     */
    labels?: {[key: string]: string};
    /**
     * Refers to the Kubernetes object with Tinkerbell-specific configuration for your nodes
     */
    machineGroupRef?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationMachineGroupRef;
    /**
     * Worker node group's name
     */
    name?: string;
    /**
     * Rollout strategy for worker node group nodes in case of upgrade operation - currently being set to defaults
     */
    rolloutStrategy?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategy;
    /**
     * A list of taints to apply to the nodes in the worker node group. At least one node group must not have NoSchedule or NoExecute taints applied to it.
     */
    taints?: {[key: string]: string};
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationMachineGroupRef {
    /**
     * Refers to the kind of resource to be associated with.
     */
    kind?: string;
    /**
     * Refers to the name of resource to be associated with of above kind.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategy {
    /**
     * Configurations related to rolling update.
     */
    rollingUpdate?: outputs.GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategyRollingUpdate;
    /**
     * Rollout strategy type - Default: 'RollingUpdate'.
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigEksaClusterConfigSpecWorkerNodeGroupConfigurationRolloutStrategyRollingUpdate {
    /**
     * Maximum number of machines that can be scheduled above the desired number of machines - Default: 1.
     */
    maxSurge?: number;
    /**
     * Maximum number of machines that can be unavailable during the upgrade - Default: 0.
     */
    maxUnavailable?: number;
}

export interface GetAksClusterV3SpecConfigFeatures {
    /**
     * List of components for cloud logging
     */
    cloudLoggingComponents?: string[];
    /**
     * List of components for cloud monitoring
     */
    cloudMonitoringComponents?: string[];
    /**
     * Application Manager is a GKE controller for managing the lifecycle of applications. It enables application delivery and updates following Kubernetes and GitOps best practices
     */
    enableApplicationManagerBeta?: boolean;
    /**
     * Backup for GKE allows you to back up and restore GKE workloads. There is no cost for enabling this feature, but you are charged for backups based on the size of the data and the number of pods you protect
     */
    enableBackupForGke?: boolean;
    /**
     * Logging collects logs emitted by your applications and by GKE infrastructure
     */
    enableCloudLogging?: boolean;
    /**
     * Monitoring collects metrics emitted by your applications and by GKE infrastructure
     */
    enableCloudMonitoring?: boolean;
    /**
     * Enable to automatically deploy and manage the Compute Engine Persistent Disk CSI Driver. This feature is an alternative to using the gcePersistentDisk in-tree volume plugin
     */
    enableComputeEnginePersistentDiskCsiDriver?: boolean;
    /**
     * Enable to automatically deploy and manage the Filestore CSI Driver
     */
    enableFilestoreCsiDriver?: boolean;
    /**
     * Image streaming allows your workloads to initialize without waiting for the entire image to download
     */
    enableImageStreaming?: boolean;
    /**
     * This option deploys managed collectors for Prometheus metrics within this cluster. These collectors must be configured using PodMonitoring resources. To enable Managed Service for Prometheus here, you'll need. Cluster version of 1.21.4-gke.300 or greater
     */
    enableManagedServicePrometheus?: boolean;
}

export interface GetAksClusterV3SpecConfigLocation {
    config?: outputs.GetAksClusterV3SpecConfigLocationConfig;
    /**
     * For Zonal cluster increase availability by selecting more than one zone. For Regional cluster By default, Kubernetes Engine runs nodes of a regional cluster across three zones within a region. Select this option if you want to manually specify the zones in which this cluster's nodes run. All zones must be within the same region.
     */
    defaultNodeLocations?: outputs.GetAksClusterV3SpecConfigLocationDefaultNodeLocations;
    /**
     * GKE Cluster location can be either zonal or regional
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigLocationConfig {
    /**
     * Regional location in which the cluster's control plane and nodes are located
     */
    region?: string;
    /**
     * Zone in the region where bootstrap VM is created for cluster provisioning
     */
    zone?: string;
}

export interface GetAksClusterV3SpecConfigLocationDefaultNodeLocations {
    /**
     * Enable providing default node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Increase availability by providing more than one zone. The same number of nodes will be deployed to each zone in the list.
     */
    zones?: string[];
}

export interface GetAksClusterV3SpecConfigMachineHealthCheck {
    /**
     * Machines selected by selector are not healthy.
     */
    maxUnHealthy?: string;
    /**
     * Name of the MachineHealthCheck
     */
    name?: string;
    /**
     * Machines older than this duration without a node will be considered to have failed and will be remediated.
     */
    nodeStartupTimeout?: string;
    /**
     * Kubeadmcontrolplane remediation strategy
     */
    remediationStrategy?: outputs.GetAksClusterV3SpecConfigMachineHealthCheckRemediationStrategy;
    /**
     * RemediationTemplate is a reference to a remediation template provided by an infrastructure provider
     */
    remediationTemplate?: outputs.GetAksClusterV3SpecConfigMachineHealthCheckRemediationTemplate;
    /**
     * Label selector to match machines whose health will be exercised
     */
    selector?: outputs.GetAksClusterV3SpecConfigMachineHealthCheckSelector;
    /**
     * UnhealthyConditions contains a list of the conditions that determine whether a node is considered unhealthy
     */
    unhealthyConditions?: outputs.GetAksClusterV3SpecConfigMachineHealthCheckUnhealthyCondition[];
    /**
     * UnhealthyRange specifies the range of machine health check failures that will be tolerated
     */
    unhealthyRange?: string;
}

export interface GetAksClusterV3SpecConfigMachineHealthCheckRemediationStrategy {
    /**
     * MaxRetry is the maximum number of remediation attempts.
     */
    maxRetry?: number;
    /**
     * MinHealthyPeriod is the minimum time to wait before remediation is attempted.
     */
    minHealthyPeriod?: string;
    /**
     * RetryPeriod is the time to wait between remediation attempts.
     */
    retryPeriod?: string;
}

export interface GetAksClusterV3SpecConfigMachineHealthCheckRemediationTemplate {
    /**
     * APIVersion defines the versioned schema of this representation of an object.
     */
    apiVersion?: string;
    /**
     * FieldPath is the path of the field to select in the specified API version.
     */
    fieldPath?: string;
    /**
     * Kind is a string value representing the REST resource this object represents.
     */
    kind?: string;
    /**
     * Name of the referent.
     */
    name?: string;
    /**
     * Namespace of the referent.
     */
    namespace?: string;
    /**
     * ResourceVersion is an opaque identifier that is used to distinguish between multiple versions of a same resource.
     */
    resourceVersion?: string;
    /**
     * UID is a unique id generated by the server on successful creation of a resource and is not propagated to the client.
     */
    uId?: string;
}

export interface GetAksClusterV3SpecConfigMachineHealthCheckSelector {
    /**
     * MatchExpressions is a list of label selector requirements.
     */
    matchExpressions?: outputs.GetAksClusterV3SpecConfigMachineHealthCheckSelectorMatchExpression[];
    /**
     * MatchLabels is a map of {key,value} pairs.
     */
    matchLabels?: {[key: string]: string};
}

export interface GetAksClusterV3SpecConfigMachineHealthCheckSelectorMatchExpression {
    /**
     * Key is the label key that the selector applies to.
     */
    key?: string;
    /**
     * Operator represents a key's relationship to a set of values.
     */
    operator?: string;
    /**
     * Values is an array of string values.
     */
    values?: string[];
}

export interface GetAksClusterV3SpecConfigMachineHealthCheckUnhealthyCondition {
    /**
     * Status indicates the state of the condition.
     */
    status?: string;
    /**
     * Timeout for the condition.
     */
    timeout?: string;
    /**
     * Type of the condition.
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigMetadata {
    name?: string;
}

export interface GetAksClusterV3SpecConfigNetwork {
    /**
     * NetworkAccess config for describing access configurations for the cluster's workload
     */
    access?: outputs.GetAksClusterV3SpecConfigNetworkAccess;
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    controlPlaneAuthorizedNetwork?: outputs.GetAksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetwork;
    /**
     * Dataplane V2 is optimized for Kubernetes networking kwhich is implemented using eBPF. Possible values: ADVANCED_DATAPATH.
     */
    dataPlaneV2?: string;
    /**
     * Dataplane V2 metrics brings better insight into the traffic between your Kubernetes workloads. Understand how your services communicate, identify issues with the network health, verify Kubernetes policies and more.
     */
    enableDataPlaneV2Metrics?: boolean;
    /**
     * Dataplane V2 observability provides Managed Hubble CLI solution that lets you observe network flows between your Kubernetes workloads in real time.
     */
    enableDataPlaneV2Observability?: boolean;
    /**
     * This feature uses alias IP and provides a more secure integration with Google Cloud Platform services
     */
    enableVpcNativetraffic?: boolean;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * Name of the network that the cluster is in. It determines which other Compute Engine resource it is able to communicate with
     */
    name?: string;
    /**
     * The Kubernetes Network Policy API allows the cluster administrator to specify what pods are allowed to communicate with each other. Possible values: CALICO
     */
    networkPolicy?: string;
    /**
     * Configuration for NetworkPolicy. This only tracks whether the addon is enabled or not on the Master,it does not track whether network policy is enabled for the nodes.
     */
    networkPolicyConfig?: boolean;
    /**
     * All pods in the cluster are assigned an IP address from this range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    podAddressRange?: string;
    /**
     * Cluster pods are assigned an IP from the selected node subnet's secondary CIDR address range.
     */
    podSecondaryRangeName?: string;
    /**
     * Cluster services will be assigned an IP address from this IP address range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    serviceAddressRange?: string;
    /**
     * Cluster services are assigned an IP from the selected node subnetes secondary CIDR address range.
     */
    serviceSecondaryRangeName?: string;
    /**
     * Subnetwork to which the Kubernetes cluster will belong. When VPC native is enabled, the subnetwork must contain at least two secondary ranges which are not used by other Kubernetes clusters. Subnet is permanent.
     */
    subnetName?: string;
}

export interface GetAksClusterV3SpecConfigNetworkAccess {
    config?: outputs.GetAksClusterV3SpecConfigNetworkAccessConfig;
    /**
     * Choose the type of network you want to allow to access your cluster's workloads. private or public
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigNetworkAccessConfig {
    /**
     * Control plane IP range is for the control plane VPC. The control plane range must not overlap with any subnet in your cluster's VPC. The control plane and your cluster use VPC peering to communicate privately
     */
    controlPlaneIpRange?: string;
    /**
     * To use Privately Used Public IPs (PUPI) ranges, the default source NAT used for IP masquerading needs to be disabled
     */
    disableSnat?: boolean;
    /**
     * Disabling this option locks down external access to the cluster control plane. There is still an external IP address used by Google for cluster management purposes, but the IP address is not accessible to anyone
     */
    enableAccessControlPlaneExternalIp?: boolean;
    /**
     * With control plane global access, you can access the control plane's private endpoint from any GCP region or on-premises environment no matter what the private cluster's region is
     */
    enableAccessControlPlaneGlobal?: boolean;
    /**
     * Use FirewallRule config to specify additional firewall rules. Only Private clusters are supported.By default, tcp:9443 and tcp:22281 are opened for private cluster.
     */
    firewallRules?: outputs.GetAksClusterV3SpecConfigNetworkAccessConfigFirewallRule[];
}

export interface GetAksClusterV3SpecConfigNetworkAccessConfigFirewallRule {
    action?: string;
    description?: string;
    destinationRanges?: string[];
    direction?: string;
    name?: string;
    network?: string;
    priority?: number;
    rules?: outputs.GetAksClusterV3SpecConfigNetworkAccessConfigFirewallRuleRule[];
    sourceRanges?: string[];
    targetTags?: string[];
}

export interface GetAksClusterV3SpecConfigNetworkAccessConfigFirewallRuleRule {
    ports?: string[];
    protocol?: string;
}

export interface GetAksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetwork {
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    authorizedNetworks?: outputs.GetAksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork[];
    /**
     * Enable Control Plane Authorized Network. Configure the Networks now or later.
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork {
    /**
     * CIDR Example: 198.51.100.0/24
     */
    cidr?: string;
    /**
     * Name of the Authorized Network Example: Corporate Office
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigNodePool {
    /**
     * Cluster autoscaler automatically creates or deletes nodes based on workload needs
     */
    autoScaling?: outputs.GetAksClusterV3SpecConfigNodePoolAutoScaling;
    /**
     * Choose the machine configuration that will best fit the resource needs of your cluster
     */
    machineConfig?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfig;
    /**
     * Node management configuration
     */
    management?: outputs.GetAksClusterV3SpecConfigNodePoolManagement;
    /**
     * Node metadata settings will be used when new nodes are created using this node pool
     */
    metadata?: outputs.GetAksClusterV3SpecConfigNodePoolMetadata;
    /**
     * Node pool names must start with a lowercase letter followed by up to 39 lowercase letters, numbers, or hyphens. They can't end with a hyphen. You cannot change the node pool's name once it's created
     */
    name?: string;
    /**
     * Node networking settings will be used when new nodes are created using this node pool
     */
    networking?: outputs.GetAksClusterV3SpecConfigNodePoolNetworking;
    /**
     * Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    nodeLocations?: outputs.GetAksClusterV3SpecConfigNodePoolNodeLocations;
    /**
     * Specify Node k8s version
     */
    nodeVersion?: string;
    /**
     * Node security settings will be used when new nodes are created using this node pool
     */
    security?: outputs.GetAksClusterV3SpecConfigNodePoolSecurity;
    /**
     * Pod address range limits the maximum size of the cluster
     */
    size?: number;
    /**
     * Node pool upgrade options
     */
    upgradeSettings?: outputs.GetAksClusterV3SpecConfigNodePoolUpgradeSettings;
}

export interface GetAksClusterV3SpecConfigNodePoolAutoScaling {
    /**
     * Maximum number of nodes (per zone)
     */
    maxNodes?: number;
    /**
     * Minimum number of nodes (per zone)
     */
    minNodes?: number;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfig {
    /**
     * Add accelerators to the node pool
     */
    accelerators?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfigAccelerator[];
    /**
     * Select Boot disk size. Boot disk size is permanent
     */
    bootDiskSize?: number;
    /**
     * Select Boot disk type. Storage space is less expensive for a standard persistent disk. An SSD persistent disk is better for random IOPS or for streaming throughput with low latency
     */
    bootDiskType?: string;
    /**
     * Choose which operating system image you want to run on each node of this cluster
     */
    imageType?: string;
    /**
     * Choose the machine type that will best fit the resource needs of your cluster
     */
    machineType?: string;
    /**
     * Zonal compute reservation to this node pool
     */
    reservationAffinity?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfigReservationAffinity;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfigAccelerator {
    /**
     * GPU Sharing allows you to share a single GPU device with multipe containers
     */
    acceleratorSharing?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing;
    /**
     * Number of GPUs
     */
    count?: number;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    gpuDriverInstallation?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation;
    /**
     * Size of partitions to create on the GPU. Valid values are described in the guide - https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning
     */
    gpuPartitionSize?: string;
    /**
     * GPU Type
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing {
    /**
     * The max number of clients that can share a physical GPU device
     */
    maxSharedClients?: number;
    /**
     * The strategy to use for sharing GPUs . Example: Time-Sharing
     */
    strategy?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation {
    config?: outputs.GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig {
    /**
     * The version of the GPU driver to install
     */
    version?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMachineConfigReservationAffinity {
    /**
     * Type of reservation consumption.
     */
    consumeReservationType?: string;
    /**
     * The name of the Reservation to be consumed. Only mandatory when consumeReservationType is set to specific
     */
    reservationName?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolManagement {
    /**
     * Whether the nodes will be automatically upgraded
     */
    autoUpgrade?: boolean;
}

export interface GetAksClusterV3SpecConfigNodePoolMetadata {
    /**
     * Metadata to be stored in the instance
     */
    gceInstanceMetadatas?: outputs.GetAksClusterV3SpecConfigNodePoolMetadataGceInstanceMetadata[];
    /**
     * Use Kubernetes labels to control how workloads are scheduled to your nodes. Labels are applied to all nodes in this node pool and cannot be changed once the cluster is created
     */
    kubernetesLabels?: outputs.GetAksClusterV3SpecConfigNodePoolMetadataKubernetesLabel[];
    /**
     * A node taint lets you mark a node so that the scheduler avoids or prevents using it for certain Pods. Node taints can be used with tolerations to ensure that Pods aren't scheduled onto inappropriate nodes
     */
    nodeTaints?: outputs.GetAksClusterV3SpecConfigNodePoolMetadataNodeTaint[];
}

export interface GetAksClusterV3SpecConfigNodePoolMetadataGceInstanceMetadata {
    /**
     * Key for this metadata
     */
    key?: string;
    /**
     * Value for this metadata
     */
    value?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMetadataKubernetesLabel {
    /**
     * Key for this kubernetes label
     */
    key?: string;
    /**
     * Value for this kubernetes lable
     */
    value?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolMetadataNodeTaint {
    /**
     * Available effects are NoSchedule, PreferNoSchedule, NoExecute
     */
    effect?: string;
    /**
     * Key for this Taint effect
     */
    key?: string;
    /**
     * Value for this Taint effect
     */
    value?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolNetworking {
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    networkTags?: string[];
}

export interface GetAksClusterV3SpecConfigNodePoolNodeLocations {
    /**
     * Enable providing node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    zones?: string[];
}

export interface GetAksClusterV3SpecConfigNodePoolSecurity {
    /**
     * Integrity monitoring lets you monitor and verify the runtime boot integrity of your shielded nodes using Cloud Monitoring
     */
    enableIntegrityMonitoring?: boolean;
    /**
     * Secure boot helps protect your nodes against boot-level and kernel-level malware and rootkits
     */
    enableSecureBoot?: boolean;
}

export interface GetAksClusterV3SpecConfigNodePoolUpgradeSettings {
    config?: outputs.GetAksClusterV3SpecConfigNodePoolUpgradeSettingsConfig;
    /**
     * Update strategy of the node pool. Possible values are SURGE and BLUE_GREEN
     */
    strategy?: string;
}

export interface GetAksClusterV3SpecConfigNodePoolUpgradeSettingsConfig {
    /**
     * Number of blue nodes to drain in a batch.
     */
    batchNodeCount?: number;
    /**
     * Soak time after each batch gets drained.
     */
    batchSoakDuration?: string;
    /**
     * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be simultaneously unavailable during the upgrade process.
     */
    maxUnavailable?: number;
    /**
     * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.
     */
    nodePoolSoakDuration?: string;
}

export interface GetAksClusterV3SpecConfigProxy {
    /**
     * AllowInsecureBootstrap
     */
    allowInsecureBootstrap?: boolean;
    /**
     * BootStrapCA
     */
    bootstrapCa?: string;
    /**
     * Enabled
     */
    enabled?: boolean;
    /**
     * HttpProxy
     */
    httpProxy?: string;
    /**
     * HttpsProxy
     */
    httpsProxy?: string;
    /**
     * NoProxy
     */
    noProxy?: string;
    /**
     * ProxyAuth
     */
    proxyAuth?: string;
}

export interface GetAksClusterV3SpecConfigSecurity {
    /**
     * Google Groups for RBAC allows you to grant roles to all members of a Google Workspace group
     */
    enableGoogleGroupsForRbac?: boolean;
    /**
     * Enable legacy authorization to support in-cluster permissions for existing clusters or workflows. Prevents full RBAC support
     */
    enableLegacyAuthorization?: boolean;
    /**
     * Workload Identity lets you connect securely to Google APIs from Kubernetes Engine workloads
     */
    enableWorkloadIdentity?: boolean;
    /**
     * Clients use this base64-encoded public certificate to authenticate to the cluster endpoint. Certificates don’t rotate automatically and are difficult to revoke
     */
    issueClientCertificate?: boolean;
    /**
     * Provide the security groups here
     */
    securityGroup?: string;
}

export interface GetAksClusterV3SpecConfigSpec {
    managedCluster?: outputs.GetAksClusterV3SpecConfigSpecManagedCluster;
    nodePools?: outputs.GetAksClusterV3SpecConfigSpecNodePool[];
    resourceGroupName?: string;
    subscriptionId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedCluster {
    /**
     * Additional metadata associated with the managed cluster.
     */
    additionalMetadata?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadata;
    apiVersion?: string;
    extendedLocation?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterExtendedLocation;
    /**
     * Identity for the managed cluster.
     */
    identity?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterIdentity;
    /**
     * The geo-location where the resource lives
     */
    location?: string;
    /**
     * Properties of the managed cluster.
     */
    properties?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterProperties;
    /**
     * The SKU of a Managed Cluster.
     */
    sku?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterSku;
    /**
     * Resource tags.
     */
    tags?: {[key: string]: string};
    /**
     * Azure Resource Type
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadata {
    /**
     * Profile for Azure Container Registry configuration
     */
    acrProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfile;
    /**
     * If not specified, defaults to the resource group of the managed cluster. Valid only if the Log analytics workspace is specified.
     */
    omsWorkspaceLocation?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfile {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * The list of Azure Container Registry profiles.
     */
    registries?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry[];
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterAdditionalMetadataAcrProfileRegistry {
    /**
     * The name of the Azure Container Registry resource.
     */
    acrName?: string;
    /**
     * If not specified, defaults to the resource group of the managed cluster
     */
    resourceGroupName?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterExtendedLocation {
    /**
     * The name of the extended location.
     */
    name?: string;
    /**
     * The type of the extended location.
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterIdentity {
    /**
     * For more information see use managed identities in AKS. Valid values are SystemAssigned, UserAssigned, None.
     */
    type?: string;
    /**
     * The keys must be ARM resource IDs in the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
     */
    userAssignedIdentities?: {[key: string]: string};
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterProperties {
    /**
     * For more details see https://docs.microsoft.com/azure/aks/managed-aad
     */
    aadProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAadProfile;
    /**
     * The profile of managed cluster add-on.
     */
    addonProfiles?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfiles;
    /**
     * Access profile for managed cluster API server.
     */
    apiServerAccessProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesApiServerAccessProfile;
    /**
     * Parameters to be applied to the cluster-autoscaler when enabled
     */
    autoScalerProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAutoScalerProfile;
    /**
     * Auto upgrade profile for a managed cluster.
     */
    autoUpgradeProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAutoUpgradeProfile;
    /**
     * If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see disable local accounts.
     */
    disableLocalAccounts?: boolean;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}
     */
    diskEncryptionSetId?: string;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    dnsPrefix?: string;
    /**
     * (DEPRECATING) Whether to enable Kubernetes pod security policy (preview). This feature is set for removal on October 15th, 2020. Learn more at aka.ms/aks/azpodpolicy.
     */
    enablePodSecurityPolicy?: boolean;
    /**
     * Whether to enable Kubernetes Role-Based Access Control.
     */
    enableRbac?: boolean;
    /**
     * This cannot be updated once the Managed Cluster has been created.
     */
    fqdnSubdomain?: string;
    /**
     * Cluster HTTP proxy configuration.
     */
    httpProxyConfig?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesHttpProxyConfig;
    /**
     * Identities associated with the cluster.
     */
    identityProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfile;
    /**
     * Both patch version (e.g. 1.20.13) and (e.g. 1.20) are supported. When is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same once it has been created (e.g. 1.14.x > 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x > 1.15.x or 1.15.x > 1.16.x are allowed, however 1.14.x > 1.16.x is not allowed. See upgrading an AKS cluster for more details.
     */
    kubernetesVersion?: string;
    /**
     * Profile for Linux VMs in the container service cluster.
     */
    linuxProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfile;
    /**
     * Profile of network configuration.
     */
    networkProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfile;
    /**
     * The name of the resource group containing agent pool nodes.
     */
    nodeResourceGroup?: string;
    /**
     * See use https://learn.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity for more details on pod identity integration.
     */
    podIdentityProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfile;
    /**
     * See use https://learn.microsoft.com/en-us/azure/aks/start-stop-cluster?tabs=azure-cli for more details on cluster power state and its operations
     */
    powerState?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPowerState;
    /**
     * Private link resources associated with the cluster.
     */
    privateLinkResources?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPrivateLinkResource[];
    /**
     * Allow or deny public network access for AKS. Valid values are Enabled, Disabled.
     */
    publicNetworkAccess?: string;
    /**
     * Security profile for the container service cluster.
     */
    securityProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfile;
    /**
     * Information about a service principal identity for the cluster to use for manipulating Azure APIs.
     */
    servicePrincipalProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesServicePrincipalProfile;
    /**
     * Storage profile for the container service cluster.
     */
    storageProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfile;
    /**
     * Profile for Windows VMs in the managed cluster.
     */
    windowsProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfile;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAadProfile {
    /**
     * The list of AAD group object IDs that will have admin role of the cluster.
     */
    adminGroupObjectIds?: string[];
    /**
     * The client AAD application ID.
     */
    clientAppId?: string;
    /**
     * Whether to enable Azure RBAC for Kubernetes authorization.
     */
    enableAzureRbac?: boolean;
    /**
     * Whether to enable managed AAD.
     */
    managed?: boolean;
    /**
     * The server AAD application ID.
     */
    serverAppId?: string;
    /**
     * The server AAD application secret.
     */
    serverAppSecret?: string;
    /**
     * The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
     */
    tenantId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfiles {
    azureKeyvaultSecretsProvider?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProvider;
    azurePolicy?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzurePolicy;
    httpApplicationRouting?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesHttpApplicationRouting;
    ingressApplicationGateway?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGateway;
    omsAgent?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgent;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProvider {
    config?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProviderConfig;
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzureKeyvaultSecretsProviderConfig {
    enableSecretRotation?: string;
    rotationPollInterval?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesAzurePolicy {
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesHttpApplicationRouting {
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGateway {
    config?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGatewayConfig;
    /**
     * whether addon profile is enabled
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesIngressApplicationGatewayConfig {
    applicationGatewayId?: string;
    applicationGatewayName?: string;
    subnetCidr?: string;
    subnetId?: string;
    watchNamespace?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgent {
    config?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgentConfig;
    /**
     * Whether the addon profile is enabled
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAddonProfilesOmsAgentConfig {
    logAnalyticsWorkspaceResourceId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesApiServerAccessProfile {
    /**
     * IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see API server authorized IP ranges.
     */
    authorizedIpRanges?: string[];
    /**
     * Whether to disable run command for the cluster or not.
     */
    disableRunCommand?: boolean;
    /**
     * For more details, see https://learn.microsoft.com/en-us/azure/aks/private-clusters
     */
    enablePrivateCluster?: boolean;
    /**
     * Whether to create additional public FQDN for private cluster or not.
     */
    enablePrivateClusterPublicFqdn?: boolean;
    /**
     * The default is System. For more details see configure private DNS zone. Allowed values are system and none.
     */
    privateDnsZone?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAutoScalerProfile {
    /**
     * Valid values are true and false
     */
    balanceSimilarNodeGroups?: string;
    /**
     * If not specified, the default is random. See https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders for more information. Valid values are least-waste, most-pods, priority, random.
     */
    expander?: string;
    /**
     * The default is 10.
     */
    maxEmptyBulkDelete?: string;
    /**
     * The default is 600.
     */
    maxGracefulTerminationSec?: string;
    /**
     * The default is 15m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    maxNodeProvisionTime?: string;
    /**
     * The default is 45. The maximum is 100 and the minimum is 0.
     */
    maxTotalUnreadyPercentage?: string;
    /**
     * For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is 0s. Values must be an integer followed by a unit (s for seconds, m for minutes, h for hours, etc).
     */
    newPodScaleUpDelay?: string;
    /**
     * This must be an integer. The default is 3.
     */
    okTotalUnreadyCount?: string;
    /**
     * The default is 10m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterAdd?: string;
    /**
     * The default is the scan-interval. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterDelete?: string;
    /**
     * The default is 3m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownDelayAfterFailure?: string;
    /**
     * The default is 10m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownUnneededTime?: string;
    /**
     * The default is 20m. Values must be an integer followed by an m. No unit of time other than minutes (m) is supported.
     */
    scaleDownUnreadyTime?: string;
    /**
     * The default is 0.5.
     */
    scaleDownUtilizationThreshold?: string;
    /**
     * The default is 10. Values must be an integer number of seconds.
     */
    scanInterval?: string;
    /**
     * The default is true.
     */
    skipNodesWithLocalStorage?: string;
    /**
     * The default is true.
     */
    skipNodesWithSystemPods?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesAutoUpgradeProfile {
    /**
     * For more information see https://learn.microsoft.com/en-us/azure/aks/upgrade-cluster?tabs=azure-cli#set-auto-upgrade-channel. Valid values are rapid, stable, patch, node-image, none.
     */
    upgradeChannel?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesHttpProxyConfig {
    /**
     * The HTTP proxy server endpoint to use.
     */
    httpProxy?: string;
    /**
     * The HTTPS proxy server endpoint to use.
     */
    httpsProxy?: string;
    /**
     * The endpoints that should not go through proxy.
     */
    noProxies?: string[];
    /**
     * Alternative CA cert to use for connecting to proxy servers.
     */
    trustedCa?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfile {
    /**
     * Kubelet Identity for managed cluster identity profile
     */
    kubeletIdentity?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfileKubeletIdentity;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesIdentityProfileKubeletIdentity {
    /**
     * value must be ARM resource ID in the form: /subscriptions/<subscription-id>/resourceGroups/<resource-group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<identity-name>
     */
    resourceId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfile {
    /**
     * The administrator username to use for Linux VMs.
     */
    adminUsername?: string;
    /**
     * SSH configuration for Linux-based VMs running on Azure.
     */
    ssh?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSsh;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSsh {
    /**
     * The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
     */
    publicKeys?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSshPublicKey[];
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesLinuxProfileSshPublicKey {
    /**
     * Certificate public key used to authenticate with VMs through SSH. The certificate must be in PEM format with or without headers.
     */
    keyData?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfile {
    /**
     * An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
     */
    dockerBridgeCidr?: string;
    /**
     * IP families are used to determine single-stack or dual-stack clusters. For single-stack, the expected value is IPv4. For dual-stack, the expected values are IPv4 and IPv6.
     */
    ipFamilies?: string[];
    /**
     * Profile of the managed cluster load balancer.
     */
    loadBalancerProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfile;
    /**
     * The default is standard. See Azure Load Balancer SKUs for more information about the differences between load balancer SKUs. Valid values are standard, basic.
     */
    loadBalancerSku?: string;
    /**
     * Profile of the managed cluster NAT gateway.
     */
    natGatewayProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfile;
    /**
     * Valid values are cilium
     */
    networkDataplane?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are transparent, bridge.
     */
    networkMode?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are transparent, bridge.
     */
    networkPlugin?: string;
    /**
     * This cannot be specified if networkPlugin is anything other than azure. Valid values are overlay.
     */
    networkPluginMode?: string;
    /**
     * Network policy used for building the Kubernetes network. Valid values are calico, azure.
     */
    networkPolicy?: string;
    /**
     * This can only be set at cluster creation time and cannot be changed later. For more information see egress outbound type. Valid values are loadBalancer, userDefinedRouting, managedNATGateway, userAssignedNATGateway.
     */
    outboundType?: string;
    /**
     * A CIDR notation IP range from which to assign pod IPs when kubenet is used.
     */
    podCidr?: string;
    /**
     * One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking.
     */
    podCidrs?: string[];
    /**
     * A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
     */
    serviceCidr?: string;
    /**
     * One IPv4 CIDR is expected for single-stack networking. Two CIDRs, one for each IP family (IPv4/IPv6), is expected for dual-stack networking. They must not overlap with any Subnet IP ranges.
     */
    serviceCidrs?: string[];
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfile {
    /**
     * The desired number of allocated SNAT ports per VM. Allowed values are in the range of 0 to 64000 (inclusive). The default value is 0 which results in Azure dynamically allocating ports.
     */
    allocatedOutboundPorts?: number;
    /**
     * The effective outbound IP resources of the cluster load balancer.
     */
    effectiveOutboundIPs?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileEffectiveOutboundIP[];
    /**
     * Enable multiple standard load balancers per AKS cluster or not.
     */
    enableMultipleStandardLoadBalancers?: boolean;
    /**
     * Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 30 minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Desired managed outbound IPs for the cluster load balancer.
     */
    managedOutboundIPs?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileManagedOutboundIPs;
    /**
     * Desired outbound IP resources for the cluster load balancer.
     */
    outboundIPs?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPs;
    /**
     * Desired outbound IP Prefix resources for the cluster load balancer.
     */
    outboundIpPrefixes?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixes;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileEffectiveOutboundIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileManagedOutboundIPs {
    /**
     * The desired number of IPv4 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 1.
     */
    count?: number;
    /**
     * The desired number of IPv6 outbound IPs created/managed by Azure for the cluster load balancer. Allowed values must be in the range of 1 to 100 (inclusive). The default value is 0 for single-stack and 1 for dual-stack.
     */
    countIPv6?: number;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPs {
    /**
     * A list of public IP resources.
     */
    publicIPs?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPsPublicIP[];
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIPsPublicIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixes {
    /**
     * A list of public IP prefix resources.
     */
    publicIpPrefixes?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixesPublicIpPrefix[];
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileLoadBalancerProfileOutboundIpPrefixesPublicIpPrefix {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfile {
    /**
     * The effective outbound IP resources of the cluster NAT gateway.
     */
    effectiveOutboundIPs?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileEffectiveOutboundIP[];
    /**
     * Desired outbound flow idle timeout in minutes. Allowed values are in the range of 4 to 120 (inclusive). The default value is 4 minutes.
     */
    idleTimeoutInMinutes?: number;
    /**
     * Profile of the managed outbound IP resources of the managed cluster.
     */
    managedOutboundIpProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileManagedOutboundIpProfile;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileEffectiveOutboundIP {
    /**
     * The fully qualified Azure resource id.
     */
    id?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesNetworkProfileNatGatewayProfileManagedOutboundIpProfile {
    /**
     * The desired number of outbound IPs created/managed by Azure. Allowed values must be in the range of 1 to 16 (inclusive). The default value is 1.
     */
    count?: number;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfile {
    /**
     * Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See https://learn.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities for more information.
     */
    allowNetworkPluginKubenet?: boolean;
    /**
     * Whether the pod identity addon is enabled.
     */
    enabled?: boolean;
    /**
     * The pod identities to use in the cluster.
     */
    userAssignedIdentities?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentity[];
    /**
     * The pod identity exceptions to allow.
     */
    userAssignedIdentityExceptions?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityException[];
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentity {
    /**
     * The binding selector to use for the AzureIdentityBinding resource.
     */
    bindingSelector?: string;
    /**
     * Details about a user assigned identity.
     */
    identity?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityIdentity;
    /**
     * The name of the pod identity.
     */
    name?: string;
    /**
     * The namespace of the pod identity.
     */
    namespace?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityException {
    /**
     * The name of the pod identity exception.
     */
    name?: string;
    /**
     * The namespace of the pod identity exception.
     */
    namespace?: string;
    /**
     * The pod labels to match.
     */
    podLabels?: {[key: string]: string};
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPodIdentityProfileUserAssignedIdentityIdentity {
    /**
     * The client ID of the user assigned identity.
     */
    clientId?: string;
    /**
     * The object ID of the user assigned identity.
     */
    objectId?: string;
    /**
     * The resource ID of the user assigned identity.
     */
    resourceId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPowerState {
    /**
     * Tells whether the cluster is Running or Stopped.
     */
    code?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesPrivateLinkResource {
    /**
     * The group ID of the resource.
     */
    groupId?: string;
    /**
     * The ID of the private link resource.
     */
    id?: string;
    /**
     * The name of the private link resource.
     */
    name?: string;
    /**
     * The RequiredMembers of the resource
     */
    requiredMembers?: string[];
    /**
     * The resource type.
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfile {
    /**
     * Azure Key Vault key management service settings for the security profile.
     */
    azureKeyVaultKms?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileAzureKeyVaultKms;
    /**
     * Microsoft Defender settings for the security profile.
     */
    defender?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefender;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileAzureKeyVaultKms {
    /**
     * Whether to enable Azure Key Vault key management service. The default is false.
     */
    enabled?: boolean;
    /**
     * Identifier of Azure Key Vault key. See key identifier format for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.
     */
    keyId?: string;
    /**
     * Network access of key vault. The possible values are Public and Private. Public means the key vault allows public access from all networks. Private means the key vault disables public access and enables private link. The default value is Public.
     */
    keyVaultNetworkAccess?: string;
    /**
     * Resource ID of key vault. When keyVaultNetworkAccess is Private, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is Public, leave the field empty.
     */
    keyVaultResourceId?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefender {
    /**
     * Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.
     */
    logAnalyticsWorkspaceResourceId?: string;
    /**
     * Microsoft Defender settings for the security profile threat detection.
     */
    securityMonitoring?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefenderSecurityMonitoring;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesSecurityProfileDefenderSecurityMonitoring {
    /**
     * Whether to enable Defender threat detection
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesServicePrincipalProfile {
    /**
     * The ID for the service principal. If specified, must be set to [parameters('servicePrincipalClientId')]. This would be set to the cloud credential's client ID during cluster deployment.
     */
    clientId?: string;
    /**
     * The secret password associated with the service principal. If specified, must be set to [parameters('servicePrincipalClientSecret')]. This would be set to the cloud credential's client secret during cluster deployment.
     */
    secret?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfile {
    /**
     * AzureDisk CSI Driver settings for the storage profile.
     */
    diskCsiDriver?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileDiskCsiDriver;
    /**
     * AzureFile CSI Driver settings for the storage profile.
     */
    fileCsiDriver?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileFileCsiDriver;
    /**
     * Snapshot Controller settings for the storage profile.
     */
    snapshotController?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileSnapshotController;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileDiskCsiDriver {
    /**
     * Whether to enable AzureDisk CSI Driver. The default value is true.
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileFileCsiDriver {
    /**
     * Whether to enable AzureFile CSI Driver. The default value is true.
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesStorageProfileSnapshotController {
    /**
     * Whether to enable Snapshot Controller. The default value is true.
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfile {
    /**
     * Specifies the name of the administrator account, Restriction: Cannot end in '.', Minimum-length: 1 character, Max-length: 20 characters
     */
    adminUsername?: string;
    /**
     * For more details on CSI proxy, see the CSI proxy GitHub repo.
     */
    enableCsiProxy?: boolean;
    /**
     * Windows gMSA Profile in the managed cluster.
     */
    gmsaProfile?: outputs.GetAksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfileGmsaProfile;
    /**
     * The license type to use for Windows VMs. See Azure Hybrid User Benefits for more details. Valid values are None, Windows_Server.
     */
    licenseType?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterPropertiesWindowsProfileGmsaProfile {
    /**
     * Specifies the DNS server for Windows gMSA. Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
     */
    dnsServer?: string;
    /**
     * Specifies whether to enable Windows gMSA in the managed cluster.
     */
    enabled?: boolean;
    /**
     * Specifies the root domain name for Windows gMSA. Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.
     */
    rootDomainName?: string;
}

export interface GetAksClusterV3SpecConfigSpecManagedClusterSku {
    /**
     * The name of a managed cluster SKU.
     */
    name?: string;
    /**
     * If not specified, the default is Free. See uptime SLA for more details. Valid values are Paid, Free.
     */
    tier?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePool {
    /**
     * Azure Api Version
     */
    apiVersion?: string;
    /**
     * The geo-location where the resource lives
     */
    location?: string;
    /**
     * The name of the agent pool.
     */
    name?: string;
    /**
     * Properties for the container service agent pool profile.
     */
    properties?: outputs.GetAksClusterV3SpecConfigSpecNodePoolProperties;
    /**
     * Nodepool azure resource type
     */
    type?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolProperties {
    /**
     * The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is VirtualMachineScaleSets.
     */
    availabilityZones?: string[];
    /**
     * Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
     */
    count?: number;
    /**
     * Data used when creating a target resource from a source resource.
     */
    creationData?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesCreationData;
    /**
     * Whether to enable auto-scaler
     */
    enableAutoScaling?: boolean;
    /**
     * This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption
     */
    enableEncryptionAtHost?: boolean;
    /**
     * See Add a FIPS-enabled node pool for more details.
     */
    enableFips?: boolean;
    /**
     * Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see assigning a public IP per node. The default is false.
     */
    enableNodePublicIp?: boolean;
    /**
     * Whether to enable UltraSSD
     */
    enableUltraSsd?: boolean;
    /**
     * GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU. Valid values are MIG1g, MIG2g, MIG3g, MIG4g, MIG7g.
     */
    gpuInstanceProfile?: string;
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see Azure dedicated hosts.
     */
    hostGroupId?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    kubeletConfig?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesKubeletConfig;
    /**
     * Valid values are OS, Temporary.
     */
    kubeletDiskType?: string;
    /**
     * See AKS custom node configuration for more details.
     */
    linuxOsConfig?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfig;
    /**
     * The maximum number of nodes for auto-scaling
     */
    maxCount?: number;
    /**
     * The maximum number of pods that can run on a node.
     */
    maxPods?: number;
    /**
     * The minimum number of nodes for auto-scaling
     */
    minCount?: number;
    /**
     * Valid values are System, User.
     */
    mode?: string;
    /**
     * The node labels to be persisted across all nodes in agent pool.
     */
    nodeLabels?: {[key: string]: string};
    /**
     * This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
     */
    nodePublicIpPrefixId?: string;
    /**
     * The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
     */
    nodeTaints?: string[];
    /**
     * Both patch version (e.g. 1.20.13) and (e.g. 1.20) are supported. When is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same once it has been created (e.g. 1.14.x > 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see upgrading a node pool.
     */
    orchestratorVersion?: string;
    /**
     * OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.
     */
    osDiskSizeGb?: number;
    /**
     * Valid values are Managed, Ephemeral.
     */
    osDiskType?: string;
    /**
     * Valid values are Ubuntu, CBLMariner, Windows2019, Windows2022.
     */
    osSku?: string;
    /**
     * Valid values are Linux, Windows.
     */
    osType?: string;
    /**
     * If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    podSubnetId?: string;
    /**
     * Describes the Power State of the cluster
     */
    powerState?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesPowerState;
    /**
     * The ID for Proximity Placement Group.
     */
    proximityPlacementGroupId?: string;
    /**
     * This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete. Valid values are Delete, Deallocate.
     */
    scaleDownMode?: string;
    /**
     * This cannot be specified unless the scaleSetPriority is Spot. If not specified, the default is Delete. Valid values are Delete, Deallocate.
     */
    scaleSetEvictionPolicy?: string;
    /**
     * The Virtual Machine Scale Set priority. If not specified, the default is Regular. Valid values are Spot, Regular.
     */
    scaleSetPriority?: string;
    /**
     * Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see spot VMs pricing
     */
    spotMaxPrice?: number;
    /**
     * The tags to be persisted on the agent pool virtual machine scale set.
     */
    tags?: {[key: string]: string};
    /**
     * Valid values are VirtualMachineScaleSets, AvailabilitySet.
     */
    type?: string;
    /**
     * Settings for upgrading an agentpool
     */
    upgradeSettings?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesUpgradeSettings;
    /**
     * VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions
     */
    vmSize?: string;
    /**
     * If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
     */
    vnetSubnetId?: string;
    /**
     * Valid values are OCIContainer, WasmWasi.
     */
    workloadRuntime?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesCreationData {
    /**
     * This is the ARM ID of the source object to be used to create the target object.
     */
    sourceResourceId?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesKubeletConfig {
    /**
     * Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in *).
     */
    allowedUnsafeSysctls?: string[];
    /**
     * The maximum number of container log files that can be present for a container. The number must be ≥ 2.
     */
    containerLogMaxFiles?: number;
    /**
     * The maximum size (e.g. 10Mi) of container log file before it is rotated.
     */
    containerLogMaxSizeMb?: number;
    /**
     * The default is true.
     */
    cpuCfsQuota?: boolean;
    /**
     * The default is 100ms. Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: 300ms, 2h45m. Supported units are ns, us, ms, s, m, and h.
     */
    cpuCfsQuotaPeriod?: string;
    /**
     * The default is none. See Kubernetes CPU management policies for more information. Allowed values are none and static.
     */
    cpuManagerPolicy?: string;
    /**
     * If set to true it will make the Kubelet fail to start if swap is enabled on the node.
     */
    failSwapOn?: boolean;
    /**
     * To disable image garbage collection, set to 100. The default is 85%
     */
    imageGcHighThreshold?: number;
    /**
     * This cannot be set higher than imageGcHighThreshold. The default is 80%
     */
    imageGcLowThreshold?: number;
    /**
     * The maximum number of processes per pod.
     */
    podMaxPids?: number;
    /**
     * For more information see Kubernetes Topology Manager. The default is none. Allowed values are none, best-effort, restricted, and single-numa-node.
     */
    topologyManagerPolicy?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfig {
    /**
     * The size in MB of a swap file that will be created on each node.
     */
    swapFileSizeMb?: number;
    /**
     * Sysctl settings for Linux agent nodes.
     */
    sysctls?: outputs.GetAksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfigSysctls;
    /**
     * Valid values are always, defer, defer+madvise, madvise and never. The default is madvise. For more information see Transparent Hugepages.
     */
    transparentHugePageDefrag?: string;
    /**
     * Valid values are always, madvise, and never. The default is always. For more information see Transparent Hugepages.
     */
    transparentHugePageEnabled?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesLinuxOsConfigSysctls {
    /**
     * Sysctl setting fs.aio-max-nr.
     */
    fsAioMaxNr?: number;
    /**
     * Sysctl setting fs.file-max.
     */
    fsFileMax?: number;
    /**
     * Sysctl setting fs.inotify.max_user_watches.
     */
    fsInotifyMaxUserWatches?: number;
    /**
     * Sysctl setting fs.nr_open.
     */
    fsNrOpen?: number;
    /**
     * Sysctl setting kernel.threads-max.
     */
    kernelThreadsMax?: number;
    /**
     * Sysctl setting net.core.netdev_max_backlog.
     */
    netCoreNetdevMaxBacklog?: number;
    /**
     * Sysctl setting net.core.optmem_max.
     */
    netCoreOptmemMax?: number;
    /**
     * Sysctl setting net.core.rmem_default.
     */
    netCoreRmemDefault?: number;
    /**
     * Sysctl setting net.core.rmem_max.
     */
    netCoreRmemMax?: number;
    /**
     * Sysctl setting net.core.somaxconn.
     */
    netCoreSomaxconn?: number;
    /**
     * Sysctl setting net.core.wmem_default.
     */
    netCoreWmemDefault?: number;
    /**
     * Sysctl setting net.core.wmem_max.
     */
    netCoreWmemMax?: number;
    /**
     * Sysctl setting net.ipv4.ip_local_port_range.
     */
    netIpv4IpLocalPortRange?: string;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh1.
     */
    netIpv4NeighDefaultGcThresh1?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh2.
     */
    netIpv4NeighDefaultGcThresh2?: number;
    /**
     * Sysctl setting net.ipv4.neigh.default.gc_thresh3.
     */
    netIpv4NeighDefaultGcThresh3?: number;
    /**
     * Sysctl setting net.ipv4.tcp_fin_timeout.
     */
    netIpv4TcpFinTimeout?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_probes.
     */
    netIpv4TcpKeepaliveProbes?: number;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_time.
     */
    netIpv4TcpKeepaliveTime?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_syn_backlog.
     */
    netIpv4TcpMaxSynBacklog?: number;
    /**
     * Sysctl setting net.ipv4.tcp_max_tw_buckets.
     */
    netIpv4TcpMaxTwBuckets?: number;
    /**
     * Sysctl setting net.ipv4.tcp_tw_reuse.
     */
    netIpv4TcpTwReuse?: boolean;
    /**
     * Sysctl setting net.ipv4.tcp_keepalive_intvl.
     */
    netIpv4TcpkeepaliveIntvl?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_buckets.
     */
    netNetfilterNfConntrackBuckets?: number;
    /**
     * Sysctl setting net.netfilter.nf_conntrack_max.
     */
    netNetfilterNfConntrackMax?: number;
    /**
     * Sysctl setting vm.max_map_count.
     */
    vmMaxMapCount?: number;
    /**
     * Sysctl setting vm.swappiness.
     */
    vmSwappiness?: number;
    /**
     * Sysctl setting vm.vfs_cache_pressure.
     */
    vmVfsCachePressure?: number;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesPowerState {
    /**
     * Tells whether the cluster is Running or Stopped.
     */
    code?: string;
}

export interface GetAksClusterV3SpecConfigSpecNodePoolPropertiesUpgradeSettings {
    /**
     * This can either be set to an integer (e.g. 5) or a percentage (e.g. 50%). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 1. For more information, including best practices, see: https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade
     */
    maxSurge?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellDatacenterConfig {
    /**
     * APIVersion of TinkerbellDatacenterConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell datacenter configuration
     */
    metaData?: outputs.GetAksClusterV3SpecConfigTinkerbellDatacenterConfigMetaData;
    /**
     * Specifications of Tinkerbell datacenter configuration
     */
    spec?: outputs.GetAksClusterV3SpecConfigTinkerbellDatacenterConfigSpec;
}

export interface GetAksClusterV3SpecConfigTinkerbellDatacenterConfigMetaData {
    /**
     * Tinkerbell datacenter configuration's name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellDatacenterConfigSpec {
    /**
     * Optional field to replace the HookOS image.
     */
    hookImagesUrlPath?: string;
    /**
     * Optional field to replace the default Bottlerocket operating system. EKS Anywhere can only auto-import Bottlerocket. In order to use Ubuntu or Redhat, self-hosting is required.
     */
    osImageUrl?: string;
    /**
     * Required field to identify the IP address of the Tinkerbell service. This IP address must be a unique IP in the network range that does not conflict with other IPs. Once the Tinkerbell services move from the Admin machine to run on the target cluster, this IP address makes it possible for the stack to be used for future provisioning needs. When separate management and workload clusters are supported in Bare Metal, the IP address becomes a necessity.
     */
    tinkerbellIp?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellHardwareConfig {
    /**
     * The IP address assigned to the BMC interface on the machine.
     */
    bmcIp?: string;
    /**
     * The password associated with the bmc_username assigned to the BMC interface on the machine.
     */
    bmcPassword?: string;
    /**
     * The username assigned to the BMC interface on the machine.
     */
    bmcUserName?: string;
    /**
     * The device name of the disk on which the operating system will be installed.
     */
    disk?: string;
    /**
     * IP address of the interface that provides access (the gateway) to the Internet.
     */
    gateway?: string;
    /**
     * The hostname assigned to the machine.
     */
    hostname?: string;
    /**
     * The IP address providing access to the host computer.
     */
    ipAddress?: string;
    /**
     * The optional labels field can consist of a key/value pair to use in conjunction with the hardwareSelector field when you set up your Bare Metal configuration. The key/value pair is connected with an equal (=) sign.
     */
    labels?: string;
    /**
     * The MAC address of the network interface card (NIC) that provides access to the host computer.
     */
    mac?: string;
    /**
     * The IP address of the server that you want to provide DNS service to the cluster.
     */
    nameservers?: string;
    /**
     * The netmask associated with the ip_address value. In the example above, a /23 subnet mask is used, allowing you to use up to 510 IP addresses in that range.
     */
    netmask?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfig {
    /**
     * APIVersion of TinkerbellMachineConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell machine configuration
     */
    metaData?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigMetaData;
    /**
     * Specifications of Tinkerbell machine configuration
     */
    spec?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpec;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigMetaData {
    /**
     * Tinkerbell machine configuration's name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpec {
    /**
     * Use fields under hardwareSelector to add key/value pair labels to match particular machines that you identified in tinkerbell machine configuration.
     */
    hardwareSelector?: {[key: string]: string};
    /**
     * Optional host os configurations for the EKSA kubernetes nodes.
     */
    hostOsConfiguration?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfiguration;
    /**
     * Operating system on the machine. For example, bottlerocket or ubuntu.
     */
    osFamily?: string;
    /**
     * Identifies the template that defines the actions that will be applied to the tinkerbell machine configuration.
     */
    templateRef?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecTemplateRef;
    /**
     * The name of the user you want to configure to access your virtual machines through SSH.
     */
    users?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecUser[];
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfiguration {
    /**
     * BottlerocketConfiguration.
     */
    bottlerocketConfiguration?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationBottlerocketConfiguration;
    /**
     * CertBundles.
     */
    certBundles?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationCertBundle[];
    /**
     * NTPConfiguration.
     */
    ntpConfiguration?: outputs.GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationNtpConfiguration;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationBottlerocketConfiguration {
    /**
     * Boot.
     */
    boot?: string;
    /**
     * Kernel.
     */
    kernel?: string;
    /**
     * Kubernetes.
     */
    kubernetes?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationCertBundle {
    /**
     * Refers to the content of cert key in pem format.
     */
    data?: string;
    /**
     * Refers to the name of cert bundle.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecHostOsConfigurationNtpConfiguration {
    /**
     * Servers.
     */
    servers?: string[];
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecTemplateRef {
    /**
     * Refers to the kind of template resource.
     */
    kind?: string;
    /**
     * Refers to the name of template resource.
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellMachineConfigSpecUser {
    /**
     * Refers to the name of user.
     */
    name?: string;
    /**
     * Public key required to ssh into the admin/cp/dp nodes.
     */
    sshAuthorizedKeys?: string[];
}

export interface GetAksClusterV3SpecConfigTinkerbellTemplateConfig {
    /**
     * APIVersion of TinkerbellTemplateConfig resource
     */
    apiVersion?: string;
    /**
     * Kind of resource
     */
    kind?: string;
    /**
     * Metadata associated with Tinkerbell template configuration
     */
    metaData?: outputs.GetAksClusterV3SpecConfigTinkerbellTemplateConfigMetaData;
    /**
     * Refer https://anywhere.eks.amazonaws.com/docs/getting-started/baremetal/bare-spec/#tinkerbelltemplateconfig-fields
     */
    spec?: string;
}

export interface GetAksClusterV3SpecConfigTinkerbellTemplateConfigMetaData {
    /**
     * tinkerbell template configuration's name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNetwork {
    /**
     * CNI configuration
     */
    cni?: outputs.GetAksClusterV3SpecConfigVsphereNetworkCni;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    devices?: outputs.GetAksClusterV3SpecConfigVsphereNetworkDevice[];
    /**
     * The pod CIDR blocks for the cluster nodes
     */
    podCidrBlocks?: string[];
}

export interface GetAksClusterV3SpecConfigVsphereNetworkCni {
    /**
     * CNI name
     */
    name?: string;
    /**
     * CNI version
     */
    version?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNetworkDevice {
    /**
     * Enable DHCP for the network
     */
    dhcp?: boolean;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    networkName?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNodePool {
    /**
     * The vSphere data center where the cluster nodes will be launched
     */
    dataCenter?: string;
    /**
     * The vSphere storage in the selected data center to launch the cluster nodes
     */
    dataStore?: string;
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * kubeadmconfig spec to run on the control plane nodes
     */
    kubeadmConfigSpec?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpec;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Nodepool name
     */
    name?: string;
    /**
     * Network configuration for the cluster
     */
    network?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolNetwork;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * The Operating System of the nodes
     */
    os?: string;
    /**
     * The vSphere resource pool in the selected data center to launch the cluster nodes
     */
    resourcePool?: string;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
    /**
     * Template name format : os-osVersion-kube-v<k8s-version>. For example ubuntu-2004-kube-v1.22.8
     */
    vmTemplate?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpec {
    /**
     * Files to be added to the kubeadm config
     */
    files?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFile[];
    /**
     * Prekubeadmcommands to run on the nodepools
     */
    preKubeadmCommands?: string[];
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFile {
    /**
     * Append to the file
     */
    append?: boolean;
    /**
     * Content of the file
     */
    content?: string;
    /**
     * ContentFrom
     */
    contentFrom?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFrom;
    /**
     * Encoding of the file
     */
    encoding?: string;
    /**
     * Owner of the file
     */
    owner?: string;
    /**
     * Path of the file
     */
    path?: string;
    /**
     * Permissions of the file
     */
    permissions?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFrom {
    /**
     * Secret
     */
    secret?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFromSecret;
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolKubeadmConfigSpecFileContentFromSecret {
    /**
     * Key
     */
    key?: string;
    /**
     * Name
     */
    name?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolNetwork {
    /**
     * CNI configuration
     */
    cni?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolNetworkCni;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    devices?: outputs.GetAksClusterV3SpecConfigVsphereNodePoolNetworkDevice[];
    /**
     * The pod CIDR blocks for the cluster nodes
     */
    podCidrBlocks?: string[];
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolNetworkCni {
    /**
     * CNI name
     */
    name?: string;
    /**
     * CNI version
     */
    version?: string;
}

export interface GetAksClusterV3SpecConfigVsphereNodePoolNetworkDevice {
    /**
     * Enable DHCP for the network
     */
    dhcp?: boolean;
    /**
     * The vSphere Network in the selected data center, to enable connectivity for the cluster nodes
     */
    networkName?: string;
}

export interface GetAksClusterV3SpecConfigWorkerNodes {
    /**
     * Hard Disk size of a node in GiB
     */
    diskGiB?: number;
    /**
     * Node count
     */
    machineCount?: number;
    /**
     * Memory size of a node in MiB
     */
    memoryMiB?: number;
    /**
     * Cpu count
     */
    numCpUs?: number;
    /**
     * Public key to configure remote SSH access to the nodes
     */
    sshAuthorizedKeys?: string[];
    /**
     * Kubernetes version of nodes
     */
    version?: string;
}

export interface GetAksClusterV3SpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface GetAksClusterV3SpecGateway {
    id?: string;
    name?: string;
}

export interface GetAksClusterV3SpecProxy {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface GetAksClusterV3SpecProxyConfig {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface GetAksClusterV3SpecSharing {
    enabled?: boolean;
    projects?: outputs.GetAksClusterV3SpecSharingProject[];
}

export interface GetAksClusterV3SpecSharingProject {
    name?: string;
}

export interface GetAksClusterV3SpecSystemComponentsPlacement {
    daemonSetOverride?: outputs.GetAksClusterV3SpecSystemComponentsPlacementDaemonSetOverride;
    nodeSelector?: {[key: string]: string};
    tolerations?: outputs.GetAksClusterV3SpecSystemComponentsPlacementToleration[];
}

export interface GetAksClusterV3SpecSystemComponentsPlacementDaemonSetOverride {
    nodeSelectionEnabled?: boolean;
    tolerations?: outputs.GetAksClusterV3SpecSystemComponentsPlacementDaemonSetOverrideToleration[];
}

export interface GetAksClusterV3SpecSystemComponentsPlacementDaemonSetOverrideToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface GetAksClusterV3SpecSystemComponentsPlacementToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface GetAksClusterV3Timeouts {
    read?: string;
}

export interface GetBlueprintMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetBlueprintMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetBlueprintMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetBlueprintMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetBlueprintMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetBlueprintSpec {
    /**
     * blueprint base
     */
    base?: outputs.GetBlueprintSpecBase;
    /**
     * Criticality of addon components
     */
    componentsCriticalities?: outputs.GetBlueprintSpecComponentsCriticality[];
    /**
     * cost profile details
     */
    costProfile?: outputs.GetBlueprintSpecCostProfile;
    /**
     * custom addon configuration
     */
    customAddons?: outputs.GetBlueprintSpecCustomAddon[];
    /**
     * default addon configuration
     */
    defaultAddons?: outputs.GetBlueprintSpecDefaultAddons;
    /**
     * blueprint drift configuration
     */
    drift?: outputs.GetBlueprintSpecDrift;
    /**
     * webhook config details
     */
    driftWebhook?: outputs.GetBlueprintSpecDriftWebhook;
    /**
     * namespace config
     */
    namespaceConfig?: outputs.GetBlueprintSpecNamespaceConfig;
    /**
     * network policy and version details
     */
    networkPolicy?: outputs.GetBlueprintSpecNetworkPolicy;
    /**
     * opa policy and version details
     */
    opaPolicy?: outputs.GetBlueprintSpecOpaPolicy;
    /**
     * blueprint placement
     */
    placement?: outputs.GetBlueprintSpecPlacement;
    /**
     * private  kubernetes API proxy networks
     */
    privateKubeApiProxies?: outputs.GetBlueprintSpecPrivateKubeApiProxy[];
    /**
     * blueprint PSP configuration
     */
    psp?: outputs.GetBlueprintSpecPsp;
    /**
     * service mesh profile and policies details
     */
    serviceMesh?: outputs.GetBlueprintSpecServiceMesh;
    /**
     * blueprint sharing configuration
     */
    sharing?: outputs.GetBlueprintSpecSharing;
    /**
     * Blueprint Type
     */
    type?: string;
    /**
     * version of the blueprint
     */
    version?: string;
}

export interface GetBlueprintSpecBase {
    /**
     * name of the blueprint base
     */
    name?: string;
    /**
     * version of the blueprint base
     */
    version?: string;
}

export interface GetBlueprintSpecComponentsCriticality {
    /**
     * Component Type of the blueprint list resource
     */
    componentType?: string;
    /**
     * Dependent resources
     */
    dependsOns?: string[];
    /**
     * Check for Global resource
     */
    isGlobal?: boolean;
    /**
     * API Version of the blueprint list resource
     */
    name?: string;
    /**
     * Published Generation of the blueprint list resource
     */
    publishedGeneration?: string;
    /**
     * Revision of the blueprint list resource
     */
    revision?: string;
    /**
     * Selector of the blueprint list resource
     */
    selector?: string;
    /**
     * Version of the blueprint list resource
     */
    version?: string;
    /**
     * Workload ID of the blueprint list resource
     */
    workloadId?: string;
}

export interface GetBlueprintSpecCostProfile {
    /**
     * name of the cost profile
     */
    name?: string;
    /**
     * version of the cost profile
     */
    version?: string;
}

export interface GetBlueprintSpecCustomAddon {
    /**
     * other addons current addons depends on
     */
    dependsOns?: string[];
    /**
     * name of the blueprint addon
     */
    name?: string;
    /**
     * version of the blueprint addon
     */
    version?: string;
}

export interface GetBlueprintSpecDefaultAddons {
    /**
     * Secret Store CSI Driver Customization details
     */
    csiSecretStoreConfig?: outputs.GetBlueprintSpecDefaultAddonsCsiSecretStoreConfig;
    /**
     * enable csi secret store
     */
    enableCsiSecretStore?: boolean;
    /**
     * enable default ingress
     */
    enableIngress?: boolean;
    /**
     * enable default logging
     */
    enableLogging?: boolean;
    /**
     * enable default monitoring
     */
    enableMonitoring?: boolean;
    /**
     * enable rook ceph storage
     */
    enableRookCeph?: boolean;
    /**
     * enable virtual machine workloads
     */
    enableVm?: boolean;
    /**
     * default monitoring configuration
     */
    monitoring?: outputs.GetBlueprintSpecDefaultAddonsMonitoring;
}

export interface GetBlueprintSpecDefaultAddonsCsiSecretStoreConfig {
    enableSecretRotation?: boolean;
    providers?: outputs.GetBlueprintSpecDefaultAddonsCsiSecretStoreConfigProviders;
    rotationPollInterval?: string;
    syncSecrets?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsCsiSecretStoreConfigProviders {
    aws?: boolean;
    vault?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoring {
    /**
     * Helm Exporter Configuration
     */
    helmExporter?: outputs.GetBlueprintSpecDefaultAddonsMonitoringHelmExporter;
    /**
     * Kubernetes State Metrics Configuration
     */
    kubeStateMetrics?: outputs.GetBlueprintSpecDefaultAddonsMonitoringKubeStateMetrics;
    /**
     * Metrics Server Configuration
     */
    metricsServer?: outputs.GetBlueprintSpecDefaultAddonsMonitoringMetricsServer;
    /**
     * Node Exporter Configuration
     */
    nodeExporter?: outputs.GetBlueprintSpecDefaultAddonsMonitoringNodeExporter;
    /**
     * Prometheus Adapter Configuration
     */
    prometheusAdapter?: outputs.GetBlueprintSpecDefaultAddonsMonitoringPrometheusAdapter;
    /**
     * Prometheus Resources
     */
    resources?: outputs.GetBlueprintSpecDefaultAddonsMonitoringResources;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringHelmExporter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.GetBlueprintSpecDefaultAddonsMonitoringHelmExporterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringHelmExporterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringKubeStateMetrics {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.GetBlueprintSpecDefaultAddonsMonitoringKubeStateMetricsDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringKubeStateMetricsDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringMetricsServer {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.GetBlueprintSpecDefaultAddonsMonitoringMetricsServerDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringMetricsServerDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringNodeExporter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.GetBlueprintSpecDefaultAddonsMonitoringNodeExporterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringNodeExporterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringPrometheusAdapter {
    /**
     * flag to specify if monitoring component customization is enabled
     */
    customizationEnabled?: boolean;
    /**
     * discovery configuration for monitoring component
     */
    discovery?: outputs.GetBlueprintSpecDefaultAddonsMonitoringPrometheusAdapterDiscovery;
    /**
     * flag to specify if monitoring component is enabled
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringPrometheusAdapterDiscovery {
    /**
     * labels of the monitoring component
     */
    labels?: {[key: string]: string};
    /**
     * namespace of the monitoring component
     */
    namespace?: string;
    /**
     * resource name of the monitoring component
     */
    resource?: string;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringResources {
    /**
     * limits for the resources
     */
    limits?: outputs.GetBlueprintSpecDefaultAddonsMonitoringResourcesLimits;
}

export interface GetBlueprintSpecDefaultAddonsMonitoringResourcesLimits {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface GetBlueprintSpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecDriftWebhook {
    /**
     * enable drift
     */
    enabled?: boolean;
}

export interface GetBlueprintSpecNamespaceConfig {
    /**
     * flag to enable namespace sync
     */
    enableSync?: boolean;
    /**
     * Synchronizing type as managed or unmanaged namespace
     */
    syncType?: string;
}

export interface GetBlueprintSpecNetworkPolicy {
    /**
     * name and version of cluster network policy
     */
    policies?: outputs.GetBlueprintSpecNetworkPolicyPolicy[];
    /**
     * name and version of network profile
     */
    profile?: outputs.GetBlueprintSpecNetworkPolicyProfile;
}

export interface GetBlueprintSpecNetworkPolicyPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface GetBlueprintSpecNetworkPolicyProfile {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface GetBlueprintSpecOpaPolicy {
    /**
     * policy configuration
     */
    opaPolicies?: outputs.GetBlueprintSpecOpaPolicyOpaPolicy[];
    /**
     * profile configuration
     */
    profile?: outputs.GetBlueprintSpecOpaPolicyProfile;
}

export interface GetBlueprintSpecOpaPolicyOpaPolicy {
    /**
     * name of the opa policy
     */
    name?: string;
    /**
     * version of the opa policy
     */
    version?: string;
}

export interface GetBlueprintSpecOpaPolicyProfile {
    /**
     * name of the opa profile
     */
    name?: string;
    /**
     * version of the opa profile
     */
    version?: string;
}

export interface GetBlueprintSpecPlacement {
    /**
     * Bool value of autoPublish
     */
    autoPublish?: boolean;
    /**
     * Array of Fleet value
     */
    fleetValues?: string[];
}

export interface GetBlueprintSpecPrivateKubeApiProxy {
    /**
     * name of the kubernetes proxy network
     */
    name?: string;
}

export interface GetBlueprintSpecPsp {
    /**
     * flag to specify if PSP is enabled for blueprint
     */
    enabled?: boolean;
    /**
     * names of the PSPs to be added for the blueprint
     */
    names?: string[];
    /**
     * scope of the PSP for the blueprint
     */
    scope?: string;
}

export interface GetBlueprintSpecServiceMesh {
    /**
     * name and version of cluster mesh policy
     */
    policies?: outputs.GetBlueprintSpecServiceMeshPolicy[];
    /**
     * name and version of service mesh profile
     */
    profile?: outputs.GetBlueprintSpecServiceMeshProfile;
}

export interface GetBlueprintSpecServiceMeshPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface GetBlueprintSpecServiceMeshProfile {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface GetBlueprintSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.GetBlueprintSpecSharingProject[];
}

export interface GetBlueprintSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface GetBlueprintTimeouts {
    read?: string;
}

export interface GetClusterBlueprintStatusMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetClusterBlueprintStatusMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetClusterBlueprintStatusMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetClusterBlueprintStatusMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetClusterBlueprintStatusMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetClusterBlueprintStatusStatus {
    /**
     * cluster blueprint addon status
     */
    addonStatusLists?: outputs.GetClusterBlueprintStatusStatusAddonStatusList[];
}

export interface GetClusterBlueprintStatusStatusAddonStatusList {
    /**
     * name of the blueprint addon
     */
    addonName?: string;
    /**
     * conditions blueprint addon status
     */
    conditions?: outputs.GetClusterBlueprintStatusStatusAddonStatusListCondition[];
    /**
     * namespce of the blueprint addon
     */
    namespace?: string;
    /**
     * status of the blueprint addon
     */
    publishStatus?: string;
    /**
     * time of the blueprint addon publish
     */
    publishTime?: string;
}

export interface GetClusterBlueprintStatusStatusAddonStatusListCondition {
    /**
     * components of blueprint addon
     */
    components?: outputs.GetClusterBlueprintStatusStatusAddonStatusListConditionComponent[];
    /**
     * condition updated time of the blueprint addon
     */
    lastUpdated?: string;
    /**
     * maxium retry count of blueprint addon publish
     */
    maxRetrycount?: number;
    /**
     * condition reason of the blueprint addon publish
     */
    reason?: string;
    /**
     * retry count of blueprint addon publish
     */
    retrycount?: number;
    /**
     * condition status of the blueprint addon
     */
    status?: string;
    /**
     * condition type of the blueprint addon
     */
    type?: string;
}

export interface GetClusterBlueprintStatusStatusAddonStatusListConditionComponent {
    /**
     * component failures blueprint addon
     */
    failures?: outputs.GetClusterBlueprintStatusStatusAddonStatusListConditionComponentFailure[];
    /**
     * component name of the blueprint addon
     */
    name?: string;
    /**
     * component failure reason of the blueprint addon publish
     */
    reason?: string;
}

export interface GetClusterBlueprintStatusStatusAddonStatusListConditionComponentFailure {
    /**
     * component failure message of the blueprint addon
     */
    message?: string;
    /**
     * component name blueprint addon publish
     */
    name?: string;
    /**
     * component failure reason the blueprint addon publish
     */
    reason?: string;
    /**
     * component failure timestamp of the blueprint addon publish
     */
    timestamp?: string;
}

export interface GetClusterBlueprintStatusTimeouts {
    read?: string;
}

export interface GetDownloadKubeconfigTimeouts {
    read?: string;
}

export interface GetEksClusterCluster {
    /**
     * The type of resource. Supported value is `Cluster`.
     */
    kind?: string;
    /**
     * Contains data that helps uniquely identify the resource.
     */
    metadata: outputs.GetEksClusterClusterMetadata;
    /**
     * The specification associated with the cluster, including cluster networking options.
     */
    spec?: outputs.GetEksClusterClusterSpec;
}

export interface GetEksClusterClusterConfig {
    /**
     * holds the EKS addon configuration
     */
    addons?: outputs.GetEksClusterClusterConfigAddon[];
    /**
     * apiversion
     */
    apiversion?: string;
    /**
     * availability zones of a cluster
     */
    availabilityZones?: string[];
    /**
     * holds all CloudWatch attributes of a cluster
     */
    cloudWatches?: outputs.GetEksClusterClusterConfigCloudWatch[];
    /**
     * defines the settings used to schedule workload onto Fargate.
     */
    fargateProfiles?: outputs.GetEksClusterClusterConfigFargateProfile[];
    /**
     * holds all IAM attributes of a cluster
     */
    iams?: outputs.GetEksClusterClusterConfigIam[];
    /**
     * maps IAM user/roles to kubenetes RBAC groups
     */
    identityMappings?: outputs.GetEksClusterClusterConfigIdentityMapping[];
    /**
     * holds an identity provider configuration.
     */
    identityProviders?: outputs.GetEksClusterClusterConfigIdentityProvider[];
    /**
     * kind
     */
    kind?: string;
    /**
     * contains cluster networking options
     */
    kubernetesNetworkConfigs?: outputs.GetEksClusterClusterConfigKubernetesNetworkConfig[];
    /**
     * holds all nodegroup attributes of a cluster.
     */
    managedNodegroups?: outputs.GetEksClusterClusterConfigManagedNodegroup[];
    /**
     * contains cluster networking options
     */
    metadatas: outputs.GetEksClusterClusterConfigMetadata[];
    /**
     * holds all nodegroup attributes of a cluster.
     */
    nodeGroups?: outputs.GetEksClusterClusterConfigNodeGroup[];
    /**
     * allows configuring a fully-private cluster in which no node has outbound internet access, and private access to AWS services is enabled via VPC endpoints
     */
    privateClusters?: outputs.GetEksClusterClusterConfigPrivateCluster[];
    /**
     * defines the configuration for KMS encryption provider
     */
    secretsEncryptions?: outputs.GetEksClusterClusterConfigSecretsEncryption[];
    /**
     * holds global subnet and all child subnets
     */
    vpcs?: outputs.GetEksClusterClusterConfigVpc[];
}

export interface GetEksClusterClusterConfigAddon {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.GetEksClusterClusterConfigAddonAttachPolicy[];
    /**
     * list of ARNs of the IAM policies to attach
     */
    attachPolicyArns?: string[];
    /**
     * holds a policy document to attach to this addon in json string format
     */
    attachPolicyV2?: string;
    /**
     * configuration values for the addon
     */
    configurationValues?: string;
    /**
     * EKS addon name
     */
    name: string;
    /**
     * ARN of the permissions boundary to associate
     */
    permissionsBoundary?: string;
    /**
     * service account role ARN
     */
    serviceAccountRoleArn?: string;
    /**
     * The metadata to apply to the cluster to assist with categorization and organization. Each tag consists of a key and an optional value, both of which you define.
     */
    tags?: {[key: string]: string};
    /**
     * EKS addon version
     */
    version?: string;
    /**
     * for attaching common IAM policies
     */
    wellKnownPolicies?: outputs.GetEksClusterClusterConfigAddonWellKnownPolicy[];
}

export interface GetEksClusterClusterConfigAddonAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.GetEksClusterClusterConfigAddonAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface GetEksClusterClusterConfigAddonAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface GetEksClusterClusterConfigAddonWellKnownPolicy {
    /**
     * service account annotations
     */
    autoScaler?: boolean;
    /**
     * adds policies for using the aws-load-balancer-controller.
     */
    awsLoadBalancerController?: boolean;
    /**
     * adds cert-manager policies.
     */
    certManager?: boolean;
    /**
     * adds cert-manager policies.
     */
    ebsCsiController?: boolean;
    /**
     * adds policies for using the ebs-csi-controller.
     */
    efsCsiController?: boolean;
    /**
     * adds external-dns policies for Amazon Route 53.
     */
    externalDns?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access.
     */
    imageBuilder?: boolean;
}

export interface GetEksClusterClusterConfigCloudWatch {
    /**
     * container config parameters related to cluster logging
     */
    clusterLoggings?: outputs.GetEksClusterClusterConfigCloudWatchClusterLogging[];
}

export interface GetEksClusterClusterConfigCloudWatchClusterLogging {
    /**
     * Types of logging to enable. Valid entries are: 'api', 'audit', 'authenticator', 'controllerManager', 'scheduler', 'all', '*'.
     */
    enableTypes?: string[];
    /**
     * The number of days you want to retain log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, and 3653.
     */
    logRetentionInDays?: number;
}

export interface GetEksClusterClusterConfigFargateProfile {
    /**
     * name of the fargate profile
     */
    name?: string;
    /**
     * IAM role's ARN to use to run pods onto Fargate.
     */
    podExecutionRoleArn?: string;
    /**
     * define the rules to select workload to schedule onto Fargate.
     */
    selectors?: outputs.GetEksClusterClusterConfigFargateProfileSelector[];
    /**
     * The current status of the Fargate profile.
     */
    status?: string;
    /**
     * define the rules to select workload to schedule onto Fargate.
     */
    subnets?: string[];
    /**
     * Used to tag the AWS resources
     */
    tags?: {[key: string]: string};
}

export interface GetEksClusterClusterConfigFargateProfileSelector {
    /**
     * Kubernetes label selectors to use to select workload.
     */
    labels?: {[key: string]: string};
    /**
     * Kubernetes namespace from which to select workload.
     */
    namespace?: string;
}

export interface GetEksClusterClusterConfigIam {
    /**
     * role used by pods to access AWS APIs. This role is added to the Kubernetes RBAC for authorization.
     */
    fargatePodExecutionRoleArn?: string;
    /**
     * permissions boundary for the fargate pod execution role.
     */
    fargatePodExecutionRolePermissionsBoundary?: string;
    /**
     * service accounts to create in the cluster.
     */
    serviceAccounts?: outputs.GetEksClusterClusterConfigIamServiceAccount[];
    /**
     * service role ARN of the cluster
     */
    serviceRoleArn?: string;
    /**
     * permissions boundary for all identity-based entities created by the vendor.
     */
    serviceRolePermissionBoundary?: string;
    /**
     * attaches the IAM policy necessary to run the VPC controller in the control plane
     */
    vpcResourceControllerPolicy?: boolean;
    /**
     * enables the IAM OIDC provider as well as IRSA for the Amazon CNI plugin
     */
    withOidc?: boolean;
}

export interface GetEksClusterClusterConfigIamServiceAccount {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicy?: string;
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    attachPolicyArns?: string[];
    /**
     * ARN of the role to attach to the service account
     */
    attachRoleArn?: string;
    /**
     * metadata for service accounts
     */
    metadatas?: outputs.GetEksClusterClusterConfigIamServiceAccountMetadata[];
    /**
     * ARN of the permissions boundary to associate with the service account
     */
    permissionsBoundary?: string;
    /**
     * Specific role name instead of the Cloudformation-generated role name
     */
    roleName?: string;
    /**
     * Specify if only the IAM Service Account role should be created without creating/annotating the service account
     */
    roleOnly?: boolean;
    /**
     * holds status of the IAM service account
     */
    statuses?: outputs.GetEksClusterClusterConfigIamServiceAccountStatus[];
    /**
     * AWS tags for the service account
     */
    tags?: {[key: string]: string};
    /**
     * for attaching common IAM policies
     */
    wellKnownPolicies?: outputs.GetEksClusterClusterConfigIamServiceAccountWellKnownPolicy[];
}

export interface GetEksClusterClusterConfigIamServiceAccountMetadata {
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    annotations?: {[key: string]: string};
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    labels?: {[key: string]: string};
    /**
     * service account name
     */
    name?: string;
    /**
     * service account namespace
     */
    namespace?: string;
}

export interface GetEksClusterClusterConfigIamServiceAccountStatus {
    /**
     * role ARN associated with the service account.
     */
    roleArn?: string;
}

export interface GetEksClusterClusterConfigIamServiceAccountWellKnownPolicy {
    /**
     * service account annotations
     */
    autoScaler?: boolean;
    /**
     * adds policies for using the aws-load-balancer-controller.
     */
    awsLoadBalancerController?: boolean;
    /**
     * adds cert-manager policies.
     */
    certManager?: boolean;
    /**
     * adds cert-manager policies.
     */
    ebsCsiController?: boolean;
    /**
     * adds policies for using the ebs-csi-controller.
     */
    efsCsiController?: boolean;
    /**
     * adds external-dns policies for Amazon Route 53.
     */
    externalDns?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access.
     */
    imageBuilder?: boolean;
}

export interface GetEksClusterClusterConfigIdentityMapping {
    /**
     * List of IAM accounts to map
     */
    accounts?: string[];
    /**
     * List of ARN objects
     */
    arns?: outputs.GetEksClusterClusterConfigIdentityMappingArn[];
}

export interface GetEksClusterClusterConfigIdentityMappingArn {
    /**
     * ARN of user/role to be mapped
     */
    arn?: string;
    /**
     * List of kubernetes groups to be mapped to
     */
    groups?: string[];
    /**
     * The username to be used by kubernetes
     */
    username?: string;
}

export interface GetEksClusterClusterConfigIdentityProvider {
    /**
     * Valid variants are: 'oidc': OIDC identity provider
     */
    type?: string;
}

export interface GetEksClusterClusterConfigKubernetesNetworkConfig {
    /**
     * Valid variants are: 'IPv4' defines an IP family of v4 to be used when creating a new VPC and cluster., 'IPv6' defines an IP family of v6 to be used when creating a new VPC and cluster..
     */
    ipFamily?: string;
    /**
     * CIDR range from where ClusterIPs are assigned
     */
    serviceIpv4Cidr?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroup {
    /**
     * Specify custom AMIs, auto-ssm, auto, or static
     */
    ami?: string;
    /**
     * Valid variants are: 'AmazonLinux2'.
     */
    amiFamily?: string;
    /**
     * See relevant AWS docs
     */
    asgSuspendProcesses?: string[];
    /**
     * Limit nodes to specific AZs
     */
    availabilityZones?: string[];
    /**
     * specifies settings for Bottlerocket nodes
     */
    bottleRockets?: outputs.GetEksClusterClusterConfigManagedNodegroupBottleRocket[];
    /**
     * desired capacity of instances in the nodegroup
     */
    desiredCapacity?: number;
    /**
     * requires requests to the metadata service to use IMDSv2 tokens
     */
    disableImdsv1?: boolean;
    /**
     * blocks all IMDS requests from non host networking pods
     */
    disablePodsImds?: boolean;
    /**
     * enables EBS optimization
     */
    ebsOptimized?: boolean;
    /**
     * creates the maximum allowed number of EFA-enabled network cards on nodes in this group.
     */
    efaEnabled?: boolean;
    /**
     * Enable EC2 detailed monitoring
     */
    enableDetailedMonitoring?: boolean;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iams?: outputs.GetEksClusterClusterConfigManagedNodegroupIam[];
    /**
     * for instances in the nodegroup
     */
    instanceName?: string;
    /**
     * for instances in the nodegroup
     */
    instancePrefix?: string;
    /**
     * specifies options for EC2 instance selector
     */
    instanceSelectors?: outputs.GetEksClusterClusterConfigManagedNodegroupInstanceSelector[];
    /**
     * type of instances in the nodegroup
     */
    instanceType?: string;
    /**
     * specifies a list of instance types
     */
    instanceTypes?: string[];
    /**
     * labels on nodes in the nodegroup
     */
    labels?: {[key: string]: string};
    /**
     * used by the scaling config, see cloudformation docs
     */
    launchTemplates?: outputs.GetEksClusterClusterConfigManagedNodegroupLaunchTemplate[];
    /**
     * Maximum pods per node
     */
    maxPodsPerNode?: number;
    /**
     * maximum size of instances in the nodegroup
     */
    maxSize?: number;
    /**
     * minimum size of instances in the nodegroup
     */
    minSize?: number;
    /**
     * name of the node group
     */
    name: string;
    /**
     * Override the vendor's bootstrapping script
     */
    overrideBootstrapCommand?: string;
    /**
     * specifies the placement group in which nodes should be spawned
     */
    placements?: outputs.GetEksClusterClusterConfigManagedNodegroupPlacement[];
    /**
     * executed before bootstrapping instances to the cluster
     */
    preBootstrapCommands?: string[];
    /**
     * Enable private networking for nodegroup
     */
    privateNetworking?: boolean;
    /**
     * controls security groups for this nodegroup
     */
    securityGroups?: outputs.GetEksClusterClusterConfigManagedNodegroupSecurityGroup[];
    /**
     * create a spot nodegroup
     */
    spot?: boolean;
    /**
     * configures ssh access for this nodegroup
     */
    sshes?: outputs.GetEksClusterClusterConfigManagedNodegroupSsh[];
    /**
     * Limit nodes to specific subnets
     */
    subnets?: string[];
    /**
     * Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed)
     */
    tags?: {[key: string]: string};
    /**
     * taints to apply to the nodegroup
     */
    taints?: outputs.GetEksClusterClusterConfigManagedNodegroupTaint[];
    /**
     * used by the scaling config, see cloudformation docs
     */
    updateConfigs?: outputs.GetEksClusterClusterConfigManagedNodegroupUpdateConfig[];
    /**
     * Kuberenetes version for the nodegroup
     */
    version?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeEncrypted?: boolean;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeIops?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeKmsKeyId?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeName?: string;
    /**
     * in gigabytes
     */
    volumeSize?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeThroughput?: number;
    /**
     * Valid variants are: 'gp2' is General Purpose SSD, 'gp3' is General Purpose SSD which can be optimised for high throughput (default), 'io1' is Provisioned IOPS SSD, 'sc1' is Cold HDD, 'st1' is Throughput Optimized HDD.
     */
    volumeType?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupBottleRocket {
    /**
     * Enable admin container
     */
    enableAdminContainer?: boolean;
    /**
     * contains any bottlerocket settings
     */
    settings?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupIam {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.GetEksClusterClusterConfigManagedNodegroupIamAttachPolicy[];
    /**
     * attach polciy ARN
     */
    attachPolicyArns?: string[];
    /**
     * attach policy in json string format
     */
    attachPolicyV2?: string;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iamNodeGroupWithAddonPolicies?: outputs.GetEksClusterClusterConfigManagedNodegroupIamIamNodeGroupWithAddonPolicy[];
    /**
     * instance profile ARN
     */
    instanceProfileArn?: string;
    /**
     * instance role ARN
     */
    instanceRoleArn?: string;
    /**
     * instance role Name
     */
    instanceRoleName?: string;
    /**
     * instance role permissions boundary
     */
    instanceRolePermissionBoundary?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupIamAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.GetEksClusterClusterConfigManagedNodegroupIamAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupIamAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupIamIamNodeGroupWithAddonPolicy {
    /**
     * enables access to ALB Ingress controller
     */
    albIngress?: boolean;
    /**
     * enables full access to AppMesh
     */
    appMesh?: boolean;
    /**
     * enables full access to AppMesh Preview
     */
    appMeshReview?: boolean;
    /**
     * enables IAM policy for cluster-autoscaler
     */
    autoScaler?: boolean;
    /**
     * enables the ability to add records to Route 53 in order to solve the DNS01 challenge.
     */
    certManager?: boolean;
    /**
     * enables access to cloud watch
     */
    cloudWatch?: boolean;
    /**
     * enables the new EBS CSI (Elastic Block Store Container Storage Interface) driver
     */
    ebs?: boolean;
    /**
     * enables full access to EFS
     */
    efs?: boolean;
    /**
     * adds the external-dns project policies for Amazon Route 53
     */
    externalDns?: boolean;
    /**
     * enables full access to FSX
     */
    fsx?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access. This is useful for building, for example, a CI server that needs to push images to ECR
     */
    imageBuilder?: boolean;
    /**
     * enables access to XRay
     */
    xray?: boolean;
}

export interface GetEksClusterClusterConfigManagedNodegroupInstanceSelector {
    /**
     * CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'
     */
    cpuArchitecture?: string;
    /**
     * specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.
     */
    gpus?: number;
    /**
     * specifies the memory The unit defaults to GiB
     */
    memory?: string;
    /**
     * specifies the number of vCPUs
     */
    vcpus?: number;
}

export interface GetEksClusterClusterConfigManagedNodegroupLaunchTemplate {
    /**
     * key of taint
     */
    id?: string;
    /**
     * value of taint
     */
    version?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupPlacement {
    /**
     * placement group name
     */
    group?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupSecurityGroup {
    /**
     * attaches additional security groups to the nodegroup
     */
    attachIds?: string[];
    /**
     * attach a security group local to this nodegroup Not supported for managed nodegroups
     */
    withLocal?: boolean;
    /**
     * attach the security group shared among all nodegroups in the cluster
     */
    withShared?: boolean;
}

export interface GetEksClusterClusterConfigManagedNodegroupSsh {
    /**
     * If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured
     */
    allow?: boolean;
    /**
     * Enables the ability to SSH onto nodes using SSM
     */
    enableSsm?: boolean;
    /**
     * Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKey?: string;
    /**
     * Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKeyName?: string;
    /**
     * source securitgy group IDs
     */
    sourceSecurityGroupIds?: string[];
}

export interface GetEksClusterClusterConfigManagedNodegroupTaint {
    /**
     * effect of taint
     */
    effect?: string;
    /**
     * key of taint
     */
    key?: string;
    /**
     * value of taint
     */
    value?: string;
}

export interface GetEksClusterClusterConfigManagedNodegroupUpdateConfig {
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as number)
     */
    maxUnavailable?: number;
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as percentage)
     */
    maxUnavailablePercentage?: number;
}

export interface GetEksClusterClusterConfigMetadata {
    /**
     * arbitrary metadata ignored by the vendor
     */
    annotations?: {[key: string]: string};
    /**
     * EKS Cluster name
     */
    name: string;
    /**
     * the AWS region hosting this cluster
     */
    region: string;
    /**
     * used to tag AWS resources created by the vendor
     */
    tags?: {[key: string]: string};
    /**
     * Valid variants are: '1.16', '1.17', '1.18', '1.19', '1.20' (default), '1.21'.
     */
    version?: string;
}

export interface GetEksClusterClusterConfigNodeGroup {
    /**
     * Specify custom AMIs, auto-ssm, auto, or static
     */
    ami?: string;
    /**
     * Valid variants are: 'AmazonLinux2' (default), 'Ubuntu2004', 'Ubuntu1804', 'Bottlerocket', 'WindowsServer2019CoreContainer', 'WindowsServer2019FullContainer', 'WindowsServer2004CoreContainer'.
     */
    amiFamily?: string;
    /**
     * used by the scaling config, see cloudformation docs
     */
    asgMetricsCollections?: outputs.GetEksClusterClusterConfigNodeGroupAsgMetricsCollection[];
    /**
     * See relevant AWS docs
     */
    asgSuspendProcesses?: string[];
    /**
     * Limit nodes to specific AZs
     */
    availabilityZones?: string[];
    /**
     * specifies settings for Bottlerocket nodes
     */
    bottleRockets?: outputs.GetEksClusterClusterConfigNodeGroupBottleRocket[];
    /**
     * Associate load balancers with auto scaling group
     */
    classicLoadBalancerNames?: string[];
    /**
     * Custom address used for DNS lookups
     */
    clusterDns?: string;
    /**
     * configures T3 Unlimited, valid only for T-type instances
     */
    cpuCredits?: string;
    /**
     * Desired capacity of instances in the nodegroup
     */
    desiredCapacity?: number;
    /**
     * requires requests to the metadata service to use IMDSv2 tokens
     */
    disableImdsv1?: boolean;
    /**
     * blocks all IMDS requests from non host networking pods
     */
    disablePodsImds?: boolean;
    /**
     * enables EBS optimization
     */
    ebsOptimized?: boolean;
    /**
     * creates the maximum allowed number of EFA-enabled network cards on nodes in this group.
     */
    efaEnabled?: boolean;
    /**
     * Enable EC2 detailed monitoring
     */
    enableDetailedMonitoring?: boolean;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iams?: outputs.GetEksClusterClusterConfigNodeGroupIam[];
    /**
     * for instances in the nodegroup
     */
    instanceName?: string;
    /**
     * for instances in the nodegroup
     */
    instancePrefix?: string;
    /**
     * specifies options for EC2 instance selector
     */
    instanceSelectors?: outputs.GetEksClusterClusterConfigNodeGroupInstanceSelector[];
    /**
     * type of instances in the nodegroup
     */
    instanceType?: string;
    /**
     * holds the configuration for spot instances
     */
    instancesDistributions?: outputs.GetEksClusterClusterConfigNodeGroupInstancesDistribution[];
    /**
     * Custom address used for DNS lookups
     */
    kubeletExtraConfigs?: outputs.GetEksClusterClusterConfigNodeGroupKubeletExtraConfig[];
    /**
     * labels on nodes in the nodegroup
     */
    labels?: {[key: string]: string};
    /**
     * Maximum pods per node
     */
    maxPodsPerNode?: number;
    /**
     * Maximum size of instances in the nodegroup
     */
    maxSize?: number;
    /**
     * Minimum size of instances in the nodegroup
     */
    minSize?: number;
    /**
     * name of the node group
     */
    name?: string;
    /**
     * Override the vendor's bootstrapping script
     */
    overrideBootstrapCommand?: string;
    /**
     * specifies the placement group in which nodes should be spawned
     */
    placements?: outputs.GetEksClusterClusterConfigNodeGroupPlacement[];
    /**
     * executed before bootstrapping instances to the cluster
     */
    preBootstrapCommands?: string[];
    /**
     * Enable private networking for nodegroup
     */
    privateNetworking?: boolean;
    /**
     * controls security groups for this nodegroup
     */
    securityGroups?: outputs.GetEksClusterClusterConfigNodeGroupSecurityGroup[];
    /**
     * configures ssh access for this nodegroup
     */
    sshes?: outputs.GetEksClusterClusterConfigNodeGroupSsh[];
    /**
     * Create new subnet from the CIDR block and limit nodes to this subnet (Applicable only for the WavelenghZone nodes)
     */
    subnetCidr?: string;
    /**
     * Limit nodes to specific subnets
     */
    subnets?: string[];
    /**
     * Applied to the Autoscaling Group and to the EC2 instances (unmanaged), Applied to the EKS Nodegroup resource and to the EC2 instances (managed)
     */
    tags?: {[key: string]: string};
    /**
     * taints to apply to the nodegroup
     */
    taints?: outputs.GetEksClusterClusterConfigNodeGroupTaint[];
    /**
     * Associate target group with auto scaling group
     */
    targetGroupArns?: string[];
    /**
     * used by the scaling config, see cloudformation docs
     */
    updateConfigs?: outputs.GetEksClusterClusterConfigNodeGroupUpdateConfig[];
    /**
     * Kuberenetes version for the nodegroup
     */
    version?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeEncrypted?: boolean;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeIops?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeKmsKeyId?: string;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeName?: string;
    /**
     * volume size in gigabytes
     */
    volumeSize?: number;
    /**
     * of volumes attached to instances in the nodegroup
     */
    volumeThroughput?: number;
    /**
     * Valid variants are: 'gp2' is General Purpose SSD, 'gp3' is General Purpose SSD which can be optimised for high throughput (default), 'io1' is Provisioned IOPS SSD, 'sc1' is Cold HDD, 'st1' is Throughput Optimized HDD.
     */
    volumeType?: string;
}

export interface GetEksClusterClusterConfigNodeGroupAsgMetricsCollection {
    /**
     * of metrics collected
     */
    granularity?: string;
    /**
     * specifies a list of metrics
     */
    metrics?: string[];
}

export interface GetEksClusterClusterConfigNodeGroupBottleRocket {
    /**
     * Enable admin container
     */
    enableAdminContainer?: boolean;
    /**
     * contains any bottlerocket settings
     */
    settings?: string;
}

export interface GetEksClusterClusterConfigNodeGroupIam {
    /**
     * holds a policy document to attach to this service account
     */
    attachPolicies?: outputs.GetEksClusterClusterConfigNodeGroupIamAttachPolicy[];
    /**
     * attach polciy ARN
     */
    attachPolicyArns?: string[];
    /**
     * attach policy in json string format
     */
    attachPolicyV2?: string;
    /**
     * holds all IAM attributes of a NodeGroup
     */
    iamNodeGroupWithAddonPolicies?: outputs.GetEksClusterClusterConfigNodeGroupIamIamNodeGroupWithAddonPolicy[];
    /**
     * instance profile ARN
     */
    instanceProfileArn?: string;
    /**
     * instance role ARN
     */
    instanceRoleArn?: string;
    /**
     * instance role Name
     */
    instanceRoleName?: string;
    /**
     * instance role permissions boundary
     */
    instanceRolePermissionBoundary?: string;
}

export interface GetEksClusterClusterConfigNodeGroupIamAttachPolicy {
    /**
     * Attach policy id
     */
    id?: string;
    /**
     * holds status of the IAM service account
     */
    statements?: outputs.GetEksClusterClusterConfigNodeGroupIamAttachPolicyStatement[];
    /**
     * Attach policy version
     */
    version?: string;
}

export interface GetEksClusterClusterConfigNodeGroupIamAttachPolicyStatement {
    /**
     * Attach policy action
     */
    actions?: string[];
    /**
     * Attach policy Statement
     */
    condition?: string;
    /**
     * Attach policy effect
     */
    effect?: string;
    /**
     * Attach policy NotAction
     */
    notActions?: string[];
    /**
     * Attach policy NotPrincipal
     */
    notPrincipal?: string;
    /**
     * Attach policy NotResource
     */
    notResources?: string[];
    /**
     * Attach policy principal
     */
    principal?: string;
    /**
     * Attach policy resource
     */
    resource?: string;
    /**
     * Sid of policy
     */
    sid?: string;
}

export interface GetEksClusterClusterConfigNodeGroupIamIamNodeGroupWithAddonPolicy {
    /**
     * enables access to ALB Ingress controller
     */
    albIngress?: boolean;
    /**
     * enables full access to AppMesh
     */
    appMesh?: boolean;
    /**
     * enables full access to AppMesh Preview
     */
    appMeshReview?: boolean;
    /**
     * enables IAM policy for cluster-autoscaler
     */
    autoScaler?: boolean;
    /**
     * enables the ability to add records to Route 53 in order to solve the DNS01 challenge.
     */
    certManager?: boolean;
    /**
     * enables access to cloud watch
     */
    cloudWatch?: boolean;
    /**
     * enables the new EBS CSI (Elastic Block Store Container Storage Interface) driver
     */
    ebs?: boolean;
    /**
     * enables full access to EFS
     */
    efs?: boolean;
    /**
     * adds the external-dns project policies for Amazon Route 53
     */
    externalDns?: boolean;
    /**
     * enables full access to FSX
     */
    fsx?: boolean;
    /**
     * allows for full ECR (Elastic Container Registry) access. This is useful for building, for example, a CI server that needs to push images to ECR
     */
    imageBuilder?: boolean;
    /**
     * enables access to XRay
     */
    xray?: boolean;
}

export interface GetEksClusterClusterConfigNodeGroupInstanceSelector {
    /**
     * CPU Architecture of the EC2 instance type. Valid variants are: 'x86_64' 'amd64' 'arm64'
     */
    cpuArchitecture?: string;
    /**
     * specifies the number of GPUs. It can be set to 0 to select non-GPU instance types.
     */
    gpus?: number;
    /**
     * specifies the memory The unit defaults to GiB
     */
    memory?: string;
    /**
     * specifies the number of vCPUs
     */
    vcpus?: number;
}

export interface GetEksClusterClusterConfigNodeGroupInstancesDistribution {
    /**
     * Enable capacity rebalancing for spot instances
     */
    capacityRebalance?: boolean;
    /**
     * Enable admin container
     */
    instanceTypes?: string[];
    /**
     * Maximum bid price in USD
     */
    maxPrice?: number;
    /**
     * base number of on-demand instances (non-negative)
     */
    onDemandBaseCapacity?: number;
    /**
     * Range [0-100]
     */
    onDemandPercentageAboveBaseCapacity?: number;
    /**
     * allocation strategy for spot instances. Valid values are capacity-optimized and lowest-price
     */
    spotAllocationStrategy?: string;
    /**
     * Range [0-20]
     */
    spotInstancePools?: number;
}

export interface GetEksClusterClusterConfigNodeGroupKubeletExtraConfig {
    evictionHard?: {[key: string]: string};
    featureGates?: {[key: string]: string};
    kubeReserved?: {[key: string]: string};
    kubeReservedCgroup?: string;
    systemReserved?: {[key: string]: string};
}

export interface GetEksClusterClusterConfigNodeGroupPlacement {
    /**
     * placement group name
     */
    group?: string;
}

export interface GetEksClusterClusterConfigNodeGroupSecurityGroup {
    /**
     * attaches additional security groups to the nodegroup
     */
    attachIds?: string[];
    /**
     * attach a security group local to this nodegroup Not supported for managed nodegroups
     */
    withLocal?: boolean;
    /**
     * attach the security group shared among all nodegroups in the cluster
     */
    withShared?: boolean;
}

export interface GetEksClusterClusterConfigNodeGroupSsh {
    /**
     * If Allow is true the SSH configuration provided is used, otherwise it is ignored. Only one of PublicKeyPath, PublicKey and PublicKeyName can be configured
     */
    allow?: boolean;
    /**
     * Enables the ability to SSH onto nodes using SSM
     */
    enableSsm?: boolean;
    /**
     * Public key to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKey?: string;
    /**
     * Public key name in EC2 to be added to the nodes SSH keychain. If Allow is false this value is ignored.
     */
    publicKeyName?: string;
    /**
     * source securitgy group IDs
     */
    sourceSecurityGroupIds?: string[];
}

export interface GetEksClusterClusterConfigNodeGroupTaint {
    /**
     * effect of taint
     */
    effect?: string;
    /**
     * key of taint
     */
    key?: string;
    /**
     * value of taint
     */
    value?: string;
}

export interface GetEksClusterClusterConfigNodeGroupUpdateConfig {
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as number)
     */
    maxUnavaliable?: number;
    /**
     * sets the max number of nodes that can become unavailable when updating a nodegroup (specified as percentage)
     */
    maxUnavaliablePercetage?: number;
}

export interface GetEksClusterClusterConfigPrivateCluster {
    /**
     * specifies additional endpoint services that must be enabled for private access. Valid entries are: 'cloudformation', 'autoscaling', 'logs'
     */
    additionalEndpointServices?: string[];
    /**
     * enables creation of a fully-private cluster
     */
    enabled?: boolean;
    /**
     * skips the creation process for endpoints completely. This is only used in case of an already provided VPC and if the user decided to set it to true.
     */
    skipEndpointCreation?: boolean;
}

export interface GetEksClusterClusterConfigSecretsEncryption {
    /**
     * Flag to encrypt existing secrets. Default is true
     */
    encryptExistingSecrets?: boolean;
    /**
     * KMS key ARN
     */
    keyArn?: string;
}

export interface GetEksClusterClusterConfigVpc {
    /**
     * AutoAllocateIPV6 requests an IPv6 CIDR block with /56 prefix for the VPC
     */
    autoAllocateIpv6?: boolean;
    /**
     * AWS VPC ID.
     */
    cidr?: string;
    /**
     * Manage access to the Kubernetes API server endpoints.
     */
    clusterEndpoints?: outputs.GetEksClusterClusterConfigVpcClusterEndpoint[];
    /**
     * for additional CIDR associations, e.g. a CIDR for private subnets or any ad-hoc subnets
     */
    extraCidrs?: string[];
    /**
     * for additional CIDR associations, e.g. a CIDR for private subnets or any ad-hoc subnets
     */
    extraIpv6Cidrs?: string[];
    /**
     * AWS VPC ID.
     */
    id?: string;
    /**
     * n/a
     */
    ipv6Cidr?: string;
    /**
     * n/a
     */
    ipv6Pool?: string;
    /**
     * Automatically add security group rules to and from the default cluster security group and the shared node security group. This allows unmanaged nodes to communicate with the control plane and managed nodes. This option cannot be disabled when using vendor created security groups.
     */
    manageSharedNodeSecurityGroupRules?: boolean;
    /**
     * NAT config
     */
    nats?: outputs.GetEksClusterClusterConfigVpcNat[];
    /**
     * which CIDR blocks to allow access to public k8s API endpoint
     */
    publicAccessCidrs?: string[];
    /**
     * (aka the ControlPlaneSecurityGroup) for communication between control plane and nodes
     */
    securityGroup?: string;
    /**
     * for pre-defined shared node SG
     */
    sharedNodeSecurityGroup?: string;
    /**
     * keyed by AZ for convenience.
     */
    subnets?: outputs.GetEksClusterClusterConfigVpcSubnet[];
}

export interface GetEksClusterClusterConfigVpcClusterEndpoint {
    /**
     * enable private access to the Kubernetes API server endpoints.
     */
    privateAccess?: boolean;
    /**
     * enable public access to the Kubernetes API server endpoints.
     */
    publicAccess?: boolean;
}

export interface GetEksClusterClusterConfigVpcNat {
    /**
     * Valid variants are: 'HighlyAvailable' configures a highly available NAT gateway, 'Single' configures a single NAT gateway (default), 'Disable' disables NAT.
     */
    gateway?: string;
}

export interface GetEksClusterClusterConfigVpcSubnet {
    /**
     * holds subnet to AZ mappings. If the key is an AZ, that also becomes the name of the subnet otherwise use the key to refer to this subnet.
     */
    privates?: outputs.GetEksClusterClusterConfigVpcSubnetPrivate[];
    /**
     * holds subnet to AZ mappings. If the key is an AZ, that also becomes the name of the subnet otherwise use the key to refer to this subnet.
     */
    publics?: outputs.GetEksClusterClusterConfigVpcSubnetPublic[];
}

export interface GetEksClusterClusterConfigVpcSubnetPrivate {
    /**
     * dont know what this is, not in docs
     */
    az?: string;
    /**
     * dont know what this is, not in docs
     */
    cidr?: string;
    /**
     * id of subnet
     */
    id?: string;
    /**
     * name of subnet
     */
    name?: string;
}

export interface GetEksClusterClusterConfigVpcSubnetPublic {
    /**
     * dont know what this is, not in docs
     */
    az?: string;
    /**
     * dont know what this is, not in docs
     */
    cidr?: string;
    /**
     * id of subnet
     */
    id?: string;
    /**
     * name of subnet
     */
    name?: string;
}

export interface GetEksClusterClusterMetadata {
    /**
     * The labels for the cluster in Rafay console.
     */
    labels?: {[key: string]: string};
    /**
     * The name of the EKS cluster in Rafay console. This must be unique in your organization.
     */
    name: string;
    /**
     * The name of the Rafay project the cluster will be created in.
     */
    project: string;
}

export interface GetEksClusterClusterSpec {
    /**
     * The blueprint associated with the cluster. A blueprint defines the configuration and policy. Use blueprints to help standardize cluster configurations.
     */
    blueprint?: string;
    /**
     * The blueprint version associated with the cluster.
     */
    blueprintVersion?: string;
    /**
     * The cloud credentials provider used to create and manage the cluster.
     */
    cloudProvider: string;
    /**
     * The container network interface (CNI) parameters.
     */
    cniParams?: outputs.GetEksClusterClusterSpecCniParams;
    /**
     * The container network interface (CNI) provider used to specify different network connectivity options for the cluster.
     */
    cniProvider?: string;
    /**
     * Role ARN of the linked account
     */
    crossAccountRoleArn?: string;
    /**
     * The proxy configuration for the cluster. Use this if the infrastructure uses an outbound proxy.
     */
    proxyConfig?: {[key: string]: string};
    /**
     * The sharing configuration for the resource. A cluster can be shared with one or more projects. Note: If the resource is not shared, set enabled = false.
     */
    sharing?: outputs.GetEksClusterClusterSpecSharing;
    /**
     * Configure tolerations and nodeSelector for Rafay system components.
     */
    systemComponentsPlacement?: outputs.GetEksClusterClusterSpecSystemComponentsPlacement;
    /**
     * The cluster type. Supported value is `eks`.
     */
    type?: string;
}

export interface GetEksClusterClusterSpecCniParams {
    /**
     * Secondary IPv4 CIDR block for the VPC. This should be specified if you choose to auto-create VPC and subnets while creating the EKS cluster.
     */
    customCniCidr?: string;
    /**
     * The custom container network interface custom resource definition specification. One or more of these blocks should be specified if you choose to use your existing VPC and subnets while creating the EKS cluster.
     */
    customCniCrdSpecs?: outputs.GetEksClusterClusterSpecCniParamsCustomCniCrdSpec[];
}

export interface GetEksClusterClusterSpecCniParamsCustomCniCrdSpec {
    /**
     * The custom CNI configuration for this AZ.
     */
    cniSpec?: outputs.GetEksClusterClusterSpecCniParamsCustomCniCrdSpecCniSpec;
    /**
     * The name of the Availability Zone (AZ). The availability zone specified here should be a part of the region specified for the EKS cluster.
     */
    name: string;
}

export interface GetEksClusterClusterSpecCniParamsCustomCniCrdSpecCniSpec {
    /**
     * The security groups associated with secondary ENIs for AWS EC2 nodes.
     */
    securityGroups?: string[];
    /**
     * The subnet associated with secondary ENIs for AWS EC2 nodes.
     */
    subnet?: string;
}

export interface GetEksClusterClusterSpecSharing {
    /**
     * Enable sharing for this resource.
     */
    enabled?: boolean;
    /**
     * The list of projects this resource is shared with. Note: Required when project sharing is enabled.
     */
    projects?: outputs.GetEksClusterClusterSpecSharingProject[];
}

export interface GetEksClusterClusterSpecSharingProject {
    /**
     * The name of the project to share the resource.
     */
    name: string;
}

export interface GetEksClusterClusterSpecSystemComponentsPlacement {
    /**
     * Allows users to override the default behaviour of DaemonSet for specific nodes, enabling the addition of additional tolerations for Daemonsets to match the taints available on the nodes.
     */
    daemonsetOverrides?: outputs.GetEksClusterClusterSpecSystemComponentsPlacementDaemonsetOverride[];
    /**
     * Key-Value pairs insuring pods to be scheduled on desired nodes.
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Enables the kuberenetes scheduler to schedule pods with matching taints.
     */
    tolerations?: outputs.GetEksClusterClusterSpecSystemComponentsPlacementToleration[];
}

export interface GetEksClusterClusterSpecSystemComponentsPlacementDaemonsetOverride {
    /**
     * enables node selection
     */
    nodeSelectionEnabled?: boolean;
    /**
     * Additional tolerations for Daemonsets to match the taints available on the nodes
     */
    tolerations?: outputs.GetEksClusterClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration[];
}

export interface GetEksClusterClusterSpecSystemComponentsPlacementDaemonsetOverrideToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface GetEksClusterClusterSpecSystemComponentsPlacementToleration {
    /**
     * indicates the taint effect to match
     */
    effect?: string;
    /**
     * the taint key that the toleration applies to
     */
    key?: string;
    /**
     * represents a key's relationship to the value
     */
    operator?: string;
    /**
     * represents the period of time the toleration tolerates the taint
     */
    tolerationSeconds?: number;
    /**
     * the taint value the toleration matches to
     */
    value?: string;
}

export interface GetEksClusterTimeouts {
    read?: string;
}

export interface GetGkeClusterMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetGkeClusterMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetGkeClusterMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetGkeClusterMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetGkeClusterMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetGkeClusterSpec {
    /**
     * The blueprint to be used for this cluster. Use this for GKE/EKSABM/MKS cluster type
     */
    blueprint?: outputs.GetGkeClusterSpecBlueprint;
    /**
     * The credentials to be used to interact with the cloud infrastructure
     */
    cloudCredentials?: string;
    /**
     * GKE cluster config
     */
    configs?: outputs.GetGkeClusterSpecConfig[];
    /**
     * The proxy to be used for this cluster. Use this for GKE/MKS cluster type
     */
    proxy?: outputs.GetGkeClusterSpecProxy;
    /**
     * Sharing spec to be used for sharing the cluster with projects
     */
    sharing?: outputs.GetGkeClusterSpecSharing;
    /**
     * The type of the cluster this spec corresponds to
     */
    type?: string;
}

export interface GetGkeClusterSpecBlueprint {
    name?: string;
    version?: string;
}

export interface GetGkeClusterSpecConfig {
    /**
     * Kubernetes version of ControlPlane
     */
    controlPlaneVersion?: string;
    /**
     * GKE cluster additional features configuration.
     */
    features?: outputs.GetGkeClusterSpecConfigFeatures;
    /**
     * GCP Project name.
     */
    gcpProject?: string;
    /**
     * GKE cluster location configuration.
     */
    location?: outputs.GetGkeClusterSpecConfigLocation;
    /**
     * GKE cluster Network configuration.
     */
    network?: outputs.GetGkeClusterSpecConfigNetwork;
    /**
     * GKE cluster node pool configuration.
     */
    nodePools?: outputs.GetGkeClusterSpecConfigNodePool[];
    /**
     * Commands will be executed every time Cluster nodes come up. Example: Node Creation, Node Restart.
     */
    preBootstrapCommands?: string[];
    /**
     * GKE cluster Network configuration.
     */
    security?: outputs.GetGkeClusterSpecConfigSecurity;
}

export interface GetGkeClusterSpecConfigFeatures {
    /**
     * List of components for cloud logging
     */
    cloudLoggingComponents?: string[];
    /**
     * List of components for cloud monitoring
     */
    cloudMonitoringComponents?: string[];
    /**
     * Application Manager is a GKE controller for managing the lifecycle of applications. It enables application delivery and updates following Kubernetes and GitOps best practices
     */
    enableApplicationManagerBeta?: boolean;
    /**
     * Backup for GKE allows you to back up and restore GKE workloads. There is no cost for enabling this feature, but you are charged for backups based on the size of the data and the number of pods you protect
     */
    enableBackupForGke?: boolean;
    /**
     * Logging collects logs emitted by your applications and by GKE infrastructure
     */
    enableCloudLogging?: boolean;
    /**
     * Monitoring collects metrics emitted by your applications and by GKE infrastructure
     */
    enableCloudMonitoring?: boolean;
    /**
     * Enable to automatically deploy and manage the Compute Engine Persistent Disk CSI Driver. This feature is an alternative to using the gcePersistentDisk in-tree volume plugin
     */
    enableComputeEnginePersistentDiskCsiDriver?: boolean;
    /**
     * Enable to automatically deploy and manage the Filestore CSI Driver
     */
    enableFilestoreCsiDriver?: boolean;
    /**
     * Image streaming allows your workloads to initialize without waiting for the entire image to download
     */
    enableImageStreaming?: boolean;
    /**
     * This option deploys managed collectors for Prometheus metrics within this cluster. These collectors must be configured using PodMonitoring resources. To enable Managed Service for Prometheus here, you'll need. Cluster version of 1.21.4-gke.300 or greater
     */
    enableManagedServicePrometheus?: boolean;
}

export interface GetGkeClusterSpecConfigLocation {
    config?: outputs.GetGkeClusterSpecConfigLocationConfig;
    /**
     * For Zonal cluster increase availability by selecting more than one zone. For Regional cluster By default, Kubernetes Engine runs nodes of a regional cluster across three zones within a region. Select this option if you want to manually specify the zones in which this cluster's nodes run. All zones must be within the same region.
     */
    defaultNodeLocations?: outputs.GetGkeClusterSpecConfigLocationDefaultNodeLocations;
    /**
     * GKE Cluster location can be either zonal or regional
     */
    type?: string;
}

export interface GetGkeClusterSpecConfigLocationConfig {
    /**
     * Regional location in which the cluster's control plane and nodes are located
     */
    region?: string;
    /**
     * Zone in the region where bootstrap VM is created for cluster provisioning
     */
    zone?: string;
}

export interface GetGkeClusterSpecConfigLocationDefaultNodeLocations {
    /**
     * Enable providing default node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Increase availability by providing more than one zone. The same number of nodes will be deployed to each zone in the list.
     */
    zones?: string[];
}

export interface GetGkeClusterSpecConfigNetwork {
    /**
     * NetworkAccess config for describing access configurations for the cluster's workload
     */
    access?: outputs.GetGkeClusterSpecConfigNetworkAccess;
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    controlPlaneAuthorizedNetwork?: outputs.GetGkeClusterSpecConfigNetworkControlPlaneAuthorizedNetwork;
    /**
     * Dataplane V2 is optimized for Kubernetes networking kwhich is implemented using eBPF. Possible values: ADVANCED_DATAPATH.
     */
    dataPlaneV2?: string;
    /**
     * Dataplane V2 metrics brings better insight into the traffic between your Kubernetes workloads. Understand how your services communicate, identify issues with the network health, verify Kubernetes policies and more.
     */
    enableDataPlaneV2Metrics?: boolean;
    /**
     * Dataplane V2 observability provides Managed Hubble CLI solution that lets you observe network flows between your Kubernetes workloads in real time.
     */
    enableDataPlaneV2Observability?: boolean;
    /**
     * This feature uses alias IP and provides a more secure integration with Google Cloud Platform services
     */
    enableVpcNativetraffic?: boolean;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * Name of the network that the cluster is in. It determines which other Compute Engine resource it is able to communicate with
     */
    name?: string;
    /**
     * The Kubernetes Network Policy API allows the cluster administrator to specify what pods are allowed to communicate with each other. Possible values: CALICO
     */
    networkPolicy?: string;
    /**
     * Configuration for NetworkPolicy. This only tracks whether the addon is enabled or not on the Master,it does not track whether network policy is enabled for the nodes.
     */
    networkPolicyConfig?: boolean;
    /**
     * All pods in the cluster are assigned an IP address from this range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    podAddressRange?: string;
    /**
     * Cluster pods are assigned an IP from the selected node subnet's secondary CIDR address range.
     */
    podSecondaryRangeName?: string;
    /**
     * Cluster services will be assigned an IP address from this IP address range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    serviceAddressRange?: string;
    /**
     * Cluster services are assigned an IP from the selected node subnetes secondary CIDR address range.
     */
    serviceSecondaryRangeName?: string;
    /**
     * Subnetwork to which the Kubernetes cluster will belong. When VPC native is enabled, the subnetwork must contain at least two secondary ranges which are not used by other Kubernetes clusters. Subnet is permanent.
     */
    subnetName?: string;
}

export interface GetGkeClusterSpecConfigNetworkAccess {
    config?: outputs.GetGkeClusterSpecConfigNetworkAccessConfig;
    /**
     * Choose the type of network you want to allow to access your cluster's workloads. private or public
     */
    type?: string;
}

export interface GetGkeClusterSpecConfigNetworkAccessConfig {
    /**
     * Control plane IP range is for the control plane VPC. The control plane range must not overlap with any subnet in your cluster's VPC. The control plane and your cluster use VPC peering to communicate privately
     */
    controlPlaneIpRange?: string;
    /**
     * To use Privately Used Public IPs (PUPI) ranges, the default source NAT used for IP masquerading needs to be disabled
     */
    disableSnat?: boolean;
    /**
     * Disabling this option locks down external access to the cluster control plane. There is still an external IP address used by Google for cluster management purposes, but the IP address is not accessible to anyone
     */
    enableAccessControlPlaneExternalIp?: boolean;
    /**
     * With control plane global access, you can access the control plane's private endpoint from any GCP region or on-premises environment no matter what the private cluster's region is
     */
    enableAccessControlPlaneGlobal?: boolean;
    /**
     * Use FirewallRule config to specify additional firewall rules. Only Private clusters are supported.By default, tcp:9443 and tcp:22281 are opened for private cluster.
     */
    firewallRules?: outputs.GetGkeClusterSpecConfigNetworkAccessConfigFirewallRule[];
}

export interface GetGkeClusterSpecConfigNetworkAccessConfigFirewallRule {
    action?: string;
    description?: string;
    destinationRanges?: string[];
    direction?: string;
    name?: string;
    network?: string;
    priority?: number;
    rules?: outputs.GetGkeClusterSpecConfigNetworkAccessConfigFirewallRuleRule[];
    sourceRanges?: string[];
    targetTags?: string[];
}

export interface GetGkeClusterSpecConfigNetworkAccessConfigFirewallRuleRule {
    ports?: string[];
    protocol?: string;
}

export interface GetGkeClusterSpecConfigNetworkControlPlaneAuthorizedNetwork {
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    authorizedNetworks?: outputs.GetGkeClusterSpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork[];
    /**
     * Enable Control Plane Authorized Network. Configure the Networks now or later.
     */
    enabled?: boolean;
}

export interface GetGkeClusterSpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork {
    /**
     * CIDR Example: 198.51.100.0/24
     */
    cidr?: string;
    /**
     * Name of the Authorized Network Example: Corporate Office
     */
    name?: string;
}

export interface GetGkeClusterSpecConfigNodePool {
    /**
     * Cluster autoscaler automatically creates or deletes nodes based on workload needs
     */
    autoScaling?: outputs.GetGkeClusterSpecConfigNodePoolAutoScaling;
    /**
     * Choose the machine configuration that will best fit the resource needs of your cluster
     */
    machineConfig?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfig;
    /**
     * Node management configuration
     */
    management?: outputs.GetGkeClusterSpecConfigNodePoolManagement;
    /**
     * Node metadata settings will be used when new nodes are created using this node pool
     */
    metadata?: outputs.GetGkeClusterSpecConfigNodePoolMetadata;
    /**
     * Node pool names must start with a lowercase letter followed by up to 39 lowercase letters, numbers, or hyphens. They can't end with a hyphen. You cannot change the node pool's name once it's created
     */
    name?: string;
    /**
     * Node networking settings will be used when new nodes are created using this node pool
     */
    networking?: outputs.GetGkeClusterSpecConfigNodePoolNetworking;
    /**
     * Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    nodeLocations?: outputs.GetGkeClusterSpecConfigNodePoolNodeLocations;
    /**
     * Specify Node k8s version
     */
    nodeVersion?: string;
    /**
     * Node security settings will be used when new nodes are created using this node pool
     */
    security?: outputs.GetGkeClusterSpecConfigNodePoolSecurity;
    /**
     * Pod address range limits the maximum size of the cluster
     */
    size?: number;
    /**
     * Node pool upgrade options
     */
    upgradeSettings?: outputs.GetGkeClusterSpecConfigNodePoolUpgradeSettings;
}

export interface GetGkeClusterSpecConfigNodePoolAutoScaling {
    /**
     * Maximum number of nodes (per zone)
     */
    maxNodes?: number;
    /**
     * Minimum number of nodes (per zone)
     */
    minNodes?: number;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfig {
    /**
     * Add accelerators to the node pool
     */
    accelerators?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfigAccelerator[];
    /**
     * Select Boot disk size. Boot disk size is permanent
     */
    bootDiskSize?: number;
    /**
     * Select Boot disk type. Storage space is less expensive for a standard persistent disk. An SSD persistent disk is better for random IOPS or for streaming throughput with low latency
     */
    bootDiskType?: string;
    /**
     * Choose which operating system image you want to run on each node of this cluster
     */
    imageType?: string;
    /**
     * Choose the machine type that will best fit the resource needs of your cluster
     */
    machineType?: string;
    /**
     * Zonal compute reservation to this node pool
     */
    reservationAffinity?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfigReservationAffinity;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfigAccelerator {
    /**
     * GPU Sharing allows you to share a single GPU device with multipe containers
     */
    acceleratorSharing?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing;
    /**
     * Number of GPUs
     */
    count?: number;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    gpuDriverInstallation?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation;
    /**
     * Size of partitions to create on the GPU. Valid values are described in the guide - https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning
     */
    gpuPartitionSize?: string;
    /**
     * GPU Type
     */
    type?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing {
    /**
     * The max number of clients that can share a physical GPU device
     */
    maxSharedClients?: number;
    /**
     * The strategy to use for sharing GPUs . Example: Time-Sharing
     */
    strategy?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation {
    config?: outputs.GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    type?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig {
    /**
     * The version of the GPU driver to install
     */
    version?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMachineConfigReservationAffinity {
    /**
     * Type of reservation consumption.
     */
    consumeReservationType?: string;
    /**
     * The name of the Reservation to be consumed. Only mandatory when consumeReservationType is set to specific
     */
    reservationName?: string;
}

export interface GetGkeClusterSpecConfigNodePoolManagement {
    /**
     * Whether the nodes will be automatically upgraded
     */
    autoUpgrade?: boolean;
}

export interface GetGkeClusterSpecConfigNodePoolMetadata {
    /**
     * Metadata to be stored in the instance
     */
    gceInstanceMetadatas?: outputs.GetGkeClusterSpecConfigNodePoolMetadataGceInstanceMetadata[];
    /**
     * Use Kubernetes labels to control how workloads are scheduled to your nodes. Labels are applied to all nodes in this node pool and cannot be changed once the cluster is created
     */
    kubernetesLabels?: outputs.GetGkeClusterSpecConfigNodePoolMetadataKubernetesLabel[];
    /**
     * A node taint lets you mark a node so that the scheduler avoids or prevents using it for certain Pods. Node taints can be used with tolerations to ensure that Pods aren't scheduled onto inappropriate nodes
     */
    nodeTaints?: outputs.GetGkeClusterSpecConfigNodePoolMetadataNodeTaint[];
}

export interface GetGkeClusterSpecConfigNodePoolMetadataGceInstanceMetadata {
    /**
     * Key for this metadata
     */
    key?: string;
    /**
     * Value for this metadata
     */
    value?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMetadataKubernetesLabel {
    /**
     * Key for this kubernetes label
     */
    key?: string;
    /**
     * Value for this kubernetes lable
     */
    value?: string;
}

export interface GetGkeClusterSpecConfigNodePoolMetadataNodeTaint {
    /**
     * Available effects are NoSchedule, PreferNoSchedule, NoExecute
     */
    effect?: string;
    /**
     * Key for this Taint effect
     */
    key?: string;
    /**
     * Value for this Taint effect
     */
    value?: string;
}

export interface GetGkeClusterSpecConfigNodePoolNetworking {
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    networkTags?: string[];
}

export interface GetGkeClusterSpecConfigNodePoolNodeLocations {
    /**
     * Enable providing node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    zones?: string[];
}

export interface GetGkeClusterSpecConfigNodePoolSecurity {
    /**
     * Integrity monitoring lets you monitor and verify the runtime boot integrity of your shielded nodes using Cloud Monitoring
     */
    enableIntegrityMonitoring?: boolean;
    /**
     * Secure boot helps protect your nodes against boot-level and kernel-level malware and rootkits
     */
    enableSecureBoot?: boolean;
}

export interface GetGkeClusterSpecConfigNodePoolUpgradeSettings {
    config?: outputs.GetGkeClusterSpecConfigNodePoolUpgradeSettingsConfig;
    /**
     * Update strategy of the node pool. Possible values are SURGE and BLUE_GREEN
     */
    strategy?: string;
}

export interface GetGkeClusterSpecConfigNodePoolUpgradeSettingsConfig {
    /**
     * Number of blue nodes to drain in a batch.
     */
    batchNodeCount?: number;
    /**
     * Soak time after each batch gets drained.
     */
    batchSoakDuration?: string;
    /**
     * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be simultaneously unavailable during the upgrade process.
     */
    maxUnavailable?: number;
    /**
     * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.
     */
    nodePoolSoakDuration?: string;
}

export interface GetGkeClusterSpecConfigSecurity {
    /**
     * Google Groups for RBAC allows you to grant roles to all members of a Google Workspace group
     */
    enableGoogleGroupsForRbac?: boolean;
    /**
     * Enable legacy authorization to support in-cluster permissions for existing clusters or workflows. Prevents full RBAC support
     */
    enableLegacyAuthorization?: boolean;
    /**
     * Workload Identity lets you connect securely to Google APIs from Kubernetes Engine workloads
     */
    enableWorkloadIdentity?: boolean;
    /**
     * Clients use this base64-encoded public certificate to authenticate to the cluster endpoint. Certificates don’t rotate automatically and are difficult to revoke
     */
    issueClientCertificate?: boolean;
    /**
     * Provide the security groups here
     */
    securityGroup?: string;
}

export interface GetGkeClusterSpecProxy {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface GetGkeClusterSpecSharing {
    enabled?: boolean;
    projects?: outputs.GetGkeClusterSpecSharingProject[];
}

export interface GetGkeClusterSpecSharingProject {
    name?: string;
}

export interface GetGkeClusterTimeouts {
    read?: string;
}

export interface GetGroupTimeouts {
    read?: string;
}

export interface GetGroupassociationTimeouts {
    read?: string;
}

export interface GetProjectMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetProjectMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetProjectMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetProjectMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetProjectMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetProjectSpec {
    /**
     * resource quota to be assigned to a cluster in a project
     */
    clusterResourceQuota?: outputs.GetProjectSpecClusterResourceQuota;
    /**
     * flag to indicate if this is the default project in the organization
     */
    default?: boolean;
    /**
     * default resource quota to be assigned to a namespacein a project
     */
    defaultClusterNamespaceQuota?: outputs.GetProjectSpecDefaultClusterNamespaceQuota;
    /**
     * webhook config details
     */
    driftWebhook?: outputs.GetProjectSpecDriftWebhook;
    /**
     * namespaces excluded from sync
     */
    syncExcludedNamespaces?: string[];
}

export interface GetProjectSpecClusterResourceQuota {
    /**
     * The maximum number of ConfigMaps that can exist in the project/namespace
     */
    configMaps?: string;
    /**
     * The maximum amount of CPU (in millicores) allocated to the project/namespace
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the project/namespace
     */
    cpuRequests?: string;
    /**
     * The maximum number of GPUs allocated to the project/namespace
     */
    gpuLimits?: string;
    /**
     * The minimum number of GPUs guaranteed to the project/namespace
     */
    gpuRequests?: string;
    /**
     * The maximum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in bytes) guaranteed to the project/namespace
     */
    memoryRequests?: string;
    /**
     * The maximum number of persistent volume claims that can exist in the project/namespace
     */
    persistentVolumeClaims?: string;
    /**
     * The maximum number of pods that can exist in the project/namespace in a non-terminal state(i.e., pods with a state of .status.phase in (Failed, Succeeded) equal to true)
     */
    pods?: string;
    /**
     * The maximum number of replication controllers that can exist in the project/namespace
     */
    replicationControllers?: string;
    /**
     * The maximum number of secrets that can exist in the project/namespace
     */
    secrets?: string;
    /**
     * The maximum number of services that can exist in the project/namespace
     */
    services?: string;
    /**
     * The maximum number of load balancers services that can exist in the project/namespace
     */
    servicesLoadBalancers?: string;
    /**
     * The maximum number of node port services that can exist in the project/namespace
     */
    servicesNodePorts?: string;
    /**
     * The minimum amount of storage (in gigabytes) guaranteed to the project/namespace
     */
    storageRequests?: string;
}

export interface GetProjectSpecDefaultClusterNamespaceQuota {
    /**
     * The maximum number of ConfigMaps that can exist in the project/namespace
     */
    configMaps?: string;
    /**
     * The maximum amount of CPU (in millicores) allocated to the project/namespace
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the project/namespace
     */
    cpuRequests?: string;
    /**
     * The maximum number of GPUs allocated to the project/namespace
     */
    gpuLimits?: string;
    /**
     * The minimum number of GPUs guaranteed to the project/namespace
     */
    gpuRequests?: string;
    /**
     * The maximum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in bytes) guaranteed to the project/namespace
     */
    memoryRequests?: string;
    /**
     * The maximum number of persistent volume claims that can exist in the project/namespace
     */
    persistentVolumeClaims?: string;
    /**
     * The maximum number of pods that can exist in the project/namespace in a non-terminal state(i.e., pods with a state of .status.phase in (Failed, Succeeded) equal to true)
     */
    pods?: string;
    /**
     * The maximum number of replication controllers that can exist in the project/namespace
     */
    replicationControllers?: string;
    /**
     * The maximum number of secrets that can exist in the project/namespace
     */
    secrets?: string;
    /**
     * The maximum number of services that can exist in the project/namespace
     */
    services?: string;
    /**
     * The maximum number of load balancers services that can exist in the project/namespace
     */
    servicesLoadBalancers?: string;
    /**
     * The maximum number of node port services that can exist in the project/namespace
     */
    servicesNodePorts?: string;
    /**
     * The minimum amount of storage (in gigabytes) guaranteed to the project/namespace
     */
    storageRequests?: string;
}

export interface GetProjectSpecDriftWebhook {
    enabled?: boolean;
}

export interface GetProjectTimeouts {
    read?: string;
}

export interface GetUserTimeouts {
    read?: string;
}

export interface GetWorkloadMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GetWorkloadMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GetWorkloadMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GetWorkloadMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetWorkloadMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GetWorkloadSpec {
    /**
     * workload artifact specification
     */
    artifact?: outputs.GetWorkloadSpecArtifact;
    /**
     * drift specification of the workload resource
     */
    drift?: outputs.GetWorkloadSpecDrift;
    /**
     * namespace of the workload resource
     */
    namespace?: string;
    /**
     * placement specification of the workload resource
     */
    placement?: outputs.GetWorkloadSpecPlacement;
    /**
     * version of the workload resource
     */
    version?: string;
}

export interface GetWorkloadSpecArtifact {
    artifact?: outputs.GetWorkloadSpecArtifactArtifact;
    options?: outputs.GetWorkloadSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.GetWorkloadSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.GetWorkloadSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.GetWorkloadSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.GetWorkloadSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.GetWorkloadSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.GetWorkloadSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.GetWorkloadSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.GetWorkloadSpecArtifactArtifactValuesRef;
}

export interface GetWorkloadSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.GetWorkloadSpecArtifactArtifactValuesRefValuesPath[];
}

export interface GetWorkloadSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.GetWorkloadSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.GetWorkloadSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface GetWorkloadSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface GetWorkloadSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface GetWorkloadSpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface GetWorkloadSpecPlacement {
    /**
     * environment details
     */
    environment?: outputs.GetWorkloadSpecPlacementEnvironment;
    /**
     * list of labels for placement
     */
    labels?: outputs.GetWorkloadSpecPlacementLabel[];
    /**
     * Kubernetes style label selector
     */
    selector?: string;
}

export interface GetWorkloadSpecPlacementEnvironment {
    /**
     * Name of the environment
     */
    name?: string;
}

export interface GetWorkloadSpecPlacementLabel {
    /**
     * Key of the placement label
     */
    key?: string;
    /**
     * Value of the placement label
     */
    value?: string;
}

export interface GetWorkloadTimeouts {
    read?: string;
}

export interface GkeClusterMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.GkeClusterMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.GkeClusterMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface GkeClusterMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GkeClusterMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface GkeClusterSpec {
    /**
     * The blueprint to be used for this cluster. Use this for GKE/EKSABM/MKS cluster type
     */
    blueprint?: outputs.GkeClusterSpecBlueprint;
    /**
     * The credentials to be used to interact with the cloud infrastructure
     */
    cloudCredentials?: string;
    /**
     * GKE cluster config
     */
    configs?: outputs.GkeClusterSpecConfig[];
    /**
     * The proxy to be used for this cluster. Use this for GKE/MKS cluster type
     */
    proxy?: outputs.GkeClusterSpecProxy;
    /**
     * Sharing spec to be used for sharing the cluster with projects
     */
    sharing?: outputs.GkeClusterSpecSharing;
    /**
     * The type of the cluster this spec corresponds to
     */
    type?: string;
}

export interface GkeClusterSpecBlueprint {
    name?: string;
    version?: string;
}

export interface GkeClusterSpecConfig {
    /**
     * Kubernetes version of ControlPlane
     */
    controlPlaneVersion?: string;
    /**
     * GKE cluster additional features configuration.
     */
    features?: outputs.GkeClusterSpecConfigFeatures;
    /**
     * GCP Project name.
     */
    gcpProject?: string;
    /**
     * GKE cluster location configuration.
     */
    location?: outputs.GkeClusterSpecConfigLocation;
    /**
     * GKE cluster Network configuration.
     */
    network?: outputs.GkeClusterSpecConfigNetwork;
    /**
     * GKE cluster node pool configuration.
     */
    nodePools?: outputs.GkeClusterSpecConfigNodePool[];
    /**
     * Commands will be executed every time Cluster nodes come up. Example: Node Creation, Node Restart.
     */
    preBootstrapCommands?: string[];
    /**
     * GKE cluster Network configuration.
     */
    security?: outputs.GkeClusterSpecConfigSecurity;
}

export interface GkeClusterSpecConfigFeatures {
    /**
     * List of components for cloud logging
     */
    cloudLoggingComponents?: string[];
    /**
     * List of components for cloud monitoring
     */
    cloudMonitoringComponents?: string[];
    /**
     * Application Manager is a GKE controller for managing the lifecycle of applications. It enables application delivery and updates following Kubernetes and GitOps best practices
     */
    enableApplicationManagerBeta?: boolean;
    /**
     * Backup for GKE allows you to back up and restore GKE workloads. There is no cost for enabling this feature, but you are charged for backups based on the size of the data and the number of pods you protect
     */
    enableBackupForGke?: boolean;
    /**
     * Logging collects logs emitted by your applications and by GKE infrastructure
     */
    enableCloudLogging?: boolean;
    /**
     * Monitoring collects metrics emitted by your applications and by GKE infrastructure
     */
    enableCloudMonitoring?: boolean;
    /**
     * Enable to automatically deploy and manage the Compute Engine Persistent Disk CSI Driver. This feature is an alternative to using the gcePersistentDisk in-tree volume plugin
     */
    enableComputeEnginePersistentDiskCsiDriver?: boolean;
    /**
     * Enable to automatically deploy and manage the Filestore CSI Driver
     */
    enableFilestoreCsiDriver?: boolean;
    /**
     * Image streaming allows your workloads to initialize without waiting for the entire image to download
     */
    enableImageStreaming?: boolean;
    /**
     * This option deploys managed collectors for Prometheus metrics within this cluster. These collectors must be configured using PodMonitoring resources. To enable Managed Service for Prometheus here, you'll need. Cluster version of 1.21.4-gke.300 or greater
     */
    enableManagedServicePrometheus?: boolean;
}

export interface GkeClusterSpecConfigLocation {
    config?: outputs.GkeClusterSpecConfigLocationConfig;
    /**
     * For Zonal cluster increase availability by selecting more than one zone. For Regional cluster By default, Kubernetes Engine runs nodes of a regional cluster across three zones within a region. Select this option if you want to manually specify the zones in which this cluster's nodes run. All zones must be within the same region.
     */
    defaultNodeLocations?: outputs.GkeClusterSpecConfigLocationDefaultNodeLocations;
    /**
     * GKE Cluster location can be either zonal or regional
     */
    type?: string;
}

export interface GkeClusterSpecConfigLocationConfig {
    /**
     * Regional location in which the cluster's control plane and nodes are located
     */
    region?: string;
    /**
     * Zone in the region where bootstrap VM is created for cluster provisioning
     */
    zone?: string;
}

export interface GkeClusterSpecConfigLocationDefaultNodeLocations {
    /**
     * Enable providing default node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Increase availability by providing more than one zone. The same number of nodes will be deployed to each zone in the list.
     */
    zones?: string[];
}

export interface GkeClusterSpecConfigNetwork {
    /**
     * NetworkAccess config for describing access configurations for the cluster's workload
     */
    access?: outputs.GkeClusterSpecConfigNetworkAccess;
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    controlPlaneAuthorizedNetwork?: outputs.GkeClusterSpecConfigNetworkControlPlaneAuthorizedNetwork;
    /**
     * Dataplane V2 is optimized for Kubernetes networking kwhich is implemented using eBPF. Possible values: ADVANCED_DATAPATH.
     */
    dataPlaneV2?: string;
    /**
     * Dataplane V2 metrics brings better insight into the traffic between your Kubernetes workloads. Understand how your services communicate, identify issues with the network health, verify Kubernetes policies and more.
     */
    enableDataPlaneV2Metrics?: boolean;
    /**
     * Dataplane V2 observability provides Managed Hubble CLI solution that lets you observe network flows between your Kubernetes workloads in real time.
     */
    enableDataPlaneV2Observability?: boolean;
    /**
     * This feature uses alias IP and provides a more secure integration with Google Cloud Platform services
     */
    enableVpcNativetraffic?: boolean;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * Name of the network that the cluster is in. It determines which other Compute Engine resource it is able to communicate with
     */
    name?: string;
    /**
     * The Kubernetes Network Policy API allows the cluster administrator to specify what pods are allowed to communicate with each other. Possible values: CALICO
     */
    networkPolicy?: string;
    /**
     * Configuration for NetworkPolicy. This only tracks whether the addon is enabled or not on the Master,it does not track whether network policy is enabled for the nodes.
     */
    networkPolicyConfig?: boolean;
    /**
     * All pods in the cluster are assigned an IP address from this range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    podAddressRange?: string;
    /**
     * Cluster pods are assigned an IP from the selected node subnet's secondary CIDR address range.
     */
    podSecondaryRangeName?: string;
    /**
     * Cluster services will be assigned an IP address from this IP address range. Enter a range (in CIDR notation) within a network range, a mask, or leave this field blank to use a default range.
     */
    serviceAddressRange?: string;
    /**
     * Cluster services are assigned an IP from the selected node subnetes secondary CIDR address range.
     */
    serviceSecondaryRangeName?: string;
    /**
     * Subnetwork to which the Kubernetes cluster will belong. When VPC native is enabled, the subnetwork must contain at least two secondary ranges which are not used by other Kubernetes clusters. Subnet is permanent.
     */
    subnetName?: string;
}

export interface GkeClusterSpecConfigNetworkAccess {
    config?: outputs.GkeClusterSpecConfigNetworkAccessConfig;
    /**
     * Choose the type of network you want to allow to access your cluster's workloads. private or public
     */
    type?: string;
}

export interface GkeClusterSpecConfigNetworkAccessConfig {
    /**
     * Control plane IP range is for the control plane VPC. The control plane range must not overlap with any subnet in your cluster's VPC. The control plane and your cluster use VPC peering to communicate privately
     */
    controlPlaneIpRange?: string;
    /**
     * To use Privately Used Public IPs (PUPI) ranges, the default source NAT used for IP masquerading needs to be disabled
     */
    disableSnat?: boolean;
    /**
     * Disabling this option locks down external access to the cluster control plane. There is still an external IP address used by Google for cluster management purposes, but the IP address is not accessible to anyone
     */
    enableAccessControlPlaneExternalIp?: boolean;
    /**
     * With control plane global access, you can access the control plane's private endpoint from any GCP region or on-premises environment no matter what the private cluster's region is
     */
    enableAccessControlPlaneGlobal?: boolean;
    /**
     * Use FirewallRule config to specify additional firewall rules. Only Private clusters are supported.By default, tcp:9443 and tcp:22281 are opened for private cluster.
     */
    firewallRules?: outputs.GkeClusterSpecConfigNetworkAccessConfigFirewallRule[];
}

export interface GkeClusterSpecConfigNetworkAccessConfigFirewallRule {
    action?: string;
    description?: string;
    destinationRanges?: string[];
    direction?: string;
    name?: string;
    network?: string;
    priority?: number;
    rules?: outputs.GkeClusterSpecConfigNetworkAccessConfigFirewallRuleRule[];
    sourceRanges?: string[];
    targetTags?: string[];
}

export interface GkeClusterSpecConfigNetworkAccessConfigFirewallRuleRule {
    ports?: string[];
    protocol?: string;
}

export interface GkeClusterSpecConfigNetworkControlPlaneAuthorizedNetwork {
    /**
     * Add control plane authorized networks to block untrusted non-GCP source IPs from accessing the Kubernetes control plane through HTTPS
     */
    authorizedNetworks?: outputs.GkeClusterSpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork[];
    /**
     * Enable Control Plane Authorized Network. Configure the Networks now or later.
     */
    enabled?: boolean;
}

export interface GkeClusterSpecConfigNetworkControlPlaneAuthorizedNetworkAuthorizedNetwork {
    /**
     * CIDR Example: 198.51.100.0/24
     */
    cidr?: string;
    /**
     * Name of the Authorized Network Example: Corporate Office
     */
    name?: string;
}

export interface GkeClusterSpecConfigNodePool {
    /**
     * Cluster autoscaler automatically creates or deletes nodes based on workload needs
     */
    autoScaling?: outputs.GkeClusterSpecConfigNodePoolAutoScaling;
    /**
     * Choose the machine configuration that will best fit the resource needs of your cluster
     */
    machineConfig?: outputs.GkeClusterSpecConfigNodePoolMachineConfig;
    /**
     * Node management configuration
     */
    management?: outputs.GkeClusterSpecConfigNodePoolManagement;
    /**
     * Node metadata settings will be used when new nodes are created using this node pool
     */
    metadata?: outputs.GkeClusterSpecConfigNodePoolMetadata;
    /**
     * Node pool names must start with a lowercase letter followed by up to 39 lowercase letters, numbers, or hyphens. They can't end with a hyphen. You cannot change the node pool's name once it's created
     */
    name?: string;
    /**
     * Node networking settings will be used when new nodes are created using this node pool
     */
    networking?: outputs.GkeClusterSpecConfigNodePoolNetworking;
    /**
     * Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    nodeLocations?: outputs.GkeClusterSpecConfigNodePoolNodeLocations;
    /**
     * Specify Node k8s version
     */
    nodeVersion?: string;
    /**
     * Node security settings will be used when new nodes are created using this node pool
     */
    security?: outputs.GkeClusterSpecConfigNodePoolSecurity;
    /**
     * Pod address range limits the maximum size of the cluster
     */
    size?: number;
    /**
     * Node pool upgrade options
     */
    upgradeSettings?: outputs.GkeClusterSpecConfigNodePoolUpgradeSettings;
}

export interface GkeClusterSpecConfigNodePoolAutoScaling {
    /**
     * Maximum number of nodes (per zone)
     */
    maxNodes?: number;
    /**
     * Minimum number of nodes (per zone)
     */
    minNodes?: number;
}

export interface GkeClusterSpecConfigNodePoolMachineConfig {
    /**
     * Add accelerators to the node pool
     */
    accelerators?: outputs.GkeClusterSpecConfigNodePoolMachineConfigAccelerator[];
    /**
     * Select Boot disk size. Boot disk size is permanent
     */
    bootDiskSize?: number;
    /**
     * Select Boot disk type. Storage space is less expensive for a standard persistent disk. An SSD persistent disk is better for random IOPS or for streaming throughput with low latency
     */
    bootDiskType?: string;
    /**
     * Choose which operating system image you want to run on each node of this cluster
     */
    imageType?: string;
    /**
     * Choose the machine type that will best fit the resource needs of your cluster
     */
    machineType?: string;
    /**
     * Zonal compute reservation to this node pool
     */
    reservationAffinity?: outputs.GkeClusterSpecConfigNodePoolMachineConfigReservationAffinity;
}

export interface GkeClusterSpecConfigNodePoolMachineConfigAccelerator {
    /**
     * GPU Sharing allows you to share a single GPU device with multipe containers
     */
    acceleratorSharing?: outputs.GkeClusterSpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing;
    /**
     * Number of GPUs
     */
    count?: number;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    gpuDriverInstallation?: outputs.GkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation;
    /**
     * Size of partitions to create on the GPU. Valid values are described in the guide - https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning
     */
    gpuPartitionSize?: string;
    /**
     * GPU Type
     */
    type?: string;
}

export interface GkeClusterSpecConfigNodePoolMachineConfigAcceleratorAcceleratorSharing {
    /**
     * The max number of clients that can share a physical GPU device
     */
    maxSharedClients?: number;
    /**
     * The strategy to use for sharing GPUs . Example: Time-Sharing
     */
    strategy?: string;
}

export interface GkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallation {
    config?: outputs.GkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig;
    /**
     * Choose how GPU drivers will be installed for GPU enabled VMs
     */
    type?: string;
}

export interface GkeClusterSpecConfigNodePoolMachineConfigAcceleratorGpuDriverInstallationConfig {
    /**
     * The version of the GPU driver to install
     */
    version?: string;
}

export interface GkeClusterSpecConfigNodePoolMachineConfigReservationAffinity {
    /**
     * Type of reservation consumption.
     */
    consumeReservationType?: string;
    /**
     * The name of the Reservation to be consumed. Only mandatory when consumeReservationType is set to specific
     */
    reservationName?: string;
}

export interface GkeClusterSpecConfigNodePoolManagement {
    /**
     * Whether the nodes will be automatically upgraded
     */
    autoUpgrade?: boolean;
}

export interface GkeClusterSpecConfigNodePoolMetadata {
    /**
     * Metadata to be stored in the instance
     */
    gceInstanceMetadatas?: outputs.GkeClusterSpecConfigNodePoolMetadataGceInstanceMetadata[];
    /**
     * Use Kubernetes labels to control how workloads are scheduled to your nodes. Labels are applied to all nodes in this node pool and cannot be changed once the cluster is created
     */
    kubernetesLabels?: outputs.GkeClusterSpecConfigNodePoolMetadataKubernetesLabel[];
    /**
     * A node taint lets you mark a node so that the scheduler avoids or prevents using it for certain Pods. Node taints can be used with tolerations to ensure that Pods aren't scheduled onto inappropriate nodes
     */
    nodeTaints?: outputs.GkeClusterSpecConfigNodePoolMetadataNodeTaint[];
}

export interface GkeClusterSpecConfigNodePoolMetadataGceInstanceMetadata {
    /**
     * Key for this metadata
     */
    key?: string;
    /**
     * Value for this metadata
     */
    value?: string;
}

export interface GkeClusterSpecConfigNodePoolMetadataKubernetesLabel {
    /**
     * Key for this kubernetes label
     */
    key?: string;
    /**
     * Value for this kubernetes lable
     */
    value?: string;
}

export interface GkeClusterSpecConfigNodePoolMetadataNodeTaint {
    /**
     * Available effects are NoSchedule, PreferNoSchedule, NoExecute
     */
    effect?: string;
    /**
     * Key for this Taint effect
     */
    key?: string;
    /**
     * Value for this Taint effect
     */
    value?: string;
}

export interface GkeClusterSpecConfigNodePoolNetworking {
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    maxPodsPerNode?: number;
    /**
     * This value is used to optimize the partitioning of cluster's IP address range to sub-ranges at node level
     */
    networkTags?: string[];
}

export interface GkeClusterSpecConfigNodePoolNodeLocations {
    /**
     * Enable providing node locations
     */
    enabled?: boolean;
    /**
     * List of zones. Additional node zones must be from the same region as the original zone. Kubernetes Engine allocates the same resource footprint for each zone. The Node pool setting overrides the defaults set in Cluster basics
     */
    zones?: string[];
}

export interface GkeClusterSpecConfigNodePoolSecurity {
    /**
     * Integrity monitoring lets you monitor and verify the runtime boot integrity of your shielded nodes using Cloud Monitoring
     */
    enableIntegrityMonitoring?: boolean;
    /**
     * Secure boot helps protect your nodes against boot-level and kernel-level malware and rootkits
     */
    enableSecureBoot?: boolean;
}

export interface GkeClusterSpecConfigNodePoolUpgradeSettings {
    config?: outputs.GkeClusterSpecConfigNodePoolUpgradeSettingsConfig;
    /**
     * Update strategy of the node pool. Possible values are SURGE and BLUE_GREEN
     */
    strategy?: string;
}

export interface GkeClusterSpecConfigNodePoolUpgradeSettingsConfig {
    /**
     * Number of blue nodes to drain in a batch.
     */
    batchNodeCount?: number;
    /**
     * Soak time after each batch gets drained.
     */
    batchSoakDuration?: string;
    /**
     * The maximum number of nodes that can be created beyond the current size of the node pool during the upgrade process.
     */
    maxSurge?: number;
    /**
     * The maximum number of nodes that can be simultaneously unavailable during the upgrade process.
     */
    maxUnavailable?: number;
    /**
     * Time needed after draining entire blue pool. After this period, blue pool will be cleaned up.
     */
    nodePoolSoakDuration?: string;
}

export interface GkeClusterSpecConfigSecurity {
    /**
     * Google Groups for RBAC allows you to grant roles to all members of a Google Workspace group
     */
    enableGoogleGroupsForRbac?: boolean;
    /**
     * Enable legacy authorization to support in-cluster permissions for existing clusters or workflows. Prevents full RBAC support
     */
    enableLegacyAuthorization?: boolean;
    /**
     * Workload Identity lets you connect securely to Google APIs from Kubernetes Engine workloads
     */
    enableWorkloadIdentity?: boolean;
    /**
     * Clients use this base64-encoded public certificate to authenticate to the cluster endpoint. Certificates don’t rotate automatically and are difficult to revoke
     */
    issueClientCertificate?: boolean;
    /**
     * Provide the security groups here
     */
    securityGroup?: string;
}

export interface GkeClusterSpecProxy {
    allowInsecureBootstrap?: boolean;
    bootstrapCa?: string;
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string;
    proxyAuth?: string;
}

export interface GkeClusterSpecSharing {
    enabled?: boolean;
    projects?: outputs.GkeClusterSpecSharingProject[];
}

export interface GkeClusterSpecSharingProject {
    name?: string;
}

export interface GkeClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface GroupassociationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ImportClusterTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface InfraProvisionerMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.InfraProvisionerMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.InfraProvisionerMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface InfraProvisionerMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface InfraProvisionerMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface InfraProvisionerSpec {
    config?: outputs.InfraProvisionerSpecConfig;
    /**
     * infrastructure provisioner git repository relative folder path
     */
    folderPath?: outputs.InfraProvisionerSpecFolderPath;
    /**
     * infrastructure provisioner git repository name
     */
    repository?: string;
    /**
     * infrastructure provisioner git repository branch or tag
     */
    revision?: string;
    /**
     * InfraProvisioner secrets
     */
    secret?: outputs.InfraProvisionerSpecSecret;
    /**
     * type of infrastructure provisioner
     */
    type?: string;
}

export interface InfraProvisionerSpecConfig {
    backendFilePath?: outputs.InfraProvisionerSpecConfigBackendFilePath;
    backendVars?: outputs.InfraProvisionerSpecConfigBackendVar[];
    /**
     * environment variables
     */
    envVars?: outputs.InfraProvisionerSpecConfigEnvVar[];
    inputVars?: outputs.InfraProvisionerSpecConfigInputVar[];
    /**
     * Pipeline secrets groups
     */
    secretGroups?: string[];
    tfVarsFilePath?: outputs.InfraProvisionerSpecConfigTfVarsFilePath;
    version?: string;
}

export interface InfraProvisionerSpecConfigBackendFilePath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.InfraProvisionerSpecConfigBackendFilePathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecConfigBackendFilePathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.InfraProvisionerSpecConfigBackendFilePathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecConfigBackendFilePathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface InfraProvisionerSpecConfigBackendVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface InfraProvisionerSpecConfigEnvVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface InfraProvisionerSpecConfigInputVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface InfraProvisionerSpecConfigTfVarsFilePath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.InfraProvisionerSpecConfigTfVarsFilePathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecConfigTfVarsFilePathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.InfraProvisionerSpecConfigTfVarsFilePathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecConfigTfVarsFilePathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface InfraProvisionerSpecFolderPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.InfraProvisionerSpecFolderPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecFolderPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.InfraProvisionerSpecFolderPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecFolderPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface InfraProvisionerSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.InfraProvisionerSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.InfraProvisionerSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface InfraProvisionerSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface InfraProvisionerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface MeshProfileMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.MeshProfileMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.MeshProfileMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface MeshProfileMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface MeshProfileMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface MeshProfileSpec {
    /**
     * Parameters for profile installation
     */
    installationParams?: outputs.MeshProfileSpecInstallationParams;
    /**
     * profile sharing configuration
     */
    sharing?: outputs.MeshProfileSpecSharing;
    /**
     * version of the profile
     */
    version?: string;
}

export interface MeshProfileSpecInstallationParams {
    /**
     * Certificate Management Type
     */
    certType?: string;
    /**
     * Enable Ingress
     */
    enableIngress?: boolean;
    /**
     * Enable Sidecar Injection Globally
     */
    enableNamespacesByDefault?: boolean;
    /**
     * mesh resource quota
     */
    resourceQuota?: outputs.MeshProfileSpecInstallationParamsResourceQuota;
}

export interface MeshProfileSpecInstallationParamsResourceQuota {
    /**
     * The maximum amount of CPU (in millicores) allocated to the service mesh control plane
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the service mesh control plane
     */
    cpuRequests?: string;
    /**
     * The maximum amount of memory (in MiB) allocated to the service mesh control plane
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in MiB) allocated to the service mesh control plane
     */
    memoryRequests?: string;
}

export interface MeshProfileSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.MeshProfileSpecSharingProject[];
}

export interface MeshProfileSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface MeshProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NamespaceMeshPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NamespaceMeshPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NamespaceMeshPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NamespaceMeshPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceMeshPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceMeshPolicySpec {
    /**
     * Group of namespace mesh rules
     */
    rules?: outputs.NamespaceMeshPolicySpecRule[];
    /**
     * namespace policy sharing configuration
     */
    sharing?: outputs.NamespaceMeshPolicySpecSharing;
    /**
     * version of the namespace policy
     */
    version?: string;
}

export interface NamespaceMeshPolicySpecRule {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface NamespaceMeshPolicySpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.NamespaceMeshPolicySpecSharingProject[];
}

export interface NamespaceMeshPolicySpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface NamespaceMeshPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NamespaceMeshRuleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NamespaceMeshRuleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NamespaceMeshRuleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NamespaceMeshRuleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceMeshRuleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceMeshRuleSpec {
    /**
     * namespace mesh rule artifact specification
     */
    artifact?: outputs.NamespaceMeshRuleSpecArtifact;
    /**
     * namespace mesh rule sharing configuration
     */
    sharing?: outputs.NamespaceMeshRuleSpecSharing;
    /**
     * version of the namespace mesh rule
     */
    version?: string;
}

export interface NamespaceMeshRuleSpecArtifact {
    artifact?: outputs.NamespaceMeshRuleSpecArtifactArtifact;
    options?: outputs.NamespaceMeshRuleSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.NamespaceMeshRuleSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.NamespaceMeshRuleSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.NamespaceMeshRuleSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.NamespaceMeshRuleSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesRef;
}

export interface NamespaceMeshRuleSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPath[];
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceMeshRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceMeshRuleSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface NamespaceMeshRuleSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.NamespaceMeshRuleSpecSharingProject[];
}

export interface NamespaceMeshRuleSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface NamespaceMeshRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NamespaceMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NamespaceMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NamespaceMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NamespaceMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceNetworkPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NamespaceNetworkPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NamespaceNetworkPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NamespaceNetworkPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceNetworkPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceNetworkPolicyRuleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NamespaceNetworkPolicyRuleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NamespaceNetworkPolicyRuleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NamespaceNetworkPolicyRuleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceNetworkPolicyRuleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NamespaceNetworkPolicyRuleSpec {
    /**
     * namespace network rule artifact specification
     */
    artifact?: outputs.NamespaceNetworkPolicyRuleSpecArtifact;
    /**
     * namespace policy rule sharing configuration
     */
    sharing?: outputs.NamespaceNetworkPolicyRuleSpecSharing;
    /**
     * version of the namespace policy rule
     */
    version?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifact {
    artifact?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifact;
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRef;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPath[];
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceNetworkPolicyRuleSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface NamespaceNetworkPolicyRuleSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.NamespaceNetworkPolicyRuleSpecSharingProject[];
}

export interface NamespaceNetworkPolicyRuleSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface NamespaceNetworkPolicyRuleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NamespaceNetworkPolicySpec {
    /**
     * Group of namespace policy rules
     */
    rules?: outputs.NamespaceNetworkPolicySpecRule[];
    /**
     * namespace policy sharing configuration
     */
    sharing?: outputs.NamespaceNetworkPolicySpecSharing;
    /**
     * version of the namespace policy
     */
    version?: string;
}

export interface NamespaceNetworkPolicySpecRule {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface NamespaceNetworkPolicySpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.NamespaceNetworkPolicySpecSharingProject[];
}

export interface NamespaceNetworkPolicySpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface NamespaceNetworkPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NamespaceSpec {
    artifact?: outputs.NamespaceSpecArtifact;
    /**
     * namespace drift
     */
    drift?: outputs.NamespaceSpecDrift;
    /**
     * namespace limit range
     */
    limitRange?: outputs.NamespaceSpecLimitRange;
    /**
     * namespace mesh policy details
     */
    namespaceMeshPolicyParams?: outputs.NamespaceSpecNamespaceMeshPolicyParams;
    /**
     * namespace network policy
     */
    networkPolicyParams?: outputs.NamespaceSpecNetworkPolicyParams;
    /**
     * namespace placement
     */
    placement?: outputs.NamespaceSpecPlacement;
    /**
     * namespace PSP
     */
    psp?: outputs.NamespaceSpecPsp;
    /**
     * namespace resource quoats
     */
    resourceQuotas?: outputs.NamespaceSpecResourceQuotas;
    /**
     * Identify if namespace is managed/unmanged
     */
    syncType?: outputs.NamespaceSpecSyncType;
}

export interface NamespaceSpecArtifact {
    /**
     * relative path to file in the git repository
     */
    path?: outputs.NamespaceSpecArtifactPath;
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
}

export interface NamespaceSpecArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.NamespaceSpecArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceSpecArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.NamespaceSpecArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface NamespaceSpecArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface NamespaceSpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface NamespaceSpecLimitRange {
    /**
     * limit range configuration for containers
     */
    container?: outputs.NamespaceSpecLimitRangeContainer;
    /**
     * limit range configuration for pods
     */
    pod?: outputs.NamespaceSpecLimitRangePod;
}

export interface NamespaceSpecLimitRangeContainer {
    /**
     * default resource quantity
     */
    default?: outputs.NamespaceSpecLimitRangeContainerDefault;
    /**
     * default request resource quantity
     */
    defaultRequest?: outputs.NamespaceSpecLimitRangeContainerDefaultRequest;
    /**
     * maximum resource quantity
     */
    max?: outputs.NamespaceSpecLimitRangeContainerMax;
    /**
     * minimum resource quantity
     */
    min?: outputs.NamespaceSpecLimitRangeContainerMin;
    /**
     * ratio of request to limit
     */
    ratio?: outputs.NamespaceSpecLimitRangeContainerRatio;
}

export interface NamespaceSpecLimitRangeContainerDefault {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangeContainerDefaultRequest {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangeContainerMax {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangeContainerMin {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangeContainerRatio {
    /**
     * ratio of cpu requests to limits
     */
    cpu?: number;
    /**
     * ratio of memory requests to limits
     */
    memory?: number;
}

export interface NamespaceSpecLimitRangePod {
    /**
     * default resource quantity
     */
    default?: outputs.NamespaceSpecLimitRangePodDefault;
    /**
     * default request resource quantity
     */
    defaultRequest?: outputs.NamespaceSpecLimitRangePodDefaultRequest;
    /**
     * maximum resource quantity
     */
    max?: outputs.NamespaceSpecLimitRangePodMax;
    /**
     * minimum resource quantity
     */
    min?: outputs.NamespaceSpecLimitRangePodMin;
    /**
     * ratio of request to limit
     */
    ratio?: outputs.NamespaceSpecLimitRangePodRatio;
}

export interface NamespaceSpecLimitRangePodDefault {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangePodDefaultRequest {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangePodMax {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangePodMin {
    /**
     * quantity of CPU in cores
     */
    cpu?: string;
    /**
     * quantity of memory in MB
     */
    memory?: string;
}

export interface NamespaceSpecLimitRangePodRatio {
    /**
     * ratio of cpu requests to limits
     */
    cpu?: number;
    /**
     * ratio of memory requests to limits
     */
    memory?: number;
}

export interface NamespaceSpecNamespaceMeshPolicyParams {
    /**
     * Service Mesh enabled flag
     */
    meshEnabled?: boolean;
    /**
     * name and version of namespace mesh policy
     */
    policies?: outputs.NamespaceSpecNamespaceMeshPolicyParamsPolicy[];
}

export interface NamespaceSpecNamespaceMeshPolicyParamsPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface NamespaceSpecNetworkPolicyParams {
    /**
     * Network policy enabled flag
     */
    networkPolicyEnabled?: boolean;
    /**
     * name and version of namespace network policy
     */
    policies?: outputs.NamespaceSpecNetworkPolicyParamsPolicy[];
}

export interface NamespaceSpecNetworkPolicyParamsPolicy {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface NamespaceSpecPlacement {
    /**
     * environment details
     */
    environment?: outputs.NamespaceSpecPlacementEnvironment;
    /**
     * list of labels for placement
     */
    labels?: outputs.NamespaceSpecPlacementLabel[];
    /**
     * Kubernetes style label selector
     */
    selector?: string;
}

export interface NamespaceSpecPlacementEnvironment {
    /**
     * Name of the environment
     */
    name?: string;
}

export interface NamespaceSpecPlacementLabel {
    /**
     * Key of the placement label
     */
    key?: string;
    /**
     * Value of the placement label
     */
    value?: string;
}

export interface NamespaceSpecPsp {
    /**
     * name of the PSP
     */
    name?: string;
}

export interface NamespaceSpecResourceQuotas {
    /**
     * The maximum number of ConfigMaps that can exist in the project/namespace
     */
    configMaps?: string;
    /**
     * The maximum amount of CPU (in millicores) allocated to the project/namespace
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the project/namespace
     */
    cpuRequests?: string;
    /**
     * The maximum amount of GPU (in millicores) allocated to the project/namespace
     */
    gpuLimits?: string;
    /**
     * The minimum amount of GPU (in millicores) guaranteed to the project/namespace
     */
    gpuRequests?: string;
    /**
     * The maximum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryRequests?: string;
    /**
     * The maximum number of persistent volume claims that can exist in the project/namespace
     */
    persistentVolumeClaims?: string;
    /**
     * The maximum number of pods that can exist in the project/namespace in a non-terminal state(i.e., pods with a state of .status.phase in (Failed, Succeeded) equal to true)
     */
    pods?: string;
    /**
     * The maximum number of replication controllers that can exist in the project/namespace
     */
    replicationControllers?: string;
    /**
     * The maximum number of secrets that can exist in the project/namespace
     */
    secrets?: string;
    /**
     * The maximum number of services that can exist in the project/namespace
     */
    services?: string;
    /**
     * The maximum number of load balancers services that can exist in the project/namespace
     */
    servicesLoadBalancers?: string;
    /**
     * The maximum number of node port services that can exist in the project/namespace
     */
    servicesNodePorts?: string;
    /**
     * The minimum amount of storage (in gigabytes) guaranteed to the project/namespace
     */
    storageRequests?: string;
}

export interface NamespaceSpecSyncType {
    managed?: string;
    unmanaged?: string;
}

export interface NamespaceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface NetworkPolicyProfileMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.NetworkPolicyProfileMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.NetworkPolicyProfileMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface NetworkPolicyProfileMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NetworkPolicyProfileMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface NetworkPolicyProfileSpec {
    /**
     * Parameters for profile installation
     */
    installationParams?: outputs.NetworkPolicyProfileSpecInstallationParams;
    /**
     * policy sharing configuration
     */
    sharing?: outputs.NetworkPolicyProfileSpecSharing;
    /**
     * version of the profile
     */
    version?: string;
}

export interface NetworkPolicyProfileSpecInstallationParams {
    /**
     * policyEnforcement mode
     */
    policyEnforcementMode?: string;
}

export interface NetworkPolicyProfileSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.NetworkPolicyProfileSpecSharingProject[];
}

export interface NetworkPolicyProfileSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface NetworkPolicyProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OpaConstraintMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.OpaConstraintMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.OpaConstraintMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface OpaConstraintMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaConstraintMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaConstraintSpec {
    /**
     * opa constraint  artifact specification
     */
    artifact?: outputs.OpaConstraintSpecArtifact;
    /**
     * publish status of the constraint
     */
    published?: boolean;
    /**
     * Name of the opa constraint template
     */
    templateName?: string;
    /**
     * version of the constraint
     */
    version?: string;
}

export interface OpaConstraintSpecArtifact {
    artifact?: outputs.OpaConstraintSpecArtifactArtifact;
    options?: outputs.OpaConstraintSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.OpaConstraintSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.OpaConstraintSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.OpaConstraintSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.OpaConstraintSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.OpaConstraintSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.OpaConstraintSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.OpaConstraintSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.OpaConstraintSpecArtifactArtifactValuesRef;
}

export interface OpaConstraintSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.OpaConstraintSpecArtifactArtifactValuesRefValuesPath[];
}

export interface OpaConstraintSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface OpaConstraintTemplateMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.OpaConstraintTemplateMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.OpaConstraintTemplateMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface OpaConstraintTemplateMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaConstraintTemplateMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaConstraintTemplateSpec {
    /**
     * constraint template artifact specification
     */
    artifact?: outputs.OpaConstraintTemplateSpecArtifact;
}

export interface OpaConstraintTemplateSpecArtifact {
    artifact?: outputs.OpaConstraintTemplateSpecArtifactArtifact;
    options?: outputs.OpaConstraintTemplateSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.OpaConstraintTemplateSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.OpaConstraintTemplateSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.OpaConstraintTemplateSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.OpaConstraintTemplateSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesRef;
}

export interface OpaConstraintTemplateSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPath[];
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface OpaConstraintTemplateSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface OpaConstraintTemplateSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface OpaConstraintTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OpaConstraintTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OpaInstallationProfileMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.OpaInstallationProfileMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.OpaInstallationProfileMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface OpaInstallationProfileMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaInstallationProfileMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaInstallationProfileSpec {
    /**
     * list of namespaces excluded from gatekeeper processing
     */
    excludedNamespaces?: outputs.OpaInstallationProfileSpecExcludedNamespace[];
    /**
     * Parameters for gatekeeper installation
     */
    installationParams?: outputs.OpaInstallationProfileSpecInstallationParams;
    /**
     * version of the OPA
     */
    opaVersion?: string;
    /**
     * profile sharing configuration
     */
    sharing?: outputs.OpaInstallationProfileSpecSharing;
    /**
     * list of k8s objects to be synced
     */
    syncObjects?: outputs.OpaInstallationProfileSpecSyncObject[];
    /**
     * version of the profile
     */
    version?: string;
}

export interface OpaInstallationProfileSpecExcludedNamespace {
    /**
     * List of namespaces to be excluded
     */
    namespaces?: outputs.OpaInstallationProfileSpecExcludedNamespaceNamespace[];
    /**
     * List of processes to be excluding namespace from
     */
    processes?: string[];
}

export interface OpaInstallationProfileSpecExcludedNamespaceNamespace {
    /**
     * name of the resource
     */
    name?: string;
}

export interface OpaInstallationProfileSpecInstallationParams {
    /**
     * audit chunk size
     */
    auditChunkSize?: number;
    /**
     * use cache for audit
     */
    auditFromCache?: boolean;
    /**
     * time(seconds) after which audit will happen
     */
    auditInterval?: number;
    /**
     * audit match kind
     */
    auditMatchKindOnly?: boolean;
    /**
     * number of violations to be listed in constraint status
     */
    constraintViolationsLimit?: number;
    /**
     * emit admission events
     */
    emitAdmissionEvents?: boolean;
    /**
     * emit audit events
     */
    emitAuditEvents?: boolean;
    /**
     * enable delete operation
     */
    enableDeleteOperations?: boolean;
    /**
     * enable mutation
     */
    experimentalEnableMutation?: boolean;
    /**
     * log denies
     */
    logDenies?: boolean;
}

export interface OpaInstallationProfileSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.OpaInstallationProfileSpecSharingProject[];
}

export interface OpaInstallationProfileSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface OpaInstallationProfileSpecSyncObject {
    /**
     * group of k8s object
     */
    group?: string;
    /**
     * kind of k8s object
     */
    kind?: string;
    /**
     * version of k8s object
     */
    version?: string;
}

export interface OpaInstallationProfileTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OpaPolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.OpaPolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.OpaPolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface OpaPolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaPolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OpaPolicySpec {
    /**
     * version of the policy
     */
    constraintLists?: outputs.OpaPolicySpecConstraintList[];
    /**
     * policy sharing configuration
     */
    sharing?: outputs.OpaPolicySpecSharing;
    /**
     * version of the policy
     */
    version?: string;
}

export interface OpaPolicySpecConstraintList {
    /**
     * Name of constraint object
     */
    name?: string;
    /**
     * version of constraint object
     */
    version?: string;
}

export interface OpaPolicySpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.OpaPolicySpecSharingProject[];
}

export interface OpaPolicySpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface OpaPolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface OrganizationalertconfigMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.OrganizationalertconfigMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.OrganizationalertconfigMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface OrganizationalertconfigMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OrganizationalertconfigMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface OrganizationalertconfigSpec {
    /**
     * List of the alerts to be subscribed
     */
    alerts?: outputs.OrganizationalertconfigSpecAlerts;
    /**
     * List of the emails to be subscribed
     */
    emails?: string[];
}

export interface OrganizationalertconfigSpecAlerts {
    agentHealth?: boolean;
    cluster?: boolean;
    node?: boolean;
    pod?: boolean;
    pvc?: boolean;
}

export interface OrganizationalertconfigTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface PipelineMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.PipelineMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.PipelineMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface PipelineMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface PipelineMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface PipelineSpec {
    /**
     * flag to indicate if pipeline is active
     */
    active?: boolean;
    /**
     * Pipeline secrets
     */
    secret?: outputs.PipelineSpecSecret;
    /**
     * pipeline sharing configuration
     */
    sharing?: outputs.PipelineSpecSharing;
    /**
     * stages in the pipeline
     */
    stages?: outputs.PipelineSpecStage[];
    /**
     * triggers for the pipeline
     */
    triggers?: outputs.PipelineSpecTrigger[];
    /**
     * pipeline scoped variables
     */
    variables?: outputs.PipelineSpecVariable[];
}

export interface PipelineSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.PipelineSpecSharingProject[];
}

export interface PipelineSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface PipelineSpecStage {
    config?: outputs.PipelineSpecStageConfig;
    /**
     * name of the pipeline stage
     */
    name?: string;
    /**
     * list of stages to be executed after this
     */
    nexts?: outputs.PipelineSpecStageNext[];
    /**
     * conditions to be evaluated before executing current stage
     */
    preConditions?: outputs.PipelineSpecStagePreCondition[];
    /**
     * type of pipeline stage
     */
    type?: string;
    /**
     * stage scoped variables
     */
    variables?: outputs.PipelineSpecStageVariable[];
}

export interface PipelineSpecStageConfig {
    action?: outputs.PipelineSpecStageConfigAction;
    /**
     * list of agents to be used for provisioning
     */
    agents?: outputs.PipelineSpecStageConfigAgent[];
    /**
     * list of approvers
     */
    approvers?: outputs.PipelineSpecStageConfigApprover[];
    /**
     * value to use as committer email when committing to destination git repository.
     */
    committerEmail?: string;
    /**
     * git repository for syncing system to git
     */
    destinationRepo?: outputs.PipelineSpecStageConfigDestinationRepo;
    /**
     * resources to exclude from syncing
     */
    excludedResources?: outputs.PipelineSpecStageConfigExcludedResource[];
    /**
     * flag to indicate if git to system sync should be enabled
     */
    gitToSystemSync?: boolean;
    /**
     * resources to include for syncing
     */
    includedResources?: outputs.PipelineSpecStageConfigIncludedResource[];
    /**
     * namespace workload template should be deployed in
     */
    namespace?: string;
    /**
     * overrides for workload template
     */
    overrides?: outputs.PipelineSpecStageConfigOverride[];
    /**
     * flag to indicate if working directory should be persisted
     */
    persistWorkingDirectory?: boolean;
    /**
     * placement for workload template
     */
    placement?: outputs.PipelineSpecStageConfigPlacement;
    /**
     * project name where workload template should be deployed in
     */
    projectName?: string;
    /**
     * name of the infrastructure provisioner
     */
    provisioner?: string;
    /**
     * branch or tag for the git repository used in infrastructure provisioner
     */
    revision?: string;
    /**
     * flag to indicate if source repository should be used as destination repository
     */
    sourceAsDestination?: boolean;
    /**
     * git repository for syncing from git to system
     */
    sourceRepo?: outputs.PipelineSpecStageConfigSourceRepo;
    /**
     * flat to indicate if system to git sync should be enabled
     */
    systemToGitSync?: boolean;
    /**
     * timeout for approval
     */
    timeout?: string;
    /**
     * type of infraprovisioner
     */
    type?: string;
    /**
     * flag to indicate weather to deploy workload using revision recieved from webhook trigger
     */
    useRevisionFromWebhookTriggerEvent?: boolean;
    /**
     * working directory for the provisioner
     */
    workingDirectory?: string;
    /**
     * name of the workload
     */
    workload?: string;
    /**
     * custom workload name
     */
    workloadName?: string;
    /**
     * name of workload template
     */
    workloadTemplate?: string;
}

export interface PipelineSpecStageConfigAction {
    action?: string;
    /**
     * backend file path
     */
    backendFilePath?: outputs.PipelineSpecStageConfigActionBackendFilePath;
    /**
     * backend variables
     */
    backendVars?: outputs.PipelineSpecStageConfigActionBackendVar[];
    /**
     * destroy
     */
    destroy?: boolean;
    /**
     * environment variables
     */
    envVars?: outputs.PipelineSpecStageConfigActionEnvVar[];
    /**
     * input variables for terrafrom
     */
    inputVars?: outputs.PipelineSpecStageConfigActionInputVar[];
    /**
     * refresh
     */
    refresh?: boolean;
    /**
     * Pipeline secrets groups
     */
    secretGroups?: string[];
    targets?: outputs.PipelineSpecStageConfigActionTarget[];
    tfVarsFilePath?: outputs.PipelineSpecStageConfigActionTfVarsFilePath;
    version?: string;
}

export interface PipelineSpecStageConfigActionBackendFilePath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecStageConfigActionBackendFilePathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigActionBackendFilePathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecStageConfigActionBackendFilePathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigActionBackendFilePathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecStageConfigActionBackendVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface PipelineSpecStageConfigActionEnvVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface PipelineSpecStageConfigActionInputVar {
    /**
     * variable key
     */
    key?: string;
    /**
     * variable type
     */
    type?: string;
    /**
     * variable value
     */
    value?: string;
}

export interface PipelineSpecStageConfigActionTarget {
    name?: string;
}

export interface PipelineSpecStageConfigActionTfVarsFilePath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecStageConfigActionTfVarsFilePathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigActionTfVarsFilePathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecStageConfigActionTfVarsFilePathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigActionTfVarsFilePathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecStageConfigAgent {
    /**
     * name of the agent
     */
    name?: string;
}

export interface PipelineSpecStageConfigApprover {
    /**
     * flag to specify if the user is a SSO User
     */
    ssoUser?: boolean;
    /**
     * user name of the approver
     */
    userName?: string;
}

export interface PipelineSpecStageConfigDestinationRepo {
    /**
     * relative folder path in the git repo
     */
    path?: outputs.PipelineSpecStageConfigDestinationRepoPath;
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
}

export interface PipelineSpecStageConfigDestinationRepoPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecStageConfigDestinationRepoPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigDestinationRepoPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecStageConfigDestinationRepoPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigDestinationRepoPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecStageConfigExcludedResource {
    /**
     * name of the system sync resource
     */
    name?: string;
}

export interface PipelineSpecStageConfigIncludedResource {
    /**
     * name of the system sync resource
     */
    name?: string;
}

export interface PipelineSpecStageConfigOverride {
    template?: outputs.PipelineSpecStageConfigOverrideTemplate;
    /**
     * type of override template
     */
    type?: string;
    /**
     * weight of the override, overrides are applied low to high weight
     */
    weight?: number;
}

export interface PipelineSpecStageConfigOverrideTemplate {
    /**
     * inline override template
     */
    inline?: string;
    /**
     * paths in the repository containing the override template
     */
    paths?: outputs.PipelineSpecStageConfigOverrideTemplatePath[];
    /**
     * git repository containing the override template
     */
    repository?: string;
    /**
     * branch or tag in the repository
     */
    revision?: string;
}

export interface PipelineSpecStageConfigOverrideTemplatePath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecStageConfigOverrideTemplatePathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigOverrideTemplatePathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecStageConfigOverrideTemplatePathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigOverrideTemplatePathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecStageConfigPlacement {
    /**
     * environment details
     */
    environment?: outputs.PipelineSpecStageConfigPlacementEnvironment;
    /**
     * list of labels for placement
     */
    labels?: outputs.PipelineSpecStageConfigPlacementLabel[];
    /**
     * Kubernetes style label selector
     */
    selector?: string;
}

export interface PipelineSpecStageConfigPlacementEnvironment {
    /**
     * Name of the environment
     */
    name?: string;
}

export interface PipelineSpecStageConfigPlacementLabel {
    /**
     * Key of the placement label
     */
    key?: string;
    /**
     * Value of the placement label
     */
    value?: string;
}

export interface PipelineSpecStageConfigSourceRepo {
    /**
     * relative folder path in the git repo
     */
    path?: outputs.PipelineSpecStageConfigSourceRepoPath;
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
}

export interface PipelineSpecStageConfigSourceRepoPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecStageConfigSourceRepoPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigSourceRepoPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecStageConfigSourceRepoPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecStageConfigSourceRepoPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecStageNext {
    /**
     * name of the next stage
     */
    name?: string;
    /**
     * weight of the next stage
     */
    weight?: number;
}

export interface PipelineSpecStagePreCondition {
    config?: outputs.PipelineSpecStagePreConditionConfig;
    /**
     * type of the stage precondiiton
     */
    type?: string;
}

export interface PipelineSpecStagePreConditionConfig {
}

export interface PipelineSpecStageVariable {
    /**
     * name of the variable
     */
    name?: string;
    /**
     * type of the variable
     */
    type?: string;
    /**
     * value of the variable
     */
    value?: string;
}

export interface PipelineSpecTrigger {
    config?: outputs.PipelineSpecTriggerConfig;
    /**
     * name of the trigger
     */
    name?: string;
    /**
     * trigger type
     */
    type?: string;
    /**
     * trigger scoped variables
     */
    variables?: outputs.PipelineSpecTriggerVariable[];
}

export interface PipelineSpecTriggerConfig {
    /**
     * cron expression for trigger
     */
    cronExpression?: string;
    repo?: outputs.PipelineSpecTriggerConfigRepo;
}

export interface PipelineSpecTriggerConfigRepo {
    /**
     * name of the chart in repo
     */
    chartName?: string;
    /**
     * version of the chart in repo
     */
    chartVersion?: string;
    /**
     * paths in the git repo to watch for changes
     */
    paths?: outputs.PipelineSpecTriggerConfigRepoPath[];
    /**
     * provider for the git repo
     */
    provider?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository to watch for changes
     */
    revision?: string;
}

export interface PipelineSpecTriggerConfigRepoPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.PipelineSpecTriggerConfigRepoPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecTriggerConfigRepoPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.PipelineSpecTriggerConfigRepoPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface PipelineSpecTriggerConfigRepoPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface PipelineSpecTriggerVariable {
    /**
     * name of the variable
     */
    name?: string;
    /**
     * type of the variable
     */
    type?: string;
    /**
     * value of the variable
     */
    value?: string;
}

export interface PipelineSpecVariable {
    /**
     * name of the variable
     */
    name?: string;
    /**
     * type of the variable
     */
    type?: string;
    /**
     * value of the variable
     */
    value?: string;
}

export interface PipelineStatus {
    /**
     * pipeline trigger status
     */
    triggers?: outputs.PipelineStatusTrigger[];
}

export interface PipelineStatusTrigger {
    /**
     * name of the trigger
     */
    name: string;
    /**
     * webhook secret
     */
    webhookSecret: string;
    /**
     * webhook url
     */
    webhookUrl: string;
}

export interface PipelineTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProjectMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ProjectMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ProjectMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ProjectMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ProjectMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ProjectSpec {
    /**
     * resource quota to be assigned to a cluster in a project
     */
    clusterResourceQuota?: outputs.ProjectSpecClusterResourceQuota;
    /**
     * flag to indicate if this is the default project in the organization
     */
    default?: boolean;
    /**
     * default resource quota to be assigned to a namespacein a project
     */
    defaultClusterNamespaceQuota?: outputs.ProjectSpecDefaultClusterNamespaceQuota;
    /**
     * webhook config details
     */
    driftWebhook?: outputs.ProjectSpecDriftWebhook;
    /**
     * namespaces excluded from sync
     */
    syncExcludedNamespaces?: string[];
}

export interface ProjectSpecClusterResourceQuota {
    /**
     * The maximum number of ConfigMaps that can exist in the project/namespace
     */
    configMaps?: string;
    /**
     * The maximum amount of CPU (in millicores) allocated to the project/namespace
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the project/namespace
     */
    cpuRequests?: string;
    /**
     * The maximum number of GPUs allocated to the project/namespace
     */
    gpuLimits?: string;
    /**
     * The minimum number of GPUs guaranteed to the project/namespace
     */
    gpuRequests?: string;
    /**
     * The maximum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in bytes) guaranteed to the project/namespace
     */
    memoryRequests?: string;
    /**
     * The maximum number of persistent volume claims that can exist in the project/namespace
     */
    persistentVolumeClaims?: string;
    /**
     * The maximum number of pods that can exist in the project/namespace in a non-terminal state(i.e., pods with a state of .status.phase in (Failed, Succeeded) equal to true)
     */
    pods?: string;
    /**
     * The maximum number of replication controllers that can exist in the project/namespace
     */
    replicationControllers?: string;
    /**
     * The maximum number of secrets that can exist in the project/namespace
     */
    secrets?: string;
    /**
     * The maximum number of services that can exist in the project/namespace
     */
    services?: string;
    /**
     * The maximum number of load balancers services that can exist in the project/namespace
     */
    servicesLoadBalancers?: string;
    /**
     * The maximum number of node port services that can exist in the project/namespace
     */
    servicesNodePorts?: string;
    /**
     * The minimum amount of storage (in gigabytes) guaranteed to the project/namespace
     */
    storageRequests?: string;
}

export interface ProjectSpecDefaultClusterNamespaceQuota {
    /**
     * The maximum number of ConfigMaps that can exist in the project/namespace
     */
    configMaps?: string;
    /**
     * The maximum amount of CPU (in millicores) allocated to the project/namespace
     */
    cpuLimits?: string;
    /**
     * The minimum amount of CPU (in millicores) guaranteed to the project/namespace
     */
    cpuRequests?: string;
    /**
     * The maximum number of GPUs allocated to the project/namespace
     */
    gpuLimits?: string;
    /**
     * The minimum number of GPUs guaranteed to the project/namespace
     */
    gpuRequests?: string;
    /**
     * The maximum amount of memory (in bytes) allocated to the project/namespace
     */
    memoryLimits?: string;
    /**
     * The minimum amount of memory (in bytes) guaranteed to the project/namespace
     */
    memoryRequests?: string;
    /**
     * The maximum number of persistent volume claims that can exist in the project/namespace
     */
    persistentVolumeClaims?: string;
    /**
     * The maximum number of pods that can exist in the project/namespace in a non-terminal state(i.e., pods with a state of .status.phase in (Failed, Succeeded) equal to true)
     */
    pods?: string;
    /**
     * The maximum number of replication controllers that can exist in the project/namespace
     */
    replicationControllers?: string;
    /**
     * The maximum number of secrets that can exist in the project/namespace
     */
    secrets?: string;
    /**
     * The maximum number of services that can exist in the project/namespace
     */
    services?: string;
    /**
     * The maximum number of load balancers services that can exist in the project/namespace
     */
    servicesLoadBalancers?: string;
    /**
     * The maximum number of node port services that can exist in the project/namespace
     */
    servicesNodePorts?: string;
    /**
     * The minimum amount of storage (in gigabytes) guaranteed to the project/namespace
     */
    storageRequests?: string;
}

export interface ProjectSpecDriftWebhook {
    enabled?: boolean;
}

export interface ProjectTagsAssociationMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ProjectTagsAssociationMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ProjectTagsAssociationMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ProjectTagsAssociationMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ProjectTagsAssociationMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ProjectTagsAssociationSpec {
    /**
     * Project tag associations
     */
    associations?: outputs.ProjectTagsAssociationSpecAssociation[];
}

export interface ProjectTagsAssociationSpecAssociation {
    /**
     * tag association key
     */
    tagKey?: string;
    /**
     * tag association type i.e. <Cost, K8s>
     */
    tagType?: string;
}

export interface ProjectTagsAssociationTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ProjectTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface RepositoriesMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.RepositoriesMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.RepositoriesMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface RepositoriesMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface RepositoriesMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface RepositoriesSpec {
    /**
     * repository agents
     */
    agents?: outputs.RepositoriesSpecAgent[];
    credentials?: outputs.RepositoriesSpecCredentials;
    /**
     * repository endpoint
     */
    endpoint?: string;
    /**
     * repository options
     */
    options?: outputs.RepositoriesSpecOptions;
    /**
     * repository secrets
     */
    secret?: outputs.RepositoriesSpecSecret;
    /**
     * repository sharing configuration
     */
    sharing?: outputs.RepositoriesSpecSharing;
    /**
     * repository type
     */
    type?: string;
}

export interface RepositoriesSpecAgent {
    /**
     * name of the agent
     */
    name?: string;
}

export interface RepositoriesSpecCredentials {
    password?: string;
    privateKey?: string;
    username?: string;
}

export interface RepositoriesSpecOptions {
    /**
     * ca certificate
     */
    caCert?: outputs.RepositoriesSpecOptionsCaCert;
    /**
     * enable git large file support
     */
    enableLfs?: boolean;
    /**
     * enable git submodules
     */
    enableSubmodules?: boolean;
    /**
     * insecure
     */
    insecure?: boolean;
    /**
     * max retries
     */
    maxRetires?: number;
    /**
     * repository provider
     */
    provider?: string;
}

export interface RepositoriesSpecOptionsCaCert {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.RepositoriesSpecOptionsCaCertOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface RepositoriesSpecOptionsCaCertOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.RepositoriesSpecOptionsCaCertOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface RepositoriesSpecOptionsCaCertOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface RepositoriesSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.RepositoriesSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface RepositoriesSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.RepositoriesSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface RepositoriesSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface RepositoriesSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.RepositoriesSpecSharingProject[];
}

export interface RepositoriesSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface RepositoriesTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ResourceTemplateMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ResourceTemplateMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ResourceTemplateMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ResourceTemplateMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ResourceTemplateMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ResourceTemplateSpec {
    /**
     * Reference to agents to process resource template
     */
    agents?: outputs.ResourceTemplateSpecAgent[];
    /**
     * Reference to artifact driver handling resource template execution
     */
    artifactDriver?: outputs.ResourceTemplateSpecArtifactDriver;
    /**
     * Reference to config context data associated with resource templates
     */
    contexts?: outputs.ResourceTemplateSpecContext[];
    /**
     * Lifecycle hooks for resource template
     */
    hooks?: outputs.ResourceTemplateSpecHooks;
    /**
     * Specify the resource template provider
     */
    provider?: string;
    /**
     * Provider specific options to be provided
     */
    providerOptions?: outputs.ResourceTemplateSpecProviderOptions;
    /**
     * Repository options to be provided
     */
    repositoryOptions?: outputs.ResourceTemplateSpecRepositoryOptions;
    /**
     * Resource Template secrets
     */
    secret?: outputs.ResourceTemplateSpecSecret;
    /**
     * Sharing resource template across projects
     */
    sharing?: outputs.ResourceTemplateSpecSharing;
    /**
     * Variables associated with resource template
     */
    variables?: outputs.ResourceTemplateSpecVariable[];
    /**
     * Version of the resource template
     */
    version?: string;
    /**
     * Represents the current state of template version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecArtifactDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecArtifactDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecArtifactDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecArtifactDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecArtifactDriverDataInput[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecArtifactDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecArtifactDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecArtifactDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecArtifactDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecArtifactDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecContext {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecContextData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecContextData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecContextDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecContextDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecContextDataVariable[];
}

export interface ResourceTemplateSpecContextDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecContextDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecContextDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecContextDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecContextDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecContextDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecContextDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecContextDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecContextDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecContextDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecContextDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecContextDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecContextDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecContextDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecContextDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooks {
    /**
     * Configure the on completion lifecycle hook
     */
    onCompletions?: outputs.ResourceTemplateSpecHooksOnCompletion[];
    /**
     * Configure the on failure lifecycle hook
     */
    onFailures?: outputs.ResourceTemplateSpecHooksOnFailure[];
    /**
     * Configure the on initialize lifecycle hook
     */
    onInits?: outputs.ResourceTemplateSpecHooksOnInit[];
    /**
     * Configure the on success lifecycle hook
     */
    onSuccesses?: outputs.ResourceTemplateSpecHooksOnSuccess[];
    /**
     * Configure the provider hooks
     */
    provider?: outputs.ResourceTemplateSpecHooksProvider;
}

export interface ResourceTemplateSpecHooksOnCompletion {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksOnCompletionAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksOnCompletionDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksOnCompletionOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksOnCompletionDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInput[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnCompletionDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsScript;
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksOnCompletionOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsNotification {
}

export interface ResourceTemplateSpecHooksOnCompletionOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnFailure {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksOnFailureAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksOnFailureDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksOnFailureOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksOnFailureDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInput[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnFailureDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksOnFailureOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksOnFailureOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksOnFailureOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksOnFailureOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksOnFailureOptionsScript;
}

export interface ResourceTemplateSpecHooksOnFailureOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksOnFailureOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksOnFailureOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksOnFailureOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnFailureOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksOnFailureOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksOnFailureOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksOnFailureOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksOnFailureOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnFailureOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnFailureOptionsNotification {
}

export interface ResourceTemplateSpecHooksOnFailureOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnInit {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksOnInitAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksOnInitDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksOnInitOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksOnInitDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInput[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnInitDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksOnInitOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksOnInitOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksOnInitOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksOnInitOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksOnInitOptionsScript;
}

export interface ResourceTemplateSpecHooksOnInitOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksOnInitOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksOnInitOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksOnInitOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnInitOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksOnInitOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksOnInitOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksOnInitOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksOnInitOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnInitOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnInitOptionsNotification {
}

export interface ResourceTemplateSpecHooksOnInitOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnSuccess {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksOnSuccessAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksOnSuccessDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksOnSuccessOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksOnSuccessDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInput[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksOnSuccessDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsScript;
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksOnSuccessOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsNotification {
}

export interface ResourceTemplateSpecHooksOnSuccessOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProvider {
    hcpTerraform?: outputs.ResourceTemplateSpecHooksProviderHcpTerraform;
    /**
     * OpenTofu provider hooks
     */
    openTofu?: outputs.ResourceTemplateSpecHooksProviderOpenTofu;
    /**
     * Pulumi provider hooks
     */
    pulumi?: outputs.ResourceTemplateSpecHooksProviderPulumi;
    terraform?: outputs.ResourceTemplateSpecHooksProviderTerraform;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraform {
    deploy?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeploy;
    destroy?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroy;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeploy {
    apply?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApply;
    init?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInit;
    output?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutput;
    plan?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlan;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApply {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployApplyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutput {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployOutputBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDeployPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroy {
    destroy?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroy;
    init?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInit;
    plan?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlan;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroy {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyDestroyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderHcpTerraformDestroyPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofu {
    /**
     * OpenTofu deploy lifecycle hook
     */
    deploy?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeploy;
    /**
     * OpenTofu destroy lifecycle hook
     */
    destroy?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroy;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeploy {
    /**
     * OpenTofu apply deploy lifecycle hook
     */
    apply?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApply;
    /**
     * OpenTofu initialize deploy lifecycle hook
     */
    init?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInit;
    /**
     * OpenTofu output deploy lifecycle hook
     */
    output?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutput;
    /**
     * OpenTofu plan deploy lifecycle hook
     */
    plan?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlan;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApply {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployApplyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutput {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployOutputBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDeployPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroy {
    /**
     * OpenTofu destroy lifecycle hook
     */
    destroy?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroy;
    /**
     * OpenTofu initialize destroy lifecycle hook
     */
    init?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInit;
    /**
     * OpenTofu plan destroy lifecycle hook
     */
    plan?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlan;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroy {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyDestroyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderOpenTofuDestroyPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumi {
    /**
     * Pulumi deploy lifecycle hook
     */
    deploy?: outputs.ResourceTemplateSpecHooksProviderPulumiDeploy;
    /**
     * Pulumi deploy lifecycle hook
     */
    destroy?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroy;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeploy {
    /**
     * Pulumi login deploy lifecycle hook
     */
    login?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLogin;
    /**
     * Pulumi output deploy lifecycle hook
     */
    output?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutput;
    /**
     * Pulumi preview deploy lifecycle hook
     */
    preview?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreview;
    /**
     * Pulumi up deploy lifecycle hook
     */
    up?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUp;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLogin {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployLoginBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutput {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployOutputBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreview {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployPreviewBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUp {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDeployUpBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroy {
    /**
     * Pulumi destroy lifecycle hook
     */
    destroy?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroy;
    /**
     * Pulumi login destroy lifecycle hook
     */
    login?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLogin;
    /**
     * Pulumi preview destroy lifecycle hook
     */
    preview?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreview;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroy {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyDestroyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLogin {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyLoginBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreview {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBefore[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderPulumiDestroyPreviewBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraform {
    deploy?: outputs.ResourceTemplateSpecHooksProviderTerraformDeploy;
    destroy?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroy;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeploy {
    apply?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApply;
    init?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInit;
    output?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutput;
    plan?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlan;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApply {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployApplyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutput {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployOutputBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDeployPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroy {
    destroy?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroy;
    init?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInit;
    plan?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlan;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroy {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyDestroyBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInit {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyInitBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlan {
    /**
     * Specify all the after lifecycle hook
     */
    afters?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfter[];
    /**
     * Specify all the before lifecycle hook
     */
    befores?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBefore[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfter {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanAfterOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBefore {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInput[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsScript;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalEmail {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsApprovalJira {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsNotification {
}

export interface ResourceTemplateSpecHooksProviderTerraformDestroyPlanBeforeOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecProviderOptions {
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecProviderOptionsDriver;
    hcpTerraform?: outputs.ResourceTemplateSpecProviderOptionsHcpTerraform;
    /**
     * Specify the opentofu specific options if any
     */
    openTofu?: outputs.ResourceTemplateSpecProviderOptionsOpenTofu;
    /**
     * Specify the pulumi specific options if any
     */
    pulumi?: outputs.ResourceTemplateSpecProviderOptionsPulumi;
    /**
     * Specify the system specific options if any
     */
    system?: outputs.ResourceTemplateSpecProviderOptionsSystem;
    terraform?: outputs.ResourceTemplateSpecProviderOptionsTerraform;
    /**
     * Specify the terrafrunt specific options if any
     */
    terragrunt?: outputs.ResourceTemplateSpecProviderOptionsTerragrunt;
    /**
     * Specify the workflow specific options if any
     */
    workflow?: outputs.ResourceTemplateSpecProviderOptionsWorkflow;
}

export interface ResourceTemplateSpecProviderOptionsDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecProviderOptionsDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInput[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecProviderOptionsDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsHcpTerraform {
    /**
     * Don't hold a state lock during the operation. This is dangerous if others might concurrently run commands against the same workspace.
     */
    lock?: outputs.ResourceTemplateSpecProviderOptionsHcpTerraformLock;
    /**
     * Duration to retry a state lock.
     */
    lockTimeoutSeconds?: number;
    /**
     * Directory containing plugin binaries. This overrides all default search paths for plugins, and prevents the automatic installation of plugins. This flag can be used multiple times
     */
    pluginDirs?: string[];
    /**
     * Skip checking for external changes to remote objects while creating the plan. This can potentially make planning faster, but at the expense of possibly planning against a stale record of the remote system state.
     */
    refresh?: outputs.ResourceTemplateSpecProviderOptionsHcpTerraformRefresh;
    /**
     * Limit the planning operation to only the given module, resource, or resource instance and all of its dependencies
     */
    targetResources?: string[];
    /**
     * Timeout in seconds
     */
    timeoutSeconds?: number;
    varFiles?: string[];
    /**
     * volumes to be mounted
     */
    volumes?: outputs.ResourceTemplateSpecProviderOptionsHcpTerraformVolume[];
}

export interface ResourceTemplateSpecProviderOptionsHcpTerraformLock {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsHcpTerraformRefresh {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsHcpTerraformVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and this resource template.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Mount path for volume
     */
    mountPath?: string;
    /**
     * PVC size in GB
     */
    pvcSizeGb?: string;
    /**
     * PVC storage class
     */
    pvcStorageClass?: string;
    /**
     * Use PVC for volume
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsHcpTerraformVolumeUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsHcpTerraformVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsOpenTofu {
    backendConfigs?: string[];
    /**
     * OpenTofu backend type
     */
    backendType?: string;
    /**
     * Don't hold a state lock during the operation. This is dangerous if others might concurrently run commands against the same workspace.
     */
    lock?: outputs.ResourceTemplateSpecProviderOptionsOpenTofuLock;
    /**
     * Duration to retry a state lock.
     */
    lockTimeoutSeconds?: number;
    /**
     * Directory containing plugin binaries. This overrides all default search paths for plugins, and prevents the automatic installation of plugins. This flag can be used multiple times
     */
    pluginDirs?: string[];
    /**
     * Skip checking for external changes to remote objects while creating the plan. This can potentially make planning faster, but at the expense of possibly planning against a stale record of the remote system state.
     */
    refresh?: outputs.ResourceTemplateSpecProviderOptionsOpenTofuRefresh;
    /**
     * Limit the planning operation to only the given module, resource, or resource instance and all of its dependencies
     */
    targetResources?: string[];
    /**
     * Timeout in seconds
     */
    timeoutSeconds?: number;
    varFiles?: string[];
    /**
     * OpenTofu version
     */
    version?: string;
    /**
     * volumes to be mounted
     */
    volumes?: outputs.ResourceTemplateSpecProviderOptionsOpenTofuVolume[];
}

export interface ResourceTemplateSpecProviderOptionsOpenTofuLock {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsOpenTofuRefresh {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsOpenTofuVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and this resource template.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Mount path for volume
     */
    mountPath?: string;
    /**
     * PVC size in GB
     */
    pvcSizeGb?: string;
    /**
     * PVC storage class
     */
    pvcStorageClass?: string;
    /**
     * Use PVC for volume
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsOpenTofuVolumeUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsOpenTofuVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsPulumi {
}

export interface ResourceTemplateSpecProviderOptionsSystem {
}

export interface ResourceTemplateSpecProviderOptionsTerraform {
    backendConfigs?: string[];
    backendType?: string;
    /**
     * Don't hold a state lock during the operation. This is dangerous if others might concurrently run commands against the same workspace.
     */
    lock?: outputs.ResourceTemplateSpecProviderOptionsTerraformLock;
    /**
     * Duration to retry a state lock.
     */
    lockTimeoutSeconds?: number;
    /**
     * Directory containing plugin binaries. This overrides all default search paths for plugins, and prevents the automatic installation of plugins. This flag can be used multiple times
     */
    pluginDirs?: string[];
    /**
     * Skip checking for external changes to remote objects while creating the plan. This can potentially make planning faster, but at the expense of possibly planning against a stale record of the remote system state.
     */
    refresh?: outputs.ResourceTemplateSpecProviderOptionsTerraformRefresh;
    /**
     * Limit the planning operation to only the given module, resource, or resource instance and all of its dependencies
     */
    targetResources?: string[];
    /**
     * Timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Use system state store, by default it is false
     */
    useSystemStateStore?: outputs.ResourceTemplateSpecProviderOptionsTerraformUseSystemStateStore;
    varFiles?: string[];
    version?: string;
    volumes?: outputs.ResourceTemplateSpecProviderOptionsTerraformVolume[];
    withTerraformCloud?: outputs.ResourceTemplateSpecProviderOptionsTerraformWithTerraformCloud;
}

export interface ResourceTemplateSpecProviderOptionsTerraformLock {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsTerraformRefresh {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsTerraformUseSystemStateStore {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsTerraformVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and this resource template.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Mount path for volume
     */
    mountPath?: string;
    /**
     * PVC size in GB
     */
    pvcSizeGb?: string;
    /**
     * PVC storage class
     */
    pvcStorageClass?: string;
    /**
     * Use PVC for volume
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsTerraformVolumeUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsTerraformVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsTerraformWithTerraformCloud {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsTerragrunt {
}

export interface ResourceTemplateSpecProviderOptionsWorkflow {
    /**
     * Configure the workflow tasks
     */
    tasks?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTask[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTask {
    /**
     * Specify the resource ref agents
     */
    agents?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskAgent[];
    /**
     * specify hook dependencies
     */
    dependsOns?: string[];
    /**
     * description of hook
     */
    description?: string;
    /**
     * Specify the driver responsible for execution
     */
    driver?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriver;
    /**
     * Hook are executed only once for all runs combined
     */
    executeOnce?: boolean;
    /**
     * name of the hook
     */
    name?: string;
    /**
     * Specify the on failure action
     */
    onFailure?: string;
    /**
     * Specify the hook options
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptions;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of hook
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskAgent {
    /**
     * name of the resource
     */
    name?: string;
    /**
     * version of the resource
     */
    version?: string;
    /**
     * state of the resource version
     */
    versionState?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriver {
    /**
     * Inline workflow handler definition
     */
    data?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverData;
    /**
     * Name of the workflow handler
     */
    name?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverData {
    /**
     * WorkflowHandler configuration
     */
    config?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfig;
    /**
     * Specify the input data
     */
    inputs?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInput[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfig {
    /**
     * Specify the container workflow handler config
     */
    container?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainer;
    /**
     * Specify the http workflow handler config
     */
    http?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigHttp;
    /**
     * Specify the max retry count
     */
    maxRetryCount?: number;
    /**
     * Specify the polling config
     */
    pollingConfig?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigPollingConfig;
    /**
     * Specify the success condition
     */
    successCondition?: string;
    /**
     * Specify the timeout in seconds
     */
    timeoutSeconds?: number;
    /**
     * Specify the type of workflow handler
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envVars?: {[key: string]: string};
    /**
     * Specify the file data
     */
    files?: {[key: string]: string};
    /**
     * Specify the container image for the driver
     */
    image?: string;
    /**
     * Specify the credentials for the registry to pull image from
     */
    imagePullCredentials?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerImagePullCredentials;
    /**
     * Specify the kube config options
     */
    kubeConfigOptions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeConfigOptions;
    /**
     * Specify the kube options
     */
    kubeOptions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptions;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the container driver volume options
     */
    volumeOptions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeOptions;
    /**
     * Configure the container volumes
     */
    volumes?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolume[];
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerImagePullCredentials {
    /**
     * Specify the registry password
     */
    password?: string;
    /**
     * Specify the container image registry
     */
    registry?: string;
    /**
     * Specify the registry username
     */
    username?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeConfigOptions {
    /**
     * Specify the kube config
     */
    kubeConfig?: string;
    /**
     * Specify if out of cluster
     */
    outOfCluster?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptions {
    /**
     * Specify the affinity
     */
    affinity?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinity;
    /**
     * Specify the labels
     */
    labels?: {[key: string]: string};
    /**
     * Specify the namespace
     */
    namespace?: string;
    /**
     * Specify the node selectors
     */
    nodeSelector?: {[key: string]: string};
    /**
     * Specify the resources
     */
    resources?: string[];
    /**
     * Specify the security context
     */
    securityContext?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContext;
    /**
     * Specify the service account name
     */
    serviceAccountName?: string;
    /**
     * Specify the tolerations
     */
    tolerations?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsToleration[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinity {
    nodeAffinity?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinity;
    podAffinity?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinity;
    podAntiAffinity?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecution?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    preference?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    nodeSelectorTerms?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerm {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression[];
    matchFields?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermMatchField {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinity {
    preferredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];
    requiredDuringSchedulingIgnoredDuringExecutions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    podAffinityTerm?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
    weight?: number;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    labelSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
    namespaceSelector?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
    namespaces?: string[];
    topologyKey?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    matchExpressions?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression[];
    matchLabels?: {[key: string]: string};
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContext {
    /**
     * Specify if privileged permissions
     */
    privileged?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContextPrivileged;
    /**
     * Specify if permission is read only root file system
     */
    readOnlyRootFileSystem?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContextPrivileged {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsSecurityContextReadOnlyRootFileSystem {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerKubeOptionsToleration {
    effect?: string;
    key?: string;
    operator?: string;
    tolerationSeconds?: number;
    value?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolume {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeOptions {
    /**
     * If enabled, contents of the volume will be backed up after the job completes and restored before the next job starts across multiple runs of the environment. Scope of backup and restore is limited to the environment and resource template where this driver is used.
     */
    enableBackupAndRestore?: boolean;
    /**
     * Specify the container mount path
     */
    mountPath?: string;
    /**
     * Specify the persistent volume claim size in GB
     */
    pvcSizeGb?: string;
    /**
     * Specify the persistent volume claim storage class
     */
    pvcStorageClass?: string;
    /**
     * Specify if the container needs to use persistent volume claims
     */
    usePvc?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeOptionsUsePvc;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeOptionsUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigContainerVolumeUsePvc {
    value?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigHttp {
    /**
     * Specify the request body
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the http endpoint
     */
    endpoint?: string;
    /**
     * Specify the http headers
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method
     */
    method?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataConfigPollingConfig {
    /**
     * Specify the repeat
     */
    repeat?: string;
    /**
     * Specify the until
     */
    until?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInput {
    /**
     * Context data of the config context
     */
    data?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputData;
    /**
     * Name of the config context
     */
    name?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputData {
    /**
     * Environment variables data
     */
    envs?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnv[];
    /**
     * File path information
     */
    files?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFile[];
    /**
     * Variables data for config context
     */
    variables?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariable[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnv {
    /**
     * Key of the environment variable to be set
     */
    key?: string;
    /**
     * Provide the environment variable options
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnvOptions;
    /**
     * Deprecated: use options.sensitive. Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
    /**
     * Value of the environment variable to be set
     */
    value?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnvOptions {
    description?: string;
    override?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnvOptionsOverride;
    /**
     * Determines whether the variable is required / mandatory
     */
    required?: boolean;
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataEnvOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFile {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFileOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFileOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFileOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataFileOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskDriverDataInputDataVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptions {
    /**
     * Specify the approval options
     */
    approval?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApproval;
    /**
     * Specify the container options
     */
    container?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsContainer;
    /**
     * Specify the http options
     */
    http?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsHttp;
    /**
     * Specify the notification options
     */
    notification?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsNotification;
    /**
     * Specify the shell script options
     */
    script?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsScript;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApproval {
    /**
     * Specify the options for email
     */
    email?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalEmail;
    /**
     * Specify the options for github pr approval
     */
    githubPullRequest?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalGithubPullRequest;
    /**
     * Specify the options for internal approval
     */
    internal?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalInternal;
    /**
     * Specify the options for jira approval
     */
    jira?: outputs.ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalJira;
    /**
     * Specify the approval options
     */
    type?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalEmail {
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalGithubPullRequest {
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalInternal {
    emails?: string[];
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsApprovalJira {
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsContainer {
    /**
     * Specify the set of arguments to be passed
     */
    arguments?: string[];
    /**
     * Specify the set of commands to be executed
     */
    commands?: string[];
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the container image to be used
     */
    image?: string;
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the success condition of the container
     */
    successCondition?: string;
    /**
     * Specify the working directory path
     */
    workingDirPath?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsHttp {
    /**
     * Specify the body of http request
     */
    body?: string;
    /**
     * Provide ca cert for the http request
     */
    caCert?: string;
    /**
     * Specify the endpoint to be invoked
     */
    endpoint?: string;
    /**
     * Specify the http headers in key,value pair
     */
    headers?: {[key: string]: string};
    /**
     * Provide skip TLS verify for the http request
     */
    insecure?: boolean;
    /**
     * Specify the http method to be used
     */
    method?: string;
    /**
     * Specify the success condition of the request
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsNotification {
}

export interface ResourceTemplateSpecProviderOptionsWorkflowTaskOptionsScript {
    /**
     * Specify the cpu limit in milli
     */
    cpuLimitMilli?: string;
    /**
     * Specify the environment variables to be set in key,value pair
     */
    envvars?: {[key: string]: string};
    /**
     * Specify the memory limit to be allocated in MB
     */
    memoryLimitMb?: string;
    /**
     * Specify the script to be executed
     */
    script?: string;
    /**
     * Specify the success condition of the script
     */
    successCondition?: string;
}

export interface ResourceTemplateSpecRepositoryOptions {
    /**
     * Specify the branch
     */
    branch?: string;
    /**
     * Specify the directory path
     */
    directoryPath?: string;
    /**
     * Specify the name of the repository
     */
    name?: string;
}

export interface ResourceTemplateSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ResourceTemplateSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ResourceTemplateSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ResourceTemplateSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.ResourceTemplateSpecSharingProject[];
}

export interface ResourceTemplateSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface ResourceTemplateSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.ResourceTemplateSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface ResourceTemplateSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.ResourceTemplateSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface ResourceTemplateSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface ResourceTemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecretGroupMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.SecretGroupMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.SecretGroupMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface SecretGroupMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretGroupMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretGroupSpec {
    /**
     * Secret Group secrets
     */
    secret?: outputs.SecretGroupSpecSecret;
    secrets?: outputs.SecretGroupSpecSecret[];
}

export interface SecretGroupSpecSecret {
    /**
     * File path where secret will be written
     */
    filePath?: string;
    /**
     * Secret
     */
    secret?: string;
}

export interface SecretGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecretProviderMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.SecretProviderMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.SecretProviderMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface SecretProviderMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretProviderMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretProviderSpec {
    /**
     * secret provider class artifact specification
     */
    artifact?: outputs.SecretProviderSpecArtifact;
    /**
     * secret provider class parameters
     */
    parameters?: {[key: string]: string};
    /**
     * Name of the secret provider class
     */
    provider?: string;
    secretObjects?: outputs.SecretProviderSpecSecretObject[];
    /**
     * secret provider class sharing configuration
     */
    sharing?: outputs.SecretProviderSpecSharing;
}

export interface SecretProviderSpecArtifact {
    artifact?: outputs.SecretProviderSpecArtifactArtifact;
    options?: outputs.SecretProviderSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.SecretProviderSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.SecretProviderSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.SecretProviderSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.SecretProviderSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.SecretProviderSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.SecretProviderSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.SecretProviderSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.SecretProviderSpecArtifactArtifactValuesRef;
}

export interface SecretProviderSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.SecretProviderSpecArtifactArtifactValuesRefValuesPath[];
}

export interface SecretProviderSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.SecretProviderSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.SecretProviderSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface SecretProviderSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface SecretProviderSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface SecretProviderSpecSecretObject {
    annotations?: {[key: string]: string};
    datas?: outputs.SecretProviderSpecSecretObjectData[];
    labels?: {[key: string]: string};
    secretName?: string;
    type?: string;
}

export interface SecretProviderSpecSecretObjectData {
    key?: string;
    objectName?: string;
}

export interface SecretProviderSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.SecretProviderSpecSharingProject[];
}

export interface SecretProviderSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface SecretProviderTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface SecretsealerMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.SecretsealerMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.SecretsealerMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface SecretsealerMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretsealerMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface SecretsealerSpec {
    /**
     * secret sealer sharing configuration
     */
    sharing?: outputs.SecretsealerSpecSharing;
    /**
     * secret sealer type
     */
    type?: string;
    /**
     * secret sealer sharing configuration
     */
    version?: string;
}

export interface SecretsealerSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.SecretsealerSpecSharingProject[];
}

export interface SecretsealerSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface SecretsealerTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface StaticResourceMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.StaticResourceMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.StaticResourceMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface StaticResourceMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface StaticResourceMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface StaticResourceSpec {
    /**
     * Resource secrets
     */
    secret?: outputs.StaticResourceSpecSecret;
    /**
     * Defines if this is shared with other projects
     */
    sharing?: outputs.StaticResourceSpecSharing;
    /**
     * Variables data for resource
     */
    variables?: outputs.StaticResourceSpecVariable[];
}

export interface StaticResourceSpecSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.StaticResourceSpecSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface StaticResourceSpecSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.StaticResourceSpecSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface StaticResourceSpecSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface StaticResourceSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.StaticResourceSpecSharingProject[];
}

export interface StaticResourceSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface StaticResourceSpecVariable {
    /**
     * Name of the variable
     */
    name?: string;
    /**
     * Provide the variable options
     */
    options?: outputs.StaticResourceSpecVariableOptions;
    /**
     * Value of the variable in the specified format
     */
    value?: string;
    /**
     * Specify the variable value type
     */
    valueType?: string;
}

export interface StaticResourceSpecVariableOptions {
    /**
     * Description of the variable
     */
    description?: string;
    /**
     * Determines whether the variable can be overridden
     */
    override?: outputs.StaticResourceSpecVariableOptionsOverride;
    /**
     * Specify whether this variable is required or optional, by default it is optional
     */
    required?: boolean;
    /**
     * Determines whether the value is sensitive or not, accordingly applies encryption on it
     */
    sensitive?: boolean;
}

export interface StaticResourceSpecVariableOptionsOverride {
    /**
     * If the override type is restricted, values it is restricted to
     */
    restrictedValues?: string[];
    /**
     * Specify the type of ovverride this variable supports
     */
    type?: string;
}

export interface StaticResourceTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface TagGroupMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.TagGroupMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.TagGroupMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface TagGroupMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface TagGroupMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface TagGroupSpec {
    /**
     * tag config specification
     */
    tags?: outputs.TagGroupSpecTag[];
}

export interface TagGroupSpecTag {
    /**
     * tag key
     */
    key?: string;
    /**
     * tag value
     */
    value?: string;
}

export interface TagGroupTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface UserTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface WorkloadCdOperatorMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.WorkloadCdOperatorMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.WorkloadCdOperatorMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface WorkloadCdOperatorMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadCdOperatorMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadCdOperatorSpec {
    credentials?: outputs.WorkloadCdOperatorSpecCredentials;
    /**
     * repository allow insecure connection
     */
    insecure?: boolean;
    /**
     * repository branch
     */
    repoBranch?: string;
    /**
     * repository local path
     */
    repoLocalPath?: string;
    /**
     * repository type
     */
    repoType?: string;
    /**
     * repository repo_url
     */
    repoUrl: string;
    workloads?: outputs.WorkloadCdOperatorSpecWorkload[];
}

export interface WorkloadCdOperatorSpecCredentials {
    password?: string;
    privateKey?: string;
    token?: string;
    username: string;
}

export interface WorkloadCdOperatorSpecWorkload {
    /**
     * repository local path
     */
    basePath?: string;
    /**
     * rafay catalog name to source chart
     */
    chartCatalogName?: string;
    /**
     * rafay git repo branch to source chart
     */
    chartGitRepoBranch?: string;
    /**
     * rafay git repo name to source chart
     */
    chartGitRepoName?: string;
    /**
     * rafay git repo path
     */
    chartGitRepoPath?: string;
    /**
     * rafay helm repo name to source chart
     */
    chartHelmRepoName?: string;
    /**
     * cluster names ',' separated
     */
    clusterNames?: string;
    /**
     * workload delete action
     */
    deleteAction?: string;
    /**
     * helm chart name
     */
    helmChartName: string;
    /**
     * helm chart version
     */
    helmChartVersion: string;
    helmOptions?: outputs.WorkloadCdOperatorSpecWorkloadHelmOptions;
    /**
     * include values from base path
     */
    includeBaseValue?: boolean;
    /**
     * workload name
     */
    name?: string;
    /**
     * project/namespace/workload name path match pattern
     */
    pathMatchPattern: string;
    /**
     * placement labels of the cluster
     */
    placementLabels?: {[key: string]: string};
}

export interface WorkloadCdOperatorSpecWorkloadHelmOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface WorkloadCdOperatorTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface WorkloadCdOperatorWorkloadDecommission {
    /**
     * Namespace of the resource
     */
    namespace: string;
    /**
     * Project of the resource
     */
    project: string;
    /**
     * Workload Name of the resource
     */
    workloadName: string;
}

export interface WorkloadCdOperatorWorkloadStatus {
    /**
     * deployed clusters
     */
    clusters: string;
    /**
     * Condition Status
     */
    conditionStatus: number;
    /**
     * Status message
     */
    conditionType: string;
    /**
     * Namespace of the resource
     */
    namespace: string;
    /**
     * Project of the resource
     */
    project: string;
    /**
     * Status message
     */
    reason: string;
    /**
     * repo path of the Workload resource
     */
    repoFolder: string;
    /**
     * Workload Name of the resource
     */
    workloadName: string;
    /**
     * Workload Name of the resource
     */
    workloadVersion: string;
}

export interface WorkloadCdOperatorWorkloadUpsert {
    /**
     * Namespace of the resource
     */
    namespace: string;
    /**
     * Project of the resource
     */
    project: string;
    /**
     * Workload Name of the resource
     */
    workloadName: string;
}

export interface WorkloadMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.WorkloadMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.WorkloadMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface WorkloadMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadSpec {
    /**
     * workload artifact specification
     */
    artifact?: outputs.WorkloadSpecArtifact;
    /**
     * drift specification of the workload resource
     */
    drift?: outputs.WorkloadSpecDrift;
    /**
     * namespace of the workload resource
     */
    namespace?: string;
    /**
     * placement specification of the workload resource
     */
    placement?: outputs.WorkloadSpecPlacement;
    /**
     * version of the workload resource
     */
    version?: string;
}

export interface WorkloadSpecArtifact {
    artifact?: outputs.WorkloadSpecArtifactArtifact;
    options?: outputs.WorkloadSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.WorkloadSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.WorkloadSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.WorkloadSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.WorkloadSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.WorkloadSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.WorkloadSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.WorkloadSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.WorkloadSpecArtifactArtifactValuesRef;
}

export interface WorkloadSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.WorkloadSpecArtifactArtifactValuesRefValuesPath[];
}

export interface WorkloadSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface WorkloadSpecDrift {
    /**
     * flag to specify if sharing is enabled for resource
     */
    action?: string;
    /**
     * flag to specify if drift reconcillation is enabled for resource
     */
    enabled?: boolean;
}

export interface WorkloadSpecPlacement {
    /**
     * environment details
     */
    environment?: outputs.WorkloadSpecPlacementEnvironment;
    /**
     * list of labels for placement
     */
    labels?: outputs.WorkloadSpecPlacementLabel[];
    /**
     * Kubernetes style label selector
     */
    selector?: string;
}

export interface WorkloadSpecPlacementEnvironment {
    /**
     * Name of the environment
     */
    name?: string;
}

export interface WorkloadSpecPlacementLabel {
    /**
     * Key of the placement label
     */
    key?: string;
    /**
     * Value of the placement label
     */
    value?: string;
}

export interface WorkloadTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface WorkloadtemplateMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.WorkloadtemplateMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.WorkloadtemplateMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface WorkloadtemplateMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadtemplateMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface WorkloadtemplateSpec {
    /**
     * workload template artifact specification
     */
    artifact?: outputs.WorkloadtemplateSpecArtifact;
    /**
     * workload template sharing configuration
     */
    sharing?: outputs.WorkloadtemplateSpecSharing;
}

export interface WorkloadtemplateSpecArtifact {
    artifact?: outputs.WorkloadtemplateSpecArtifactArtifact;
    options?: outputs.WorkloadtemplateSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.WorkloadtemplateSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.WorkloadtemplateSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.WorkloadtemplateSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.WorkloadtemplateSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.WorkloadtemplateSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.WorkloadtemplateSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.WorkloadtemplateSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.WorkloadtemplateSpecArtifactArtifactValuesRef;
}

export interface WorkloadtemplateSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.WorkloadtemplateSpecArtifactArtifactValuesRefValuesPath[];
}

export interface WorkloadtemplateSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.WorkloadtemplateSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.WorkloadtemplateSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface WorkloadtemplateSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface WorkloadtemplateSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface WorkloadtemplateSpecSharing {
    /**
     * flag to specify if sharing is enabled for resource
     */
    enabled?: boolean;
    /**
     * list of projects this resource is shared to
     */
    projects?: outputs.WorkloadtemplateSpecSharingProject[];
}

export interface WorkloadtemplateSpecSharingProject {
    /**
     * name of the project
     */
    name?: string;
}

export interface WorkloadtemplateTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ZtkapolicyMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ZtkapolicyMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ZtkapolicyMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ZtkapolicyMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ZtkapolicyMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ZtkapolicySpec {
    /**
     * version of the ztka policy
     */
    version?: string;
    /**
     * list of ztka rules associated with policy
     */
    ztkaRuleLists?: outputs.ZtkapolicySpecZtkaRuleList[];
}

export interface ZtkapolicySpecZtkaRuleList {
    /**
     * Name of ztka
     */
    name?: string;
    /**
     * version of ztka rule
     */
    version?: string;
}

export interface ZtkapolicyTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

export interface ZtkaruleMetadata {
    /**
     * annotations of the resource
     */
    annotations?: {[key: string]: string};
    /**
     * User who created this resource
     */
    createdBy?: outputs.ZtkaruleMetadataCreatedBy;
    /**
     * description of the resource
     */
    description?: string;
    /**
     * Display Name of the resource
     */
    displayName?: string;
    /**
     * labels of the resource
     */
    labels?: {[key: string]: string};
    /**
     * User who last modified this resource
     */
    modifiedBy?: outputs.ZtkaruleMetadataModifiedBy;
    /**
     * name of the resource
     */
    name?: string;
    /**
     * Project of the resource
     */
    project?: string;
}

export interface ZtkaruleMetadataCreatedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ZtkaruleMetadataModifiedBy {
    /**
     * Id of the Person
     */
    id?: string;
    /**
     * Whether person is logged in using sso
     */
    isSsoUser?: boolean;
    /**
     * Username fo the Person
     */
    username?: string;
}

export interface ZtkaruleSpec {
    /**
     * ztka rule  artifact specification
     */
    artifact?: outputs.ZtkaruleSpecArtifact;
    /**
     * Cluster Selector to specify clusters in which rules to apply
     */
    clusterSelector?: outputs.ZtkaruleSpecClusterSelector;
    /**
     * Project Selector to specify projects to which rules to apply
     */
    projectSelector?: outputs.ZtkaruleSpecProjectSelector;
    /**
     * publish status of the ztka rule
     */
    published?: boolean;
    /**
     * version of the ztka rule
     */
    version?: string;
}

export interface ZtkaruleSpecArtifact {
    artifact?: outputs.ZtkaruleSpecArtifactArtifact;
    options?: outputs.ZtkaruleSpecArtifactOptions;
    /**
     * type of the artifact
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifact {
    /**
     * name of the helm catalog
     */
    catalog?: string;
    /**
     * name of the chart
     */
    chartName?: string;
    /**
     * relative path to chart file in the git repository
     */
    chartPath?: outputs.ZtkaruleSpecArtifactArtifactChartPath;
    /**
     * version of the chart
     */
    chartVersion?: string;
    /**
     * relative paths to alert manager configmap file
     */
    configmap?: outputs.ZtkaruleSpecArtifactArtifactConfigmap;
    /**
     * relative paths to alert manager configuration file
     */
    configuration?: outputs.ZtkaruleSpecArtifactArtifactConfiguration;
    /**
     * relative paths to file in the git repository
     */
    paths?: outputs.ZtkaruleSpecArtifactArtifactPath[];
    /**
     * project name of the repository
     */
    project?: string;
    /**
     * name of the helm repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative paths to alert manager secret file
     */
    secret?: outputs.ZtkaruleSpecArtifactArtifactSecret;
    /**
     * relative paths to alert manager statefulset file
     */
    statefulset?: outputs.ZtkaruleSpecArtifactArtifactStatefulset;
    /**
     * relative paths to values files
     */
    valuesPaths?: outputs.ZtkaruleSpecArtifactArtifactValuesPath[];
    /**
     * Override relative paths to values files
     */
    valuesRef?: outputs.ZtkaruleSpecArtifactArtifactValuesRef;
}

export interface ZtkaruleSpecArtifactArtifactChartPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactChartPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactChartPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactChartPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactChartPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactConfigmap {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactConfigmapOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactConfigmapOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactConfigmapOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactConfigmapOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactConfiguration {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactConfigurationOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactConfigurationOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactConfigurationOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactConfigurationOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactSecret {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactSecretOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactSecretOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactSecretOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactSecretOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactStatefulset {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactStatefulsetOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactStatefulsetOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactStatefulsetOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactStatefulsetOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactArtifactValuesRef {
    /**
     * name of the git repository
     */
    repository?: string;
    /**
     * branch or tag in the git repository
     */
    revision?: string;
    /**
     * relative path to value file in the git repository
     */
    valuesPaths?: outputs.ZtkaruleSpecArtifactArtifactValuesRefValuesPath[];
}

export interface ZtkaruleSpecArtifactArtifactValuesRefValuesPath {
    /**
     * data is the base64 encoded contents of the file
     */
    data?: string;
    /**
     * specify mount path of the file
     */
    mountPath?: string;
    /**
     * Name or relative path of a artifact
     */
    name?: string;
    /**
     * specify options for the file
     */
    options?: outputs.ZtkaruleSpecArtifactArtifactValuesRefValuesPathOptions;
    /**
     * Deprected: use options.sensitive. data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactValuesRefValuesPathOptions {
    /**
     * Description of the file
     */
    description?: string;
    /**
     * Override options for file
     */
    override?: outputs.ZtkaruleSpecArtifactArtifactValuesRefValuesPathOptionsOverride;
    /**
     * Determines whether the file is required / mandatory
     */
    required?: boolean;
    /**
     * data is encrypted  if sensitive is set to true
     */
    sensitive?: boolean;
}

export interface ZtkaruleSpecArtifactArtifactValuesRefValuesPathOptionsOverride {
    /**
     * Specify the type of override this file supports
     */
    type?: string;
}

export interface ZtkaruleSpecArtifactOptions {
    /**
     * deploy Helm artifact with atomic flag
     */
    atomic?: boolean;
    /**
     * cleanup deployed resources when chart fails to deploy
     */
    cleanUpOnFail?: boolean;
    /**
     * custom description for the release
     */
    description?: string;
    /**
     * disable OpenAPI validation while deploying the YAML
     */
    disableOpenApiValidation?: boolean;
    /**
     * deploy YAML artifact with force flag
     */
    force?: boolean;
    /**
     * keep release history after uninstalling
     */
    keepHistory?: boolean;
    /**
     * limit Helm artifact history
     */
    maxHistory?: number;
    /**
     * deploy Helm artifact without hooks
     */
    noHooks?: boolean;
    /**
     * render sub chart notes
     */
    renderSubChartNotes?: boolean;
    /**
     * reset existing helm values
     */
    resetValues?: boolean;
    /**
     * reuse existing values
     */
    reuseValues?: boolean;
    /**
     * pass custom helm values as key=value
     */
    setStrings?: string[];
    /**
     * skip deploying crds
     */
    skipCrd?: boolean;
    /**
     * timeout for waiting for the resources to become ready
     */
    timeout?: string;
    /**
     * deploy Helm artifact with wait flag
     */
    wait?: boolean;
    /**
     * deploy Helm artifact with --wait-for-jobs flag
     */
    waitForJobs?: boolean;
    /**
     * uninstall Helm artifact with --wait flag
     */
    waitForUninstall?: boolean;
}

export interface ZtkaruleSpecClusterSelector {
    matchLabels?: {[key: string]: string};
    matchNames?: string[];
    selectAll?: boolean;
}

export interface ZtkaruleSpecProjectSelector {
    matchNames?: string[];
    selectAll?: boolean;
}

export interface ZtkaruleTimeouts {
    create?: string;
    delete?: string;
    update?: string;
}

