// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CatalogEntriesEntries {
    /**
     * Optional aliases that can be used to reference this entry
     */
    aliases: string[];
    attributeValues: {[key: string]: outputs.CatalogEntriesEntriesAttributeValues};
    /**
     * ID of this catalog entry
     */
    id: string;
    /**
     * Name is the human readable name of this entry
     */
    name: string;
    /**
     * When catalog type is ranked, this is used to help order things
     */
    rank: number;
}

export interface CatalogEntriesEntriesAttributeValues {
    /**
     * The value of this element of the array, in a format suitable for this attribute type.
     */
    arrayValues?: string[];
    /**
     * The value of this attribute, in a format suitable for this attribute type.
     */
    value?: string;
}

export interface CatalogEntryAttributeValue {
    /**
     * The value of this element of the array, in a format suitable for this attribute type.
     */
    arrayValues?: string[];
    /**
     * The ID of this attribute, usually loaded from the incident.CatalogTypeAttribute resource.
     */
    attribute: string;
    /**
     * The value of this attribute, in a format suitable for this attribute type.
     */
    value?: string;
}

export interface EscalationPathPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElse;
    level?: outputs.EscalationPathPathLevel;
    repeat?: outputs.EscalationPathPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseThenPath[];
}

export interface EscalationPathPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseElsePathIfElse;
    level?: outputs.EscalationPathPathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseElsePathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseElsePathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseElsePathIfElseThenPath[];
}

export interface EscalationPathPathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseElsePathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseElsePathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseElsePathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElse;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPath[];
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElse;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPath[];
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseThenPathIfElse;
    level?: outputs.EscalationPathPathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseThenPathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseThenPathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseThenPathIfElseThenPath[];
}

export interface EscalationPathPathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseThenPathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseThenPathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseThenPathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElse;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPath[];
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    ifElse?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElse;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseCondition[];
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePath[];
    /**
     * Then path nodes
     */
    thenPaths: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPath[];
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingValue;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id: string;
    level?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevel;
    repeat?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathRepeat;
    /**
     * The type of this node: level or branch
     */
    type: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathIfElseThenPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathIfElseThenPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathIfElseThenPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathIfElseThenPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathPathLevel {
    roundRobinConfig?: outputs.EscalationPathPathLevelRoundRobinConfig;
    /**
     * The targets for this level
     */
    targets: outputs.EscalationPathPathLevelTarget[];
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: string;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: number;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: string;
}

export interface EscalationPathPathLevelRoundRobinConfig {
    enabled: boolean;
    rotateAfterSeconds?: number;
}

export interface EscalationPathPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: string;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode: string;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: string;
    /**
     * The urgency of this escalation path target
     */
    urgency: string;
}

export interface EscalationPathPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: number;
    /**
     * Which node ID we begin repeating from
     */
    toNode: string;
}

export interface EscalationPathWorkingHour {
    /**
     * The unique identifier for this set of working intervals
     */
    id: string;
    /**
     * A human readable label for this set of working intervals
     */
    name: string;
    /**
     * How to interpret all the intervals
     */
    timezone: string;
    weekdayIntervals: outputs.EscalationPathWorkingHourWeekdayInterval[];
}

export interface EscalationPathWorkingHourWeekdayInterval {
    /**
     * End time of the interval, in 24hr format
     */
    endTime: string;
    /**
     * Start time of the interval, in 24hr format
     */
    startTime: string;
    /**
     * Weekday this interval applies to
     */
    weekday: string;
}

export interface ScheduleHolidaysPublicConfig {
    /**
     * ISO 3166-1 alpha-2 country codes for the countries that this schedule is configured to view holidays for
     */
    countryCodes: string[];
}

export interface ScheduleRotation {
    /**
     * Unique internal ID of the rotation
     */
    id: string;
    /**
     * Human readable name synced from external provider
     */
    name: string;
    versions: outputs.ScheduleRotationVersion[];
}

export interface ScheduleRotationVersion {
    /**
     * When this rotation config will be effective from
     */
    effectiveFrom?: string;
    /**
     * Defines the next moment we'll trigger a handover
     */
    handoverStartAt: string;
    /**
     * Defines the handover intervals for this rota, in order they should apply
     */
    handovers?: outputs.ScheduleRotationVersionHandover[];
    /**
     * Controls how many people are on-call concurrently
     */
    layers: outputs.ScheduleRotationVersionLayer[];
    /**
     * The incident.io ID of a user
     */
    users: string[];
    workingIntervals?: outputs.ScheduleRotationVersionWorkingInterval[];
}

export interface ScheduleRotationVersionHandover {
    interval: number;
    intervalType: string;
}

export interface ScheduleRotationVersionLayer {
    id: string;
    name: string;
}

export interface ScheduleRotationVersionWorkingInterval {
    day: string;
    end: string;
    start: string;
}

export interface WorkflowConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.WorkflowConditionGroupCondition[];
}

export interface WorkflowConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.WorkflowConditionGroupConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface WorkflowConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowConditionGroupConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowConditionGroupConditionParamBindingValue;
}

export interface WorkflowConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowDelay {
    /**
     * If this workflow is delayed, whether the conditions should be rechecked between trigger firing and execution
     */
    conditionsApplyOverDelay: boolean;
    /**
     * Delay in seconds between trigger firing and running the workflow
     */
    forSeconds: number;
}

export interface WorkflowExpression {
    /**
     * The else branch to resort to if all operations fail
     */
    elseBranch?: outputs.WorkflowExpressionElseBranch;
    /**
     * The human readable label of the expression
     */
    label: string;
    /**
     * The operations to execute in sequence for this expression
     */
    operations: outputs.WorkflowExpressionOperation[];
    /**
     * A short ID that can be used to reference the expression
     */
    reference: string;
    /**
     * The root reference for this expression (i.e. where the expression starts)
     */
    rootReference: string;
}

export interface WorkflowExpressionElseBranch {
    /**
     * The result assumed if the else branch is reached
     */
    result: outputs.WorkflowExpressionElseBranchResult;
}

export interface WorkflowExpressionElseBranchResult {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowExpressionElseBranchResultArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowExpressionElseBranchResultValue;
}

export interface WorkflowExpressionElseBranchResultArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionElseBranchResultValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperation {
    /**
     * An operation type that allows for a value to be set conditionally by a series of logical branches
     */
    branches?: outputs.WorkflowExpressionOperationBranches;
    /**
     * An operation type that allows values to be filtered out by conditions
     */
    filter?: outputs.WorkflowExpressionOperationFilter;
    /**
     * An operation type that allows attributes of a type to be accessed by reference
     */
    navigate?: outputs.WorkflowExpressionOperationNavigate;
    /**
     * Indicates which operation type to execute
     */
    operationType: string;
    /**
     * An operation type that allows a value to parsed from within a JSON object
     */
    parse?: outputs.WorkflowExpressionOperationParse;
}

export interface WorkflowExpressionOperationBranches {
    /**
     * The branches to apply for this operation
     */
    branches: outputs.WorkflowExpressionOperationBranchesBranch[];
    /**
     * The return type of an operation
     */
    returns: outputs.WorkflowExpressionOperationBranchesReturns;
}

export interface WorkflowExpressionOperationBranchesBranch {
    /**
     * Groups of prerequisite conditions. All conditions in at least one group must be satisfied
     */
    conditionGroups: outputs.WorkflowExpressionOperationBranchesBranchConditionGroup[];
    /**
     * The result assumed if the condition groups are satisfied
     */
    result: outputs.WorkflowExpressionOperationBranchesBranchResult;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.WorkflowExpressionOperationBranchesBranchConditionGroupCondition[];
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingValue;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationBranchesBranchResult {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowExpressionOperationBranchesBranchResultArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowExpressionOperationBranchesBranchResultValue;
}

export interface WorkflowExpressionOperationBranchesBranchResultArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationBranchesBranchResultValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationBranchesReturns {
    /**
     * Whether the return value should be single or multi-value
     */
    array: boolean;
    /**
     * Expected return type of this expression (what to try casting the result to)
     */
    type: string;
}

export interface WorkflowExpressionOperationFilter {
    /**
     * Groups of prerequisite conditions. All conditions in at least one group must be satisfied
     */
    conditionGroups: outputs.WorkflowExpressionOperationFilterConditionGroup[];
}

export interface WorkflowExpressionOperationFilterConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: outputs.WorkflowExpressionOperationFilterConditionGroupCondition[];
}

export interface WorkflowExpressionOperationFilterConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBinding[];
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: string;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBindingValue;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowExpressionOperationNavigate {
    reference: string;
}

export interface WorkflowExpressionOperationParse {
    /**
     * The return type of an operation
     */
    returns: outputs.WorkflowExpressionOperationParseReturns;
    /**
     * The ES5 Javascript expression to execute
     */
    source: string;
}

export interface WorkflowExpressionOperationParseReturns {
    /**
     * Whether the return value should be single or multi-value
     */
    array: boolean;
    /**
     * Expected return type of this expression (what to try casting the result to)
     */
    type: string;
}

export interface WorkflowStep {
    forEach?: string;
    id: string;
    name: string;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: outputs.WorkflowStepParamBinding[];
}

export interface WorkflowStepParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: outputs.WorkflowStepParamBindingArrayValue[];
    /**
     * The literal or reference parameter value
     */
    value?: outputs.WorkflowStepParamBindingValue;
}

export interface WorkflowStepParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

export interface WorkflowStepParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: string;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: string;
}

