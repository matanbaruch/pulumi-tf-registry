// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CatalogEntriesEntries {
    /**
     * Optional aliases that can be used to reference this entry
     */
    aliases?: pulumi.Input<pulumi.Input<string>[]>;
    attributeValues: pulumi.Input<{[key: string]: pulumi.Input<inputs.CatalogEntriesEntriesAttributeValues>}>;
    /**
     * ID of this catalog entry
     */
    id?: pulumi.Input<string>;
    /**
     * Name is the human readable name of this entry
     */
    name: pulumi.Input<string>;
    /**
     * When catalog type is ranked, this is used to help order things
     */
    rank?: pulumi.Input<number>;
}

export interface CatalogEntriesEntriesAttributeValues {
    /**
     * The value of this element of the array, in a format suitable for this attribute type.
     */
    arrayValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The value of this attribute, in a format suitable for this attribute type.
     */
    value?: pulumi.Input<string>;
}

export interface CatalogEntryAttributeValue {
    /**
     * The value of this element of the array, in a format suitable for this attribute type.
     */
    arrayValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of this attribute, usually loaded from the incident.CatalogTypeAttribute resource.
     */
    attribute: pulumi.Input<string>;
    /**
     * The value of this attribute, in a format suitable for this attribute type.
     */
    value?: pulumi.Input<string>;
}

export interface EscalationPathPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    ifElse?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElse>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElse {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseCondition>[]>;
    /**
     * The nodes that form the levels if our condition is not met
     */
    elsePaths?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePath>[]>;
    /**
     * Then path nodes
     */
    thenPaths: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPath>[]>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingValue>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseElsePathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPath {
    /**
     * Unique internal ID of the escalation path node
     */
    id?: pulumi.Input<string>;
    level?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevel>;
    repeat?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathRepeat>;
    /**
     * The type of this node: level or branch
     */
    type: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathIfElseThenPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathIfElseThenPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathIfElseThenPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathIfElseThenPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathPathLevel {
    roundRobinConfig?: pulumi.Input<inputs.EscalationPathPathLevelRoundRobinConfig>;
    /**
     * The targets for this level
     */
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPathPathLevelTarget>[]>;
    /**
     * If the time to ack is relative to a time window, this defines whether we move when the window is active or inactive
     */
    timeToAckIntervalCondition?: pulumi.Input<string>;
    /**
     * How long should we wait for this level to acknowledge before escalating?
     */
    timeToAckSeconds?: pulumi.Input<number>;
    /**
     * If the time to ack is relative to a time window, this identifies which window it is relative to
     */
    timeToAckWeekdayIntervalConfigId?: pulumi.Input<string>;
}

export interface EscalationPathPathLevelRoundRobinConfig {
    enabled: pulumi.Input<boolean>;
    rotateAfterSeconds?: pulumi.Input<number>;
}

export interface EscalationPathPathLevelTarget {
    /**
     * Uniquely identifies an entity of this type
     */
    id: pulumi.Input<string>;
    /**
     * Only set for schedule targets, and either currently_on_call, all_users or all_users_for_rota and specifies which users to fetch from the schedule
     */
    scheduleMode?: pulumi.Input<string>;
    /**
     * Controls what type of entity this target identifies, such as EscalationPolicy or User
     */
    type: pulumi.Input<string>;
    /**
     * The urgency of this escalation path target
     */
    urgency: pulumi.Input<string>;
}

export interface EscalationPathPathRepeat {
    /**
     * How many times to repeat these steps
     */
    repeatTimes: pulumi.Input<number>;
    /**
     * Which node ID we begin repeating from
     */
    toNode: pulumi.Input<string>;
}

export interface EscalationPathWorkingHour {
    /**
     * The unique identifier for this set of working intervals
     */
    id: pulumi.Input<string>;
    /**
     * A human readable label for this set of working intervals
     */
    name: pulumi.Input<string>;
    /**
     * How to interpret all the intervals
     */
    timezone: pulumi.Input<string>;
    weekdayIntervals: pulumi.Input<pulumi.Input<inputs.EscalationPathWorkingHourWeekdayInterval>[]>;
}

export interface EscalationPathWorkingHourWeekdayInterval {
    /**
     * End time of the interval, in 24hr format
     */
    endTime: pulumi.Input<string>;
    /**
     * Start time of the interval, in 24hr format
     */
    startTime: pulumi.Input<string>;
    /**
     * Weekday this interval applies to
     */
    weekday: pulumi.Input<string>;
}

export interface ScheduleHolidaysPublicConfig {
    /**
     * ISO 3166-1 alpha-2 country codes for the countries that this schedule is configured to view holidays for
     */
    countryCodes: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ScheduleRotation {
    /**
     * Unique internal ID of the rotation
     */
    id: pulumi.Input<string>;
    /**
     * Human readable name synced from external provider
     */
    name: pulumi.Input<string>;
    versions: pulumi.Input<pulumi.Input<inputs.ScheduleRotationVersion>[]>;
}

export interface ScheduleRotationVersion {
    /**
     * When this rotation config will be effective from
     */
    effectiveFrom?: pulumi.Input<string>;
    /**
     * Defines the next moment we'll trigger a handover
     */
    handoverStartAt: pulumi.Input<string>;
    /**
     * Defines the handover intervals for this rota, in order they should apply
     */
    handovers?: pulumi.Input<pulumi.Input<inputs.ScheduleRotationVersionHandover>[]>;
    /**
     * Controls how many people are on-call concurrently
     */
    layers: pulumi.Input<pulumi.Input<inputs.ScheduleRotationVersionLayer>[]>;
    /**
     * The incident.io ID of a user
     */
    users: pulumi.Input<pulumi.Input<string>[]>;
    workingIntervals?: pulumi.Input<pulumi.Input<inputs.ScheduleRotationVersionWorkingInterval>[]>;
}

export interface ScheduleRotationVersionHandover {
    interval: pulumi.Input<number>;
    intervalType: pulumi.Input<string>;
}

export interface ScheduleRotationVersionLayer {
    id: pulumi.Input<string>;
    name: pulumi.Input<string>;
}

export interface ScheduleRotationVersionWorkingInterval {
    day: pulumi.Input<string>;
    end: pulumi.Input<string>;
    start: pulumi.Input<string>;
}

export interface WorkflowConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.WorkflowConditionGroupCondition>[]>;
}

export interface WorkflowConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.WorkflowConditionGroupConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface WorkflowConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowConditionGroupConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowConditionGroupConditionParamBindingValue>;
}

export interface WorkflowConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowDelay {
    /**
     * If this workflow is delayed, whether the conditions should be rechecked between trigger firing and execution
     */
    conditionsApplyOverDelay: pulumi.Input<boolean>;
    /**
     * Delay in seconds between trigger firing and running the workflow
     */
    forSeconds: pulumi.Input<number>;
}

export interface WorkflowExpression {
    /**
     * The else branch to resort to if all operations fail
     */
    elseBranch?: pulumi.Input<inputs.WorkflowExpressionElseBranch>;
    /**
     * The human readable label of the expression
     */
    label: pulumi.Input<string>;
    /**
     * The operations to execute in sequence for this expression
     */
    operations: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperation>[]>;
    /**
     * A short ID that can be used to reference the expression
     */
    reference: pulumi.Input<string>;
    /**
     * The root reference for this expression (i.e. where the expression starts)
     */
    rootReference: pulumi.Input<string>;
}

export interface WorkflowExpressionElseBranch {
    /**
     * The result assumed if the else branch is reached
     */
    result: pulumi.Input<inputs.WorkflowExpressionElseBranchResult>;
}

export interface WorkflowExpressionElseBranchResult {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionElseBranchResultArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowExpressionElseBranchResultValue>;
}

export interface WorkflowExpressionElseBranchResultArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionElseBranchResultValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperation {
    /**
     * An operation type that allows for a value to be set conditionally by a series of logical branches
     */
    branches?: pulumi.Input<inputs.WorkflowExpressionOperationBranches>;
    /**
     * An operation type that allows values to be filtered out by conditions
     */
    filter?: pulumi.Input<inputs.WorkflowExpressionOperationFilter>;
    /**
     * An operation type that allows attributes of a type to be accessed by reference
     */
    navigate?: pulumi.Input<inputs.WorkflowExpressionOperationNavigate>;
    /**
     * Indicates which operation type to execute
     */
    operationType: pulumi.Input<string>;
    /**
     * An operation type that allows a value to parsed from within a JSON object
     */
    parse?: pulumi.Input<inputs.WorkflowExpressionOperationParse>;
}

export interface WorkflowExpressionOperationBranches {
    /**
     * The branches to apply for this operation
     */
    branches: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranch>[]>;
    /**
     * The return type of an operation
     */
    returns: pulumi.Input<inputs.WorkflowExpressionOperationBranchesReturns>;
}

export interface WorkflowExpressionOperationBranchesBranch {
    /**
     * Groups of prerequisite conditions. All conditions in at least one group must be satisfied
     */
    conditionGroups: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchConditionGroup>[]>;
    /**
     * The result assumed if the condition groups are satisfied
     */
    result: pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchResult>;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchConditionGroupCondition>[]>;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingValue>;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationBranchesBranchConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationBranchesBranchResult {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchResultArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowExpressionOperationBranchesBranchResultValue>;
}

export interface WorkflowExpressionOperationBranchesBranchResultArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationBranchesBranchResultValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationBranchesReturns {
    /**
     * Whether the return value should be single or multi-value
     */
    array: pulumi.Input<boolean>;
    /**
     * Expected return type of this expression (what to try casting the result to)
     */
    type: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationFilter {
    /**
     * Groups of prerequisite conditions. All conditions in at least one group must be satisfied
     */
    conditionGroups: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationFilterConditionGroup>[]>;
}

export interface WorkflowExpressionOperationFilterConditionGroup {
    /**
     * The prerequisite conditions that must all be satisfied
     */
    conditions: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationFilterConditionGroupCondition>[]>;
}

export interface WorkflowExpressionOperationFilterConditionGroupCondition {
    /**
     * The logical operation to be applied
     */
    operation: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBinding>[]>;
    /**
     * The subject of the condition, on which the operation is applied
     */
    subject: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowExpressionOperationFilterConditionGroupConditionParamBindingValue>;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationFilterConditionGroupConditionParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationNavigate {
    reference: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationParse {
    /**
     * The return type of an operation
     */
    returns: pulumi.Input<inputs.WorkflowExpressionOperationParseReturns>;
    /**
     * The ES5 Javascript expression to execute
     */
    source: pulumi.Input<string>;
}

export interface WorkflowExpressionOperationParseReturns {
    /**
     * Whether the return value should be single or multi-value
     */
    array: pulumi.Input<boolean>;
    /**
     * Expected return type of this expression (what to try casting the result to)
     */
    type: pulumi.Input<string>;
}

export interface WorkflowStep {
    forEach?: pulumi.Input<string>;
    id: pulumi.Input<string>;
    name: pulumi.Input<string>;
    /**
     * Bindings for the operation parameters
     */
    paramBindings: pulumi.Input<pulumi.Input<inputs.WorkflowStepParamBinding>[]>;
}

export interface WorkflowStepParamBinding {
    /**
     * The array of literal or reference parameter values
     */
    arrayValues?: pulumi.Input<pulumi.Input<inputs.WorkflowStepParamBindingArrayValue>[]>;
    /**
     * The literal or reference parameter value
     */
    value?: pulumi.Input<inputs.WorkflowStepParamBindingValue>;
}

export interface WorkflowStepParamBindingArrayValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}

export interface WorkflowStepParamBindingValue {
    /**
     * If set, this is the literal value of the step parameter
     */
    literal?: pulumi.Input<string>;
    /**
     * If set, this is the reference into the trigger scope that is the value of this parameter
     */
    reference?: pulumi.Input<string>;
}
