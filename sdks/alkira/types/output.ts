// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ConnectorAkamaiProlexicByoipOption {
    /**
     * BYOIP prefix ID.
     */
    byoipPrefixId: number;
    /**
     * Whether enabling route advertisement.
     */
    enableRouteAdvertisement: boolean;
}

export interface ConnectorAkamaiProlexicTunnelConfiguration {
    /**
     * Alkira public IP.
     */
    alkiraPublicIp: string;
    /**
     * Tunnel IPs.
     */
    tunnelIps: outputs.ConnectorAkamaiProlexicTunnelConfigurationTunnelIp[];
}

export interface ConnectorAkamaiProlexicTunnelConfigurationTunnelIp {
    /**
     * The overlay IP of the GRE tunnel on the Alkira side.
     */
    akamaiOverlayTunnelIp: string;
    /**
     * The overlay IP of the GRE tunnel on the Alkira side.
     */
    alkiraOverlayTunnelIp: string;
    /**
     * The underlay tunnel IP on the Akamai side to be used to configure tunnels between the Alkira CXP and the Akamai Prolexic service. A RAN (Routed Access Network) is the unit of availability for the Route GRE 3.0 service.
     */
    ranTunnelIp: string;
}

export interface ConnectorArubaEdgeArubaEdgeVrfMapping {
    /**
     * Enables or disables access to the internet when traffic arrives via this connector. The default value is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Allow routes from the branch/premises to be advertised to the cloud. The default value is False.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * The segment of the Aruba Edge connector.
     */
    arubaEdgeConnectSegment: string;
    /**
     * The gateway BGP ASN.
     */
    gatewayGbpAsn: number;
    /**
     * The segment ID associated with the Aruba Edge connector.
     */
    segmentId: string;
}

export interface ConnectorArubaEdgeInstance {
    /**
     * The account key generated in Silver Peak orchestrator account.
     */
    accountKey: string;
    /**
     * The account name given in Silver Peak orchestrator registration.
     */
    accountName: string;
    /**
     * The host name given to the Aruba SD-WAN appliance that appears in Silver Peak orchestrator.
     */
    hostName: string;
    /**
     * The ID of the endpoint.
     */
    id: number;
    /**
     * The instance name associated with Aruba Edge Connect instance.
     */
    name: string;
    /**
     * The site tag that appears on the SD-WAN appliance on Silver Peak orchestrator
     */
    siteTag: string;
}

export interface ConnectorAwsVpcTgwAttachment {
    /**
     * The availability zone of the subnet.
     */
    az: string;
    /**
     * The Id of the subnet.
     */
    subnetId: string;
}

export interface ConnectorAwsVpcVpcRouteTable {
    /**
     * The Id of the route table
     */
    id?: string;
    /**
     * Routing options, one of `ADVERTISE_DEFAULT_ROUTE`, `OVERRIDE_DEFAULT_ROUTE` or `ADVERTISE_CUSTOM_PREFIX`.
     */
    options?: string;
    /**
     * Prefix List IDs
     */
    prefixListIds?: number[];
}

export interface ConnectorAwsVpcVpcSubnet {
    /**
     * The CIDR of the subnet.
     */
    cidr?: string;
    /**
     * The Id of the subnet.
     */
    id?: string;
}

export interface ConnectorAzureExpressrouteInstance {
    /**
     * An opaque identifier generated when storing Azure VNET credentials.
     */
    credentialId: string;
    /**
     * ExpressRoute circuit ID from Azure. ExpresRoute Circuit should have a private peering connection provisioned, also an valid authorization key associated with it.
     */
    expressrouteCircuitId: string;
    /**
     * An array containing the mac addresses of VXLAN gateways reachable through ExpressRoute circuit. The field is only expected if VXLAN tunnel protocol is selected, and 2 gateway MAC addresses are expected only if `redundant_router` is enabled.
     */
    gatewayMacAddresses?: string[];
    id: number;
    /**
     * A `/26` subnet from which loopback IPs would be used to establish underlay VXLAN GPE tunnels.
     */
    loopbackSubnet: string;
    /**
     * User provided connector instance name.
     */
    name: string;
    /**
     * Indicates if ExpressRoute Circuit terminates on redundant routers on customer side.
     */
    redundantRouter?: boolean;
    /**
     * This is an optional field if the `tunnel_protocol` is `VXLAN`. If not specified Alkira allocates unique VNI from the range `[16773023, 16777215]`.
     */
    virtualNetworkInterfaces?: number[];
}

export interface ConnectorAzureExpressrouteSegmentOption {
    /**
     * Allow routes from the branch/premises to be advertised to the cloud.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * ASN on the customer premise side.
     */
    customerAsn: number;
    /**
     * Enable or disable access to the internet when traffic arrives via this connector.
     */
    disableInternetExit?: boolean;
    /**
     * The ID of the segment.
     */
    segmentId: number;
    /**
     * The name of an existing segment.
     */
    segmentName: string;
}

export interface ConnectorAzureVnetVnetCidr {
    /**
     * VNET CIDR.
     */
    cidr: string;
    /**
     * Prefix List IDs.
     */
    prefixListIds?: number[];
    /**
     * Routing options for the CIDR, either `ADVERTISE_DEFAULT_ROUTE` or `ADVERTISE_CUSTOM_PREFIX`.
     */
    routingOptions?: string;
    /**
     * List of service tags provided by Azure.
     */
    serviceTags?: string[];
    /**
     * User defined routes list (`list_udr`).
     */
    udrListIds?: number[];
}

export interface ConnectorAzureVnetVnetSubnet {
    /**
     * Prefix List IDs.
     */
    prefixListIds?: number[];
    /**
     * Routing options for the subnet, either `ADVERTISE_DEFAULT_ROUTE` or `ADVERTISE_CUSTOM_PREFIX`.
     */
    routingOptions?: string;
    /**
     * List of service tags provided by Azure.
     */
    serviceTags?: string[];
    /**
     * VNET subnet CIDR.
     */
    subnetCidr?: string;
    /**
     * VNET subnet ID.
     */
    subnetId: string;
    /**
     * User defined routes list (`list_udr`).
     */
    udrListIds?: number[];
}

export interface ConnectorCiscoSdwanVedge {
    /**
     * The cloud-init file for the vEdge.
     */
    cloudInitFile: string;
    /**
     * The generated credential ID for Cisco SD-WAN.
     */
    credentialId: string;
    /**
     * The ID of the credential for SSH Key Pair.
     */
    credentialSshKeyPairId?: string;
    /**
     * The hostname of the vEdge.
     */
    hostname: string;
    /**
     * The ID of the vEdge instance.
     */
    id: number;
    /**
     * Cisco SD-WAN password. It could be also set by environment variable `AK_CISCO_SDWAN_PASSWORD`.
     */
    password: string;
    /**
     * Cisco SD-WAN username. It could be also set by environment variable `AK_CISCO_SDWAN_USERNAME`.
     */
    username: string;
}

export interface ConnectorCiscoSdwanVrfSegmentMapping {
    /**
     * Whether advertise default route of internet connector. Default value is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Advertise On Prem Routes. Default value is `false`.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * BGP ASN on the customer premise side. A typical value for 2 byte segment is `64523` and `4200064523` for 4 byte segment.
     */
    customerAsn: number;
    /**
     * Segment ID.
     */
    segmentId: number;
    /**
     * VRF ID.
     */
    vrfId: number;
}

export interface ConnectorFortinetSdwanTargetSegment {
    /**
     * Whether advertise default route of internet connector. Default value is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Whether advertising On Prem Routes. Default value is `false`.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * BGP ASN on the customer premise side. A typical value for 2 byte segment is `64523` and `4200064523` for 4 byte segment.
     */
    gatewayBgpAsn?: number;
    /**
     * Alkira Segment ID.
     */
    segmentId: number;
    /**
     * Fortinet SD-WAN Segment name for correlating with Alkria segment.
     */
    vrfId: number;
}

export interface ConnectorFortinetSdwanWanEdge {
    /**
     * The generated credential ID.
     */
    credentialId: string;
    /**
     * The hostname of the WAN Edge.
     */
    hostname: string;
    /**
     * The ID of the WAN Edge instance.
     */
    id: number;
    /**
     * The type of license. Either `PAY_AS_YOU_GO` or `BRING_YOUR_OWN`.
     */
    licenseType: string;
    /**
     * The password of the WAN Edge instance.
     */
    password: string;
    /**
     * Serial Number of the WAN Edge. It's only required when `license_type` is `BRING_YOUR_OWN`. It could be set by ENV variable `AK_FORTINET_SDWAN_SERIAL_NUMBER`.
     */
    serialNumber?: string;
    /**
     * The username of the WAN Edge instance.The default value is `admin`.
     */
    username?: string;
    /**
     * The version of Fortinet WAN Edge. Please check Alkira Portal for all supported versions.
     */
    version: string;
}

export interface ConnectorGcpVpcGcpRouting {
    /**
     * Specifies the source of the routes that need to be imported. The value could be `ADVERTISE_DEFAULT_ROUTE` and `ADVERTISE_CUSTOM_PREFIX`.
     */
    customPrefix: string;
    /**
     * IDs of prefix lists defined on the network.
     */
    prefixListIds: number[];
}

export interface ConnectorGcpVpcVpcSubnet {
    /**
     * The CIDR of the subnet.
     */
    cidr?: string;
    /**
     * An identifier for the subnetwork resource with format `projects/{{project}}/regions/{{region}}/subnetworks/{{name}}`.
     */
    id?: string;
}

export interface ConnectorIpsecAdvGateway {
    /**
     * The IP address of the customer gateway. This should be `0.0.0.0` to indicate that this is a dynamic gateway.
     */
    customerGatewayIp: string;
    /**
     * The value could be `ACTIVE` or`STANDBY`. A gateway in `STANDBY` mode will not be used for traffic unless all other gateways for the connector are down. There can only be one gateway in `STANDBY` mode per connector and there must be at least one gateway that isn't in `STANDBY` mode per connector.
     */
    haMode?: string;
    /**
     * The ID of the gateway.
     */
    id: number;
    /**
     * The name of the endpoint.
     */
    name: string;
    /**
     * Tunnel of the gateway. The number of the tunnels should be equal to `tunnel_per_gateway`.
     */
    tunnels: outputs.ConnectorIpsecAdvGatewayTunnel[];
}

export interface ConnectorIpsecAdvGatewayTunnel {
    /**
     * Advanced options for the IPSec gateway.
     */
    advancedOptions?: outputs.ConnectorIpsecAdvGatewayTunnelAdvancedOptions;
    /**
     * The overlay IP address of the customer end of the tunnel.
     */
    customerEndOverlayIp: string;
    /**
     * The overlay IP reservation ID of the customer end of the tunnel.
     */
    customerEndOverlayIpReservationId: string;
    /**
     * The overlay IP reservation ID of the CXP end of the tunnel.
     */
    cxpEndOverlayIpReservationId: string;
    /**
     * The public IP reservation ID of the CXP end of the tunnel.
     */
    cxpEndPublicIpReservationId: string;
    /**
     * The ID of the tunnel.
     */
    id: string;
    /**
     * The number of the tunnel.
     */
    number: number;
    /**
     * The pre-shared key of the tunnel.
     */
    presharedKey: string;
    /**
     * The ID of the IPSec Tunnel Profile (`connector_ipsec_tunnel_profile`). `advanced_options` block is required when this is used.
     */
    profileId?: number;
}

export interface ConnectorIpsecAdvGatewayTunnelAdvancedOptions {
    /**
     * IKE version, either `IKEv1` or `IKEv2`
     */
    ikeVersion: string;
    /**
     * When true CXP will initiate the IKE connection and if false then the customer gateway should initiate IKE. When `gateway_ip_type` is `DYNAMIC`,initiator must be `true`.
     */
    initiator: boolean;
    /**
     * Remote-ID type - IKE identity to use for authentication round, one of `FQDN`, `USER_FQDN`, `KEYID`, `IP_ADDR`.
     */
    remoteAuthType: string;
    /**
     * Remote-ID value.
     */
    remoteAuthValue: string;
}

export interface ConnectorIpsecAdvPolicyOption {
    /**
     * CXP Prefix List IDs.
     */
    cxpPrefixListIds: number[];
    /**
     * On-Prem Prefix List IDs.
     */
    onPremPrefixListIds: number[];
}

export interface ConnectorIpsecAdvRoutingOption {
    /**
     * The method to determine the availability of the routes. The value could be `IKE_STATUS` or `IPSEC_INTERFACE_PING`. Default value is `IPSEC_INTERFACE_PING`.
     */
    availability?: string;
    /**
     * BGP MD5 auth key for Alkira to authenticate Alkira CXP (On Premise Gateway).
     */
    bgpAuthKey?: string;
    /**
     * The customer gateway ASN to use for dynamic route propagation.
     */
    customerGatewayAsn?: string;
    /**
     * The ID of prefix list to use for static route propagation.
     */
    prefixListId?: number;
    /**
     * Routing type, one of `STATIC`, `DYNAMIC`, or `BOTH`.
     */
    type: string;
}

export interface ConnectorIpsecEndpoint {
    /**
     * Advanced options for IPSec endpoint.
     */
    advancedOptions?: outputs.ConnectorIpsecEndpointAdvancedOption[];
    /**
     * A list of IDs of billing tag associated with the endpoint.
     */
    billingTagIds?: number[];
    /**
     * The IP address of the customer gateway.
     */
    customerGatewayIp: string;
    /**
     * Disable this if all tunnels will not be configured or enabled on the on-premise device. If it's set to `false`, connector health will be shown as `UP` if at least one of the tunnels is `UP`. If enabled, all tunnels need to be `UP` for the connectorhealth to be shown as `UP`.
     */
    enableTunnelRedundancy?: boolean;
    /**
     * The value could be `ACTIVE` or `STANDBY`. A endpoint in `STANDBY` mode will not be used for traffic unless all other endpoints for the connector are down. There can only be one endpoint in `STANDBY` mode per connector and there must be at least one endpoint that isn't in `STANDBY` mode per connector.
     */
    haMode?: string;
    /**
     * The ID of the endpoint.
     */
    id: number;
    /**
     * The name of the endpoint.
     */
    name: string;
    /**
     * An array of preshared keys, one per tunnel. The value needs to be provided explictly unlike portal.
     */
    presharedKeys: string[];
}

export interface ConnectorIpsecEndpointAdvancedOption {
    /**
     * Diffie Hellman groups to use for IPsec SA. Value could `MODP1024`, `MODP2048`, `MODP3072`, `MODP4096`, `MODP6144`, `MODP8192`, `ECP256`, `ECP384`, `ECP521`, `CURVE25519` and `NONE`.
     */
    espDhGroupNumbers: string[];
    /**
     * Encryption algorithms to use for IPsec SA. Value could be `AES256CBC`, `AES192CBC`, `AES128CBC`, `AES256GCM16` `3DESCBC`, or `NULL`.
     */
    espEncryptionAlgorithms: string[];
    /**
     * Integrity algorithms to use for IPsec SA. Value could `SHA1`, `SHA256`, `SHA384`, `SHA512` or `MD5`.
     */
    espIntegrityAlgorithms: string[];
    /**
     * Diffie Hellman groups to use for IKE SA, one of `MODP1024`, `MODP2048`, `MODP3072`, `MODP4096`, `MODP6144`, `MODP8192`, `ECP256`, `ECP384`, `ECP521`, `CURVE25519`.
     */
    ikeDhGroupNumbers: string[];
    /**
     * Encryption algorithms to use for IKE SA, one of `AES256CBC`, `AES192CBC`, `AES128CBC` and `3DESCBC`.
     */
    ikeEncryptionAlgorithms: string[];
    /**
     * Integrity algorithms to use for IKE SA, one of `SHA1`, `SHA256`, `SHA384`, `SHA512`.
     */
    ikeIntegrityAlgorithms: string[];
    /**
     * IKE version, either `IKEv1` or `IKEv2`
     */
    ikeVersion: string;
    /**
     * When true CXP will initiate the IKE connection and if false then the customer gateway should initiate IKE. When `gateway_ip_type` is `DYNAMIC`, initiator must be `true`.
     */
    initiator: boolean;
    /**
     * Remote-ID type - IKE identity to use for authentication round, one of `FQDN`, `USER_FQDN`, `KEYID`, `IP_ADDR`.
     */
    remoteAuthType: string;
    /**
     * Remote-ID value.
     */
    remoteAuthValue: string;
}

export interface ConnectorIpsecPolicyOption {
    /**
     * CXP Prefix List IDs.
     */
    cxpPrefixListIds: number[];
    /**
     * On Prem Prefix List IDs.
     */
    onPremPrefixListIds: number[];
}

export interface ConnectorIpsecRoutingOption {
    /**
     * The method to determine the availability of the routes. The value could be `IKE_STATUS` or `IPSEC_INTERFACE_PING`. Default value is `IPSEC_INTERFACE_PING`.
     */
    availability?: string;
    /**
     * BGP MD5 auth key for Alkira to authenticate Alkira CXP (On Premise Gateway).
     */
    bgpAuthKey?: string;
    /**
     * The customer gateway ASN to use for dynamic route propagation.
     */
    customerGatewayAsn?: string;
    /**
     * The ID of prefix list to use for static route propagation.
     */
    prefixListId?: number;
    /**
     * Routing type, one of `STATIC`, `DYNAMIC`, or `BOTH`.
     */
    type: string;
}

export interface ConnectorIpsecSegmentOption {
    /**
     * Enable or disable access to the internet when traffic arrives via this connector. Default is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Additional options for each segment associated with the connector. Default is `false`.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * Segment Name.
     */
    name: string;
}

export interface ConnectorOciVcnVcnRouteTable {
    /**
     * The ID of the route table.
     */
    id?: string;
    /**
     * Routing options, one of `ADVERTISE_DEFAULT_ROUTE`, `OVERRIDE_DEFAULT_ROUTE` and `ADVERTISE_CUSTOM_PREFIX`.
     */
    options?: string;
    /**
     * Prefix List IDs.
     */
    prefixListIds?: number[];
}

export interface ConnectorOciVcnVcnSubnet {
    /**
     * The CIDR of the subnet.
     */
    cidr?: string;
    /**
     * The Id of the subnet.
     */
    id?: string;
}

export interface ConnectorRemoteAccessAuthorization {
    /**
     * Billing tag (`alkira.BillingTag`).
     */
    billingTagId?: number;
    /**
     * The ID of the prefix list (`alkira.PolicyPrefixList`).
     */
    prefixListId?: number;
    /**
     * The segment (`alkira.Segment`) to be mapped.
     */
    segmentId: number;
    /**
     * Enable split tunneling to send traffic destined to only IP addresses in the prefix list over the VPN tunnel. Default is `false`
     */
    splitTunneling?: boolean;
    /**
     * The client subnet.
     */
    subnet: string;
    /**
     * User group (`alkira.GroupUser`) name.
     */
    userGroupName: string;
}

export interface ConnectorRemoteAccessLdapSetting {
    /**
     * The domain.
     */
    bindUserDomain: string;
    /**
     * Destination dddress.
     */
    destinationAddress: string;
    /**
     * The LDAP type.
     */
    ldapType: string;
    /**
     * The management segment.
     */
    managementSegmentId: number;
    /**
     * Base DN to query and validate remote users that will connect to the connector.
     */
    searchScopeDomain: string;
}

export interface ConnectorVersaSdwanVersaVosDevice {
    /**
     * The hostname of the VOS Device.
     */
    hostname: string;
    /**
     * The ID of the VOS device.
     */
    id: number;
    /**
     * Local device serial number.
     */
    localDeviceSerialNumber: string;
    /**
     * Versa version.
     */
    version: string;
}

export interface ConnectorVersaSdwanVrfSegmentMapping {
    /**
     * Whether advertise default route of internet connector. Default value is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Advertise On Prem Routes. Default value is `false`.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * Segment ID.
     */
    segmentId: number;
    /**
     * BGP ASN on the Versa. A typical value for 2 byte segment is `64523` and `4200064523` for 4 byte segment.
     */
    versaBgpAsn: number;
    /**
     * VRF Name.
     */
    vrfName: string;
}

export interface ConnectorVmwareSdwanTargetSegment {
    /**
     * Whether advertise default route of internet connector. Default value is `false`.
     */
    advertiseDefaultRoute?: boolean;
    /**
     * Whether advertising On Prem Routes. Default value is `false`.
     */
    advertiseOnPremRoutes?: boolean;
    /**
     * BGP ASN on the customer premise side. A typical value for 2 byte segment is `64523` and `4200064523` for 4 byte segment.
     */
    gatewayBgpAsn?: number;
    /**
     * Alkira Segment ID.
     */
    segmentId: number;
    /**
     * VMWare SD-WAN Segment name for correlating with Alkria segment.
     */
    vmwareSdwanSegmentName: string;
}

export interface ConnectorVmwareSdwanVirtualEdge {
    /**
     * Activation code generated in VMWare orchestrator account.
     */
    activationCode: string;
    /**
     * The generated credential ID.
     */
    credentialId: string;
    /**
     * The hostname of the virtual edge.
     */
    hostname: string;
    /**
     * The ID of the virtual edge.
     */
    id: number;
}

export interface InternetApplicationSourceNatIpPool {
    /**
     * The end IP of the range.
     */
    endIp: string;
    /**
     * The start IP of the range.
     */
    startIp: string;
}

export interface InternetApplicationTarget {
    /**
     * list of ports or port ranges. Values can be mixed i.e. `["20", "100-200"]`. An array with only the value `-1` means any port.
     */
    portRanges: string[];
    /**
     * The type of the target, one of `IP` or `ILB_NAME`.
     */
    type: string;
    /**
     * IFA ILB name or private IP.
     */
    value: string;
}

export interface ListUdrRoute {
    /**
     * Description for the route.
     */
    description?: string;
    /**
     * The prefix of the route. This prefix must be in the CIDR format (`x.x.x.x/mask`). The mask can be between `8-32`.
     */
    prefix: string;
}

export interface PolicyNatRuleAction {
    /**
     * Whether the destination address should be advertised to connector.
     */
    dstAddrTranslationAdvertiseToConnector?: boolean;
    /**
     * The ID of policy FQDN list.
     */
    dstAddrTranslationListPolicyFqdnId?: number;
    /**
     * The port list to translate the destination prefixes to.
     */
    dstAddrTranslationPorts?: string[];
    /**
     * The list of prefix list IDs.
     */
    dstAddrTranslationPrefixListIds?: number[];
    /**
     * The list of prefixes.
     */
    dstAddrTranslationPrefixes?: string[];
    /**
     * The translation type are: `STATIC_IP`, `STATIC_IP_AND_PORT` , `STATIC_PORT` and `NONE`. Default value is `NONE`.
     */
    dstAddrTranslationType?: string;
    /**
     * The egress type to use with the match. Options are are `ALKIRA_PUBLIC_IP` or `BYOIP`.
     */
    egressType?: string;
    /**
     * Whether the translation match and invalidate. Default is `true`.
     */
    srcAddrTranslationMatchAndInvalidate?: boolean;
    /**
     * The list of prefix list IDs.
     */
    srcAddrTranslationPrefixListIds?: number[];
    /**
     * The list of prefixes.
     */
    srcAddrTranslationPrefixes?: string[];
    /**
     * Whether to invalidate the track prefixes.
     */
    srcAddrTranslationRoutingTrackInvalidatePrefixes?: boolean;
    /**
     * The list of prefix list IDs.
     */
    srcAddrTranslationRoutingTrackPrefixListIds?: number[];
    /**
     * The list of prefixes to track.
     */
    srcAddrTranslationRoutingTrackPrefixes?: string[];
    /**
     * The translation type are: `STATIC_IP`, `DYNAMIC_IP_AND_PORT` and `NONE`. Default value is `NONE`.
     */
    srcAddrTranslationType?: string;
}

export interface PolicyNatRuleMatch {
    /**
     * The list of ports for destination.
     */
    dstPorts?: string[];
    /**
     * The list of prefix IDs as destination.
     */
    dstPrefixListIds?: number[];
    /**
     * The list of prefixes for destination.
     */
    dstPrefixes?: string[];
    /**
     * The following protocols are supported, `icmp`, `tcp`, `udp` or `any`.
     */
    protocol: string;
    /**
     * The list of ports for source.
     */
    srcPorts?: string[];
    /**
     * The list of prefix IDs as source.
     */
    srcPrefixListIds?: number[];
    /**
     * The list of prefixes for source.
     */
    srcPrefixes?: string[];
}

export interface PolicyPrefixListPrefixRange {
    /**
     * Integer less than `32` but greater than mask `m` in prefix and less than `le`.
     */
    ge?: number;
    /**
     * Integer less than `32` but greater than mask `m` in prefix
     */
    le?: number;
    /**
     * A valid CIDR as prefix in `x.x.x.x/m` format.
     */
    prefix: string;
}

export interface PolicyRoutingRule {
    /**
     * Action to be set on matched routes. Value could be `ALLOW`, `DENY` and `ALLOW_W_SET`.
     */
    action: string;
    /**
     * This acts as match all if enabledand should be used as exlusive match option.
     */
    matchAll?: boolean;
    /**
     * IDs of a AS Path Lists.
     */
    matchAsPathListIds?: number[];
    /**
     * IDs of Community Lists.
     */
    matchCommunityListIds?: number[];
    /**
     * List of CXPs.
     */
    matchCxps?: string[];
    /**
     * IDs of Extended Community Lists.
     */
    matchExtendedCommunityListIds?: number[];
    /**
     * IDs of groups.
     */
    matchGroupIds?: number[];
    /**
     * IDs of Prefix Lists.
     */
    matchPrefixListIds?: number[];
    /**
     * IDs of segment resources.
     */
    matchSegmentResourceIds?: number[];
    /**
     * The name of the rule.
     */
    name: string;
    /**
     * This allows to redistribute routes with lower preference to the restrictedCxps. Hence, this option can only be used with `RESTRICTED_CXPS` distribution_type. Also only 1 CXP is allowed in restricted_cxps, when this is set to `true`.
     */
    routesDistributionAsSecondary?: boolean;
    /**
     * List of cxps to which routes distribution is restricted. Should be used only with distributionType `RESTRICTED_CXPS`.
     */
    routesDistributionRestrictedCxps?: string[];
    /**
     * Redistribute routes that match with this rule match codition to. The value could be `ALL`, `LOCAL_ONLY` and `RESTRICTED_CXPS`.
     */
    routesDistributionType?: string;
    /**
     * System assigned number for each rule starting with `1000`. It defines the order of the rules.
     */
    sequenceNo: number;
    /**
     * Allows to prepend one or more AS numbers to the current AS PATH. Each AS number can be a value from 0 through 65535. Example - 100 100 100.
     */
    setAsPathPrepend?: string;
    /**
     * Allows to add one or more community attributes to the existing communities on the route. Community attribute is specified in this format: `as-number:community-value`. as-number and community-value can be a value from `0` through `65535`. Example: `65512:20 65512:21`.
     */
    setCommunity?: string;
    /**
     * Allows to add one or more extended community attributes to the existing extended communities on the route. Extended community attribute is specified in this format: `type:administrator:assigned-number`. Currently only type origin(soo) is supported.
     */
    setExtendedCommunity?: string;
}

export interface PolicyRuleListRule {
    priority: number;
    ruleId: number;
}

export interface SegmentResourceGroupPrefix {
    /**
     * The connector group ID associated with the segment resource.
     */
    groupId?: number;
    /**
     * The Prefix List ID associated with the segment resource.
     */
    prefixListId?: number;
}

export interface ServiceCheckpointInstance {
    /**
     * ID of Checkpoint Firewall Instance credential.
     */
    credentialId: string;
    /**
     * The ID of the checkpoint instance.
     */
    id: number;
    /**
     * The name of the checkpoint instance.
     */
    name: string;
    /**
     * The checkpoint instance sic keys.
     */
    sicKey: string;
}

export interface ServiceCheckpointManagementServer {
    /**
     * The configuration_mode specifies whether the firewall is to be automatically configured by Alkira or not. To automatically configure the firewall Alkira needs access to the CheckPoint management server. If you choose to use manual configuration Alkira will provide the customer information about the Checkpoint instances so that you can manually configure the firewall.
     */
    configurationMode: string;
    /**
     * ID of Checkpoint Firewall Managment server credential.
     */
    credentialId: string;
    /**
     * Management server domain.
     */
    domain?: string;
    /**
     * The ID of the global cidr list to be associated with the management server.
     */
    globalCidrListId: number;
    /**
     * Management server IPs.
     */
    ips: string[];
    /**
     * The password of the management server.
     */
    password?: string;
    /**
     * Specifies whether the management server is publicly reachable or not. If the reachability is private then you need to provide the segment to be used to access the management server. Default value is `PUBLIC`.
     */
    reachability?: string;
    /**
     * The IDs of the segment to be used to access the management server.
     */
    segmentId?: string;
    /**
     * The type of the management server. either `SMS` or `MDS`.
     */
    type: string;
    /**
     * The username of the management server.
     */
    username?: string;
}

export interface ServiceCheckpointSegmentOption {
    /**
     * The list of Groups associated with the zone.
     */
    groups: string[];
    /**
     * The ID of the segment.
     */
    segmentId: string;
    /**
     * The name of the associated zone. Default value is `DEFAULT`.
     */
    zoneName?: string;
}

export interface ServiceCiscoFtdvFirepowerManagementCenter {
    /**
     * An opaque identifier generated when storing firepower_management_center credentials.
     */
    credentialId: string;
    /**
     * List of IP addresses and CIDRs to access the Firepower Management Center.
     */
    ipAllowLists?: string[];
    /**
     * Firepower Management Center (FMC) password.
     */
    password: string;
    /**
     * ID of the segment accociated with the Firepower Management Center.
     */
    segmentId: string;
    /**
     * IP address of the Firepower Management Center.
     */
    serverIp: string;
    /**
     * Firepower Management Center (FMC) username.
     */
    username: string;
}

export interface ServiceCiscoFtdvInstance {
    /**
     * Firepower Firewall Admin Password.
     */
    adminPassword: string;
    /**
     * An opaque identifier generated when storing Cisco Firepower Firewall instance credentials.
     */
    credentialId: string;
    /**
     * FMC Registration Key.
     */
    fmcRegistrationKey: string;
    /**
     * FTDv NAT ID.
     */
    ftdvNatId?: string;
    /**
     * Hostname of the Firepower Firewall.
     */
    hostname: string;
    /**
     * ID of the Cisco Firepower Firewall instance.
     */
    id: number;
    /**
     * Cisco Firepower Firewall license type, either `BRING_YOUR_OWN` or `PAY_AS_YOU_GO`.
     */
    licenseType: string;
    /**
     * Cisco Firepower Firewall version. Please check Alkira Portal for all supported versions.
     */
    version: string;
}

export interface ServiceCiscoFtdvSegmentOption {
    /**
     * The list of Groups associated with the zone.
     */
    groups?: string[];
    /**
     * ID of the segment.
     */
    segmentId: string;
    /**
     * The name of the associated zone.
     */
    zoneName: string;
}

export interface ServiceFortinetInstance {
    /**
     * The ID of the Fortinet Firewall instance credentials. Required only when `license_type` is `BRING_YOUR_OWN`.
     */
    credentialId: string;
    /**
     * The ID of the Fortinet Firewall instance.
     */
    id: number;
    licenseKey?: string;
    /**
     * Fortinet license key file path. The path to the desired license key. 
     *
     *
     * There are two options for providing the required license key for Fortinet instance credentials. You can either input the value directly into the `license_key` field or provide the file path for the license key file using the `license_key_file_path`. Either `license_key` or `license_key_file_path` must have an input. If both are provided, the Alkira provider will treat the `license_key` field with precedence.
     */
    licenseKeyFilePath?: string;
    /**
     * The name of the Fortinet Firewall instance.
     */
    name?: string;
    /**
     * The serial_number of the Fortinet Firewall instance. Required only when `license_type` is `BRING_YOUR_OWN.
     */
    serialNumber?: string;
}

export interface ServiceFortinetSegmentOption {
    /**
     * The list of groups associated with the zone.
     */
    groups: string[];
    /**
     * The ID of the segment.
     */
    segmentId: string;
    /**
     * The name of the associated zone.
     */
    zoneName: string;
}

export interface ServiceInfobloxAnycast {
    /**
     * The `backup_cxps` to be used when the current Infoblox service is not available. It also needs to have a configured Infoblox service in order to take advantage of this feature. It is NOT required that the `backup_cxps` should have a configured Infoblox service before it can be designated as a backup.
     */
    backupCxps?: string[];
    /**
     * Defines if AnyCast should be enabled. Default value is `false`.
     */
    enabled?: boolean;
    /**
     * The IPs to be used when AnyCast is enabled. When AnyCast is enabled this list cannot be empty. The IPs used for AnyCast MUST NOT overlap the CIDR of `alkira.Segment` resource associated with the service.
     */
    ips?: string[];
}

export interface ServiceInfobloxGridMaster {
    /**
     * The credential ID of the Grid Master.
     */
    credentialId: string;
    /**
     * External indicates if a new grid master should be created or if an existing grid master should be used. Default value is `false`.
     */
    external?: boolean;
    /**
     * The IP address of the grid master.
     */
    ip: string;
    /**
     * Name of the grid master.
     */
    name: string;
    /**
     * The Grid Master password.
     */
    password: string;
    /**
     * The Grid Master user name.
     */
    username: string;
}

export interface ServiceInfobloxInstance {
    /**
     * This knob controls whether AnyCast is to be enabled for this instance or not. AnyCast can only be enabled on an instance if it is also enabled on the service. The default value is `false`.
     */
    anycastEnabled?: boolean;
    /**
     * The credential ID of the Infoblox instance.
     */
    credentialId: string;
    /**
     * The host name of the instance. The host name MUST always have a suffix `.localdomain`.
     */
    hostname: string;
    /**
     * The ID of the Infoblox instance.
     */
    id: number;
    /**
     * The model of the Infoblox instance.
     */
    model: string;
    /**
     * The password associated with the infoblox instance.
     */
    password: string;
    /**
     * The type of the Infoblox instance that is to be provisioned. The value could be `MASTER`, `MASTER_CANDIDATE` and `MEMBER`.
     */
    type: string;
    /**
     * The version of the Infoblox to be used. Please check Alkira Portal for all supported versions
     */
    version: string;
}

export interface ServicePanGlobalProtectSegmentOption {
    /**
     * Prefix for the global protect portal FQDN, this would be prepended to customer specific alkira domain For Example: if prefix is abc and tenant name is example then the FQDN would be abc.example.gpportal.alkira.com
     */
    portalFqdnPrefix: string;
    /**
     * Firewall security zone is created using the zone name for remote user sessions.
     */
    remoteUserZoneName: string;
    /**
     * The name of the segment to which the global protect options should apply
     */
    segmentId: string;
    /**
     * The name of the service group. A group with the same name will be created.
     */
    serviceGroupName: string;
}

export interface ServicePanInstance {
    /**
     * PAN instance auth code. Only required when `license_type` is `BRING_YOUR_OWN`.
     */
    authCode?: string;
    /**
     * PAN instance auth key. This is only required when `panorama_enabled` is set to `true`.
     */
    authKey?: string;
    /**
     * ID of PAN instance credential.
     */
    credentialId: string;
    /**
     * These options should be set only when global protect is enabled on service. These are set per segment. It is expected that on a segment where global protect is enabled at least 1 instance should be set with portal_enabled and at least one with gateway_enabled. It can be on the same instance or a different instance under the segment.
     */
    globalProtectSegmentOptions?: outputs.ServicePanInstanceGlobalProtectSegmentOption[];
    /**
     * The ID of the PAN instance.
     */
    id: number;
    /**
     * The name of the PAN instance.
     */
    name?: string;
}

export interface ServicePanInstanceGlobalProtectSegmentOption {
    /**
     * indicates if the Global Protect Gateway is enabled on this PAN instance
     */
    gatewayEnabled: boolean;
    /**
     * indicates if the GlobalProtect Portal is enabled on this PAN instance
     */
    portalEnabled: boolean;
    /**
     * Prefix List with Client IP Pool.
     */
    prefixListId: number;
    /**
     * The segment ID for Global Protect options.
     */
    segmentId: string;
}

export interface ServicePanSegmentOption {
    /**
     * The list of groups associated with the zone.
     */
    groups: string[];
    /**
     * The ID of the segment.
     */
    segmentId: string;
    /**
     * The name of the associated firewall zone.
     */
    zoneName: string;
}

export interface ServiceZscalerIpsecConfiguration {
    /**
     * The IPSEC phase 2 DH Group to be used. Input value must be either `MODP1024`or `MODP2048`. The default value is `MODP1024`
     */
    espDhGroupNumber?: string;
    /**
     * The IPSEC phase 2 Encryption Algorithm to be used. Input value must be either `NULL` or `AES256CBC`. The default value is `NULL`
     */
    espEncryptionAlgorithm?: string;
    /**
     * The IPSEC phase 2 Integrity Algorithm to be used. Input value must be either `MD5` or `SHA256`. The default value is `MD5`.
     */
    espIntegrityAlgorithm?: string;
    /**
     * The type of health check. Input values must be either `IKE_STATUS` `PING_PROBE` or `HTTP_PROBE`
     */
    healthCheckType: string;
    /**
     * The url to check connection to health, should be provided when health check type is 'HTTP_PROBE'
     */
    httpProbeUrl?: string;
    /**
     * The IPSEC phase 1 DH Group to be used. Input value must either be `MODP1024` or `MODP2048`. The default is `MODP1024`
     */
    ikeDhGroupNumber?: string;
    /**
     * The IPSEC phase 1 Encryption Algorithm to be used. Only `AES256CBC` is allowed. The default value is `AES256CBC`.
     */
    ikeEncryptionAlgorithm?: string;
    /**
     * The IPSEC phase 1 Integrity Algorithm to be used. Only `SHA256` is allowed. The default value is `SHA256`.
     */
    ikeIntegrityAlgorithm?: string;
    /**
     * The local FQDN Id.
     */
    localFpdnId: string;
    /**
     * The ping destination to check connection health. It should be provided when `health_check_type` is `PING_PROBE`
     */
    pingProbeIp?: string;
    /**
     * The preshared key.
     */
    preSharedKey: string;
}

