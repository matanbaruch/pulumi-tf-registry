// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export function getStoragePhysicalDisk(args?: GetStoragePhysicalDiskArgs, opts?: pulumi.InvokeOptions): Promise<GetStoragePhysicalDiskResult> {
    args = args || {};

    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("intersight:index/getStoragePhysicalDisk:getStoragePhysicalDisk", {
        "accountMoid": args.accountMoid,
        "additionalProperties": args.additionalProperties,
        "ancestors": args.ancestors,
        "backgroundOperations": args.backgroundOperations,
        "blockSize": args.blockSize,
        "bootable": args.bootable,
        "classId": args.classId,
        "configurationCheckpoint": args.configurationCheckpoint,
        "configurationState": args.configurationState,
        "createTime": args.createTime,
        "description": args.description,
        "deviceMoId": args.deviceMoId,
        "disabledForRemoval": args.disabledForRemoval,
        "discoveredPath": args.discoveredPath,
        "diskId": args.diskId,
        "diskState": args.diskState,
        "dn": args.dn,
        "domainGroupMoid": args.domainGroupMoid,
        "driveFirmware": args.driveFirmware,
        "driveState": args.driveState,
        "encryptionStatus": args.encryptionStatus,
        "failurePredicted": args.failurePredicted,
        "fdeCapable": args.fdeCapable,
        "hotSpareType": args.hotSpareType,
        "id": args.id,
        "indicatorLed": args.indicatorLed,
        "inventoryDeviceInfo": args.inventoryDeviceInfo,
        "isPlatformSupported": args.isPlatformSupported,
        "isUpgraded": args.isUpgraded,
        "linkSpeed": args.linkSpeed,
        "linkState": args.linkState,
        "locatorLed": args.locatorLed,
        "maximumOperatingTemperature": args.maximumOperatingTemperature,
        "mediaErrorCount": args.mediaErrorCount,
        "modTime": args.modTime,
        "model": args.model,
        "moid": args.moid,
        "name": args.name,
        "nonCoercedSizeBytes": args.nonCoercedSizeBytes,
        "numBlocks": args.numBlocks,
        "objectType": args.objectType,
        "operPowerState": args.operPowerState,
        "operQualifierReason": args.operQualifierReason,
        "operability": args.operability,
        "operatingTemperature": args.operatingTemperature,
        "owners": args.owners,
        "parent": args.parent,
        "partNumber": args.partNumber,
        "percentLifeLeft": args.percentLifeLeft,
        "percentReservedCapacityConsumed": args.percentReservedCapacityConsumed,
        "performancePercent": args.performancePercent,
        "permissionResources": args.permissionResources,
        "physicalBlockSize": args.physicalBlockSize,
        "physicalDiskExtensions": args.physicalDiskExtensions,
        "pid": args.pid,
        "powerCycleCount": args.powerCycleCount,
        "powerOnHours": args.powerOnHours,
        "powerOnHoursPercentage": args.powerOnHoursPercentage,
        "predictedMediaLifeLeftPercent": args.predictedMediaLifeLeftPercent,
        "predictiveFailureCount": args.predictiveFailureCount,
        "presence": args.presence,
        "previousFru": args.previousFru,
        "protocol": args.protocol,
        "rawSize": args.rawSize,
        "readErrorCountThreshold": args.readErrorCountThreshold,
        "readIoErrorCount": args.readIoErrorCount,
        "registeredDevice": args.registeredDevice,
        "revision": args.revision,
        "rn": args.rn,
        "runningFirmwares": args.runningFirmwares,
        "sasPorts": args.sasPorts,
        "secured": args.secured,
        "serial": args.serial,
        "sharedScope": args.sharedScope,
        "size": args.size,
        "storageController": args.storageController,
        "storageEnclosure": args.storageEnclosure,
        "tags": args.tags,
        "thermal": args.thermal,
        "thresholdOperatingTemperature": args.thresholdOperatingTemperature,
        "type": args.type,
        "variantType": args.variantType,
        "vendor": args.vendor,
        "versionContext": args.versionContext,
        "wearStatusInDays": args.wearStatusInDays,
        "writeErrorCountThreshold": args.writeErrorCountThreshold,
        "writeIoErrorCount": args.writeIoErrorCount,
    }, opts, utilities.getPackage());
}

/**
 * A collection of arguments for invoking getStoragePhysicalDisk.
 */
export interface GetStoragePhysicalDiskArgs {
    accountMoid?: string;
    additionalProperties?: string;
    ancestors?: inputs.GetStoragePhysicalDiskAncestor[];
    backgroundOperations?: string;
    blockSize?: string;
    bootable?: string;
    classId?: string;
    configurationCheckpoint?: string;
    configurationState?: string;
    createTime?: string;
    description?: string;
    deviceMoId?: string;
    disabledForRemoval?: boolean;
    discoveredPath?: string;
    diskId?: string;
    diskState?: string;
    dn?: string;
    domainGroupMoid?: string;
    driveFirmware?: string;
    driveState?: string;
    encryptionStatus?: string;
    failurePredicted?: boolean;
    fdeCapable?: string;
    hotSpareType?: string;
    id?: string;
    indicatorLed?: string;
    inventoryDeviceInfo?: inputs.GetStoragePhysicalDiskInventoryDeviceInfo;
    isPlatformSupported?: boolean;
    isUpgraded?: boolean;
    linkSpeed?: string;
    linkState?: string;
    locatorLed?: inputs.GetStoragePhysicalDiskLocatorLed;
    maximumOperatingTemperature?: number;
    mediaErrorCount?: number;
    modTime?: string;
    model?: string;
    moid?: string;
    name?: string;
    nonCoercedSizeBytes?: number;
    numBlocks?: string;
    objectType?: string;
    operPowerState?: string;
    operQualifierReason?: string;
    operability?: string;
    operatingTemperature?: number;
    owners?: string[];
    parent?: inputs.GetStoragePhysicalDiskParent;
    partNumber?: string;
    percentLifeLeft?: number;
    percentReservedCapacityConsumed?: number;
    performancePercent?: number;
    permissionResources?: inputs.GetStoragePhysicalDiskPermissionResource[];
    physicalBlockSize?: string;
    physicalDiskExtensions?: inputs.GetStoragePhysicalDiskPhysicalDiskExtension[];
    pid?: string;
    powerCycleCount?: number;
    powerOnHours?: number;
    powerOnHoursPercentage?: number;
    predictedMediaLifeLeftPercent?: number;
    predictiveFailureCount?: number;
    presence?: string;
    previousFru?: inputs.GetStoragePhysicalDiskPreviousFru;
    protocol?: string;
    rawSize?: string;
    readErrorCountThreshold?: number;
    readIoErrorCount?: number;
    registeredDevice?: inputs.GetStoragePhysicalDiskRegisteredDevice;
    revision?: string;
    rn?: string;
    runningFirmwares?: inputs.GetStoragePhysicalDiskRunningFirmware[];
    sasPorts?: inputs.GetStoragePhysicalDiskSasPort[];
    secured?: string;
    serial?: string;
    sharedScope?: string;
    size?: string;
    storageController?: inputs.GetStoragePhysicalDiskStorageController;
    storageEnclosure?: inputs.GetStoragePhysicalDiskStorageEnclosure;
    tags?: inputs.GetStoragePhysicalDiskTag[];
    thermal?: string;
    thresholdOperatingTemperature?: number;
    type?: string;
    variantType?: string;
    vendor?: string;
    versionContext?: inputs.GetStoragePhysicalDiskVersionContext;
    wearStatusInDays?: number;
    writeErrorCountThreshold?: number;
    writeIoErrorCount?: number;
}

/**
 * A collection of values returned by getStoragePhysicalDisk.
 */
export interface GetStoragePhysicalDiskResult {
    readonly accountMoid?: string;
    readonly additionalProperties?: string;
    readonly ancestors?: outputs.GetStoragePhysicalDiskAncestor[];
    readonly backgroundOperations?: string;
    readonly blockSize?: string;
    readonly bootable?: string;
    readonly classId?: string;
    readonly configurationCheckpoint?: string;
    readonly configurationState?: string;
    readonly createTime?: string;
    readonly description?: string;
    readonly deviceMoId?: string;
    readonly disabledForRemoval?: boolean;
    readonly discoveredPath?: string;
    readonly diskId?: string;
    readonly diskState?: string;
    readonly dn?: string;
    readonly domainGroupMoid?: string;
    readonly driveFirmware?: string;
    readonly driveState?: string;
    readonly encryptionStatus?: string;
    readonly failurePredicted?: boolean;
    readonly fdeCapable?: string;
    readonly hotSpareType?: string;
    readonly id: string;
    readonly indicatorLed?: string;
    readonly inventoryDeviceInfo?: outputs.GetStoragePhysicalDiskInventoryDeviceInfo;
    readonly isPlatformSupported?: boolean;
    readonly isUpgraded?: boolean;
    readonly linkSpeed?: string;
    readonly linkState?: string;
    readonly locatorLed?: outputs.GetStoragePhysicalDiskLocatorLed;
    readonly maximumOperatingTemperature?: number;
    readonly mediaErrorCount?: number;
    readonly modTime?: string;
    readonly model?: string;
    readonly moid?: string;
    readonly name?: string;
    readonly nonCoercedSizeBytes?: number;
    readonly numBlocks?: string;
    readonly objectType?: string;
    readonly operPowerState?: string;
    readonly operQualifierReason?: string;
    readonly operability?: string;
    readonly operatingTemperature?: number;
    readonly owners?: string[];
    readonly parent?: outputs.GetStoragePhysicalDiskParent;
    readonly partNumber?: string;
    readonly percentLifeLeft?: number;
    readonly percentReservedCapacityConsumed?: number;
    readonly performancePercent?: number;
    readonly permissionResources?: outputs.GetStoragePhysicalDiskPermissionResource[];
    readonly physicalBlockSize?: string;
    readonly physicalDiskExtensions?: outputs.GetStoragePhysicalDiskPhysicalDiskExtension[];
    readonly pid?: string;
    readonly powerCycleCount?: number;
    readonly powerOnHours?: number;
    readonly powerOnHoursPercentage?: number;
    readonly predictedMediaLifeLeftPercent?: number;
    readonly predictiveFailureCount?: number;
    readonly presence?: string;
    readonly previousFru?: outputs.GetStoragePhysicalDiskPreviousFru;
    readonly protocol?: string;
    readonly rawSize?: string;
    readonly readErrorCountThreshold?: number;
    readonly readIoErrorCount?: number;
    readonly registeredDevice?: outputs.GetStoragePhysicalDiskRegisteredDevice;
    readonly results: outputs.GetStoragePhysicalDiskResult[];
    readonly revision?: string;
    readonly rn?: string;
    readonly runningFirmwares?: outputs.GetStoragePhysicalDiskRunningFirmware[];
    readonly sasPorts?: outputs.GetStoragePhysicalDiskSasPort[];
    readonly secured?: string;
    readonly serial?: string;
    readonly sharedScope?: string;
    readonly size?: string;
    readonly storageController?: outputs.GetStoragePhysicalDiskStorageController;
    readonly storageEnclosure?: outputs.GetStoragePhysicalDiskStorageEnclosure;
    readonly tags?: outputs.GetStoragePhysicalDiskTag[];
    readonly thermal?: string;
    readonly thresholdOperatingTemperature?: number;
    readonly type?: string;
    readonly variantType?: string;
    readonly vendor?: string;
    readonly versionContext?: outputs.GetStoragePhysicalDiskVersionContext;
    readonly wearStatusInDays?: number;
    readonly writeErrorCountThreshold?: number;
    readonly writeIoErrorCount?: number;
}
export function getStoragePhysicalDiskOutput(args?: GetStoragePhysicalDiskOutputArgs, opts?: pulumi.InvokeOptions): pulumi.Output<GetStoragePhysicalDiskResult> {
    return pulumi.output(args).apply((a: any) => getStoragePhysicalDisk(a, opts))
}

/**
 * A collection of arguments for invoking getStoragePhysicalDisk.
 */
export interface GetStoragePhysicalDiskOutputArgs {
    accountMoid?: pulumi.Input<string>;
    additionalProperties?: pulumi.Input<string>;
    ancestors?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskAncestorArgs>[]>;
    backgroundOperations?: pulumi.Input<string>;
    blockSize?: pulumi.Input<string>;
    bootable?: pulumi.Input<string>;
    classId?: pulumi.Input<string>;
    configurationCheckpoint?: pulumi.Input<string>;
    configurationState?: pulumi.Input<string>;
    createTime?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    deviceMoId?: pulumi.Input<string>;
    disabledForRemoval?: pulumi.Input<boolean>;
    discoveredPath?: pulumi.Input<string>;
    diskId?: pulumi.Input<string>;
    diskState?: pulumi.Input<string>;
    dn?: pulumi.Input<string>;
    domainGroupMoid?: pulumi.Input<string>;
    driveFirmware?: pulumi.Input<string>;
    driveState?: pulumi.Input<string>;
    encryptionStatus?: pulumi.Input<string>;
    failurePredicted?: pulumi.Input<boolean>;
    fdeCapable?: pulumi.Input<string>;
    hotSpareType?: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    indicatorLed?: pulumi.Input<string>;
    inventoryDeviceInfo?: pulumi.Input<inputs.GetStoragePhysicalDiskInventoryDeviceInfoArgs>;
    isPlatformSupported?: pulumi.Input<boolean>;
    isUpgraded?: pulumi.Input<boolean>;
    linkSpeed?: pulumi.Input<string>;
    linkState?: pulumi.Input<string>;
    locatorLed?: pulumi.Input<inputs.GetStoragePhysicalDiskLocatorLedArgs>;
    maximumOperatingTemperature?: pulumi.Input<number>;
    mediaErrorCount?: pulumi.Input<number>;
    modTime?: pulumi.Input<string>;
    model?: pulumi.Input<string>;
    moid?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    nonCoercedSizeBytes?: pulumi.Input<number>;
    numBlocks?: pulumi.Input<string>;
    objectType?: pulumi.Input<string>;
    operPowerState?: pulumi.Input<string>;
    operQualifierReason?: pulumi.Input<string>;
    operability?: pulumi.Input<string>;
    operatingTemperature?: pulumi.Input<number>;
    owners?: pulumi.Input<pulumi.Input<string>[]>;
    parent?: pulumi.Input<inputs.GetStoragePhysicalDiskParentArgs>;
    partNumber?: pulumi.Input<string>;
    percentLifeLeft?: pulumi.Input<number>;
    percentReservedCapacityConsumed?: pulumi.Input<number>;
    performancePercent?: pulumi.Input<number>;
    permissionResources?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskPermissionResourceArgs>[]>;
    physicalBlockSize?: pulumi.Input<string>;
    physicalDiskExtensions?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskPhysicalDiskExtensionArgs>[]>;
    pid?: pulumi.Input<string>;
    powerCycleCount?: pulumi.Input<number>;
    powerOnHours?: pulumi.Input<number>;
    powerOnHoursPercentage?: pulumi.Input<number>;
    predictedMediaLifeLeftPercent?: pulumi.Input<number>;
    predictiveFailureCount?: pulumi.Input<number>;
    presence?: pulumi.Input<string>;
    previousFru?: pulumi.Input<inputs.GetStoragePhysicalDiskPreviousFruArgs>;
    protocol?: pulumi.Input<string>;
    rawSize?: pulumi.Input<string>;
    readErrorCountThreshold?: pulumi.Input<number>;
    readIoErrorCount?: pulumi.Input<number>;
    registeredDevice?: pulumi.Input<inputs.GetStoragePhysicalDiskRegisteredDeviceArgs>;
    revision?: pulumi.Input<string>;
    rn?: pulumi.Input<string>;
    runningFirmwares?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskRunningFirmwareArgs>[]>;
    sasPorts?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskSasPortArgs>[]>;
    secured?: pulumi.Input<string>;
    serial?: pulumi.Input<string>;
    sharedScope?: pulumi.Input<string>;
    size?: pulumi.Input<string>;
    storageController?: pulumi.Input<inputs.GetStoragePhysicalDiskStorageControllerArgs>;
    storageEnclosure?: pulumi.Input<inputs.GetStoragePhysicalDiskStorageEnclosureArgs>;
    tags?: pulumi.Input<pulumi.Input<inputs.GetStoragePhysicalDiskTagArgs>[]>;
    thermal?: pulumi.Input<string>;
    thresholdOperatingTemperature?: pulumi.Input<number>;
    type?: pulumi.Input<string>;
    variantType?: pulumi.Input<string>;
    vendor?: pulumi.Input<string>;
    versionContext?: pulumi.Input<inputs.GetStoragePhysicalDiskVersionContextArgs>;
    wearStatusInDays?: pulumi.Input<number>;
    writeErrorCountThreshold?: pulumi.Input<number>;
    writeIoErrorCount?: pulumi.Input<number>;
}
