// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ClusterPeersResourceRemote {
    /**
     * list of the remote ip addresses
     */
    ipAddresses: string[];
}

export interface ClusterPeersResourceSourceDetails {
    /**
     * list of the source ip addresses
     */
    ipAddresses: string[];
}

export interface ClusterResourceCertificate {
    id: string;
}

export interface ClusterResourceLicense {
    /**
     * list of license keys
     */
    keys?: string[];
}

export interface ClusterResourceManagementInterface {
    /**
     * The UUID that uniquely identifies the interface.
     */
    id: string;
    /**
     * IP formation
     */
    ip: outputs.ClusterResourceManagementInterfaceIp;
    /**
     * The name of the interface. If only the name is provided, the SVM scope must be provided by the object this object is embedded in.
     */
    name: string;
}

export interface ClusterResourceManagementInterfaceIp {
    /**
     * IP address
     */
    address: string;
}

export interface ClusterResourceTimezone {
    /**
     * Name of the time zone
     */
    name: string;
}

export interface ClusterResourceVersion {
    /**
     * ONTAP software version
     */
    full: string;
}

export interface ClusterScheduleResourceCron {
    /**
     * List of cluster schedule days
     */
    days?: number[];
    /**
     * List of cluster schedule hours
     */
    hours?: number[];
    /**
     * List of cluster schedule minutes
     */
    minutes?: number[];
    /**
     * List of cluster schedule months
     */
    months?: number[];
    /**
     * List of cluster schedule weekdays
     */
    weekdays?: number[];
}

export interface GetClusterDataSourceCertificate {
    id: string;
}

export interface GetClusterDataSourceManagementInterface {
    /**
     * ID
     */
    id: string;
    /**
     * IP address
     */
    ip: outputs.GetClusterDataSourceManagementInterfaceIp;
    /**
     * Name
     */
    name: string;
}

export interface GetClusterDataSourceManagementInterfaceIp {
    /**
     * IP address
     */
    address: string;
}

export interface GetClusterDataSourceNode {
    managementIpAddresses: string[];
    name: string;
}

export interface GetClusterDataSourceTimezone {
    /**
     * Time zone
     */
    name: string;
}

export interface GetClusterDataSourceVersion {
    /**
     * ONTAP software version
     */
    full: string;
}

export interface GetClusterLicensingLicenseDataSourceLicense {
    /**
     * active of the license
     */
    active: boolean;
    /**
     * compliance of the license
     */
    compliance: outputs.GetClusterLicensingLicenseDataSourceLicenseCompliance;
    /**
     * evaluation of the license
     */
    evaluation: boolean;
    /**
     * installed license of the license
     */
    installedLicense: string;
    /**
     * owner of the license
     */
    owner: string;
    /**
     * Serial Number of the license
     */
    serialNumber: string;
}

export interface GetClusterLicensingLicenseDataSourceLicenseCompliance {
    /**
     * state of the license
     */
    state: string;
}

export interface GetClusterLicensingLicensesDataSourceClusterLicensingLicense {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Licenses of the license
     */
    licenses: outputs.GetClusterLicensingLicensesDataSourceClusterLicensingLicenseLicense[];
    /**
     * ClusterLicensingLicense name
     */
    name: string;
    /**
     * Scope of the license
     */
    scope: string;
    /**
     * State of the license
     */
    state: string;
}

export interface GetClusterLicensingLicensesDataSourceClusterLicensingLicenseLicense {
    /**
     * active of the license
     */
    active: boolean;
    /**
     * compliance of the license
     */
    compliance: outputs.GetClusterLicensingLicensesDataSourceClusterLicensingLicenseLicenseCompliance;
    /**
     * evaluation of the license
     */
    evaluation: boolean;
    /**
     * installed_license of the license
     */
    installedLicense: string;
    /**
     * owner of the license
     */
    owner: string;
    /**
     * Serial Number of the license
     */
    serialNumber: string;
}

export interface GetClusterLicensingLicensesDataSourceClusterLicensingLicenseLicenseCompliance {
    /**
     * state of the license
     */
    state: string;
}

export interface GetClusterLicensingLicensesDataSourceFilter {
    /**
     * ClusterLicensingLicense name
     */
    name?: string;
}

export interface GetClusterPeerDataSourceEncryption {
    /**
     * Proposed encryption of cluster peer
     */
    proposed: string;
    /**
     * State of encryption of cluster peer
     */
    state: string;
}

export interface GetClusterPeerDataSourceIpspace {
    /**
     * Name of ipspace of cluster peer
     */
    name: string;
}

export interface GetClusterPeerDataSourceRemote {
    /**
     * List of IP addresses of remote cluster
     */
    ipAddresses: string[];
    /**
     * Name of remote cluster
     */
    name: string;
}

export interface GetClusterPeerDataSourceStatus {
    /**
     * State of cluster peer
     */
    state: string;
}

export interface GetClusterPeersDataSourceClusterPeer {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Encryption of cluster peer
     */
    encryption: outputs.GetClusterPeersDataSourceClusterPeerEncryption;
    /**
     * ID of cluster peer
     */
    id: string;
    /**
     * IP address
     */
    ipAddress: string;
    /**
     * Ipspace of cluster peer
     */
    ipspace: outputs.GetClusterPeersDataSourceClusterPeerIpspace;
    /**
     * ClusterPeer name
     */
    name: string;
    /**
     * List of peer applications
     */
    peerApplications: string[];
    /**
     * Remote cluster
     */
    remote: outputs.GetClusterPeersDataSourceClusterPeerRemote;
    /**
     * Status of cluster peer
     */
    status: outputs.GetClusterPeersDataSourceClusterPeerStatus;
}

export interface GetClusterPeersDataSourceClusterPeerEncryption {
    /**
     * Proposed encryption of cluster peer
     */
    proposed: string;
    /**
     * State of encryption of cluster peer
     */
    state: string;
}

export interface GetClusterPeersDataSourceClusterPeerIpspace {
    /**
     * Name of ipspace of cluster peer
     */
    name: string;
}

export interface GetClusterPeersDataSourceClusterPeerRemote {
    /**
     * List of IP addresses of remote cluster
     */
    ipAddresses: string[];
    /**
     * Name of remote cluster
     */
    name: string;
}

export interface GetClusterPeersDataSourceClusterPeerStatus {
    /**
     * State of cluster peer
     */
    state: string;
}

export interface GetClusterPeersDataSourceFilter {
    /**
     * ClusterPeer name
     */
    name?: string;
}

export interface GetClusterScheduleDataSourceCron {
    /**
     * List of cluster schedule days
     */
    days: number[];
    /**
     * List of cluster schedule hours
     */
    hours: number[];
    /**
     * List of cluster schedule minutes
     */
    minutes: number[];
    /**
     * List of cluster schedule months
     */
    months: number[];
    /**
     * List of cluster schedule weekdays
     */
    weekdays: number[];
}

export interface GetClusterSchedulesDataSourceClusterSchedule {
    cron: outputs.GetClusterSchedulesDataSourceClusterScheduleCron;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Cluster schedule UUID
     */
    id: string;
    /**
     * Cluster schedule interval
     */
    interval: string;
    /**
     * ClusterSchedule name
     */
    name: string;
    /**
     * Cluster schedule scope
     */
    scope: string;
    /**
     * Cluster schdeule type
     */
    type: string;
}

export interface GetClusterSchedulesDataSourceClusterScheduleCron {
    /**
     * List of cluster schedule days
     */
    days: number[];
    /**
     * List of cluster schedule hours
     */
    hours: number[];
    /**
     * List of cluster schedule minutes
     */
    minutes: number[];
    /**
     * List of cluster schedule months
     */
    months: number[];
    /**
     * List of cluster schedule weekdays
     */
    weekdays: number[];
}

export interface GetClusterSchedulesDataSourceFilter {
    /**
     * Cluster schdeule type
     */
    type?: string;
}

export interface GetNameServicesDnssDataSourceFilter {
    /**
     * DNS domain such as 'sales.bar.com'. The first domain is the one that the svm belongs to.
     */
    dnsDomains?: string;
    /**
     * IPv4 address of name servers such as '123.123.123.123'.
     */
    nameServers?: string;
    /**
     * IPInterface svm name.
     */
    svmName?: string;
}

export interface GetNameServicesDnssDataSourceNameServicesDnss {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * List of DNS domains such as 'sales.bar.com'. The first domain is the one that the svm belongs to.
     */
    dnsDomains: string[];
    /**
     * List of IPv4 addresses of name servers such as '123.123.123.123'.
     */
    nameServers: string[];
    /**
     * IPInterface svm name
     */
    svmName: string;
    /**
     * UUID of svm
     */
    svmUuid: string;
}

export interface GetNameServicesLdapsDataSourceFilter {
    /**
     * Specifies the default search scope for LDAP queries
     */
    baseScope?: string;
    /**
     * The minimum bind authentication level
     */
    minBindLevel?: string;
    /**
     * NameServicesLDAP svm name
     */
    svmName?: string;
}

export interface GetNameServicesLdapsDataSourceNameServicesLdap {
    /**
     * Specifies the name of the Active Directory domain used to discover LDAP servers for use by this client
     */
    adDomain: string;
    /**
     * Specifies the default base DN for all searches
     */
    baseDn: string;
    /**
     * Specifies the default search scope for LDAP queries
     */
    baseScope: string;
    /**
     * Specifies whether or not CIFS server's credentials are used to bind to the LDAP server
     */
    bindAsCifsServer: boolean;
    /**
     * Specifies the user that binds to the LDAP servers
     */
    bindDn: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Specifies whether or not LDAPS is enabled
     */
    ldapsEnabled: boolean;
    /**
     * The minimum bind authentication level
     */
    minBindLevel: string;
    /**
     * The port used to connect to the LDAP Servers
     */
    port: number;
    /**
     * This parameter specifies a list of LDAP servers preferred over discovered servers
     */
    preferredAdServers: string[];
    /**
     * Specifies the timeout for LDAP queries
     */
    queryTimeout: number;
    /**
     * Specifies whether or not LDAP referral is enabled
     */
    referralEnabled: boolean;
    /**
     * The name of the schema template used by the SVM
     */
    schema: string;
    /**
     * List of LDAP servers used for this client configuration
     */
    servers: string[];
    /**
     * Specifies the level of security to be used for LDAP communications
     */
    sessionSecurity: string;
    /**
     * IPInterface svm name
     */
    svmName: string;
    /**
     * Specifies whether or not to use Start TLS over LDAP connections
     */
    useStartTls: boolean;
}

export interface GetNetworkingIpInterfaceDataSourceIp {
    /**
     * IPInterface IP address
     */
    address: string;
    /**
     * IPInterface IP netmask
     */
    netmask: number;
}

export interface GetNetworkingIpInterfaceDataSourceLocation {
    /**
     * IPInterface home node
     */
    homeNode: string;
    /**
     * IPInterface home port
     */
    homePort: string;
}

export interface GetNetworkingIpInterfacesDataSourceFilter {
    /**
     * IPInterface name
     */
    name?: string;
    /**
     * IPInterface scope
     */
    scope?: string;
    /**
     * IPInterface svm name
     */
    svmName?: string;
}

export interface GetNetworkingIpInterfacesDataSourceIpInterface {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    ip: outputs.GetNetworkingIpInterfacesDataSourceIpInterfaceIp;
    location: outputs.GetNetworkingIpInterfacesDataSourceIpInterfaceLocation;
    /**
     * IPInterface name
     */
    name: string;
    /**
     * IPInterface scope
     */
    scope: string;
    /**
     * IPInterface svm name
     */
    svmName: string;
}

export interface GetNetworkingIpInterfacesDataSourceIpInterfaceIp {
    /**
     * IPInterface IP address
     */
    address: string;
    /**
     * IPInterface IP netmask
     */
    netmask: number;
}

export interface GetNetworkingIpInterfacesDataSourceIpInterfaceLocation {
    /**
     * IPInterface home node
     */
    homeNode: string;
    /**
     * IPInterface home port
     */
    homePort: string;
}

export interface GetNetworkingIpRouteDataSourceDestination {
    /**
     * IPv4 or IPv6 address
     */
    address: string;
    /**
     * netmask length (16) or IPv4 mask (255.255.0.0). For IPv6, valid range is 1 to 127.
     */
    netmask: string;
}

export interface GetNetworkingIpRoutesDataSourceFilter {
    /**
     * destination IP address information
     */
    destination?: outputs.GetNetworkingIpRoutesDataSourceFilterDestination;
    /**
     * The IP address of the gateway router leading to the destination.
     */
    gateway?: string;
    /**
     * IP Route svm name
     */
    svmName?: string;
}

export interface GetNetworkingIpRoutesDataSourceFilterDestination {
    /**
     * IPv4 or IPv6 address
     */
    address?: string;
    /**
     * netmask length (16) or IPv4 mask (255.255.0.0). For IPv6, valid range is 1 to 127.
     */
    netmask?: string;
}

export interface GetNetworkingIpRoutesDataSourceIpRoute {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * destination IP address information
     */
    destination: outputs.GetNetworkingIpRoutesDataSourceIpRouteDestination;
    /**
     * The IP address of the gateway router leading to the destination.
     */
    gateway: string;
    /**
     * Indicates a preference order between several routes to the same destination.
     */
    metric: number;
    /**
     * IPInterface svm name
     */
    svmName?: string;
}

export interface GetNetworkingIpRoutesDataSourceIpRouteDestination {
    /**
     * IPv4 or IPv6 address
     */
    address: string;
    /**
     * netmask length (16) or IPv4 mask (255.255.0.0). For IPv6, valid range is 1 to 127.
     */
    netmask: string;
}

export interface GetProtocolsCifsLocalGroupDataSourceMember {
    /**
     * Cifs Local Group member
     */
    name: string;
}

export interface GetProtocolsCifsLocalGroupsDataSourceFilter {
    /**
     * Cifs Local Group name
     */
    name?: string;
    /**
     * Cifs Local Group svm name
     */
    svmName?: string;
}

export interface GetProtocolsCifsLocalGroupsDataSourceProtocolsCifsLocalGroup {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Cifs Local Group description
     */
    description: string;
    /**
     * Cifs Local Group identifier
     */
    id: string;
    /**
     * Cifs Local Group members
     */
    members: outputs.GetProtocolsCifsLocalGroupsDataSourceProtocolsCifsLocalGroupMember[];
    /**
     * Cifs Local Group name
     */
    name: string;
    /**
     * Cifs Local Group svm name
     */
    svmName: string;
}

export interface GetProtocolsCifsLocalGroupsDataSourceProtocolsCifsLocalGroupMember {
    /**
     * Cifs Local Group member names
     */
    name: string;
}

export interface GetProtocolsCifsLocalUserDataSourceMembership {
    /**
     * CifsLocalUser membership name
     */
    name: string;
}

export interface GetProtocolsCifsLocalUsersDataSourceFilter {
    /**
     * CifsLocalUser name
     */
    name?: string;
    /**
     * CifsLocalUser svm name
     */
    svmName?: string;
}

export interface GetProtocolsCifsLocalUsersDataSourceProtocolsCifsLocalUser {
    /**
     * CifsLocalUser account disabled
     */
    accountDisabled: boolean;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * CifsLocalUser description
     */
    description: string;
    /**
     * CifsLocalUser full name
     */
    fullName: string;
    /**
     * CifsLocalUser id
     */
    id: string;
    /**
     * CifsLocalUser membership
     */
    memberships: outputs.GetProtocolsCifsLocalUsersDataSourceProtocolsCifsLocalUserMembership[];
    /**
     * CifsLocalUser name
     */
    name: string;
    /**
     * CifsLocalUser svm name
     */
    svmName: string;
}

export interface GetProtocolsCifsLocalUsersDataSourceProtocolsCifsLocalUserMembership {
    /**
     * CifsLocalUser membership name
     */
    name: string;
}

export interface GetProtocolsCifsServiceDataSourceAdDomain {
    /**
     * Fully qualified domain name of the Windows Active Directory to which this CIFS server belongs
     */
    fqdn: string;
    /**
     * Organizational unit
     */
    organizationalUnit: string;
    /**
     * Account password used to add this CIFS server to the Active Directory
     */
    password: string;
    /**
     * User account with the access to add the CIFS server to the Active Directory
     */
    user: string;
}

export interface GetProtocolsCifsServiceDataSourceNetbios {
    /**
     * list of one or more NetBIOS aliases for the CIFS server
     */
    aliases: string[];
    /**
     * NetBios name service (NBNS) is enabled for the CIFS
     */
    enabled: boolean;
    /**
     * list of Windows Internet Name Server (WINS) addresses that manage and map the NetBIOS name of the CIFS server to their network IP addresses. The IP addresses must be IPv4 addresses.
     */
    winsServers: string[];
}

export interface GetProtocolsCifsServiceDataSourceSecurity {
    /**
     * List of encryption types that are advertised to the KDC
     */
    advertisedKdcEncryptions: string[];
    /**
     * An AES session key is enabled for the Netlogon channel
     */
    aesNetlogonEnabled: boolean;
    /**
     * Encryption is required for domain controller connections
     */
    encryptDcConnection: boolean;
    /**
     * Specifies whether AES-128 and AES-256 encryption is enabled for all Kerberos-based communication with the Active Directory KDC
     */
    kdcEncryption: boolean;
    /**
     * Specifies if LDAP referral chasing is enabled for AD LDAP connections
     */
    ldapReferralEnabled: boolean;
    /**
     * CIFS server minimum security level
     */
    lmCompatibilityLevel: string;
    /**
     * Specifies what level of access an anonymous user is granted
     */
    restrictAnonymous: string;
    /**
     * Client session security for AD LDAP connections
     */
    sessionSecurity: string;
    /**
     * Specifies if encryption is required for incoming CIFS traffic
     */
    smbEncryption: boolean;
    /**
     * Specifies if signing is required for incoming CIFS traffic
     */
    smbSigning: boolean;
    /**
     * Specifies whether or not channel binding is attempted in the case of TLS/LDAPS
     */
    tryLdapChannelBinding: boolean;
    /**
     * Specifies whether or not to use use LDAPS for secure Active Directory LDAP connections by using the TLS/SSL protocols
     */
    useLdaps: boolean;
    /**
     * Specifies whether or not to use SSL/TLS for allowing secure LDAP communication with Active Directory LDAP servers
     */
    useStartTls: boolean;
}

export interface GetProtocolsCifsServicesDataSourceFilter {
    /**
     * CifsService name
     */
    name?: string;
    /**
     * CifsService svm name
     */
    svmName?: string;
}

export interface GetProtocolsCifsServicesDataSourceProtocolsCifsService {
    /**
     * Ad domain
     */
    adDomain: outputs.GetProtocolsCifsServicesDataSourceProtocolsCifsServiceAdDomain;
    /**
     * text comment of up to 48 characters about the CIFS server
     */
    comment: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Default unix user
     */
    defaultUnixUser: string;
    /**
     * Specifies if the CIFS service is administratively enabled
     */
    enabled: boolean;
    /**
     * Name of the CIFS server
     */
    name: string;
    /**
     * Netbios
     */
    netbios: outputs.GetProtocolsCifsServicesDataSourceProtocolsCifsServiceNetbios;
    /**
     * Security
     */
    security: outputs.GetProtocolsCifsServicesDataSourceProtocolsCifsServiceSecurity;
    /**
     * Svm name
     */
    svmName: string;
}

export interface GetProtocolsCifsServicesDataSourceProtocolsCifsServiceAdDomain {
    /**
     * Fully qualified domain name of the Windows Active Directory to which this CIFS server belongs
     */
    fqdn: string;
    /**
     * Organizational unit
     */
    organizationalUnit: string;
    /**
     * Account password used to add this CIFS server to the Active Directory
     */
    password: string;
    /**
     * User account with the access to add the CIFS server to the Active Directory
     */
    user: string;
}

export interface GetProtocolsCifsServicesDataSourceProtocolsCifsServiceNetbios {
    /**
     * list of one or more NetBIOS aliases for the CIFS server
     */
    aliases: string[];
    /**
     * NetBios name service (NBNS) is enabled for the CIFS
     */
    enabled: boolean;
    /**
     * list of Windows Internet Name Server (WINS) addresses that manage and map the NetBIOS name of the CIFS server to their network IP addresses. The IP addresses must be IPv4 addresses.
     */
    winsServers: string[];
}

export interface GetProtocolsCifsServicesDataSourceProtocolsCifsServiceSecurity {
    /**
     * List of encryption types that are advertised to the KDC
     */
    advertisedKdcEncryptions: string[];
    /**
     * An AES session key is enabled for the Netlogon channel
     */
    aesNetlogonEnabled: boolean;
    /**
     * Encryption is required for domain controller connections
     */
    encryptDcConnection: boolean;
    /**
     * Specifies whether AES-128 and AES-256 encryption is enabled for all Kerberos-based communication with the Active Directory KDC
     */
    kdcEncryption: boolean;
    /**
     * Specifies if LDAP referral chasing is enabled for AD LDAP connections
     */
    ldapReferralEnabled: boolean;
    /**
     * CIFS server minimum security level
     */
    lmCompatibilityLevel: string;
    /**
     * Specifies what level of access an anonymous user is granted
     */
    restrictAnonymous: string;
    /**
     * Client session security for AD LDAP connections
     */
    sessionSecurity: string;
    /**
     * Specifies if encryption is required for incoming CIFS traffic
     */
    smbEncryption: boolean;
    /**
     * Specifies if signing is required for incoming CIFS traffic
     */
    smbSigning: boolean;
    /**
     * Specifies whether or not channel binding is attempted in the case of TLS/LDAPS
     */
    tryLdapChannelBinding: boolean;
    /**
     * Specifies whether or not to use use LDAPS for secure Active Directory LDAP connections by using the TLS/SSL protocols
     */
    useLdaps: boolean;
    /**
     * Specifies whether or not to use SSL/TLS for allowing secure LDAP communication with Active Directory LDAP servers
     */
    useStartTls: boolean;
}

export interface GetProtocolsCifsShareDataSourceAcl {
    /**
     * Specifies the access rights that a user or group has on the defined CIFS Share.
     */
    permission: string;
    /**
     * string Specifies the type of the user or group to add to the access control list of a CIFS share.
     */
    type: string;
    /**
     * Specifies the user or group name to add to the access control list of a CIFS share.
     */
    userOrGroup: string;
}

export interface GetProtocolsCifsSharesDataSourceFilter {
    /**
     * ProtocolsCIFSShare name
     */
    name?: string;
    /**
     * ProtocolsCIFSShare svm name
     */
    svmName?: string;
}

export interface GetProtocolsCifsSharesDataSourceProtocolsCifsShare {
    /**
     * The permissions that users and groups have on a CIFS share.
     */
    acls: outputs.GetProtocolsCifsSharesDataSourceProtocolsCifsShareAcl[];
    /**
     * Specifies whether CIFS clients can request for change notifications for directories on this share.
     */
    changeNotify: boolean;
    /**
     * Specify the CIFS share descriptions.
     */
    comment: string;
    /**
     * Specifies whether or not the clients connecting to this share can open files in a persistent manner.Files opened in this way are protected from disruptive events, such as, failover and giveback.
     */
    continuouslyAvailable: boolean;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Directory Mode Creation Mask to be viewed as an octal number.
     */
    dirUmask: number;
    /**
     * Specifies that SMB encryption must be used when accessing this share. Clients that do not support encryption are not able to access this share.
     */
    encryption: boolean;
    /**
     * File Mode Creation Mask to be viewed as an octal number.
     */
    fileUmask: number;
    /**
     * Specifies that all files that CIFS users create in a specific share belong to the same group
     * 							(also called the force-group). The force-group must be a predefined group in the UNIX group
     * 							database. This setting has no effect unless the security style of the volume is UNIX or mixed
     * 							security style.
     */
    forceGroupForCreate: string;
    /**
     * Specifies whether or not the share is a home directory share, where the share and path names are dynamic.
     * 							ONTAP home directory functionality automatically offer each user a dynamic share to their home directory without creating an
     * 							individual SMB share for each user.
     * 							The ONTAP CIFS home directory feature enable us to configure a share that maps to
     * 							different directories based on the user that connects to it. Instead of creating a separate shares for each user,
     * 							a single share with a home directory parameters can be created.
     * 							In a home directory share, ONTAP dynamically generates the share-name and share-path by substituting
     * 							%w, %u, and %d variables with the corresponding Windows user name, UNIX user name, and domain name, respectively.
     */
    homeDirectory: boolean;
    /**
     * Specifies the name of the CIFS share that you want to create. If this
     * 							is a home directory share then the share name includes the pattern as
     * 							%w (Windows user name), %u (UNIX user name) and %d (Windows domain name)
     * 							variables in any combination with this parameter to generate shares dynamically.
     */
    name: string;
    /**
     * Specifies whether or not the SMB clients connecting to this share can cache the directory enumeration
     * 							results returned by the CIFS servers.
     */
    namespaceCaching: boolean;
    /**
     * Specifies whether or not CIFS clients can follow a unix symlinks outside the share boundaries.
     */
    noStrictSecurity: boolean;
    /**
     * Offline Files. The supported values are:
     * 							none - Clients are not permitted to cache files for offline access.
     * 							manual - Clients may cache files that are explicitly selected by the user for offline access.
     * 							documents - Clients may automatically cache files that are used by the user for offline access.
     * 							programs - Clients may automatically cache files that are used by the user for offline access
     * 							and may use those files in an offline mode even if the share is available.
     */
    offlineFiles: string;
    /**
     * Specify whether opportunistic locks are enabled on this share. "Oplocks" allow clients to lock files and cache content locally,
     * 							which can increase performance for file operations.
     */
    oplocks: boolean;
    /**
     * The fully-qualified pathname in the owning SVM namespace that is shared through this share.
     * 							If this is a home directory share then the path should be dynamic by specifying the pattern
     * 							%w (Windows user name), %u (UNIX user name), or %d (domain name) variables in any combination.
     * 							ONTAP generates the path dynamically for the connected user and this path is appended to each
     * 							search path to find the full Home Directory path.
     */
    path: string;
    /**
     * Specifies whether or not the Snapshot copies can be viewed and traversed by clients.
     */
    showSnapshot: boolean;
    /**
     * IPInterface svm name
     */
    svmName?: string;
    /**
     * Controls the access of UNIX symbolic links to CIFS clients.
     * 							The supported values are:
     * 							* local - Enables only local symbolic links which is within the same CIFS share.
     * 							* widelink - Enables both local symlinks and widelinks.
     * 							* disable - Disables local symlinks and widelinks.
     */
    unixSymlink: string;
    /**
     * Vscan File-Operations Profile
     * 							The supported values are:
     * 							no_scan - Virus scans are never triggered for accesses to this share.
     * 							standard - Virus scans can be triggered by open, close, and rename operations.
     * 							strict - Virus scans can be triggered by open, read, close, and rename operations.
     * 							writes_only - Virus scans can be triggered only when a file that has been modified is closed.
     */
    vscanProfile: string;
}

export interface GetProtocolsCifsSharesDataSourceProtocolsCifsShareAcl {
    /**
     * Specifies the access rights that a user or group has on the defined CIFS Share.
     */
    permission: string;
    /**
     * string Specifies the type of the user or group to add to the access control list of a CIFS share.
     */
    type: string;
    /**
     * Specifies the user or group name to add to the access control list of a CIFS share.
     */
    userOrGroup: string;
}

export interface GetProtocolsCifsUserGroupPrivilegesDataSourceFilter {
    /**
     * CifsUserGroupPrivilege name
     */
    name?: string;
    /**
     * CifsUserGroupPrivilege privileges
     */
    privileges?: string;
    /**
     * CifsUserGroupPrivilege svm name
     */
    svmName?: string;
}

export interface GetProtocolsCifsUserGroupPrivilegesDataSourceProtocolsCifsUserGroupPrivilege {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * CifsUserGroupPrivilege name
     */
    name: string;
    /**
     * List of privileges
     */
    privileges: string[];
    /**
     * CifsUserGroupPrivilege svm name
     */
    svmName: string;
}

export interface GetProtocolsNfsExportPoliciesDataSourceFilter {
    /**
     * ExportPolicy name
     */
    name?: string;
    /**
     * ExportPolicy svm name name
     */
    svmName?: string;
}

export interface GetProtocolsNfsExportPoliciesDataSourceProtocolsNfsExportPolicy {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Export policy identifier
     */
    id: number;
    /**
     * ExportPolicy name
     */
    name: string;
    /**
     * Name of the svm name
     */
    svmName: string;
    /**
     * UUID of the svm uuid
     */
    svmUuid: string;
}

export interface GetProtocolsNfsExportPolicyRulesDataSourceFilter {
    /**
     * ProtocolsNFSExportPolicyRule svm name
     */
    svmName?: string;
}

export interface GetProtocolsNfsExportPolicyRulesDataSourceProtocolsNfsExportPolicyRule {
    /**
     * Allow Creation of Devices
     */
    allowDeviceCreation: boolean;
    /**
     * Honor SetUID Bits in SETATTR
     */
    allowSuid: boolean;
    /**
     * User ID To Which Anonymous Users Are Mapped
     */
    anonymousUser: string;
    /**
     * Specifies who is authorized to change the ownership mode of a file
     */
    chownMode: string;
    /**
     * List of Client Match Hostnames, IP Addresses, Netgroups, or Domains
     */
    clientsMatches: string[];
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Export policy identifier
     */
    exportPolicyId: string;
    /**
     * Export policy name
     */
    exportPolicyName: string;
    /**
     * rule index
     */
    index: number;
    /**
     * NTFS export UNIX security options
     */
    ntfsUnixSecurity: string;
    /**
     * Access Protocol
     */
    protocols: string[];
    /**
     * RO Access Rule
     */
    roRules: string[];
    /**
     * RW Access Rule
     */
    rwRules: string[];
    /**
     * Superuser Security Types
     */
    superusers: string[];
    /**
     * Name of the svm to use
     */
    svmName: string;
}

export interface GetProtocolsNfsServiceDataSourceProtocol {
    /**
     * NFSv3 enabled
     */
    v3Enabled: boolean;
    /**
     * NFSv4.0 enabled
     */
    v40Enabled: boolean;
    /**
     * NFSv4.0 features
     */
    v40Features: outputs.GetProtocolsNfsServiceDataSourceProtocolV40Features;
    /**
     * NFSv4.1 enabled
     */
    v41Enabled: boolean;
    /**
     * NFSv4.1 features
     */
    v41Features: outputs.GetProtocolsNfsServiceDataSourceProtocolV41Features;
    /**
     * User ID domain for NFSv4
     */
    v4IdDomain: string;
}

export interface GetProtocolsNfsServiceDataSourceProtocolV40Features {
    /**
     * Enable ACL for NFSv4.0
     */
    aclEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.0
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.0
     */
    writeDelegationEnabled: boolean;
}

export interface GetProtocolsNfsServiceDataSourceProtocolV41Features {
    /**
     * Enable ACL for NFSv4.1
     */
    aclEnabled: boolean;
    /**
     * Enabled pNFS (parallel NFS) for NFSv4.1
     */
    pnfsEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.1
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.1
     */
    writeDelegationEnabled: boolean;
}

export interface GetProtocolsNfsServiceDataSourceRoot {
    /**
     * Ignore NTFS ACL for root user
     */
    ignoreNtAcl: boolean;
    /**
     * Skip write permissions check for root user
     */
    skipWritePermissionCheck: boolean;
}

export interface GetProtocolsNfsServiceDataSourceSecurity {
    /**
     * Specifies whether file ownership can be changed only by the superuser, or if a non-root user can also change file ownership
     */
    chownMode: string;
    /**
     * Controls the permissions that are displayed to NFSv3 and NFSv4 clients on a file or directory that has an NT ACL set
     */
    ntAclDisplayPermission: boolean;
    /**
     * Specifies how NFSv3 security changes affect NTFS volumes
     */
    ntfsUnixSecurity: string;
    /**
     * Specifies the permitted encryption types for Kerberos over NFS.
     */
    permittedEncryptionTypes: string[];
    /**
     * Specifies, in seconds, the amount of time a RPCSEC_GSS context is permitted to remain unused before it is deleted
     */
    rpcsecContextIdle: number;
}

export interface GetProtocolsNfsServiceDataSourceTransport {
    /**
     * tcp enabled
     */
    tcpEnabled: boolean;
    /**
     * Max tcp transfter size
     */
    tcpMaxTransferSize: number;
    /**
     * udp enabled
     */
    udpEnabled: boolean;
}

export interface GetProtocolsNfsServiceDataSourceWindows {
    /**
     * default Windows user for the NFS server
     */
    defaultUser: string;
    /**
     * whether or not the mapping of an unknown UID to the default Windows user is enabled
     */
    mapUnknownUidToDefaultUser: boolean;
    /**
     * if permission checks are to be skipped for NFS WRITE calls from root/owner.
     */
    v3MsDosClientEnabled: boolean;
}

export interface GetProtocolsNfsServicesDataSourceFilter {
    /**
     * ProtocolsNfsService svm name
     */
    svmName?: string;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsService {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * NFS should be enabled or disabled
     */
    enabled: boolean;
    /**
     * Protocol
     */
    protocol: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocol;
    /**
     * Specific Root user options
     */
    root: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceRoot;
    /**
     * NFS Security options
     */
    security: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceSecurity;
    /**
     * Whether SVM allows showmount
     */
    showmountEnabled: boolean;
    /**
     * IPInterface svm name
     */
    svmName: string;
    transport: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceTransport;
    /**
     * Whether Vstorage is enabled
     */
    vstorageEnabled: boolean;
    windows: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceWindows;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocol {
    /**
     * NFSv3 enabled
     */
    v3Enabled: boolean;
    /**
     * NFSv4.0 enabled
     */
    v40Enabled: boolean;
    /**
     * NFSv4.0 features
     */
    v40Features: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocolV40Features;
    /**
     * NFSv4.1 enabled
     */
    v41Enabled: boolean;
    /**
     * NFSv4.1 features
     */
    v41Features: outputs.GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocolV41Features;
    /**
     * User ID domain for NFSv4
     */
    v4IdDomain: string;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocolV40Features {
    /**
     * Enable ACL for NFSv4.0
     */
    aclEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.0
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.0
     */
    writeDelegationEnabled: boolean;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceProtocolV41Features {
    /**
     * Enable ACL for NFSv4.1
     */
    aclEnabled: boolean;
    /**
     * Enabled pNFS (parallel NFS) for NFSv4.1
     */
    pnfsEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.1
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.1
     */
    writeDelegationEnabled: boolean;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceRoot {
    /**
     * Ignore NTFS ACL for root user
     */
    ignoreNtAcl: boolean;
    /**
     * Skip write permissions check for root user
     */
    skipWritePermissionCheck: boolean;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceSecurity {
    /**
     * Specifies whether file ownership can be changed only by the superuser, or if a non-root user can also change file ownership
     */
    chownMode: string;
    /**
     * Controls the permissions that are displayed to NFSv3 and NFSv4 clients on a file or directory that has an NT ACL set
     */
    ntAclDisplayPermission: boolean;
    /**
     * Specifies how NFSv3 security changes affect NTFS volumes
     */
    ntfsUnixSecurity: string;
    /**
     * Specifies the permitted encryption types for Kerberos over NFS.
     */
    permittedEncryptionTypes: string[];
    /**
     * Specifies, in seconds, the amount of time a RPCSEC_GSS context is permitted to remain unused before it is deleted
     */
    rpcsecContextIdle: number;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceTransport {
    /**
     * tcp enabled
     */
    tcpEnabled: boolean;
    /**
     * Max tcp transfter size
     */
    tcpMaxTransferSize: number;
    /**
     * udp enabled
     */
    udpEnabled: boolean;
}

export interface GetProtocolsNfsServicesDataSourceProtocolsNfsServiceWindows {
    /**
     * default Windows user for the NFS server
     */
    defaultUser: string;
    /**
     * whether or not the mapping of an unknown UID to the default Windows user is enabled
     */
    mapUnknownUidToDefaultUser: boolean;
    /**
     * if permission checks are to be skipped for NFS WRITE calls from root/owner.
     */
    v3MsDosClientEnabled: boolean;
}

export interface GetProtocolsSanIgroupDataSourceIgroup {
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * UUID
     */
    uuid: string;
}

export interface GetProtocolsSanIgroupDataSourceInitiator {
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
}

export interface GetProtocolsSanIgroupDataSourceLunMap {
    /**
     * The logical unit number assigned to the LUN for initiators in the initiator group.
     */
    logicalUnitNumber: number;
    /**
     * The LUN to which the initiator group is mapped
     */
    lun: outputs.GetProtocolsSanIgroupDataSourceLunMapLun;
}

export interface GetProtocolsSanIgroupDataSourceLunMapLun {
    /**
     * The name of the LUN.
     */
    name: string;
    /**
     * The UUID of the LUN.
     */
    uuid: string;
}

export interface GetProtocolsSanIgroupDataSourcePortset {
    /**
     * The name of the LUN.
     */
    name: string;
    /**
     * The UUID of the LUN.
     */
    uuid: string;
}

export interface GetProtocolsSanIgroupsDataSourceFilter {
    /**
     * ProtocolsSanIgroup name
     */
    name?: string;
    /**
     * ProtocolsSanIgroup svm name
     */
    svmName?: string;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroup {
    /**
     * Required ONTAP 9.9 or greater. Comment
     */
    comment: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * The UUID of the initiator group.
     */
    id: string;
    /**
     * Required ONTAP 9.9 or greater. The initiator groups that are members of the group.
     */
    igroups: outputs.GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupIgroup[];
    /**
     * Required ONTAP 9.9 or greater. The initiators that are members of the group or any group nested below this group.
     */
    initiators: outputs.GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupInitiator[];
    /**
     * All LUN maps with which the initiator is associated.
     */
    lunMaps: outputs.GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupLunMap[];
    /**
     * The name of the initiator group.
     */
    name?: string;
    /**
     * The host operating system of the initiator group. All initiators in the group should be hosts of the same operating system.
     */
    osType: string;
    /**
     * Required ONTAP 9.9 or greater. The portset to which the initiator group is bound. Binding the initiator group to a portset restricts the initiators of the group to accessing mapped LUNs only through network interfaces in the portset.
     */
    portset: outputs.GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupPortset;
    /**
     * The protocols supported by the initiator group. This restricts the type of initiators that can be added to the initiator group.
     */
    protocol: string;
    /**
     * The name of the SVM
     */
    svmName?: string;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupIgroup {
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
    /**
     * UUID
     */
    uuid: string;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupInitiator {
    /**
     * Comment
     */
    comment: string;
    /**
     * Name
     */
    name: string;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupLunMap {
    /**
     * The logical unit number assigned to the LUN for initiators in the initiator group.
     */
    logicalUnitNumber: number;
    /**
     * The LUN to which the initiator group is mapped
     */
    lun: outputs.GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupLunMapLun;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupLunMapLun {
    /**
     * The name of the LUN.
     */
    name: string;
    /**
     * The UUID of the LUN.
     */
    uuid: string;
}

export interface GetProtocolsSanIgroupsDataSourceProtocolsSanIgroupPortset {
    /**
     * The name of the portset.
     */
    name: string;
    /**
     * The UUID of the portset.
     */
    uuid: string;
}

export interface GetProtocolsSanLunMapDataSourceIgroup {
    /**
     * name of the igroup
     */
    name: string;
}

export interface GetProtocolsSanLunMapDataSourceLun {
    /**
     * name of the lun
     */
    name: string;
}

export interface GetProtocolsSanLunMapDataSourceSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface GetProtocolsSanLunMapsDataSourceFilter {
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    igroup?: outputs.GetProtocolsSanLunMapsDataSourceFilterIgroup;
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    lun?: outputs.GetProtocolsSanLunMapsDataSourceFilterLun;
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    svm?: outputs.GetProtocolsSanLunMapsDataSourceFilterSvm;
}

export interface GetProtocolsSanLunMapsDataSourceFilterIgroup {
    /**
     * name of the igroup
     */
    name?: string;
}

export interface GetProtocolsSanLunMapsDataSourceFilterLun {
    /**
     * name of the lun
     */
    name?: string;
}

export interface GetProtocolsSanLunMapsDataSourceFilterSvm {
    /**
     * name of the SVM
     */
    name?: string;
}

export interface GetProtocolsSanLunMapsDataSourceProtocolsSanLunMap {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    igroup: outputs.GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapIgroup;
    /**
     * If no value is provided, ONTAP assigns the lowest available value
     */
    logicalUnitNumber: number;
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    lun: outputs.GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapLun;
    /**
     * SVM details for ProtocolsSanLunMaps
     */
    svm: outputs.GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapSvm;
}

export interface GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapIgroup {
    /**
     * name of the igroup
     */
    name: string;
}

export interface GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapLun {
    /**
     * name of the lun
     */
    name: string;
}

export interface GetProtocolsSanLunMapsDataSourceProtocolsSanLunMapSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface GetSecurityAccountDataSourceApplication {
    /**
     * SecurityAccount application
     */
    application: string;
    /**
     * SecurityAccount authentication methods
     */
    authenticationMethods: string[];
    /**
     * SecurityAccount second authentication method
     */
    secondAuthenticationMethod: string;
}

export interface GetSecurityAccountDataSourceOwner {
    /**
     * SecurityAccount owner name
     */
    name: string;
    /**
     * SecurityAccount owner uuid
     */
    uuid: string;
}

export interface GetSecurityAccountDataSourceRole {
    /**
     * SecurityAccount role name
     */
    name: string;
}

export interface GetSecurityAccountsDataSourceFilter {
    /**
     * SecurityAccount name
     */
    name?: string;
    /**
     * SecurityAccount svm name (Owner name)
     */
    svmName?: string;
}

export interface GetSecurityAccountsDataSourceSecurityAccount {
    /**
     * SecurityAccount applications
     */
    applications: outputs.GetSecurityAccountsDataSourceSecurityAccountApplication[];
    /**
     * SecurityAccount comment
     */
    comment: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * SecurityAccount id
     */
    id: string;
    /**
     * SecurityAccount locked
     */
    locked: boolean;
    /**
     * SecurityAccount name
     */
    name: string;
    /**
     * SecurityAccount owner
     */
    owner: outputs.GetSecurityAccountsDataSourceSecurityAccountOwner;
    /**
     * SecurityAccount role
     */
    role: outputs.GetSecurityAccountsDataSourceSecurityAccountRole;
    /**
     * SecurityAccount scope
     */
    scope: string;
}

export interface GetSecurityAccountsDataSourceSecurityAccountApplication {
    /**
     * SecurityAccount application
     */
    application: string;
    /**
     * SecurityAccount authentication methods
     */
    authenticationMethods: string[];
    /**
     * SecurityAccount second authentication method
     */
    secondAuthenticationMethod: string;
}

export interface GetSecurityAccountsDataSourceSecurityAccountOwner {
    /**
     * SecurityAccount owner name
     */
    name: string;
    /**
     * SecurityAccount owner uuid
     */
    uuid: string;
}

export interface GetSecurityAccountsDataSourceSecurityAccountRole {
    /**
     * SecurityAccount role name
     */
    name: string;
}

export interface GetSnapmirrorDataSourceDestination {
    /**
     * Path to the destination endpoint of the SnapMirror relationship
     */
    path: string;
    /**
     * Cluster details
     */
    svm: outputs.GetSnapmirrorDataSourceDestinationSvm;
}

export interface GetSnapmirrorDataSourceDestinationSvm {
    /**
     * cluster name
     */
    name: string;
    /**
     * cluster UUID
     */
    uuid: string;
}

export interface GetSnapmirrorDataSourcePolicy {
    /**
     * Policy UUID
     */
    uuid: string;
}

export interface GetSnapmirrorDataSourceSource {
    /**
     * Cluster details
     */
    cluster: outputs.GetSnapmirrorDataSourceSourceCluster;
    /**
     * Path to the source endpoint of the SnapMirror relationship
     */
    path: string;
    /**
     * Cluster details
     */
    svm: outputs.GetSnapmirrorDataSourceSourceSvm;
}

export interface GetSnapmirrorDataSourceSourceCluster {
    /**
     * cluster name
     */
    name: string;
    /**
     * cluster UUID
     */
    uuid: string;
}

export interface GetSnapmirrorDataSourceSourceSvm {
    /**
     * svm name
     */
    name: string;
    /**
     * svm UUID
     */
    uuid: string;
}

export interface GetSnapmirrorPoliciesDataSourceFilter {
    /**
     * SnapmirrorPolicy name
     */
    name?: string;
}

export interface GetSnapmirrorPoliciesDataSourceSnapmirrorPolicy {
    /**
     * Comment associated with the policy.
     */
    comment: string;
    /**
     * Specifies that all the source Snapshot copies (including the one created by SnapMirror before the transfer begins) should be copied to the destination on a transfer.
     */
    copyAllSourceSnapshots: boolean;
    /**
     * Specifies that the latest source Snapshot copy (created by SnapMirror before the transfer begins) should be copied to the destination on a transfer. 'Retention' properties cannot be specified along with this property. This is applicable only to async policies. Property can only be set to 'true'.
     */
    copyLatestSourceSnapshot: boolean;
    /**
     * Specifies that all the source Snapshot copies (including the one created by SnapMirror before the transfer begins) should be copied to the destination on a transfer.
     */
    createSnapshotOnSource: boolean;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * SnapmirrorPolicy uuid
     */
    id: string;
    /**
     * Specifies which configuration of the source SVM is replicated to the destination SVM.
     */
    identityPreservation: string;
    /**
     * SnapmirrorPolicy name
     */
    name: string;
    /**
     * Specifies whether network compression is enabled for transfers
     */
    networkCompressionEnabled: boolean;
    /**
     * Rules for Snapshot copy retention.
     */
    retentions: outputs.GetSnapmirrorPoliciesDataSourceSnapmirrorPolicyRetention[];
    /**
     * SnapmirrorPolicy svm name
     */
    svmName: string;
    /**
     * SnapmirrorPolicy sync type. [sync, strict_sync, automated_failover]
     */
    syncType: string;
    /**
     * The schedule used to update asynchronous relationships
     */
    transferScheduleName: string;
    /**
     * SnapmirrorPolicy type. [async, sync, continuous]
     */
    type: string;
}

export interface GetSnapmirrorPoliciesDataSourceSnapmirrorPolicyRetention {
    /**
     * Number of Snapshot copies to be kept for retention.
     */
    count: number;
    /**
     * Schedule used to create Snapshot copies on the destination for long term retention.
     */
    creationScheduleName: string;
    /**
     * Snapshot copy label
     */
    label: string;
    /**
     * Specifies the prefix for the Snapshot copy name to be created as per the schedule
     */
    prefix: string;
}

export interface GetSnapmirrorPolicyDataSourceRetention {
    /**
     * Number of Snapshot copies to be kept for retention.
     */
    count: number;
    /**
     * Schedule used to create Snapshot copies on the destination for long term retention.
     */
    creationScheduleName: string;
    /**
     * Snapshot copy label
     */
    label: string;
    /**
     * Specifies the prefix for the Snapshot copy name to be created as per the schedule
     */
    prefix: string;
}

export interface GetSnapmirrorsDataSourceFilter {
    /**
     * Destination path
     */
    destinationPath?: string;
}

export interface GetSnapmirrorsDataSourceSnapmirror {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Snapmirror destination endpoint
     */
    destination: outputs.GetSnapmirrorsDataSourceSnapmirrorDestination;
    /**
     * group_type of the relationship
     */
    groupType: string;
    /**
     * healthy of the relationship
     */
    healthy: boolean;
    /**
     * uuid of the relationship
     */
    id: string;
    /**
     * policy of the relationship
     */
    policy: outputs.GetSnapmirrorsDataSourceSnapmirrorPolicy;
    /**
     * restore of the relationship
     */
    restore: boolean;
    /**
     * Snapmirror source endpoint
     */
    source: outputs.GetSnapmirrorsDataSourceSnapmirrorSource;
    /**
     * state of the relationship
     */
    state: string;
    /**
     * throttle of the relationship
     */
    throttle: number;
}

export interface GetSnapmirrorsDataSourceSnapmirrorDestination {
    /**
     * Path to the destination endpoint of the SnapMirror relationship
     */
    path: string;
    /**
     * Cluster details
     */
    svm: outputs.GetSnapmirrorsDataSourceSnapmirrorDestinationSvm;
}

export interface GetSnapmirrorsDataSourceSnapmirrorDestinationSvm {
    /**
     * cluster name
     */
    name: string;
    /**
     * cluster UUID
     */
    uuid: string;
}

export interface GetSnapmirrorsDataSourceSnapmirrorPolicy {
    /**
     * Policy UUID
     */
    uuid: string;
}

export interface GetSnapmirrorsDataSourceSnapmirrorSource {
    /**
     * Cluster details
     */
    cluster: outputs.GetSnapmirrorsDataSourceSnapmirrorSourceCluster;
    /**
     * Path to the source endpoint of the SnapMirror relationship
     */
    path: string;
    /**
     * Cluster details
     */
    svm: outputs.GetSnapmirrorsDataSourceSnapmirrorSourceSvm;
}

export interface GetSnapmirrorsDataSourceSnapmirrorSourceCluster {
    /**
     * cluster name
     */
    name: string;
    /**
     * cluster UUID
     */
    uuid: string;
}

export interface GetSnapmirrorsDataSourceSnapmirrorSourceSvm {
    /**
     * svm name
     */
    name: string;
    /**
     * svm UUID
     */
    uuid: string;
}

export interface GetStorageAggregatesDataSourceFilter {
    /**
     * StorageAggregate name
     */
    name?: string;
    /**
     * StorageAggregate svm name
     */
    svmName?: string;
}

export interface GetStorageAggregatesDataSourceStorageAggregate {
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Class of disk to use to build aggregate. capacity_flash is listed in swagger, but rejected as invalid by ONTAP.
     */
    diskClass: string;
    /**
     * Number of disks to place into the aggregate, including parity disks.
     * 				The disks in this newly-created aggregate come from the spare disk pool.
     * 				The smallest disks in this pool join the aggregate first, unless the disk_size argument is provided.
     * 				Modifiable only if specified disk_count is larger than current disk_count.
     * 				If the disk_count % raid_size == 1, only disk_count/raid_size * raid_size will be added.
     * 				If disk_count is 6, raid_type is raid4, raid_size 4, all 6 disks will be added.
     * 				If disk_count is 5, raid_type is raid4, raid_size 4, 5/4 * 4 = 4 will be added. 1 will not be added.
     */
    diskCount: number;
    /**
     * Whether to enable software encryption. This is equivalent to -encrypt-with-aggr-key when using the CLI.Requires a VE license.
     */
    encryption: boolean;
    /**
     * Aggregate identifier
     */
    id: string;
    /**
     * Specifies that the new aggregate be mirrored (have two plexes). If set to true, then the indicated disks will be split across the two plexes. By default, the new aggregate will not be mirrored.
     */
    isMirrored: boolean;
    /**
     * StorageAggregate name
     */
    name: string;
    /**
     * Node for the aggregate to be created on. If no node specified, mgmt lif home will be used. If disk_count is present, node name is required.
     */
    node: string;
    /**
     * Sets the maximum number of drives per raid group.
     */
    raidSize: number;
    raidType: string;
    /**
     * Type of snaplock for the aggregate being created.
     */
    snaplockType: string;
    /**
     * Whether the specified aggregate should be enabled or disabled. Creates aggregate if doesnt exist.
     */
    state: string;
}

export interface GetStorageFlexcacheDataSourceAggregate {
    /**
     * UUID of the aggregate
     */
    id: string;
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface GetStorageFlexcacheDataSourceGuarantee {
    /**
     * The type of guarantee
     */
    type: string;
}

export interface GetStorageFlexcacheDataSourceOrigin {
    /**
     * Origin volume SVM
     */
    svm: outputs.GetStorageFlexcacheDataSourceOriginSvm;
    /**
     * Origin volume
     */
    volume: outputs.GetStorageFlexcacheDataSourceOriginVolume;
}

export interface GetStorageFlexcacheDataSourceOriginSvm {
    /**
     * ID of the origin volume
     */
    id: string;
    /**
     * Name of the origin volume
     */
    name: string;
}

export interface GetStorageFlexcacheDataSourceOriginVolume {
    /**
     * ID of the origin volume
     */
    id: string;
    /**
     * Name of the origin volume
     */
    name: string;
}

export interface GetStorageFlexcachesDataSourceFilter {
    /**
     * StorageFlexcache name
     */
    name?: string;
    /**
     * StorageFlexcache svm name
     */
    svmName?: string;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcach {
    aggregates: outputs.GetStorageFlexcachesDataSourceStorageFlexcachAggregate[];
    /**
     * The number of constituents per aggregate
     */
    constituentsPerAggregate: number;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * The state of the dr cache
     */
    drCache: boolean;
    /**
     * The state of the global file locking
     */
    globalFileLockingEnabled: boolean;
    /**
     * The guarantee of the volume
     */
    guarantee: outputs.GetStorageFlexcachesDataSourceStorageFlexcachGuarantee;
    /**
     * The UUID of the flexcache volume
     */
    id: string;
    /**
     * Name of the junction path
     */
    junctionPath: string;
    /**
     * The name of the flexcache volume to manage
     */
    name: string;
    /**
     * Set of the origin volumes
     */
    origins: outputs.GetStorageFlexcachesDataSourceStorageFlexcachOrigin[];
    /**
     * The size of the flexcache volume
     */
    size: number;
    /**
     * The unit used to interpret the size parameter
     */
    sizeUnit: string;
    /**
     * Name of the svm to use
     */
    svmName: string;
    /**
     * The state of the use tiered aggregates
     */
    useTieredAggregate: boolean;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcachAggregate {
    /**
     * ID of the aggregate
     */
    id: string;
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcachGuarantee {
    /**
     * The type of the guarantee
     */
    type: string;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcachOrigin {
    /**
     * Origin volume SVM
     */
    svm: outputs.GetStorageFlexcachesDataSourceStorageFlexcachOriginSvm;
    /**
     * Origin volume
     */
    volume: outputs.GetStorageFlexcachesDataSourceStorageFlexcachOriginVolume;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcachOriginSvm {
    /**
     * ID of the origin volume SVM
     */
    id: string;
    /**
     * Name of the origin volume SVM
     */
    name: string;
}

export interface GetStorageFlexcachesDataSourceStorageFlexcachOriginVolume {
    /**
     * ID of the origin volume
     */
    id: string;
    /**
     * Name of the origin volume
     */
    name: string;
}

export interface GetStorageLunDataSourceLocation {
    /**
     * Logical unit name
     */
    logicalUnit: string;
    volume: outputs.GetStorageLunDataSourceLocationVolume;
}

export interface GetStorageLunDataSourceLocationVolume {
    /**
     * Volume name
     */
    name: string;
    /**
     * Volume uuid
     */
    uuid: string;
}

export interface GetStorageLunDataSourceQosPolicy {
    /**
     * QoS policy name
     */
    name: string;
    /**
     * QoS policy uuid
     */
    uuid: string;
}

export interface GetStorageLunDataSourceSpace {
    /**
     * Size of the lun
     */
    size: number;
    /**
     * Used space of the lun
     */
    used: number;
}

export interface GetStorageLunsDataSourceFilter {
    /**
     * StorageLun name
     */
    name?: string;
    /**
     * StorageLun svm name
     */
    svmName?: string;
    /**
     * StorageLun volume name
     */
    volumeName?: string;
}

export interface GetStorageLunsDataSourceStorageLun {
    /**
     * Time when the lun was created
     */
    createTime: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * StorageLun UUID
     */
    id: string;
    location: outputs.GetStorageLunsDataSourceStorageLunLocation;
    /**
     * StorageLun name
     */
    name: string;
    /**
     * OS type for lun
     */
    osType: string;
    qosPolicy: outputs.GetStorageLunsDataSourceStorageLunQosPolicy;
    /**
     * Serial number for lun
     */
    serialNumber: string;
    space: outputs.GetStorageLunsDataSourceStorageLunSpace;
    /**
     * StorageLun svm name
     */
    svmName: string;
}

export interface GetStorageLunsDataSourceStorageLunLocation {
    /**
     * Logical unit name
     */
    logicalUnit: string;
    volume: outputs.GetStorageLunsDataSourceStorageLunLocationVolume;
}

export interface GetStorageLunsDataSourceStorageLunLocationVolume {
    /**
     * Volume name
     */
    name: string;
    /**
     * Volume uuid
     */
    uuid: string;
}

export interface GetStorageLunsDataSourceStorageLunQosPolicy {
    /**
     * QoS policy name
     */
    name: string;
    /**
     * QoS policy uuid
     */
    uuid: string;
}

export interface GetStorageLunsDataSourceStorageLunSpace {
    /**
     * Size of lun in bytes
     */
    size: number;
    /**
     * Used space of lun in bytes
     */
    used: number;
}

export interface GetStorageSnapshotPoliciesDataSourceFilter {
    /**
     * SnapshotPolicy name
     */
    name?: string;
    /**
     * SnapshotPolicy svm name
     */
    svmName?: string;
}

export interface GetStorageSnapshotPoliciesDataSourceStorageSnapshotPolicy {
    /**
     * A comment associated with the Snapshot copy policy
     */
    comment: string;
    /**
     * Snapshot copy
     */
    copies: outputs.GetStorageSnapshotPoliciesDataSourceStorageSnapshotPolicyCopy[];
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Is the Snapshot copy policy enabled?
     */
    enabled: boolean;
    /**
     * SnapshotPolicy UUID
     */
    id: string;
    /**
     * SnapshotPolicy name
     */
    name: string;
    /**
     * IPInterface svm name
     */
    svmName: string;
}

export interface GetStorageSnapshotPoliciesDataSourceStorageSnapshotPolicyCopy {
    /**
     * The number of Snapshot copies to maintain for this schedule
     */
    count: number;
    /**
     * The prefix to use while creating Snapshot copies at regular intervals
     */
    prefix: string;
    /**
     * The retention period of Snapshot copies for this schedule
     */
    retentionPeriod: string;
    /**
     * Schedule at which Snapshot copies are captured on the volume
     */
    schedule: outputs.GetStorageSnapshotPoliciesDataSourceStorageSnapshotPolicyCopySchedule;
    /**
     * Label for SnapMirror operations
     */
    snapmirrorLabel: string;
}

export interface GetStorageSnapshotPoliciesDataSourceStorageSnapshotPolicyCopySchedule {
    /**
     * Some common schedules already defined in the system are hourly, daily, weekly, at 15 minute intervals, and at 5 minute intervals. Snapshot copy policies with custom schedules can be referenced
     */
    name: string;
}

export interface GetStorageSnapshotPolicyDataSourceCopy {
    /**
     * The number of Snapshot copies to maintain for this schedule
     */
    count: number;
    /**
     * The prefix to use while creating Snapshot copies at regular intervals
     */
    prefix: string;
    /**
     * The retention period of Snapshot copies for this schedule
     */
    retentionPeriod: string;
    /**
     * Schedule at which Snapshot copies are captured on the volume
     */
    schedule: outputs.GetStorageSnapshotPolicyDataSourceCopySchedule;
    /**
     * Label for SnapMirror operations
     */
    snapmirrorLabel: string;
}

export interface GetStorageSnapshotPolicyDataSourceCopySchedule {
    /**
     * Some common schedules already defined in the system are hourly, daily, weekly, at 15 minute intervals, and at 5 minute intervals. Snapshot copy policies with custom schedules can be referenced
     */
    name: string;
}

export interface GetStorageVolumeDataSourceAggregate {
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface GetStorageVolumeDataSourceAnalytics {
    /**
     * Set file system analytics state of the volume
     */
    state: string;
}

export interface GetStorageVolumeDataSourceEfficiency {
    /**
     * Whether to enable compression for the volume (HDD and Flash Pool aggregates)
     */
    compression: string;
    /**
     * Allows a storage efficiency policy to be set on volume creation
     */
    policyName: string;
}

export interface GetStorageVolumeDataSourceNas {
    /**
     * The name of the export policy
     */
    exportPolicyName: string;
    /**
     * The UNIX group ID for the volume
     */
    groupId: number;
    /**
     * Junction path of the volume
     */
    junctionPath: string;
    /**
     * The security style associated to the volume
     */
    securityStyle: string;
    /**
     * Unix permission bits in octal or symbolic format. For example, 0 is equivalent to ------------, 777 is equivalent to ---rwxrwxrwx,both formats are accepted
     */
    unixPermissions: number;
    /**
     * The UNIX user ID for the volume
     */
    userId: number;
}

export interface GetStorageVolumeDataSourceSnaplock {
    /**
     * The SnapLock type of the volume
     */
    type: string;
}

export interface GetStorageVolumeDataSourceSpace {
    logicalSpace: outputs.GetStorageVolumeDataSourceSpaceLogicalSpace;
    /**
     * Amount of space reserved for snapshot copies of the volume
     */
    percentSnapshotSpace: number;
    /**
     * The size of the volume
     */
    size: number;
    /**
     * The unit used to interpret the size parameter
     */
    sizeUnit: string;
}

export interface GetStorageVolumeDataSourceSpaceLogicalSpace {
    /**
     * Whether to perform logical space accounting on the volume
     */
    enforcement: boolean;
    /**
     * Whether to report space logically
     */
    reporting: boolean;
}

export interface GetStorageVolumeDataSourceTiering {
    /**
     * Determines how many days must pass before inactive data in a volume using the Auto or Snapshot-Only policy is considered cold and eligible for tiering
     */
    minimumCoolingDays: number;
    /**
     * The tiering policy that is to be associated with the volume
     */
    policyName: string;
}

export interface GetStorageVolumeSnapshotsDataSourceFilter {
    /**
     * StorageVolumeSnapshot name
     */
    name: string;
    /**
     * StorageVolumeSnapshot svm name
     */
    svmName: string;
    /**
     * StorageVolumeSnapshot volume name
     */
    volumeName: string;
}

export interface GetStorageVolumeSnapshotsDataSourceStorageVolumeSnapshot {
    /**
     * Comment
     */
    comment: string;
    /**
     * Create time
     */
    createTime: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * Expiry time
     */
    expiryTime: string;
    /**
     * volume snapshot UUID
     */
    id: string;
    /**
     * StorageVolumeSnapshot name
     */
    name: string;
    /**
     * Size
     */
    size: number;
    /**
     * Snapmirror Label
     */
    snapmirrorLabel: string;
    /**
     * State
     */
    state: string;
    /**
     * SVM Name
     */
    svmName: string;
    /**
     * Volume Name
     */
    volumeName: string;
}

export interface GetStorageVolumesDataSourceFilter {
    /**
     * StorageVolume name
     */
    name?: string;
    /**
     * StorageVolume svm name
     */
    svmName?: string;
}

export interface GetStorageVolumesDataSourceStorageVolume {
    /**
     * List of aggregates that the volume is on
     */
    aggregates: outputs.GetStorageVolumesDataSourceStorageVolumeAggregate[];
    analytics: outputs.GetStorageVolumesDataSourceStorageVolumeAnalytics;
    /**
     * Sets a comment associated with the volume
     */
    comment: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    efficiency: outputs.GetStorageVolumesDataSourceStorageVolumeEfficiency;
    /**
     * Whether or not to enable Volume Encryption
     */
    encryption: boolean;
    /**
     * Volume identifier
     */
    id: string;
    /**
     * Language to use for volume
     */
    language: string;
    /**
     * The name of the volume to manage
     */
    name: string;
    nas: outputs.GetStorageVolumesDataSourceStorageVolumeNas;
    /**
     * Specifies a QoS policy group to be set on volume
     */
    qosPolicyGroup: string;
    snaplock: outputs.GetStorageVolumesDataSourceStorageVolumeSnaplock;
    /**
     * The name of the snapshot policy
     */
    snapshotPolicy: string;
    space: outputs.GetStorageVolumesDataSourceStorageVolumeSpace;
    /**
     * Space guarantee style for the volume
     */
    spaceGuarantee: string;
    /**
     * Whether the specified volume is online, or not
     */
    state: string;
    /**
     * Name of the svm to use
     */
    svmName: string;
    tiering: outputs.GetStorageVolumesDataSourceStorageVolumeTiering;
    /**
     * The volume type, either read-write (RW) or data-protection (DP)
     */
    type: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeAggregate {
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeAnalytics {
    /**
     * Set file system analytics state of the volume
     */
    state: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeEfficiency {
    /**
     * Whether to enable compression for the volume (HDD and Flash Pool aggregates)
     */
    compression: string;
    /**
     * Allows a storage efficiency policy to be set on volume creation
     */
    policyName: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeNas {
    /**
     * The name of the export policy
     */
    exportPolicyName: string;
    /**
     * The UNIX group ID for the volume
     */
    groupId: number;
    /**
     * Junction path of the volume
     */
    junctionPath: string;
    /**
     * The security style associated to the volume
     */
    securityStyle: string;
    /**
     * Unix permission bits in octal or symbolic format. For example, 0 is equivalent to ------------, 777 is equivalent to ---rwxrwxrwx,both formats are accepted
     */
    unixPermissions: number;
    /**
     * The UNIX user ID for the volume
     */
    userId: number;
}

export interface GetStorageVolumesDataSourceStorageVolumeSnaplock {
    /**
     * The SnapLock type of the volume
     */
    type: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeSpace {
    logicalSpace: outputs.GetStorageVolumesDataSourceStorageVolumeSpaceLogicalSpace;
    /**
     * Amount of space reserved for snapshot copies of the volume
     */
    percentSnapshotSpace: number;
    /**
     * The size of the volume
     */
    size: number;
    /**
     * The unit used to interpret the size parameter
     */
    sizeUnit: string;
}

export interface GetStorageVolumesDataSourceStorageVolumeSpaceLogicalSpace {
    /**
     * Whether to perform logical space accounting on the volume
     */
    enforcement: boolean;
    /**
     * Whether to report space logically
     */
    reporting: boolean;
}

export interface GetStorageVolumesDataSourceStorageVolumeTiering {
    /**
     * Determines how many days must pass before inactive data in a volume using the Auto or Snapshot-Only policy is considered cold and eligible for tiering
     */
    minimumCoolingDays: number;
    /**
     * The tiering policy that is to be associated with the volume
     */
    policyName: string;
}

export interface GetSvmPeerDataSourcePeer {
    /**
     * peer Cluster details for SVMPeer
     */
    cluster: outputs.GetSvmPeerDataSourcePeerCluster;
    /**
     * peer SVM details for SVMPeer
     */
    svm: outputs.GetSvmPeerDataSourcePeerSvm;
}

export interface GetSvmPeerDataSourcePeerCluster {
    /**
     * name of the peer Cluster
     */
    name: string;
}

export interface GetSvmPeerDataSourcePeerSvm {
    /**
     * name of the peer SVM
     */
    name: string;
}

export interface GetSvmPeerDataSourceSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface GetSvmPeersDataSourceFilter {
    /**
     * Peer details for SVMPeer
     */
    peer?: outputs.GetSvmPeersDataSourceFilterPeer;
    /**
     * SVM details for SVMPeer
     */
    svm?: outputs.GetSvmPeersDataSourceFilterSvm;
}

export interface GetSvmPeersDataSourceFilterPeer {
    /**
     * peer Cluster details for SVMPeer
     */
    cluster?: outputs.GetSvmPeersDataSourceFilterPeerCluster;
    /**
     * peer SVM details for SVMPeer
     */
    svm?: outputs.GetSvmPeersDataSourceFilterPeerSvm;
}

export interface GetSvmPeersDataSourceFilterPeerCluster {
    /**
     * name of the peer Cluster
     */
    name?: string;
}

export interface GetSvmPeersDataSourceFilterPeerSvm {
    /**
     * name of the peer SVM
     */
    name?: string;
}

export interface GetSvmPeersDataSourceFilterSvm {
    /**
     * name of the SVM
     */
    name?: string;
}

export interface GetSvmPeersDataSourceSvmPeer {
    /**
     * SVMPeering applications
     */
    applications: string[];
    /**
     * Connection profile name
     */
    cxProfileName: string;
    /**
     * SVMPeers UUID
     */
    id: string;
    /**
     * Peer details for SVMPeer
     */
    peer: outputs.GetSvmPeersDataSourceSvmPeerPeer;
    state: string;
    /**
     * SVM details for SVMPeer
     */
    svm: outputs.GetSvmPeersDataSourceSvmPeerSvm;
}

export interface GetSvmPeersDataSourceSvmPeerPeer {
    /**
     * peer Cluster details for SVMPeer
     */
    cluster: outputs.GetSvmPeersDataSourceSvmPeerPeerCluster;
    /**
     * peer SVM details for SVMPeer
     */
    svm: outputs.GetSvmPeersDataSourceSvmPeerPeerSvm;
}

export interface GetSvmPeersDataSourceSvmPeerPeerCluster {
    /**
     * name of the peer Cluster
     */
    name: string;
}

export interface GetSvmPeersDataSourceSvmPeerPeerSvm {
    /**
     * name of the peer SVM
     */
    name: string;
}

export interface GetSvmPeersDataSourceSvmPeerSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface GetSvmsDataSourceFilter {
    /**
     * Svm name
     */
    name?: string;
}

export interface GetSvmsDataSourceSvm {
    /**
     * Aggregates to be assigned use for svm
     */
    aggregates: string[];
    /**
     * Comment for svm to be created
     */
    comment: string;
    /**
     * Connection profile name
     */
    cxProfileName: string;
    id: string;
    /**
     * The name of the ipspace to manage
     */
    ipspace: string;
    /**
     * Language to use for svm
     */
    language: string;
    /**
     * Maximum number of volumes that can be created on the svm. Expects an integer or unlimited
     */
    maxVolumes: string;
    /**
     * Svm name
     */
    name: string;
    /**
     * The name of the snapshot policy to manage
     */
    snapshotPolicy: string;
    /**
     * The subtype for svm to be created
     */
    subtype: string;
}

export interface NetworkingIpInterfaceResourceIp {
    /**
     * IPInterface IP address
     */
    address: string;
    /**
     * IPInterface IP netmask
     */
    netmask: number;
}

export interface NetworkingIpInterfaceResourceLocation {
    /**
     * IPInterface home node
     */
    homeNode: string;
    /**
     * IPInterface home port
     */
    homePort: string;
}

export interface NetworkingIpRouteResourceDestination {
    /**
     * IPv4 or IPv6 address
     */
    address: string;
    /**
     * netmask length (16) or IPv4 mask (255.255.0.0). For IPv6, valid range is 1 to 127.
     */
    netmask: string;
}

export interface ProtocolsCifsLocalGroupResourceMember {
    /**
     * Cifs Local Group member
     */
    name: string;
}

export interface ProtocolsCifsLocalUserResourceMembership {
    /**
     * CifsLocalUser membership name
     */
    name: string;
}

export interface ProtocolsCifsServiceResourceAdDomain {
    /**
     * Fully qualified domain name of the Windows Active Directory to which this CIFS server belongs
     */
    fqdn: string;
    /**
     * Organizational unit
     */
    organizationalUnit: string;
    /**
     * Account password used to add this CIFS server to the Active Directory
     */
    password: string;
    /**
     * User account with the access to add the CIFS server to the Active Directory
     */
    user: string;
}

export interface ProtocolsCifsServiceResourceNetbios {
    /**
     * list of one or more NetBIOS aliases for the CIFS server
     */
    aliases: string[];
    /**
     * NetBios name service (NBNS) is enabled for the CIFS
     */
    enabled: boolean;
    /**
     * list of Windows Internet Name Server (WINS) addresses that manage and map the NetBIOS name of the CIFS server to their network IP addresses. The IP addresses must be IPv4 addresses.
     */
    winsServers: string[];
}

export interface ProtocolsCifsServiceResourceSecurity {
    /**
     * List of advertised KDC encryptions (9.12)
     */
    advertisedKdcEncryptions: string[];
    /**
     * An AES session key is enabled for the Netlogon channel (9.10)
     */
    aesNetlogonEnabled: boolean;
    /**
     * Encryption is required for domain controller connections (9.8)
     */
    encryptDcConnection: boolean;
    /**
     * Specifies whether AES-128 and AES-256 encryption is enabled for all Kerberos-based communication with the Active Directory KDC. Deprecated in 9.12. Use 'advertised_kdc_encryptions' instead.
     */
    kdcEncryption: boolean;
    /**
     * Specifies if LDAP referral chasing is enabled for AD LDAP connections (9.10)
     */
    ldapReferralEnabled: boolean;
    /**
     * CIFS server minimum security level
     */
    lmCompatibilityLevel: string;
    /**
     * Specifies what level of access an anonymous user is granted
     */
    restrictAnonymous: string;
    /**
     * Client session security for AD LDAP connections (9.10)
     */
    sessionSecurity: string;
    /**
     * Specifies if encryption is required for incoming CIFS traffic
     */
    smbEncryption: boolean;
    /**
     * Specifies if signing is required for incoming CIFS traffic
     */
    smbSigning: boolean;
    /**
     * Specifies whether or not channel binding is attempted in the case of TLS/LDAPS (9.10)
     */
    tryLdapChannelBinding: boolean;
    /**
     * Specifies whether or not to use use LDAPS for secure Active Directory LDAP connections by using the TLS/SSL protocols (9.10)
     */
    useLdaps: boolean;
    /**
     * Specifies whether or not to use SSL/TLS for allowing secure LDAP communication with Active Directory LDAP servers (9.10)
     */
    useStartTls: boolean;
}

export interface ProtocolsCifsShareResourceAcl {
    /**
     * Specifies the access rights that a user or group has on the defined CIFS Share.
     */
    permission: string;
    /**
     * string Specifies the type of the user or group to add to the access control list of a CIFS share.
     */
    type: string;
    /**
     * Specifies the user or group name to add to the access control list of a CIFS share.
     */
    userOrGroup: string;
}

export interface ProtocolsNfsServiceResourceProtocol {
    /**
     * NFSv3 enabled
     */
    v3Enabled: boolean;
    /**
     * NFSv4.0 enabled
     */
    v40Enabled: boolean;
    /**
     * NFSv4.0 features
     */
    v40Features: outputs.ProtocolsNfsServiceResourceProtocolV40Features;
    /**
     * NFSv4.1 enabled
     */
    v41Enabled: boolean;
    /**
     * NFSv4.1 features
     */
    v41Features: outputs.ProtocolsNfsServiceResourceProtocolV41Features;
    /**
     * User ID domain for NFSv4
     */
    v4IdDomain: string;
}

export interface ProtocolsNfsServiceResourceProtocolV40Features {
    /**
     * Enable ACL for NFSv4.0
     */
    aclEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.0
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.0
     */
    writeDelegationEnabled: boolean;
}

export interface ProtocolsNfsServiceResourceProtocolV41Features {
    /**
     * Enable ACL for NFSv4.1
     */
    aclEnabled: boolean;
    /**
     * Enabled pNFS (parallel NFS) for NFSv4.1
     */
    pnfsEnabled: boolean;
    /**
     * Enable Read File Delegation for NFSv4.1
     */
    readDelegationEnabled: boolean;
    /**
     * Enable Write File Delegation for NFSv4.1
     */
    writeDelegationEnabled: boolean;
}

export interface ProtocolsNfsServiceResourceRoot {
    /**
     * Ignore NTFS ACL for root user
     */
    ignoreNtAcl: boolean;
    /**
     * Skip write permissions check for root user
     */
    skipWritePermissionCheck: boolean;
}

export interface ProtocolsNfsServiceResourceSecurity {
    /**
     * Specifies whether file ownership can be changed only by the superuser, or if a non-root user can also change file ownership
     */
    chownMode: string;
    /**
     * Controls the permissions that are displayed to NFSv3 and NFSv4 clients on a file or directory that has an NT ACL set
     */
    ntAclDisplayPermission: boolean;
    /**
     * Specifies how NFSv3 security changes affect NTFS volumes
     */
    ntfsUnixSecurity: string;
    /**
     * Specifies, in seconds, the amount of time a RPCSEC_GSS context is permitted to remain unused before it is deleted
     */
    rpcsecContextIdle: number;
}

export interface ProtocolsNfsServiceResourceTransport {
    /**
     * tcp enabled
     */
    tcpEnabled: boolean;
    /**
     * Max tcp transfer size
     */
    tcpMaxTransferSize: number;
    /**
     * udp enabled
     */
    udpEnabled: boolean;
}

export interface ProtocolsNfsServiceResourceWindows {
    /**
     * default Windows user for the NFS server
     */
    defaultUser: string;
    /**
     * whether or not the mapping of an unknown UID to the default Windows user is enabled
     */
    mapUnknownUidToDefaultUser: boolean;
    /**
     * if permission checks are to be skipped for NFS WRITE calls from root/owner.
     */
    v3MsDosClientEnabled: boolean;
}

export interface ProtocolsSanIgroupResourceIgroup {
    /**
     * Initiator group name
     */
    name: string;
}

export interface ProtocolsSanIgroupResourceInitiator {
    /**
     * Initiator name
     */
    name: string;
}

export interface ProtocolsSanIgroupResourcePortset {
    /**
     * Portset name
     */
    name: string;
}

export interface ProtocolsSanIgroupResourceSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface ProtocolsSanLunMapsResourceIgroup {
    /**
     * name of the igroup
     */
    name: string;
}

export interface ProtocolsSanLunMapsResourceLun {
    /**
     * name of the lun
     */
    name: string;
}

export interface ProtocolsSanLunMapsResourceSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface SecurityAccountResourceApplication {
    /**
     * Application name
     */
    application: string;
    /**
     * List of authentication methods
     */
    authenticationMethods?: string[];
    /**
     * Second authentication method
     */
    secondAuthenticationMethod: string;
}

export interface SecurityAccountResourceOwner {
    /**
     * Account owner name
     */
    name: string;
}

export interface SecurityAccountResourceRole {
    /**
     * Account role name
     */
    name: string;
}

export interface SnapmirrorPolicyResourceRetention {
    /**
     * Number of Snapshot copies to be kept for retention.
     */
    count?: number;
    /**
     * Schedule used to create Snapshot copies on the destination for long term retention.
     */
    creationScheduleName?: string;
    /**
     * Snapshot copy label
     */
    label: string;
    /**
     * Specifies the prefix for the Snapshot copy name to be created as per the schedule
     */
    prefix: string;
}

export interface SnapmirrorResourceCreateDestination {
    /**
     * Enable this property to provision the destination endpoint
     */
    enabled: boolean;
}

export interface SnapmirrorResourceDestinationEndpoint {
    /**
     * Cluster details
     */
    cluster?: outputs.SnapmirrorResourceDestinationEndpointCluster;
    /**
     * Path to the destination endpoint of the SnapMirror relationship
     */
    path: string;
}

export interface SnapmirrorResourceDestinationEndpointCluster {
    /**
     * cluster name
     */
    name: string;
}

export interface SnapmirrorResourcePolicy {
    /**
     * policy name
     */
    name: string;
}

export interface SnapmirrorResourceSourceEndpoint {
    /**
     * Cluster details
     */
    cluster?: outputs.SnapmirrorResourceSourceEndpointCluster;
    /**
     * Path to the source endpoint of the SnapMirror relationship
     */
    path: string;
}

export interface SnapmirrorResourceSourceEndpointCluster {
    /**
     * cluster name
     */
    name: string;
}

export interface StorageFlexcacheResourceAggregate {
    /**
     * UUID of the aggregate
     */
    id: string;
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface StorageFlexcacheResourceGuarantee {
    /**
     * The type of guarantee
     */
    type: string;
}

export interface StorageFlexcacheResourceOrigin {
    /**
     * origin volume SVM
     */
    svm: outputs.StorageFlexcacheResourceOriginSvm;
    /**
     * origin volume
     */
    volume: outputs.StorageFlexcacheResourceOriginVolume;
}

export interface StorageFlexcacheResourceOriginSvm {
    /**
     * ID of the origin volume SVM
     */
    id: string;
    /**
     * Name of the origin volume SVM
     */
    name: string;
}

export interface StorageFlexcacheResourceOriginVolume {
    /**
     * ID of the origin volume
     */
    id: string;
    /**
     * Name of the origin volume
     */
    name: string;
}

export interface StorageSnapshotPolicyResourceCopy {
    /**
     * The number of Snapshot copies to maintain for this schedule
     */
    count: number;
    /**
     * The prefix to use while creating Snapshot copies at regular intervals
     */
    prefix?: string;
    /**
     * The retention period of Snapshot copies for this schedule
     */
    retentionPeriod?: string;
    /**
     * Schedule at which Snapshot copies are captured on the volume
     */
    schedule: outputs.StorageSnapshotPolicyResourceCopySchedule;
    /**
     * Label for SnapMirror operations
     */
    snapmirrorLabel?: string;
}

export interface StorageSnapshotPolicyResourceCopySchedule {
    /**
     * Some common schedules already defined in the system are hourly, daily, weekly, at 15 minute intervals, and at 5 minute intervals. Snapshot copy policies with custom schedules can be referenced
     */
    name: string;
}

export interface StorageVolumeResourceAggregate {
    /**
     * Name of the aggregate
     */
    name: string;
}

export interface StorageVolumeResourceAnalytics {
    /**
     * Set file system analytics state of the volume
     */
    state: string;
}

export interface StorageVolumeResourceEfficiency {
    /**
     * Whether to enable compression for the volume (HDD and Flash Pool aggregates)
     */
    compression: string;
    /**
     * Allows a storage efficiency policy to be set on volume creation
     */
    policyName: string;
}

export interface StorageVolumeResourceNas {
    /**
     * The name of the export policy
     */
    exportPolicyName: string;
    /**
     * The UNIX group ID for the volume
     */
    groupId: number;
    /**
     * Junction path of the volume
     */
    junctionPath: string;
    /**
     * The security style associated to the volume
     */
    securityStyle: string;
    /**
     * Unix permission bits in octal or symbolic format. For example, 0 is equivalent to ------------, 777 is equivalent to ---rwxrwxrwx,both formats are accepted
     */
    unixPermissions: number;
    /**
     * The UNIX user ID for the volume
     */
    userId: number;
}

export interface StorageVolumeResourceSnaplock {
    /**
     * The SnapLock type of the volume
     */
    type: string;
}

export interface StorageVolumeResourceSpace {
    logicalSpace: outputs.StorageVolumeResourceSpaceLogicalSpace;
    /**
     * Amount of space reserved for snapshot copies of the volume
     */
    percentSnapshotSpace: number;
    /**
     * The size of the volume
     */
    size: number;
    /**
     * The unit used to interpret the size parameter
     */
    sizeUnit: string;
}

export interface StorageVolumeResourceSpaceLogicalSpace {
    /**
     * Whether to perform logical space accounting on the volume
     */
    enforcement: boolean;
    /**
     * Whether to report space logically
     */
    reporting: boolean;
}

export interface StorageVolumeResourceTiering {
    /**
     * Determines how many days must pass before inactive data in a volume using the Auto or Snapshot-Only policy is considered cold and eligible for tiering
     */
    minimumCoolingDays: number;
    /**
     * The tiering policy that is to be associated with the volume
     */
    policyName: string;
}

export interface SvmPeersResourcePeer {
    /**
     * peer Cluster details for SVMPeer
     */
    cluster: outputs.SvmPeersResourcePeerCluster;
    /**
     * Peer connection profile name, if not provided, status will be only initiated and need to be accepted from peer side to make the status peered
     */
    peerCxProfileName?: string;
    /**
     * peer SVM details for SVMPeer
     */
    svm: outputs.SvmPeersResourcePeerSvm;
}

export interface SvmPeersResourcePeerCluster {
    /**
     * name of the peer Cluster
     */
    name: string;
}

export interface SvmPeersResourcePeerSvm {
    /**
     * name of the peer SVM
     */
    name: string;
}

export interface SvmPeersResourceSvm {
    /**
     * name of the SVM
     */
    name: string;
}

export interface SvmResourceAggregate {
    /**
     * Name of the aggregate
     */
    name: string;
}

export namespace config {
    export interface ConnectionProfiles {
        /**
         * ONTAP management interface IP address or name
         */
        hostname: string;
        /**
         * Profile name
         */
        name: string;
        /**
         * ONTAP management password for username
         */
        password: string;
        /**
         * ONTAP management user name (cluster or svm)
         */
        username: string;
        /**
         * Whether to enforce SSL certificate validation, defaults to true
         */
        validateCerts?: boolean;
    }

}
