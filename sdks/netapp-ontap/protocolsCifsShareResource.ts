// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class ProtocolsCifsShareResource extends pulumi.CustomResource {
    /**
     * Get an existing ProtocolsCifsShareResource resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ProtocolsCifsShareResourceState, opts?: pulumi.CustomResourceOptions): ProtocolsCifsShareResource {
        return new ProtocolsCifsShareResource(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'netapp-ontap:index/protocolsCifsShareResource:ProtocolsCifsShareResource';

    /**
     * Returns true if the given object is an instance of ProtocolsCifsShareResource.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ProtocolsCifsShareResource {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ProtocolsCifsShareResource.__pulumiType;
    }

    /**
     * The permissions that users and groups have on a CIFS share.
     */
    public readonly acls!: pulumi.Output<outputs.ProtocolsCifsShareResourceAcl[]>;
    /**
     * Specifies whether CIFS clients can request for change notifications for directories on this share.
     */
    public readonly changeNotify!: pulumi.Output<boolean>;
    /**
     * Specify the CIFS share descriptions.
     */
    public readonly comment!: pulumi.Output<string>;
    /**
     * Specifies whether or not the clients connecting to this share can open files in a persistent manner.Files opened in this
     * way are protected from disruptive events, such as, failover and giveback.
     */
    public readonly continuouslyAvailable!: pulumi.Output<boolean>;
    /**
     * Connection profile name
     */
    public readonly cxProfileName!: pulumi.Output<string>;
    /**
     * Directory Mode Creation Mask to be viewed as an octal number.
     */
    public readonly dirUmask!: pulumi.Output<number>;
    /**
     * Specifies that SMB encryption must be used when accessing this share. Clients that do not support encryption are not
     * able to access this share.
     */
    public readonly encryption!: pulumi.Output<boolean>;
    /**
     * File Mode Creation Mask to be viewed as an octal number.
     */
    public readonly fileUmask!: pulumi.Output<number>;
    /**
     * Specifies that all files that CIFS users create in a specific share belong to the same group (also called the
     * force-group). The force-group must be a predefined group in the UNIX group database. This setting has no effect unless
     * the security style of the volume is UNIX or mixed security style.
     */
    public readonly forceGroupForCreate!: pulumi.Output<string>;
    /**
     * Specifies whether or not the share is a home directory share, where the share and path names are dynamic. ONTAP home
     * directory functionality automatically offer each user a dynamic share to their home directory without creating an
     * individual SMB share for each user. The ONTAP CIFS home directory feature enable us to configure a share that maps to
     * different directories based on the user that connects to it. Instead of creating a separate shares for each user, a
     * single share with a home directory parameters can be created. In a home directory share, ONTAP dynamically generates the
     * share-name and share-path by substituting %w, %u, and %d variables with the corresponding Windows user name, UNIX user
     * name, and domain name, respectively.
     */
    public readonly homeDirectory!: pulumi.Output<boolean>;
    /**
     * Specifies the name of the CIFS share that you want to create. If this is a home directory share then the share name
     * includes the pattern as %w (Windows user name), %u (UNIX user name) and %d (Windows domain name) variables in any
     * combination with this parameter to generate shares dynamically.
     */
    public readonly name!: pulumi.Output<string>;
    /**
     * Specifies whether or not the SMB clients connecting to this share can cache the directory enumeration results returned
     * by the CIFS servers.
     */
    public readonly namespaceCaching!: pulumi.Output<boolean>;
    /**
     * Specifies whether or not CIFS clients can follow a unix symlinks outside the share boundaries.
     */
    public readonly noStrictSecurity!: pulumi.Output<boolean>;
    /**
     * Offline Files. The supported values are: none - Clients are not permitted to cache files for offline access. manual -
     * Clients may cache files that are explicitly selected by the user for offline access. documents - Clients may
     * automatically cache files that are used by the user for offline access. programs - Clients may automatically cache files
     * that are used by the user for offline access and may use those files in an offline mode even if the share is available.
     */
    public readonly offlineFiles!: pulumi.Output<string>;
    /**
     * Specify whether opportunistic locks are enabled on this share. "Oplocks" allow clients to lock files and cache content
     * locally, which can increase performance for file operations.
     */
    public readonly oplocks!: pulumi.Output<boolean>;
    /**
     * The fully-qualified pathname in the owning SVM namespace that is shared through this share. If this is a home directory
     * share then the path should be dynamic by specifying the pattern %w (Windows user name), %u (UNIX user name), or %d
     * (domain name) variables in any combination. ONTAP generates the path dynamically for the connected user and this path is
     * appended to each search path to find the full Home Directory path.
     */
    public readonly path!: pulumi.Output<string>;
    /**
     * Specifies whether or not the Snapshot copies can be viewed and traversed by clients.
     */
    public readonly showSnapshot!: pulumi.Output<boolean>;
    /**
     * svm name
     */
    public readonly svmName!: pulumi.Output<string>;
    /**
     * Controls the access of UNIX symbolic links to CIFS clients. The supported values are: * local - Enables only local
     * symbolic links which is within the same CIFS share. * widelink - Enables both local symlinks and widelinks. * disable -
     * Disables local symlinks and widelinks.
     */
    public readonly unixSymlink!: pulumi.Output<string>;
    /**
     * Vscan File-Operations Profile The supported values are: no_scan - Virus scans are never triggered for accesses to this
     * share. standard - Virus scans can be triggered by open, close, and rename operations. strict - Virus scans can be
     * triggered by open, read, close, and rename operations. writes_only - Virus scans can be triggered only when a file that
     * has been modified is closed.
     */
    public readonly vscanProfile!: pulumi.Output<string>;

    /**
     * Create a ProtocolsCifsShareResource resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ProtocolsCifsShareResourceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ProtocolsCifsShareResourceArgs | ProtocolsCifsShareResourceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ProtocolsCifsShareResourceState | undefined;
            resourceInputs["acls"] = state ? state.acls : undefined;
            resourceInputs["changeNotify"] = state ? state.changeNotify : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["continuouslyAvailable"] = state ? state.continuouslyAvailable : undefined;
            resourceInputs["cxProfileName"] = state ? state.cxProfileName : undefined;
            resourceInputs["dirUmask"] = state ? state.dirUmask : undefined;
            resourceInputs["encryption"] = state ? state.encryption : undefined;
            resourceInputs["fileUmask"] = state ? state.fileUmask : undefined;
            resourceInputs["forceGroupForCreate"] = state ? state.forceGroupForCreate : undefined;
            resourceInputs["homeDirectory"] = state ? state.homeDirectory : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["namespaceCaching"] = state ? state.namespaceCaching : undefined;
            resourceInputs["noStrictSecurity"] = state ? state.noStrictSecurity : undefined;
            resourceInputs["offlineFiles"] = state ? state.offlineFiles : undefined;
            resourceInputs["oplocks"] = state ? state.oplocks : undefined;
            resourceInputs["path"] = state ? state.path : undefined;
            resourceInputs["showSnapshot"] = state ? state.showSnapshot : undefined;
            resourceInputs["svmName"] = state ? state.svmName : undefined;
            resourceInputs["unixSymlink"] = state ? state.unixSymlink : undefined;
            resourceInputs["vscanProfile"] = state ? state.vscanProfile : undefined;
        } else {
            const args = argsOrState as ProtocolsCifsShareResourceArgs | undefined;
            if ((!args || args.cxProfileName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'cxProfileName'");
            }
            if ((!args || args.path === undefined) && !opts.urn) {
                throw new Error("Missing required property 'path'");
            }
            if ((!args || args.svmName === undefined) && !opts.urn) {
                throw new Error("Missing required property 'svmName'");
            }
            resourceInputs["acls"] = args ? args.acls : undefined;
            resourceInputs["changeNotify"] = args ? args.changeNotify : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["continuouslyAvailable"] = args ? args.continuouslyAvailable : undefined;
            resourceInputs["cxProfileName"] = args ? args.cxProfileName : undefined;
            resourceInputs["dirUmask"] = args ? args.dirUmask : undefined;
            resourceInputs["encryption"] = args ? args.encryption : undefined;
            resourceInputs["fileUmask"] = args ? args.fileUmask : undefined;
            resourceInputs["forceGroupForCreate"] = args ? args.forceGroupForCreate : undefined;
            resourceInputs["homeDirectory"] = args ? args.homeDirectory : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["namespaceCaching"] = args ? args.namespaceCaching : undefined;
            resourceInputs["noStrictSecurity"] = args ? args.noStrictSecurity : undefined;
            resourceInputs["offlineFiles"] = args ? args.offlineFiles : undefined;
            resourceInputs["oplocks"] = args ? args.oplocks : undefined;
            resourceInputs["path"] = args ? args.path : undefined;
            resourceInputs["showSnapshot"] = args ? args.showSnapshot : undefined;
            resourceInputs["svmName"] = args ? args.svmName : undefined;
            resourceInputs["unixSymlink"] = args ? args.unixSymlink : undefined;
            resourceInputs["vscanProfile"] = args ? args.vscanProfile : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ProtocolsCifsShareResource.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering ProtocolsCifsShareResource resources.
 */
export interface ProtocolsCifsShareResourceState {
    /**
     * The permissions that users and groups have on a CIFS share.
     */
    acls?: pulumi.Input<pulumi.Input<inputs.ProtocolsCifsShareResourceAcl>[]>;
    /**
     * Specifies whether CIFS clients can request for change notifications for directories on this share.
     */
    changeNotify?: pulumi.Input<boolean>;
    /**
     * Specify the CIFS share descriptions.
     */
    comment?: pulumi.Input<string>;
    /**
     * Specifies whether or not the clients connecting to this share can open files in a persistent manner.Files opened in this
     * way are protected from disruptive events, such as, failover and giveback.
     */
    continuouslyAvailable?: pulumi.Input<boolean>;
    /**
     * Connection profile name
     */
    cxProfileName?: pulumi.Input<string>;
    /**
     * Directory Mode Creation Mask to be viewed as an octal number.
     */
    dirUmask?: pulumi.Input<number>;
    /**
     * Specifies that SMB encryption must be used when accessing this share. Clients that do not support encryption are not
     * able to access this share.
     */
    encryption?: pulumi.Input<boolean>;
    /**
     * File Mode Creation Mask to be viewed as an octal number.
     */
    fileUmask?: pulumi.Input<number>;
    /**
     * Specifies that all files that CIFS users create in a specific share belong to the same group (also called the
     * force-group). The force-group must be a predefined group in the UNIX group database. This setting has no effect unless
     * the security style of the volume is UNIX or mixed security style.
     */
    forceGroupForCreate?: pulumi.Input<string>;
    /**
     * Specifies whether or not the share is a home directory share, where the share and path names are dynamic. ONTAP home
     * directory functionality automatically offer each user a dynamic share to their home directory without creating an
     * individual SMB share for each user. The ONTAP CIFS home directory feature enable us to configure a share that maps to
     * different directories based on the user that connects to it. Instead of creating a separate shares for each user, a
     * single share with a home directory parameters can be created. In a home directory share, ONTAP dynamically generates the
     * share-name and share-path by substituting %w, %u, and %d variables with the corresponding Windows user name, UNIX user
     * name, and domain name, respectively.
     */
    homeDirectory?: pulumi.Input<boolean>;
    /**
     * Specifies the name of the CIFS share that you want to create. If this is a home directory share then the share name
     * includes the pattern as %w (Windows user name), %u (UNIX user name) and %d (Windows domain name) variables in any
     * combination with this parameter to generate shares dynamically.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies whether or not the SMB clients connecting to this share can cache the directory enumeration results returned
     * by the CIFS servers.
     */
    namespaceCaching?: pulumi.Input<boolean>;
    /**
     * Specifies whether or not CIFS clients can follow a unix symlinks outside the share boundaries.
     */
    noStrictSecurity?: pulumi.Input<boolean>;
    /**
     * Offline Files. The supported values are: none - Clients are not permitted to cache files for offline access. manual -
     * Clients may cache files that are explicitly selected by the user for offline access. documents - Clients may
     * automatically cache files that are used by the user for offline access. programs - Clients may automatically cache files
     * that are used by the user for offline access and may use those files in an offline mode even if the share is available.
     */
    offlineFiles?: pulumi.Input<string>;
    /**
     * Specify whether opportunistic locks are enabled on this share. "Oplocks" allow clients to lock files and cache content
     * locally, which can increase performance for file operations.
     */
    oplocks?: pulumi.Input<boolean>;
    /**
     * The fully-qualified pathname in the owning SVM namespace that is shared through this share. If this is a home directory
     * share then the path should be dynamic by specifying the pattern %w (Windows user name), %u (UNIX user name), or %d
     * (domain name) variables in any combination. ONTAP generates the path dynamically for the connected user and this path is
     * appended to each search path to find the full Home Directory path.
     */
    path?: pulumi.Input<string>;
    /**
     * Specifies whether or not the Snapshot copies can be viewed and traversed by clients.
     */
    showSnapshot?: pulumi.Input<boolean>;
    /**
     * svm name
     */
    svmName?: pulumi.Input<string>;
    /**
     * Controls the access of UNIX symbolic links to CIFS clients. The supported values are: * local - Enables only local
     * symbolic links which is within the same CIFS share. * widelink - Enables both local symlinks and widelinks. * disable -
     * Disables local symlinks and widelinks.
     */
    unixSymlink?: pulumi.Input<string>;
    /**
     * Vscan File-Operations Profile The supported values are: no_scan - Virus scans are never triggered for accesses to this
     * share. standard - Virus scans can be triggered by open, close, and rename operations. strict - Virus scans can be
     * triggered by open, read, close, and rename operations. writes_only - Virus scans can be triggered only when a file that
     * has been modified is closed.
     */
    vscanProfile?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ProtocolsCifsShareResource resource.
 */
export interface ProtocolsCifsShareResourceArgs {
    /**
     * The permissions that users and groups have on a CIFS share.
     */
    acls?: pulumi.Input<pulumi.Input<inputs.ProtocolsCifsShareResourceAcl>[]>;
    /**
     * Specifies whether CIFS clients can request for change notifications for directories on this share.
     */
    changeNotify?: pulumi.Input<boolean>;
    /**
     * Specify the CIFS share descriptions.
     */
    comment?: pulumi.Input<string>;
    /**
     * Specifies whether or not the clients connecting to this share can open files in a persistent manner.Files opened in this
     * way are protected from disruptive events, such as, failover and giveback.
     */
    continuouslyAvailable?: pulumi.Input<boolean>;
    /**
     * Connection profile name
     */
    cxProfileName: pulumi.Input<string>;
    /**
     * Directory Mode Creation Mask to be viewed as an octal number.
     */
    dirUmask?: pulumi.Input<number>;
    /**
     * Specifies that SMB encryption must be used when accessing this share. Clients that do not support encryption are not
     * able to access this share.
     */
    encryption?: pulumi.Input<boolean>;
    /**
     * File Mode Creation Mask to be viewed as an octal number.
     */
    fileUmask?: pulumi.Input<number>;
    /**
     * Specifies that all files that CIFS users create in a specific share belong to the same group (also called the
     * force-group). The force-group must be a predefined group in the UNIX group database. This setting has no effect unless
     * the security style of the volume is UNIX or mixed security style.
     */
    forceGroupForCreate?: pulumi.Input<string>;
    /**
     * Specifies whether or not the share is a home directory share, where the share and path names are dynamic. ONTAP home
     * directory functionality automatically offer each user a dynamic share to their home directory without creating an
     * individual SMB share for each user. The ONTAP CIFS home directory feature enable us to configure a share that maps to
     * different directories based on the user that connects to it. Instead of creating a separate shares for each user, a
     * single share with a home directory parameters can be created. In a home directory share, ONTAP dynamically generates the
     * share-name and share-path by substituting %w, %u, and %d variables with the corresponding Windows user name, UNIX user
     * name, and domain name, respectively.
     */
    homeDirectory?: pulumi.Input<boolean>;
    /**
     * Specifies the name of the CIFS share that you want to create. If this is a home directory share then the share name
     * includes the pattern as %w (Windows user name), %u (UNIX user name) and %d (Windows domain name) variables in any
     * combination with this parameter to generate shares dynamically.
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies whether or not the SMB clients connecting to this share can cache the directory enumeration results returned
     * by the CIFS servers.
     */
    namespaceCaching?: pulumi.Input<boolean>;
    /**
     * Specifies whether or not CIFS clients can follow a unix symlinks outside the share boundaries.
     */
    noStrictSecurity?: pulumi.Input<boolean>;
    /**
     * Offline Files. The supported values are: none - Clients are not permitted to cache files for offline access. manual -
     * Clients may cache files that are explicitly selected by the user for offline access. documents - Clients may
     * automatically cache files that are used by the user for offline access. programs - Clients may automatically cache files
     * that are used by the user for offline access and may use those files in an offline mode even if the share is available.
     */
    offlineFiles?: pulumi.Input<string>;
    /**
     * Specify whether opportunistic locks are enabled on this share. "Oplocks" allow clients to lock files and cache content
     * locally, which can increase performance for file operations.
     */
    oplocks?: pulumi.Input<boolean>;
    /**
     * The fully-qualified pathname in the owning SVM namespace that is shared through this share. If this is a home directory
     * share then the path should be dynamic by specifying the pattern %w (Windows user name), %u (UNIX user name), or %d
     * (domain name) variables in any combination. ONTAP generates the path dynamically for the connected user and this path is
     * appended to each search path to find the full Home Directory path.
     */
    path: pulumi.Input<string>;
    /**
     * Specifies whether or not the Snapshot copies can be viewed and traversed by clients.
     */
    showSnapshot?: pulumi.Input<boolean>;
    /**
     * svm name
     */
    svmName: pulumi.Input<string>;
    /**
     * Controls the access of UNIX symbolic links to CIFS clients. The supported values are: * local - Enables only local
     * symbolic links which is within the same CIFS share. * widelink - Enables both local symlinks and widelinks. * disable -
     * Disables local symlinks and widelinks.
     */
    unixSymlink?: pulumi.Input<string>;
    /**
     * Vscan File-Operations Profile The supported values are: no_scan - Virus scans are never triggered for accesses to this
     * share. standard - Virus scans can be triggered by open, close, and rename operations. strict - Virus scans can be
     * triggered by open, read, close, and rename operations. writes_only - Virus scans can be triggered only when a file that
     * has been modified is closed.
     */
    vscanProfile?: pulumi.Input<string>;
}
