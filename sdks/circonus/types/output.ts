// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CheckCaql {
    /**
     * The query definition
     */
    query: string;
}

export interface CheckCloudwatch {
    /**
     * The AWS API Key
     */
    apiKey?: string;
    /**
     * The AWS API Secret
     */
    apiSecret?: string;
    /**
     * The dimensions to query for the metric
     */
    dimmensions: {[key: string]: string};
    /**
     * One or more CloudWatch Metric attributes
     */
    metrics: string[];
    /**
     * The namespace to pull telemetry from
     */
    namespace: string;
    /**
     * The URL including schema and hostname for the Cloudwatch monitoring server. This value will be used to specify the region - for example, to pull from us-east-1, the URL would be https://monitoring.us-east-1.amazonaws.com.
     */
    url: string;
    /**
     * The version of the Cloudwatch API to use.
     */
    version?: string;
}

export interface CheckCollector {
    /**
     * The ID of the collector
     */
    id: string;
}

export interface CheckConsul {
    /**
     * A Consul ACL token
     */
    aclToken?: string;
    /**
     * Allow Consul to read from a non-leader system
     */
    allowStale?: boolean;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: string;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: string;
    /**
     * A blacklist of check names to exclude from metric results
     */
    checkBlacklists?: string[];
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: string;
    /**
     * The Consul datacenter to extract health information from
     */
    dc?: string;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: {[key: string]: string};
    /**
     * The HTTP Address of a Consul agent to query
     */
    httpAddr?: string;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: string;
    /**
     * Node Name or NodeID of a Consul agent
     */
    node?: string;
    /**
     * A blacklist of node names or IDs to exclude from metric results
     */
    nodeBlacklists?: string[];
    /**
     * Name of the Consul service to check
     */
    service?: string;
    /**
     * A blacklist of service names to exclude from metric results
     */
    serviceBlacklists?: string[];
    /**
     * Check for Consul services in this particular state
     */
    state?: string;
}

export interface CheckDns {
    /**
     * The DNS class of the query. IN: Internet, CH: Chaos, HS: Hesoid.
     */
    ctype?: string;
    /**
     * The domain name server to query. If the name of the check is in-addr.arpa, the system default nameserver is used. Otherwise, the nameserver is the %[target] of the check.
     */
    nameserver?: string;
    /**
     * The query to send. If the name of the check is in-addr.arpa, the reverse IP octet notation of in-addr.arpa syntax is synthesized by default. Otherwise the default query is the name of the check itself.
     */
    query: string;
    /**
     * The DNS resource record type of the query. If the name of the check is in-addr.arpa, the default is PTR, otherwise it is A.
     */
    rtype?: string;
}

export interface CheckExternal {
    /**
     * The 1st argument to the command
     */
    arg1?: string;
    /**
     * The 10th argument to the command
     */
    arg10?: string;
    /**
     * The 2nd argument to the command
     */
    arg2?: string;
    /**
     * The 3rd argument to the command
     */
    arg3?: string;
    /**
     * The 4th argument to the command
     */
    arg4?: string;
    /**
     * The 5th argument to the command
     */
    arg5?: string;
    /**
     * The 6th argument to the command
     */
    arg6?: string;
    /**
     * The 7th argument to the command
     */
    arg7?: string;
    /**
     * The 8th argument to the command
     */
    arg8?: string;
    /**
     * The 9th argument to the command
     */
    arg9?: string;
    /**
     * The full path to the command to run
     */
    command: string;
    /**
     * The map of environment vars
     */
    env?: {[key: string]: string};
    /**
     * The output extraction method: JSON or NAGIOS, otherwise treated as regexp
     */
    outputExtract: string;
}

export interface CheckHttp {
    /**
     * The HTTP Authentication method
     */
    authMethod?: string;
    /**
     * The HTTP Authentication user password
     */
    authPassword?: string;
    /**
     * The HTTP Authentication user name
     */
    authUser?: string;
    /**
     * This regular expression is matched against the body of the response. If a match is not found, the check will be marked as "bad.
     */
    bodyRegexp?: string;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: string;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: string;
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: string;
    /**
     * The HTTP code that is expected. If the code received does not match this regular expression, the check is marked as "bad."
     */
    code?: string;
    /**
     * This regular expression is matched against the body of the response globally. The first capturing match is the key and the second capturing match is the value. Each key/value extracted is registered as a metric for the check.
     */
    extract?: string;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: {[key: string]: string};
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: string;
    /**
     * The HTTP method to use
     */
    method?: string;
    /**
     * The information transferred as the payload of an HTTP request
     */
    payload?: string;
    /**
     * Sets an approximate limit on the data read (0 means no limit)
     */
    readLimit?: number;
    /**
     * The maximum number of Location header redirects to follow.
     */
    redirects?: string;
    /**
     * The URL to use as the target of the check
     */
    url: string;
    /**
     * Sets the HTTP version for the check to use
     */
    version?: string;
}

export interface CheckHttptrap {
    /**
     * Specify whether httptrap metrics are logged immediately or held until the status message is emitted
     */
    asyncMetrics?: boolean;
    secret?: string;
}

export interface CheckIcmpPing {
    /**
     * The percentage of ICMP available required for the check to be considered "good."
     */
    availability?: number;
    /**
     * The number of ICMP requests to send during a single check.
     */
    count?: number;
    /**
     * The number of milliseconds between ICMP requests.
     */
    interval?: string;
}

export interface CheckJmx {
    /**
     * JMX host
     */
    host: string;
    /**
     * The space separated list of domains to filter to
     */
    mbeanDomains?: string[];
    /**
     * The space separated list of properties to filter to
     */
    mbeanProperties?: outputs.CheckJmxMbeanProperty[];
    /**
     * JMX password
     */
    password?: string;
    /**
     * JMX port
     */
    port: number;
    /**
     * JMX uri, defaults to '/jmxrmi'
     */
    uri?: string;
    /**
     * JMX username
     */
    username?: string;
}

export interface CheckJmxMbeanProperty {
    index: string;
    name: string;
    type: string;
}

export interface CheckJson {
    /**
     * The HTTP Authentication method
     */
    authMethod?: string;
    /**
     * The HTTP Authentication user password
     */
    authPassword?: string;
    /**
     * The HTTP Authentication user name
     */
    authUser?: string;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: string;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: string;
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: string;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: {[key: string]: string};
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: string;
    /**
     * The HTTP method to use
     */
    method?: string;
    /**
     * The information transferred as the payload of an HTTP request
     */
    payload?: string;
    /**
     * Specifies the port on which the management interface can be reached
     */
    port?: number;
    /**
     * Sets an approximate limit on the data read (0 means no limit)
     */
    readLimit?: number;
    /**
     * The URL to use as the target of the check
     */
    url: string;
    /**
     * Sets the HTTP version for the check to use
     */
    version?: string;
}

export interface CheckMemcached {
    /**
     * The port the memcached instance is listenening on, default 11211
     */
    port?: number;
}

export interface CheckMetric {
    /**
     * Enables or disables the metric
     */
    active?: boolean;
    /**
     * Name of the metric
     */
    name: string;
    /**
     * Type of metric (e.g. numeric, histogram, text)
     */
    type: string;
}

export interface CheckMetricFilter {
    /**
     * Comment on this filter
     */
    comment?: string;
    /**
     * Regex of the filter
     */
    regex: string;
    /**
     * The tag query to apply
     */
    tagQuery?: string;
    /**
     * 'allow' or 'deny'
     */
    type: string;
}

export interface CheckMysql {
    /**
     * The connect DSN for the MySQL instance
     */
    dsn: string;
    /**
     * The SQL to use as the query
     */
    query: string;
}

export interface CheckNtp {
    /**
     * The port to talk to NTP over (default: 123)
     */
    port?: number;
    /**
     * Control protocol means that the agent will request the NTP telemetry of the target regarding its preferred peer, (default: false)
     */
    useControl?: boolean;
}

export interface CheckPostgresql {
    /**
     * The connect DSN for the PostgreSQL instance
     */
    dsn: string;
    /**
     * The SQL to use as the query
     */
    query: string;
}

export interface CheckPromtext {
    /**
     * Specifies the port on which the prometheus metrics can be scraped
     */
    port?: number;
    /**
     * The URL to use as the target of the check
     */
    url: string;
}

export interface CheckRedis {
    /**
     * The redis command to run to gather stats, default: INFO.
     */
    command?: string;
    /**
     * The database index to query, defaults to zero
     */
    dbIndex?: number;
    /**
     * The pass required to run the command.
     */
    password?: string;
    /**
     * Specifies the port on which the Redis instance can be reached.
     */
    port?: number;
}

export interface CheckSmtp {
    /**
     * Specifies the EHLO parameter. (default: noit.local)
     */
    ehlo?: string;
    /**
     * Specifies the envelope sender.
     */
    from?: string;
    /**
     * Specifies the payload sent (on the wire). CR LF DOT CR LF is appended automatically. (default: Subject: Testing)
     */
    payload?: string;
    /**
     * Specifies the TCP port to connect to. (default: 25)
     */
    port?: number;
    /**
     * The IP (or string) to use as the destination address portion of the PROXY protocol. More on the proxy protocol here: http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
     */
    proxyDestAddress?: string;
    /**
     * The port to use as the dest port portion of the PROXY protocol. Defaults to the port setting or 25
     */
    proxyDestPort?: number;
    /**
     * The protocol family to send in the PROXY header. (default: TCP4)
     */
    proxyFamily?: string;
    /**
     * Test MTA responses to a PROXY protocol header by setting this to true. (default: false)
     */
    proxyProtocol?: boolean;
    /**
     * The IP (or string) to use as the source address portion of the PROXY protocol. More on the proxy protocol here: http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
     */
    proxySourceAddress?: string;
    /**
     * The port to use as the source port portion of the PROXY protocol. Defaults to the actual source port of the connection to the target_ip.
     */
    proxySourcePort?: number;
    /**
     * The SASL Authorization Identity.
     */
    saslAuthId?: string;
    /**
     * Specifies the type of SASL Authentication to use. (default: off)
     */
    saslAuthentication?: string;
    /**
     * The SASL Authentication password.
     */
    saslPassword?: string;
    /**
     * The SASL Authentication username.
     */
    saslUser?: string;
    /**
     * Specified if the client should attempt a STARTTLS upgrade. (default: false)
     */
    starttls?: boolean;
    /**
     * Specifies the envelope recipient.
     */
    to: string;
}

export interface CheckSnmp {
    /**
     * The authentication passphrase to use. Only applicaable to SNMP Version 3.
     */
    authPassphrase?: string;
    /**
     * The authentication protocol to use. Only applicaable to SNMP Version 3.
     */
    authProtocol?: string;
    /**
     * The SNMP community string providing read access.
     */
    community: string;
    /**
     * The context engine hex value to use. Only applicaable to SNMP Version 3.
     */
    contextEngine?: string;
    /**
     * The context name to use. Only applicaable to SNMP Version 3.
     */
    contextName?: string;
    /**
     * Defines a metric to query.
     */
    oids: outputs.CheckSnmpOid[];
    /**
     * The UDP port to which SNMP queries will be sent.
     */
    port?: number;
    /**
     * The privacy passphrase to use. Only applicaable to SNMP Version 3.
     */
    privacyPassphrase?: string;
    /**
     * The privacy protocol to use. Only applicaable to SNMP Version 3.
     */
    privacyProtocol?: string;
    /**
     * The security engine hex value to use. Only applicaable to SNMP Version 3.
     */
    securityEngine?: string;
    /**
     * The security level to use for the SNMP session. Choices are "authPriv" (authenticated and encrypted), "authNoPriv" (authenticated and unencrypted) and "noAuthNoPriv" (unauthenticated and unencrypted). Only applicaable to SNMP Version 3.
     */
    securityLevel?: string;
    /**
     * The security name (or user name) to use. Only applicaable to SNMP Version 3.
     */
    securityName?: string;
    /**
     * Whether or not to query each OID separately.
     */
    separateQueries?: boolean;
    /**
     * The SNMP version used for queries.
     */
    version: string;
}

export interface CheckSnmpOid {
    /**
     * Name of the metric produced by this MIB.
     */
    name: string;
    /**
     * The decimal notation or MIB name of this OID.
     */
    path: string;
    /**
     * The metric type of this OID. The value can be either one of the single letter codes in the metric_type_t enum or the following string variants: guess, int32, uint32, int64, uint64, double, string.
     */
    type?: string;
}

export interface CheckSsh2 {
    /**
     * The compress algorithm used from client to server
     */
    methodCompCs?: string;
    /**
     * The compress algorithm used from server to client
     */
    methodCompSc?: string;
    /**
     * The encryption algorithm used from client to server
     */
    methodCryptCs?: string;
    /**
     * The encryption algorithm used from server to client
     */
    methodCryptSc?: string;
    /**
     * The host key algorithm supported
     */
    methodHostkey?: string;
    /**
     * The key exchange method to use
     */
    methodKex?: string;
    /**
     * The language used from server to client
     */
    methodLandSc?: string;
    /**
     * The language used from client to server
     */
    methodLangCs?: string;
    /**
     * The message authentication code algorithm used from client to server
     */
    methodMacCs?: string;
    /**
     * The message authentication code algorithm used from server to client
     */
    methodMacSc?: string;
    /**
     * The TCP port on which the remote server's ssh service is running
     */
    port?: number;
}

export interface CheckStatsd {
    /**
     * The source IP of the statsd metrics stream
     */
    sourceIp: string;
}

export interface CheckTcp {
    /**
     * This regular expression is matched against the response banner. If a match is not found, the check will be marked as bad.
     */
    bannerRegexp?: string;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks).
     */
    caChain?: string;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS checks).
     */
    certificateFile?: string;
    /**
     * A list of ciphers to be used when establishing a TLS connection
     */
    ciphers?: string;
    /**
     * Specifies the host name or IP address to connect to for this TCP check
     */
    host: string;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: string;
    /**
     * Specifies the port on which the management interface can be reached.
     */
    port: number;
    /**
     * Upgrade TCP connection to use TLS.
     */
    tls?: boolean;
}

export interface ContactGroupAlertOption {
    escalateAfter?: string;
    escalateTo?: string;
    reminder?: string;
    severity: number;
}

export interface ContactGroupEmail {
    address?: string;
    user?: string;
}

export interface ContactGroupHttp {
    format?: string;
    method?: string;
    url: string;
}

export interface ContactGroupPagerDuty {
    account: string;
    contactGroupFallback?: string;
    serviceKey: string;
    webhookUrl: string;
}

export interface ContactGroupSlack {
    buttons?: boolean;
    channel: string;
    contactGroupFallback?: string;
    team: string;
    /**
     * Username Slackbot uses in Slack to deliver a notification
     */
    username?: string;
}

export interface ContactGroupSms {
    address?: string;
    user?: string;
}

export interface ContactGroupVictorop {
    apiKey: string;
    contactGroupFallback?: string;
    critical: number;
    info: number;
    team: string;
    warning: number;
}

export interface DashboardOption {
    accessConfigs?: outputs.DashboardOptionAccessConfig[];
    fullScreenHideTitle?: boolean;
    hideGrid?: boolean;
    scaleText?: boolean;
    textSize?: number;
}

export interface DashboardOptionAccessConfig {
    blackDash?: boolean;
    enabled?: boolean;
    fullScreen?: boolean;
    fullScreenHideTitle?: boolean;
    nickName?: string;
    scaleText?: boolean;
    sharedId?: string;
    textSize?: number;
}

export interface DashboardWidget {
    active?: boolean;
    height: number;
    name: string;
    origin: string;
    settings: outputs.DashboardWidgetSetting[];
    type: string;
    widgetId: string;
    width: number;
}

export interface DashboardWidgetSetting {
    accountId?: string;
    acknowledged?: string;
    algorithm?: string;
    autoformat?: boolean;
    badRules?: outputs.DashboardWidgetSettingBadRules;
    bodyFormat?: string;
    caql?: string;
    chartType?: string;
    checkUuid?: string;
    cleared?: string;
    clusterId?: number;
    clusterName?: string;
    contentType?: string;
    datapoints?: outputs.DashboardWidgetSettingDatapoint[];
    dateWindow?: string;
    dependents?: string;
    disableAutoformat?: boolean;
    display?: string;
    displayMarkup?: string;
    format?: string;
    formula?: string;
    goodColor?: string;
    graphUuid?: string;
    hideXaxis?: boolean;
    hideYaxis?: boolean;
    keyInline?: boolean;
    keyLoc?: string;
    keySize?: number;
    keyWrap?: boolean;
    label?: string;
    layout?: string;
    layoutStyle?: string;
    limit?: number;
    linkUrl?: string;
    maintenance?: string;
    markup?: string;
    metricDisplayName?: string;
    metricName?: string;
    metricType?: string;
    minAge?: string;
    overlaySetId?: string;
    period?: number;
    rangeHigh?: number;
    rangeLow?: number;
    realTime?: boolean;
    resourceLimit?: string;
    resourceUsage?: string;
    search?: string;
    severity?: string;
    showFlags?: boolean;
    showValue?: boolean;
    size?: string;
    textAlign?: string;
    threshold?: number;
    thresholds?: outputs.DashboardWidgetSettingThreshold[];
    timeWindow?: string;
    title?: string;
    titleFormat?: string;
    trend?: string;
    type?: string;
    useDefault?: boolean;
    valueType?: string;
}

export interface DashboardWidgetSettingBadRules {
    color: string;
    criterion: string;
    value: string;
}

export interface DashboardWidgetSettingDatapoint {
    _checkId: number;
    _metricType: string;
    label: string;
    metric: string;
}

export interface DashboardWidgetSettingThreshold {
    colors: string[];
    flip: boolean;
    values: string[];
}

export interface GetAccountInvite {
    email: string;
    role: string;
}

export interface GetAccountUsage {
    limit: number;
    type: string;
    used: number;
}

export interface GetAccountUser {
    id: string;
    role: string;
}

export interface GetCollectorDetail {
    cn: string;
    externalHost: string;
    externalPort: number;
    ip: string;
    minVersion: number;
    modules: string[];
    name: string;
    port: number;
    skew: string;
    status: string;
    version: number;
}

export interface GraphGuide {
    color?: string;
    formula?: string;
    hidden?: boolean;
    legendFormula?: string;
    name?: string;
}

export interface GraphMetric {
    active?: boolean;
    alpha?: string;
    axis?: string;
    caql?: string;
    check?: string;
    color?: string;
    formula?: string;
    function: string;
    legendFormula?: string;
    metricName?: string;
    metricType: string;
    name?: string;
    search?: string;
    stack?: string;
}

export interface GraphMetricCluster {
    active?: boolean;
    aggregate?: string;
    axis?: string;
    color?: string;
    name: string;
    query?: string;
}

export interface OverlaySetOverlay {
    dataOpts: outputs.OverlaySetOverlayDataOpt[];
    id: string;
    uiSpecs: outputs.OverlaySetOverlayUiSpec[];
}

export interface OverlaySetOverlayDataOpt {
    graphTitle: string;
    graphUuid: string;
    xShift: string;
}

export interface OverlaySetOverlayUiSpec {
    decouple?: boolean;
    id: string;
    label: string;
    type: string;
    z?: string;
}

export interface RuleSetGroupCondition {
    index: number;
    matchingSeverities: string[];
    ruleSet: string;
}

export interface RuleSetGroupFormula {
    expression: string;
    raiseSeverity: number;
    wait: number;
}

export interface RuleSetGroupNotify {
    sev1s?: string[];
    sev2s?: string[];
    sev3s?: string[];
    sev4s?: string[];
    sev5s?: string[];
}

export interface RuleSetIf {
    /**
     * Description of the action(s) to take when this rule set is active
     */
    then?: outputs.RuleSetIfThen;
    /**
     * Predicate that the rule set uses to evaluate a stream of metrics
     */
    value?: outputs.RuleSetIfValue;
}

export interface RuleSetIfThen {
    /**
     * The length of time we should wait before contacting the contact groups after this ruleset has faulted.
     */
    after?: string;
    /**
     * List of contact groups to notify at the following appropriate severity if this rule set is active.
     */
    notifies?: string[];
    /**
     * Send a notification at this severity level.
     */
    severity?: number;
}

export interface RuleSetIfValue {
    /**
     * Fire the rule set if there has been no data for the given metric stream over the last duration
     */
    absent?: string;
    /**
     * Boolean indicating the value has changed
     */
    changed?: string;
    /**
     * Fire the rule set if the text metric contain the following string
     */
    contains?: string;
    /**
     * Fire the rule set if the numeric value equals the specified value
     */
    eqValue?: string;
    /**
     * Fire the rule set if the text metric exactly match the following string
     */
    match?: string;
    /**
     * Fire the rule set if the numeric value is more than the specified value
     */
    maxValue?: string;
    /**
     * Fire the rule set if the numeric value less than the specified value
     */
    minValue?: string;
    /**
     * Fire the rule set if the numeric value does not equal the specified value
     */
    neqValue?: string;
    /**
     * Fire the rule set if the text metric does not contain the following string
     */
    notContain?: string;
    /**
     * Fire the rule set if the text metric not match the following string
     */
    notMatch?: string;
    /**
     * Use a derived value using a window
     */
    over?: outputs.RuleSetIfValueOver;
}

export interface RuleSetIfValueOver {
    /**
     * Wait at least this long (seconds) before evaluating the rule
     */
    atleast: string;
    /**
     * Duration over which data from the last interval is examined
     */
    last: string;
    /**
     * Define the window function to use over the last duration
     */
    using: string;
}

export interface WorksheetSmartQuery {
    name: string;
    orders?: string[];
    query: string;
}

