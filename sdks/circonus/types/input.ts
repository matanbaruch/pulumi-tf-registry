// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CheckCaql {
    /**
     * The query definition
     */
    query: pulumi.Input<string>;
}

export interface CheckCloudwatch {
    /**
     * The AWS API Key
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The AWS API Secret
     */
    apiSecret?: pulumi.Input<string>;
    /**
     * The dimensions to query for the metric
     */
    dimmensions: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * One or more CloudWatch Metric attributes
     */
    metrics: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The namespace to pull telemetry from
     */
    namespace: pulumi.Input<string>;
    /**
     * The URL including schema and hostname for the Cloudwatch monitoring server. This value will be used to specify the region - for example, to pull from us-east-1, the URL would be https://monitoring.us-east-1.amazonaws.com.
     */
    url: pulumi.Input<string>;
    /**
     * The version of the Cloudwatch API to use.
     */
    version?: pulumi.Input<string>;
}

export interface CheckCollector {
    /**
     * The ID of the collector
     */
    id: pulumi.Input<string>;
}

export interface CheckConsul {
    /**
     * A Consul ACL token
     */
    aclToken?: pulumi.Input<string>;
    /**
     * Allow Consul to read from a non-leader system
     */
    allowStale?: pulumi.Input<boolean>;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: pulumi.Input<string>;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: pulumi.Input<string>;
    /**
     * A blacklist of check names to exclude from metric results
     */
    checkBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: pulumi.Input<string>;
    /**
     * The Consul datacenter to extract health information from
     */
    dc?: pulumi.Input<string>;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The HTTP Address of a Consul agent to query
     */
    httpAddr?: pulumi.Input<string>;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: pulumi.Input<string>;
    /**
     * Node Name or NodeID of a Consul agent
     */
    node?: pulumi.Input<string>;
    /**
     * A blacklist of node names or IDs to exclude from metric results
     */
    nodeBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Name of the Consul service to check
     */
    service?: pulumi.Input<string>;
    /**
     * A blacklist of service names to exclude from metric results
     */
    serviceBlacklists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Check for Consul services in this particular state
     */
    state?: pulumi.Input<string>;
}

export interface CheckDns {
    /**
     * The DNS class of the query. IN: Internet, CH: Chaos, HS: Hesoid.
     */
    ctype?: pulumi.Input<string>;
    /**
     * The domain name server to query. If the name of the check is in-addr.arpa, the system default nameserver is used. Otherwise, the nameserver is the %[target] of the check.
     */
    nameserver?: pulumi.Input<string>;
    /**
     * The query to send. If the name of the check is in-addr.arpa, the reverse IP octet notation of in-addr.arpa syntax is synthesized by default. Otherwise the default query is the name of the check itself.
     */
    query: pulumi.Input<string>;
    /**
     * The DNS resource record type of the query. If the name of the check is in-addr.arpa, the default is PTR, otherwise it is A.
     */
    rtype?: pulumi.Input<string>;
}

export interface CheckExternal {
    /**
     * The 1st argument to the command
     */
    arg1?: pulumi.Input<string>;
    /**
     * The 10th argument to the command
     */
    arg10?: pulumi.Input<string>;
    /**
     * The 2nd argument to the command
     */
    arg2?: pulumi.Input<string>;
    /**
     * The 3rd argument to the command
     */
    arg3?: pulumi.Input<string>;
    /**
     * The 4th argument to the command
     */
    arg4?: pulumi.Input<string>;
    /**
     * The 5th argument to the command
     */
    arg5?: pulumi.Input<string>;
    /**
     * The 6th argument to the command
     */
    arg6?: pulumi.Input<string>;
    /**
     * The 7th argument to the command
     */
    arg7?: pulumi.Input<string>;
    /**
     * The 8th argument to the command
     */
    arg8?: pulumi.Input<string>;
    /**
     * The 9th argument to the command
     */
    arg9?: pulumi.Input<string>;
    /**
     * The full path to the command to run
     */
    command: pulumi.Input<string>;
    /**
     * The map of environment vars
     */
    env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * The output extraction method: JSON or NAGIOS, otherwise treated as regexp
     */
    outputExtract: pulumi.Input<string>;
}

export interface CheckHttp {
    /**
     * The HTTP Authentication method
     */
    authMethod?: pulumi.Input<string>;
    /**
     * The HTTP Authentication user password
     */
    authPassword?: pulumi.Input<string>;
    /**
     * The HTTP Authentication user name
     */
    authUser?: pulumi.Input<string>;
    /**
     * This regular expression is matched against the body of the response. If a match is not found, the check will be marked as "bad.
     */
    bodyRegexp?: pulumi.Input<string>;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: pulumi.Input<string>;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: pulumi.Input<string>;
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: pulumi.Input<string>;
    /**
     * The HTTP code that is expected. If the code received does not match this regular expression, the check is marked as "bad."
     */
    code?: pulumi.Input<string>;
    /**
     * This regular expression is matched against the body of the response globally. The first capturing match is the key and the second capturing match is the value. Each key/value extracted is registered as a metric for the check.
     */
    extract?: pulumi.Input<string>;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: pulumi.Input<string>;
    /**
     * The HTTP method to use
     */
    method?: pulumi.Input<string>;
    /**
     * The information transferred as the payload of an HTTP request
     */
    payload?: pulumi.Input<string>;
    /**
     * Sets an approximate limit on the data read (0 means no limit)
     */
    readLimit?: pulumi.Input<number>;
    /**
     * The maximum number of Location header redirects to follow.
     */
    redirects?: pulumi.Input<string>;
    /**
     * The URL to use as the target of the check
     */
    url: pulumi.Input<string>;
    /**
     * Sets the HTTP version for the check to use
     */
    version?: pulumi.Input<string>;
}

export interface CheckHttptrap {
    /**
     * Specify whether httptrap metrics are logged immediately or held until the status message is emitted
     */
    asyncMetrics?: pulumi.Input<boolean>;
    secret?: pulumi.Input<string>;
}

export interface CheckIcmpPing {
    /**
     * The percentage of ICMP available required for the check to be considered "good."
     */
    availability?: pulumi.Input<number>;
    /**
     * The number of ICMP requests to send during a single check.
     */
    count?: pulumi.Input<number>;
    /**
     * The number of milliseconds between ICMP requests.
     */
    interval?: pulumi.Input<string>;
}

export interface CheckJmx {
    /**
     * JMX host
     */
    host: pulumi.Input<string>;
    /**
     * The space separated list of domains to filter to
     */
    mbeanDomains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The space separated list of properties to filter to
     */
    mbeanProperties?: pulumi.Input<pulumi.Input<inputs.CheckJmxMbeanProperty>[]>;
    /**
     * JMX password
     */
    password?: pulumi.Input<string>;
    /**
     * JMX port
     */
    port: pulumi.Input<number>;
    /**
     * JMX uri, defaults to '/jmxrmi'
     */
    uri?: pulumi.Input<string>;
    /**
     * JMX username
     */
    username?: pulumi.Input<string>;
}

export interface CheckJmxMbeanProperty {
    index: pulumi.Input<string>;
    name: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface CheckJson {
    /**
     * The HTTP Authentication method
     */
    authMethod?: pulumi.Input<string>;
    /**
     * The HTTP Authentication user password
     */
    authPassword?: pulumi.Input<string>;
    /**
     * The HTTP Authentication user name
     */
    authUser?: pulumi.Input<string>;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks)
     */
    caChain?: pulumi.Input<string>;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS-enabled checks)
     */
    certificateFile?: pulumi.Input<string>;
    /**
     * A list of ciphers to be used in the TLS protocol (for HTTPS checks)
     */
    ciphers?: pulumi.Input<string>;
    /**
     * Map of HTTP Headers to send along with HTTP Requests
     */
    headers?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: pulumi.Input<string>;
    /**
     * The HTTP method to use
     */
    method?: pulumi.Input<string>;
    /**
     * The information transferred as the payload of an HTTP request
     */
    payload?: pulumi.Input<string>;
    /**
     * Specifies the port on which the management interface can be reached
     */
    port?: pulumi.Input<number>;
    /**
     * Sets an approximate limit on the data read (0 means no limit)
     */
    readLimit?: pulumi.Input<number>;
    /**
     * The URL to use as the target of the check
     */
    url: pulumi.Input<string>;
    /**
     * Sets the HTTP version for the check to use
     */
    version?: pulumi.Input<string>;
}

export interface CheckMemcached {
    /**
     * The port the memcached instance is listenening on, default 11211
     */
    port?: pulumi.Input<number>;
}

export interface CheckMetric {
    /**
     * Enables or disables the metric
     */
    active?: pulumi.Input<boolean>;
    /**
     * Name of the metric
     */
    name: pulumi.Input<string>;
    /**
     * Type of metric (e.g. numeric, histogram, text)
     */
    type: pulumi.Input<string>;
}

export interface CheckMetricFilter {
    /**
     * Comment on this filter
     */
    comment?: pulumi.Input<string>;
    /**
     * Regex of the filter
     */
    regex: pulumi.Input<string>;
    /**
     * The tag query to apply
     */
    tagQuery?: pulumi.Input<string>;
    /**
     * 'allow' or 'deny'
     */
    type: pulumi.Input<string>;
}

export interface CheckMysql {
    /**
     * The connect DSN for the MySQL instance
     */
    dsn: pulumi.Input<string>;
    /**
     * The SQL to use as the query
     */
    query: pulumi.Input<string>;
}

export interface CheckNtp {
    /**
     * The port to talk to NTP over (default: 123)
     */
    port?: pulumi.Input<number>;
    /**
     * Control protocol means that the agent will request the NTP telemetry of the target regarding its preferred peer, (default: false)
     */
    useControl?: pulumi.Input<boolean>;
}

export interface CheckPostgresql {
    /**
     * The connect DSN for the PostgreSQL instance
     */
    dsn: pulumi.Input<string>;
    /**
     * The SQL to use as the query
     */
    query: pulumi.Input<string>;
}

export interface CheckPromtext {
    /**
     * Specifies the port on which the prometheus metrics can be scraped
     */
    port?: pulumi.Input<number>;
    /**
     * The URL to use as the target of the check
     */
    url: pulumi.Input<string>;
}

export interface CheckRedis {
    /**
     * The redis command to run to gather stats, default: INFO.
     */
    command?: pulumi.Input<string>;
    /**
     * The database index to query, defaults to zero
     */
    dbIndex?: pulumi.Input<number>;
    /**
     * The pass required to run the command.
     */
    password?: pulumi.Input<string>;
    /**
     * Specifies the port on which the Redis instance can be reached.
     */
    port?: pulumi.Input<number>;
}

export interface CheckSmtp {
    /**
     * Specifies the EHLO parameter. (default: noit.local)
     */
    ehlo?: pulumi.Input<string>;
    /**
     * Specifies the envelope sender.
     */
    from?: pulumi.Input<string>;
    /**
     * Specifies the payload sent (on the wire). CR LF DOT CR LF is appended automatically. (default: Subject: Testing)
     */
    payload?: pulumi.Input<string>;
    /**
     * Specifies the TCP port to connect to. (default: 25)
     */
    port?: pulumi.Input<number>;
    /**
     * The IP (or string) to use as the destination address portion of the PROXY protocol. More on the proxy protocol here: http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
     */
    proxyDestAddress?: pulumi.Input<string>;
    /**
     * The port to use as the dest port portion of the PROXY protocol. Defaults to the port setting or 25
     */
    proxyDestPort?: pulumi.Input<number>;
    /**
     * The protocol family to send in the PROXY header. (default: TCP4)
     */
    proxyFamily?: pulumi.Input<string>;
    /**
     * Test MTA responses to a PROXY protocol header by setting this to true. (default: false)
     */
    proxyProtocol?: pulumi.Input<boolean>;
    /**
     * The IP (or string) to use as the source address portion of the PROXY protocol. More on the proxy protocol here: http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt
     */
    proxySourceAddress?: pulumi.Input<string>;
    /**
     * The port to use as the source port portion of the PROXY protocol. Defaults to the actual source port of the connection to the target_ip.
     */
    proxySourcePort?: pulumi.Input<number>;
    /**
     * The SASL Authorization Identity.
     */
    saslAuthId?: pulumi.Input<string>;
    /**
     * Specifies the type of SASL Authentication to use. (default: off)
     */
    saslAuthentication?: pulumi.Input<string>;
    /**
     * The SASL Authentication password.
     */
    saslPassword?: pulumi.Input<string>;
    /**
     * The SASL Authentication username.
     */
    saslUser?: pulumi.Input<string>;
    /**
     * Specified if the client should attempt a STARTTLS upgrade. (default: false)
     */
    starttls?: pulumi.Input<boolean>;
    /**
     * Specifies the envelope recipient.
     */
    to: pulumi.Input<string>;
}

export interface CheckSnmp {
    /**
     * The authentication passphrase to use. Only applicaable to SNMP Version 3.
     */
    authPassphrase?: pulumi.Input<string>;
    /**
     * The authentication protocol to use. Only applicaable to SNMP Version 3.
     */
    authProtocol?: pulumi.Input<string>;
    /**
     * The SNMP community string providing read access.
     */
    community: pulumi.Input<string>;
    /**
     * The context engine hex value to use. Only applicaable to SNMP Version 3.
     */
    contextEngine?: pulumi.Input<string>;
    /**
     * The context name to use. Only applicaable to SNMP Version 3.
     */
    contextName?: pulumi.Input<string>;
    /**
     * Defines a metric to query.
     */
    oids: pulumi.Input<pulumi.Input<inputs.CheckSnmpOid>[]>;
    /**
     * The UDP port to which SNMP queries will be sent.
     */
    port?: pulumi.Input<number>;
    /**
     * The privacy passphrase to use. Only applicaable to SNMP Version 3.
     */
    privacyPassphrase?: pulumi.Input<string>;
    /**
     * The privacy protocol to use. Only applicaable to SNMP Version 3.
     */
    privacyProtocol?: pulumi.Input<string>;
    /**
     * The security engine hex value to use. Only applicaable to SNMP Version 3.
     */
    securityEngine?: pulumi.Input<string>;
    /**
     * The security level to use for the SNMP session. Choices are "authPriv" (authenticated and encrypted), "authNoPriv" (authenticated and unencrypted) and "noAuthNoPriv" (unauthenticated and unencrypted). Only applicaable to SNMP Version 3.
     */
    securityLevel?: pulumi.Input<string>;
    /**
     * The security name (or user name) to use. Only applicaable to SNMP Version 3.
     */
    securityName?: pulumi.Input<string>;
    /**
     * Whether or not to query each OID separately.
     */
    separateQueries?: pulumi.Input<boolean>;
    /**
     * The SNMP version used for queries.
     */
    version: pulumi.Input<string>;
}

export interface CheckSnmpOid {
    /**
     * Name of the metric produced by this MIB.
     */
    name: pulumi.Input<string>;
    /**
     * The decimal notation or MIB name of this OID.
     */
    path: pulumi.Input<string>;
    /**
     * The metric type of this OID. The value can be either one of the single letter codes in the metric_type_t enum or the following string variants: guess, int32, uint32, int64, uint64, double, string.
     */
    type?: pulumi.Input<string>;
}

export interface CheckSsh2 {
    /**
     * The compress algorithm used from client to server
     */
    methodCompCs?: pulumi.Input<string>;
    /**
     * The compress algorithm used from server to client
     */
    methodCompSc?: pulumi.Input<string>;
    /**
     * The encryption algorithm used from client to server
     */
    methodCryptCs?: pulumi.Input<string>;
    /**
     * The encryption algorithm used from server to client
     */
    methodCryptSc?: pulumi.Input<string>;
    /**
     * The host key algorithm supported
     */
    methodHostkey?: pulumi.Input<string>;
    /**
     * The key exchange method to use
     */
    methodKex?: pulumi.Input<string>;
    /**
     * The language used from server to client
     */
    methodLandSc?: pulumi.Input<string>;
    /**
     * The language used from client to server
     */
    methodLangCs?: pulumi.Input<string>;
    /**
     * The message authentication code algorithm used from client to server
     */
    methodMacCs?: pulumi.Input<string>;
    /**
     * The message authentication code algorithm used from server to client
     */
    methodMacSc?: pulumi.Input<string>;
    /**
     * The TCP port on which the remote server's ssh service is running
     */
    port?: pulumi.Input<number>;
}

export interface CheckStatsd {
    /**
     * The source IP of the statsd metrics stream
     */
    sourceIp: pulumi.Input<string>;
}

export interface CheckTcp {
    /**
     * This regular expression is matched against the response banner. If a match is not found, the check will be marked as bad.
     */
    bannerRegexp?: pulumi.Input<string>;
    /**
     * A path to a file containing all the certificate authorities that should be loaded to validate the remote certificate (for TLS checks).
     */
    caChain?: pulumi.Input<string>;
    /**
     * A path to a file containing the client certificate that will be presented to the remote server (for TLS checks).
     */
    certificateFile?: pulumi.Input<string>;
    /**
     * A list of ciphers to be used when establishing a TLS connection
     */
    ciphers?: pulumi.Input<string>;
    /**
     * Specifies the host name or IP address to connect to for this TCP check
     */
    host: pulumi.Input<string>;
    /**
     * A path to a file containing key to be used in conjunction with the cilent certificate (for TLS checks)
     */
    keyFile?: pulumi.Input<string>;
    /**
     * Specifies the port on which the management interface can be reached.
     */
    port: pulumi.Input<number>;
    /**
     * Upgrade TCP connection to use TLS.
     */
    tls?: pulumi.Input<boolean>;
}

export interface ContactGroupAlertOption {
    escalateAfter?: pulumi.Input<string>;
    escalateTo?: pulumi.Input<string>;
    reminder?: pulumi.Input<string>;
    severity: pulumi.Input<number>;
}

export interface ContactGroupEmail {
    address?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ContactGroupHttp {
    format?: pulumi.Input<string>;
    method?: pulumi.Input<string>;
    url: pulumi.Input<string>;
}

export interface ContactGroupPagerDuty {
    account: pulumi.Input<string>;
    contactGroupFallback?: pulumi.Input<string>;
    serviceKey: pulumi.Input<string>;
    webhookUrl: pulumi.Input<string>;
}

export interface ContactGroupSlack {
    buttons?: pulumi.Input<boolean>;
    channel: pulumi.Input<string>;
    contactGroupFallback?: pulumi.Input<string>;
    team: pulumi.Input<string>;
    /**
     * Username Slackbot uses in Slack to deliver a notification
     */
    username?: pulumi.Input<string>;
}

export interface ContactGroupSms {
    address?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ContactGroupVictorop {
    apiKey: pulumi.Input<string>;
    contactGroupFallback?: pulumi.Input<string>;
    critical: pulumi.Input<number>;
    info: pulumi.Input<number>;
    team: pulumi.Input<string>;
    warning: pulumi.Input<number>;
}

export interface DashboardOption {
    accessConfigs?: pulumi.Input<pulumi.Input<inputs.DashboardOptionAccessConfig>[]>;
    fullScreenHideTitle?: pulumi.Input<boolean>;
    hideGrid?: pulumi.Input<boolean>;
    scaleText?: pulumi.Input<boolean>;
    textSize?: pulumi.Input<number>;
}

export interface DashboardOptionAccessConfig {
    blackDash?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    fullScreen?: pulumi.Input<boolean>;
    fullScreenHideTitle?: pulumi.Input<boolean>;
    nickName?: pulumi.Input<string>;
    scaleText?: pulumi.Input<boolean>;
    sharedId?: pulumi.Input<string>;
    textSize?: pulumi.Input<number>;
}

export interface DashboardWidget {
    active?: pulumi.Input<boolean>;
    height: pulumi.Input<number>;
    name: pulumi.Input<string>;
    origin: pulumi.Input<string>;
    settings: pulumi.Input<pulumi.Input<inputs.DashboardWidgetSetting>[]>;
    type: pulumi.Input<string>;
    widgetId: pulumi.Input<string>;
    width: pulumi.Input<number>;
}

export interface DashboardWidgetSetting {
    accountId?: pulumi.Input<string>;
    acknowledged?: pulumi.Input<string>;
    algorithm?: pulumi.Input<string>;
    autoformat?: pulumi.Input<boolean>;
    badRules?: pulumi.Input<inputs.DashboardWidgetSettingBadRules>;
    bodyFormat?: pulumi.Input<string>;
    caql?: pulumi.Input<string>;
    chartType?: pulumi.Input<string>;
    checkUuid?: pulumi.Input<string>;
    cleared?: pulumi.Input<string>;
    clusterId?: pulumi.Input<number>;
    clusterName?: pulumi.Input<string>;
    contentType?: pulumi.Input<string>;
    datapoints?: pulumi.Input<pulumi.Input<inputs.DashboardWidgetSettingDatapoint>[]>;
    dateWindow?: pulumi.Input<string>;
    dependents?: pulumi.Input<string>;
    disableAutoformat?: pulumi.Input<boolean>;
    display?: pulumi.Input<string>;
    displayMarkup?: pulumi.Input<string>;
    format?: pulumi.Input<string>;
    formula?: pulumi.Input<string>;
    goodColor?: pulumi.Input<string>;
    graphUuid?: pulumi.Input<string>;
    hideXaxis?: pulumi.Input<boolean>;
    hideYaxis?: pulumi.Input<boolean>;
    keyInline?: pulumi.Input<boolean>;
    keyLoc?: pulumi.Input<string>;
    keySize?: pulumi.Input<number>;
    keyWrap?: pulumi.Input<boolean>;
    label?: pulumi.Input<string>;
    layout?: pulumi.Input<string>;
    layoutStyle?: pulumi.Input<string>;
    limit?: pulumi.Input<number>;
    linkUrl?: pulumi.Input<string>;
    maintenance?: pulumi.Input<string>;
    markup?: pulumi.Input<string>;
    metricDisplayName?: pulumi.Input<string>;
    metricName?: pulumi.Input<string>;
    metricType?: pulumi.Input<string>;
    minAge?: pulumi.Input<string>;
    overlaySetId?: pulumi.Input<string>;
    period?: pulumi.Input<number>;
    rangeHigh?: pulumi.Input<number>;
    rangeLow?: pulumi.Input<number>;
    realTime?: pulumi.Input<boolean>;
    resourceLimit?: pulumi.Input<string>;
    resourceUsage?: pulumi.Input<string>;
    search?: pulumi.Input<string>;
    severity?: pulumi.Input<string>;
    showFlags?: pulumi.Input<boolean>;
    showValue?: pulumi.Input<boolean>;
    size?: pulumi.Input<string>;
    textAlign?: pulumi.Input<string>;
    threshold?: pulumi.Input<number>;
    thresholds?: pulumi.Input<pulumi.Input<inputs.DashboardWidgetSettingThreshold>[]>;
    timeWindow?: pulumi.Input<string>;
    title?: pulumi.Input<string>;
    titleFormat?: pulumi.Input<string>;
    trend?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
    useDefault?: pulumi.Input<boolean>;
    valueType?: pulumi.Input<string>;
}

export interface DashboardWidgetSettingBadRules {
    color: pulumi.Input<string>;
    criterion: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface DashboardWidgetSettingDatapoint {
    _checkId: pulumi.Input<number>;
    _metricType: pulumi.Input<string>;
    label: pulumi.Input<string>;
    metric: pulumi.Input<string>;
}

export interface DashboardWidgetSettingThreshold {
    colors: pulumi.Input<pulumi.Input<string>[]>;
    flip: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface GraphGuide {
    color?: pulumi.Input<string>;
    formula?: pulumi.Input<string>;
    hidden?: pulumi.Input<boolean>;
    legendFormula?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
}

export interface GraphMetric {
    active?: pulumi.Input<boolean>;
    alpha?: pulumi.Input<string>;
    axis?: pulumi.Input<string>;
    caql?: pulumi.Input<string>;
    check?: pulumi.Input<string>;
    color?: pulumi.Input<string>;
    formula?: pulumi.Input<string>;
    function?: pulumi.Input<string>;
    legendFormula?: pulumi.Input<string>;
    metricName?: pulumi.Input<string>;
    metricType: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    search?: pulumi.Input<string>;
    stack?: pulumi.Input<string>;
}

export interface GraphMetricCluster {
    active?: pulumi.Input<boolean>;
    aggregate?: pulumi.Input<string>;
    axis?: pulumi.Input<string>;
    color?: pulumi.Input<string>;
    name: pulumi.Input<string>;
    query?: pulumi.Input<string>;
}

export interface OverlaySetOverlay {
    dataOpts: pulumi.Input<pulumi.Input<inputs.OverlaySetOverlayDataOpt>[]>;
    id: pulumi.Input<string>;
    uiSpecs: pulumi.Input<pulumi.Input<inputs.OverlaySetOverlayUiSpec>[]>;
}

export interface OverlaySetOverlayDataOpt {
    graphTitle: pulumi.Input<string>;
    graphUuid: pulumi.Input<string>;
    xShift: pulumi.Input<string>;
}

export interface OverlaySetOverlayUiSpec {
    decouple?: pulumi.Input<boolean>;
    id: pulumi.Input<string>;
    label: pulumi.Input<string>;
    type: pulumi.Input<string>;
    z?: pulumi.Input<string>;
}

export interface RuleSetGroupCondition {
    index: pulumi.Input<number>;
    matchingSeverities: pulumi.Input<pulumi.Input<string>[]>;
    ruleSet: pulumi.Input<string>;
}

export interface RuleSetGroupFormula {
    expression: pulumi.Input<string>;
    raiseSeverity: pulumi.Input<number>;
    wait: pulumi.Input<number>;
}

export interface RuleSetGroupNotify {
    sev1s?: pulumi.Input<pulumi.Input<string>[]>;
    sev2s?: pulumi.Input<pulumi.Input<string>[]>;
    sev3s?: pulumi.Input<pulumi.Input<string>[]>;
    sev4s?: pulumi.Input<pulumi.Input<string>[]>;
    sev5s?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface RuleSetIf {
    /**
     * Description of the action(s) to take when this rule set is active
     */
    then?: pulumi.Input<inputs.RuleSetIfThen>;
    /**
     * Predicate that the rule set uses to evaluate a stream of metrics
     */
    value?: pulumi.Input<inputs.RuleSetIfValue>;
}

export interface RuleSetIfThen {
    /**
     * The length of time we should wait before contacting the contact groups after this ruleset has faulted.
     */
    after?: pulumi.Input<string>;
    /**
     * List of contact groups to notify at the following appropriate severity if this rule set is active.
     */
    notifies?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Send a notification at this severity level.
     */
    severity?: pulumi.Input<number>;
}

export interface RuleSetIfValue {
    /**
     * Fire the rule set if there has been no data for the given metric stream over the last duration
     */
    absent?: pulumi.Input<string>;
    /**
     * Boolean indicating the value has changed
     */
    changed?: pulumi.Input<string>;
    /**
     * Fire the rule set if the text metric contain the following string
     */
    contains?: pulumi.Input<string>;
    /**
     * Fire the rule set if the numeric value equals the specified value
     */
    eqValue?: pulumi.Input<string>;
    /**
     * Fire the rule set if the text metric exactly match the following string
     */
    match?: pulumi.Input<string>;
    /**
     * Fire the rule set if the numeric value is more than the specified value
     */
    maxValue?: pulumi.Input<string>;
    /**
     * Fire the rule set if the numeric value less than the specified value
     */
    minValue?: pulumi.Input<string>;
    /**
     * Fire the rule set if the numeric value does not equal the specified value
     */
    neqValue?: pulumi.Input<string>;
    /**
     * Fire the rule set if the text metric does not contain the following string
     */
    notContain?: pulumi.Input<string>;
    /**
     * Fire the rule set if the text metric not match the following string
     */
    notMatch?: pulumi.Input<string>;
    /**
     * Use a derived value using a window
     */
    over?: pulumi.Input<inputs.RuleSetIfValueOver>;
}

export interface RuleSetIfValueOver {
    /**
     * Wait at least this long (seconds) before evaluating the rule
     */
    atleast: pulumi.Input<string>;
    /**
     * Duration over which data from the last interval is examined
     */
    last: pulumi.Input<string>;
    /**
     * Define the window function to use over the last duration
     */
    using: pulumi.Input<string>;
}

export interface WorksheetSmartQuery {
    name: pulumi.Input<string>;
    orders?: pulumi.Input<pulumi.Input<string>[]>;
    query: pulumi.Input<string>;
}
