// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Domain extends pulumi.CustomResource {
    /**
     * Get an existing Domain resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: DomainState, opts?: pulumi.CustomResourceOptions): Domain {
        return new Domain(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'gocache:index/domain:Domain';

    /**
     * Returns true if the given object is an instance of Domain.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Domain {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Domain.__pulumiType;
    }

    public readonly cache301!: pulumi.Output<boolean | undefined>;
    public readonly cache302!: pulumi.Output<boolean | undefined>;
    public readonly cache404!: pulumi.Output<boolean | undefined>;
    public readonly cacheTtl!: pulumi.Output<number | undefined>;
    public readonly cachingBehavior!: pulumi.Output<string | undefined>;
    public readonly deployMode!: pulumi.Output<boolean | undefined>;
    public readonly dnsMode!: pulumi.Output<string | undefined>;
    public readonly domain!: pulumi.Output<string>;
    public readonly expireBypassSec!: pulumi.Output<number | undefined>;
    public readonly expiresTtl!: pulumi.Output<number | undefined>;
    public readonly gzipStatus!: pulumi.Output<boolean | undefined>;
    public readonly headerDeviceType!: pulumi.Output<boolean | undefined>;
    public readonly headerGeoipContinent!: pulumi.Output<boolean | undefined>;
    public readonly headerGeoipCountry!: pulumi.Output<boolean | undefined>;
    public readonly headerGeoipOrg!: pulumi.Output<boolean | undefined>;
    public readonly ignoreCacheControl!: pulumi.Output<boolean | undefined>;
    public readonly ignoreExpires!: pulumi.Output<boolean | undefined>;
    public readonly ignoreVary!: pulumi.Output<boolean | undefined>;
    public readonly imageOptimize!: pulumi.Output<boolean | undefined>;
    public readonly imageOptimizeLevel!: pulumi.Output<number | undefined>;
    public readonly imageOptimizeMetadata!: pulumi.Output<boolean | undefined>;
    public readonly imageOptimizeProgressive!: pulumi.Output<boolean | undefined>;
    public readonly imageOptimizeWebp!: pulumi.Output<boolean | undefined>;
    public readonly lastUpdated!: pulumi.Output<string>;
    public readonly logFreq!: pulumi.Output<number | undefined>;
    public readonly publicLog!: pulumi.Output<string | undefined>;
    public readonly rateLimitIgnoreGoodBots!: pulumi.Output<boolean | undefined>;
    public readonly rateLimitIgnoreStaticContent!: pulumi.Output<boolean | undefined>;
    public readonly rateLimitStatus!: pulumi.Output<boolean | undefined>;
    public readonly smartCacheStatus!: pulumi.Output<boolean | undefined>;
    public readonly smartCacheTemplate!: pulumi.Output<string | undefined>;
    public readonly smartCacheTtl!: pulumi.Output<number | undefined>;
    public readonly sslMode!: pulumi.Output<string | undefined>;
    public readonly tls10!: pulumi.Output<boolean | undefined>;
    public readonly tls11!: pulumi.Output<boolean | undefined>;
    public readonly tls12!: pulumi.Output<boolean | undefined>;
    public readonly wafLevel!: pulumi.Output<string | undefined>;
    public readonly wafMode!: pulumi.Output<string | undefined>;
    public readonly wafStatus!: pulumi.Output<boolean | undefined>;

    /**
     * Create a Domain resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: DomainArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: DomainArgs | DomainState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as DomainState | undefined;
            resourceInputs["cache301"] = state ? state.cache301 : undefined;
            resourceInputs["cache302"] = state ? state.cache302 : undefined;
            resourceInputs["cache404"] = state ? state.cache404 : undefined;
            resourceInputs["cacheTtl"] = state ? state.cacheTtl : undefined;
            resourceInputs["cachingBehavior"] = state ? state.cachingBehavior : undefined;
            resourceInputs["deployMode"] = state ? state.deployMode : undefined;
            resourceInputs["dnsMode"] = state ? state.dnsMode : undefined;
            resourceInputs["domain"] = state ? state.domain : undefined;
            resourceInputs["expireBypassSec"] = state ? state.expireBypassSec : undefined;
            resourceInputs["expiresTtl"] = state ? state.expiresTtl : undefined;
            resourceInputs["gzipStatus"] = state ? state.gzipStatus : undefined;
            resourceInputs["headerDeviceType"] = state ? state.headerDeviceType : undefined;
            resourceInputs["headerGeoipContinent"] = state ? state.headerGeoipContinent : undefined;
            resourceInputs["headerGeoipCountry"] = state ? state.headerGeoipCountry : undefined;
            resourceInputs["headerGeoipOrg"] = state ? state.headerGeoipOrg : undefined;
            resourceInputs["ignoreCacheControl"] = state ? state.ignoreCacheControl : undefined;
            resourceInputs["ignoreExpires"] = state ? state.ignoreExpires : undefined;
            resourceInputs["ignoreVary"] = state ? state.ignoreVary : undefined;
            resourceInputs["imageOptimize"] = state ? state.imageOptimize : undefined;
            resourceInputs["imageOptimizeLevel"] = state ? state.imageOptimizeLevel : undefined;
            resourceInputs["imageOptimizeMetadata"] = state ? state.imageOptimizeMetadata : undefined;
            resourceInputs["imageOptimizeProgressive"] = state ? state.imageOptimizeProgressive : undefined;
            resourceInputs["imageOptimizeWebp"] = state ? state.imageOptimizeWebp : undefined;
            resourceInputs["lastUpdated"] = state ? state.lastUpdated : undefined;
            resourceInputs["logFreq"] = state ? state.logFreq : undefined;
            resourceInputs["publicLog"] = state ? state.publicLog : undefined;
            resourceInputs["rateLimitIgnoreGoodBots"] = state ? state.rateLimitIgnoreGoodBots : undefined;
            resourceInputs["rateLimitIgnoreStaticContent"] = state ? state.rateLimitIgnoreStaticContent : undefined;
            resourceInputs["rateLimitStatus"] = state ? state.rateLimitStatus : undefined;
            resourceInputs["smartCacheStatus"] = state ? state.smartCacheStatus : undefined;
            resourceInputs["smartCacheTemplate"] = state ? state.smartCacheTemplate : undefined;
            resourceInputs["smartCacheTtl"] = state ? state.smartCacheTtl : undefined;
            resourceInputs["sslMode"] = state ? state.sslMode : undefined;
            resourceInputs["tls10"] = state ? state.tls10 : undefined;
            resourceInputs["tls11"] = state ? state.tls11 : undefined;
            resourceInputs["tls12"] = state ? state.tls12 : undefined;
            resourceInputs["wafLevel"] = state ? state.wafLevel : undefined;
            resourceInputs["wafMode"] = state ? state.wafMode : undefined;
            resourceInputs["wafStatus"] = state ? state.wafStatus : undefined;
        } else {
            const args = argsOrState as DomainArgs | undefined;
            if ((!args || args.domain === undefined) && !opts.urn) {
                throw new Error("Missing required property 'domain'");
            }
            resourceInputs["cache301"] = args ? args.cache301 : undefined;
            resourceInputs["cache302"] = args ? args.cache302 : undefined;
            resourceInputs["cache404"] = args ? args.cache404 : undefined;
            resourceInputs["cacheTtl"] = args ? args.cacheTtl : undefined;
            resourceInputs["cachingBehavior"] = args ? args.cachingBehavior : undefined;
            resourceInputs["deployMode"] = args ? args.deployMode : undefined;
            resourceInputs["dnsMode"] = args ? args.dnsMode : undefined;
            resourceInputs["domain"] = args ? args.domain : undefined;
            resourceInputs["expireBypassSec"] = args ? args.expireBypassSec : undefined;
            resourceInputs["expiresTtl"] = args ? args.expiresTtl : undefined;
            resourceInputs["gzipStatus"] = args ? args.gzipStatus : undefined;
            resourceInputs["headerDeviceType"] = args ? args.headerDeviceType : undefined;
            resourceInputs["headerGeoipContinent"] = args ? args.headerGeoipContinent : undefined;
            resourceInputs["headerGeoipCountry"] = args ? args.headerGeoipCountry : undefined;
            resourceInputs["headerGeoipOrg"] = args ? args.headerGeoipOrg : undefined;
            resourceInputs["ignoreCacheControl"] = args ? args.ignoreCacheControl : undefined;
            resourceInputs["ignoreExpires"] = args ? args.ignoreExpires : undefined;
            resourceInputs["ignoreVary"] = args ? args.ignoreVary : undefined;
            resourceInputs["imageOptimize"] = args ? args.imageOptimize : undefined;
            resourceInputs["imageOptimizeLevel"] = args ? args.imageOptimizeLevel : undefined;
            resourceInputs["imageOptimizeMetadata"] = args ? args.imageOptimizeMetadata : undefined;
            resourceInputs["imageOptimizeProgressive"] = args ? args.imageOptimizeProgressive : undefined;
            resourceInputs["imageOptimizeWebp"] = args ? args.imageOptimizeWebp : undefined;
            resourceInputs["lastUpdated"] = args ? args.lastUpdated : undefined;
            resourceInputs["logFreq"] = args ? args.logFreq : undefined;
            resourceInputs["publicLog"] = args ? args.publicLog : undefined;
            resourceInputs["rateLimitIgnoreGoodBots"] = args ? args.rateLimitIgnoreGoodBots : undefined;
            resourceInputs["rateLimitIgnoreStaticContent"] = args ? args.rateLimitIgnoreStaticContent : undefined;
            resourceInputs["rateLimitStatus"] = args ? args.rateLimitStatus : undefined;
            resourceInputs["smartCacheStatus"] = args ? args.smartCacheStatus : undefined;
            resourceInputs["smartCacheTemplate"] = args ? args.smartCacheTemplate : undefined;
            resourceInputs["smartCacheTtl"] = args ? args.smartCacheTtl : undefined;
            resourceInputs["sslMode"] = args ? args.sslMode : undefined;
            resourceInputs["tls10"] = args ? args.tls10 : undefined;
            resourceInputs["tls11"] = args ? args.tls11 : undefined;
            resourceInputs["tls12"] = args ? args.tls12 : undefined;
            resourceInputs["wafLevel"] = args ? args.wafLevel : undefined;
            resourceInputs["wafMode"] = args ? args.wafMode : undefined;
            resourceInputs["wafStatus"] = args ? args.wafStatus : undefined;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Domain.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Domain resources.
 */
export interface DomainState {
    cache301?: pulumi.Input<boolean>;
    cache302?: pulumi.Input<boolean>;
    cache404?: pulumi.Input<boolean>;
    cacheTtl?: pulumi.Input<number>;
    cachingBehavior?: pulumi.Input<string>;
    deployMode?: pulumi.Input<boolean>;
    dnsMode?: pulumi.Input<string>;
    domain?: pulumi.Input<string>;
    expireBypassSec?: pulumi.Input<number>;
    expiresTtl?: pulumi.Input<number>;
    gzipStatus?: pulumi.Input<boolean>;
    headerDeviceType?: pulumi.Input<boolean>;
    headerGeoipContinent?: pulumi.Input<boolean>;
    headerGeoipCountry?: pulumi.Input<boolean>;
    headerGeoipOrg?: pulumi.Input<boolean>;
    ignoreCacheControl?: pulumi.Input<boolean>;
    ignoreExpires?: pulumi.Input<boolean>;
    ignoreVary?: pulumi.Input<boolean>;
    imageOptimize?: pulumi.Input<boolean>;
    imageOptimizeLevel?: pulumi.Input<number>;
    imageOptimizeMetadata?: pulumi.Input<boolean>;
    imageOptimizeProgressive?: pulumi.Input<boolean>;
    imageOptimizeWebp?: pulumi.Input<boolean>;
    lastUpdated?: pulumi.Input<string>;
    logFreq?: pulumi.Input<number>;
    publicLog?: pulumi.Input<string>;
    rateLimitIgnoreGoodBots?: pulumi.Input<boolean>;
    rateLimitIgnoreStaticContent?: pulumi.Input<boolean>;
    rateLimitStatus?: pulumi.Input<boolean>;
    smartCacheStatus?: pulumi.Input<boolean>;
    smartCacheTemplate?: pulumi.Input<string>;
    smartCacheTtl?: pulumi.Input<number>;
    sslMode?: pulumi.Input<string>;
    tls10?: pulumi.Input<boolean>;
    tls11?: pulumi.Input<boolean>;
    tls12?: pulumi.Input<boolean>;
    wafLevel?: pulumi.Input<string>;
    wafMode?: pulumi.Input<string>;
    wafStatus?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Domain resource.
 */
export interface DomainArgs {
    cache301?: pulumi.Input<boolean>;
    cache302?: pulumi.Input<boolean>;
    cache404?: pulumi.Input<boolean>;
    cacheTtl?: pulumi.Input<number>;
    cachingBehavior?: pulumi.Input<string>;
    deployMode?: pulumi.Input<boolean>;
    dnsMode?: pulumi.Input<string>;
    domain: pulumi.Input<string>;
    expireBypassSec?: pulumi.Input<number>;
    expiresTtl?: pulumi.Input<number>;
    gzipStatus?: pulumi.Input<boolean>;
    headerDeviceType?: pulumi.Input<boolean>;
    headerGeoipContinent?: pulumi.Input<boolean>;
    headerGeoipCountry?: pulumi.Input<boolean>;
    headerGeoipOrg?: pulumi.Input<boolean>;
    ignoreCacheControl?: pulumi.Input<boolean>;
    ignoreExpires?: pulumi.Input<boolean>;
    ignoreVary?: pulumi.Input<boolean>;
    imageOptimize?: pulumi.Input<boolean>;
    imageOptimizeLevel?: pulumi.Input<number>;
    imageOptimizeMetadata?: pulumi.Input<boolean>;
    imageOptimizeProgressive?: pulumi.Input<boolean>;
    imageOptimizeWebp?: pulumi.Input<boolean>;
    lastUpdated?: pulumi.Input<string>;
    logFreq?: pulumi.Input<number>;
    publicLog?: pulumi.Input<string>;
    rateLimitIgnoreGoodBots?: pulumi.Input<boolean>;
    rateLimitIgnoreStaticContent?: pulumi.Input<boolean>;
    rateLimitStatus?: pulumi.Input<boolean>;
    smartCacheStatus?: pulumi.Input<boolean>;
    smartCacheTemplate?: pulumi.Input<string>;
    smartCacheTtl?: pulumi.Input<number>;
    sslMode?: pulumi.Input<string>;
    tls10?: pulumi.Input<boolean>;
    tls11?: pulumi.Input<boolean>;
    tls12?: pulumi.Input<boolean>;
    wafLevel?: pulumi.Input<string>;
    wafMode?: pulumi.Input<string>;
    wafStatus?: pulumi.Input<boolean>;
}
